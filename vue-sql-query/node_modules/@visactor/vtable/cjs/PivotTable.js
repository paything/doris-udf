"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    void 0 === k2 && (k2 = k);
    var desc = Object.getOwnPropertyDescriptor(m, k);
    desc && !("get" in desc ? !m.__esModule : desc.writable || desc.configurable) || (desc = {
        enumerable: !0,
        get: function() {
            return m[k];
        }
    }), Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), o[k2] = m[k];
}), __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: !0,
        value: v
    });
} : function(o, v) {
    o.default = v;
}), __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (null != mod) for (var k in mod) "default" !== k && Object.prototype.hasOwnProperty.call(mod, k) && __createBinding(result, mod, k);
    return __setModuleDefault(result, mod), result;
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.PivotTable = void 0;

const ts_types_1 = require("./ts-types"), pivot_header_layout_1 = require("./layout/pivot-header-layout"), flatDataToObject_1 = require("./dataset/flatDataToObject"), PIVOT_TABLE_EVENT_TYPE_1 = require("./ts-types/pivot-table/PIVOT_TABLE_EVENT_TYPE"), helper_1 = require("./tools/helper"), dataset_1 = require("./dataset/dataset"), BaseTable_1 = require("./core/BaseTable"), vutils_1 = require("@visactor/vutils"), env_1 = require("./tools/env"), tree_helper_1 = require("./layout/tree-helper"), TABLE_EVENT_TYPE_1 = require("./core/TABLE_EVENT_TYPE"), edit_manager_1 = require("./edit/edit-manager"), editors = __importStar(require("./edit/editors")), compute_col_width_1 = require("./scenegraph/layout/compute-col-width"), compute_row_height_1 = require("./scenegraph/layout/compute-row-height"), util_1 = require("./tools/util"), vutils_extension_1 = require("@visactor/vutils-extension"), layout_helper_1 = require("./layout/layout-helper"), factory_1 = require("./core/factory"), chart_render_helper_1 = require("./scenegraph/graphic/contributions/chart-render-helper");

class PivotTable extends BaseTable_1.BaseTable {
    constructor(container, options) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z;
        if (super(container, options), this.layoutNodeId = {
            seqId: 0
        }, options = this.options) {
            options.rowHierarchyType || (options.rowHierarchyType = "grid"), options.columnHierarchyType || (options.columnHierarchyType = "grid"), 
            options.layout && Object.assign(options, options.layout), this.internalProps.columns = (0, 
            vutils_1.cloneDeep)(options.columns), this.internalProps.rows = (0, vutils_1.cloneDeep)(options.rows), 
            this.internalProps.indicators = (0, vutils_extension_1.cloneDeepSpec)(options.indicators), 
            null === (_a = options.indicators) || void 0 === _a || _a.forEach(((indicatorDefine, index) => {
                "object" == typeof indicatorDefine && (null == indicatorDefine ? void 0 : indicatorDefine.editor) && (this.internalProps.indicators[index].editor = indicatorDefine.editor);
            })), this.internalProps.columnTree = !options.indicatorsAsCol || (null === (_b = options.columns) || void 0 === _b ? void 0 : _b.length) || options.columnTree ? (0, 
            vutils_1.cloneDeep)(options.columnTree) : [], this.internalProps.rowTree = options.indicatorsAsCol || (null === (_c = options.rows) || void 0 === _c ? void 0 : _c.length) || options.rowTree ? (0, 
            vutils_1.cloneDeep)(options.rowTree) : [], this.internalProps.records = options.records, 
            this.pagination = options.pagination, this.internalProps.columnResizeType = null !== (_f = null !== (_e = null === (_d = options.resize) || void 0 === _d ? void 0 : _d.columnResizeType) && void 0 !== _e ? _e : options.columnResizeType) && void 0 !== _f ? _f : "column", 
            this.internalProps.rowResizeType = null !== (_j = null !== (_h = null === (_g = options.resize) || void 0 === _g ? void 0 : _g.rowResizeType) && void 0 !== _h ? _h : options.rowResizeType) && void 0 !== _j ? _j : "row", 
            this.internalProps.dataConfig = (0, vutils_1.cloneDeep)(options.dataConfig), this.internalProps.columnWidthConfig = options.columnWidthConfig, 
            this.internalProps.columnWidthConfigForRowHeader = options.columnWidthConfigForRowHeader;
            const records = this.internalProps.records;
            if (this.internalProps.recordsIsTwoDimensionalArray = !1, (null === (_k = null == records ? void 0 : records[0]) || void 0 === _k ? void 0 : _k.constructor) === Array && (this.internalProps.recordsIsTwoDimensionalArray = !0), 
            !1 === (null === (_l = options.customConfig) || void 0 === _l ? void 0 : _l.enableDataAnalysis)) {
                const columnDimensionTree = new tree_helper_1.DimensionTree(null !== (_m = this.internalProps.columnTree) && void 0 !== _m ? _m : [], this.layoutNodeId, this.options.columnHierarchyType, "grid" !== this.options.columnHierarchyType ? null !== (_o = this.options.columnExpandLevel) && void 0 !== _o ? _o : 1 : void 0), rowDimensionTree = new tree_helper_1.DimensionTree(null !== (_p = this.internalProps.rowTree) && void 0 !== _p ? _p : [], this.layoutNodeId, this.options.rowHierarchyType, "grid" !== this.options.rowHierarchyType ? null !== (_q = this.options.rowExpandLevel) && void 0 !== _q ? _q : 1 : void 0);
                this.internalProps.layoutMap = new pivot_header_layout_1.PivotHeaderLayoutMap(this, null, columnDimensionTree, rowDimensionTree), 
                !1 === this.internalProps.recordsIsTwoDimensionalArray && (this.flatDataToObjects = new flatDataToObject_1.FlatDataToObjects({
                    rows: this.internalProps.layoutMap.fullRowDimensionKeys,
                    columns: this.internalProps.layoutMap.colDimensionKeys,
                    indicators: this.internalProps.layoutMap.indicatorKeys,
                    indicatorsAsCol: this.internalProps.layoutMap.indicatorsAsCol,
                    indicatorDimensionKey: this.internalProps.layoutMap.indicatorDimensionKey
                }, records));
            } else {
                const keysResults = (0, layout_helper_1.parseColKeyRowKeyForPivotTable)(this, options), {rowKeys: rowKeys, columnKeys: columnKeys, indicatorKeys: indicatorKeys} = keysResults;
                let {columnDimensionTree: columnDimensionTree, rowDimensionTree: rowDimensionTree} = keysResults;
                this.dataset = new dataset_1.Dataset(this.internalProps.dataConfig, rowKeys, columnKeys, indicatorKeys, this.internalProps.indicators, null === (_r = options.indicatorsAsCol) || void 0 === _r || _r, options.records, options.rowHierarchyType, options.columnHierarchyType, this.internalProps.columnTree, this.internalProps.rowTree, !1, !!options.extensionRows, !!options.parseCustomTreeToMatchRecords), 
                options.columnTree ? columnDimensionTree.hasHideNode && ((0, layout_helper_1.deleteHideIndicatorNode)(columnDimensionTree.tree.children, options.indicators, !0, this), 
                columnDimensionTree.reset(columnDimensionTree.tree.children)) : (!1 !== options.indicatorsAsCol && (this.dataset.colHeaderTree = (0, 
                layout_helper_1.supplementIndicatorNodesForCustomTree)(this.dataset.colHeaderTree, options.indicators)), 
                !1 !== options.indicatorsAsCol && options.indicators && this.dataset.colHeaderTree && (0, 
                layout_helper_1.deleteHideIndicatorNode)(this.dataset.colHeaderTree, options.indicators, !1, this), 
                columnDimensionTree = new tree_helper_1.DimensionTree(null !== (_s = this.dataset.colHeaderTree) && void 0 !== _s ? _s : [], this.layoutNodeId, this.options.columnHierarchyType, "grid" !== this.options.columnHierarchyType ? null !== (_t = this.options.columnExpandLevel) && void 0 !== _t ? _t : 1 : void 0)), 
                options.rowTree ? rowDimensionTree.hasHideNode && ((0, layout_helper_1.deleteHideIndicatorNode)(rowDimensionTree.tree.children, options.indicators, !0, this), 
                rowDimensionTree.reset(rowDimensionTree.tree.children)) : (!1 === options.indicatorsAsCol && (this.dataset.rowHeaderTree = (0, 
                layout_helper_1.supplementIndicatorNodesForCustomTree)(this.dataset.rowHeaderTree, options.indicators)), 
                !1 === options.indicatorsAsCol && this.dataset.rowHeaderTree && options.indicators && (0, 
                layout_helper_1.deleteHideIndicatorNode)(this.dataset.rowHeaderTree, options.indicators, !1, this), 
                rowDimensionTree = new tree_helper_1.DimensionTree(null !== (_u = this.dataset.rowHeaderTree) && void 0 !== _u ? _u : [], this.layoutNodeId, this.options.rowHierarchyType, "grid" !== this.options.rowHierarchyType ? null !== (_v = this.options.rowExpandLevel) && void 0 !== _v ? _v : 1 : void 0)), 
                this.internalProps.layoutMap = new pivot_header_layout_1.PivotHeaderLayoutMap(this, this.dataset, columnDimensionTree, rowDimensionTree);
            }
            if (this._changePivotSortStateBySortRules(), (null !== (_x = null === (_w = options.pivotSortState) || void 0 === _w ? void 0 : _w.length) && void 0 !== _x ? _x : 0) > 0 && (this.pivotSortState = [], 
            this.pivotSortState = options.pivotSortState), "node" !== env_1.Env.mode && (this.editorManager = new edit_manager_1.EditManager(this)), 
            this.refreshHeader(), this.internalProps.useOneRowHeightFillAll = !1, this.stateManager.initCheckedState(records), 
            this.scenegraph.createSceneGraph(), options.title) {
                const Title = factory_1.Factory.getComponent("title");
                this.internalProps.title = new Title(options.title, this), this.scenegraph.resize();
            }
            if (this.options.emptyTip) if (this.internalProps.emptyTip) null === (_y = this.internalProps.emptyTip) || void 0 === _y || _y.resetVisible(); else {
                const EmptyTip = factory_1.Factory.getComponent("emptyTip");
                this.internalProps.emptyTip = new EmptyTip(this.options.emptyTip, this), null === (_z = this.internalProps.emptyTip) || void 0 === _z || _z.resetVisible();
            }
            setTimeout((() => {
                this.fireListeners(TABLE_EVENT_TYPE_1.TABLE_EVENT_TYPE.INITIALIZED, null);
            }), 0);
        }
    }
    static get EVENT_TYPE() {
        return PIVOT_TABLE_EVENT_TYPE_1.PIVOT_TABLE_EVENT_TYPE;
    }
    isListTable() {
        return !1;
    }
    isPivotTable() {
        return !0;
    }
    isPivotChart() {
        return !1;
    }
    get recordsCount() {
        var _a;
        return null === (_a = this.records) || void 0 === _a ? void 0 : _a.length;
    }
    _canResizeColumn(col, row) {
        const ifCan = super._canResizeColumn(col, row);
        if (ifCan) {
            if (this.internalProps.layoutMap.isSeriesNumber(col, row) && !0 === this.internalProps.rowSeriesNumber.disableColumnResize) return !1;
            if (!this.internalProps.layoutMap.indicatorsAsCol) {
                const cellDefine = this.internalProps.layoutMap.getBody(col, this.columnHeaderLevelCount);
                if (null == cellDefine ? void 0 : cellDefine.disableColumnResize) return !1;
            }
        }
        return ifCan;
    }
    updateOption(options) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1;
        const internalProps = this.internalProps;
        if (super.updateOption(options), options.rowHierarchyType || (options.rowHierarchyType = "grid"), 
        options.columnHierarchyType || (options.columnHierarchyType = "grid"), this.layoutNodeId = {
            seqId: 0
        }, this.internalProps.columns = (0, vutils_1.cloneDeep)(options.columns), this.internalProps.rows = (0, 
        vutils_1.cloneDeep)(options.rows), this.internalProps.indicators = (null === (_a = options.indicators) || void 0 === _a ? void 0 : _a.length) ? (0, 
        vutils_extension_1.cloneDeepSpec)(options.indicators) : [], null === (_b = options.indicators) || void 0 === _b || _b.forEach(((indicatorDefine, index) => {
            "object" == typeof indicatorDefine && (null == indicatorDefine ? void 0 : indicatorDefine.editor) && (this.internalProps.indicators[index].editor = indicatorDefine.editor);
        })), this.internalProps.columnTree = !options.indicatorsAsCol || (null === (_c = options.columns) || void 0 === _c ? void 0 : _c.length) || options.columnTree ? (0, 
        vutils_1.cloneDeep)(options.columnTree) : [], this.internalProps.rowTree = options.indicatorsAsCol || (null === (_d = options.rows) || void 0 === _d ? void 0 : _d.length) || options.rowTree ? (0, 
        vutils_1.cloneDeep)(options.rowTree) : [], options.records && (this.internalProps.records = options.records), 
        this.stateManager.initCheckedState(this.internalProps.records), this.stateManager.updateDrillState(void 0, void 0, !1, !1, -1, -1), 
        this.pagination = options.pagination, internalProps.columnResizeType = null !== (_g = null !== (_f = null === (_e = options.resize) || void 0 === _e ? void 0 : _e.columnResizeType) && void 0 !== _f ? _f : options.columnResizeType) && void 0 !== _g ? _g : "column", 
        internalProps.rowResizeType = null !== (_k = null !== (_j = null === (_h = options.resize) || void 0 === _h ? void 0 : _h.rowResizeType) && void 0 !== _j ? _j : options.rowResizeType) && void 0 !== _k ? _k : "row", 
        internalProps.dataConfig = (0, vutils_1.cloneDeep)(options.dataConfig), this.internalProps.columnWidthConfig = options.columnWidthConfig, 
        this.internalProps.columnWidthConfigForRowHeader = options.columnWidthConfigForRowHeader, 
        "grid" !== (null == options ? void 0 : options.rowHierarchyType) && "grid" !== this.internalProps.layoutMap.rowHierarchyType && this.internalProps.layoutMap.rowExpandLevel === (null == options ? void 0 : options.rowExpandLevel)) {
            const beforeRowDimensions = this.internalProps.layoutMap.rowDimensionTree.tree.children;
            null === (_l = this.internalProps.rowTree) || void 0 === _l || _l.forEach(((node, index) => {
                const beforeRowDimension = beforeRowDimensions.find((item => item.dimensionKey === node.dimensionKey && item.value === node.value));
                beforeRowDimension && this._syncHierarchyState(beforeRowDimension, node);
            }));
        }
        const records = this.internalProps.records;
        if (this.internalProps.recordsIsTwoDimensionalArray = !1, (null === (_m = null == records ? void 0 : records[0]) || void 0 === _m ? void 0 : _m.constructor) === Array && (this.internalProps.recordsIsTwoDimensionalArray = !0), 
        !1 === (null === (_o = options.customConfig) || void 0 === _o ? void 0 : _o.enableDataAnalysis)) {
            let columnDimensionTree, rowDimensionTree;
            options.columnTree && (columnDimensionTree = new tree_helper_1.DimensionTree(null !== (_p = this.internalProps.columnTree) && void 0 !== _p ? _p : [], this.layoutNodeId, this.options.columnHierarchyType, "grid" !== this.options.columnHierarchyType ? null !== (_q = this.options.columnExpandLevel) && void 0 !== _q ? _q : 1 : void 0)), 
            options.rowTree && (rowDimensionTree = new tree_helper_1.DimensionTree(null !== (_r = this.internalProps.rowTree) && void 0 !== _r ? _r : [], this.layoutNodeId, this.options.rowHierarchyType, "grid" !== this.options.rowHierarchyType ? null !== (_s = this.options.rowExpandLevel) && void 0 !== _s ? _s : 1 : void 0)), 
            internalProps.layoutMap.clearHeaderPathCache(), internalProps.layoutMap = new pivot_header_layout_1.PivotHeaderLayoutMap(this, null, columnDimensionTree, rowDimensionTree), 
            !1 === this.internalProps.recordsIsTwoDimensionalArray && (this.flatDataToObjects = new flatDataToObject_1.FlatDataToObjects({
                rows: internalProps.layoutMap.fullRowDimensionKeys,
                columns: internalProps.layoutMap.colDimensionKeys,
                indicators: internalProps.layoutMap.indicatorKeys,
                indicatorsAsCol: internalProps.layoutMap.indicatorsAsCol,
                indicatorDimensionKey: internalProps.layoutMap.indicatorDimensionKey
            }, records));
        } else {
            const keysResults = (0, layout_helper_1.parseColKeyRowKeyForPivotTable)(this, options), {rowKeys: rowKeys, columnKeys: columnKeys, indicatorKeys: indicatorKeys} = keysResults;
            let {columnDimensionTree: columnDimensionTree, rowDimensionTree: rowDimensionTree} = keysResults;
            this.dataset = new dataset_1.Dataset(internalProps.dataConfig, rowKeys, columnKeys, indicatorKeys, this.internalProps.indicators, null === (_t = options.indicatorsAsCol) || void 0 === _t || _t, records, options.rowHierarchyType, options.columnHierarchyType, this.internalProps.columnTree, this.internalProps.rowTree, !1, !!options.extensionRows, !!options.parseCustomTreeToMatchRecords), 
            options.columnTree ? columnDimensionTree.hasHideNode && ((0, layout_helper_1.deleteHideIndicatorNode)(columnDimensionTree.tree.children, options.indicators, !0, this), 
            columnDimensionTree.reset(columnDimensionTree.tree.children)) : (!1 !== options.indicatorsAsCol && (this.dataset.colHeaderTree = (0, 
            layout_helper_1.supplementIndicatorNodesForCustomTree)(this.dataset.colHeaderTree, options.indicators)), 
            !1 !== options.indicatorsAsCol && options.indicators && this.dataset.colHeaderTree && (0, 
            layout_helper_1.deleteHideIndicatorNode)(this.dataset.colHeaderTree, options.indicators, !1, this), 
            columnDimensionTree = new tree_helper_1.DimensionTree(null !== (_u = this.dataset.colHeaderTree) && void 0 !== _u ? _u : [], this.layoutNodeId, this.options.columnHierarchyType, "grid" !== this.options.columnHierarchyType ? null !== (_v = this.options.columnExpandLevel) && void 0 !== _v ? _v : 1 : void 0)), 
            options.rowTree ? rowDimensionTree.hasHideNode && ((0, layout_helper_1.deleteHideIndicatorNode)(rowDimensionTree.tree.children, options.indicators, !0, this), 
            rowDimensionTree.reset(rowDimensionTree.tree.children)) : (!1 === options.indicatorsAsCol && (this.dataset.rowHeaderTree = (0, 
            layout_helper_1.supplementIndicatorNodesForCustomTree)(this.dataset.rowHeaderTree, options.indicators)), 
            !1 === options.indicatorsAsCol && this.dataset.rowHeaderTree && options.indicators && (0, 
            layout_helper_1.deleteHideIndicatorNode)(this.dataset.rowHeaderTree, options.indicators, !1, this), 
            rowDimensionTree = new tree_helper_1.DimensionTree(null !== (_w = this.dataset.rowHeaderTree) && void 0 !== _w ? _w : [], this.layoutNodeId, this.options.rowHierarchyType, "grid" !== this.options.rowHierarchyType ? null !== (_x = this.options.rowExpandLevel) && void 0 !== _x ? _x : 1 : void 0)), 
            internalProps.layoutMap = new pivot_header_layout_1.PivotHeaderLayoutMap(this, this.dataset, columnDimensionTree, rowDimensionTree);
        }
        if (this._changePivotSortStateBySortRules(), (null !== (_z = null === (_y = options.pivotSortState) || void 0 === _y ? void 0 : _y.length) && void 0 !== _z ? _z : 0) > 0 && (this.pivotSortState = [], 
        this.pivotSortState = options.pivotSortState), this.refreshHeader(), this.internalProps.useOneRowHeightFillAll = !1, 
        internalProps.releaseList && (internalProps.releaseList.forEach((releaseObj => {
            var _a;
            return null === (_a = null == releaseObj ? void 0 : releaseObj.release) || void 0 === _a ? void 0 : _a.call(releaseObj);
        })), internalProps.releaseList = null), this.scenegraph.clearCells(), this.scenegraph.createSceneGraph(), 
        options.title) {
            const Title = factory_1.Factory.getComponent("title");
            this.internalProps.title = new Title(options.title, this), this.scenegraph.resize();
        }
        if (this.options.emptyTip) if (this.internalProps.emptyTip) null === (_0 = this.internalProps.emptyTip) || void 0 === _0 || _0.resetVisible(); else {
            const EmptyTip = factory_1.Factory.getComponent("emptyTip");
            this.internalProps.emptyTip = new EmptyTip(this.options.emptyTip, this), null === (_1 = this.internalProps.emptyTip) || void 0 === _1 || _1.resetVisible();
        }
        return new Promise((resolve => {
            setTimeout(resolve, 0);
        }));
    }
    updatePagination(pagination) {
        this.internalProps.layoutMap.clearHeaderPathCache(), pagination ? (this.pagination || (this.pagination = {
            currentPage: 0,
            perPageCount: 0
        }), "number" == typeof pagination.currentPage && pagination.currentPage >= 0 && (this.pagination.currentPage = pagination.currentPage), 
        pagination.perPageCount && (this.pagination.perPageCount = pagination.perPageCount || this.pagination.perPageCount), 
        this.scenegraph.clearCells(), this.internalProps.layoutMap.setPagination(this.pagination), 
        this.refreshRowColCount(), this.scenegraph.createSceneGraph(), this.render()) : this.pagination && (this.pagination = void 0, 
        this.scenegraph.clearCells(), this.internalProps.layoutMap.setPagination(void 0), 
        this.refreshRowColCount(), this.scenegraph.createSceneGraph(), this.render());
    }
    refreshHeader() {
        this.setMinMaxLimitWidth(!0), this.refreshRowColCount();
    }
    refreshRowColCount() {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const table = this, {layoutMap: layoutMap} = table.internalProps;
        layoutMap && (table.colCount = null !== (_a = layoutMap.colCount) && void 0 !== _a ? _a : 0, 
        table.rowCount = null !== (_b = layoutMap.rowCount) && void 0 !== _b ? _b : 0, this.internalProps.frozenColCount = this.options.frozenColCount ? this.options.frozenColCount : (null !== (_c = layoutMap.rowHeaderLevelCount) && void 0 !== _c ? _c : 0) + layoutMap.leftRowSeriesNumberColumnCount, 
        table.frozenRowCount = Math.max(layoutMap.headerLevelCount, null !== (_d = this.options.frozenRowCount) && void 0 !== _d ? _d : 0), 
        table.bottomFrozenRowCount !== (null !== (_e = this.options.bottomFrozenRowCount) && void 0 !== _e ? _e : 0) && (table.bottomFrozenRowCount = null !== (_f = this.options.bottomFrozenRowCount) && void 0 !== _f ? _f : 0), 
        table.rightFrozenColCount !== (null !== (_g = this.options.rightFrozenColCount) && void 0 !== _g ? _g : 0) && (table.rightFrozenColCount = null !== (_h = this.options.rightFrozenColCount) && void 0 !== _h ? _h : 0), 
        this.stateManager.setFrozenCol(this.internalProps.frozenColCount), this.stateManager.setFrozenRow(this.frozenRowCount));
    }
    _getSortFuncFromHeaderOption(columns, field, fieldKey) {}
    get rowHierarchyType() {
        return this.internalProps.layoutMap.rowHierarchyType;
    }
    get columnHierarchyType() {
        return this.internalProps.layoutMap.columnHierarchyType;
    }
    _syncHierarchyState(sourceNode, targetNode) {
        var _a, _b;
        sourceNode.value === targetNode.value && sourceNode.dimensionKey === targetNode.dimensionKey && (targetNode.hierarchyState = null !== (_a = targetNode.hierarchyState) && void 0 !== _a ? _a : (null == targetNode ? void 0 : targetNode.children) ? sourceNode.hierarchyState : void 0, 
        null === (_b = null == targetNode ? void 0 : targetNode.children) || void 0 === _b || _b.forEach(((targetChildNode, index) => {
            var _a;
            if ((null === (_a = null == sourceNode ? void 0 : sourceNode.children) || void 0 === _a ? void 0 : _a[index]) && targetChildNode) {
                const beforeRowDimension = sourceNode.children.find((item => item.dimensionKey === targetChildNode.dimensionKey && item.value === targetChildNode.value));
                beforeRowDimension && this._syncHierarchyState(beforeRowDimension, targetChildNode);
            }
        })));
    }
    getRecordShowIndexByCell(col, row) {}
    getTableIndexByRecordIndex(recordIndex) {}
    getTableIndexByField(field) {}
    getCellAddrByFieldRecord(field, recordIndex) {}
    getBodyIndexByRow(row) {
        const {layoutMap: layoutMap} = this.internalProps;
        return layoutMap.getBodyIndexByRow(row);
    }
    getBodyIndexByCol(col) {
        const {layoutMap: layoutMap} = this.internalProps;
        return layoutMap.getBodyIndexByCol(col);
    }
    getFieldData(field, col, row) {
        var _a, _b, _c;
        if (!this.internalProps.layoutMap.isHeader(col, row)) {
            if (this.internalProps.recordsIsTwoDimensionalArray) {
                const rowIndex = this.getBodyIndexByRow(row), colIndex = this.getBodyIndexByCol(col);
                return null === (_a = this.records[rowIndex]) || void 0 === _a ? void 0 : _a[colIndex];
            }
            if (this.dataset) {
                const cellDimensionPath = this.internalProps.layoutMap.getCellHeaderPaths(col, row);
                if (cellDimensionPath) {
                    let indicatorPosition;
                    const colKeys = null === (_b = cellDimensionPath.colHeaderPaths) || void 0 === _b ? void 0 : _b.filter((path => !path.virtual)).map(((colPath, index) => {
                        var _a;
                        return colPath.indicatorKey && (indicatorPosition = {
                            position: "col",
                            index: index
                        }), null !== (_a = colPath.indicatorKey) && void 0 !== _a ? _a : colPath.value;
                    })), rowKeys = null === (_c = cellDimensionPath.rowHeaderPaths) || void 0 === _c ? void 0 : _c.filter((path => !path.virtual)).map(((rowPath, index) => {
                        var _a;
                        return rowPath.indicatorKey && (indicatorPosition = {
                            position: "row",
                            index: index
                        }), null !== (_a = rowPath.indicatorKey) && void 0 !== _a ? _a : rowPath.value;
                    })), aggregator = this.dataset.getAggregator(rowKeys, colKeys, this.internalProps.layoutMap.getIndicatorKey(col, row), !0, indicatorPosition);
                    if (aggregator.records && aggregator.records.length >= 1) return aggregator.records[0][field];
                }
            } else if (this.flatDataToObjects) {
                const cellDimensionPath = this.internalProps.layoutMap.getCellHeaderPaths(col, row), colKeys = cellDimensionPath.colHeaderPaths.map((colPath => {
                    var _a;
                    return null !== (_a = colPath.indicatorKey) && void 0 !== _a ? _a : colPath.value;
                })), rowKeys = cellDimensionPath.rowHeaderPaths.map((rowPath => {
                    var _a;
                    return null !== (_a = rowPath.indicatorKey) && void 0 !== _a ? _a : rowPath.value;
                })), treeNode = this.flatDataToObjects.getTreeNode(rowKeys, colKeys, this.internalProps.layoutMap.getBody(col, row).indicatorKey, !1);
                if (null == treeNode ? void 0 : treeNode.record) return null == treeNode ? void 0 : treeNode.record[field];
            }
        }
    }
    getCellValue(col, row, skipCustomMerge) {
        var _a, _b, _c, _d, _e, _f, _g;
        if (!skipCustomMerge) {
            const customMergeText = this.getCustomMergeValue(col, row);
            if (customMergeText) return customMergeText;
        }
        if (this.internalProps.layoutMap.isSeriesNumber(col, row)) {
            if (this.internalProps.layoutMap.isSeriesNumberInHeader(col, row)) {
                const {title: title} = this.internalProps.layoutMap.getSeriesNumberHeader(col, row);
                return title;
            }
            const {format: format} = this.internalProps.layoutMap.getSeriesNumberBody(col, row);
            return "function" == typeof format ? format(col, row, this) : row - this.columnHeaderLevelCount + 1;
        }
        if (this.internalProps.layoutMap.isHeader(col, row)) {
            const {title: title, fieldFormat: fieldFormat} = this.internalProps.layoutMap.getHeader(col, row);
            return "function" == typeof fieldFormat ? fieldFormat(title, col, row, this) : title;
        }
        if (this.internalProps.recordsIsTwoDimensionalArray) {
            const {fieldFormat: fieldFormat} = this.internalProps.layoutMap.getBody(col, row), rowIndex = this.getBodyIndexByRow(row), colIndex = this.getBodyIndexByCol(col), dataValue = null === (_a = this.records[rowIndex]) || void 0 === _a ? void 0 : _a[colIndex];
            if ("function" == typeof fieldFormat) {
                return fieldFormat(dataValue, col, row, this);
            }
            return dataValue;
        }
        if (this.dataset) {
            const cellDimensionPath = this.internalProps.layoutMap.getCellHeaderPaths(col, row);
            let indicatorPosition;
            const colKeys = null === (_c = null === (_b = cellDimensionPath.colHeaderPaths) || void 0 === _b ? void 0 : _b.filter((path => !path.virtual))) || void 0 === _c ? void 0 : _c.map(((colPath, index) => {
                var _a;
                return colPath.indicatorKey && (indicatorPosition = {
                    position: "col",
                    index: index
                }), null !== (_a = colPath.indicatorKey) && void 0 !== _a ? _a : colPath.value;
            })), rowKeys = null === (_e = null === (_d = cellDimensionPath.rowHeaderPaths) || void 0 === _d ? void 0 : _d.filter((path => !path.virtual))) || void 0 === _e ? void 0 : _e.map(((rowPath, index) => {
                var _a;
                return rowPath.indicatorKey && (indicatorPosition = {
                    position: "row",
                    index: index
                }), null !== (_a = rowPath.indicatorKey) && void 0 !== _a ? _a : rowPath.value;
            })), aggregator = this.dataset.getAggregator(rowKeys, colKeys, this.internalProps.layoutMap.getIndicatorKey(col, row), !0, indicatorPosition), {fieldFormat: fieldFormat} = this.internalProps.layoutMap.getBody(col, row);
            return aggregator.formatValue ? aggregator.formatValue(col, row, this) : "function" == typeof fieldFormat ? fieldFormat(null == aggregator ? void 0 : aggregator.value(), col, row, this) : null !== (_f = null == aggregator ? void 0 : aggregator.value()) && void 0 !== _f ? _f : "";
        }
        if (this.flatDataToObjects) {
            const cellDimensionPath = this.internalProps.layoutMap.getCellHeaderPaths(col, row), colKeys = cellDimensionPath.colHeaderPaths.map((colPath => {
                var _a;
                return null !== (_a = colPath.indicatorKey) && void 0 !== _a ? _a : colPath.value;
            })), rowKeys = cellDimensionPath.rowHeaderPaths.map((rowPath => {
                var _a;
                return null !== (_a = rowPath.indicatorKey) && void 0 !== _a ? _a : rowPath.value;
            })), valueNode = this.flatDataToObjects.getTreeNode(rowKeys, colKeys, this.internalProps.layoutMap.getBody(col, row).indicatorKey), {fieldFormat: fieldFormat} = this.internalProps.layoutMap.getBody(col, row);
            return "function" == typeof fieldFormat ? fieldFormat(null == valueNode ? void 0 : valueNode.value, col, row, this) : null !== (_g = null == valueNode ? void 0 : valueNode.value) && void 0 !== _g ? _g : "";
        }
    }
    getCellOriginValue(col, row) {
        var _a, _b, _c;
        const table = this;
        if (table.internalProps.layoutMap.isHeader(col, row)) {
            const {title: title} = table.internalProps.layoutMap.getHeader(col, row);
            return "function" == typeof title ? title() : title;
        }
        if (this.internalProps.recordsIsTwoDimensionalArray) {
            const rowIndex = this.getBodyIndexByRow(row), colIndex = this.getBodyIndexByCol(col);
            return null === (_a = this.records[rowIndex]) || void 0 === _a ? void 0 : _a[colIndex];
        }
        if (this.dataset) {
            let indicatorPosition;
            const cellDimensionPath = this.internalProps.layoutMap.getCellHeaderPaths(col, row), colKeys = null === (_b = cellDimensionPath.colHeaderPaths) || void 0 === _b ? void 0 : _b.filter((path => !path.virtual)).map(((colPath, index) => {
                var _a;
                return colPath.indicatorKey && (indicatorPosition = {
                    position: "col",
                    index: index
                }), null !== (_a = colPath.indicatorKey) && void 0 !== _a ? _a : colPath.value;
            })), rowKeys = null === (_c = cellDimensionPath.rowHeaderPaths) || void 0 === _c ? void 0 : _c.filter((path => !path.virtual)).map(((rowPath, index) => {
                var _a;
                return rowPath.indicatorKey && (indicatorPosition = {
                    position: "row",
                    index: index
                }), null !== (_a = rowPath.indicatorKey) && void 0 !== _a ? _a : rowPath.value;
            })), aggregator = this.dataset.getAggregator(rowKeys, colKeys, this.internalProps.layoutMap.getIndicatorKey(col, row), !0, indicatorPosition);
            return aggregator.value ? aggregator.value() : void 0;
        }
        if (this.flatDataToObjects) {
            const cellDimensionPath = this.internalProps.layoutMap.getCellHeaderPaths(col, row), colKeys = cellDimensionPath.colHeaderPaths.map((colPath => {
                var _a;
                return null !== (_a = colPath.indicatorKey) && void 0 !== _a ? _a : colPath.value;
            })), rowKeys = cellDimensionPath.rowHeaderPaths.map((rowPath => {
                var _a;
                return null !== (_a = rowPath.indicatorKey) && void 0 !== _a ? _a : rowPath.value;
            })), treeNode = this.flatDataToObjects.getTreeNode(rowKeys, colKeys, this.internalProps.layoutMap.getBody(col, row).indicatorKey);
            return null == treeNode ? void 0 : treeNode.value;
        }
    }
    getCellRawValue(col, row) {
        var _a, _b, _c;
        const table = this;
        if (table.internalProps.layoutMap.isHeader(col, row)) {
            const {title: title} = table.internalProps.layoutMap.getHeader(col, row);
            return "function" == typeof title ? title() : title;
        }
        if (this.internalProps.recordsIsTwoDimensionalArray) {
            const rowIndex = this.getBodyIndexByRow(row), colIndex = this.getBodyIndexByCol(col);
            return null === (_a = this.records[rowIndex]) || void 0 === _a ? void 0 : _a[colIndex];
        }
        if (this.dataset) {
            let indicatorPosition;
            const cellDimensionPath = this.internalProps.layoutMap.getCellHeaderPaths(col, row), colKeys = null === (_b = cellDimensionPath.colHeaderPaths) || void 0 === _b ? void 0 : _b.filter((path => !path.virtual)).map(((colPath, index) => {
                var _a;
                return colPath.indicatorKey && (indicatorPosition = {
                    position: "col",
                    index: index
                }), null !== (_a = colPath.indicatorKey) && void 0 !== _a ? _a : colPath.value;
            })), rowKeys = null === (_c = cellDimensionPath.rowHeaderPaths) || void 0 === _c ? void 0 : _c.filter((path => !path.virtual)).map(((rowPath, index) => {
                var _a;
                return rowPath.indicatorKey && (indicatorPosition = {
                    position: "row",
                    index: index
                }), null !== (_a = rowPath.indicatorKey) && void 0 !== _a ? _a : rowPath.value;
            })), aggregator = this.dataset.getAggregator(rowKeys, colKeys, this.internalProps.layoutMap.getIndicatorKey(col, row), !1, indicatorPosition);
            return aggregator.value ? aggregator.value() : void 0;
        }
        if (this.flatDataToObjects) {
            const cellDimensionPath = this.internalProps.layoutMap.getCellHeaderPaths(col, row), colKeys = cellDimensionPath.colHeaderPaths.map((colPath => {
                var _a;
                return null !== (_a = colPath.indicatorKey) && void 0 !== _a ? _a : colPath.value;
            })), rowKeys = cellDimensionPath.rowHeaderPaths.map((rowPath => {
                var _a;
                return null !== (_a = rowPath.indicatorKey) && void 0 !== _a ? _a : rowPath.value;
            })), treeNode = this.flatDataToObjects.getTreeNode(rowKeys, colKeys, this.internalProps.layoutMap.getBody(col, row).indicatorKey, !1);
            return null == treeNode ? void 0 : treeNode.value;
        }
    }
    getCellOriginRecord(col, row) {
        var _a, _b, _c;
        if (!this.internalProps.layoutMap.isHeader(col, row)) {
            if (this.internalProps.recordsIsTwoDimensionalArray) {
                const rowIndex = this.getBodyIndexByRow(row), colIndex = this.getBodyIndexByCol(col);
                return null === (_a = this.records[rowIndex]) || void 0 === _a ? void 0 : _a[colIndex];
            }
            if (this.dataset) {
                let indicatorPosition;
                const cellDimensionPath = this.internalProps.layoutMap.getCellHeaderPaths(col, row), colKeys = null === (_b = cellDimensionPath.colHeaderPaths) || void 0 === _b ? void 0 : _b.filter((path => !path.virtual)).map(((colPath, index) => {
                    var _a;
                    return colPath.indicatorKey && (indicatorPosition = {
                        position: "col",
                        index: index
                    }), null !== (_a = colPath.indicatorKey) && void 0 !== _a ? _a : colPath.value;
                })), rowKeys = null === (_c = cellDimensionPath.rowHeaderPaths) || void 0 === _c ? void 0 : _c.filter((path => !path.virtual)).map(((rowPath, index) => {
                    var _a;
                    return rowPath.indicatorKey && (indicatorPosition = {
                        position: "row",
                        index: index
                    }), null !== (_a = rowPath.indicatorKey) && void 0 !== _a ? _a : rowPath.value;
                }));
                return this.dataset.getAggregator(rowKeys, colKeys, this.internalProps.layoutMap.getIndicatorKey(col, row), !0, indicatorPosition).records;
            }
            if (this.flatDataToObjects) {
                const cellDimensionPath = this.internalProps.layoutMap.getCellHeaderPaths(col, row), colKeys = cellDimensionPath.colHeaderPaths.map((colPath => {
                    var _a;
                    return null !== (_a = colPath.indicatorKey) && void 0 !== _a ? _a : colPath.value;
                })), rowKeys = cellDimensionPath.rowHeaderPaths.map((rowPath => {
                    var _a;
                    return null !== (_a = rowPath.indicatorKey) && void 0 !== _a ? _a : rowPath.value;
                })), treeNode = this.flatDataToObjects.getTreeNode(rowKeys, colKeys, this.internalProps.layoutMap.getBody(col, row).indicatorKey);
                return null == treeNode ? void 0 : treeNode.record;
            }
        }
    }
    getCellRawRecord(col, row) {
        var _a, _b, _c;
        if (!this.internalProps.layoutMap.isHeader(col, row)) {
            if (this.internalProps.recordsIsTwoDimensionalArray) {
                const rowIndex = this.getBodyIndexByRow(row), colIndex = this.getBodyIndexByCol(col);
                return null === (_a = this.records[rowIndex]) || void 0 === _a ? void 0 : _a[colIndex];
            }
            if (this.dataset) {
                let indicatorPosition;
                const cellDimensionPath = this.internalProps.layoutMap.getCellHeaderPaths(col, row), colKeys = null === (_b = cellDimensionPath.colHeaderPaths) || void 0 === _b ? void 0 : _b.filter((path => !path.virtual)).map(((colPath, index) => {
                    var _a;
                    return colPath.indicatorKey && (indicatorPosition = {
                        position: "col",
                        index: index
                    }), null !== (_a = colPath.indicatorKey) && void 0 !== _a ? _a : colPath.value;
                })), rowKeys = null === (_c = cellDimensionPath.rowHeaderPaths) || void 0 === _c ? void 0 : _c.filter((path => !path.virtual)).map(((rowPath, index) => {
                    var _a;
                    return rowPath.indicatorKey && (indicatorPosition = {
                        position: "row",
                        index: index
                    }), null !== (_a = rowPath.indicatorKey) && void 0 !== _a ? _a : rowPath.value;
                }));
                return this.dataset.getAggregator(rowKeys, colKeys, this.internalProps.layoutMap.getIndicatorKey(col, row), !1, indicatorPosition).records;
            }
            if (this.flatDataToObjects) {
                const cellDimensionPath = this.internalProps.layoutMap.getCellHeaderPaths(col, row), colKeys = cellDimensionPath.colHeaderPaths.map((colPath => {
                    var _a;
                    return null !== (_a = colPath.indicatorKey) && void 0 !== _a ? _a : colPath.value;
                })), rowKeys = cellDimensionPath.rowHeaderPaths.map((rowPath => {
                    var _a;
                    return null !== (_a = rowPath.indicatorKey) && void 0 !== _a ? _a : rowPath.value;
                })), treeNode = this.flatDataToObjects.getTreeNode(rowKeys, colKeys, this.internalProps.layoutMap.getBody(col, row).indicatorKey, !1);
                return null == treeNode ? void 0 : treeNode.record;
            }
        }
    }
    updateSortRules(sortRules, col, row) {
        this.internalProps.dataConfig ? this.internalProps.dataConfig.sortRules = sortRules : this.internalProps.dataConfig = {
            sortRules: sortRules
        }, this.dataset.updateSortRules(sortRules), this._changePivotSortStateBySortRules();
        const {layoutMap: layoutMap} = this.internalProps;
        layoutMap.resetHeaderTree(), this.scenegraph.clearCells(), (0, vutils_1.isNumber)(col) && (0, 
        vutils_1.isNumber)(row) ? (this.isRowHeader(col, row) ? (this.setMinMaxLimitWidth(!0), 
        this.internalProps._widthResizedColMap.clear()) : this.isCornerHeader(col, row) ? "column" === layoutMap.cornerSetting.titleOnDimension ? (this.setMinMaxLimitWidth(!0), 
        this.internalProps._widthResizedColMap.clear()) : "row" === layoutMap.cornerSetting.titleOnDimension && this.internalProps._heightResizedRowMap.clear() : this.isColumnHeader(col, row) && this.internalProps._heightResizedRowMap.clear(), 
        this.refreshRowColCount()) : this.refreshHeader(), this.internalProps.useOneRowHeightFillAll = !1, 
        this.scenegraph.createSceneGraph(!0), this.render();
    }
    _changePivotSortStateBySortRules() {
        var _a, _b, _c, _d;
        this.pivotSortState = [];
        const sortRules = null !== (_b = null === (_a = this.internalProps.dataConfig) || void 0 === _a ? void 0 : _a.sortRules) && void 0 !== _b ? _b : [];
        for (let i = 0; i < sortRules.length; i++) {
            const sortRule = sortRules[i], dimensions = [];
            if (sortRule.sortByIndicator && sortRule.sortField === (this.dataset.indicatorsAsCol ? this.dataset.rows[this.dataset.rows.length - 1] : this.dataset.columns[this.dataset.columns.length - 1])) {
                for (let j = 0; j < sortRule.query.length; j++) dimensions.push({
                    dimensionKey: this.dataset.indicatorsAsCol ? this.dataset.columns[j] : this.dataset.rows[j],
                    value: sortRule.query[j]
                });
                dimensions.push({
                    indicatorKey: sortRule.sortByIndicator,
                    value: null !== (_d = null === (_c = this.internalProps.layoutMap.getIndicatorInfo(sortRule.sortByIndicator)) || void 0 === _c ? void 0 : _c.title) && void 0 !== _d ? _d : sortRule.sortByIndicator
                });
            } else dimensions.push({
                dimensionKey: sortRule.sortField,
                isPivotCorner: !0,
                value: sortRule.sortField
            });
            const sortType = sortRule.sortType ? sortRule.sortType.toUpperCase() : "ASC";
            this.pivotSortState.push({
                dimensions: dimensions,
                order: ts_types_1.SortType[sortType]
            });
        }
    }
    _parseColumnWidthConfig(columnWidthConfig) {
        for (let i = 0; i < (null == columnWidthConfig ? void 0 : columnWidthConfig.length); i++) {
            const item = columnWidthConfig[i], dimensions = item.dimensions, width = item.width, cell = this.getCellAddressByHeaderPaths(dimensions);
            if (cell && cell.col >= this.rowHeaderLevelCount) {
                const cellPath = this.getCellHeaderPaths(cell.col, this.columnHeaderLevelCount);
                if (cellPath.colHeaderPaths.length === dimensions.length) {
                    let match = !0;
                    for (let i = 0; i < dimensions.length; i++) {
                        const dimension = dimensions[i];
                        if (cellPath.colHeaderPaths.findIndex(((colPath, index) => colPath.indicatorKey === dimension.indicatorKey || colPath.dimensionKey === dimension.dimensionKey && colPath.value === dimension.value)) < 0) {
                            match = !1;
                            break;
                        }
                    }
                    match && !this.internalProps._widthResizedColMap.has(cell.col) && (this._setColWidth(cell.col, width), 
                    this.internalProps._widthResizedColMap.add(cell.col));
                }
            } else cell && cell.col < this.rowHeaderLevelCount && (this.internalProps._widthResizedColMap.has(cell.col) || (this._setColWidth(cell.col, width), 
            this.internalProps._widthResizedColMap.add(cell.col)));
        }
    }
    _parseColumnWidthConfigForRowHeader(columnWidthConfig) {
        for (let i = 0; i < (null == columnWidthConfig ? void 0 : columnWidthConfig.length); i++) {
            const item = columnWidthConfig[i], dimensions = item.dimensions, width = item.width, cell = this.getCellAddressByHeaderPaths(dimensions);
            cell && cell.col < this.rowHeaderLevelCount && (this.internalProps._widthResizedColMap.has(cell.col) || (this._setColWidth(cell.col, width), 
            this.internalProps._widthResizedColMap.add(cell.col)));
        }
    }
    updatePivotSortState(pivotSortStateConfig) {
        this.pivotSortState = pivotSortStateConfig;
    }
    sort(col, row, order) {
        var _a, _b;
        let dimensions;
        if (this.isCornerHeader(col, row)) {
            const dimensionInfo = this.getHeaderDefine(col, row);
            dimensions = [];
            const dimension = {
                isPivotCorner: !0,
                dimensionKey: dimensionInfo.value,
                value: dimensionInfo.value
            };
            dimensions.push(dimension);
        } else dimensions = this.isColumnHeader(col, row) ? this.getCellHeaderPaths(col, row).colHeaderPaths : this.getCellHeaderPaths(col, row).rowHeaderPaths;
        const sortIndicator = dimensions[dimensions.length - 1].indicatorKey, headerDefine = this.getHeaderDefine(col, row);
        if (headerDefine.sort) {
            if (this.dataset.sortRules) {
                const cacheOldDimensionSortRule = {};
                for (let i = this.dataset.sortRules.length - 1; i >= 0; i--) {
                    const sortRule = this.dataset.sortRules[i];
                    (headerDefine.dimensionKey && sortRule.sortField === headerDefine.dimensionKey || sortIndicator && sortRule.sortField === (this.dataset.indicatorsAsCol ? this.dataset.rows[this.dataset.rows.length - 1] : this.dataset.columns[this.dataset.columns.length - 1])) && (cacheOldDimensionSortRule[sortRule.sortField] = sortRule, 
                    this.dataset.sortRules.splice(i, 1));
                }
                if (sortIndicator) {
                    const sortField = this.dataset.indicatorsAsCol ? this.dataset.rows[this.dataset.rows.length - 1] : this.dataset.columns[this.dataset.columns.length - 1];
                    this.dataset.sortRules.push({
                        sortField: sortField,
                        sortType: ts_types_1.SortType[order],
                        sortByIndicator: sortIndicator,
                        query: dimensions.reduce(((arr, dimension) => (dimension.dimensionKey && arr.push(dimension.value), 
                        arr)), []),
                        sortFunc: null === (_a = cacheOldDimensionSortRule[sortField]) || void 0 === _a ? void 0 : _a.sortFunc
                    });
                } else this.dataset.sortRules.push(Object.assign(null !== (_b = cacheOldDimensionSortRule[headerDefine.dimensionKey]) && void 0 !== _b ? _b : {}, {
                    sortField: headerDefine.dimensionKey,
                    sortType: ts_types_1.SortType[order]
                }));
            } else this.dataset.sortRules = sortIndicator ? [ {
                sortField: this.dataset.indicatorsAsCol ? this.dataset.rows[this.dataset.rows.length - 1] : this.dataset.columns[this.dataset.columns.length - 1],
                sortType: ts_types_1.SortType[order],
                sortByIndicator: sortIndicator,
                query: dimensions.reduce(((arr, dimension) => (dimension.dimensionKey && arr.push(dimension.value), 
                arr)), [])
            } ] : [ {
                sortField: headerDefine.dimensionKey,
                sortType: ts_types_1.SortType[order]
            } ];
            this.updateSortRules(this.dataset.sortRules, col, row);
        }
    }
    getPivotSortState(col, row) {
        if (!this.pivotSortState) return;
        const cellRange = this.getCellRange(col, row);
        for (let i = 0; i < this.pivotSortState.length; i++) {
            const pivotState = this.pivotSortState[i], dimensions = pivotState.dimensions, cell = this.getCellAddressByHeaderPaths(dimensions), order = pivotState.order;
            if (cell && (0, helper_1.cellInRange)(cellRange, cell.col, cell.row)) return order;
        }
    }
    _moveHeaderPosition(source, target) {
        const sourceCellRange = this.getCellRange(source.col, source.row), targetCellRange = this.getCellRange(target.col, target.row), moveContext = this.internalProps.layoutMap.moveHeaderPosition(source, target);
        if (moveContext) {
            if ("column" === moveContext.moveType) {
                if (this.internalProps.recordsIsTwoDimensionalArray) for (let row = 0; row < this.internalProps.records.length; row++) {
                    const sourceColumns = this.internalProps.records[row].splice(moveContext.sourceIndex - this.rowHeaderLevelCount, moveContext.sourceSize);
                    sourceColumns.unshift(moveContext.targetIndex - this.rowHeaderLevelCount, 0), Array.prototype.splice.apply(this.internalProps.records[row], sourceColumns);
                }
                this.colWidthsMap.exchangeOrder(sourceCellRange.start.col, sourceCellRange.end.col - sourceCellRange.start.col + 1, targetCellRange.start.col, targetCellRange.end.col - targetCellRange.start.col + 1, moveContext.targetIndex), 
                this.setMinMaxLimitWidth();
            } else if ("row" === moveContext.moveType) {
                if (this.internalProps.recordsIsTwoDimensionalArray) {
                    const sourceRows = this.internalProps.records.splice(moveContext.sourceIndex - this.columnHeaderLevelCount, moveContext.sourceSize);
                    sourceRows.unshift(moveContext.targetIndex - this.columnHeaderLevelCount, 0), Array.prototype.splice.apply(this.internalProps.records, sourceRows);
                }
                moveContext.targetIndex > moveContext.sourceIndex ? this.rowHeightsMap.exchangeOrder(moveContext.sourceIndex, moveContext.sourceSize, moveContext.targetIndex + moveContext.sourceSize - moveContext.targetSize, moveContext.targetSize, moveContext.targetIndex) : this.rowHeightsMap.exchangeOrder(moveContext.sourceIndex, moveContext.sourceSize, moveContext.targetIndex, moveContext.targetSize, moveContext.targetIndex);
            }
            return moveContext;
        }
        return null;
    }
    toggleHierarchyState(col, row, recalculateColWidths = !0) {
        this.internalProps.layoutMap.clearHeaderPathCache();
        const hierarchyState = this.getHierarchyState(col, row);
        if (hierarchyState === ts_types_1.HierarchyState.expand) this._refreshHierarchyState(col, row, recalculateColWidths), 
        this.fireListeners(PIVOT_TABLE_EVENT_TYPE_1.PIVOT_TABLE_EVENT_TYPE.TREE_HIERARCHY_STATE_CHANGE, {
            col: col,
            row: row,
            hierarchyState: ts_types_1.HierarchyState.collapse
        }); else if (hierarchyState === ts_types_1.HierarchyState.collapse) {
            const headerTreeNode = this.internalProps.layoutMap.getHeadNode(col, row);
            Array.isArray(headerTreeNode.children) && this._refreshHierarchyState(col, row, recalculateColWidths), 
            this.fireListeners(PIVOT_TABLE_EVENT_TYPE_1.PIVOT_TABLE_EVENT_TYPE.TREE_HIERARCHY_STATE_CHANGE, {
                col: col,
                row: row,
                hierarchyState: ts_types_1.HierarchyState.expand,
                originData: headerTreeNode
            });
        }
    }
    _refreshHierarchyState(col, row, recalculateColWidths = !0, beforeUpdateCell) {
        var _a, _b;
        this.frozenColCount, this.frozenRowCount;
        const visibleStartRow = this.getBodyVisibleRowRange().rowStart;
        this.internalProps._oldRowCount = this.rowCount, this.internalProps._oldColCount = this.colCount;
        let notFillWidth = !1, notFillHeight = !1;
        this.stateManager.updateHoverIcon(col, row, void 0, void 0);
        const checkHasChart = this.internalProps.layoutMap.checkHasChart();
        checkHasChart && (this.autoFillWidth && (notFillWidth = this.getAllColsWidth() <= this.tableNoFrameWidth), 
        this.autoFillHeight && (notFillHeight = this.getAllRowsHeight() <= this.tableNoFrameHeight));
        const result = this.internalProps.layoutMap.isRowHeader(col, row) ? this.internalProps.layoutMap.toggleHierarchyState(col, row) : this.internalProps.layoutMap.toggleHierarchyStateForColumnTree(col, row);
        beforeUpdateCell && beforeUpdateCell(), this.refreshRowColCount();
        this.frozenColCount, this.frozenRowCount;
        this.clearCellStyleCache(), "tree" === this.rowHierarchyType && this.scenegraph.updateHierarchyIcon(col, row), 
        null === (_a = this.reactCustomLayout) || void 0 === _a || _a.clearCache(), "grid-tree" !== this.rowHierarchyType && "grid-tree" !== this.columnHierarchyType ? this.scenegraph.updateRow(result.removeCellPositionsRowDirection, result.addCellPositionsRowDirection, result.updateCellPositionsRowDirection, recalculateColWidths) : (this.internalProps.stick.changedCells.clear(), 
        this.scenegraph.clearCells(), this.clearCellStyleCache(), this.scenegraph.createSceneGraph(), 
        this.scrollToRow(visibleStartRow)), null === (_b = this.reactCustomLayout) || void 0 === _b || _b.updateAllCustomCell(), 
        checkHasChart && (this.autoFillWidth && !notFillWidth && (notFillWidth = this.getAllColsWidth() <= this.tableNoFrameWidth), 
        this.autoFillHeight && !notFillHeight && (notFillHeight = this.getAllRowsHeight() <= this.tableNoFrameHeight), 
        ("adaptive" === this.widthMode || notFillWidth || "adaptive" === this.heightMode || notFillHeight) && this.scenegraph.updateChartSizeForResizeColWidth(-1)), 
        this.internalProps._oldRowCount = void 0, this.internalProps._oldColCount = void 0;
    }
    getHeaderCellAddressByPath(dimensionPaths) {
        return this.internalProps.layoutMap.getPivotCellAdress(dimensionPaths);
    }
    getCellAddressByHeaderPaths(dimensionPaths) {
        return this.internalProps.layoutMap.getCellAdressByHeaderPath(dimensionPaths);
    }
    getHeaderPathByXY(coordinate) {
        let cellAddr;
        cellAddr = coordinate ? this.getCellAt(coordinate.x + this.getFrozenColsWidth() + this.scrollLeft + 1, coordinate.y + this.getFrozenRowsHeight() + this.scrollTop + 1) : this.getCellAt(this.getFrozenColsWidth() + this.scrollLeft + 1, this.getFrozenRowsHeight() + this.scrollTop + 1);
        return this.internalProps.layoutMap.getCellHeaderPaths(cellAddr.col, cellAddr.row);
    }
    getHierarchyState(col, row) {
        var _a;
        return null === (_a = this._getHeaderLayoutMap(col, row)) || void 0 === _a ? void 0 : _a.hierarchyState;
    }
    getLayoutColumnTree() {
        return this.internalProps.layoutMap.getLayoutColumnTree();
    }
    getLayoutColumnTreeCount() {
        return this.internalProps.layoutMap.getLayoutColumnTreeCount();
    }
    getLayoutRowTree() {
        return this.internalProps.layoutMap.getLayoutRowTree();
    }
    getLayoutRowTreeCount() {
        return this.internalProps.layoutMap.getLayoutRowTreeCount();
    }
    getCellHeaderTreeNodes(col, row) {
        return this.internalProps.layoutMap.getCellHeaderPathsWithTreeNode(col, row);
    }
    getMenuInfo(col, row, type) {
        const dimensionInfos = this.internalProps.layoutMap.getPivotDimensionInfo(col, row);
        return {
            dimensionKey: dimensionInfos[dimensionInfos.length - 1].dimensionKey,
            value: this.getCellValue(col, row),
            cellLocation: this.getCellLocation(col, row),
            isPivotCorner: this.isCornerHeader(col, row),
            event: void 0
        };
    }
    setRecords(records) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        (0, chart_render_helper_1.clearChartRenderQueue)();
        const oldHoverState = {
            col: this.stateManager.hover.cellPos.col,
            row: this.stateManager.hover.cellPos.row
        };
        this.options.records = this.internalProps.records = records, this.internalProps.recordsIsTwoDimensionalArray = !1, 
        (null === (_a = null == records ? void 0 : records[0]) || void 0 === _a ? void 0 : _a.constructor) === Array && (this.internalProps.recordsIsTwoDimensionalArray = !0);
        const options = this.options, internalProps = this.internalProps;
        if (!1 === (null === (_b = this.options.customConfig) || void 0 === _b ? void 0 : _b.enableDataAnalysis)) !1 === this.internalProps.recordsIsTwoDimensionalArray && (this.flatDataToObjects = new flatDataToObject_1.FlatDataToObjects({
            rows: internalProps.layoutMap.fullRowDimensionKeys,
            columns: internalProps.layoutMap.colDimensionKeys,
            indicators: internalProps.layoutMap.indicatorKeys,
            indicatorsAsCol: internalProps.layoutMap.indicatorsAsCol,
            indicatorDimensionKey: internalProps.layoutMap.indicatorDimensionKey
        }, records)); else {
            let columnDimensionTree, rowDimensionTree;
            this.dataset.setRecords(records), options.columnTree ? columnDimensionTree = internalProps.layoutMap.columnDimensionTree : (!1 !== options.indicatorsAsCol && options.indicators && this.dataset.colHeaderTree && (0, 
            layout_helper_1.deleteHideIndicatorNode)(this.dataset.colHeaderTree, options.indicators, !1, this), 
            columnDimensionTree = new tree_helper_1.DimensionTree(null !== (_c = this.dataset.colHeaderTree) && void 0 !== _c ? _c : [], this.layoutNodeId, this.options.columnHierarchyType, "grid" !== this.options.columnHierarchyType ? null !== (_d = this.options.columnExpandLevel) && void 0 !== _d ? _d : 1 : void 0)), 
            options.rowTree ? rowDimensionTree = internalProps.layoutMap.rowDimensionTree : (!1 === options.indicatorsAsCol && this.dataset.rowHeaderTree && options.indicators && (0, 
            layout_helper_1.deleteHideIndicatorNode)(this.dataset.rowHeaderTree, options.indicators, !1, this), 
            rowDimensionTree = new tree_helper_1.DimensionTree(null !== (_e = this.dataset.rowHeaderTree) && void 0 !== _e ? _e : [], this.layoutNodeId, this.options.rowHierarchyType, "grid" !== this.options.rowHierarchyType ? null !== (_f = this.options.rowExpandLevel) && void 0 !== _f ? _f : 1 : void 0)), 
            internalProps.layoutMap = new pivot_header_layout_1.PivotHeaderLayoutMap(this, this.dataset, columnDimensionTree, rowDimensionTree), 
            this.pivotSortState = [], options.pivotSortState && (this.pivotSortState = options.pivotSortState);
        }
        if (this.refreshHeader(), this.internalProps.useOneRowHeightFillAll = !1, this.scenegraph.clearCells(), 
        this.clearCellStyleCache(), this.scenegraph.createSceneGraph(), this.stateManager.updateHoverPos(oldHoverState.col, oldHoverState.row), 
        this.internalProps.title && !this.internalProps.title.isReleased && (this._updateSize(), 
        this.internalProps.title.resize(), this.scenegraph.resize()), this.eventManager.updateEventBinder(), 
        this.options.emptyTip) if (this.internalProps.emptyTip) null === (_g = this.internalProps.emptyTip) || void 0 === _g || _g.resetVisible(); else {
            const EmptyTip = factory_1.Factory.getComponent("emptyTip");
            this.internalProps.emptyTip = new EmptyTip(this.options.emptyTip, this), null === (_h = this.internalProps.emptyTip) || void 0 === _h || _h.resetVisible();
        }
    }
    startEditCell(col, row, value) {
        var _a;
        if ((0, vutils_1.isValid)(col) && (0, vutils_1.isValid)(row)) this.eventManager.isDraging = !1, 
        this.selectCell(col, row), this.editorManager.startEditCell(col, row, value); else if (null === (_a = this.stateManager.select) || void 0 === _a ? void 0 : _a.cellPos) {
            const {col: col, row: row} = this.stateManager.select.cellPos;
            (0, vutils_1.isValid)(col) && (0, vutils_1.isValid)(row) && this.editorManager.startEditCell(col, row, value);
        }
    }
    completeEditCell() {
        this.editorManager.completeEdit();
    }
    getEditor(col, row) {
        var _a, _b, _c;
        let editorDefine;
        if (this.isCornerHeader(col, row)) {
            const define = this.getHeaderDefine(col, row);
            editorDefine = null !== (_a = null == define ? void 0 : define.headerEditor) && void 0 !== _a ? _a : this.options.headerEditor;
        } else if (this.isHeader(col, row)) {
            const define = this.getHeaderDefine(col, row);
            editorDefine = null !== (_b = null == define ? void 0 : define.headerEditor) && void 0 !== _b ? _b : this.options.headerEditor;
        } else {
            const define = this.getBodyColumnDefine(col, row);
            editorDefine = null !== (_c = null == define ? void 0 : define.editor) && void 0 !== _c ? _c : this.options.editor;
        }
        if ("function" == typeof editorDefine) {
            editorDefine = editorDefine({
                col: col,
                row: row,
                dataValue: this.getCellOriginValue(col, row),
                value: this.getCellValue(col, row) || "",
                table: this
            });
        }
        return "string" == typeof editorDefine ? editors.get(editorDefine) : editorDefine;
    }
    isHasEditorDefine(col, row) {
        var _a;
        const define = this.getBodyColumnDefine(col, row);
        let editorDefine = null !== (_a = null == define ? void 0 : define.editor) && void 0 !== _a ? _a : this.options.editor;
        if ("function" == typeof editorDefine) {
            editorDefine = editorDefine({
                col: col,
                row: row,
                dataValue: this.getCellOriginValue(col, row),
                value: this.getCellValue(col, row) || "",
                table: this
            });
        }
        return (0, vutils_1.isValid)(editorDefine);
    }
    changeCellValue(col, row, value, workOnEditableCell = !1) {
        if (workOnEditableCell && this.isHasEditorDefine(col, row) || !1 === workOnEditableCell) {
            let newValue = value;
            const oldValue = this.getCellOriginValue(col, row), rawValue = this.getCellRawValue(col, row);
            "number" == typeof rawValue && (0, util_1.isAllDigits)(value) && (newValue = parseFloat(value)), 
            this._changeCellValueToDataSet(col, row, oldValue, newValue);
            const range = this.getCellRange(col, row);
            for (let sCol = range.start.col; sCol <= range.end.col; sCol++) for (let sRow = range.start.row; sRow <= range.end.row; sRow++) this.scenegraph.updateCellContent(sCol, sRow);
            if ("adaptive" === this.widthMode || this.autoFillWidth && this.getAllColsWidth() <= this.tableNoFrameWidth) 0 === this.internalProps._widthResizedColMap.size && this.scenegraph.recalculateColWidths(); else if (!this.internalProps._widthResizedColMap.has(col)) {
                const oldWidth = this.getColWidth(col), newWidth = (0, compute_col_width_1.computeColWidth)(col, 0, this.rowCount - 1, this, !1);
                newWidth !== oldWidth && this.scenegraph.updateColWidth(col, newWidth - oldWidth);
            }
            if ("adaptive" === this.heightMode || this.autoFillHeight && this.getAllRowsHeight() <= this.tableNoFrameHeight) 0 === this.internalProps._heightResizedRowMap.size && this.scenegraph.recalculateRowHeights(); else if (this.isAutoRowHeight(row) && !this.internalProps._heightResizedRowMap.has(row)) {
                const oldHeight = this.getRowHeight(row), newHeight = (0, compute_row_height_1.computeRowHeight)(row, 0, this.colCount - 1, this);
                this.scenegraph.updateRowHeight(row, newHeight - oldHeight);
            }
            oldValue !== newValue && this.fireListeners(TABLE_EVENT_TYPE_1.TABLE_EVENT_TYPE.CHANGE_CELL_VALUE, {
                col: col,
                row: row,
                rawValue: rawValue,
                currentValue: oldValue,
                changedValue: newValue
            }), this.scenegraph.updateNextFrame();
        }
    }
    changeCellValues(startCol, startRow, values, workOnEditableCell = !1) {
        let pasteColEnd = startCol, pasteRowEnd = startRow;
        const beforeChangeValues = [], oldValues = [];
        for (let i = 0; i < values.length && !(startRow + i > this.rowCount - 1); i++) {
            const rowValues = values[i], rawRowValues = [], oldRowValues = [];
            beforeChangeValues.push(rawRowValues), oldValues.push(oldRowValues);
            for (let j = 0; j < rowValues.length && !(startCol + j > this.colCount - 1); j++) {
                const beforeChangeValue = this.getCellRawValue(startCol + j, startRow + i);
                rawRowValues.push(beforeChangeValue);
                const oldValue = this.getCellOriginValue(startCol + j, startRow + i);
                oldRowValues.push(oldValue);
            }
        }
        for (let i = 0; i < values.length && !(startRow + i > this.rowCount - 1); i++) {
            pasteRowEnd = startRow + i;
            const rowValues = values[i];
            let thisRowPasteColEnd = startCol;
            for (let j = 0; j < rowValues.length && !(startCol + j > this.colCount - 1); j++) if (thisRowPasteColEnd = startCol + j, 
            workOnEditableCell && this.isHasEditorDefine(startCol + j, startRow + i) || !1 === workOnEditableCell) {
                const value = rowValues[j];
                let newValue = value;
                const oldValue = oldValues[i][j], rawValue = beforeChangeValues[i][j];
                "number" == typeof rawValue && (0, util_1.isAllDigits)(value) && (newValue = parseFloat(value)), 
                this._changeCellValueToDataSet(startCol + j, startRow + i, oldValue, newValue);
                const changedValue = this.getCellOriginValue(startCol + j, startRow + i);
                changedValue !== oldValue && this.fireListeners(TABLE_EVENT_TYPE_1.TABLE_EVENT_TYPE.CHANGE_CELL_VALUE, {
                    col: startCol + j,
                    row: startRow + i,
                    rawValue: rawValue,
                    currentValue: oldValue,
                    changedValue: changedValue
                });
            }
            pasteColEnd = Math.max(pasteColEnd, thisRowPasteColEnd);
        }
        const startRange = this.getCellRange(startCol, startRow), range = this.getCellRange(pasteColEnd, pasteRowEnd);
        for (let sCol = startRange.start.col; sCol <= range.end.col; sCol++) for (let sRow = startRange.start.row; sRow <= range.end.row; sRow++) this.scenegraph.updateCellContent(sCol, sRow);
        if ("adaptive" === this.widthMode || this.autoFillWidth && this.getAllColsWidth() <= this.tableNoFrameWidth) 0 === this.internalProps._widthResizedColMap.size && this.scenegraph.recalculateColWidths(); else for (let sCol = startCol; sCol <= range.end.col; sCol++) if (!this.internalProps._widthResizedColMap.has(sCol)) {
            const oldWidth = this.getColWidth(sCol), newWidth = (0, compute_col_width_1.computeColWidth)(sCol, 0, this.rowCount - 1, this, !1);
            newWidth !== oldWidth && this.scenegraph.updateColWidth(sCol, newWidth - oldWidth);
        }
        if ("adaptive" === this.heightMode || this.autoFillHeight && this.getAllRowsHeight() <= this.tableNoFrameHeight) this.scenegraph.recalculateRowHeights(); else if (this.isAutoRowHeight(startRow)) {
            const rows = [], deltaYs = [];
            for (let sRow = startRow; sRow <= range.end.row; sRow++) if (this.rowHeightsMap.get(sRow)) {
                const oldHeight = this.getRowHeight(sRow), newHeight = (0, compute_row_height_1.computeRowHeight)(sRow, 0, this.colCount - 1, this);
                rows.push(sRow), deltaYs.push(newHeight - oldHeight);
            }
            this.scenegraph.updateRowsHeight(rows, deltaYs);
        }
        this.scenegraph.updateNextFrame();
    }
    _changeCellValueToDataSet(col, row, oldValue, newValue) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        if (this.internalProps.recordsIsTwoDimensionalArray) {
            const rowIndex = this.getBodyIndexByRow(row), colIndex = this.getBodyIndexByCol(col);
            this.records[rowIndex][colIndex] = newValue;
        } else if (this.dataset) {
            const cellDimensionPath = this.internalProps.layoutMap.getCellHeaderPaths(col, row);
            if (this.isCornerHeader(col, row)) this.internalProps.layoutMap.changeCornerTitle(col, row, newValue); else if (this.isHeader(col, row)) this.internalProps.layoutMap.changeTreeNodeTitle(col, row, newValue), 
            !this.isCornerHeader(col, row) && this.dataset.changeRecordFieldValue((null === (_a = cellDimensionPath.colHeaderPaths) || void 0 === _a ? void 0 : _a.length) ? null !== (_b = cellDimensionPath.colHeaderPaths[cellDimensionPath.colHeaderPaths.length - 1].indicatorKey) && void 0 !== _b ? _b : cellDimensionPath.colHeaderPaths[cellDimensionPath.colHeaderPaths.length - 1].dimensionKey : null !== (_c = cellDimensionPath.rowHeaderPaths[cellDimensionPath.rowHeaderPaths.length - 1].indicatorKey) && void 0 !== _c ? _c : cellDimensionPath.rowHeaderPaths[cellDimensionPath.rowHeaderPaths.length - 1].dimensionKey, oldValue, newValue); else {
                const colKeys = null === (_d = cellDimensionPath.colHeaderPaths) || void 0 === _d ? void 0 : _d.filter((path => !path.virtual)).map((colPath => {
                    var _a;
                    return null !== (_a = colPath.indicatorKey) && void 0 !== _a ? _a : colPath.value;
                })), rowKeys = null === (_e = cellDimensionPath.rowHeaderPaths) || void 0 === _e ? void 0 : _e.filter((path => !path.virtual)).map((rowPath => {
                    var _a;
                    return null !== (_a = rowPath.indicatorKey) && void 0 !== _a ? _a : rowPath.value;
                }));
                this.dataset.changeTreeNodeValue(this.internalProps.layoutMap.indicatorsAsCol ? rowKeys : rowKeys.slice(0, -1), this.internalProps.layoutMap.indicatorsAsCol ? colKeys.slice(0, -1) : colKeys, this.internalProps.layoutMap.getIndicatorKey(col, row), newValue);
            }
        } else if (this.flatDataToObjects) {
            const cellDimensionPath = this.internalProps.layoutMap.getCellHeaderPaths(col, row);
            if (this.isHeader(col, row)) this.internalProps.layoutMap.changeTreeNodeTitle(col, row, newValue), 
            !this.isCornerHeader(col, row) && this.flatDataToObjects.changeRecordFieldValue((null === (_f = cellDimensionPath.colHeaderPaths) || void 0 === _f ? void 0 : _f.length) ? null !== (_g = cellDimensionPath.colHeaderPaths[cellDimensionPath.colHeaderPaths.length - 1].indicatorKey) && void 0 !== _g ? _g : cellDimensionPath.colHeaderPaths[cellDimensionPath.colHeaderPaths.length - 1].dimensionKey : null !== (_h = cellDimensionPath.rowHeaderPaths[cellDimensionPath.rowHeaderPaths.length - 1].indicatorKey) && void 0 !== _h ? _h : cellDimensionPath.rowHeaderPaths[cellDimensionPath.rowHeaderPaths.length - 1].dimensionKey, oldValue, newValue); else {
                const colKeys = cellDimensionPath.colHeaderPaths.map((colPath => {
                    var _a;
                    return null !== (_a = colPath.indicatorKey) && void 0 !== _a ? _a : colPath.value;
                })), rowKeys = cellDimensionPath.rowHeaderPaths.map((rowPath => {
                    var _a;
                    return null !== (_a = rowPath.indicatorKey) && void 0 !== _a ? _a : rowPath.value;
                }));
                this.flatDataToObjects.changeTreeNodeValue(rowKeys, colKeys, this.internalProps.layoutMap.getBody(col, row).indicatorKey, newValue);
            }
        }
    }
    _hasCustomRenderOrLayout() {
        if (this.options.customRender) return !0;
        const {columnsDefine: columnsDefine, rowsDefine: rowsDefine, indicatorsDefine: indicatorsDefine} = this.internalProps.layoutMap;
        for (let i = 0; i < columnsDefine.length; i++) {
            const columnDefine = columnsDefine[i];
            if ("string" != typeof columnDefine && (columnDefine.headerCustomLayout || columnDefine.headerCustomRender)) return !0;
        }
        for (let i = 0; i < rowsDefine.length; i++) {
            const rowDefine = rowsDefine[i];
            if ("string" != typeof rowDefine && (rowDefine.headerCustomLayout || rowDefine.headerCustomRender)) return !0;
        }
        for (let i = 0; i < indicatorsDefine.length; i++) {
            const indicatorDefine = indicatorsDefine[i];
            if ("string" != typeof indicatorDefine && (indicatorDefine.customLayout || indicatorDefine.headerCustomLayout || indicatorDefine.customRender || indicatorDefine.headerCustomRender)) return !0;
        }
        return !1;
    }
    changeRecordOrder(source, target) {}
    setTreeNodeChildren(children, records, col, row) {
        if (this.flatDataToObjects) {
            this.internalProps.layoutMap.getHeadNode(col, row).children = children, this._refreshHierarchyState(col, row, !0, (() => {
                this.flatDataToObjects.changeDataConfig({
                    rows: this.internalProps.layoutMap.fullRowDimensionKeys,
                    columns: this.internalProps.layoutMap.colDimensionKeys,
                    indicators: this.internalProps.layoutMap.indicatorKeys,
                    indicatorsAsCol: this.internalProps.layoutMap.indicatorsAsCol,
                    indicatorDimensionKey: this.internalProps.layoutMap.indicatorDimensionKey
                }), this.flatDataToObjects.addRecords(records);
            }));
        } else {
            this.internalProps.layoutMap.getHeadNode(col, row).children = children, this._refreshHierarchyState(col, row, !0, (() => {
                this.dataset._rowTreeHasChanged(), this.dataset.changeDataConfig({
                    rows: this.internalProps.layoutMap.fullRowDimensionKeys,
                    columns: this.internalProps.layoutMap.colDimensionKeys
                }), this.dataset.addRecords(records);
            }));
        }
    }
    updateFilterRules(filterRules) {
        this.internalProps.dataConfig.filterRules = filterRules, this.dataset.updateFilterRules(filterRules), 
        this.renderWithRecreateCells();
    }
    getFilteredRecords() {
        var _a;
        return null === (_a = this.dataset) || void 0 === _a ? void 0 : _a.filterRules;
    }
    getCellPivotRole(col, row) {
        const path = this.getCellHeaderPaths(col, row), {cellLocation: cellLocation, colHeaderPaths: colHeaderPaths, rowHeaderPaths: rowHeaderPaths} = path;
        let colRole = colHeaderPaths.length ? "normal" : void 0, rowRole = rowHeaderPaths.length ? "normal" : void 0;
        return colHeaderPaths.forEach((path => {
            "sub-total" === path.role ? colRole = "sub-total" : "grand-total" === path.role && (colRole = "grand-total");
        })), rowHeaderPaths.forEach((path => {
            "sub-total" === path.role ? rowRole = "sub-total" : "grand-total" === path.role && (rowRole = "grand-total");
        })), {
            colRole: colRole,
            rowRole: rowRole,
            cellLocation: cellLocation
        };
    }
    setLoadingHierarchyState(col, row) {
        this.scenegraph.setLoadingHierarchyState(col, row);
    }
    release() {
        this.internalProps.layoutMap.clearHeaderPathCache(), this.editorManager.release(), 
        super.release();
    }
}

exports.PivotTable = PivotTable;
//# sourceMappingURL=PivotTable.js.map