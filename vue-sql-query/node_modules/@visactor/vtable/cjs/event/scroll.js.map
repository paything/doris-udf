{"version":3,"sources":["../src/event/scroll.ts"],"names":[],"mappings":"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","file":"scroll.js","sourcesContent":["import type { StateManager } from '../state/state';\nimport { InteractionState } from '../ts-types';\nimport type { FederatedWheelEvent } from './../vrender';\n\n/**\n *\n * @param event\n * @param state\n * @param isWheelEvent 是否是由鼠标或者触摸板原生滚动事件触发进入？\n */\nexport function handleWhell(event: FederatedWheelEvent, state: StateManager, isWheelEvent: boolean = true) {\n  let { deltaX, deltaY } = event;\n  // 如果按住了shift 则进行横向滚动 纵向不滚动\n  if (event.shiftKey && event.deltaY) {\n    //mac电脑按住shift 鼠标滚动deltaX和deltaY是自动互换的，所以此逻辑只针对windows电脑有效及mac触摸板有效\n    deltaX = deltaY;\n    deltaY = 0;\n  }\n  const [optimizedDeltaX, optimizedDeltaY] = optimizeScrollXY(deltaX, deltaY, { horizontal: 1, vertical: 1 });\n  if (optimizedDeltaX || optimizedDeltaY) {\n    if (state.interactionState !== InteractionState.scrolling) {\n      state.updateInteractionState(InteractionState.scrolling);\n    }\n  }\n\n  if (optimizedDeltaX) {\n    state.setScrollLeft(state.scroll.horizontalBarPos + optimizedDeltaX, event);\n    state.showHorizontalScrollBar(true);\n  }\n  if (optimizedDeltaY) {\n    state.setScrollTop(state.scroll.verticalBarPos + optimizedDeltaY, event);\n    state.showVerticalScrollBar(true);\n  }\n  isWheelEvent && state.resetInteractionState(state.interactionStateBeforeScroll);\n  if (\n    event.nativeEvent?.cancelable &&\n    (state.table.internalProps.overscrollBehavior === 'none' ||\n      (Math.abs(deltaY) >= Math.abs(deltaX) && deltaY !== 0 && isVerticalScrollable(deltaY, state)) ||\n      (Math.abs(deltaY) <= Math.abs(deltaX) && deltaX !== 0 && isHorizontalScrollable(deltaX, state)))\n  ) {\n    event.nativeEvent.preventDefault();\n  }\n}\n\ninterface ScrollSpeedRatio {\n  horizontal?: number;\n  vertical?: number;\n}\n\n/**\n * 优化滚动方向，对于小角度的滚动，固定为一个方向\n * @param x\n * @param y\n * @param ratio\n */\nfunction optimizeScrollXY(x: number, y: number, ratio: ScrollSpeedRatio): [number, number] {\n  const ANGLE = 2; // 调参 根据斜率来调整xy方向的划分\n  const angle = Math.abs(x / y);\n\n  // 经过滚动优化之后的 x, y\n  const deltaX = angle <= 1 / ANGLE ? 0 : x;\n  const deltaY = angle > ANGLE ? 0 : y;\n\n  return [Math.ceil(deltaX * (ratio.horizontal ?? 0)), Math.ceil(deltaY * (ratio.vertical ?? 0))];\n}\n\nexport function isVerticalScrollable(deltaY: number, state: StateManager) {\n  const totalHeight = state.table.getAllRowsHeight() - state.table.scenegraph.height;\n  if (totalHeight === 0) {\n    return false;\n  }\n  return !isScrollToTop(deltaY, state) && !isScrollToBottom(deltaY, state);\n}\n\nexport function isHorizontalScrollable(deltaX: number, state: StateManager) {\n  const totalWidth = state.table.getAllColsWidth() - state.table.scenegraph.width;\n  if (totalWidth === 0) {\n    return false;\n  }\n  return !isScrollToLeft(deltaX, state) && !isScrollToRight(deltaX, state);\n}\n\nfunction isScrollToTop(deltaY: number, state: StateManager) {\n  const totalHeight = state.table.getAllRowsHeight() - state.table.scenegraph.height;\n  return totalHeight !== 0 && deltaY <= 0 && state.scroll.verticalBarPos < 1;\n}\n\nfunction isScrollToBottom(deltaY: number, state: StateManager) {\n  // 这里加入tolerance，避免出现无用滚动\n  const sizeTolerance = state.table.options.customConfig?._disableColumnAndRowSizeRound ? 1 : 0;\n\n  const totalHeight = state.table.getAllRowsHeight() - state.table.scenegraph.height;\n  return totalHeight !== 0 && deltaY >= 0 && Math.abs(state.scroll.verticalBarPos - totalHeight) < 1 + sizeTolerance;\n}\n\nfunction isScrollToLeft(deltaX: number, state: StateManager) {\n  const totalWidth = state.table.getAllColsWidth() - state.table.scenegraph.width;\n  return totalWidth !== 0 && deltaX <= 0 && state.scroll.horizontalBarPos < 1;\n}\n\nfunction isScrollToRight(deltaX: number, state: StateManager) {\n  // 这里加入tolerance，避免出现无用滚动\n  const sizeTolerance = state.table.options.customConfig?._disableColumnAndRowSizeRound ? 1 : 0;\n\n  const totalWidth = state.table.getAllColsWidth() - state.table.scenegraph.width;\n  return totalWidth !== 0 && deltaX >= 0 && Math.abs(state.scroll.horizontalBarPos - totalWidth) < 1 + sizeTolerance;\n}\n\nexport class InertiaScroll {\n  friction: number;\n  lastTime: number;\n  speedX: number;\n  speedY: number;\n  stateManager: StateManager;\n  runingId: number;\n  scrollHandle: (dx: number, dy: number) => void;\n  constructor(stateManager: StateManager) {\n    this.stateManager = stateManager;\n  }\n  setScrollHandle(scrollHandle: (dx: number, dy: number) => void) {\n    this.scrollHandle = scrollHandle;\n  }\n\n  startInertia(speedX: number, speedY: number, friction: number) {\n    this.lastTime = Date.now();\n    this.speedX = speedX;\n    this.speedY = speedY;\n    this.friction = friction;\n    if (!this.runingId) {\n      this.runingId = requestAnimationFrame(this.inertia.bind(this));\n    }\n  }\n  inertia() {\n    const now = Date.now();\n    const dffTime = now - this.lastTime;\n    let stopped = true;\n    const f = Math.pow(this.friction, dffTime / 16);\n    const newSpeedX = f * this.speedX;\n    const newSpeedY = f * this.speedY;\n    let dx = 0;\n    let dy = 0;\n    if (Math.abs(newSpeedX) > 0.05) {\n      stopped = false;\n      dx = ((this.speedX + newSpeedX) / 2) * dffTime;\n    }\n    if (Math.abs(newSpeedY) > 0.05) {\n      stopped = false;\n      dy = ((this.speedY + newSpeedY) / 2) * dffTime;\n    }\n    this.scrollHandle?.(dx, dy);\n    if (stopped) {\n      this.runingId = null;\n      return;\n    }\n    this.lastTime = now;\n    this.speedX = newSpeedX;\n    this.speedY = newSpeedY;\n\n    this.runingId = requestAnimationFrame(this.inertia.bind(this));\n  }\n  endInertia() {\n    cancelAnimationFrame(this.runingId);\n    this.runingId = null;\n  }\n  isInertiaScrolling() {\n    return !!this.runingId;\n  }\n}\n"]}