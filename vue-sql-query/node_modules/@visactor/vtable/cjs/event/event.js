"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.EventManager = void 0;

const vrender_1 = require("./../vrender"), TABLE_EVENT_TYPE_1 = require("../core/TABLE_EVENT_TYPE"), media_click_1 = require("./media-click"), drill_1 = require("./drill"), sparkline_event_1 = require("./sparkline-event"), stick_text_1 = require("../scenegraph/stick-text"), table_group_1 = require("./listener/table-group"), scroll_bar_1 = require("./listener/scroll-bar"), container_dom_1 = require("./listener/container-dom"), touch_1 = require("./listener/touch"), axis_click_1 = require("./self-event-listener/pivot-chart/axis-click"), axis_hover_1 = require("./self-event-listener/pivot-chart/axis-hover"), env_1 = require("../tools/env"), vutils_1 = require("@visactor/vutils"), scroll_1 = require("./scroll"), is_cell_select_highlight_1 = require("../state/select/is-cell-select-highlight"), checkbox_1 = require("./self-event-listener/list-table/checkbox"), button_1 = require("./component/button"), icon_1 = require("./self-event-listener/base-table/icon"), dropdown_menu_1 = require("./self-event-listener/base-table/dropdown-menu"), dbclick_auto_column_width_1 = require("./self-event-listener/base-table/dbclick-auto-column-width"), right_button_click_1 = require("./self-event-listener/base-table/right-button-click");

class EventManager {
    constructor(table) {
        this.isDown = !1, this.isDraging = !1, this.globalEventListeners = [], this._enableTableScroll = !0, 
        this.table = table, this.handleTextStickBindId = [], this.inertiaScroll = new scroll_1.InertiaScroll(table.stateManager), 
        "node" === env_1.Env.mode || table.options.disableInteraction || (this.bindOuterEvent(), 
        setTimeout((() => {
            this.bindSelfEvent();
        }), 0));
    }
    bindOuterEvent() {
        (0, table_group_1.bindTableGroupListener)(this), (0, container_dom_1.bindContainerDomListener)(this), 
        (0, scroll_bar_1.bindScrollBarListener)(this), (0, touch_1.bindTouchListener)(this), 
        (0, table_group_1.bindGesture)(this);
    }
    updateEventBinder() {
        setTimeout((() => {
            var _a;
            this.table.isReleased || ((0, stick_text_1.checkHaveTextStick)(this.table) && 0 === (null === (_a = this.handleTextStickBindId) || void 0 === _a ? void 0 : _a.length) ? (this.handleTextStickBindId.push(this.table.on(TABLE_EVENT_TYPE_1.TABLE_EVENT_TYPE.SCROLL, (e => {
                (0, stick_text_1.handleTextStick)(this.table);
            }))), this.handleTextStickBindId.push(this.table.on(TABLE_EVENT_TYPE_1.TABLE_EVENT_TYPE.RESIZE_COLUMN_END, (e => {
                (0, stick_text_1.handleTextStick)(this.table);
            }))), this.handleTextStickBindId.push(this.table.on(TABLE_EVENT_TYPE_1.TABLE_EVENT_TYPE.RESIZE_ROW_END, (e => {
                (0, stick_text_1.handleTextStick)(this.table);
            })))) : !(0, stick_text_1.checkHaveTextStick)(this.table) && this.handleTextStickBindId && (this.handleTextStickBindId.forEach((id => {
                this.table.off(id);
            })), this.handleTextStickBindId = []), (0, sparkline_event_1.bindSparklineHoverEvent)(this.table));
        }), 0);
    }
    bindSelfEvent() {
        this.table.isReleased || ((0, icon_1.bindIconClickEvent)(this.table), (0, dropdown_menu_1.bindDropdownMenuClickEvent)(this.table), 
        this.updateEventBinder(), (0, media_click_1.bindMediaClick)(this.table), (0, dbclick_auto_column_width_1.bindDBClickAutoColumnWidthEvent)(this.table), 
        this.table.isPivotTable() && (0, drill_1.checkHaveDrill)(this.table) && (0, drill_1.bindDrillEvent)(this.table), 
        (0, sparkline_event_1.bindSparklineHoverEvent)(this.table), (0, axis_click_1.bindAxisClickEvent)(this.table), 
        (0, axis_hover_1.bindAxisHoverEvent)(this.table), (0, checkbox_1.bindGroupTitleCheckboxChange)(this.table), 
        (0, checkbox_1.bindHeaderCheckboxChange)(this.table), (0, button_1.bindButtonClickEvent)(this.table), 
        (0, right_button_click_1.rightButtonClickEvent)(this.table));
    }
    dealTableHover(eventArgsSet) {
        if (!eventArgsSet) return void this.table.stateManager.updateHoverPos(-1, -1);
        const {eventArgs: eventArgs} = eventArgsSet;
        eventArgs ? this.table.stateManager.updateHoverPos(eventArgs.col, eventArgs.row) : this.table.stateManager.updateHoverPos(-1, -1);
    }
    dealIconHover(eventArgsSet) {
        const {eventArgs: eventArgs} = eventArgsSet;
        eventArgs ? this.table.stateManager.updateHoverIcon(eventArgs.col, eventArgs.row, eventArgs.target, eventArgs.targetCell) : this.table.stateManager.updateHoverIcon(-1, -1, void 0, void 0);
    }
    dealMenuHover(eventArgsSet) {}
    dealTableSelect(eventArgsSet, isSelectMoving) {
        var _a, _b, _c, _d, _e;
        if (!eventArgsSet) return this.table.stateManager.updateSelectPos(-1, -1), !1;
        const {eventArgs: eventArgs} = eventArgsSet;
        if (eventArgs) {
            if ("checkbox" === eventArgs.target.name || "radio" === eventArgs.target.name || "switch" === eventArgs.target.name || "button" === eventArgs.target.name) return !1;
            if (this.table.isHeader(eventArgs.col, eventArgs.row) && (0, is_cell_select_highlight_1.isCellDisableSelect)(this.table, eventArgs.col, eventArgs.row)) return isSelectMoving || this.table.stateManager.updateSelectPos(-1, -1), 
            !1;
            if (!this.table.isHeader(eventArgs.col, eventArgs.row) && (0, is_cell_select_highlight_1.isCellDisableSelect)(this.table, eventArgs.col, eventArgs.row)) {
                if (!isSelectMoving) {
                    const isHasSelected = !!(null === (_a = this.table.stateManager.select.ranges) || void 0 === _a ? void 0 : _a.length);
                    this.table.stateManager.updateSelectPos(-1, -1), isHasSelected && this.table.stateManager.endSelectCells(!0, isHasSelected);
                }
                return !1;
            }
            return !this.table.isPivotChart() || "axis-label" !== (null === (_b = null == eventArgsSet ? void 0 : eventArgsSet.eventArgs) || void 0 === _b ? void 0 : _b.target.name) && "chart" !== (null === (_c = null == eventArgsSet ? void 0 : eventArgsSet.eventArgs) || void 0 === _c ? void 0 : _c.target.type) ? (this.table.stateManager.updateSelectPos(eventArgs.col, eventArgs.row, eventArgs.event.shiftKey, eventArgs.event.ctrlKey || eventArgs.event.metaKey, !1, !isSelectMoving && (null === (_e = null === (_d = this.table.options.select) || void 0 === _d ? void 0 : _d.makeSelectCellVisible) || void 0 === _e || _e)), 
            !0) : (this.table.stateManager.updateSelectPos(-1, -1), !1);
        }
        return !1;
    }
    dealFillSelect(eventArgsSet, isSelectMoving) {
        var _a, _b;
        const {eventArgs: eventArgs} = eventArgsSet;
        if (eventArgs) {
            if ((null === (_b = null === (_a = this.table.stateManager.select) || void 0 === _a ? void 0 : _a.ranges) || void 0 === _b ? void 0 : _b.length) && this.table.stateManager.isFillHandle()) {
                let updateRow, updateCol;
                const currentRange = this.table.stateManager.select.ranges[this.table.stateManager.select.ranges.length - 1];
                isSelectMoving && ((0, vutils_1.isValid)(this.table.stateManager.fillHandle.directionRow) || (Math.abs(this.table.stateManager.fillHandle.startY - eventArgsSet.abstractPos.y) >= Math.abs(this.table.stateManager.fillHandle.startX - eventArgsSet.abstractPos.x) ? this.table.stateManager.fillHandle.directionRow = !0 : this.table.stateManager.fillHandle.directionRow = !1), 
                Math.abs(this.table.stateManager.fillHandle.startY - eventArgsSet.abstractPos.y) >= Math.abs(this.table.stateManager.fillHandle.startX - eventArgsSet.abstractPos.x) ? this.table.stateManager.fillHandle.startY - eventArgsSet.abstractPos.y > 0 ? this.table.stateManager.fillHandle.direction = "top" : this.table.stateManager.fillHandle.direction = "bottom" : this.table.stateManager.fillHandle.startX - eventArgsSet.abstractPos.x > 0 ? this.table.stateManager.fillHandle.direction = "left" : this.table.stateManager.fillHandle.direction = "right", 
                this.table.stateManager.fillHandle.directionRow ? (updateRow = eventArgs.row, updateCol = currentRange.end.col) : (updateRow = currentRange.end.row, 
                updateCol = eventArgs.col)), this.table.stateManager.updateSelectPos(isSelectMoving ? updateCol : currentRange.end.col, isSelectMoving ? updateRow : currentRange.end.row, !0, eventArgs.event.ctrlKey || eventArgs.event.metaKey, !1, !isSelectMoving);
            } else this.table.stateManager.updateSelectPos(eventArgs.col, eventArgs.row, eventArgs.event.shiftKey, eventArgs.event.ctrlKey || eventArgs.event.metaKey, !1, !isSelectMoving);
            return !0;
        }
        return !1;
    }
    deelTableSelectAll() {
        this.table.stateManager.updateSelectPos(-1, -1, !1, !1, !0), this.table.fireListeners(TABLE_EVENT_TYPE_1.TABLE_EVENT_TYPE.SELECTED_CELL, {
            ranges: this.table.stateManager.select.ranges,
            col: 0,
            row: 0
        });
    }
    dealMenuSelect(eventArgsSet) {}
    checkColumnResize(eventArgsSet, update) {
        const {eventArgs: eventArgs} = eventArgsSet;
        if (this.table.options.enableTreeStickCell && !eventArgs) return !1;
        const resizeCol = this.table.scenegraph.getResizeColAt(eventArgsSet.abstractPos.x, eventArgsSet.abstractPos.y, null == eventArgs ? void 0 : eventArgs.targetCell);
        return this.table._canResizeColumn(resizeCol.col, resizeCol.row) && resizeCol.col >= 0 ? (update && this.table.stateManager.startResizeCol(resizeCol.col, eventArgsSet.abstractPos.x, eventArgsSet.abstractPos.y, resizeCol.rightFrozen), 
        !0) : (this.table.stateManager.isResizeCol() && this.table.stateManager.endResizeCol(), 
        !1);
    }
    checkRowResize(eventArgsSet, update) {
        const {eventArgs: eventArgs} = eventArgsSet;
        if (eventArgs) {
            const resizeRow = this.table.scenegraph.getResizeRowAt(eventArgsSet.abstractPos.x, eventArgsSet.abstractPos.y, eventArgs.targetCell);
            if (this.table._canResizeRow(resizeRow.col, resizeRow.row) && resizeRow.row >= 0) return update && this.table.stateManager.startResizeRow(resizeRow.row, eventArgsSet.abstractPos.x, eventArgsSet.abstractPos.y, resizeRow.bottomFrozen), 
            !0;
        }
        return !1;
    }
    cellIsHeaderCheck(eventArgsSet, update) {
        const {eventArgs: eventArgs} = eventArgsSet, {col: col, row: row, target: target} = eventArgs;
        if (!this.table.isHeader(col, row)) return !1;
        return "checkbox" === this.table.getCellType(eventArgs.col, eventArgs.row) && "checkbox" === target.name;
    }
    checkCellFillhandle(eventArgsSet, update) {
        var _a, _b, _c, _d, _e;
        let isFillHandle = !1;
        if (isFillHandle = "function" == typeof (null === (_a = this.table.options.excelOptions) || void 0 === _a ? void 0 : _a.fillHandle) ? this.table.options.excelOptions.fillHandle({
            selectRanges: this.table.stateManager.select.ranges,
            table: this.table
        }) : null === (_b = this.table.options.excelOptions) || void 0 === _b ? void 0 : _b.fillHandle, 
        isFillHandle) {
            const {eventArgs: eventArgs} = eventArgsSet;
            if (eventArgs && (null === (_d = null === (_c = this.table.stateManager.select) || void 0 === _c ? void 0 : _c.ranges) || void 0 === _d ? void 0 : _d.length)) {
                const lastCol = Math.max(this.table.stateManager.select.ranges[this.table.stateManager.select.ranges.length - 1].start.col, this.table.stateManager.select.ranges[this.table.stateManager.select.ranges.length - 1].end.col), lastRow = Math.max(this.table.stateManager.select.ranges[this.table.stateManager.select.ranges.length - 1].start.row, this.table.stateManager.select.ranges[this.table.stateManager.select.ranges.length - 1].end.row), startCol = Math.min(this.table.stateManager.select.ranges[this.table.stateManager.select.ranges.length - 1].start.col, this.table.stateManager.select.ranges[this.table.stateManager.select.ranges.length - 1].end.col), startRow = Math.min(this.table.stateManager.select.ranges[this.table.stateManager.select.ranges.length - 1].start.row, this.table.stateManager.select.ranges[this.table.stateManager.select.ranges.length - 1].end.row);
                let lastCellBound;
                lastCellBound = lastCol < this.table.colCount - 1 ? this.table.scenegraph.highPerformanceGetCell(lastCol, lastRow).globalAABBBounds : this.table.scenegraph.highPerformanceGetCell(startCol - 1, lastRow).globalAABBBounds;
                const distanceX = Math.abs(eventArgsSet.abstractPos.x - lastCellBound.x2);
                lastCellBound = lastRow < this.table.rowCount - 1 ? this.table.scenegraph.highPerformanceGetCell(lastCol, lastRow).globalAABBBounds : this.table.scenegraph.highPerformanceGetCell(lastCol, startRow - 1).globalAABBBounds;
                const distanceY = Math.abs(eventArgsSet.abstractPos.y - lastCellBound.y2), squareSize = 18;
                if ((null === (_e = this.table.stateManager.fillHandle) || void 0 === _e ? void 0 : _e.isFilling) || distanceX <= squareSize / 2 && distanceY <= squareSize / 2) return update && this.table.stateManager.startFillSelect(eventArgsSet.abstractPos.x, eventArgsSet.abstractPos.y), 
                !0;
            }
        }
        return !1;
    }
    dealColumnResize(xInTable, yInTable) {
        this.table.stateManager.updateResizeCol(xInTable, yInTable);
    }
    dealRowResize(xInTable, yInTable) {
        this.table.stateManager.updateResizeRow(xInTable, yInTable);
    }
    checkColumnMover(eventArgsSet) {
        var _a;
        const {eventArgs: eventArgs} = eventArgsSet;
        return !(!eventArgs || !this.table._canDragHeaderPosition(eventArgs.col, eventArgs.row)) && (this.table.stateManager.startMoveCol(eventArgs.col, eventArgs.row, eventArgsSet.abstractPos.x, eventArgsSet.abstractPos.y, null === (_a = null == eventArgs ? void 0 : eventArgs.event) || void 0 === _a ? void 0 : _a.nativeEvent), 
        !0);
    }
    dealColumnMover(eventArgsSet) {
        var _a;
        const {eventArgs: eventArgs} = eventArgsSet;
        (0, vutils_1.isValid)(eventArgs.col) && (0, vutils_1.isValid)(eventArgs.row) && this.table.stateManager.updateMoveCol(eventArgs.col, eventArgs.row, eventArgsSet.abstractPos.x, eventArgsSet.abstractPos.y, null === (_a = null == eventArgs ? void 0 : eventArgs.event) || void 0 === _a ? void 0 : _a.nativeEvent);
    }
    startColumnResize(eventArgsSet) {}
    dealIconClick(e, eventArgsSet) {
        const {eventArgs: eventArgs} = eventArgsSet, {target: target, event: event, col: col, row: row} = eventArgs || {
            target: e.target,
            event: e,
            col: -1,
            row: -1
        }, icon = target;
        if (icon.role && icon.role.startsWith("icon-")) return this.table.fireListeners(TABLE_EVENT_TYPE_1.TABLE_EVENT_TYPE.ICON_CLICK, {
            name: icon.name,
            x: (icon.globalAABBBounds.x1 + icon.globalAABBBounds.x2) / 2,
            y: icon.globalAABBBounds.y2,
            col: col,
            row: row,
            funcType: icon.attribute.funcType,
            icon: icon,
            event: event
        }), !0;
        if (target instanceof vrender_1.RichText) {
            const icon = target.pickIcon(event.global);
            if (icon) return this.table.fireListeners(TABLE_EVENT_TYPE_1.TABLE_EVENT_TYPE.ICON_CLICK, {
                name: icon.attribute.id,
                x: icon.globalX + icon.globalAABBBounds.width() / 2,
                y: icon.globalY + icon.AABBBounds.height(),
                col: col,
                row: row,
                funcType: icon.attribute.funcType,
                icon: icon,
                event: event
            }), !0;
        }
        return !1;
    }
    release() {
        this.gesture.release(), this.globalEventListeners.forEach((item => {
            "document" === item.env ? document.removeEventListener(item.name, item.callback) : "body" === item.env ? document.body.removeEventListener(item.name, item.callback) : "window" === item.env ? window.removeEventListener(item.name, item.callback) : "vglobal" === item.env && vrender_1.vglobal.removeEventListener(item.name, item.callback);
        })), this.globalEventListeners = [];
    }
    enableScroll() {
        this._enableTableScroll = !0;
    }
    disableScroll() {
        this._enableTableScroll = !1;
    }
}

exports.EventManager = EventManager;
//# sourceMappingURL=event.js.map