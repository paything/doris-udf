"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.EventHandler = exports.ResizeObserver = void 0;

const debounce_1 = require("../tools/debounce"), env_1 = require("../tools/env");

let idCount = 1;

class ResizeObserver {
    constructor(element, cb, resizeTime) {
        var _a;
        if (this.resizeTime = 100, this.lastSize = {
            width: 0,
            height: 0
        }, this.mutationResize = () => {
            this.onResize();
        }, this.callBack = () => {
            const newSize = this.getSize();
            let windowSizeNotChange = !1;
            newSize.width === this.lastSize.width && newSize.height === this.lastSize.height && (windowSizeNotChange = !0), 
            this.lastSize = newSize, this.cb && this.cb(Object.assign(Object.assign({}, this.lastSize), {
                windowSizeNotChange: windowSizeNotChange
            }));
        }, this.onResize = () => {
            this.callBackDebounce();
        }, this.element = element, this.cb = cb, this.lastSize = this.getSize(), resizeTime && (this.resizeTime = Math.max(resizeTime, 16)), 
        this.callBackDebounce = (0, debounce_1.debounce)(this.callBack, this.resizeTime), 
        null === window || void 0 === window || window.addEventListener("resize", this.onResize), 
        "ResizeObserver" in window) {
            const ResizeObserverWindow = window.ResizeObserver;
            this.observer = new ResizeObserverWindow(this.mutationResize), null === (_a = this.observer) || void 0 === _a || _a.observe(this.element);
        } else "MutationObserver" in window && (this.observer = new MutationObserver(this.mutationResize), 
        this.observer.observe(this.element, {
            attributes: !0,
            attributeFilter: [ "style" ]
        }));
    }
    disConnect() {
        window.removeEventListener("resize", this.onResize), this.observer && (this.observer.disconnect(), 
        this.observer = void 0);
    }
    setSize(size) {
        this.lastSize = size;
    }
    checkSize() {
        const newSize = this.getSize();
        return newSize.width !== this.lastSize.width || newSize.height !== this.lastSize.height;
    }
    getSize() {
        return this.element ? {
            width: Math.floor(this.element.clientWidth),
            height: Math.floor(this.element.clientHeight)
        } : Object.assign({}, this.lastSize);
    }
}

exports.ResizeObserver = ResizeObserver;

class EventHandler {
    constructor() {
        this.listeners = {}, this.reseizeListeners = {};
    }
    on(target, type, listener, ...options) {
        if ("node" === env_1.Env.mode) return -1;
        const id = idCount++;
        if (null == target ? void 0 : target.addEventListener) if ("resize" !== type || target === window) null == target || target.addEventListener(type, listener, ...options); else {
            const resizeObserver = new ResizeObserver(target, listener, this.resizeTime);
            this.reseizeListeners[id] = resizeObserver;
        }
        const obj = {
            target: target,
            type: type,
            listener: listener,
            options: options
        };
        return this.listeners[id] = obj, id;
    }
    once(target, type, listener, ...options) {
        if ("node" === env_1.Env.mode) return -1;
        const id = this.on(target, type, ((...args) => {
            this.off(id), listener(...args);
        }), ...options);
        return id;
    }
    off(id) {
        var _a;
        if ("node" === env_1.Env.mode) return;
        if (null === id) return;
        const obj = null === (_a = this.listeners) || void 0 === _a ? void 0 : _a[id];
        obj && (delete this.listeners[id], obj.target.removeEventListener && obj.target.removeEventListener(obj.type, obj.listener, ...obj.options));
    }
    fire(target, type, ...args) {
        if ("node" !== env_1.Env.mode) for (const key in this.listeners) {
            const listener = this.listeners[key];
            listener.target === target && listener.type === type && listener.listener.call(listener.target, ...args);
        }
    }
    hasListener(target, type) {
        if ("node" === env_1.Env.mode) return !1;
        let result = !1;
        for (const key in this.listeners) {
            const listener = this.listeners[key];
            listener.target === target && listener.type === type && (result = !0);
        }
        return result;
    }
    clear() {
        if ("node" !== env_1.Env.mode) {
            for (const key in this.listeners) {
                const listener = this.listeners[key];
                listener.target.removeEventListener && listener.target.removeEventListener(listener.type, listener.listener, ...listener.options);
            }
            for (const key in this.reseizeListeners) {
                const resizeObserver = this.reseizeListeners[key];
                null == resizeObserver || resizeObserver.disConnect();
            }
            this.listeners = {};
        }
    }
    release() {
        "node" !== env_1.Env.mode && (this.clear(), this.listeners = {});
    }
}

exports.EventHandler = EventHandler;
//# sourceMappingURL=EventHandler.js.map