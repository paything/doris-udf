import type { ColorPropertyDefine } from '.';
import type { Either } from '../tools/helper';
import type { BaseTableAPI } from './base-table';
export interface TotalsStatus {
    isRowTotal: boolean;
    isRowSubTotal: boolean;
    isColTotal: boolean;
    isColSubTotal: boolean;
}
export declare enum AggregationType {
    RECORD = "RECORD",
    NONE = "NONE",
    SUM = "SUM",
    MIN = "MIN",
    MAX = "MAX",
    AVG = "AVG",
    COUNT = "COUNT",
    CUSTOM = "CUSTOM",
    RECALCULATE = "RECALCULATE"
}
export declare enum SortType {
    ASC = "ASC",
    DESC = "DESC",
    NORMAL = "NORMAL",
    desc = "desc",
    asc = "asc",
    normal = "normal"
}
export interface CalcTotals {
    aggregationType?: AggregationType;
}
export interface Total {
    showGrandTotals: boolean;
    showSubTotals: boolean;
    subTotalsDimensions?: string[];
    grandTotalLabel?: string;
    subTotalLabel?: string;
}
export interface Totals {
    row?: Total & {
        showGrandTotalsOnTop?: boolean;
        showSubTotalsOnTop?: boolean;
    };
    column?: Total & {
        showGrandTotalsOnLeft?: boolean;
        showSubTotalsOnLeft?: boolean;
    };
}
export interface SortTypeRule {
    sortField: string;
    sortType?: SortType;
}
export interface SortByRule {
    sortField: string;
    sortType?: SortType;
    sortBy?: string[];
}
export interface SortByIndicatorRule {
    sortField: string;
    sortType?: SortType;
    sortByIndicator?: string;
    query?: string[];
    sortFunc?: (value_a: string | number, value_b: string | number, path_a: string[], path_b: string[], sortType: SortType) => number;
}
export interface SortFuncRule {
    sortField: string;
    sortType?: SortType;
    sortFunc?: (a: any, b: any, sortType: SortType) => number;
}
export type SortRule = SortTypeRule | SortByRule | SortByIndicatorRule | SortFuncRule;
export type SortRules = SortRule[];
export interface FilterFuncRule {
    filterFunc?: (row: Record<string, any>) => boolean;
}
export interface FilterValueRule {
    filterKey?: string;
    filteredValues?: unknown[];
}
export type FilterRules = Either<FilterFuncRule, FilterValueRule>[];
export interface AggregationRule<T extends AggregationType> {
    indicatorKey: string;
    field: string[] | string;
    aggregationType: string | T;
    aggregationFun?: T extends AggregationType.CUSTOM ? (values: any[], records: any[]) => any : undefined;
    formatFun?: (value: number, col: number, row: number, table: BaseTableAPI) => number | string;
}
export type AggregationRules = AggregationRule<AggregationType>[];
export interface MappingRule {
    label?: LabelMapping;
    symbol?: SymbolMapping;
    bgColor?: MappingFuncRule;
}
export type MappingRules = MappingRule[];
export interface LabelMapping {
    text?: MappingFuncRule;
    color?: MappingFuncRule;
}
export interface SymbolMapping {
    shape?: 'circle' | 'rect';
    color?: MappingFuncRule;
    size?: MappingFuncRule;
}
export type MappingFuncRule = {
    indicatorKey: string;
    mapping?: ColorPropertyDefine;
};
export interface DerivedFieldRule {
    fieldName?: string;
    derivedFunc?: (record: Record<string, any>) => any;
}
export type DerivedFieldRules = DerivedFieldRule[];
export interface CalculateddFieldRule {
    key: string;
    dependIndicatorKeys: string[];
    calculateFun?: (dependFieldsValue: any) => any;
}
export type CalculateddFieldRules = CalculateddFieldRule[];
export interface IListTableDataConfig {
    groupByRules?: string[];
    filterRules?: FilterRules;
}
export interface IPivotTableDataConfig {
    aggregationRules?: AggregationRules;
    sortRules?: SortRules;
    filterRules?: FilterRules;
    totals?: Totals;
    mappingRules?: MappingRules;
    derivedFieldRules?: DerivedFieldRules;
    calculatedFieldRules?: CalculateddFieldRules;
}
export interface IPivotChartDataConfig extends IPivotTableDataConfig {
    collectValuesBy?: Record<string, CollectValueBy>;
    isPivotChart?: boolean;
    dimensionSortArray?: string[];
}
export type CollectValueBy = {
    by: string[];
    range?: boolean;
    sumBy?: string[];
    type?: 'xField' | 'yField' | undefined;
    sortBy?: string[];
    extendRange?: number | 'sum' | 'max';
};
export type CollectedValue = {
    max?: number;
    min?: number;
} | Array<string>;
export type Aggregation = {
    aggregationType: AggregationType;
    showOnTop?: boolean;
    formatFun?: (value: number, col: number, row: number, table: BaseTableAPI) => string | number;
};
export type CustomAggregation = {
    aggregationType: AggregationType.CUSTOM;
    aggregationFun: (values: any[], records: any[]) => any;
    showOnTop?: boolean;
    formatFun?: (value: number, col: number, row: number, table: BaseTableAPI) => string | number;
};
