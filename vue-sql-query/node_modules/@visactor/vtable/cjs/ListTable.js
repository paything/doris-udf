"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    void 0 === k2 && (k2 = k);
    var desc = Object.getOwnPropertyDescriptor(m, k);
    desc && !("get" in desc ? !m.__esModule : desc.writable || desc.configurable) || (desc = {
        enumerable: !0,
        get: function() {
            return m[k];
        }
    }), Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    void 0 === k2 && (k2 = k), o[k2] = m[k];
}), __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: !0,
        value: v
    });
} : function(o, v) {
    o.default = v;
}), __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (null != mod) for (var k in mod) "default" !== k && Object.prototype.hasOwnProperty.call(mod, k) && __createBinding(result, mod, k);
    return __setModuleDefault(result, mod), result;
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.ListTable = void 0;

const ts_types_1 = require("./ts-types"), layout_1 = require("./layout"), vutils_1 = require("@visactor/vutils"), tableHelper_1 = require("./core/tableHelper"), core_1 = require("./core"), TABLE_EVENT_TYPE_1 = require("./core/TABLE_EVENT_TYPE"), env_1 = require("./tools/env"), editors = __importStar(require("./edit/editors")), edit_manager_1 = require("./edit/edit-manager"), compute_row_height_1 = require("./scenegraph/layout/compute-row-height"), util_1 = require("./tools/util"), radio_1 = require("./state/radio/radio"), vutils_extension_1 = require("@visactor/vutils-extension"), checkbox_1 = require("./state/checkbox/checkbox"), factory_1 = require("./core/factory"), group_helper_1 = require("./core/group-helper"), data_1 = require("./data"), record_helper_1 = require("./core/record-helper"), update_row_1 = require("./tools/update-row"), chart_render_helper_1 = require("./scenegraph/graphic/contributions/chart-render-helper");

class ListTable extends core_1.BaseTable {
    constructor(container, options) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        super(container, options), this.showHeader = !0, options = this.options;
        const internalProps = this.internalProps;
        if (internalProps.frozenColDragHeaderMode = null !== (_b = null === (_a = options.dragOrder) || void 0 === _a ? void 0 : _a.frozenColDragHeaderMode) && void 0 !== _b ? _b : options.frozenColDragHeaderMode, 
        this.pagination = options.pagination, internalProps.sortState = options.sortState, 
        internalProps.multipleSort = !!options.multipleSort, internalProps.dataConfig = options.groupBy ? (0, 
        group_helper_1.getGroupByDataConfig)(options.groupBy) : {}, internalProps.columns = options.columns ? (0, 
        vutils_extension_1.cloneDeepSpec)(options.columns, [ "children" ]) : options.header ? (0, 
        vutils_extension_1.cloneDeepSpec)(options.header, [ "children" ]) : [], (0, tableHelper_1.generateAggregationForColumn)(this), 
        internalProps.enableTreeNodeMerge = null !== (_d = null !== (_c = options.enableTreeNodeMerge) && void 0 !== _c ? _c : (0, 
        vutils_1.isValid)(options.groupBy)) && void 0 !== _d && _d, this.internalProps.headerHelper.setTableColumnsEditor(), 
        this.showHeader = null === (_e = options.showHeader) || void 0 === _e || _e, this.internalProps.columnWidthConfig = options.columnWidthConfig, 
        this.transpose = null !== (_f = options.transpose) && void 0 !== _f && _f, "node" !== env_1.Env.mode && (this.editorManager = new edit_manager_1.EditManager(this)), 
        this.refreshHeader(), this.internalProps.useOneRowHeightFillAll = !1, options.dataSource ? this.dataSource = options.dataSource : options.records ? this.setRecords(options.records, {
            sortState: internalProps.sortState
        }) : this.setRecords([]), options.title) {
            const Title = factory_1.Factory.getComponent("title");
            internalProps.title = new Title(options.title, this), this.scenegraph.resize();
        }
        if (this.options.emptyTip) if (this.internalProps.emptyTip) null === (_g = this.internalProps.emptyTip) || void 0 === _g || _g.resetVisible(); else {
            const EmptyTip = factory_1.Factory.getComponent("emptyTip");
            this.internalProps.emptyTip = new EmptyTip(this.options.emptyTip, this), null === (_h = this.internalProps.emptyTip) || void 0 === _h || _h.resetVisible();
        }
        if (options.enableTreeStickCell) {
            const ListTreeStickCellPlugin = factory_1.Factory.getComponent("listTreeStickCellPlugin");
            this.listTreeStickCellPlugin = new ListTreeStickCellPlugin(this);
        }
        setTimeout((() => {
            this.fireListeners(TABLE_EVENT_TYPE_1.TABLE_EVENT_TYPE.INITIALIZED, null);
        }), 0);
    }
    isListTable() {
        return !0;
    }
    isPivotTable() {
        return !1;
    }
    isPivotChart() {
        return !1;
    }
    get sortState() {
        return this.internalProps.sortState;
    }
    get records() {
        var _a;
        return null === (_a = this.dataSource) || void 0 === _a ? void 0 : _a.records;
    }
    get recordsCount() {
        return this.dataSource.records.length;
    }
    updateColumns(columns) {
        var _a, _b, _c, _d;
        this.scenegraph.clearCells();
        const oldHoverState = {
            col: this.stateManager.hover.cellPos.col,
            row: this.stateManager.hover.cellPos.row
        };
        this.internalProps.columns = (0, vutils_extension_1.cloneDeepSpec)(columns, [ "children" ]), 
        (0, tableHelper_1.generateAggregationForColumn)(this), this.options.columns = columns, 
        this.internalProps.headerHelper.setTableColumnsEditor(), this._hasAutoImageColumn = void 0, 
        this.refreshHeader(), null === (_b = (_a = this.dataSource).updateColumns) || void 0 === _b || _b.call(_a, this.internalProps.columns), 
        this.records && (0, tableHelper_1.checkHasAggregationOnColumnDefine)(columns) && this.dataSource.processRecords(null !== (_d = null === (_c = this.dataSource.dataSourceObj) || void 0 === _c ? void 0 : _c.records) && void 0 !== _d ? _d : this.dataSource.dataSourceObj), 
        this.internalProps.useOneRowHeightFillAll = !1, this.headerStyleCache = new Map, 
        this.bodyStyleCache = new Map, this.bodyBottomStyleCache = new Map, this.scenegraph.createSceneGraph(), 
        this.stateManager.updateHoverPos(oldHoverState.col, oldHoverState.row), this.renderAsync(), 
        this.eventManager.updateEventBinder();
    }
    addColumn(column) {
        const columns = this.options.columns;
        columns.push(column), this.updateColumns(columns);
    }
    get columns() {
        return this.internalProps.layoutMap.columnTree.getCopiedTree();
    }
    get header() {
        return this.internalProps.columns;
    }
    set header(header) {
        this.internalProps.columns = header, (0, tableHelper_1.generateAggregationForColumn)(this), 
        this.options.header = header, this.refreshHeader(), this.internalProps.useOneRowHeightFillAll = !1, 
        this.renderAsync();
    }
    get transpose() {
        var _a;
        return null !== (_a = this.internalProps.transpose) && void 0 !== _a && _a;
    }
    set transpose(transpose) {
        this.internalProps.transpose !== transpose && (this.internalProps.transpose = transpose, 
        this.internalProps.layoutMap && (this.internalProps.layoutMap.transpose = transpose, 
        this.refreshRowColCount(), this._resetFrozenColCount(), this.renderAsync()));
    }
    getCellValue(col, row, skipCustomMerge) {
        if (-1 === col || -1 === row) return null;
        if (!skipCustomMerge) {
            const customMergeText = this.getCustomMergeValue(col, row);
            if (customMergeText) return customMergeText;
        }
        const table = this;
        if (table.internalProps.layoutMap.isSeriesNumber(col, row)) {
            if (table.internalProps.layoutMap.isSeriesNumberInHeader(col, row)) {
                const {title: title} = table.internalProps.layoutMap.getSeriesNumberHeader(col, row);
                return title;
            }
            let value;
            if (this.options.groupBy) {
                const record = table.getCellRawRecord(col, row);
                if (null == record ? void 0 : record.vtableMerge) return "";
                table.internalProps.layoutMap.isAggregation(col, row) || (value = this.dataSource.getGroupSeriesNumber(row - this.columnHeaderLevelCount));
            } else value = row - this.columnHeaderLevelCount + 1;
            const {format: format} = table.internalProps.layoutMap.getSeriesNumberBody(col, row);
            return "function" == typeof format ? format(col, row, this, value) : value;
        }
        if (table.internalProps.layoutMap.isHeader(col, row)) {
            const {title: title} = table.internalProps.layoutMap.getHeader(col, row);
            return "function" == typeof title ? title() : title;
        }
        if (table.internalProps.layoutMap.isAggregation(col, row)) {
            if (table.internalProps.layoutMap.isTopAggregation(col, row)) {
                const aggregator = table.internalProps.layoutMap.getAggregatorOnTop(col, row);
                return (null == aggregator ? void 0 : aggregator.formatValue) ? aggregator.formatValue(col, row, this) : "";
            }
            if (table.internalProps.layoutMap.isBottomAggregation(col, row)) {
                const aggregator = table.internalProps.layoutMap.getAggregatorOnBottom(col, row);
                return (null == aggregator ? void 0 : aggregator.formatValue) ? aggregator.formatValue(col, row, this) : "";
            }
        }
        const {field: field, fieldFormat: fieldFormat} = table.internalProps.layoutMap.getBody(col, row);
        return table.getFieldData(fieldFormat || field, col, row);
    }
    getCellOriginValue(col, row) {
        if (-1 === col || -1 === row) return null;
        const table = this;
        if (table.internalProps.layoutMap.isSeriesNumber(col, row)) {
            if (table.internalProps.layoutMap.isSeriesNumberInHeader(col, row)) {
                const {title: title} = table.internalProps.layoutMap.getSeriesNumberHeader(col, row);
                return title;
            }
            const {format: format} = table.internalProps.layoutMap.getSeriesNumberBody(col, row);
            return "function" == typeof format ? format(col, row, this) : row - this.columnHeaderLevelCount;
        }
        if (table.internalProps.layoutMap.isHeader(col, row)) {
            const {title: title} = table.internalProps.layoutMap.getHeader(col, row);
            return "function" == typeof title ? title() : title;
        }
        if (table.internalProps.layoutMap.isAggregation(col, row)) {
            if (table.internalProps.layoutMap.isTopAggregation(col, row)) {
                const aggregator = table.internalProps.layoutMap.getAggregatorOnTop(col, row);
                return null == aggregator ? void 0 : aggregator.value();
            }
            if (table.internalProps.layoutMap.isBottomAggregation(col, row)) {
                const aggregator = table.internalProps.layoutMap.getAggregatorOnBottom(col, row);
                return null == aggregator ? void 0 : aggregator.value();
            }
        }
        const {field: field} = table.internalProps.layoutMap.getBody(col, row);
        return table.getFieldData(field, col, row);
    }
    getCellRawValue(col, row) {
        if (-1 === col || -1 === row) return null;
        const table = this;
        if (table.internalProps.layoutMap.isHeader(col, row)) {
            const {title: title} = table.internalProps.layoutMap.getHeader(col, row);
            return "function" == typeof title ? title() : title;
        }
        const {field: field} = table.internalProps.layoutMap.getBody(col, row);
        return table.getRawFieldData(field, col, row);
    }
    getRecordShowIndexByCell(col, row) {
        const {layoutMap: layoutMap} = this.internalProps;
        return layoutMap.getRecordShowIndexByCell(col, row);
    }
    getRecordIndexByCell(col, row) {
        const {layoutMap: layoutMap} = this.internalProps, recordShowIndex = layoutMap.getRecordShowIndexByCell(col, row);
        return this.dataSource.getRecordIndexPaths(recordShowIndex);
    }
    getTableIndexByRecordIndex(recordIndex) {
        return this.transpose ? this.dataSource.getTableIndex(recordIndex) + this.rowHeaderLevelCount : this.dataSource.getTableIndex(recordIndex) + this.columnHeaderLevelCount;
    }
    getTableIndexByField(field) {
        const colObj = this.internalProps.layoutMap.columnObjects.find((col => col.field === field));
        if (!colObj) return -1;
        const layoutRange = this.internalProps.layoutMap.getBodyLayoutRangeById(colObj.id);
        return this.transpose ? layoutRange.start.row : layoutRange.start.col;
    }
    getCellAddrByFieldRecord(field, recordIndex) {
        return this.transpose ? {
            col: this.getTableIndexByRecordIndex(recordIndex),
            row: this.getTableIndexByField(field)
        } : {
            col: this.getTableIndexByField(field),
            row: this.getTableIndexByRecordIndex(recordIndex)
        };
    }
    getCellOriginRecord(col, row) {
        const table = this, index = table.getRecordShowIndexByCell(col, row);
        if (index > -1) return table.dataSource.get(index);
    }
    getCellRawRecord(col, row) {
        const table = this, index = table.getRecordShowIndexByCell(col, row);
        if (index > -1) return table.dataSource.getRaw(index);
    }
    _canResizeColumn(col, row) {
        const ifCan = super._canResizeColumn(col, row);
        if (ifCan && !this.transpose) {
            const cellDefine = this.internalProps.layoutMap.getBody(col, this.columnHeaderLevelCount), isSeriesNumber = this.internalProps.layoutMap.isSeriesNumber(col, row);
            if (null == cellDefine ? void 0 : cellDefine.disableColumnResize) return !1;
            if (isSeriesNumber && !0 === this.internalProps.rowSeriesNumber.disableColumnResize) return !1;
        }
        return ifCan;
    }
    updateOption(options) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const internalProps = this.internalProps;
        if (super.updateOption(options), internalProps.frozenColDragHeaderMode = null !== (_b = null === (_a = options.dragOrder) || void 0 === _a ? void 0 : _a.frozenColDragHeaderMode) && void 0 !== _b ? _b : options.frozenColDragHeaderMode, 
        this.pagination = options.pagination, internalProps.sortState = options.sortState, 
        internalProps.dataConfig = options.groupBy ? (0, group_helper_1.getGroupByDataConfig)(options.groupBy) : {}, 
        this.showHeader = null === (_c = options.showHeader) || void 0 === _c || _c, internalProps.columns = options.columns ? (0, 
        vutils_extension_1.cloneDeepSpec)(options.columns, [ "children" ]) : options.header ? (0, 
        vutils_extension_1.cloneDeepSpec)(options.header, [ "children" ]) : [], (0, tableHelper_1.generateAggregationForColumn)(this), 
        internalProps.enableTreeNodeMerge = null !== (_e = null !== (_d = options.enableTreeNodeMerge) && void 0 !== _d ? _d : (0, 
        vutils_1.isValid)(options.groupBy)) && void 0 !== _e && _e, this.internalProps.headerHelper.setTableColumnsEditor(), 
        this.transpose = null !== (_f = options.transpose) && void 0 !== _f && _f, this.refreshHeader(), 
        this.internalProps.useOneRowHeightFillAll = !1, this.internalProps.columnWidthConfig = options.columnWidthConfig, 
        internalProps.releaseList) for (let i = internalProps.releaseList.length - 1; i >= 0; i--) {
            const releaseObj = internalProps.releaseList[i];
            releaseObj instanceof data_1.DataSource ? releaseObj.updateColumns(this.internalProps.columns) : (null === (_g = null == releaseObj ? void 0 : releaseObj.release) || void 0 === _g || _g.call(releaseObj), 
            internalProps.releaseList.splice(i, 1));
        }
        if (options.dataSource && this.dataSource !== options.dataSource ? this.dataSource = options.dataSource : options.records ? this.setRecords(options.records, {
            sortState: options.sortState
        }) : (this.refreshRowColCount(), this._resetFrozenColCount(), this.scenegraph.createSceneGraph(), 
        this.render()), options.title) {
            const Title = factory_1.Factory.getComponent("title");
            internalProps.title = new Title(options.title, this), this.scenegraph.resize();
        }
        if (this.options.emptyTip) if (this.internalProps.emptyTip) null === (_h = this.internalProps.emptyTip) || void 0 === _h || _h.resetVisible(); else {
            const EmptyTip = factory_1.Factory.getComponent("emptyTip");
            this.internalProps.emptyTip = new EmptyTip(this.options.emptyTip, this), null === (_j = this.internalProps.emptyTip) || void 0 === _j || _j.resetVisible();
        }
        return this.pluginManager.updatePlugins(options.plugins), new Promise((resolve => {
            setTimeout(resolve, 0);
        }));
    }
    updatePagination(pagination) {
        this.pagination && ("number" == typeof pagination.currentPage && pagination.currentPage >= 0 && (this.pagination.currentPage = pagination.currentPage), 
        pagination.perPageCount && (this.pagination.perPageCount = pagination.perPageCount || this.pagination.perPageCount), 
        this.internalProps.layoutMap.clearCellRangeMap(), this.internalProps.useOneRowHeightFillAll = !1, 
        this.scenegraph.clearCells(), this.dataSource.updatePagination(this.pagination), 
        this.refreshRowColCount(), this.stateManager.initCheckedState(this.records), this.scenegraph.createSceneGraph(), 
        this.renderAsync());
    }
    refreshHeader() {
        var _a;
        const internalProps = this.internalProps, transpose = this.transpose, showHeader = this.showHeader;
        (internalProps.layoutMap = new layout_1.SimpleHeaderLayoutMap(this, null !== (_a = internalProps.columns) && void 0 !== _a ? _a : [], showHeader, this.options.hierarchyIndent)).transpose = transpose, 
        transpose || this.setMinMaxLimitWidth(!0), this.refreshRowColCount();
    }
    refreshRowColCount() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
        const table = this, {layoutMap: layoutMap} = table.internalProps;
        if (!layoutMap) return;
        const dataCount = null !== (_b = null === (_a = table.internalProps.dataSource) || void 0 === _a ? void 0 : _a.length) && void 0 !== _b ? _b : 0;
        layoutMap.recordsCount = dataCount + (dataCount > 0 || this.options.showAggregationWhenEmpty ? layoutMap.hasAggregationOnTopCount + layoutMap.hasAggregationOnBottomCount : 0), 
        table.transpose ? (table.rowCount = null !== (_c = layoutMap.rowCount) && void 0 !== _c ? _c : 0, 
        table.colCount = null !== (_d = layoutMap.colCount) && void 0 !== _d ? _d : 0, this.internalProps.frozenColCount = Math.max((null !== (_e = layoutMap.headerLevelCount) && void 0 !== _e ? _e : 0) + layoutMap.leftRowSeriesNumberColumnCount, null !== (_f = this.options.frozenColCount) && void 0 !== _f ? _f : 0), 
        this.internalProps.frozenRowCount = null !== (_g = this.options.frozenRowCount) && void 0 !== _g ? _g : 0, 
        table.bottomFrozenRowCount !== (null !== (_h = this.options.bottomFrozenRowCount) && void 0 !== _h ? _h : 0) && (table.bottomFrozenRowCount = null !== (_j = this.options.bottomFrozenRowCount) && void 0 !== _j ? _j : 0), 
        table.rightFrozenColCount !== (null !== (_k = this.options.rightFrozenColCount) && void 0 !== _k ? _k : 0) && (table.rightFrozenColCount = null !== (_l = this.options.rightFrozenColCount) && void 0 !== _l ? _l : 0)) : (table.colCount = null !== (_m = layoutMap.colCount) && void 0 !== _m ? _m : 0, 
        table.rowCount = layoutMap.recordsCount * layoutMap.bodyRowSpanCount + layoutMap.headerLevelCount, 
        this.internalProps.frozenColCount = null !== (_o = this.options.frozenColCount) && void 0 !== _o ? _o : 0, 
        table.frozenRowCount = Math.max(layoutMap.headerLevelCount, null !== (_p = this.options.frozenRowCount) && void 0 !== _p ? _p : 0), 
        table.bottomFrozenRowCount !== (null !== (_q = this.options.bottomFrozenRowCount) && void 0 !== _q ? _q : 0) && (table.bottomFrozenRowCount = null !== (_r = this.options.bottomFrozenRowCount) && void 0 !== _r ? _r : 0), 
        table.rightFrozenColCount !== (null !== (_s = this.options.rightFrozenColCount) && void 0 !== _s ? _s : 0) && (table.rightFrozenColCount = null !== (_t = this.options.rightFrozenColCount) && void 0 !== _t ? _t : 0)), 
        this.stateManager.setFrozenCol(this.internalProps.frozenColCount);
    }
    getFieldData(field, col, row) {
        if (null === field) return null;
        if (this.internalProps.layoutMap.isHeader(col, row)) return null;
        const index = this.getRecordShowIndexByCell(this.transpose ? col - this.internalProps.layoutMap.leftRowSeriesNumberColumnCount : col, row);
        return this.internalProps.dataSource.getField(index, field, col, row, this);
    }
    getRawFieldData(field, col, row) {
        if (null === field) return null;
        if (this.internalProps.layoutMap.isHeader(col, row)) return null;
        const index = this.getRecordShowIndexByCell(col, row);
        return this.internalProps.dataSource.getRawField(index, field, col, row, this);
    }
    _moveHeaderPosition(source, target) {
        const sourceCellRange = this.getCellRange(source.col, source.row), targetCellRange = this.getCellRange(target.col, target.row), moveContext = this.internalProps.layoutMap.moveHeaderPosition(source, target);
        return moveContext ? ("column" === moveContext.moveType ? (this.colWidthsMap.exchangeOrder(sourceCellRange.start.col, sourceCellRange.end.col - sourceCellRange.start.col + 1, targetCellRange.start.col, targetCellRange.end.col - targetCellRange.start.col + 1, moveContext.targetIndex), 
        this.transpose || (this.colWidthsLimit = {}, this.setMinMaxLimitWidth())) : moveContext.targetIndex > moveContext.sourceIndex ? this.rowHeightsMap.exchangeOrder(moveContext.sourceIndex, moveContext.sourceSize, moveContext.targetIndex + moveContext.sourceSize - moveContext.targetSize, moveContext.targetSize, moveContext.targetIndex) : this.rowHeightsMap.exchangeOrder(moveContext.sourceIndex, moveContext.sourceSize, moveContext.targetIndex, moveContext.targetSize, moveContext.targetIndex), 
        moveContext) : null;
    }
    changeRecordOrder(sourceIndex, targetIndex) {
        this.transpose ? (sourceIndex = this.getRecordShowIndexByCell(sourceIndex, 0), targetIndex = this.getRecordShowIndexByCell(targetIndex, 0)) : (sourceIndex = this.getRecordShowIndexByCell(0, sourceIndex), 
        targetIndex = this.getRecordShowIndexByCell(0, targetIndex)), this.dataSource.changeOrder(sourceIndex, targetIndex);
    }
    getCellAddress(findTargetRecord, field) {
        let targetRecordIndex;
        for (let i = 0; i < this.internalProps.records.length; i++) {
            const record = this.internalProps.records[i];
            if ("function" == typeof findTargetRecord) findTargetRecord(record) && (targetRecordIndex = i); else {
                let isAllRight = !0;
                for (const prop in findTargetRecord) if (record[prop] !== findTargetRecord[prop]) {
                    isAllRight = !1;
                    break;
                }
                isAllRight && (targetRecordIndex = i);
            }
            if ((0, vutils_1.isValid)(targetRecordIndex)) break;
        }
        const cellRange = this.getCellRangeByField(field, targetRecordIndex);
        if (cellRange) return {
            row: cellRange.start.row,
            col: cellRange.start.col
        };
    }
    getCellRangeByField(field, index) {
        const {layoutMap: layoutMap} = this.internalProps, colObj = layoutMap.columnObjects.find((col => col.field === field));
        if (colObj) {
            const layoutRange = layoutMap.getBodyLayoutRangeById(colObj.id);
            let startRow;
            return (0, vutils_1.isValid)(index) && (startRow = layoutMap.getRecordStartRowByRecordIndex(index)), 
            this.transpose ? {
                start: {
                    row: layoutRange.start.row,
                    col: (0, vutils_1.isValid)(startRow) ? startRow + layoutRange.start.col : void 0
                },
                end: {
                    row: layoutRange.end.row,
                    col: (0, vutils_1.isValid)(startRow) ? startRow + layoutRange.end.col : void 0
                }
            } : {
                start: {
                    col: layoutRange.start.col,
                    row: (0, vutils_1.isValid)(startRow) ? startRow + layoutRange.start.row : void 0
                },
                end: {
                    col: layoutRange.end.col,
                    row: (0, vutils_1.isValid)(startRow) ? startRow + layoutRange.end.row : void 0
                }
            };
        }
        return null;
    }
    getHierarchyState(col, row) {
        var _a;
        if (this.isHeader(col, row)) return null === (_a = this._getHeaderLayoutMap(col, row)) || void 0 === _a ? void 0 : _a.hierarchyState;
        if (!this.options.groupBy || (0, vutils_1.isArray)(this.options.groupBy) && 0 === this.options.groupBy.length) {
            if (!this.getBodyColumnDefine(col, row).tree) return ts_types_1.HierarchyState.none;
        }
        const index = this.getRecordShowIndexByCell(col, row);
        return this.dataSource.getHierarchyState(index);
    }
    toggleHierarchyState(col, row, recalculateColWidths = !0) {
        this.stateManager.updateHoverIcon(col, row, void 0, void 0);
        const hierarchyState = this.getHierarchyState(col, row);
        if (this.isHeader(col, row)) {
            const headerTreeNode = this.internalProps.layoutMap.getHeader(col, row), {hierarchyState: rawHierarchyState, define: columnDefine} = headerTreeNode;
            if (![ ts_types_1.HierarchyState.collapse, ts_types_1.HierarchyState.expand ].includes(rawHierarchyState) || !columnDefine) return;
            const children = columnDefine.columns;
            if (Array.isArray(children) && children.length > 0) {
                const hierarchyState = rawHierarchyState === ts_types_1.HierarchyState.expand ? ts_types_1.HierarchyState.collapse : ts_types_1.HierarchyState.expand;
                headerTreeNode.hierarchyState = hierarchyState, headerTreeNode.define.hierarchyState = hierarchyState, 
                this.updateColumns(this.internalProps.columns);
            }
            this.fireListeners(TABLE_EVENT_TYPE_1.TABLE_EVENT_TYPE.TREE_HIERARCHY_STATE_CHANGE, {
                col: col,
                row: row,
                hierarchyState: hierarchyState,
                originData: headerTreeNode,
                cellLocation: this.getCellLocation(col, row)
            });
        } else if (hierarchyState === ts_types_1.HierarchyState.expand) this._refreshHierarchyState(col, row, recalculateColWidths), 
        this.fireListeners(TABLE_EVENT_TYPE_1.TABLE_EVENT_TYPE.TREE_HIERARCHY_STATE_CHANGE, {
            col: col,
            row: row,
            hierarchyState: ts_types_1.HierarchyState.collapse
        }); else if (hierarchyState === ts_types_1.HierarchyState.collapse) {
            const record = this.getCellOriginRecord(col, row);
            Array.isArray(record.children) && this._refreshHierarchyState(col, row, recalculateColWidths), 
            this.fireListeners(TABLE_EVENT_TYPE_1.TABLE_EVENT_TYPE.TREE_HIERARCHY_STATE_CHANGE, {
                col: col,
                row: row,
                hierarchyState: ts_types_1.HierarchyState.expand,
                originData: record
            });
        }
    }
    setLoadingHierarchyState(col, row) {
        this.scenegraph.setLoadingHierarchyState(col, row);
    }
    _refreshHierarchyState(col, row, recalculateColWidths = !0) {
        var _a, _b;
        let notFillWidth = !1, notFillHeight = !1;
        const checkHasChart = this.internalProps.layoutMap.checkHasChart();
        checkHasChart && (this.autoFillWidth && (notFillWidth = this.getAllColsWidth() <= this.tableNoFrameWidth), 
        this.autoFillHeight && (notFillHeight = this.getAllRowsHeight() <= this.tableNoFrameHeight));
        const index = this.getRecordShowIndexByCell(col, row), diffDataIndices = this.dataSource.toggleHierarchyState(index, this.scenegraph.proxy.rowStart - this.columnHeaderLevelCount, Math.max(this.scenegraph.proxy.rowEnd - this.columnHeaderLevelCount, this.scenegraph.proxy.rowStart - this.columnHeaderLevelCount + this.scenegraph.proxy.rowLimit - 1)), diffPositions = this.internalProps.layoutMap.toggleHierarchyState(diffDataIndices);
        this.refreshRowColCount();
        for (let row = this.rowCount - this.bottomFrozenRowCount; row < this.rowCount; row++) {
            const newHeight = (0, compute_row_height_1.computeRowHeight)(row, 0, this.colCount - 1, this);
            this._setRowHeight(row, newHeight);
        }
        this.clearCellStyleCache(), this.internalProps.layoutMap.clearCellRangeMap(), this.internalProps.useOneRowHeightFillAll = !1;
        const {updateCells: updateCells, addCells: addCells, removeCells: removeCells} = (0, 
        update_row_1.fixUpdateRowRange)(diffPositions, col, row, this);
        null === (_a = this.reactCustomLayout) || void 0 === _a || _a.clearCache(), this.scenegraph.updateRow(removeCells, addCells, updateCells, recalculateColWidths, !0), 
        null === (_b = this.reactCustomLayout) || void 0 === _b || _b.updateAllCustomCell(), 
        checkHasChart && (this.autoFillWidth && !notFillWidth && (notFillWidth = this.getAllColsWidth() <= this.tableNoFrameWidth), 
        this.autoFillHeight && !notFillHeight && (notFillHeight = this.getAllRowsHeight() <= this.tableNoFrameHeight), 
        ("adaptive" === this.widthMode || notFillWidth || "adaptive" === this.heightMode || notFillHeight) && this.scenegraph.updateChartSizeForResizeColWidth(-1));
    }
    _hasHierarchyTreeHeader() {
        var _a, _b;
        return null === (_b = null !== (_a = this.options.columns) && void 0 !== _a ? _a : this.options.header) || void 0 === _b ? void 0 : _b.some(((column, i) => column.tree));
    }
    getMenuInfo(col, row, type) {
        return {
            field: this.getHeaderField(col, row),
            value: this.getCellValue(col, row),
            cellLocation: this.getCellLocation(col, row),
            event: void 0
        };
    }
    _getSortFuncFromHeaderOption(columns, field, fieldKey) {
        if (columns || (columns = this.internalProps.columns), field && columns && columns.length > 0) for (let i = 0; i < columns.length; i++) {
            const header = columns[i];
            if ((fieldKey && fieldKey === header.fieldKey || !fieldKey && header.field === field) && header.sort && "function" == typeof header.sort) return header.sort;
            if (header.columns) {
                const sort = this._getSortFuncFromHeaderOption(header.columns, field, fieldKey);
                if (sort) return sort;
            }
        }
    }
    updateSortState(sortState, executeSort = !0) {
        var _a;
        if (sortState) this.internalProps.sortState = sortState; else if (this.internalProps.sortState) if (Array.isArray(this.internalProps.sortState)) for (let i = 0; i < this.internalProps.sortState.length; i++) (sortState = null === (_a = this.internalProps.sortState) || void 0 === _a ? void 0 : _a[i]) && (sortState.order = "normal"); else this.internalProps.sortState.order = "normal", 
        sortState = this.internalProps.sortState;
        (sortState = Array.isArray(sortState) ? sortState : [ sortState ]).some((item => item.field)) && executeSort && this.internalProps.layoutMap.headerObjects.some((item => !1 !== item.define.sort)) && (this.dataSource.sort(sortState.map((item => {
            const sortFunc = this._getSortFuncFromHeaderOption(this.internalProps.columns, item.field);
            this.internalProps.layoutMap.headerObjects.find((col => col && col.field === item.field));
            return {
                field: item.field,
                order: item.order,
                orderFn: null != sortFunc ? sortFunc : util_1.defaultOrderFn
            };
        }))), this.internalProps.layoutMap.clearCellRangeMap(), this.internalProps.useOneRowHeightFillAll = !1, 
        this.scenegraph.sortCell()), sortState.length && this.stateManager.updateSortState(sortState);
    }
    updateFilterRules(filterRules) {
        this.scenegraph.clearCells(), this.sortState ? (this.dataSource.updateFilterRulesForSorted(filterRules), 
        (0, record_helper_1.sortRecords)(this)) : this.dataSource.updateFilterRules(filterRules), 
        this.refreshRowColCount(), this.stateManager.initCheckedState(this.records), this.scenegraph.createSceneGraph();
    }
    getCheckboxState(field) {
        if (this.stateManager.checkedState.size < this.rowCount - this.columnHeaderLevelCount && this.stateManager.initLeftRecordsCheckState(this.records), 
        (0, vutils_1.isValid)(field)) {
            let stateArr = Array.from(this.stateManager.checkedState.keys()).sort(((a, b) => {
                var _a, _b;
                const aArr = a.split(","), bArr = b.split(","), maxLength = Math.max(aArr.length, bArr.length);
                for (let i = 0; i < maxLength; i++) {
                    const a = null !== (_a = Number(aArr[i])) && void 0 !== _a ? _a : 0, b = null !== (_b = Number(bArr[i])) && void 0 !== _b ? _b : 0;
                    if (a !== b) return a - b;
                }
                return 0;
            })).map((key => this.stateManager.checkedState.get(key)));
            return this.options.groupBy && (stateArr = (0, checkbox_1.getGroupCheckboxState)(this)), 
            Array.from(stateArr, (state => state && state[field]));
        }
        return new Array(...this.stateManager.checkedState.values());
    }
    getCellCheckboxState(col, row) {
        var _a;
        const define = this.getBodyColumnDefine(col, row), field = null == define ? void 0 : define.field, cellType = this.getCellType(col, row);
        if ((0, vutils_1.isValid)(field) && ("checkbox" === cellType || "switch" === cellType)) {
            const dataIndex = this.dataSource.getIndexKey(this.getRecordShowIndexByCell(col, row)).toString();
            return null === (_a = this.stateManager.checkedState.get(dataIndex)) || void 0 === _a ? void 0 : _a[field];
        }
    }
    getRadioState(field) {
        return (0, vutils_1.isValid)(field) ? this.stateManager.radioState[field] : this.stateManager.radioState;
    }
    getCellRadioState(col, row) {
        return (0, radio_1.getCellRadioState)(col, row, this);
    }
    setCellCheckboxState(col, row, checked) {
        (0, checkbox_1.setCellCheckboxState)(col, row, checked, this);
    }
    setCellRadioState(col, row, index) {
        (0, radio_1.setCellRadioState)(col, row, index, this);
    }
    getSwitchState(field) {
        return this.getCheckboxState(field);
    }
    getCellSwitchState(col, row) {
        return this.getCellCheckboxState(col, row);
    }
    setCellSwitchState(col, row, checked) {
        this.setCellCheckboxState(col, row, checked);
    }
    setRecords(records, option) {
        var _a, _b, _c, _d;
        let sort;
        (0, chart_render_helper_1.clearChartRenderQueue)(), null === (_a = this.internalProps.dataSource) || void 0 === _a || _a.release(), 
        this.internalProps.releaseList = null === (_b = this.internalProps.releaseList) || void 0 === _b ? void 0 : _b.filter((item => !item.dataSourceObj)), 
        this.internalProps.dataSource = null, Array.isArray(option) || (null == option ? void 0 : option.order) ? sort = option : option ? sort = option.sortState : null === option && (sort = null);
        "undefined" != typeof window && window.performance.now();
        const oldHoverState = {
            col: this.stateManager.hover.cellPos.col,
            row: this.stateManager.hover.cellPos.row
        };
        if (this.scenegraph.clearCells(), void 0 !== sort && (null === sort || !Array.isArray(sort) && (0, 
        vutils_1.isValid)(sort.field) || Array.isArray(sort)) && (this.internalProps.sortState = this.internalProps.multipleSort ? Array.isArray(sort) ? sort : [ sort ] : sort, 
        this.stateManager.setSortState(this.sortState)), records) {
            if ((0, tableHelper_1._setRecords)(this, records), this.sortState) {
                const sortState = Array.isArray(this.sortState) ? this.sortState : [ this.sortState ];
                sortState.some((item => item.order && item.field && "normal" !== item.order)) && this.internalProps.layoutMap.headerObjectsIncludeHided.some((item => !1 !== item.define.sort)) && this.dataSource.sort(sortState.map((item => {
                    const sortFunc = this._getSortFuncFromHeaderOption(void 0, item.field);
                    this.internalProps.layoutMap.headerObjectsIncludeHided.find((col => col && col.field === item.field));
                    return {
                        field: item.field,
                        order: item.order || "asc",
                        orderFn: null != sortFunc ? sortFunc : util_1.defaultOrderFn
                    };
                })));
            }
            this.refreshRowColCount();
        } else (0, tableHelper_1._setRecords)(this, records);
        if (this.stateManager.initCheckedState(records), this.clearCellStyleCache(), this.scenegraph.createSceneGraph(), 
        this.stateManager.updateHoverPos(oldHoverState.col, oldHoverState.row), this.internalProps.title && !this.internalProps.title.isReleased && (this._updateSize(), 
        this.internalProps.title.resize(), this.scenegraph.resize()), this.options.emptyTip) if (this.internalProps.emptyTip) null === (_c = this.internalProps.emptyTip) || void 0 === _c || _c.resetVisible(); else {
            const EmptyTip = factory_1.Factory.getComponent("emptyTip");
            this.internalProps.emptyTip = new EmptyTip(this.options.emptyTip, this), null === (_d = this.internalProps.emptyTip) || void 0 === _d || _d.resetVisible();
        }
        this.render(), (0, vutils_1.isValid)(oldHoverState.col) && (0, vutils_1.isValid)(oldHoverState.row) && oldHoverState.col >= 0 && oldHoverState.row >= 0 && setTimeout((() => {
            var _a;
            null === (_a = this.internalProps) || void 0 === _a || _a.tooltipHandler.showTooltip(oldHoverState.col, oldHoverState.row);
        }), 0);
    }
    setRecordChildren(records, col, row, recalculateColWidths = !0) {
        const record = this.getCellOriginRecord(col, row);
        record.children = records;
        const index = this.getRecordShowIndexByCell(col, row);
        this.dataSource.setRecord(record, index), this._refreshHierarchyState(col, row, recalculateColWidths);
    }
    startEditCell(col, row, value) {
        var _a;
        if ((0, vutils_1.isValid)(col) && (0, vutils_1.isValid)(row)) this.eventManager.isDraging = !1, 
        this.selectCell(col, row), this.editorManager.startEditCell(col, row, value); else if (null === (_a = this.stateManager.select) || void 0 === _a ? void 0 : _a.cellPos) {
            const {col: col, row: row} = this.stateManager.select.cellPos;
            (0, vutils_1.isValid)(col) && (0, vutils_1.isValid)(row) && this.editorManager.startEditCell(col, row, value);
        }
    }
    completeEditCell() {
        this.editorManager.completeEdit();
    }
    getEditor(col, row) {
        var _a, _b;
        const define = this.getBodyColumnDefine(col, row);
        let editorDefine = this.isHeader(col, row) ? null !== (_a = null == define ? void 0 : define.headerEditor) && void 0 !== _a ? _a : this.options.headerEditor : null !== (_b = null == define ? void 0 : define.editor) && void 0 !== _b ? _b : this.options.editor;
        if ("function" == typeof editorDefine) {
            editorDefine = editorDefine({
                col: col,
                row: row,
                dataValue: this.getCellOriginValue(col, row),
                value: this.getCellValue(col, row) || "",
                table: this
            });
        }
        return "string" == typeof editorDefine ? editors.get(editorDefine) : editorDefine;
    }
    isHasEditorDefine(col, row) {
        var _a, _b;
        const define = this.getBodyColumnDefine(col, row);
        let editorDefine = this.isHeader(col, row) ? null !== (_a = null == define ? void 0 : define.headerEditor) && void 0 !== _a ? _a : this.options.headerEditor : null !== (_b = null == define ? void 0 : define.editor) && void 0 !== _b ? _b : this.options.editor;
        if ("function" == typeof editorDefine) {
            editorDefine = editorDefine({
                col: col,
                row: row,
                dataValue: this.getCellOriginValue(col, row),
                value: this.getCellValue(col, row) || "",
                table: this
            });
        }
        return (0, vutils_1.isValid)(editorDefine);
    }
    changeCellValue(col, row, value, workOnEditableCell = !1, triggerEvent = !0) {
        return (0, record_helper_1.listTableChangeCellValue)(col, row, value, workOnEditableCell, triggerEvent, this);
    }
    changeCellValues(startCol, startRow, values, workOnEditableCell = !1, triggerEvent = !0) {
        return (0, record_helper_1.listTableChangeCellValues)(startCol, startRow, values, workOnEditableCell, triggerEvent, this);
    }
    addRecord(record, recordIndex) {
        var _a;
        (0, record_helper_1.listTableAddRecord)(record, recordIndex, this), null === (_a = this.internalProps.emptyTip) || void 0 === _a || _a.resetVisible();
    }
    addRecords(records, recordIndex) {
        var _a;
        (0, record_helper_1.listTableAddRecords)(records, recordIndex, this), null === (_a = this.internalProps.emptyTip) || void 0 === _a || _a.resetVisible();
    }
    deleteRecords(recordIndexs) {
        var _a;
        (0, record_helper_1.listTableDeleteRecords)(recordIndexs, this), null === (_a = this.internalProps.emptyTip) || void 0 === _a || _a.resetVisible();
    }
    updateRecords(records, recordIndexs) {
        (0, record_helper_1.listTableUpdateRecords)(records, recordIndexs, this);
    }
    _hasCustomRenderOrLayout() {
        var _a, _b, _c, _d;
        const {headerObjects: headerObjects} = this.internalProps.layoutMap;
        if (this.options.customRender) return !0;
        for (let i = 0; i < headerObjects.length; i++) {
            const headerObject = headerObjects[i];
            if ((null === (_a = null == headerObject ? void 0 : headerObject.define) || void 0 === _a ? void 0 : _a.customLayout) || (null === (_b = null == headerObject ? void 0 : headerObject.define) || void 0 === _b ? void 0 : _b.headerCustomLayout) || (null === (_c = null == headerObject ? void 0 : headerObject.define) || void 0 === _c ? void 0 : _c.customRender) || (null === (_d = null == headerObject ? void 0 : headerObject.define) || void 0 === _d ? void 0 : _d.headerCustomRender)) return !0;
        }
        return !1;
    }
    getAggregateValuesByField(field) {
        const columns = this.internalProps.layoutMap.getColumnByField(field), results = [];
        for (let i = 0; i < columns.length; i++) {
            const aggregator = columns[i].columnDefine.aggregator;
            if (delete columns[i].columnDefine, aggregator) {
                const columnAggregateValue = {
                    col: columns[i].col,
                    aggregateValue: null
                };
                if (columnAggregateValue.aggregateValue = [], Array.isArray(aggregator)) for (let j = 0; j < aggregator.length; j++) columnAggregateValue.aggregateValue.push({
                    aggregationType: aggregator[j].type,
                    value: aggregator[j].value()
                }); else columnAggregateValue.aggregateValue.push({
                    aggregationType: aggregator.type,
                    value: aggregator.value()
                });
                results.push(columnAggregateValue);
            }
        }
        return results;
    }
    isAggregation(col, row) {
        return this.internalProps.layoutMap.isAggregation(col, row);
    }
    getGroupTitleLevel(col, row) {
        var _a;
        if (!this.options.groupBy) return;
        const indexArr = this.dataSource.getIndexKey(this.getRecordShowIndexByCell(col, row)), groupLength = null !== (_a = this.dataSource.getGroupLength()) && void 0 !== _a ? _a : 0;
        let indexArrLngth = (0, vutils_1.isArray)(indexArr) ? indexArr.length - 1 : 0;
        return groupLength > 0 && indexArrLngth === groupLength && (indexArrLngth = void 0), 
        indexArrLngth;
    }
    getBodyRowIndexByRecordIndex(index) {
        return Array.isArray(index) && 1 === index.length && (index = index[0]), this.dataSource.getTableIndex(index);
    }
    _parseColumnWidthConfig(columnWidthConfig) {
        for (let i = 0; i < (null == columnWidthConfig ? void 0 : columnWidthConfig.length); i++) {
            const item = columnWidthConfig[i], key = item.key, width = item.width, columnData = this.internalProps.layoutMap.getColumnByKey(key);
            if (columnData.columnDefine) {
                const {col: col} = columnData;
                this.internalProps._widthResizedColMap.has(col) || (this._setColWidth(col, width), 
                this.internalProps._widthResizedColMap.add(col));
            }
        }
    }
    release() {
        this.editorManager.release(), super.release();
    }
}

exports.ListTable = ListTable;
//# sourceMappingURL=ListTable.js.map