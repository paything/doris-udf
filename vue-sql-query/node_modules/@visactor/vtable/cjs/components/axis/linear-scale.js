"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.LinearAxisScale = void 0;

const vscale_1 = require("@visactor/vscale"), vutils_1 = require("@visactor/vutils"), e10 = Math.sqrt(50), e5 = Math.sqrt(10), e2 = Math.sqrt(2);

class LinearAxisScale {
    constructor(type) {
        this._extend = {}, this.type = null != type ? type : "linear", this._scale = "log" === type ? new vscale_1.LogScale : "symlog" === type ? new vscale_1.SymlogScale : new vscale_1.LinearScale, 
        this._scales = [ this._scale ];
    }
    setExtraAttrFromSpec(nice, zero, range, expand, base, constant) {
        this.nice = !1, this.zero = zero, this.zero && (range.min = Math.min(range.min, 0), 
        range.max = Math.max(range.max, 0)), this.domain = range, this.expand = expand, 
        "log" === this.type ? this._scale.base(null != base ? base : 10) : "symlog" === this.type && this._scale.constant(null != constant ? constant : 10);
    }
    transformScaleDomain() {
        "symlog" === this.type || "log" === this.type || this.setScaleNice();
    }
    setScaleNice() {
        "log" === this.type ? this.setLogScaleNice() : this.setLinearScaleNice();
    }
    setLogScaleNice() {
        var _a, _b, _c, _d, _e, _f;
        (0, vutils_1.isNil)(null === (_a = this.domain) || void 0 === _a ? void 0 : _a.min) && (0, 
        vutils_1.isNil)(null === (_b = this.domain) || void 0 === _b ? void 0 : _b.max) ? this.nice && this._scale.nice() : (0, 
        vutils_1.isValid)(null === (_c = this.domain) || void 0 === _c ? void 0 : _c.min) && (0, 
        vutils_1.isNil)(null === (_d = this.domain) || void 0 === _d ? void 0 : _d.max) ? this.nice && this._scale.niceMax() : (0, 
        vutils_1.isNil)(null === (_e = this.domain) || void 0 === _e ? void 0 : _e.min) && (0, 
        vutils_1.isValid)(null === (_f = this.domain) || void 0 === _f ? void 0 : _f.max) && this.nice && this._scale.niceMin();
    }
    setLinearScaleNice() {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        let tickCount = null !== (_b = null !== (_a = this.forceTickCount) && void 0 !== _a ? _a : this.tickCount) && void 0 !== _b ? _b : 10;
        "accurateFirst" === this.niceType && (tickCount = Math.max(10, tickCount)), (0, 
        vutils_1.isNil)(null === (_c = this.domain) || void 0 === _c ? void 0 : _c.min) && (0, 
        vutils_1.isNil)(null === (_d = this.domain) || void 0 === _d ? void 0 : _d.max) ? this.nice && this._scale.nice(tickCount) : (0, 
        vutils_1.isValid)(null === (_e = this.domain) || void 0 === _e ? void 0 : _e.min) && (0, 
        vutils_1.isNil)(null === (_f = this.domain) || void 0 === _f ? void 0 : _f.max) ? this.nice && this._scale.niceMax(tickCount) : (0, 
        vutils_1.isNil)(null === (_g = this.domain) || void 0 === _g ? void 0 : _g.min) && (0, 
        vutils_1.isValid)(null === (_h = this.domain) || void 0 === _h ? void 0 : _h.max) ? this.nice && this._scale.niceMin(tickCount) : this.nice && this._scale.nice(tickCount);
    }
    dataToPosition(values) {
        return this.valueToPosition(values[0]);
    }
    valueToPosition(value) {
        return this._scale.scale(value);
    }
    computeLinearDomain(data) {
        const domain = [];
        return data.forEach((d => {
            const {min: min, max: max} = d;
            domain[0] = void 0 === domain[0] ? min : Math.min(domain[0], min), domain[1] = void 0 === domain[1] ? max : Math.max(domain[1], max);
        })), this.expandDomain(domain), this.includeZero(domain), this.setDomainMinMax(domain), 
        domain;
    }
    expandDomain(domain) {
        if (!this.expand) return;
        const domainMin = domain[0], domainMax = domain[domain.length - 1];
        (0, vutils_1.isValid)(this.expand.min) && (domain[0] = domainMin - (domainMax - domainMin) * this.expand.min), 
        (0, vutils_1.isValid)(this.expand.max) && (domain[domain.length - 1] = domainMax + (domainMax - domainMin) * this.expand.max);
    }
    niceDomain(domain) {
        if ((0, vutils_1.isValid)(domain[0]) || (0, vutils_1.isValid)(domain[1]) || "linear" !== this.type) return domain;
        if (Math.abs((0, vutils_1.minInArray)(domain) - (0, vutils_1.maxInArray)(domain)) <= 1e-12) {
            let num = domain[0];
            const flag = num >= 0 ? 1 : -1;
            if (num = Math.abs(num), num < 1) domain[0] = 0, domain[1] = 1; else {
                let step = num / 5;
                const power = Math.floor(Math.log(step) / Math.LN10), err = step / Math.pow(10, power);
                step = (err >= e10 ? 10 : err >= e5 ? 5 : err >= e2 ? 2 : 1) * Math.pow(10, power), 
                domain[0] = 0, domain[1] = 10 * step;
            }
            flag < 0 && (domain.reverse(), domain[0] *= -1, domain[1] *= -1);
        }
        return domain;
    }
    niceMinMax() {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        if (this.nice) {
            let tickCount = null !== (_b = null !== (_a = this.forceTickCount) && void 0 !== _a ? _a : this.tickCount) && void 0 !== _b ? _b : 10;
            "accurateFirst" === this.niceType && (tickCount = Math.max(10, tickCount)), (0, 
            vutils_1.isNil)(null === (_c = this.domain) || void 0 === _c ? void 0 : _c.min) && (0, 
            vutils_1.isNil)(null === (_d = this.domain) || void 0 === _d ? void 0 : _d.max) ? this._scale.nice(tickCount) : (0, 
            vutils_1.isValid)(null === (_e = this.domain) || void 0 === _e ? void 0 : _e.min) && (0, 
            vutils_1.isNil)(null === (_f = this.domain) || void 0 === _f ? void 0 : _f.max) ? this._scale.niceMax(tickCount) : (0, 
            vutils_1.isNil)(null === (_g = this.domain) || void 0 === _g ? void 0 : _g.min) && (0, 
            vutils_1.isValid)(null === (_h = this.domain) || void 0 === _h ? void 0 : _h.max) ? this._scale.niceMin(tickCount) : this._scale.nice(tickCount);
        }
    }
    includeZero(domain) {
        this.zero && (domain[0] = Math.min(domain[0], 0), domain[domain.length - 1] = Math.max(domain[domain.length - 1], 0));
    }
    setExtendDomain(key, value) {
        if (void 0 === value) return void delete this._extend[key];
        this._extend[key] = value;
        const domain = this._scale.domain();
        this.extendDomain(domain), this.includeZero(domain), this.setDomainMinMax(domain), 
        this.niceDomain(domain), this._scale.domain(domain, this.nice), this.niceMinMax();
    }
    extendDomain(domain) {
        let temp;
        const domainLast = domain.length - 1, reverse = domain[0] - domain[domainLast] > 0, min = reverse ? domainLast : 0, max = reverse ? 0 : domainLast;
        for (const key in this._extend) temp = this._extend[key], temp > domain[max] && (domain[max] = temp), 
        temp < domain[min] && (domain[min] = temp);
    }
    setDomainMinMax(domain) {
        if (!this.domain) return;
        const {min: min, max: max} = this.domain;
        (0, vutils_1.isValid)(min) && (domain[0] = min), (0, vutils_1.isValid)(max) && (domain[1] = max);
    }
    setZero(zero) {
        this.zero !== zero && (this.zero = zero, this.updateScaleDomain());
    }
    updateScaleDomain() {
        const domain = this.computeDomain([ this.domain ]);
        this.updateScaleDomainByModel(domain);
    }
    computeDomain(data) {
        return this.computeLinearDomain(data);
    }
    updateScaleDomainByModel(domain) {
        domain = null != domain ? domain : this._scale.domain(), this.extendDomain(domain), 
        this.includeZero(domain), this.setDomainMinMax(domain), this.niceDomain(domain), 
        this._scale.domain(domain, this.nice), this.niceMinMax();
    }
    updateRange(newRange) {
        const [start, end] = this._scale.range();
        newRange[0] === start && newRange[1] === end || this._scale.range(newRange);
    }
}

exports.LinearAxisScale = LinearAxisScale;
//# sourceMappingURL=linear-scale.js.map
