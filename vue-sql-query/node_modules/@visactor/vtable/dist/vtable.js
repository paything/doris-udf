(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.VTable = {}));
})(this, (function (exports) { 'use strict';

    class Generator {
      static GenAutoIncrementId() {
        return Generator.auto_increment_id++;
      }
    }
    Generator.auto_increment_id = 0;

    class ContainerModule {
      constructor(registry) {
        this.id = Generator.GenAutoIncrementId(), this.registry = registry;
      }
    }

    const NAMED_TAG = "named";
    const INJECT_TAG = "inject";
    const MULTI_INJECT_TAG = "multi_inject";
    const TAGGED = "inversify:tagged";
    const PARAM_TYPES = "inversify:paramtypes";

    class Metadata {
      constructor(key, value) {
        this.key = key, this.value = value;
      }
      toString() {
        return this.key === NAMED_TAG ? `named: ${String(this.value).toString()} ` : `tagged: { key:${this.key.toString()}, value: ${String(this.value)} }`;
      }
    }

    var Reflect$1 = (function (Reflect) {
      var target;
      return function (exporter) {
        const supportsSymbol = "function" == typeof Symbol,
          toPrimitiveSymbol = supportsSymbol && void 0 !== Symbol.toPrimitive ? Symbol.toPrimitive : "@@toPrimitive",
          functionPrototype = (Object.getPrototypeOf(Function)),
          _Map = ("object" == typeof process && process.env && process.env.REFLECT_METADATA_USE_MAP_POLYFILL, Map),
          Metadata = (new WeakMap());
        function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
          if (!IsObject(target)) throw new TypeError();
          return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
        }
        function hasMetadata(metadataKey, target, propertyKey) {
          if (!IsObject(target)) throw new TypeError();
          return IsUndefined(propertyKey) || (propertyKey = ToPropertyKey(propertyKey)), OrdinaryHasMetadata(metadataKey, target, propertyKey);
        }
        function hasOwnMetadata(metadataKey, target, propertyKey) {
          if (!IsObject(target)) throw new TypeError();
          return IsUndefined(propertyKey) || (propertyKey = ToPropertyKey(propertyKey)), OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
        }
        function getMetadata(metadataKey, target, propertyKey) {
          if (!IsObject(target)) throw new TypeError();
          return IsUndefined(propertyKey) || (propertyKey = ToPropertyKey(propertyKey)), OrdinaryGetMetadata(metadataKey, target, propertyKey);
        }
        function GetOrCreateMetadataMap(O, P, Create) {
          let targetMetadata = Metadata.get(O);
          if (IsUndefined(targetMetadata)) {
            if (!Create) return;
            targetMetadata = new _Map(), Metadata.set(O, targetMetadata);
          }
          let metadataMap = targetMetadata.get(P);
          if (IsUndefined(metadataMap)) {
            if (!Create) return;
            metadataMap = new _Map(), targetMetadata.set(P, metadataMap);
          }
          return metadataMap;
        }
        function OrdinaryHasMetadata(MetadataKey, O, P) {
          if (OrdinaryHasOwnMetadata(MetadataKey, O, P)) return !0;
          const parent = OrdinaryGetPrototypeOf(O);
          return !IsNull(parent) && OrdinaryHasMetadata(MetadataKey, parent, P);
        }
        function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
          const metadataMap = GetOrCreateMetadataMap(O, P, !1);
          return !IsUndefined(metadataMap) && ToBoolean(metadataMap.has(MetadataKey));
        }
        function OrdinaryGetMetadata(MetadataKey, O, P) {
          if (OrdinaryHasOwnMetadata(MetadataKey, O, P)) return OrdinaryGetOwnMetadata(MetadataKey, O, P);
          const parent = OrdinaryGetPrototypeOf(O);
          return IsNull(parent) ? void 0 : OrdinaryGetMetadata(MetadataKey, parent, P);
        }
        function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
          const metadataMap = GetOrCreateMetadataMap(O, P, !1);
          if (!IsUndefined(metadataMap)) return metadataMap.get(MetadataKey);
        }
        function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
          GetOrCreateMetadataMap(O, P, !0).set(MetadataKey, MetadataValue);
        }
        function Type(x) {
          if (null === x) return 1;
          switch (typeof x) {
            case "undefined":
              return 0;
            case "boolean":
              return 2;
            case "string":
              return 3;
            case "symbol":
              return 4;
            case "number":
              return 5;
            case "object":
              return null === x ? 1 : 6;
            default:
              return 6;
          }
        }
        function IsUndefined(x) {
          return void 0 === x;
        }
        function IsNull(x) {
          return null === x;
        }
        function IsSymbol(x) {
          return "symbol" == typeof x;
        }
        function IsObject(x) {
          return "object" == typeof x ? null !== x : "function" == typeof x;
        }
        function ToPrimitive(input, PreferredType) {
          switch (Type(input)) {
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
              return input;
          }
          const hint = 3 === PreferredType ? "string" : 5 === PreferredType ? "number" : "default",
            exoticToPrim = GetMethod(input, toPrimitiveSymbol);
          if (void 0 !== exoticToPrim) {
            const result = exoticToPrim.call(input, hint);
            if (IsObject(result)) throw new TypeError();
            return result;
          }
          return OrdinaryToPrimitive(input, "default" === hint ? "number" : hint);
        }
        function OrdinaryToPrimitive(O, hint) {
          if ("string" === hint) {
            const toString_1 = O.toString;
            if (IsCallable(toString_1)) {
              const result = toString_1.call(O);
              if (!IsObject(result)) return result;
            }
            const valueOf = O.valueOf;
            if (IsCallable(valueOf)) {
              const result = valueOf.call(O);
              if (!IsObject(result)) return result;
            }
          } else {
            const valueOf = O.valueOf;
            if (IsCallable(valueOf)) {
              const result = valueOf.call(O);
              if (!IsObject(result)) return result;
            }
            const toString_2 = O.toString;
            if (IsCallable(toString_2)) {
              const result = toString_2.call(O);
              if (!IsObject(result)) return result;
            }
          }
          throw new TypeError();
        }
        function ToBoolean(argument) {
          return !!argument;
        }
        function ToString(argument) {
          return "" + argument;
        }
        function ToPropertyKey(argument) {
          const key = ToPrimitive(argument, 3);
          return IsSymbol(key) ? key : ToString(key);
        }
        function IsCallable(argument) {
          return "function" == typeof argument;
        }
        function GetMethod(V, P) {
          const func = V[P];
          if (null != func) {
            if (!IsCallable(func)) throw new TypeError();
            return func;
          }
        }
        function OrdinaryGetPrototypeOf(O) {
          const proto = Object.getPrototypeOf(O);
          if ("function" != typeof O || O === functionPrototype) return proto;
          if (proto !== functionPrototype) return proto;
          const prototype = O.prototype,
            prototypeProto = prototype && Object.getPrototypeOf(prototype);
          if (null == prototypeProto || prototypeProto === Object.prototype) return proto;
          const constructor = prototypeProto.constructor;
          return "function" != typeof constructor || constructor === O ? proto : constructor;
        }
        exporter("defineMetadata", defineMetadata), exporter("hasMetadata", hasMetadata), exporter("hasOwnMetadata", hasOwnMetadata), exporter("getMetadata", getMetadata);
      }((target = Reflect, function (key, value) {
        "function" != typeof target[key] && Object.defineProperty(target, key, {
          configurable: !0,
          writable: !0,
          value: value
        });
      })), Reflect;
    })({});

    function _tagParameterOrProperty(metadataKey, annotationTarget, key, metadata) {
      const metadatas = [metadata];
      let paramsOrPropertiesMetadata = {};
      Reflect$1.hasOwnMetadata(metadataKey, annotationTarget) && (paramsOrPropertiesMetadata = Reflect$1.getMetadata(metadataKey, annotationTarget));
      let paramOrPropertyMetadata = paramsOrPropertiesMetadata[key];
      void 0 === paramOrPropertyMetadata && (paramOrPropertyMetadata = []), paramOrPropertyMetadata.push(...metadatas), paramsOrPropertiesMetadata[key] = paramOrPropertyMetadata, Reflect$1.defineMetadata(metadataKey, paramsOrPropertiesMetadata, annotationTarget);
    }
    function tagParameter(annotationTarget, parameterName, parameterIndex, metadata) {
      _tagParameterOrProperty(TAGGED, annotationTarget, parameterIndex.toString(), metadata);
    }
    function createTaggedDecorator(metadata) {
      return (target, targetKey, indexOrPropertyDescriptor) => {
        tagParameter(target, targetKey, indexOrPropertyDescriptor, metadata);
      };
    }
    function injectBase(metadataKey) {
      return serviceIdentifier => (target, targetKey, indexOrPropertyDescriptor) => createTaggedDecorator(new Metadata(metadataKey, serviceIdentifier))(target, targetKey, indexOrPropertyDescriptor);
    }

    const inject = injectBase(INJECT_TAG);

    const multiInject = injectBase(MULTI_INJECT_TAG);

    function injectable() {
      return function (target) {
        return Reflect$1.defineMetadata(PARAM_TYPES, null, target), target;
      };
    }

    function named(name) {
      return createTaggedDecorator(new Metadata(NAMED_TAG, name));
    }

    const BindingScopeEnum = {
        Singleton: "Singleton",
        Transient: "Transient"
      },
      BindingTypeEnum = {
        ConstantValue: "ConstantValue",
        Constructor: "Constructor",
        DynamicValue: "DynamicValue",
        Factory: "Factory",
        Function: "Function",
        Instance: "Instance",
        Invalid: "Invalid",
        Provider: "Provider"
      };

    class Binding {
      constructor(serviceIdentifier, scope) {
        this.id = Generator.GenAutoIncrementId(), this.activated = !1, this.serviceIdentifier = serviceIdentifier, this.scope = scope, this.type = BindingTypeEnum.Invalid, this.constraint = request => !0, this.implementationType = null, this.cache = null, this.factory = null, this.provider = null, this.dynamicValue = null;
      }
      clone() {
        const clone = new Binding(this.serviceIdentifier, this.scope);
        return clone.activated = clone.scope === BindingScopeEnum.Singleton && this.activated, clone.implementationType = this.implementationType, clone.dynamicValue = this.dynamicValue, clone.scope = this.scope, clone.type = this.type, clone.provider = this.provider, clone.constraint = this.constraint, clone.cache = this.cache, clone;
      }
    }

    class MetadataReader {
      getConstructorMetadata(constructorFunc) {
        return {
          compilerGeneratedMetadata: Reflect$1.getMetadata(PARAM_TYPES, constructorFunc),
          userGeneratedMetadata: Reflect$1.getMetadata(TAGGED, constructorFunc) || {}
        };
      }
      getPropertiesMetadata(constructorFunc) {
        throw new Error("暂未实现");
      }
    }

    const taggedConstraint = key => value => {
      const constraint = request => {
        if (null == request) return !1;
        if (request.key === key && request.value === value) return !0;
        if (null == request.constructorArgsMetadata) return !1;
        const constructorArgsMetadata = request.constructorArgsMetadata;
        for (let i = 0; i < constructorArgsMetadata.length; i++) if (constructorArgsMetadata[i].key === key && constructorArgsMetadata[i].value === value) return !0;
        return !1;
      };
      return constraint.metaData = new Metadata(key, value), constraint;
    };
    const namedConstraint = taggedConstraint(NAMED_TAG);

    class BindingInSyntax {
      constructor(binding) {
        this._binding = binding;
      }
      inRequestScope() {
        throw new Error("暂未实现");
      }
      inSingletonScope() {
        return this._binding.scope = BindingScopeEnum.Singleton, this;
      }
      inTransientScope() {
        return this._binding.scope = BindingScopeEnum.Transient, this;
      }
      whenTargetNamed(name) {
        return this._binding.constraint = namedConstraint(name), this;
      }
    }

    class BindingToSyntax {
      constructor(binding) {
        this._binding = binding;
      }
      to(constructor) {
        return this._binding.type = BindingTypeEnum.Instance, this._binding.implementationType = constructor, new BindingInSyntax(this._binding);
      }
      toSelf() {
        const self = this._binding.serviceIdentifier;
        return this.to(self);
      }
      toDynamicValue(func) {
        return this._binding.type = BindingTypeEnum.DynamicValue, this._binding.cache = null, this._binding.dynamicValue = func, this._binding.implementationType = null, new BindingInSyntax(this._binding);
      }
      toConstantValue(value) {
        return this._binding.type = BindingTypeEnum.ConstantValue, this._binding.cache = value, this._binding.dynamicValue = null, this._binding.implementationType = null, this._binding.scope = BindingScopeEnum.Singleton, new BindingInSyntax(this._binding);
      }
      toFactory(factory) {
        return this._binding.type = BindingTypeEnum.Factory, this._binding.factory = factory, this._binding.scope = BindingScopeEnum.Singleton, new BindingInSyntax(this._binding);
      }
      toService(service) {
        this.toDynamicValue(context => context.container.get(service));
      }
    }

    let Container$2 = class Container {
      constructor(containerOptions) {
        const options = containerOptions || {};
        options.defaultScope = options.defaultScope || BindingScopeEnum.Transient, this.options = options, this.id = Generator.GenAutoIncrementId(), this._bindingDictionary = new Map(), this._metadataReader = new MetadataReader();
      }
      load(module) {
        const containerModuleHelpers = this._getContainerModuleHelpersFactory()(module.id);
        module.registry(containerModuleHelpers.bindFunction, containerModuleHelpers.unbindFunction, containerModuleHelpers.isboundFunction, containerModuleHelpers.rebindFunction);
      }
      get(serviceIdentifier) {
        const getArgs = this._getNotAllArgs(serviceIdentifier, !1);
        return this._get(getArgs);
      }
      getAll(serviceIdentifier) {
        const getArgs = this._getAllArgs(serviceIdentifier);
        return this._get(getArgs);
      }
      getTagged(serviceIdentifier, key, value) {
        const getArgs = this._getNotAllArgs(serviceIdentifier, !1, key, value);
        return this._get(getArgs);
      }
      getNamed(serviceIdentifier, named) {
        return this.getTagged(serviceIdentifier, NAMED_TAG, named);
      }
      isBound(serviceIdentifier) {
        return this._bindingDictionary.has(serviceIdentifier);
      }
      bind(serviceIdentifier) {
        const scope = this.options.defaultScope,
          binding = new Binding(serviceIdentifier, scope),
          list = this._bindingDictionary.get(serviceIdentifier) || [];
        return list.push(binding), this._bindingDictionary.set(serviceIdentifier, list), new BindingToSyntax(binding);
      }
      unbind(serviceIdentifier) {
        this._bindingDictionary.delete(serviceIdentifier);
      }
      rebind(serviceIdentifier) {
        return this.unbind(serviceIdentifier), this.bind(serviceIdentifier);
      }
      _getContainerModuleHelpersFactory() {
        const setModuleId = (bindingToSyntax, moduleId) => {
            bindingToSyntax._binding.moduleId = moduleId;
          },
          getBindFunction = moduleId => serviceIdentifier => {
            const bindingToSyntax = this.bind(serviceIdentifier);
            return setModuleId(bindingToSyntax, moduleId), bindingToSyntax;
          },
          getUnbindFunction = () => serviceIdentifier => this.unbind(serviceIdentifier),
          getIsboundFunction = () => serviceIdentifier => this.isBound(serviceIdentifier),
          getRebindFunction = moduleId => serviceIdentifier => {
            const bindingToSyntax = this.rebind(serviceIdentifier);
            return setModuleId(bindingToSyntax, moduleId), bindingToSyntax;
          };
        return mId => ({
          bindFunction: getBindFunction(mId),
          isboundFunction: getIsboundFunction(),
          rebindFunction: getRebindFunction(mId),
          unbindFunction: getUnbindFunction(),
          unbindAsyncFunction: serviceIdentifier => null
        });
      }
      _getNotAllArgs(serviceIdentifier, isMultiInject, key, value) {
        return {
          avoidConstraints: !1,
          isMultiInject: isMultiInject,
          serviceIdentifier: serviceIdentifier,
          key: key,
          value: value
        };
      }
      _getAllArgs(serviceIdentifier) {
        return {
          avoidConstraints: !0,
          isMultiInject: !0,
          serviceIdentifier: serviceIdentifier
        };
      }
      _get(getArgs) {
        const result = [];
        return this._bindingDictionary.get(getArgs.serviceIdentifier).filter(b => b.constraint(getArgs)).forEach(binding => {
          result.push(this._resolveFromBinding(binding));
        }), getArgs.isMultiInject || 1 !== result.length ? result : result[0];
      }
      _getChildRequest(binding) {
        const constr = binding.implementationType,
          {
            userGeneratedMetadata: userGeneratedMetadata
          } = this._metadataReader.getConstructorMetadata(constr),
          keys = Object.keys(userGeneratedMetadata),
          arr = [];
        for (let i = 0; i < keys.length; i++) {
          const constructorArgsMetadata = userGeneratedMetadata[i],
            targetMetadataMap = {};
          constructorArgsMetadata.forEach(md => {
            targetMetadataMap[md.key] = md.value;
          });
          const metadata = {
              inject: targetMetadataMap[INJECT_TAG],
              multiInject: targetMetadataMap[MULTI_INJECT_TAG]
            },
            injectIdentifier = metadata.inject || metadata.multiInject,
            target = {
              serviceIdentifier: injectIdentifier,
              constructorArgsMetadata: constructorArgsMetadata
            },
            bindings = (this._bindingDictionary.get(injectIdentifier) || []).filter(b => b.constraint(target));
          if (bindings.length) {
            const request = {
              injectIdentifier: injectIdentifier,
              metadata: constructorArgsMetadata,
              bindings: bindings
            };
            arr.push(request);
          }
        }
        return arr;
      }
      _resolveFromBinding(binding) {
        const result = this._getResolvedFromBinding(binding);
        return this._saveToScope(binding, result), result;
      }
      _getResolvedFromBinding(binding) {
        let result;
        switch (binding.type) {
          case BindingTypeEnum.ConstantValue:
          case BindingTypeEnum.Function:
            result = binding.cache;
            break;
          case BindingTypeEnum.Instance:
            result = this._resolveInstance(binding, binding.implementationType);
            break;
          default:
            result = binding.dynamicValue({
              container: this
            });
        }
        return result;
      }
      _resolveInstance(binding, constr) {
        if (binding.activated) return binding.cache;
        const childRequests = this._getChildRequest(binding);
        return this._createInstance(constr, childRequests);
      }
      _createInstance(constr, childRequests) {
        if (childRequests.length) {
          return new constr(...this._resolveRequests(childRequests));
        }
        return new constr();
      }
      _resolveRequests(childRequests) {
        return childRequests.map(request => request.bindings.length > 1 ? request.bindings.map(binding => this._resolveFromBinding(binding)) : this._resolveFromBinding(request.bindings[0]));
      }
      _saveToScope(binding, result) {
        binding.scope === BindingScopeEnum.Singleton && (binding.cache = result, binding.activated = !0);
      }
    };

    const ContributionProvider = Symbol("ContributionProvider");
    class ContributionProviderCache {
      constructor(serviceIdentifier, container) {
        this.serviceIdentifier = serviceIdentifier, this.container = container, ContributionStore.setStore(this.serviceIdentifier, this);
      }
      getContributions() {
        return this.caches || (this.caches = [], this.container && this.container.isBound(this.serviceIdentifier) && this.caches.push(...this.container.getAll(this.serviceIdentifier))), this.caches;
      }
      refresh() {
        this.caches && (this.caches.length = 0, this.container && this.container.isBound(this.serviceIdentifier) && this.caches.push(...this.container.getAll(this.serviceIdentifier)));
      }
    }
    function bindContributionProvider(bind, id) {
      bind(ContributionProvider).toDynamicValue(_ref => {
        let {
          container: container
        } = _ref;
        return new ContributionProviderCache(id, container);
      }).inSingletonScope().whenTargetNamed(id);
    }
    function bindContributionProviderNoSingletonScope(bind, id) {
      bind(ContributionProvider).toDynamicValue(_ref2 => {
        let {
          container: container
        } = _ref2;
        return new ContributionProviderCache(id, container);
      }).whenTargetNamed(id);
    }
    class ContributionStore {
      static getStore(id) {
        return this.store.get(id);
      }
      static setStore(id, cache) {
        this.store.set(id, cache);
      }
      static refreshAllContributions() {
        this.store.forEach(cache => {
          cache.refresh();
        });
      }
    }
    ContributionStore.store = new Map();

    class Hook {
      constructor(args, name) {
        this._args = args, this.name = name, this.taps = [];
      }
      tap(options, fn) {
        this._tap("sync", options, fn);
      }
      unTap(options, fn) {
        const name = "string" == typeof options ? options.trim() : options.name;
        name && (this.taps = this.taps.filter(tap => !(tap.name === name && (!fn || tap.fn === fn))));
      }
      _parseOptions(type, options, fn) {
        let _options;
        if ("string" == typeof options) _options = {
          name: options.trim()
        };else if ("object" != typeof options || null === options) throw new Error("Invalid tap options");
        if ("string" != typeof _options.name || "" === _options.name) throw new Error("Missing name for tap");
        return _options = Object.assign({
          type: type,
          fn: fn
        }, _options), _options;
      }
      _tap(type, options, fn) {
        this._insert(this._parseOptions(type, options, fn));
      }
      _insert(item) {
        let before;
        "string" == typeof item.before ? before = new Set([item.before]) : Array.isArray(item.before) && (before = new Set(item.before));
        let stage = 0;
        "number" == typeof item.stage && (stage = item.stage);
        let i = this.taps.length;
        for (; i > 0;) {
          i--;
          const x = this.taps[i];
          this.taps[i + 1] = x;
          const xStage = x.stage || 0;
          if (before) {
            if (before.has(x.name)) {
              before.delete(x.name);
              continue;
            }
            if (before.size > 0) continue;
          }
          if (!(xStage > stage)) {
            i++;
            break;
          }
        }
        this.taps[i] = item;
      }
    }

    class SyncHook extends Hook {
      call() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        this.taps.map(t => t.fn).forEach(cb => cb(...args));
      }
    }

    const EnvContribution = Symbol.for("EnvContribution");
    const VGlobal = Symbol.for("VGlobal");
    const DEFAULT_TEXT_FONT_FAMILY$2 = "PingFang SC,Helvetica Neue,Microsoft Yahei,system-ui,-apple-system,segoe ui,Roboto,Helvetica,Arial,sans-serif,apple color emoji,segoe ui emoji,segoe ui symbol";

    class EventListenerManager {
      constructor() {
        this._listenerMap = new Map(), this._eventListenerTransformer = event => event;
      }
      setEventListenerTransformer(transformer) {
        this._eventListenerTransformer = transformer || (event => event);
      }
      addEventListener(type, listener, options) {
        if (!listener) return;
        const wrappedListener = event => {
          const transformedEvent = this._eventListenerTransformer(event);
          "function" == typeof listener ? listener(transformedEvent) : listener.handleEvent && listener.handleEvent(transformedEvent);
        };
        this._listenerMap.has(type) || this._listenerMap.set(type, new Map()), this._listenerMap.get(type).set(listener, wrappedListener), this._nativeAddEventListener(type, wrappedListener, options);
      }
      removeEventListener(type, listener, options) {
        var _a;
        if (!listener) return;
        const wrappedListener = null === (_a = this._listenerMap.get(type)) || void 0 === _a ? void 0 : _a.get(listener);
        wrappedListener && (this._nativeRemoveEventListener(type, wrappedListener, options), this._listenerMap.get(type).delete(listener), 0 === this._listenerMap.get(type).size && this._listenerMap.delete(type));
      }
      dispatchEvent(event) {
        return this._nativeDispatchEvent(event);
      }
      clearAllEventListeners() {
        this._listenerMap.forEach((listenersMap, type) => {
          listenersMap.forEach((wrappedListener, originalListener) => {
            this._nativeRemoveEventListener(type, wrappedListener, void 0);
          });
        }), this._listenerMap.clear();
      }
      _nativeAddEventListener(type, listener, options) {
        throw new Error("_nativeAddEventListener must be implemented by derived classes");
      }
      _nativeRemoveEventListener(type, listener, options) {
        throw new Error("_nativeRemoveEventListener must be implemented by derived classes");
      }
      _nativeDispatchEvent(event) {
        throw new Error("_nativeDispatchEvent must be implemented by derived classes");
      }
    }

    var __decorate$10 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
        var d,
          c = arguments.length,
          r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      },
      __metadata$N = undefined && undefined.__metadata || function (k, v) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
      },
      __param$B = undefined && undefined.__param || function (paramIndex, decorator) {
        return function (target, key) {
          decorator(target, key, paramIndex);
        };
      },
      __awaiter$5 = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator.throw(value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            var value;
            result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P(function (resolve) {
              resolve(value);
            })).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
    let DefaultGlobal = class extends EventListenerManager {
      get env() {
        return this._env;
      }
      get isImageAnonymous() {
        return this._isImageAnonymous;
      }
      set isImageAnonymous(isImageAnonymous) {
        this._isImageAnonymous = isImageAnonymous;
      }
      get devicePixelRatio() {
        return this._env || this.setEnv("browser"), this.envContribution.getDevicePixelRatio();
      }
      get supportEvent() {
        return this._env || this.setEnv("browser"), this.envContribution.supportEvent;
      }
      set supportEvent(support) {
        this._env || this.setEnv("browser"), this.envContribution.supportEvent = support;
      }
      get supportsTouchEvents() {
        return this._env || this.setEnv("browser"), this.envContribution.supportsTouchEvents;
      }
      set supportsTouchEvents(support) {
        this._env || this.setEnv("browser"), this.envContribution.supportsTouchEvents = support;
      }
      get supportsPointerEvents() {
        return this._env || this.setEnv("browser"), this.envContribution.supportsPointerEvents;
      }
      set supportsPointerEvents(support) {
        this._env || this.setEnv("browser"), this.envContribution.supportsPointerEvents = support;
      }
      get supportsMouseEvents() {
        return this._env || this.setEnv("browser"), this.envContribution.supportsMouseEvents;
      }
      set supportsMouseEvents(support) {
        this._env || this.setEnv("browser"), this.envContribution.supportsMouseEvents = support;
      }
      get applyStyles() {
        return this._env || this.setEnv("browser"), this.envContribution.applyStyles;
      }
      set applyStyles(support) {
        this._env || this.setEnv("browser"), this.envContribution.applyStyles = support;
      }
      constructor(contributions) {
        super(), this.contributions = contributions, this._isImageAnonymous = !0, this.eventListenerTransformer = event => event, this.id = Generator.GenAutoIncrementId(), this.hooks = {
          onSetEnv: new SyncHook(["lastEnv", "env", "global"])
        }, this.measureTextMethod = "native", this.optimizeVisible = !1;
      }
      _nativeAddEventListener(type, listener, options) {
        return this._env || this.setEnv("browser"), this.envContribution.addEventListener(type, listener, options);
      }
      _nativeRemoveEventListener(type, listener, options) {
        return this._env || this.setEnv("browser"), this.envContribution.removeEventListener(type, listener, options);
      }
      _nativeDispatchEvent(event) {
        return this._env || this.setEnv("browser"), this.envContribution.dispatchEvent(event);
      }
      bindContribution(params) {
        const promiseArr = [];
        if (this.contributions.getContributions().forEach(contribution => {
          const data = contribution.configure(this, params);
          data && data.then && promiseArr.push(data);
        }), promiseArr.length) return Promise.all(promiseArr);
      }
      getDynamicCanvasCount() {
        return this._env || this.setEnv("browser"), this.envContribution.getDynamicCanvasCount();
      }
      getStaticCanvasCount() {
        return this._env || this.setEnv("browser"), this.envContribution.getStaticCanvasCount();
      }
      setEnv(env, params) {
        if (params && !0 === params.force || this._env !== env) return this.deactiveCurrentEnv(), this.activeEnv(env, params);
      }
      deactiveCurrentEnv() {
        this.envContribution && this.envContribution.release();
      }
      activeEnv(env, params) {
        const lastEnv = this._env;
        this._env = env;
        const data = this.bindContribution(params);
        if (data && data.then) return data.then(() => {
          this.envParams = params, this.hooks.onSetEnv.call(lastEnv, env, this);
        });
        this.envParams = params, this.hooks.onSetEnv.call(lastEnv, env, this);
      }
      setActiveEnvContribution(contribution) {
        this.envContribution = contribution;
      }
      createCanvas(params) {
        return this._env || this.setEnv("browser"), this.envContribution.createCanvas(params);
      }
      createOffscreenCanvas(params) {
        return this._env || this.setEnv("browser"), this.envContribution.createOffscreenCanvas(params);
      }
      releaseCanvas(canvas) {
        return this._env || this.setEnv("browser"), this.envContribution.releaseCanvas(canvas);
      }
      getRequestAnimationFrame() {
        return this._env || this.setEnv("browser"), this.envContribution.getRequestAnimationFrame();
      }
      getCancelAnimationFrame() {
        return this._env || this.setEnv("browser"), this.envContribution.getCancelAnimationFrame();
      }
      getElementById(str) {
        return this._env || this.setEnv("browser"), this.envContribution.getElementById ? this.envContribution.getElementById(str) : null;
      }
      getRootElement() {
        return this._env || this.setEnv("browser"), this.envContribution.getRootElement ? this.envContribution.getRootElement() : null;
      }
      getDocument() {
        return this._env || this.setEnv("browser"), this.envContribution.getDocument ? this.envContribution.getDocument() : null;
      }
      mapToCanvasPoint(event, domElement) {
        return this._env || this.setEnv("browser"), this.envContribution.mapToCanvasPoint ? this.envContribution.mapToCanvasPoint(event, domElement) : null;
      }
      loadImage(url) {
        return this._env || this.setEnv("browser"), this.envContribution.loadImage(url);
      }
      loadSvg(str) {
        return this._env || this.setEnv("browser"), this.envContribution.loadSvg(str);
      }
      loadJson(url) {
        return this._env || this.setEnv("browser"), this.envContribution.loadJson(url);
      }
      loadArrayBuffer(url) {
        return this._env || this.setEnv("browser"), this.envContribution.loadArrayBuffer(url);
      }
      loadBlob(url) {
        return this._env || this.setEnv("browser"), this.envContribution.loadBlob(url);
      }
      loadFont(name, source, descriptors) {
        return __awaiter$5(this, void 0, void 0, function* () {
          return this._env || this.setEnv("browser"), this.envContribution.loadFont(name, source, descriptors);
        });
      }
      isChrome() {
        return null != this._isChrome || (this._env || this.setEnv("browser"), this._isChrome = "browser" === this._env && navigator.userAgent.indexOf("Chrome") > -1), this._isChrome;
      }
      isSafari() {
        return null != this._isSafari || (this._env || this.setEnv("browser"), this._isSafari = "browser" === this._env && /Safari/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent)), this._isSafari;
      }
      getNativeAABBBounds(dom) {
        return this._env || this.setEnv("browser"), this.envContribution.getNativeAABBBounds(dom);
      }
      removeDom(dom) {
        return this._env || this.setEnv("browser"), this.envContribution.removeDom(dom);
      }
      createDom(params) {
        return this._env || this.setEnv("browser"), this.envContribution.createDom(params);
      }
      updateDom(dom, params) {
        return this._env || this.setEnv("browser"), this.envContribution.updateDom(dom, params);
      }
      getElementTop(dom) {
        let baseWindow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
        return this._env || this.setEnv("browser"), this.envContribution.getElementTop(dom, baseWindow);
      }
      getElementLeft(dom) {
        let baseWindow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
        return this._env || this.setEnv("browser"), this.envContribution.getElementLeft(dom, baseWindow);
      }
      getElementTopLeft(dom) {
        let baseWindow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
        return this._env || this.setEnv("browser"), this.envContribution.getElementTopLeft(dom, baseWindow);
      }
      isMacOS() {
        return this._env || this.setEnv("browser"), this.envContribution.isMacOS();
      }
      copyToClipBoard(text) {
        return this._env || this.setEnv("browser"), this.envContribution.copyToClipBoard(text);
      }
    };
    DefaultGlobal = __decorate$10([injectable(), __param$B(0, inject(ContributionProvider)), __param$B(0, named(EnvContribution)), __metadata$N("design:paramtypes", [Object])], DefaultGlobal);

    var MeasureModeEnum;
    !function (MeasureModeEnum) {
      MeasureModeEnum[MeasureModeEnum.estimate = 0] = "estimate", MeasureModeEnum[MeasureModeEnum.actualBounding = 1] = "actualBounding", MeasureModeEnum[MeasureModeEnum.fontBounding = 2] = "fontBounding";
    }(MeasureModeEnum || (MeasureModeEnum = {}));

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function getDefaultExportFromCjs (x) {
    	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
    }

    var eventemitter3 = {exports: {}};

    (function (module) {

      var has = Object.prototype.hasOwnProperty,
        prefix = '~';

      /**
       * Constructor to create a storage for our `EE` objects.
       * An `Events` instance is a plain object whose properties are event names.
       *
       * @constructor
       * @private
       */
      function Events() {}

      //
      // We try to not inherit from `Object.prototype`. In some engines creating an
      // instance in this way is faster than calling `Object.create(null)` directly.
      // If `Object.create(null)` is not supported we prefix the event names with a
      // character to make sure that the built-in object properties are not
      // overridden or used as an attack vector.
      //
      if (Object.create) {
        Events.prototype = Object.create(null);

        //
        // This hack is needed because the `__proto__` property is still inherited in
        // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
        //
        if (!new Events().__proto__) prefix = false;
      }

      /**
       * Representation of a single event listener.
       *
       * @param {Function} fn The listener function.
       * @param {*} context The context to invoke the listener with.
       * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
       * @constructor
       * @private
       */
      function EE(fn, context, once) {
        this.fn = fn;
        this.context = context;
        this.once = once || false;
      }

      /**
       * Add a listener for a given event.
       *
       * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
       * @param {(String|Symbol)} event The event name.
       * @param {Function} fn The listener function.
       * @param {*} context The context to invoke the listener with.
       * @param {Boolean} once Specify if the listener is a one-time listener.
       * @returns {EventEmitter}
       * @private
       */
      function addListener(emitter, event, fn, context, once) {
        if (typeof fn !== 'function') {
          throw new TypeError('The listener must be a function');
        }
        var listener = new EE(fn, context || emitter, once),
          evt = prefix ? prefix + event : event;
        if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);else emitter._events[evt] = [emitter._events[evt], listener];
        return emitter;
      }

      /**
       * Clear event by name.
       *
       * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
       * @param {(String|Symbol)} evt The Event name.
       * @private
       */
      function clearEvent(emitter, evt) {
        if (--emitter._eventsCount === 0) emitter._events = new Events();else delete emitter._events[evt];
      }

      /**
       * Minimal `EventEmitter` interface that is molded against the Node.js
       * `EventEmitter` interface.
       *
       * @constructor
       * @public
       */
      function EventEmitter() {
        this._events = new Events();
        this._eventsCount = 0;
      }

      /**
       * Return an array listing the events for which the emitter has registered
       * listeners.
       *
       * @returns {Array}
       * @public
       */
      EventEmitter.prototype.eventNames = function eventNames() {
        var names = [],
          events,
          name;
        if (this._eventsCount === 0) return names;
        for (name in events = this._events) {
          if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
        }
        if (Object.getOwnPropertySymbols) {
          return names.concat(Object.getOwnPropertySymbols(events));
        }
        return names;
      };

      /**
       * Return the listeners registered for a given event.
       *
       * @param {(String|Symbol)} event The event name.
       * @returns {Array} The registered listeners.
       * @public
       */
      EventEmitter.prototype.listeners = function listeners(event) {
        var evt = prefix ? prefix + event : event,
          handlers = this._events[evt];
        if (!handlers) return [];
        if (handlers.fn) return [handlers.fn];
        for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
          ee[i] = handlers[i].fn;
        }
        return ee;
      };

      /**
       * Return the number of listeners listening to a given event.
       *
       * @param {(String|Symbol)} event The event name.
       * @returns {Number} The number of listeners.
       * @public
       */
      EventEmitter.prototype.listenerCount = function listenerCount(event) {
        var evt = prefix ? prefix + event : event,
          listeners = this._events[evt];
        if (!listeners) return 0;
        if (listeners.fn) return 1;
        return listeners.length;
      };

      /**
       * Calls each of the listeners registered for a given event.
       *
       * @param {(String|Symbol)} event The event name.
       * @returns {Boolean} `true` if the event had listeners, else `false`.
       * @public
       */
      EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt]) return false;
        var listeners = this._events[evt],
          len = arguments.length,
          args,
          i;
        if (listeners.fn) {
          if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);
          switch (len) {
            case 1:
              return listeners.fn.call(listeners.context), true;
            case 2:
              return listeners.fn.call(listeners.context, a1), true;
            case 3:
              return listeners.fn.call(listeners.context, a1, a2), true;
            case 4:
              return listeners.fn.call(listeners.context, a1, a2, a3), true;
            case 5:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
            case 6:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
          }
          for (i = 1, args = new Array(len - 1); i < len; i++) {
            args[i - 1] = arguments[i];
          }
          listeners.fn.apply(listeners.context, args);
        } else {
          var length = listeners.length,
            j;
          for (i = 0; i < length; i++) {
            if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);
            switch (len) {
              case 1:
                listeners[i].fn.call(listeners[i].context);
                break;
              case 2:
                listeners[i].fn.call(listeners[i].context, a1);
                break;
              case 3:
                listeners[i].fn.call(listeners[i].context, a1, a2);
                break;
              case 4:
                listeners[i].fn.call(listeners[i].context, a1, a2, a3);
                break;
              default:
                if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                  args[j - 1] = arguments[j];
                }
                listeners[i].fn.apply(listeners[i].context, args);
            }
          }
        }
        return true;
      };

      /**
       * Add a listener for a given event.
       *
       * @param {(String|Symbol)} event The event name.
       * @param {Function} fn The listener function.
       * @param {*} [context=this] The context to invoke the listener with.
       * @returns {EventEmitter} `this`.
       * @public
       */
      EventEmitter.prototype.on = function on(event, fn, context) {
        return addListener(this, event, fn, context, false);
      };

      /**
       * Add a one-time listener for a given event.
       *
       * @param {(String|Symbol)} event The event name.
       * @param {Function} fn The listener function.
       * @param {*} [context=this] The context to invoke the listener with.
       * @returns {EventEmitter} `this`.
       * @public
       */
      EventEmitter.prototype.once = function once(event, fn, context) {
        return addListener(this, event, fn, context, true);
      };

      /**
       * Remove the listeners of a given event.
       *
       * @param {(String|Symbol)} event The event name.
       * @param {Function} fn Only remove the listeners that match this function.
       * @param {*} context Only remove the listeners that have this context.
       * @param {Boolean} once Only remove one-time listeners.
       * @returns {EventEmitter} `this`.
       * @public
       */
      EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt]) return this;
        if (!fn) {
          clearEvent(this, evt);
          return this;
        }
        var listeners = this._events[evt];
        if (listeners.fn) {
          if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
            clearEvent(this, evt);
          }
        } else {
          for (var i = 0, events = [], length = listeners.length; i < length; i++) {
            if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
              events.push(listeners[i]);
            }
          }

          //
          // Reset the array, or remove it completely if we have no more listeners.
          //
          if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;else clearEvent(this, evt);
        }
        return this;
      };

      /**
       * Remove all listeners, or those of the specified event.
       *
       * @param {(String|Symbol)} [event] The event name.
       * @returns {EventEmitter} `this`.
       * @public
       */
      EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
        var evt;
        if (event) {
          evt = prefix ? prefix + event : event;
          if (this._events[evt]) clearEvent(this, evt);
        } else {
          this._events = new Events();
          this._eventsCount = 0;
        }
        return this;
      };

      //
      // Alias methods names because people roll like that.
      //
      EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
      EventEmitter.prototype.addListener = EventEmitter.prototype.on;

      //
      // Expose the prefix.
      //
      EventEmitter.prefixed = prefix;

      //
      // Allow `EventEmitter` to be imported as module namespace.
      //
      EventEmitter.EventEmitter = EventEmitter;

      //
      // Expose the module.
      //
      {
        module.exports = EventEmitter;
      }
    })(eventemitter3);
    var eventemitter3Exports = eventemitter3.exports;
    var EventEmitter = /*@__PURE__*/getDefaultExportFromCjs(eventemitter3Exports);

    const isType$4 = (value, type) => Object.prototype.toString.call(value) === `[object ${type}]`;
    var isType$5 = isType$4;

    const isBoolean$5 = function (value) {
      let fuzzy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
      return fuzzy ? "boolean" == typeof value : !0 === value || !1 === value || isType$5(value, "Boolean");
    };
    var isBoolean$6 = isBoolean$5;

    const isFunction$6 = value => "function" == typeof value;
    var isFunction$7 = isFunction$6;

    const isNil$4 = value => null == value;
    var isNil$5 = isNil$4;

    const isValid$4 = value => null != value;
    var isValid$5 = isValid$4;

    const isObject$8 = value => {
      const type = typeof value;
      return null !== value && "object" === type || "function" === type;
    };
    var isObject$9 = isObject$8;

    const isObjectLike$6 = value => "object" == typeof value && null !== value;
    var isObjectLike$7 = isObjectLike$6;

    const isPlainObject$4 = function (value) {
      if (!isObjectLike$7(value) || !isType$5(value, "Object")) return !1;
      if (null === Object.getPrototypeOf(value)) return !0;
      let proto = value;
      for (; null !== Object.getPrototypeOf(proto);) proto = Object.getPrototypeOf(proto);
      return Object.getPrototypeOf(value) === proto;
    };
    var isPlainObject$5 = isPlainObject$4;

    const isUndefined = value => void 0 === value;
    var isUndefined$1 = isUndefined;

    const isString$5 = function (value) {
      let fuzzy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
      const type = typeof value;
      return fuzzy ? "string" === type : "string" === type || isType$5(value, "String");
    };
    var isString$6 = isString$5;

    const isArray$8 = value => Array.isArray ? Array.isArray(value) : isType$5(value, "Array");
    var isArray$9 = isArray$8;

    const isArrayLike$4 = function (value) {
      return null !== value && "function" != typeof value && Number.isFinite(value.length);
    };
    var isArrayLike$5 = isArrayLike$4;

    const isDate$4 = value => isType$5(value, "Date");
    var isDate$5 = isDate$4;

    const isNumber$5 = function (value) {
      let fuzzy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
      const type = typeof value;
      return fuzzy ? "number" === type : "number" === type || isType$5(value, "Number");
    };
    var isNumber$6 = isNumber$5;

    const isValidNumber$2 = value => isNumber$6(value) && Number.isFinite(value);
    var isValidNumber$3 = isValidNumber$2;

    const isValidUrl = value => new RegExp(/^(http(s)?:\/\/)\w+[^\s]+(\.[^\s]+){1,}$/).test(value);
    var isValidUrl$1 = isValidUrl;

    const isBase64 = value => new RegExp(/^data:image\/(?:gif|png|jpeg|bmp|webp|svg\+xml)(?:;charset=utf-8)?;base64,(?:[A-Za-z0-9]|[+/])+={0,2}/g).test(value);
    var isBase64$1 = isBase64;

    const getType$2 = value => ({}).toString.call(value).replace(/^\[object /, "").replace(/]$/, "");
    var getType$3 = getType$2;

    const objectProto$6 = Object.prototype,
      isPrototype$2 = function (value) {
        const Ctor = value && value.constructor;
        return value === ("function" == typeof Ctor && Ctor.prototype || objectProto$6);
      };
    var isPrototype$3 = isPrototype$2;

    const hasOwnProperty$6 = Object.prototype.hasOwnProperty;
    function isEmpty$1(value) {
      if (isNil$5(value)) return !0;
      if (isArrayLike$5(value)) return !value.length;
      const type = getType$3(value);
      if ("Map" === type || "Set" === type) return !value.size;
      if (isPrototype$3(value)) return !Object.keys(value).length;
      for (const key in value) if (hasOwnProperty$6.call(value, key)) return !1;
      return !0;
    }

    const get$8 = (obj, path, defaultValue) => {
      const paths = isString$6(path) ? path.split(".") : path;
      for (let p = 0; p < paths.length; p++) obj = obj ? obj[paths[p]] : void 0;
      return void 0 === obj ? defaultValue : obj;
    };
    var get$9 = get$8;

    const hasOwnProperty$5 = Object.prototype.hasOwnProperty,
      has = (object, key) => null != object && hasOwnProperty$5.call(object, key);
    var has$1 = has;

    function cloneDeep$2(value, ignoreWhen, excludeKeys) {
      let result;
      if (!isValid$5(value) || "object" != typeof value || ignoreWhen && ignoreWhen(value)) return value;
      const isArr = isArray$9(value),
        length = value.length;
      result = isArr ? new Array(length) : "object" == typeof value ? {} : isBoolean$6(value) || isNumber$6(value) || isString$6(value) ? value : isDate$5(value) ? new Date(+value) : void 0;
      const props = isArr ? void 0 : Object.keys(Object(value));
      let index = -1;
      if (result) for (; ++index < (props || value).length;) {
        const key = props ? props[index] : index,
          subValue = value[key];
        excludeKeys && excludeKeys.includes(key.toString()) ? result[key] = subValue : result[key] = cloneDeep$2(subValue, ignoreWhen, excludeKeys);
      }
      return result;
    }

    function baseMerge$2(target, source) {
      let shallowArray = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
      let skipTargetArray = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
      if (source) {
        if (target === source) return;
        if (isValid$5(source) && "object" == typeof source) {
          const iterable = Object(source),
            props = [];
          for (const key in iterable) props.push(key);
          let {
              length: length
            } = props,
            propIndex = -1;
          for (; length--;) {
            const key = props[++propIndex];
            !isValid$5(iterable[key]) || "object" != typeof iterable[key] || skipTargetArray && isArray$9(target[key]) ? assignMergeValue$2(target, key, iterable[key]) : baseMergeDeep$2(target, source, key, shallowArray, skipTargetArray);
          }
        }
      }
    }
    function baseMergeDeep$2(target, source, key) {
      let shallowArray = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
      let skipTargetArray = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !1;
      const objValue = target[key],
        srcValue = source[key];
      let newValue = source[key],
        isCommon = !0;
      if (isArray$9(srcValue)) {
        if (shallowArray) newValue = [];else if (isArray$9(objValue)) newValue = objValue;else if (isArrayLike$5(objValue)) {
          newValue = new Array(objValue.length);
          let index = -1;
          const length = objValue.length;
          for (; ++index < length;) newValue[index] = objValue[index];
        }
      } else isPlainObject$5(srcValue) ? (newValue = null != objValue ? objValue : {}, "function" != typeof objValue && "object" == typeof objValue || (newValue = {})) : isCommon = !1;
      isCommon && baseMerge$2(newValue, srcValue, shallowArray, skipTargetArray), assignMergeValue$2(target, key, newValue);
    }
    function assignMergeValue$2(target, key, value) {
      (void 0 !== value && !eq$4(target[key], value) || void 0 === value && !(key in target)) && (target[key] = value);
    }
    function eq$4(value, other) {
      return value === other || Number.isNaN(value) && Number.isNaN(other);
    }
    function merge$2(target) {
      let sourceIndex = -1;
      const length = arguments.length <= 1 ? 0 : arguments.length - 1;
      for (; ++sourceIndex < length;) {
        baseMerge$2(target, sourceIndex + 1 < 1 || arguments.length <= sourceIndex + 1 ? undefined : arguments[sourceIndex + 1], !0);
      }
      return target;
    }

    function keys$1(obj) {
      if (!obj) return [];
      if (Object.keys) return Object.keys(obj);
      const keyList = [];
      for (const key in obj) obj.hasOwnProperty(key) && keyList.push(key);
      return keyList;
    }
    function defaults$1(target, source, overlay) {
      const keysArr = keys$1(source);
      for (let i = 0; i < keysArr.length; i++) {
        const key = keysArr[i];
        (overlay ? null != source[key] : null == target[key]) && (target[key] = source[key]);
      }
      return target;
    }
    function mixin$1(target, source) {
      let override = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !0;
      if (target = "prototype" in target ? target.prototype : target, source = "prototype" in source ? source.prototype : source, Object.getOwnPropertyNames) {
        const keyList = Object.getOwnPropertyNames(source);
        for (let i = 0; i < keyList.length; i++) {
          const key = keyList[i];
          "constructor" !== key && (override ? null != source[key] : null == target[key]) && (target[key] = source[key]);
        }
      } else defaults$1(target, source, override);
    }

    function array$1(arr) {
      return isValid$5(arr) ? isArray$9(arr) ? arr : [arr] : [];
    }
    function last$1(val) {
      if (isArrayLike$5(val)) {
        return val[val.length - 1];
      }
    }
    const maxInArray$1 = (arr, compareFn) => {
      var _a;
      if (0 === arr.length) return;
      let max = arr[0];
      for (let i = 1; i < arr.length; i++) {
        const value = arr[i];
        (null !== (_a = null == compareFn ? void 0 : compareFn(value, max)) && void 0 !== _a ? _a : value - max) > 0 && (max = value);
      }
      return max;
    };
    const minInArray$1 = (arr, compareFn) => {
      var _a;
      if (0 === arr.length) return;
      let min = arr[0];
      for (let i = 1; i < arr.length; i++) {
        const value = arr[i];
        (null !== (_a = null == compareFn ? void 0 : compareFn(value, min)) && void 0 !== _a ? _a : value - min) < 0 && (min = value);
      }
      return min;
    };
    function arrayEqual$1(a, b) {
      if (!isArray$9(a) || !isArray$9(b)) return !1;
      if (a.length !== b.length) return !1;
      for (let i = 0; i < a.length; i++) if (a[i] !== b[i]) return !1;
      return !0;
    }
    function flattenArray(arr) {
      if (!isArray$9(arr)) return [arr];
      const result = [];
      for (const value of arr) result.push(...flattenArray(value));
      return result;
    }

    function range$1(start, stop, step) {
      isValid$5(stop) || (stop = start, start = 0), isValid$5(step) || (step = 1);
      let i = -1;
      const n = 0 | Math.max(0, Math.ceil((stop - start) / step)),
        range = new Array(n);
      for (; ++i < n;) range[i] = start + i * step;
      return range;
    }

    function ascending$1(a, b) {
      return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    }

    function toNumber$1(a) {
      return Number(a);
    }

    const hasConsole$1 = "undefined" != typeof console;
    function log$1(method, level, input) {
      const args = [level].concat([].slice.call(input));
      hasConsole$1 && console[method].apply(console, args);
    }
    var LoggerLevel$1;
    !function (LoggerLevel) {
      LoggerLevel[LoggerLevel.None = 0] = "None", LoggerLevel[LoggerLevel.Error = 1] = "Error", LoggerLevel[LoggerLevel.Warn = 2] = "Warn", LoggerLevel[LoggerLevel.Info = 3] = "Info", LoggerLevel[LoggerLevel.Debug = 4] = "Debug";
    }(LoggerLevel$1 || (LoggerLevel$1 = {}));
    let Logger$1 = class Logger {
      static getInstance(level, method) {
        return Logger._instance && isNumber$6(level) ? Logger._instance.level(level) : Logger._instance || (Logger._instance = new Logger(level, method)), Logger._instance;
      }
      static setInstance(logger) {
        return Logger._instance = logger;
      }
      static setInstanceLevel(level) {
        Logger._instance ? Logger._instance.level(level) : Logger._instance = new Logger(level);
      }
      static clearInstance() {
        Logger._instance = null;
      }
      constructor() {
        let level = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : LoggerLevel$1.None;
        let method = arguments.length > 1 ? arguments[1] : undefined;
        this._onErrorHandler = [], this._level = level, this._method = method;
      }
      addErrorHandler(handler) {
        this._onErrorHandler.find(h => h === handler) || this._onErrorHandler.push(handler);
      }
      removeErrorHandler(handler) {
        const index = this._onErrorHandler.findIndex(h => h === handler);
        index < 0 || this._onErrorHandler.splice(index, 1);
      }
      callErrorHandler() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        this._onErrorHandler.forEach(h => h(...args));
      }
      canLogInfo() {
        return this._level >= LoggerLevel$1.Info;
      }
      canLogDebug() {
        return this._level >= LoggerLevel$1.Debug;
      }
      canLogError() {
        return this._level >= LoggerLevel$1.Error;
      }
      canLogWarn() {
        return this._level >= LoggerLevel$1.Warn;
      }
      level(levelValue) {
        return arguments.length ? (this._level = +levelValue, this) : this._level;
      }
      error() {
        var _a;
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        return this._level >= LoggerLevel$1.Error && (this._onErrorHandler.length ? this.callErrorHandler(...args) : log$1(null !== (_a = this._method) && void 0 !== _a ? _a : "error", "ERROR", args)), this;
      }
      warn() {
        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }
        return this._level >= LoggerLevel$1.Warn && log$1(this._method || "warn", "WARN", args), this;
      }
      info() {
        for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          args[_key4] = arguments[_key4];
        }
        return this._level >= LoggerLevel$1.Info && log$1(this._method || "log", "INFO", args), this;
      }
      debug() {
        for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
          args[_key5] = arguments[_key5];
        }
        return this._level >= LoggerLevel$1.Debug && log$1(this._method || "log", "DEBUG", args), this;
      }
    };
    Logger$1._instance = null;

    function bisect$1(a, x) {
      let lo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      let hi = arguments.length > 3 ? arguments[3] : undefined;
      for (isNil$5(hi) && (hi = a.length); lo < hi;) {
        const mid = lo + hi >>> 1;
        ascending$1(a[mid], x) > 0 ? hi = mid : lo = mid + 1;
      }
      return lo;
    }
    const binaryFuzzySearchInNumberRange = (x1, x2, compareFn) => {
      let left = x1,
        right = x2;
      for (; left < right;) {
        const mid = Math.floor((left + right) / 2);
        compareFn(mid) >= 0 ? right = mid : left = mid + 1;
      }
      return left;
    };

    const DEFAULT_ABSOLUTE_TOLERATE$1 = 1e-10,
      DEFAULT_RELATIVE_TOLERATE$1 = 1e-10;
    function isNumberClose$1(a, b) {
      let relTol = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_RELATIVE_TOLERATE$1;
      let absTol = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_ABSOLUTE_TOLERATE$1;
      const abs = absTol,
        rel = relTol * Math.max(a, b);
      return Math.abs(a - b) <= Math.max(abs, rel);
    }

    const memoize$3 = func => {
      let lastArgs = null,
        lastResult = null;
      return function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return lastArgs && args.every((val, i) => val === lastArgs[i]) || (lastArgs = args, lastResult = func(...args)), lastResult;
      };
    };

    const clamp$2 = function (input, min, max) {
      return input < min ? min : input > max ? max : input;
    };
    var clamp$3 = clamp$2;

    const clampRange = (range, min, max) => {
      let [lowValue, highValue] = range;
      highValue < lowValue && (lowValue = range[1], highValue = range[0]);
      const span = highValue - lowValue;
      return span >= max - min ? [min, max] : (lowValue = Math.min(Math.max(lowValue, min), max - span), [lowValue, lowValue + span]);
    };
    var clampRange$1 = clampRange;

    function clamper$1(a, b) {
      let t;
      return a > b && (t = a, a = b, b = t), x => Math.max(a, Math.min(b, x));
    }

    let hasRaf = !1;
    try {
      hasRaf = "function" == typeof requestAnimationFrame && "function" == typeof cancelAnimationFrame;
    } catch (err) {
      hasRaf = !1;
    }
    function debounce$1(func, wait, options) {
      let lastArgs,
        lastThis,
        maxWait,
        result,
        timerId,
        lastCallTime,
        lastInvokeTime = 0,
        leading = !1,
        maxing = !1,
        trailing = !0;
      const useRAF = !wait && 0 !== wait && hasRaf;
      if ("function" != typeof func) throw new TypeError("Expected a function");
      function invokeFunc(time) {
        const args = lastArgs,
          thisArg = lastThis;
        return lastArgs = lastThis = void 0, lastInvokeTime = time, result = func.apply(thisArg, args), result;
      }
      function startTimer(pendingFunc, wait) {
        return useRAF ? (cancelAnimationFrame(timerId), requestAnimationFrame(pendingFunc)) : setTimeout(pendingFunc, wait);
      }
      function shouldInvoke(time) {
        const timeSinceLastCall = time - lastCallTime;
        return void 0 === lastCallTime || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && time - lastInvokeTime >= maxWait;
      }
      function timerExpired() {
        const time = Date.now();
        if (shouldInvoke(time)) return trailingEdge(time);
        timerId = startTimer(timerExpired, function (time) {
          const timeSinceLastInvoke = time - lastInvokeTime,
            timeWaiting = wait - (time - lastCallTime);
          return maxing ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        }(time));
      }
      function trailingEdge(time) {
        return timerId = void 0, trailing && lastArgs ? invokeFunc(time) : (lastArgs = lastThis = void 0, result);
      }
      function debounced() {
        const time = Date.now(),
          isInvoking = shouldInvoke(time);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        if (lastArgs = args, lastThis = this, lastCallTime = time, isInvoking) {
          if (void 0 === timerId) return function (time) {
            return lastInvokeTime = time, timerId = startTimer(timerExpired, wait), leading ? invokeFunc(time) : result;
          }(lastCallTime);
          if (maxing) return timerId = startTimer(timerExpired, wait), invokeFunc(lastCallTime);
        }
        return void 0 === timerId && (timerId = startTimer(timerExpired, wait)), result;
      }
      return wait = +wait || 0, isObject$9(options) && (leading = !!options.leading, maxing = "maxWait" in options, maxing && (maxWait = Math.max(isValidNumber$3(options.maxWait) ? options.maxWait : 0, wait)), trailing = "trailing" in options ? !!options.trailing : trailing), debounced.cancel = function () {
        void 0 !== timerId && function (id) {
          if (useRAF) return cancelAnimationFrame(id);
          clearTimeout(id);
        }(timerId), lastInvokeTime = 0, lastArgs = lastCallTime = lastThis = timerId = void 0;
      }, debounced.flush = function () {
        return void 0 === timerId ? result : trailingEdge(Date.now());
      }, debounced.pending = function () {
        return void 0 !== timerId;
      }, debounced;
    }
    hasRaf = !1;

    function throttle$1(func, wait, options) {
      let leading = !0,
        trailing = !0;
      if ("function" != typeof func) throw new TypeError("Expected a function");
      return isObject$9(options) && (leading = "leading" in options ? !!options.leading : leading, trailing = "trailing" in options ? !!options.trailing : trailing), debounce$1(func, wait, {
        leading: leading,
        trailing: trailing,
        maxWait: wait
      });
    }

    function interpolateNumber$1(a, b) {
      return t => a * (1 - t) + b * t;
    }
    function interpolateNumberRound$1(a, b) {
      return function (t) {
        return Math.round(a * (1 - t) + b * t);
      };
    }
    function interpolateDate$1(a, b) {
      const aVal = a.valueOf(),
        bVal = b.valueOf(),
        d = new Date();
      return t => (d.setTime(aVal * (1 - t) + bVal * t), d);
    }

    const epsilon = 1e-12;
    const pi = Math.PI;
    const halfPi$1 = pi / 2;
    const tau = 2 * pi;
    const pi2 = 2 * Math.PI;
    const abs = Math.abs;
    const atan2 = Math.atan2;
    const cos = Math.cos;
    const max = Math.max;
    const min = Math.min;
    const sin = Math.sin;
    const sqrt = Math.sqrt;
    const pow = Math.pow;
    function acos(x) {
      return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
    }
    function asin(x) {
      return x >= 1 ? halfPi$1 : x <= -1 ? -halfPi$1 : Math.asin(x);
    }
    function pointAt(x1, y1, x2, y2, t) {
      let x = x2,
        y = y2;
      return "number" == typeof x1 && "number" == typeof x2 && (x = (1 - t) * x1 + t * x2), "number" == typeof y1 && "number" == typeof y2 && (y = (1 - t) * y1 + t * y2), {
        x: x,
        y: y
      };
    }
    function crossProduct(dir1, dir2) {
      return dir1[0] * dir2[1] - dir1[1] * dir2[0];
    }

    class Point {
      constructor() {
        let x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        let y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        let x1 = arguments.length > 2 ? arguments[2] : undefined;
        let y1 = arguments.length > 3 ? arguments[3] : undefined;
        this.x = 0, this.y = 0, this.x = x, this.y = y, this.x1 = x1, this.y1 = y1;
      }
      clone() {
        return new Point(this.x, this.y);
      }
      copyFrom(p) {
        return this.x = p.x, this.y = p.y, this.x1 = p.x1, this.y1 = p.y1, this.defined = p.defined, this.context = p.context, this;
      }
      set(x, y) {
        return this.x = x, this.y = y, this;
      }
      add(point) {
        return isNumber$6(point) ? (this.x += point, void (this.y += point)) : (this.x += point.x, this.y += point.y, this);
      }
      sub(point) {
        return isNumber$6(point) ? (this.x -= point, void (this.y -= point)) : (this.x -= point.x, this.y -= point.y, this);
      }
      multi(point) {
        throw new Error("暂不支持");
      }
      div(point) {
        throw new Error("暂不支持");
      }
    }
    class PointService {
      static distancePP(p1, p2) {
        return sqrt(pow(p1.x - p2.x, 2) + pow(p1.y - p2.y, 2));
      }
      static distanceNN(x, y, x1, y1) {
        return sqrt(pow(x - x1, 2) + pow(y - y1, 2));
      }
      static distancePN(point, x, y) {
        return sqrt(pow(x - point.x, 2) + pow(y - point.y, 2));
      }
      static pointAtPP(p1, p2, t) {
        return new Point((p2.x - p1.x) * t + p1.x, (p2.y - p1.y) * t + p1.y);
      }
    }

    function degreeToRadian$1(degree) {
      return degree * (Math.PI / 180);
    }
    function radianToDegree(radian) {
      return 180 * radian / Math.PI;
    }
    const clampRadian = function () {
      let angle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      if (angle < 0) for (; angle < -tau;) angle += tau;else if (angle > 0) for (; angle > tau;) angle -= tau;
      return angle;
    };
    const clampAngleByRadian = clampRadian;
    function polarToCartesian(center, radius, angleInRadian) {
      return radius ? {
        x: center.x + radius * Math.cos(angleInRadian),
        y: center.y + radius * Math.sin(angleInRadian)
      } : {
        x: center.x,
        y: center.y
      };
    }
    function normalizeAngle(angle) {
      for (; angle < 0;) angle += 2 * Math.PI;
      for (; angle >= 2 * Math.PI;) angle -= 2 * Math.PI;
      return angle;
    }

    function getRectIntersect(bbox1, bbox2, format) {
      if (null === bbox1) return bbox2;
      if (null === bbox2) return bbox1;
      const {
        x11: x11,
        x12: x12,
        y11: y11,
        y12: y12,
        x21: x21,
        x22: x22,
        y21: y21,
        y22: y22
      } = formatTwoBBox(bbox1, bbox2, format);
      return x11 >= x22 || x12 <= x21 || y11 >= y22 || y12 <= y21 ? {
        x1: 0,
        y1: 0,
        x2: 0,
        y2: 0
      } : {
        x1: Math.max(x11, x21),
        y1: Math.max(y11, y21),
        x2: Math.min(x12, x22),
        y2: Math.min(y12, y22)
      };
    }
    var InnerBBox;
    !function (InnerBBox) {
      InnerBBox[InnerBBox.NONE = 0] = "NONE", InnerBBox[InnerBBox.BBOX1 = 1] = "BBOX1", InnerBBox[InnerBBox.BBOX2 = 2] = "BBOX2";
    }(InnerBBox || (InnerBBox = {}));
    const formatTwoBBox = (bbox1, bbox2, format) => {
      let x11 = bbox1.x1,
        x12 = bbox1.x2,
        y11 = bbox1.y1,
        y12 = bbox1.y2,
        x21 = bbox2.x1,
        x22 = bbox2.x2,
        y21 = bbox2.y1,
        y22 = bbox2.y2;
      return format && (x11 > x12 && ([x11, x12] = [x12, x11]), y11 > y12 && ([y11, y12] = [y12, y11]), x21 > x22 && ([x21, x22] = [x22, x21]), y21 > y22 && ([y21, y22] = [y22, y21])), {
        x11: x11,
        x12: x12,
        y11: y11,
        y12: y12,
        x21: x21,
        x22: x22,
        y21: y21,
        y22: y22
      };
    };
    function rectInsideAnotherRect(bbox1, bbox2, format) {
      if (!bbox1 || !bbox2) return InnerBBox.NONE;
      const {
        x11: x11,
        x12: x12,
        y11: y11,
        y12: y12,
        x21: x21,
        x22: x22,
        y21: y21,
        y22: y22
      } = formatTwoBBox(bbox1, bbox2, format);
      return x11 > x21 && x12 < x22 && y11 > y21 && y12 < y22 ? InnerBBox.BBOX1 : x21 > x11 && x22 < x12 && y21 > y11 && y22 < y12 ? InnerBBox.BBOX2 : InnerBBox.NONE;
    }
    function isRectIntersect(bbox1, bbox2, format) {
      if (bbox1 && bbox2) {
        if (!format) return !(bbox1.x1 > bbox2.x2 || bbox1.x2 < bbox2.x1 || bbox1.y1 > bbox2.y2 || bbox1.y2 < bbox2.y1);
        const {
          x11: x11,
          x12: x12,
          y11: y11,
          y12: y12,
          x21: x21,
          x22: x22,
          y21: y21,
          y22: y22
        } = formatTwoBBox(bbox1, bbox2, !0);
        return !(x11 > x22 || x12 < x21 || y11 > y22 || y12 < y21);
      }
      return !0;
    }
    function getProjectionRadius(checkAxis, axis) {
      return Math.abs(axis[0] * checkAxis[0] + axis[1] * checkAxis[1]);
    }
    function rotatePoint(_ref, rad) {
      let {
        x: x,
        y: y
      } = _ref;
      let origin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
        x: 0,
        y: 0
      };
      return {
        x: (x - origin.x) * Math.cos(rad) - (y - origin.y) * Math.sin(rad) + origin.x,
        y: (x - origin.x) * Math.sin(rad) + (y - origin.y) * Math.cos(rad) + origin.y
      };
    }
    function getCenterPoint(box) {
      return {
        x: (box.x1 + box.x2) / 2,
        y: (box.y1 + box.y2) / 2
      };
    }
    function toRect(box, isDeg) {
      const deg = isDeg ? degreeToRadian$1(box.angle) : box.angle,
        cp = getCenterPoint(box);
      return [rotatePoint({
        x: box.x1,
        y: box.y1
      }, deg, cp), rotatePoint({
        x: box.x2,
        y: box.y1
      }, deg, cp), rotatePoint({
        x: box.x2,
        y: box.y2
      }, deg, cp), rotatePoint({
        x: box.x1,
        y: box.y2
      }, deg, cp)];
    }
    function isRotateAABBIntersect(box1, box2) {
      let isDeg = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
      const rect1 = toRect(box1, isDeg),
        rect2 = toRect(box2, isDeg),
        vector = (start, end) => [end.x - start.x, end.y - start.y],
        vp1p2 = vector(getCenterPoint(box1), getCenterPoint(box2)),
        AB = vector(rect1[0], rect1[1]),
        BC = vector(rect1[1], rect1[2]),
        A1B1 = vector(rect2[0], rect2[1]),
        B1C1 = vector(rect2[1], rect2[2]),
        deg11 = isDeg ? degreeToRadian$1(box1.angle) : box1.angle;
      let deg12 = isDeg ? degreeToRadian$1(90 - box1.angle) : box1.angle + halfPi$1;
      const deg21 = isDeg ? degreeToRadian$1(box2.angle) : box2.angle;
      let deg22 = isDeg ? degreeToRadian$1(90 - box2.angle) : box2.angle + halfPi$1;
      deg12 > pi2 && (deg12 -= pi2), deg22 > pi2 && (deg22 -= pi2);
      const isCover = (checkAxisRadius, deg, targetAxis1, targetAxis2) => {
        const checkAxis = [Math.cos(deg), Math.sin(deg)];
        return checkAxisRadius + (getProjectionRadius(checkAxis, targetAxis1) + getProjectionRadius(checkAxis, targetAxis2)) / 2 > getProjectionRadius(checkAxis, vp1p2);
      };
      return isCover((box1.x2 - box1.x1) / 2, deg11, A1B1, B1C1) && isCover((box1.y2 - box1.y1) / 2, deg12, A1B1, B1C1) && isCover((box2.x2 - box2.x1) / 2, deg21, AB, BC) && isCover((box2.y2 - box2.y1) / 2, deg22, AB, BC);
    }

    const eastAsianCharacterInfo$1 = character => {
      let x = character.charCodeAt(0),
        y = 2 === character.length ? character.charCodeAt(1) : 0,
        codePoint = x;
      return 55296 <= x && x <= 56319 && 56320 <= y && y <= 57343 && (x &= 1023, y &= 1023, codePoint = x << 10 | y, codePoint += 65536), 12288 === codePoint || 65281 <= codePoint && codePoint <= 65376 || 65504 <= codePoint && codePoint <= 65510 ? "F" : 8361 === codePoint || 65377 <= codePoint && codePoint <= 65470 || 65474 <= codePoint && codePoint <= 65479 || 65482 <= codePoint && codePoint <= 65487 || 65490 <= codePoint && codePoint <= 65495 || 65498 <= codePoint && codePoint <= 65500 || 65512 <= codePoint && codePoint <= 65518 ? "H" : 4352 <= codePoint && codePoint <= 4447 || 4515 <= codePoint && codePoint <= 4519 || 4602 <= codePoint && codePoint <= 4607 || 9001 <= codePoint && codePoint <= 9002 || 11904 <= codePoint && codePoint <= 11929 || 11931 <= codePoint && codePoint <= 12019 || 12032 <= codePoint && codePoint <= 12245 || 12272 <= codePoint && codePoint <= 12283 || 12289 <= codePoint && codePoint <= 12350 || 12353 <= codePoint && codePoint <= 12438 || 12441 <= codePoint && codePoint <= 12543 || 12549 <= codePoint && codePoint <= 12589 || 12593 <= codePoint && codePoint <= 12686 || 12688 <= codePoint && codePoint <= 12730 || 12736 <= codePoint && codePoint <= 12771 || 12784 <= codePoint && codePoint <= 12830 || 12832 <= codePoint && codePoint <= 12871 || 12880 <= codePoint && codePoint <= 13054 || 13056 <= codePoint && codePoint <= 19903 || 19968 <= codePoint && codePoint <= 42124 || 42128 <= codePoint && codePoint <= 42182 || 43360 <= codePoint && codePoint <= 43388 || 44032 <= codePoint && codePoint <= 55203 || 55216 <= codePoint && codePoint <= 55238 || 55243 <= codePoint && codePoint <= 55291 || 63744 <= codePoint && codePoint <= 64255 || 65040 <= codePoint && codePoint <= 65049 || 65072 <= codePoint && codePoint <= 65106 || 65108 <= codePoint && codePoint <= 65126 || 65128 <= codePoint && codePoint <= 65131 || 110592 <= codePoint && codePoint <= 110593 || 127488 <= codePoint && codePoint <= 127490 || 127504 <= codePoint && codePoint <= 127546 || 127552 <= codePoint && codePoint <= 127560 || 127568 <= codePoint && codePoint <= 127569 || 131072 <= codePoint && codePoint <= 194367 || 177984 <= codePoint && codePoint <= 196605 || 196608 <= codePoint && codePoint <= 262141 ? "W" : 32 <= codePoint && codePoint <= 126 || 162 <= codePoint && codePoint <= 163 || 165 <= codePoint && codePoint <= 166 || 172 === codePoint || 175 === codePoint || 10214 <= codePoint && codePoint <= 10221 || 10629 <= codePoint && codePoint <= 10630 ? "Na" : 161 === codePoint || 164 === codePoint || 167 <= codePoint && codePoint <= 168 || 170 === codePoint || 173 <= codePoint && codePoint <= 174 || 176 <= codePoint && codePoint <= 180 || 182 <= codePoint && codePoint <= 186 || 188 <= codePoint && codePoint <= 191 || 198 === codePoint || 208 === codePoint || 215 <= codePoint && codePoint <= 216 || 222 <= codePoint && codePoint <= 225 || 230 === codePoint || 232 <= codePoint && codePoint <= 234 || 236 <= codePoint && codePoint <= 237 || 240 === codePoint || 242 <= codePoint && codePoint <= 243 || 247 <= codePoint && codePoint <= 250 || 252 === codePoint || 254 === codePoint || 257 === codePoint || 273 === codePoint || 275 === codePoint || 283 === codePoint || 294 <= codePoint && codePoint <= 295 || 299 === codePoint || 305 <= codePoint && codePoint <= 307 || 312 === codePoint || 319 <= codePoint && codePoint <= 322 || 324 === codePoint || 328 <= codePoint && codePoint <= 331 || 333 === codePoint || 338 <= codePoint && codePoint <= 339 || 358 <= codePoint && codePoint <= 359 || 363 === codePoint || 462 === codePoint || 464 === codePoint || 466 === codePoint || 468 === codePoint || 470 === codePoint || 472 === codePoint || 474 === codePoint || 476 === codePoint || 593 === codePoint || 609 === codePoint || 708 === codePoint || 711 === codePoint || 713 <= codePoint && codePoint <= 715 || 717 === codePoint || 720 === codePoint || 728 <= codePoint && codePoint <= 731 || 733 === codePoint || 735 === codePoint || 768 <= codePoint && codePoint <= 879 || 913 <= codePoint && codePoint <= 929 || 931 <= codePoint && codePoint <= 937 || 945 <= codePoint && codePoint <= 961 || 963 <= codePoint && codePoint <= 969 || 1025 === codePoint || 1040 <= codePoint && codePoint <= 1103 || 1105 === codePoint || 8208 === codePoint || 8211 <= codePoint && codePoint <= 8214 || 8216 <= codePoint && codePoint <= 8217 || 8220 <= codePoint && codePoint <= 8221 || 8224 <= codePoint && codePoint <= 8226 || 8228 <= codePoint && codePoint <= 8231 || 8240 === codePoint || 8242 <= codePoint && codePoint <= 8243 || 8245 === codePoint || 8251 === codePoint || 8254 === codePoint || 8308 === codePoint || 8319 === codePoint || 8321 <= codePoint && codePoint <= 8324 || 8364 === codePoint || 8451 === codePoint || 8453 === codePoint || 8457 === codePoint || 8467 === codePoint || 8470 === codePoint || 8481 <= codePoint && codePoint <= 8482 || 8486 === codePoint || 8491 === codePoint || 8531 <= codePoint && codePoint <= 8532 || 8539 <= codePoint && codePoint <= 8542 || 8544 <= codePoint && codePoint <= 8555 || 8560 <= codePoint && codePoint <= 8569 || 8585 === codePoint || 8592 <= codePoint && codePoint <= 8601 || 8632 <= codePoint && codePoint <= 8633 || 8658 === codePoint || 8660 === codePoint || 8679 === codePoint || 8704 === codePoint || 8706 <= codePoint && codePoint <= 8707 || 8711 <= codePoint && codePoint <= 8712 || 8715 === codePoint || 8719 === codePoint || 8721 === codePoint || 8725 === codePoint || 8730 === codePoint || 8733 <= codePoint && codePoint <= 8736 || 8739 === codePoint || 8741 === codePoint || 8743 <= codePoint && codePoint <= 8748 || 8750 === codePoint || 8756 <= codePoint && codePoint <= 8759 || 8764 <= codePoint && codePoint <= 8765 || 8776 === codePoint || 8780 === codePoint || 8786 === codePoint || 8800 <= codePoint && codePoint <= 8801 || 8804 <= codePoint && codePoint <= 8807 || 8810 <= codePoint && codePoint <= 8811 || 8814 <= codePoint && codePoint <= 8815 || 8834 <= codePoint && codePoint <= 8835 || 8838 <= codePoint && codePoint <= 8839 || 8853 === codePoint || 8857 === codePoint || 8869 === codePoint || 8895 === codePoint || 8978 === codePoint || 9312 <= codePoint && codePoint <= 9449 || 9451 <= codePoint && codePoint <= 9547 || 9552 <= codePoint && codePoint <= 9587 || 9600 <= codePoint && codePoint <= 9615 || 9618 <= codePoint && codePoint <= 9621 || 9632 <= codePoint && codePoint <= 9633 || 9635 <= codePoint && codePoint <= 9641 || 9650 <= codePoint && codePoint <= 9651 || 9654 <= codePoint && codePoint <= 9655 || 9660 <= codePoint && codePoint <= 9661 || 9664 <= codePoint && codePoint <= 9665 || 9670 <= codePoint && codePoint <= 9672 || 9675 === codePoint || 9678 <= codePoint && codePoint <= 9681 || 9698 <= codePoint && codePoint <= 9701 || 9711 === codePoint || 9733 <= codePoint && codePoint <= 9734 || 9737 === codePoint || 9742 <= codePoint && codePoint <= 9743 || 9748 <= codePoint && codePoint <= 9749 || 9756 === codePoint || 9758 === codePoint || 9792 === codePoint || 9794 === codePoint || 9824 <= codePoint && codePoint <= 9825 || 9827 <= codePoint && codePoint <= 9829 || 9831 <= codePoint && codePoint <= 9834 || 9836 <= codePoint && codePoint <= 9837 || 9839 === codePoint || 9886 <= codePoint && codePoint <= 9887 || 9918 <= codePoint && codePoint <= 9919 || 9924 <= codePoint && codePoint <= 9933 || 9935 <= codePoint && codePoint <= 9953 || 9955 === codePoint || 9960 <= codePoint && codePoint <= 9983 || 10045 === codePoint || 10071 === codePoint || 10102 <= codePoint && codePoint <= 10111 || 11093 <= codePoint && codePoint <= 11097 || 12872 <= codePoint && codePoint <= 12879 || 57344 <= codePoint && codePoint <= 63743 || 65024 <= codePoint && codePoint <= 65039 || 65533 === codePoint || 127232 <= codePoint && codePoint <= 127242 || 127248 <= codePoint && codePoint <= 127277 || 127280 <= codePoint && codePoint <= 127337 || 127344 <= codePoint && codePoint <= 127386 || 917760 <= codePoint && codePoint <= 917999 || 983040 <= codePoint && codePoint <= 1048573 || 1048576 <= codePoint && codePoint <= 1114109 ? "A" : "N";
    };

    function getContextFont$1(text) {
      let defaultAttr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      let fontSizeScale = arguments.length > 2 ? arguments[2] : undefined;
      fontSizeScale || (fontSizeScale = 1);
      const {
        fontStyle = defaultAttr.fontStyle,
        fontVariant = defaultAttr.fontVariant,
        fontWeight = defaultAttr.fontWeight,
        fontSize = defaultAttr.fontSize,
        fontFamily = defaultAttr.fontFamily
      } = text;
      return (fontStyle ? fontStyle + " " : "") + (fontVariant ? fontVariant + " " : "") + (fontWeight ? fontWeight + " " : "") + fontSize * fontSizeScale + "px " + (fontFamily || "sans-serif");
    }

    let TextMeasure$1 = class TextMeasure {
      constructor(option, textSpec) {
        this._numberCharSize = null, this._fullCharSize = null, this._letterCharSize = null, this._specialCharSizeMap = {}, this._canvas = null, this._context = null, this._contextSaved = !1, this._notSupportCanvas = !1, this._notSupportVRender = !1, this._userSpec = {}, this.specialCharSet = "-/: .,@%'\"~", this._option = option, this._userSpec = null != textSpec ? textSpec : {}, this.textSpec = this._initSpec(), isValid$5(option.specialCharSet) && (this.specialCharSet = option.specialCharSet), this._standardMethod = isValid$5(option.getTextBounds) ? this.fullMeasure.bind(this) : this.measureWithNaiveCanvas.bind(this);
      }
      initContext() {
        if (this._notSupportCanvas) return !1;
        if (isNil$5(this._canvas) && (isValid$5(this._option.getCanvasForMeasure) && (this._canvas = this._option.getCanvasForMeasure()), isNil$5(this._canvas) && "undefined" != typeof window && void 0 !== window.document && globalThis && isValid$5(globalThis.document) && (this._canvas = globalThis.document.createElement("canvas"))), isNil$5(this._context) && isValid$5(this._canvas)) {
          const context = this._canvas.getContext("2d");
          isValid$5(context) && (context.save(), context.font = getContextFont$1(this.textSpec), this._contextSaved = !0, this._context = context);
        }
        return !isNil$5(this._context) || (this._notSupportCanvas = !0, !1);
      }
      _initSpec() {
        var _a, _b, _c;
        const {
            defaultFontParams = {}
          } = this._option,
          {
            fontStyle = defaultFontParams.fontStyle,
            fontVariant = defaultFontParams.fontVariant,
            fontWeight = null !== (_a = defaultFontParams.fontWeight) && void 0 !== _a ? _a : "normal",
            fontSize = null !== (_b = defaultFontParams.fontSize) && void 0 !== _b ? _b : 12,
            fontFamily = null !== (_c = defaultFontParams.fontFamily) && void 0 !== _c ? _c : "sans-serif",
            align: align,
            textAlign = null != align ? align : "center",
            baseline: baseline,
            textBaseline = null != baseline ? baseline : "middle",
            ellipsis: ellipsis,
            limit: limit
          } = this._userSpec;
        let {
          lineHeight = fontSize
        } = this._userSpec;
        if (isString$6(lineHeight) && "%" === lineHeight[lineHeight.length - 1]) {
          const scale = Number.parseFloat(lineHeight.substring(0, lineHeight.length - 1)) / 100;
          lineHeight = fontSize * scale;
        }
        return {
          fontStyle: fontStyle,
          fontVariant: fontVariant,
          fontFamily: fontFamily,
          fontSize: fontSize,
          fontWeight: fontWeight,
          textAlign: textAlign,
          textBaseline: textBaseline,
          ellipsis: ellipsis,
          limit: limit,
          lineHeight: lineHeight
        };
      }
      measure(text, method) {
        switch (method) {
          case "vrender":
          case "canopus":
            return this.fullMeasure(text);
          case "canvas":
            return this.measureWithNaiveCanvas(text);
          case "simple":
            return this.quickMeasureWithoutCanvas(text);
          default:
            return this.quickMeasure(text);
        }
      }
      fullMeasure(text) {
        if (isNil$5(text)) return {
          width: 0,
          height: 0
        };
        if (isNil$5(this._option.getTextBounds) || !this._notSupportVRender) return this.measureWithNaiveCanvas(text);
        const {
          fontFamily: fontFamily,
          fontSize: fontSize,
          fontWeight: fontWeight,
          textAlign: textAlign,
          textBaseline: textBaseline,
          ellipsis: ellipsis,
          limit: limit,
          lineHeight: lineHeight
        } = this.textSpec;
        let size;
        try {
          const bounds = this._option.getTextBounds({
            text: text,
            fontFamily: fontFamily,
            fontSize: fontSize,
            fontWeight: fontWeight,
            textAlign: textAlign,
            textBaseline: textBaseline,
            ellipsis: !!ellipsis,
            maxLineWidth: limit || 1 / 0,
            lineHeight: lineHeight
          });
          size = {
            width: bounds.width(),
            height: bounds.height()
          };
        } catch (e) {
          this._notSupportVRender = !0, size = this.measureWithNaiveCanvas(text);
        }
        return size;
      }
      measureWithNaiveCanvas(text) {
        return this._measureReduce(text, this._measureWithNaiveCanvas.bind(this));
      }
      _measureWithNaiveCanvas(text) {
        var _a;
        if (!this.initContext()) return this._quickMeasureWithoutCanvas(text);
        const metrics = this._context.measureText(text),
          {
            fontSize: fontSize,
            lineHeight: lineHeight
          } = this.textSpec;
        return {
          width: metrics.width,
          height: null !== (_a = lineHeight) && void 0 !== _a ? _a : fontSize,
          fontBoundingBoxAscent: metrics.fontBoundingBoxAscent,
          fontBoundingBoxDescent: metrics.fontBoundingBoxDescent
        };
      }
      quickMeasure(text) {
        return this._measureReduce(text, this._quickMeasure.bind(this));
      }
      _quickMeasure(text) {
        const totalSize = {
          width: 0,
          height: 0
        };
        for (let i = 0; i < text.length; i++) {
          const char = text[i];
          let size = this._measureSpecialChar(char);
          isNil$5(size) && TextMeasure.NUMBERS_CHAR_SET.includes(char) && (size = this._measureNumberChar()), isNil$5(size) && ["F", "W"].includes(eastAsianCharacterInfo$1(char)) && (size = this._measureFullSizeChar()), isNil$5(size) && (size = this._measureLetterChar()), totalSize.width += size.width, totalSize.height = Math.max(totalSize.height, size.height), !isNil$5(size.fontBoundingBoxAscent) && (totalSize.fontBoundingBoxAscent = size.fontBoundingBoxAscent), !isNil$5(size.fontBoundingBoxDescent) && (totalSize.fontBoundingBoxDescent = size.fontBoundingBoxDescent);
        }
        return totalSize;
      }
      quickMeasureWithoutCanvas(text) {
        return this._measureReduce(text, this._quickMeasureWithoutCanvas.bind(this));
      }
      _quickMeasureWithoutCanvas(text) {
        var _a;
        const totalSize = {
            width: 0,
            height: 0
          },
          {
            fontSize: fontSize,
            lineHeight: lineHeight
          } = this.textSpec;
        for (let i = 0; i < text.length; i++) {
          const char = text[i],
            size = ["F", "W"].includes(eastAsianCharacterInfo$1(char)) ? 1 : .53;
          totalSize.width += size * fontSize;
        }
        return totalSize.height = null !== (_a = lineHeight) && void 0 !== _a ? _a : fontSize, totalSize;
      }
      _measureReduce(text, processor) {
        var _a;
        const {
            fontSize: fontSize,
            lineHeight: lineHeight
          } = this.textSpec,
          defaultResult = {
            width: 0,
            height: 0
          };
        if (isNil$5(text)) return defaultResult;
        if (isArray$9(text)) {
          const textArr = text.filter(isValid$5).map(s => s.toString());
          return 0 === textArr.length ? defaultResult : 1 === textArr.length ? processor(textArr[0]) : {
            width: textArr.reduce((maxWidth, cur) => Math.max(maxWidth, processor(cur).width), 0),
            height: textArr.length * ((null !== (_a = lineHeight) && void 0 !== _a ? _a : fontSize) + 1) + 1
          };
        }
        return processor(text.toString());
      }
      _measureNumberChar() {
        if (isNil$5(this._numberCharSize)) {
          const numberBounds = this._standardMethod(TextMeasure.NUMBERS_CHAR_SET);
          this._numberCharSize = {
            width: numberBounds.width / TextMeasure.NUMBERS_CHAR_SET.length,
            height: numberBounds.height,
            fontBoundingBoxAscent: numberBounds.fontBoundingBoxAscent,
            fontBoundingBoxDescent: numberBounds.fontBoundingBoxDescent
          };
        }
        return this._numberCharSize;
      }
      _measureFullSizeChar() {
        return isNil$5(this._fullCharSize) && (this._fullCharSize = this._standardMethod(TextMeasure.FULL_SIZE_CHAR)), this._fullCharSize;
      }
      _measureLetterChar() {
        if (isNil$5(this._letterCharSize)) {
          const alphabetBounds = this._standardMethod(TextMeasure.ALPHABET_CHAR_SET);
          this._letterCharSize = {
            width: alphabetBounds.width / TextMeasure.ALPHABET_CHAR_SET.length,
            height: alphabetBounds.height,
            fontBoundingBoxAscent: alphabetBounds.fontBoundingBoxAscent,
            fontBoundingBoxDescent: alphabetBounds.fontBoundingBoxDescent
          };
        }
        return this._letterCharSize;
      }
      _measureSpecialChar(char) {
        return isValid$5(this._specialCharSizeMap[char]) ? this._specialCharSizeMap[char] : this.specialCharSet.includes(char) ? (this._specialCharSizeMap[char] = this._standardMethod(char), this._specialCharSizeMap[char]) : null;
      }
      release() {
        isValid$5(this._canvas) && (this._canvas = null), isValid$5(this._context) && (this._contextSaved && (this._context.restore(), this._contextSaved = !1), this._context = null);
      }
    };
    TextMeasure$1.ALPHABET_CHAR_SET = "abcdefghijklmnopqrstuvwxyz", TextMeasure$1.NUMBERS_CHAR_SET = "0123456789", TextMeasure$1.FULL_SIZE_CHAR = "字";

    const aabbSeparation = (a, b) => Math.max(b.x1 - a.x2, a.x1 - b.x2, b.y1 - a.y2, a.y1 - b.y2);
    const obbSeparation = (a, b) => {
      const axes = [{
        x: Math.cos(a.angle),
        y: Math.sin(a.angle)
      }, {
        x: -Math.sin(a.angle),
        y: Math.cos(a.angle)
      }, {
        x: Math.cos(b.angle),
        y: Math.sin(a.angle)
      }, {
        x: -Math.sin(b.angle),
        y: Math.cos(a.angle)
      }];
      function getProjectionRange(obb, axisX, axisY) {
        const projections = obb.getRotatedCorners().map(p => p.x * axisX + p.y * axisY);
        return {
          min: Math.min(...projections),
          max: Math.max(...projections)
        };
      }
      let maxDistance = 0;
      for (const axis of axes) {
        const rangeA = getProjectionRange(a, axis.x, axis.y),
          rangeB = getProjectionRange(b, axis.x, axis.y);
        let distance;
        distance = rangeA.max < rangeB.min ? rangeB.min - rangeA.max : rangeB.max < rangeA.min ? rangeA.min - rangeB.max : 0, maxDistance = Math.max(maxDistance, distance);
      }
      return maxDistance;
    };

    function transformBoundsWithMatrix$1(out, bounds, matrix) {
      const {
        x1: x1,
        y1: y1,
        x2: x2,
        y2: y2
      } = bounds;
      return matrix.onlyTranslate() ? (out !== bounds && out.setValue(bounds.x1, bounds.y1, bounds.x2, bounds.y2), out.translate(matrix.e, matrix.f), bounds) : (out.clear(), out.add(matrix.a * x1 + matrix.c * y1 + matrix.e, matrix.b * x1 + matrix.d * y1 + matrix.f), out.add(matrix.a * x2 + matrix.c * y1 + matrix.e, matrix.b * x2 + matrix.d * y1 + matrix.f), out.add(matrix.a * x2 + matrix.c * y2 + matrix.e, matrix.b * x2 + matrix.d * y2 + matrix.f), out.add(matrix.a * x1 + matrix.c * y2 + matrix.e, matrix.b * x1 + matrix.d * y2 + matrix.f), bounds);
    }
    let Bounds$1 = class Bounds {
      constructor(bounds) {
        bounds ? this.setValue(bounds.x1, bounds.y1, bounds.x2, bounds.y2) : this.clear();
      }
      clone() {
        return new Bounds(this);
      }
      clear() {
        return this.x1 = +Number.MAX_VALUE, this.y1 = +Number.MAX_VALUE, this.x2 = -Number.MAX_VALUE, this.y2 = -Number.MAX_VALUE, this;
      }
      empty() {
        return this.x1 === +Number.MAX_VALUE && this.y1 === +Number.MAX_VALUE && this.x2 === -Number.MAX_VALUE && this.y2 === -Number.MAX_VALUE;
      }
      equals(b) {
        return this.x1 === b.x1 && this.y1 === b.y1 && this.x2 === b.x2 && this.y2 === b.y2;
      }
      setValue() {
        let x1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        let y1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        let x2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        let y2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
        return this.x1 = x1, this.y1 = y1, this.x2 = x2, this.y2 = y2, this;
      }
      set() {
        let x1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        let y1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        let x2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        let y2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
        return x2 < x1 ? (this.x2 = x1, this.x1 = x2) : (this.x1 = x1, this.x2 = x2), y2 < y1 ? (this.y2 = y1, this.y1 = y2) : (this.y1 = y1, this.y2 = y2), this;
      }
      add() {
        let x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        let y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        return x < this.x1 && (this.x1 = x), y < this.y1 && (this.y1 = y), x > this.x2 && (this.x2 = x), y > this.y2 && (this.y2 = y), this;
      }
      expand() {
        let d = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        return isArray$9(d) ? (this.y1 -= d[0], this.x2 += d[1], this.y2 += d[2], this.x1 -= d[3]) : (this.x1 -= d, this.y1 -= d, this.x2 += d, this.y2 += d), this;
      }
      round() {
        return this.x1 = Math.floor(this.x1), this.y1 = Math.floor(this.y1), this.x2 = Math.ceil(this.x2), this.y2 = Math.ceil(this.y2), this;
      }
      translate() {
        let dx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        let dy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        return this.x1 += dx, this.x2 += dx, this.y1 += dy, this.y2 += dy, this;
      }
      rotate() {
        let angle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        let x = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        let y = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        const p = this.rotatedPoints(angle, x, y);
        return this.clear().add(p[0], p[1]).add(p[2], p[3]).add(p[4], p[5]).add(p[6], p[7]);
      }
      scale() {
        let sx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        let sy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        let x = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        let y = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
        const p = this.scalePoints(sx, sy, x, y);
        return this.clear().add(p[0], p[1]).add(p[2], p[3]);
      }
      union(b) {
        return b.x1 < this.x1 && (this.x1 = b.x1), b.y1 < this.y1 && (this.y1 = b.y1), b.x2 > this.x2 && (this.x2 = b.x2), b.y2 > this.y2 && (this.y2 = b.y2), this;
      }
      intersect(b) {
        return b.x1 > this.x1 && (this.x1 = b.x1), b.y1 > this.y1 && (this.y1 = b.y1), b.x2 < this.x2 && (this.x2 = b.x2), b.y2 < this.y2 && (this.y2 = b.y2), this;
      }
      encloses(b) {
        return b && this.x1 <= b.x1 && this.x2 >= b.x2 && this.y1 <= b.y1 && this.y2 >= b.y2;
      }
      alignsWith(b) {
        return b && (this.x1 === b.x1 || this.x2 === b.x2 || this.y1 === b.y1 || this.y2 === b.y2);
      }
      intersects(b) {
        return b && !(this.x2 < b.x1 || this.x1 > b.x2 || this.y2 < b.y1 || this.y1 > b.y2);
      }
      contains() {
        let x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        let y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        return !(x < this.x1 || x > this.x2 || y < this.y1 || y > this.y2);
      }
      containsPoint(p) {
        return !(p.x < this.x1 || p.x > this.x2 || p.y < this.y1 || p.y > this.y2);
      }
      width() {
        return this.empty() ? 0 : this.x2 - this.x1;
      }
      height() {
        return this.empty() ? 0 : this.y2 - this.y1;
      }
      scaleX() {
        let s = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        return this.x1 *= s, this.x2 *= s, this;
      }
      scaleY() {
        let s = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        return this.y1 *= s, this.y2 *= s, this;
      }
      transformWithMatrix(matrix) {
        return transformBoundsWithMatrix$1(this, this, matrix), this;
      }
      copy(b) {
        return this.x1 = b.x1, this.y1 = b.y1, this.x2 = b.x2, this.y2 = b.y2, this;
      }
      rotatedPoints(angle, x, y) {
        const {
            x1: x1,
            y1: y1,
            x2: x2,
            y2: y2
          } = this,
          cos = Math.cos(angle),
          sin = Math.sin(angle),
          cx = x - x * cos + y * sin,
          cy = y - x * sin - y * cos;
        return [cos * x1 - sin * y1 + cx, sin * x1 + cos * y1 + cy, cos * x1 - sin * y2 + cx, sin * x1 + cos * y2 + cy, cos * x2 - sin * y1 + cx, sin * x2 + cos * y1 + cy, cos * x2 - sin * y2 + cx, sin * x2 + cos * y2 + cy];
      }
      scalePoints(sx, sy, x, y) {
        const {
          x1: x1,
          y1: y1,
          x2: x2,
          y2: y2
        } = this;
        return [sx * x1 + (1 - sx) * x, sy * y1 + (1 - sy) * y, sx * x2 + (1 - sx) * x, sy * y2 + (1 - sy) * y];
      }
    };
    let AABBBounds$1 = class AABBBounds extends Bounds$1 {};
    class OBBBounds extends Bounds$1 {
      constructor(bounds) {
        let angle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var _a;
        super(bounds), bounds && (this.angle = null !== (_a = bounds.angle) && void 0 !== _a ? _a : angle);
      }
      intersects(b) {
        return isRotateAABBIntersect(this, b);
      }
      setValue() {
        let x1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        let y1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        let x2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        let y2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
        let angle = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
        return super.setValue(x1, y1, x2, y2), this.angle = angle, this;
      }
      clone() {
        return new OBBBounds(this);
      }
      getRotatedCorners() {
        const originPoint = {
          x: (this.x1 + this.x2) / 2,
          y: (this.y1 + this.y2) / 2
        };
        return [rotatePoint({
          x: this.x1,
          y: this.y1
        }, this.angle, originPoint), rotatePoint({
          x: this.x2,
          y: this.y1
        }, this.angle, originPoint), rotatePoint({
          x: this.x1,
          y: this.y2
        }, this.angle, originPoint), rotatePoint({
          x: this.x2,
          y: this.y2
        }, this.angle, originPoint)];
      }
    }

    class Matrix {
      constructor() {
        let a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
        let b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        let c = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        let d = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
        let e = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
        let f = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
        this.a = a, this.b = b, this.c = c, this.d = d, this.e = e, this.f = f;
      }
      equalToMatrix(m2) {
        return !(this.e !== m2.e || this.f !== m2.f || this.a !== m2.a || this.d !== m2.d || this.b !== m2.b || this.c !== m2.c);
      }
      equalTo(a, b, c, d, e, f) {
        return !(this.e !== e || this.f !== f || this.a !== a || this.d !== d || this.b !== b || this.c !== c);
      }
      setValue(a, b, c, d, e, f) {
        return this.a = a, this.b = b, this.c = c, this.d = d, this.e = e, this.f = f, this;
      }
      reset() {
        return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.e = 0, this.f = 0, this;
      }
      getInverse() {
        const a = this.a,
          b = this.b,
          c = this.c,
          d = this.d,
          e = this.e,
          f = this.f,
          m = new Matrix(),
          dt = a * d - b * c;
        return m.a = d / dt, m.b = -b / dt, m.c = -c / dt, m.d = a / dt, m.e = (c * f - d * e) / dt, m.f = -(a * f - b * e) / dt, m;
      }
      rotate(rad) {
        const c = Math.cos(rad),
          s = Math.sin(rad),
          m11 = this.a * c + this.c * s,
          m12 = this.b * c + this.d * s,
          m21 = this.a * -s + this.c * c,
          m22 = this.b * -s + this.d * c;
        return this.a = m11, this.b = m12, this.c = m21, this.d = m22, this;
      }
      rotateByCenter(rad, cx, cy) {
        const cos = Math.cos(rad),
          sin = Math.sin(rad),
          rotateM13 = (1 - cos) * cx + sin * cy,
          rotateM23 = (1 - cos) * cy - sin * cx,
          m11 = cos * this.a - sin * this.b,
          m21 = sin * this.a + cos * this.b,
          m12 = cos * this.c - sin * this.d,
          m22 = sin * this.c + cos * this.d,
          m13 = cos * this.e - sin * this.f + rotateM13,
          m23 = sin * this.e + cos * this.f + rotateM23;
        return this.a = m11, this.b = m21, this.c = m12, this.d = m22, this.e = m13, this.f = m23, this;
      }
      scale(sx, sy) {
        return this.a *= sx, this.b *= sx, this.c *= sy, this.d *= sy, this;
      }
      setScale(sx, sy) {
        return this.b = this.b / this.a * sx, this.c = this.c / this.d * sy, this.a = sx, this.d = sy, this;
      }
      transform(a, b, c, d, e, f) {
        return this.multiply(a, b, c, d, e, f), this;
      }
      translate(x, y) {
        return this.e += this.a * x + this.c * y, this.f += this.b * x + this.d * y, this;
      }
      transpose() {
        const {
          a: a,
          b: b,
          c: c,
          d: d,
          e: e,
          f: f
        } = this;
        return this.a = b, this.b = a, this.c = d, this.d = c, this.e = f, this.f = e, this;
      }
      multiply(a2, b2, c2, d2, e2, f2) {
        const a1 = this.a,
          b1 = this.b,
          c1 = this.c,
          d1 = this.d,
          m11 = a1 * a2 + c1 * b2,
          m12 = b1 * a2 + d1 * b2,
          m21 = a1 * c2 + c1 * d2,
          m22 = b1 * c2 + d1 * d2,
          dx = a1 * e2 + c1 * f2 + this.e,
          dy = b1 * e2 + d1 * f2 + this.f;
        return this.a = m11, this.b = m12, this.c = m21, this.d = m22, this.e = dx, this.f = dy, this;
      }
      interpolate(m2, t) {
        const m = new Matrix();
        return m.a = this.a + (m2.a - this.a) * t, m.b = this.b + (m2.b - this.b) * t, m.c = this.c + (m2.c - this.c) * t, m.d = this.d + (m2.d - this.d) * t, m.e = this.e + (m2.e - this.e) * t, m.f = this.f + (m2.f - this.f) * t, m;
      }
      transformPoint(source, target) {
        const {
            a: a,
            b: b,
            c: c,
            d: d,
            e: e,
            f: f
          } = this,
          dt = a * d - b * c,
          nextA = d / dt,
          nextB = -b / dt,
          nextC = -c / dt,
          nextD = a / dt,
          nextE = (c * f - d * e) / dt,
          nextF = -(a * f - b * e) / dt,
          {
            x: x,
            y: y
          } = source;
        target.x = x * nextA + y * nextC + nextE, target.y = x * nextB + y * nextD + nextF;
      }
      onlyTranslate() {
        let scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
        return this.a === scale && 0 === this.b && 0 === this.c && this.d === scale;
      }
      clone() {
        return new Matrix(this.a, this.b, this.c, this.d, this.e, this.f);
      }
      toTransformAttrs() {
        const a = this.a,
          b = this.b,
          c = this.c,
          d = this.d,
          delta = a * d - b * c,
          result = {
            x: this.e,
            y: this.f,
            rotateDeg: 0,
            scaleX: 0,
            scaleY: 0,
            skewX: 0,
            skewY: 0
          };
        if (0 !== a || 0 !== b) {
          const r = Math.sqrt(a * a + b * b);
          result.rotateDeg = b > 0 ? Math.acos(a / r) : -Math.acos(a / r), result.scaleX = r, result.scaleY = delta / r, result.skewX = (a * c + b * d) / delta, result.skewY = 0;
        } else if (0 !== c || 0 !== d) {
          const s = Math.sqrt(c * c + d * d);
          result.rotateDeg = Math.PI / 2 - (d > 0 ? Math.acos(-c / s) : -Math.acos(c / s)), result.scaleX = delta / s, result.scaleY = s, result.skewX = 0, result.skewY = (a * c + b * d) / delta;
        }
        return result.rotateDeg = radianToDegree(result.rotateDeg), result;
      }
    }
    function normalTransform(out, origin, x, y, scaleX, scaleY, angle, rotateCenter) {
      const oa = origin.a,
        ob = origin.b,
        oc = origin.c,
        od = origin.d,
        oe = origin.e,
        of = origin.f,
        cosTheta = cos(angle),
        sinTheta = sin(angle);
      let rotateCenterX, rotateCenterY;
      rotateCenter ? (rotateCenterX = rotateCenter[0], rotateCenterY = rotateCenter[1]) : (rotateCenterX = x, rotateCenterY = y);
      const offsetX = rotateCenterX - x,
        offsetY = rotateCenterY - y,
        a1 = oa * cosTheta + oc * sinTheta,
        b1 = ob * cosTheta + od * sinTheta,
        c1 = oc * cosTheta - oa * sinTheta,
        d1 = od * cosTheta - ob * sinTheta;
      out.a = scaleX * a1, out.b = scaleX * b1, out.c = scaleY * c1, out.d = scaleY * d1, out.e = oe + oa * rotateCenterX + oc * rotateCenterY - a1 * offsetX - c1 * offsetY, out.f = of + ob * rotateCenterX + od * rotateCenterY - b1 * offsetX - d1 * offsetY;
    }

    class LRU {
      constructor() {
        this.CLEAN_THRESHOLD = 1e3, this.L_TIME = 1e3, this.R_COUNT = 1, this.R_TIMESTAMP_MAX_SIZE = 20;
      }
      clearCache(cache, params) {
        const {
          CLEAN_THRESHOLD = this.CLEAN_THRESHOLD,
          L_TIME = this.L_TIME,
          R_COUNT = this.R_COUNT
        } = params;
        if (cache.size < CLEAN_THRESHOLD) return 0;
        let clearNum = 0;
        const clear = key => {
            clearNum++, cache.delete(key);
          },
          now = Date.now();
        return cache.forEach((item, key) => {
          if (item.timestamp.length < R_COUNT) return clear(key);
          let useCount = 0;
          for (; now - item.timestamp[item.timestamp.length - 1 - useCount] < L_TIME && (useCount++, !(useCount >= R_COUNT)););
          if (useCount < R_COUNT) return clear(key);
          for (; now - item.timestamp[0] > L_TIME;) item.timestamp.shift();
        }), clearNum;
      }
      addLimitedTimestamp(cacheItem, t, params) {
        const {
          R_TIMESTAMP_MAX_SIZE = this.R_TIMESTAMP_MAX_SIZE
        } = params;
        cacheItem.timestamp.length > R_TIMESTAMP_MAX_SIZE && cacheItem.timestamp.shift(), cacheItem.timestamp.push(t);
      }
      clearTimeStamp(cache, params) {
        const {
            L_TIME = this.L_TIME
          } = params,
          now = Date.now();
        cache.forEach(item => {
          for (; now - item.timestamp[0] > L_TIME;) item.timestamp.shift();
        });
      }
      clearItemTimestamp(cacheItem, params) {
        const {
            L_TIME = this.L_TIME
          } = params,
          now = Date.now();
        for (; now - cacheItem.timestamp[0] > L_TIME;) cacheItem.timestamp.shift();
      }
    }

    function hslToRgb$1(h, s, l) {
      s /= 100, l /= 100;
      const c = (1 - Math.abs(2 * l - 1)) * s,
        x = c * (1 - Math.abs(h / 60 % 2 - 1)),
        m = l - c / 2;
      let r = 0,
        g = 0,
        b = 0;
      return 0 <= h && h < 60 ? (r = c, g = x, b = 0) : 60 <= h && h < 120 ? (r = x, g = c, b = 0) : 120 <= h && h < 180 ? (r = 0, g = c, b = x) : 180 <= h && h < 240 ? (r = 0, g = x, b = c) : 240 <= h && h < 300 ? (r = x, g = 0, b = c) : 300 <= h && h < 360 && (r = c, g = 0, b = x), r = Math.round(255 * (r + m)), g = Math.round(255 * (g + m)), b = Math.round(255 * (b + m)), {
        r: r,
        g: g,
        b: b
      };
    }

    function rgbToHsl$1(r, g, b) {
      r /= 255, g /= 255, b /= 255;
      const cMin = Math.min(r, g, b),
        cMax = Math.max(r, g, b),
        delta = cMax - cMin;
      let h = 0,
        s = 0,
        l = 0;
      return h = 0 === delta ? 0 : cMax === r ? (g - b) / delta % 6 : cMax === g ? (b - r) / delta + 2 : (r - g) / delta + 4, h = Math.round(60 * h), h < 0 && (h += 360), l = (cMax + cMin) / 2, s = 0 === delta ? 0 : delta / (1 - Math.abs(2 * l - 1)), s = +(100 * s).toFixed(1), l = +(100 * l).toFixed(1), {
        h: h,
        s: s,
        l: l
      };
    }

    const REG_HEX$1 = /^#([0-9a-f]{3,8})$/,
      DEFAULT_COLORS_OPACITY$1 = {
        transparent: 4294967040
      };
    const DEFAULT_COLORS$1 = {
      aliceblue: 15792383,
      antiquewhite: 16444375,
      aqua: 65535,
      aquamarine: 8388564,
      azure: 15794175,
      beige: 16119260,
      bisque: 16770244,
      black: 0,
      blanchedalmond: 16772045,
      blue: 255,
      blueviolet: 9055202,
      brown: 10824234,
      burlywood: 14596231,
      cadetblue: 6266528,
      chartreuse: 8388352,
      chocolate: 13789470,
      coral: 16744272,
      cornflowerblue: 6591981,
      cornsilk: 16775388,
      crimson: 14423100,
      cyan: 65535,
      darkblue: 139,
      darkcyan: 35723,
      darkgoldenrod: 12092939,
      darkgray: 11119017,
      darkgreen: 25600,
      darkgrey: 11119017,
      darkkhaki: 12433259,
      darkmagenta: 9109643,
      darkolivegreen: 5597999,
      darkorange: 16747520,
      darkorchid: 10040012,
      darkred: 9109504,
      darksalmon: 15308410,
      darkseagreen: 9419919,
      darkslateblue: 4734347,
      darkslategray: 3100495,
      darkslategrey: 3100495,
      darkturquoise: 52945,
      darkviolet: 9699539,
      deeppink: 16716947,
      deepskyblue: 49151,
      dimgray: 6908265,
      dimgrey: 6908265,
      dodgerblue: 2003199,
      firebrick: 11674146,
      floralwhite: 16775920,
      forestgreen: 2263842,
      fuchsia: 16711935,
      gainsboro: 14474460,
      ghostwhite: 16316671,
      gold: 16766720,
      goldenrod: 14329120,
      gray: 8421504,
      green: 32768,
      greenyellow: 11403055,
      grey: 8421504,
      honeydew: 15794160,
      hotpink: 16738740,
      indianred: 13458524,
      indigo: 4915330,
      ivory: 16777200,
      khaki: 15787660,
      lavender: 15132410,
      lavenderblush: 16773365,
      lawngreen: 8190976,
      lemonchiffon: 16775885,
      lightblue: 11393254,
      lightcoral: 15761536,
      lightcyan: 14745599,
      lightgoldenrodyellow: 16448210,
      lightgray: 13882323,
      lightgreen: 9498256,
      lightgrey: 13882323,
      lightpink: 16758465,
      lightsalmon: 16752762,
      lightseagreen: 2142890,
      lightskyblue: 8900346,
      lightslategray: 7833753,
      lightslategrey: 7833753,
      lightsteelblue: 11584734,
      lightyellow: 16777184,
      lime: 65280,
      limegreen: 3329330,
      linen: 16445670,
      magenta: 16711935,
      maroon: 8388608,
      mediumaquamarine: 6737322,
      mediumblue: 205,
      mediumorchid: 12211667,
      mediumpurple: 9662683,
      mediumseagreen: 3978097,
      mediumslateblue: 8087790,
      mediumspringgreen: 64154,
      mediumturquoise: 4772300,
      mediumvioletred: 13047173,
      midnightblue: 1644912,
      mintcream: 16121850,
      mistyrose: 16770273,
      moccasin: 16770229,
      navajowhite: 16768685,
      navy: 128,
      oldlace: 16643558,
      olive: 8421376,
      olivedrab: 7048739,
      orange: 16753920,
      orangered: 16729344,
      orchid: 14315734,
      palegoldenrod: 15657130,
      palegreen: 10025880,
      paleturquoise: 11529966,
      palevioletred: 14381203,
      papayawhip: 16773077,
      peachpuff: 16767673,
      peru: 13468991,
      pink: 16761035,
      plum: 14524637,
      powderblue: 11591910,
      purple: 8388736,
      rebeccapurple: 6697881,
      red: 16711680,
      rosybrown: 12357519,
      royalblue: 4286945,
      saddlebrown: 9127187,
      salmon: 16416882,
      sandybrown: 16032864,
      seagreen: 3050327,
      seashell: 16774638,
      sienna: 10506797,
      silver: 12632256,
      skyblue: 8900331,
      slateblue: 6970061,
      slategray: 7372944,
      slategrey: 7372944,
      snow: 16775930,
      springgreen: 65407,
      steelblue: 4620980,
      tan: 13808780,
      teal: 32896,
      thistle: 14204888,
      tomato: 16737095,
      turquoise: 4251856,
      violet: 15631086,
      wheat: 16113331,
      white: 16777215,
      whitesmoke: 16119285,
      yellow: 16776960,
      yellowgreen: 10145074
    };
    function hex$1(value) {
      return ((value = Math.max(0, Math.min(255, Math.round(value) || 0))) < 16 ? "0" : "") + value.toString(16);
    }
    function rgb$1(value) {
      return isNumber$6(value) ? new RGB$1(value >> 16, value >> 8 & 255, 255 & value, 1) : isArray$9(value) ? new RGB$1(value[0], value[1], value[2]) : new RGB$1(255, 255, 255);
    }
    function rgba$1(value) {
      return isNumber$6(value) ? new RGB$1(value >>> 24, value >>> 16 & 255, value >>> 8 & 255, 255 & value) : isArray$9(value) ? new RGB$1(value[0], value[1], value[2], value[3]) : new RGB$1(255, 255, 255, 1);
    }
    function SRGBToLinear$1(c) {
      return c < .04045 ? .0773993808 * c : Math.pow(.9478672986 * c + .0521327014, 2.4);
    }
    function LinearToSRGB$1(c) {
      return c < .0031308 ? 12.92 * c : 1.055 * Math.pow(c, .41666) - .055;
    }
    const setHex$1 = (formatValue, forceHex) => {
      const isHex = REG_HEX$1.exec(formatValue);
      if (forceHex || isHex) {
        const hex = parseInt(isHex[1], 16),
          hexLength = isHex[1].length;
        return 3 === hexLength ? new RGB$1((hex >> 8 & 15) + ((hex >> 8 & 15) << 4), (hex >> 4 & 15) + ((hex >> 4 & 15) << 4), (15 & hex) + ((15 & hex) << 4), 1) : 6 === hexLength ? rgb$1(hex) : 8 === hexLength ? new RGB$1(hex >> 24 & 255, hex >> 16 & 255, hex >> 8 & 255, (255 & hex) / 255) : null;
      }
    };
    let Color$1 = class Color {
      static Brighter(source) {
        let b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
        return 1 === b ? source : new Color(source).brighter(b).toRGBA();
      }
      static SetOpacity(source) {
        let o = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
        return 1 === o ? source : new Color(source).setOpacity(o).toRGBA();
      }
      static getColorBrightness(source) {
        let model = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "hsl";
        const color = source instanceof Color ? source : new Color(source);
        switch (model) {
          case "hsv":
          default:
            return color.getHSVBrightness();
          case "hsl":
            return color.getHSLBrightness();
          case "lum":
            return color.getLuminance();
          case "lum2":
            return color.getLuminance2();
          case "lum3":
            return color.getLuminance3();
          case "wcag":
            return color.getLuminanceWCAG();
        }
      }
      static parseColorString(value) {
        if (isValid$5(DEFAULT_COLORS_OPACITY$1[value])) return rgba$1(DEFAULT_COLORS_OPACITY$1[value]);
        if (isValid$5(DEFAULT_COLORS$1[value])) return rgb$1(DEFAULT_COLORS$1[value]);
        const formatValue = `${value}`.trim().toLowerCase(),
          hexRes = setHex$1(formatValue);
        if (void 0 !== hexRes) return hexRes;
        if (/^(rgb|RGB|rgba|RGBA)/.test(formatValue)) {
          const aColor = formatValue.replace(/(?:\(|\)|rgba|RGBA|rgb|RGB)*/g, "").split(",");
          return new RGB$1(parseInt(aColor[0], 10), parseInt(aColor[1], 10), parseInt(aColor[2], 10), parseFloat(aColor[3]));
        }
        if (/^(hsl|HSL|hsla|HSLA)/.test(formatValue)) {
          const aColor = formatValue.replace(/(?:\(|\)|hsla|HSLA|hsl|HSL)*/g, "").split(","),
            rgb = hslToRgb$1(parseInt(aColor[0], 10), parseInt(aColor[1], 10), parseInt(aColor[2], 10));
          return new RGB$1(rgb.r, rgb.g, rgb.b, parseFloat(aColor[3]));
        }
      }
      constructor(value) {
        const color = Color.parseColorString(value);
        color ? this.color = color : (this.color = new RGB$1(255, 255, 255));
      }
      toRGBA() {
        return this.color.formatRgb();
      }
      toString() {
        return this.color.formatRgb();
      }
      toHex() {
        return this.color.formatHex();
      }
      toHsl() {
        return this.color.formatHsl();
      }
      brighter(k) {
        const {
          r: r,
          g: g,
          b: b
        } = this.color;
        return this.color.r = Math.max(0, Math.min(255, Math.floor(r * k))), this.color.g = Math.max(0, Math.min(255, Math.floor(g * k))), this.color.b = Math.max(0, Math.min(255, Math.floor(b * k))), this;
      }
      add(color) {
        const {
          r: r,
          g: g,
          b: b
        } = this.color;
        return this.color.r += Math.min(255, r + color.color.r), this.color.g += Math.min(255, g + color.color.g), this.color.b += Math.min(255, b + color.color.b), this;
      }
      sub(color) {
        return this.color.r = Math.max(0, this.color.r - color.color.r), this.color.g = Math.max(0, this.color.g - color.color.g), this.color.b = Math.max(0, this.color.b - color.color.b), this;
      }
      multiply(color) {
        const {
          r: r,
          g: g,
          b: b
        } = this.color;
        return this.color.r = Math.max(0, Math.min(255, Math.floor(r * color.color.r))), this.color.g = Math.max(0, Math.min(255, Math.floor(g * color.color.g))), this.color.b = Math.max(0, Math.min(255, Math.floor(b * color.color.b))), this;
      }
      getHSVBrightness() {
        return Math.max(this.color.r, this.color.g, this.color.b) / 255;
      }
      getHSLBrightness() {
        return .5 * (Math.max(this.color.r, this.color.g, this.color.b) / 255 + Math.min(this.color.r, this.color.g, this.color.b) / 255);
      }
      setHsl(h, s, l) {
        const opacity = this.color.opacity,
          hsl = rgbToHsl$1(this.color.r, this.color.g, this.color.b),
          rgb = hslToRgb$1(isNil$5(h) ? hsl.h : clamp$3(h, 0, 360), isNil$5(s) ? hsl.s : s >= 0 && s <= 1 ? 100 * s : s, isNil$5(l) ? hsl.l : l <= 1 && l >= 0 ? 100 * l : l);
        return this.color = new RGB$1(rgb.r, rgb.g, rgb.b, opacity), this;
      }
      setRGB(r, g, b) {
        return !isNil$5(r) && (this.color.r = r), !isNil$5(g) && (this.color.g = g), !isNil$5(b) && (this.color.b = b), this;
      }
      setHex(value) {
        const formatValue = `${value}`.trim().toLowerCase(),
          res = setHex$1(formatValue, !0);
        return null != res ? res : this;
      }
      setColorName(name) {
        const hex = DEFAULT_COLORS$1[name.toLowerCase()];
        return void 0 !== hex ? this.setHex(hex) : (void 0), this;
      }
      setScalar(scalar) {
        return this.color.r = scalar, this.color.g = scalar, this.color.b = scalar, this;
      }
      setOpacity() {
        let o = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
        return this.color.opacity = o, this;
      }
      getLuminance() {
        return (.2126 * this.color.r + .7152 * this.color.g + .0722 * this.color.b) / 255;
      }
      getLuminance2() {
        return (.2627 * this.color.r + .678 * this.color.g + .0593 * this.color.b) / 255;
      }
      getLuminance3() {
        return (.299 * this.color.r + .587 * this.color.g + .114 * this.color.b) / 255;
      }
      getLuminanceWCAG() {
        const RsRGB = this.color.r / 255,
          GsRGB = this.color.g / 255,
          BsRGB = this.color.b / 255;
        let R, G, B;
        R = RsRGB <= .03928 ? RsRGB / 12.92 : Math.pow((RsRGB + .055) / 1.055, 2.4), G = GsRGB <= .03928 ? GsRGB / 12.92 : Math.pow((GsRGB + .055) / 1.055, 2.4), B = BsRGB <= .03928 ? BsRGB / 12.92 : Math.pow((BsRGB + .055) / 1.055, 2.4);
        return .2126 * R + .7152 * G + .0722 * B;
      }
      clone() {
        return new Color(this.color.toString());
      }
      copyGammaToLinear(color) {
        let gammaFactor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
        return this.color.r = Math.pow(color.color.r, gammaFactor), this.color.g = Math.pow(color.color.g, gammaFactor), this.color.b = Math.pow(color.color.b, gammaFactor), this;
      }
      copyLinearToGamma(color) {
        let gammaFactor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
        const safeInverse = gammaFactor > 0 ? 1 / gammaFactor : 1;
        return this.color.r = Math.pow(color.color.r, safeInverse), this.color.g = Math.pow(color.color.g, safeInverse), this.color.b = Math.pow(color.color.b, safeInverse), this;
      }
      convertGammaToLinear(gammaFactor) {
        return this.copyGammaToLinear(this, gammaFactor), this;
      }
      convertLinearToGamma(gammaFactor) {
        return this.copyLinearToGamma(this, gammaFactor), this;
      }
      copySRGBToLinear(color) {
        return this.color.r = SRGBToLinear$1(color.color.r), this.color.g = SRGBToLinear$1(color.color.g), this.color.b = SRGBToLinear$1(color.color.b), this;
      }
      copyLinearToSRGB(color) {
        return this.color.r = LinearToSRGB$1(color.color.r), this.color.g = LinearToSRGB$1(color.color.g), this.color.b = LinearToSRGB$1(color.color.b), this;
      }
      convertSRGBToLinear() {
        return this.copySRGBToLinear(this), this;
      }
      convertLinearToSRGB() {
        return this.copyLinearToSRGB(this), this;
      }
    };
    let RGB$1 = class RGB {
      constructor(r, g, b, opacity) {
        this.r = isNaN(+r) ? 255 : Math.max(0, Math.min(255, +r)), this.g = isNaN(+g) ? 255 : Math.max(0, Math.min(255, +g)), this.b = isNaN(+b) ? 255 : Math.max(0, Math.min(255, +b)), isValid$5(opacity) ? this.opacity = isNaN(+opacity) ? 1 : Math.max(0, Math.min(1, +opacity)) : this.opacity = 1;
      }
      formatHex() {
        return `#${hex$1(this.r) + hex$1(this.g) + hex$1(this.b) + (1 === this.opacity ? "" : hex$1(255 * this.opacity))}`;
      }
      formatRgb() {
        const opacity = this.opacity;
        return `${1 === opacity ? "rgb(" : "rgba("}${this.r},${this.g},${this.b}${1 === opacity ? ")" : `,${opacity})`}`;
      }
      formatHsl() {
        const opacity = this.opacity,
          {
            h: h,
            s: s,
            l: l
          } = rgbToHsl$1(this.r, this.g, this.b);
        return `${1 === opacity ? "hsl(" : "hsla("}${h},${s}%,${l}%${1 === opacity ? ")" : `,${opacity})`}`;
      }
      toString() {
        return this.formatHex();
      }
    };

    function hexToRgb$1(str) {
      let r = "",
        g = "",
        b = "";
      const strtIndex = "#" === str[0] ? 1 : 0;
      for (let i = strtIndex; i < str.length; i++) "#" !== str[i] && (i < strtIndex + 2 ? r += str[i] : i < strtIndex + 4 ? g += str[i] : i < strtIndex + 6 && (b += str[i]));
      return [parseInt(r, 16), parseInt(g, 16), parseInt(b, 16)];
    }

    function rgbToHex$1(r, g, b) {
      return Number((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    }

    function interpolateRgb$3(colorA, colorB) {
      const redA = colorA.r,
        redB = colorB.r,
        greenA = colorA.g,
        greenB = colorB.g,
        blueA = colorA.b,
        blueB = colorB.b,
        opacityA = colorA.opacity,
        opacityB = colorB.opacity;
      return t => {
        const r = Math.round(redA * (1 - t) + redB * t),
          g = Math.round(greenA * (1 - t) + greenB * t),
          b = Math.round(blueA * (1 - t) + blueB * t);
        return new RGB$1(r, g, b, opacityA * (1 - t) + opacityB * t);
      };
    }

    var ColorUtil$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        Color: Color$1,
        DEFAULT_COLORS: DEFAULT_COLORS$1,
        RGB: RGB$1,
        hexToRgb: hexToRgb$1,
        hslToRgb: hslToRgb$1,
        interpolateRgb: interpolateRgb$3,
        rgbToHex: rgbToHex$1,
        rgbToHsl: rgbToHsl$1
    });

    function normalizePadding(padding) {
      if (isValidNumber$3(padding)) return [padding, padding, padding, padding];
      if (isArray$9(padding)) {
        const length = padding.length;
        if (1 === length) {
          const paddingValue = padding[0];
          return [paddingValue, paddingValue, paddingValue, paddingValue];
        }
        if (2 === length) {
          const [vertical, horizontal] = padding;
          return [vertical, horizontal, vertical, horizontal];
        }
        if (3 === length) {
          const [top, horizontal, bottom] = padding;
          return [top, horizontal, bottom, horizontal];
        }
        if (4 === length) return padding;
      }
      if (isObject$9(padding)) {
        const {
          top = 0,
          right = 0,
          bottom = 0,
          left = 0
        } = padding;
        return [top, right, bottom, left];
      }
      return [0, 0, 0, 0];
    }

    const circleThreshold = tau - 1e-8;
    class BoundsContext {
      constructor(bounds) {
        this.init(bounds);
      }
      init(bounds) {
        this.bounds = bounds;
      }
      arc(cx, cy, r, sa, ea, ccw) {
        if (Math.abs(ea - sa) > circleThreshold) return this.bounds.add(cx - r, cy - r), void this.bounds.add(cx + r, cy + r);
        let s,
          i,
          x,
          y,
          xmin = 1 / 0,
          xmax = -1 / 0,
          ymin = 1 / 0,
          ymax = -1 / 0;
        function update(a) {
          x = r * Math.cos(a), y = r * Math.sin(a), x < xmin && (xmin = x), x > xmax && (xmax = x), y < ymin && (ymin = y), y > ymax && (ymax = y);
        }
        if (update(sa), update(ea), ea !== sa) if ((sa %= tau) < 0 && (sa += tau), (ea %= tau) < 0 && (ea += tau), ea < sa && (ccw = !ccw, s = sa, sa = ea, ea = s), ccw) for (ea -= tau, s = sa - sa % halfPi$1, i = 0; i < 4 && s > ea; ++i, s -= halfPi$1) update(s);else for (s = sa - sa % halfPi$1 + halfPi$1, i = 0; i < 4 && s < ea; ++i, s += halfPi$1) update(s);
        this.bounds.add(cx + xmin, cy + ymin), this.bounds.add(cx + xmax, cy + ymax);
      }
      arcTo(x1, y1, x2, y2, radius) {
        this.bounds.add(x1, y1);
      }
      bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
        this.bounds.add(cp1x, cp1y), this.bounds.add(cp2x, cp2y), this.bounds.add(x, y);
      }
      closePath() {}
      ellipse() {
        throw new Error("不支持ellipse");
      }
      lineTo(x, y) {
        this.bounds.add(x, y);
      }
      moveTo(x, y) {
        this.bounds.add(x, y);
      }
      quadraticCurveTo(cpx, cpy, x, y) {
        this.bounds.add(cpx, cpy), this.bounds.add(x, y);
      }
      rect(x, y, w, h) {
        this.bounds.add(x, y), this.bounds.add(x + w, y + h);
      }
      clear() {
        this.bounds.clear();
      }
      release() {}
    }

    class CurvePath {
      constructor() {
        this._curves = [], this.bounds = new AABBBounds$1();
      }
      get curves() {
        return this._curves;
      }
      getCurveLengths() {
        return this._curves.map(curve => curve.getLength());
      }
      getPointAt(t) {
        return {
          x: 0,
          y: 0
        };
      }
      getLength() {
        return 0;
      }
      getBounds() {
        return this.bounds;
      }
    }

    const rePathCommand = /([-+]?((\d+\.\d+)|((\d+)|(\.\d+)))(?:[eE][-+]?\d+)?)/gi,
      commandLengths = {
        m: 2,
        l: 2,
        h: 1,
        v: 1,
        c: 6,
        s: 4,
        q: 4,
        t: 2,
        a: 7,
        M: 2,
        L: 2,
        H: 1,
        V: 1,
        C: 6,
        S: 4,
        Q: 4,
        T: 2,
        A: 7
      };
    const enumCommandMap = {
      A: 0,
      AT: 1,
      C: 2,
      Z: 3,
      E: 4,
      L: 5,
      M: 6,
      Q: 7,
      R: 8
    };
    let currPath, coordsStr, commandChar, coordStr, coordNumber, standardCommandLen;
    function parseSvgPath(str) {
      if (!str) return [];
      const paths = str.match(/[mzlhvcsqta][^mzlhvcsqta]*/gi);
      if (null === paths) return [];
      let currCommandData, coordsStrArr;
      const result = [];
      for (let i = 0, len = paths.length; i < len; i++) if (currPath = paths[i], coordsStr = currPath.slice(1), commandChar = currPath[0], currCommandData = [commandChar], coordsStrArr = coordsStr.match(rePathCommand), null !== coordsStrArr) {
        for (let i = 0, len = coordsStrArr.length; i < len; i++) coordStr = coordsStrArr[i], coordNumber = parseFloat(coordStr), Number.isNaN(coordNumber) || currCommandData.push(coordNumber);
        if (standardCommandLen = commandLengths[commandChar], currCommandData.length - 1 > standardCommandLen) {
          let subCommand,
            bestCommandChar = commandChar;
          for (let i = 1, len = currCommandData.length; i < len; i += standardCommandLen) {
            subCommand = [bestCommandChar];
            for (let j = i, subLen = i + standardCommandLen; j < subLen; j++) subCommand.push(currCommandData[j]);
            result.push(subCommand), "m" === bestCommandChar ? bestCommandChar = "l" : "M" === bestCommandChar && (bestCommandChar = "L");
          }
        } else result.push(currCommandData);
      } else result.push(currCommandData);
      return result;
    }

    var UpdateTag;
    !function (UpdateTag) {
      UpdateTag[UpdateTag.NONE = 0] = "NONE", UpdateTag[UpdateTag.UPDATE_BOUNDS = 1] = "UPDATE_BOUNDS", UpdateTag[UpdateTag.UPDATE_SHAPE = 2] = "UPDATE_SHAPE", UpdateTag[UpdateTag.CLEAR_SHAPE = 253] = "CLEAR_SHAPE", UpdateTag[UpdateTag.UPDATE_SHAPE_AND_BOUNDS = 3] = "UPDATE_SHAPE_AND_BOUNDS", UpdateTag[UpdateTag.INIT = 179] = "INIT", UpdateTag[UpdateTag.CLEAR_BOUNDS = 254] = "CLEAR_BOUNDS", UpdateTag[UpdateTag.UPDATE_GLOBAL_MATRIX = 32] = "UPDATE_GLOBAL_MATRIX", UpdateTag[UpdateTag.CLEAR_GLOBAL_MATRIX = 223] = "CLEAR_GLOBAL_MATRIX", UpdateTag[UpdateTag.UPDATE_LOCAL_MATRIX = 16] = "UPDATE_LOCAL_MATRIX", UpdateTag[UpdateTag.CLEAR_LOCAL_MATRIX = 239] = "CLEAR_LOCAL_MATRIX", UpdateTag[UpdateTag.UPDATE_GLOBAL_LOCAL_MATRIX = 48] = "UPDATE_GLOBAL_LOCAL_MATRIX", UpdateTag[UpdateTag.UPDATE_LAYOUT = 128] = "UPDATE_LAYOUT", UpdateTag[UpdateTag.CLEAR_LAYOUT = 127] = "CLEAR_LAYOUT";
    }(UpdateTag || (UpdateTag = {}));
    var IContainPointMode;
    !function (IContainPointMode) {
      IContainPointMode[IContainPointMode.GLOBAL = 1] = "GLOBAL", IContainPointMode[IContainPointMode.LOCAL = 16] = "LOCAL", IContainPointMode[IContainPointMode.GLOBAL_ACCURATE = 3] = "GLOBAL_ACCURATE", IContainPointMode[IContainPointMode.LOCAL_ACCURATE = 48] = "LOCAL_ACCURATE";
    }(IContainPointMode || (IContainPointMode = {}));
    var AttributeUpdateType;
    !function (AttributeUpdateType) {
      AttributeUpdateType[AttributeUpdateType.INIT = 0] = "INIT", AttributeUpdateType[AttributeUpdateType.DEFAULT = 1] = "DEFAULT", AttributeUpdateType[AttributeUpdateType.STATE = 2] = "STATE", AttributeUpdateType[AttributeUpdateType.ANIMATE_BIND = 10] = "ANIMATE_BIND", AttributeUpdateType[AttributeUpdateType.ANIMATE_PLAY = 11] = "ANIMATE_PLAY", AttributeUpdateType[AttributeUpdateType.ANIMATE_START = 12] = "ANIMATE_START", AttributeUpdateType[AttributeUpdateType.ANIMATE_UPDATE = 13] = "ANIMATE_UPDATE", AttributeUpdateType[AttributeUpdateType.ANIMATE_END = 14] = "ANIMATE_END", AttributeUpdateType[AttributeUpdateType.TRANSLATE = 20] = "TRANSLATE", AttributeUpdateType[AttributeUpdateType.TRANSLATE_TO = 21] = "TRANSLATE_TO", AttributeUpdateType[AttributeUpdateType.SCALE = 22] = "SCALE", AttributeUpdateType[AttributeUpdateType.SCALE_TO = 23] = "SCALE_TO", AttributeUpdateType[AttributeUpdateType.ROTATE = 24] = "ROTATE", AttributeUpdateType[AttributeUpdateType.ROTATE_TO = 25] = "ROTATE_TO";
    }(AttributeUpdateType || (AttributeUpdateType = {}));
    var AnimateStatus;
    !function (AnimateStatus) {
      AnimateStatus[AnimateStatus.INITIAL = 0] = "INITIAL", AnimateStatus[AnimateStatus.RUNNING = 1] = "RUNNING", AnimateStatus[AnimateStatus.PAUSED = 2] = "PAUSED", AnimateStatus[AnimateStatus.END = 3] = "END";
    }(AnimateStatus || (AnimateStatus = {}));
    var AnimateMode;
    !function (AnimateMode) {
      AnimateMode[AnimateMode.NORMAL = 0] = "NORMAL", AnimateMode[AnimateMode.SET_ATTR_IMMEDIATELY = 1] = "SET_ATTR_IMMEDIATELY";
    }(AnimateMode || (AnimateMode = {}));
    var AnimateStepType;
    !function (AnimateStepType) {
      AnimateStepType.wait = "wait", AnimateStepType.from = "from", AnimateStepType.to = "to", AnimateStepType.customAnimate = "customAnimate";
    }(AnimateStepType || (AnimateStepType = {}));
    var Direction$2;
    !function (Direction) {
      Direction[Direction.ROW = 1] = "ROW", Direction[Direction.COLUMN = 2] = "COLUMN";
    }(Direction$2 || (Direction$2 = {}));
    var CurveTypeEnum;
    !function (CurveTypeEnum) {
      CurveTypeEnum[CurveTypeEnum.CubicBezierCurve = 0] = "CubicBezierCurve", CurveTypeEnum[CurveTypeEnum.QuadraticBezierCurve = 1] = "QuadraticBezierCurve", CurveTypeEnum[CurveTypeEnum.ArcCurve = 2] = "ArcCurve", CurveTypeEnum[CurveTypeEnum.LineCurve = 3] = "LineCurve", CurveTypeEnum[CurveTypeEnum.EllipseCurve = 4] = "EllipseCurve", CurveTypeEnum[CurveTypeEnum.MoveCurve = 5] = "MoveCurve";
    }(CurveTypeEnum || (CurveTypeEnum = {}));
    var BaseRenderContributionTime;
    !function (BaseRenderContributionTime) {
      BaseRenderContributionTime[BaseRenderContributionTime.beforeFillStroke = 0] = "beforeFillStroke", BaseRenderContributionTime[BaseRenderContributionTime.afterFillStroke = 1] = "afterFillStroke";
    }(BaseRenderContributionTime || (BaseRenderContributionTime = {}));

    function segments(x, y, rx, ry, large, sweep, rotateX, ox, oy) {
      const th = degreeToRadian$1(rotateX),
        sin_th = Math.sin(th),
        cos_th = Math.cos(th),
        px = cos_th * (ox - x) * .5 + sin_th * (oy - y) * .5,
        py = cos_th * (oy - y) * .5 - sin_th * (ox - x) * .5;
      let pl = px * px / ((rx = Math.abs(rx)) * rx) + py * py / ((ry = Math.abs(ry)) * ry);
      pl > 1 && (pl = Math.sqrt(pl), rx *= pl, ry *= pl);
      const a00 = cos_th / rx,
        a01 = sin_th / rx,
        a10 = -sin_th / ry,
        a11 = cos_th / ry,
        x0 = a00 * ox + a01 * oy,
        y0 = a10 * ox + a11 * oy,
        x1 = a00 * x + a01 * y,
        y1 = a10 * x + a11 * y;
      let sfactor_sq = 1 / ((x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0)) - .25;
      sfactor_sq < 0 && (sfactor_sq = 0);
      let sfactor = Math.sqrt(sfactor_sq);
      sweep === large && (sfactor = -sfactor);
      const xc = .5 * (x0 + x1) - sfactor * (y1 - y0),
        yc = .5 * (y0 + y1) + sfactor * (x1 - x0),
        th0 = Math.atan2(y0 - yc, x0 - xc);
      let th_arc = Math.atan2(y1 - yc, x1 - xc) - th0;
      th_arc < 0 && 1 === sweep ? th_arc += tau : th_arc > 0 && 0 === sweep && (th_arc -= tau);
      const segs = Math.ceil(Math.abs(th_arc / (halfPi$1 + .001))),
        result = [];
      for (let i = 0; i < segs; ++i) {
        const th2 = th0 + i * th_arc / segs,
          th3 = th0 + (i + 1) * th_arc / segs;
        result[i] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];
      }
      return result;
    }
    function bezier(params) {
      const cx = params[0],
        cy = params[1],
        th0 = params[2],
        th1 = params[3],
        rx = params[4],
        ry = params[5],
        sin_th = params[6],
        cos_th = params[7],
        a00 = cos_th * rx,
        a01 = -sin_th * ry,
        a10 = sin_th * rx,
        a11 = cos_th * ry,
        cos_th0 = Math.cos(th0),
        sin_th0 = Math.sin(th0),
        cos_th1 = Math.cos(th1),
        sin_th1 = Math.sin(th1),
        th_half = .5 * (th1 - th0),
        sin_th_h2 = Math.sin(.5 * th_half),
        t = 8 / 3 * sin_th_h2 * sin_th_h2 / Math.sin(th_half),
        x1 = cx + cos_th0 - t * sin_th0,
        y1 = cy + sin_th0 + t * cos_th0,
        x3 = cx + cos_th1,
        y3 = cy + sin_th1,
        x2 = x3 + t * sin_th1,
        y2 = y3 - t * cos_th1;
      return [a00 * x1 + a01 * y1, a10 * x1 + a11 * y1, a00 * x2 + a01 * y2, a10 * x2 + a11 * y2, a00 * x3 + a01 * y3, a10 * x3 + a11 * y3];
    }
    function drawArc(context, x, y, coords) {
      const seg = segments(coords[5], coords[6], coords[0], coords[1], coords[3], coords[4], coords[2], x, y);
      for (let i = 0; i < seg.length; ++i) {
        const bez = bezier(seg[i]);
        context.bezierCurveTo(bez[0], bez[1], bez[2], bez[3], bez[4], bez[5]);
      }
    }
    const addArcToBezierPath$1 = (bezierPath, startAngle, endAngle, cx, cy, rx, ry) => {
      const delta = Math.abs(endAngle - startAngle),
        count = delta > .5 * Math.PI ? Math.ceil(2 * delta / Math.PI) : 1,
        stepAngle = (endAngle - startAngle) / count;
      for (let i = 0; i < count; i++) {
        const sa = startAngle + stepAngle * i,
          ea = startAngle + stepAngle * (i + 1),
          len = 4 * Math.tan(Math.abs(stepAngle) / 4) / 3,
          dir = ea < sa ? -1 : 1,
          c1 = Math.cos(sa),
          s1 = Math.sin(sa),
          c2 = Math.cos(ea),
          s2 = Math.sin(ea),
          x1 = c1 * rx + cx,
          y1 = s1 * ry + cy,
          x4 = c2 * rx + cx,
          y4 = s2 * ry + cy,
          hx = rx * len * dir,
          hy = ry * len * dir;
        bezierPath.push(x1 - hx * s1, y1 + hy * c1, x4 + hx * s2, y4 - hy * c2, x4, y4);
      }
    };

    const commandFuncs = [(command, context, x, y, sx, sy, z) => context.arc(command[1] * sx + x, command[2] * sy + y, command[3] * (sx + sy) / 2, command[4], command[5], command[6], z), (command, context, x, y, sx, sy, z) => context.arcTo(command[1] * sx + x, command[2] * sy + y, command[3] * sx + x, command[4] * sy + y, command[5] * (sx + sy) / 2, z), (command, context, x, y, sx, sy, z) => context.bezierCurveTo(command[1] * sx + x, command[2] * sy + y, command[3] * sx + x, command[4] * sy + y, command[5] * sx + x, command[6] * sy + y, z), (command, context, x, y) => context.closePath(), (command, context, x, y, sx, sy) => context.ellipse(command[1] * sx + x, command[2] * sy + y, command[3] * sx, command[4] * sy, command[5], command[6], command[7], command[8]), (command, context, x, y, sx, sy, z) => context.lineTo(command[1] * sx + x, command[2] * sy + y, z), (command, context, x, y, sx, sy, z) => context.moveTo(command[1] * sx + x, command[2] * sy + y, z), (command, context, x, y, sx, sy, z) => context.quadraticCurveTo(command[1] * sx + x, command[2] * sy + y, command[3] * sx + x, command[4] * sy + y, z), (command, context, x, y, sx, sy, z) => context.rect(command[1] * sx + x, command[2] * sy + y, command[3] * sx, command[4] * sy, z)];
    function renderCommandList(commandList, context) {
      let x = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      let y = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      let sx = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;
      let sy = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;
      let z = arguments.length > 6 ? arguments[6] : undefined;
      for (let i = 0; i < commandList.length; i++) {
        const command = commandList[i];
        commandFuncs[command[0]](command, context, x, y, sx, sy, z);
      }
    }

    class Curve {
      getLength(direction) {
        return null != direction ? this.calcProjLength(direction) : (Number.isFinite(this.length) || (this.length = this.calcLength()), this.length);
      }
    }

    function snapLength(xArr, yArr) {
      let totalLength = 0;
      const count = xArr.length;
      for (let i = 0; i < count; i++) {
        const x = xArr[i],
          y = yArr[i],
          nextX = xArr[(i + 1) % count],
          nextY = yArr[(i + 1) % count];
        totalLength += PointService.distanceNN(x, y, nextX, nextY);
      }
      return totalLength / 2;
    }
    function cubicLength(p0, p1, p2, p3, iterationCount) {
      return snapLength([p0.x, p1.x, p2.x, p3.x], [p0.y, p1.y, p2.y, p3.y]);
    }
    function cubicCalc(p0, p1, p2, p3, t) {
      const one = 1 - t;
      return one * one * one * p0 + 3 * p1 * t * one * one + 3 * p2 * t * t * one + p3 * t * t * t;
    }
    function cubicPointAt(p0, p1, p2, p3, t) {
      const x = cubicCalc(p0.x, p1.x, p2.x, p3.x, t),
        y = cubicCalc(p0.y, p1.y, p2.y, p3.y, t);
      return new Point(x, y);
    }
    function quadCalc(p0, p1, p2, t) {
      const one = 1 - t;
      return one * one * p0 + 2 * one * t * p1 + t * t * p2;
    }
    function quadPointAt(p0, p1, p2, t) {
      const x = quadCalc(p0.x, p1.x, p2.x, t),
        y = quadCalc(p0.y, p1.y, p2.y, t);
      return new Point(x, y);
    }
    function quadLength(p0, p1, p2, iterationCount) {
      return snapLength([p0.x, p1.x, p2.x], [p0.y, p1.y, p2.y]);
    }

    class QuadraticBezierCurve extends Curve {
      constructor(p0, p1, p2) {
        super(), this.type = CurveTypeEnum.QuadraticBezierCurve, this.p0 = p0, this.p1 = p1, this.p2 = p2;
      }
      _validPoint() {
        return Number.isFinite(this.p0.x + this.p0.y + this.p1.x + this.p1.y + this.p2.x + this.p2.y);
      }
      getPointAt(t) {
        if (!1 !== this.defined) return quadPointAt(this.p0, this.p1, this.p2, t);
        throw new Error("defined为false的点不能getPointAt");
      }
      calcLength() {
        return this._validPoint() ? quadLength(this.p0, this.p1, this.p2) : 60;
      }
      calcProjLength(direction) {
        return direction === Direction$2.ROW ? abs(this.p0.x - this.p2.x) : direction === Direction$2.COLUMN ? abs(this.p0.y - this.p2.y) : 0;
      }
      getAngleAt(t) {
        const minT = max(t - .01, 0),
          maxT = min(t + .01, 1),
          minP = this.getPointAt(minT),
          maxP = this.getPointAt(maxT);
        return atan2(maxP.y - minP.y, maxP.x - minP.x);
      }
      draw(path, x, y, sx, sy, percent) {
        if (path.moveTo(this.p0.x * sx + x, this.p0.y * sy + y), percent >= 1) path.quadraticCurveTo(this.p1.x * sx + x, this.p1.y * sy + y, this.p2.x * sx + x, this.p2.y * sy + y);else if (percent > 0) {
          const [curve1] = divideQuad(this, percent);
          path.quadraticCurveTo(curve1.p1.x * sx + x, curve1.p1.y * sy + y, curve1.p2.x * sx + x, curve1.p2.y * sy + y);
        }
      }
      getYAt(x) {
        throw new Error("QuadraticBezierCurve暂不支持getYAt");
      }
      includeX(x) {
        throw new Error("QuadraticBezierCurve暂不支持includeX");
      }
    }

    function divideCubic(curve, t) {
      const {
          p0: p0,
          p1: p1,
          p2: p2,
          p3: p3
        } = curve,
        pt = cubicPointAt(p0, p1, p2, p3, t),
        c1 = PointService.pointAtPP(p0, p1, t),
        c2 = PointService.pointAtPP(p1, p2, t),
        c3 = PointService.pointAtPP(p2, p3, t),
        c12 = PointService.pointAtPP(c1, c2, t),
        c23 = PointService.pointAtPP(c2, c3, t);
      return [new CubicBezierCurve(p0, c1, c12, pt), new CubicBezierCurve(pt, c23, c3, p3)];
    }
    function divideQuad(curve, t) {
      const {
          p0: p0,
          p1: p1,
          p2: p2
        } = curve,
        pt = quadPointAt(p0, p1, p2, t),
        c1 = PointService.pointAtPP(p0, p1, t),
        c2 = PointService.pointAtPP(p1, p2, t);
      return [new QuadraticBezierCurve(p0, c1, pt), new QuadraticBezierCurve(pt, c2, p2)];
    }
    class CubicBezierCurve extends Curve {
      constructor(p0, p1, p2, p3) {
        super(), this.type = CurveTypeEnum.CubicBezierCurve, this.p0 = p0, this.p1 = p1, this.p2 = p2, this.p3 = p3;
      }
      _validPoint() {
        return Number.isFinite(this.p0.x + this.p0.y + this.p1.x + this.p1.y + this.p2.x + this.p2.y + this.p3.x + this.p3.y);
      }
      getPointAt(t) {
        if (!1 !== this.defined) return cubicPointAt(this.p0, this.p1, this.p2, this.p3, t);
        throw new Error("defined为false的点不能getPointAt");
      }
      calcLength() {
        return this._validPoint() ? cubicLength(this.p0, this.p1, this.p2, this.p3) : 60;
      }
      calcProjLength(direction) {
        return direction === Direction$2.ROW ? abs(this.p0.x - this.p3.x) : direction === Direction$2.COLUMN ? abs(this.p0.y - this.p3.y) : 0;
      }
      getAngleAt(t) {
        const minT = max(t - .01, 0),
          maxT = min(t + .01, 1),
          minP = this.getPointAt(minT),
          maxP = this.getPointAt(maxT);
        return atan2(maxP.y - minP.y, maxP.x - minP.x);
      }
      draw(path, x, y, sx, sy, percent) {
        if (path.moveTo(this.p0.x * sx + x, this.p0.y * sy + y), percent >= 1) path.bezierCurveTo(this.p1.x * sx + x, this.p1.y * sy + y, this.p2.x * sx + x, this.p2.y * sy + y, this.p3.x * sx + x, this.p3.y * sy + y);else if (percent > 0) {
          const [curve1] = divideCubic(this, percent);
          path.bezierCurveTo(curve1.p1.x * sx + x, curve1.p1.y * sy + y, curve1.p2.x * sx + x, curve1.p2.y * sy + y, curve1.p3.x * sx + x, curve1.p3.y * sy + y);
        }
      }
      includeX(x) {
        const minX = min(this.p0.x, this.p1.x, this.p2.x, this.p3.x),
          maxX = max(this.p0.x, this.p1.x, this.p2.x, this.p3.x);
        return x >= minX && x <= maxX;
      }
      getYAt(x) {
        const minX = min(this.p0.x, this.p1.x, this.p2.x, this.p3.x),
          t = (x - minX) / (max(this.p0.x, this.p1.x, this.p2.x, this.p3.x) - minX);
        return this.getPointAt(t).y;
      }
    }

    function divideLinear(curve, t) {
      const {
          p0: p0,
          p1: p1
        } = curve,
        c1 = PointService.pointAtPP(p0, p1, t);
      return [new LineCurve(p0, c1), new LineCurve(c1, p1)];
    }
    class LineCurve extends Curve {
      constructor(p0, p1) {
        super(), this.type = CurveTypeEnum.LineCurve, this.p0 = p0, this.p1 = p1;
      }
      getPointAt(t) {
        if (!1 !== this.defined) return PointService.pointAtPP(this.p0, this.p1, t);
        throw new Error("defined为false的点不能getPointAt");
      }
      getAngleAt(t) {
        return null == this.angle && (this.angle = atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x)), this.angle;
      }
      _validPoint() {
        return Number.isFinite(this.p0.x + this.p0.y + this.p1.x + this.p1.y);
      }
      calcLength() {
        return this._validPoint() ? PointService.distancePP(this.p0, this.p1) : 60;
      }
      calcProjLength(direction) {
        return direction === Direction$2.ROW ? abs(this.p0.x - this.p1.x) : direction === Direction$2.COLUMN ? abs(this.p0.y - this.p1.y) : 0;
      }
      draw(path, x, y, sx, sy, percent) {
        if (path.moveTo(this.p0.x * sx + x, this.p0.y * sy + y), percent >= 1) path.lineTo(this.p1.x * sx + x, this.p1.y * sy + y);else if (percent > 0) {
          const p = this.getPointAt(percent);
          path.lineTo(p.x * sx + x, p.y * sy + y);
        }
      }
      includeX(x) {
        return x >= this.p0.x && x <= this.p1.x || x >= this.p1.x && x <= this.p0.x;
      }
      getYAt(x) {
        if (this.includeX(x)) {
          let minP = this.p0,
            maxP = this.p1;
          this.p0.x > this.p1.x && (minP = this.p1, maxP = this.p0);
          const percent = (x - minP.x) / (maxP.x - minP.x);
          return minP.y + percent * (maxP.y - minP.y);
        }
        return 1 / 0;
      }
    }

    class SegContext {
      get endX() {
        return this._lastX;
      }
      get endY() {
        return this._lastY;
      }
      constructor(curveType, direction) {
        this.init(curveType, direction);
      }
      init(curveType, direction) {
        this._lastX = this._lastY = this._startX = this._startY = 0, this.curveType = curveType, this.direction = direction, this.curves = [];
      }
      bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, defined, p) {
        const curve = new CubicBezierCurve(new Point(this._lastX, this._lastY), new Point(cp1x, cp1y), new Point(cp2x, cp2y), new Point(x, y));
        curve.originP1 = this._lastOriginP, curve.originP2 = p, curve.defined = defined, this.curves.push(curve), this._lastX = x, this._lastY = y, this._lastOriginP = p;
      }
      closePath() {
        if (this.curves.length < 2) return;
        const lastCurve = this.curves[this.curves.length - 1];
        this.lineTo(this._startX, this._startY, lastCurve.defined, this._startOriginP);
      }
      ellipse() {
        throw new Error("SegContext不支持调用ellipse");
      }
      lineTo(x, y, defined, p) {
        const curve = this.addLinearCurve(x, y, defined, this._lastOriginP, p);
        this.curves.push(curve), this._lastX = x, this._lastY = y, this._lastOriginP = p;
      }
      moveTo(x, y, p) {
        return this._lastX = this._startX = x, this._lastY = this._startY = y, this._lastOriginP = p, this._startOriginP = p, this;
      }
      quadraticCurveTo(cpx, cpy, x, y) {
        throw new Error("SegContext不支持调用quadraticCurveTo");
      }
      clear() {
        this.curves = [], this.length = NaN;
      }
      tryUpdateLength(direction) {
        return this.getLength(direction);
      }
      addLinearCurve(x, y, defined, p1, p2) {
        const curve = new LineCurve(new Point(this._lastX, this._lastY), new Point(x, y));
        return curve.originP1 = p1, curve.originP2 = p2, curve.defined = defined, curve;
      }
      getPointAt(t) {
        throw new Error("暂未实现");
      }
      getCurveLengths() {
        return [];
      }
      getLength(direction) {
        var _a, _b;
        if (direction === Direction$2.COLUMN) {
          if (!this.curves.length) return 0;
          const sc = this.curves[0],
            ec = this.curves[this.curves.length - 1],
            endP = null !== (_a = ec.p3) && void 0 !== _a ? _a : ec.p1;
          return abs(sc.p0.y - endP.y);
        }
        if (direction === Direction$2.ROW) {
          if (!this.curves.length) return 0;
          const sc = this.curves[0],
            ec = this.curves[this.curves.length - 1],
            endP = null !== (_b = ec.p3) && void 0 !== _b ? _b : ec.p1;
          return abs(sc.p0.x - endP.x);
        }
        return Number.isFinite(this.length) || (this.length = this.curves.reduce((l, c) => l + c.getLength(), 0)), this.length;
      }
    }
    class ReflectSegContext extends SegContext {
      bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, defined, p) {
        return super.bezierCurveTo(cp1y, cp1x, cp2y, cp2x, y, x, defined, p);
      }
      lineTo(x, y, defined, p) {
        return super.lineTo(y, x, defined, p);
      }
      moveTo(x, y, p) {
        return super.moveTo(y, x, p);
      }
      clear() {
        return super.clear();
      }
    }

    function genCurveSegments(path, points) {
      let defined0 = !1;
      for (let i = 0, n = points.length; i <= n; i++) i >= n === defined0 && ((defined0 = !defined0) ? path.lineStart() : path.lineEnd()), defined0 && path.point(points[i]);
    }
    function genSegContext(curveType, direction, points) {
      const curveDirection = null != direction ? direction : abs(points[points.length - 1].x - points[0].x) > abs(points[points.length - 1].y - points[0].y) ? Direction$2.ROW : Direction$2.COLUMN;
      return "monotoneY" === curveType ? new ReflectSegContext(curveType, curveDirection) : new SegContext(curveType, curveDirection);
    }

    class Linear {
      constructor(context, startPoint) {
        this.context = context, startPoint && (this.startPoint = startPoint);
      }
      areaStart() {
        this._line = 0;
      }
      areaEnd() {
        this._line = NaN;
      }
      lineStart() {
        this._point = 0, this.startPoint && this.point(this.startPoint);
      }
      lineEnd() {
        (this._line || 0 !== this._line && 1 === this._point) && this.context.closePath(), this._line = 1 - this._line;
      }
      point(p) {
        const x = p.x,
          y = p.y;
        switch (this._point) {
          case 0:
            this._point = 1, this._line ? this.context.lineTo(x, y, !1 !== this._lastDefined && !1 !== p.defined, p) : this.context.moveTo(x, y, p);
            break;
          case 1:
            this._point = 2;
          default:
            this.context.lineTo(x, y, !1 !== this._lastDefined && !1 !== p.defined, p);
        }
        this._lastDefined = p.defined;
      }
      tryUpdateLength() {
        return this.context.tryUpdateLength();
      }
    }
    function genLinearSegments(points) {
      let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      const {
        direction: direction,
        startPoint: startPoint
      } = params;
      if (points.length < 2 - Number(!!startPoint)) return null;
      const segContext = genSegContext("linear", direction, points);
      return genLinearTypeSegments(new Linear(segContext, startPoint), points), segContext;
    }
    function genLinearTypeSegments(path, points) {
      return genCurveSegments(path, points);
    }

    function point$3(curveClass, x, y, defined, p) {
      curveClass.context.bezierCurveTo((2 * curveClass._x0 + curveClass._x1) / 3, (2 * curveClass._y0 + curveClass._y1) / 3, (curveClass._x0 + 2 * curveClass._x1) / 3, (curveClass._y0 + 2 * curveClass._y1) / 3, (curveClass._x0 + 4 * curveClass._x1 + x) / 6, (curveClass._y0 + 4 * curveClass._y1 + y) / 6, defined, curveClass.lastPoint1);
    }
    class Basis {
      constructor(context, startPoint) {
        this.context = context, this.startPoint = startPoint;
      }
      areaStart() {
        this._line = 0;
      }
      areaEnd() {
        this._line = NaN;
      }
      lineStart() {
        this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0, this.startPoint && this.point(this.startPoint);
      }
      lineEnd() {
        if (2 === this._point) point$3(this, 6 * this._x1 - (this._x0 + 4 * this._x1), 6 * this._y1 - (this._y0 + 4 * this._y1), !1 !== this._lastDefined1 && !1 !== this._lastDefined2, this.lastPoint1);
        (this._line || 0 !== this._line && 1 === this._point) && this.context.closePath(), this._line = 1 - this._line;
      }
      point(p) {
        const x = p.x,
          y = p.y;
        switch (this._point) {
          case 0:
            this._point = 1, this._line ? this.context.lineTo(x, y, !1 !== this._lastDefined1 && !1 !== this._lastDefined2, p) : this.context.moveTo(x, y, p);
            break;
          case 1:
            this._point = 2;
            break;
          default:
            point$3(this, x, y, !1 !== this._lastDefined1 && !1 !== this._lastDefined2);
        }
        this._x0 = this._x1, this._x1 = x, this._y0 = this._y1, this._y1 = y, this._lastDefined1 = this._lastDefined2, this._lastDefined2 = p.defined, this.lastPoint0 = this.lastPoint1, this.lastPoint1 = p;
      }
      tryUpdateLength() {
        return this.context.tryUpdateLength();
      }
    }
    function genBasisTypeSegments(path, points) {
      return genCurveSegments(path, points);
    }
    function genBasisSegments(points) {
      let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      const {
        direction: direction,
        startPoint: startPoint
      } = params;
      if (points.length < 2 - Number(!!startPoint)) return null;
      if (points.length < 3 - Number(!!startPoint)) return genLinearSegments(points, params);
      const segContext = genSegContext("basis", direction, points);
      return genBasisTypeSegments(new Basis(segContext, startPoint), points), segContext;
    }

    function sign(x) {
      return x < 0 ? -1 : 1;
    }
    function slope3(curveClass, x2, y2) {
      const h0 = curveClass._x1 - curveClass._x0,
        h1 = x2 - curveClass._x1,
        s0 = (curveClass._y1 - curveClass._y0) / (h0 || Number(h1 < 0 && -0)),
        s1 = (y2 - curveClass._y1) / (h1 || Number(h0 < 0 && -0)),
        p = (s0 * h1 + s1 * h0) / (h0 + h1);
      return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), .5 * Math.abs(p)) || 0;
    }
    function slope2(curveClass, t) {
      const h = curveClass._x1 - curveClass._x0;
      return h ? (3 * (curveClass._y1 - curveClass._y0) / h - t) / 2 : t;
    }
    function point$2(curveClass, t0, t1, defined, p) {
      const x0 = curveClass._x0,
        y0 = curveClass._y0,
        x1 = curveClass._x1,
        y1 = curveClass._y1,
        dx = (x1 - x0) / 3;
      curveClass.context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1, defined, curveClass.lastPoint1);
    }
    class MonotoneX {
      constructor(context, startPoint) {
        this.context = context, this.startPoint = startPoint;
      }
      areaStart() {
        this._line = 0;
      }
      areaEnd() {
        this._line = NaN;
      }
      lineStart() {
        this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0, this.startPoint && this.point(this.startPoint);
      }
      lineEnd() {
        switch (this._point) {
          case 2:
            this.context.lineTo(this._x1, this._y1, !1 !== this._lastDefined1 && !1 !== this._lastDefined2, this.lastPoint1);
            break;
          case 3:
            point$2(this, this._t0, slope2(this, this._t0), !1 !== this._lastDefined1 && !1 !== this._lastDefined2, this.lastPoint1);
        }
        (this._line || 0 !== this._line && 1 === this._point) && this.context.closePath(), this._line = 1 - this._line;
      }
      point(p) {
        let t1 = NaN;
        const x = p.x,
          y = p.y;
        switch (this._point) {
          case 0:
            this._point = 1, this._line ? this.context.lineTo(x, y, !1 !== this._lastDefined1 && !1 !== this._lastDefined2, p) : this.context.moveTo(x, y, p);
            break;
          case 1:
            this._point = 2;
            break;
          case 2:
            this._point = 3, point$2(this, slope2(this, t1 = slope3(this, x, y)), t1, !1 !== this._lastDefined1 && !1 !== this._lastDefined2);
            break;
          default:
            point$2(this, this._t0, t1 = slope3(this, x, y), !1 !== this._lastDefined1 && !1 !== this._lastDefined2);
        }
        this._x0 = this._x1, this._x1 = x, this._y0 = this._y1, this._y1 = y, this._t0 = t1, this._lastDefined1 = this._lastDefined2, this._lastDefined2 = !1 !== p.defined, this.lastPoint0 = this.lastPoint1, this.lastPoint1 = p;
      }
      tryUpdateLength() {
        return this.context.tryUpdateLength();
      }
    }
    class MonotoneY extends MonotoneX {
      constructor(context, startPoint) {
        super(context, startPoint);
      }
      point(p) {
        return super.point({
          y: p.x,
          x: p.y,
          defined: p.defined
        });
      }
    }
    function genMonotoneXTypeSegments(path, points) {
      return genCurveSegments(path, points);
    }
    function genMonotoneXSegments(points) {
      let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      const {
        direction: direction,
        startPoint: startPoint
      } = params;
      if (points.length < 2 - Number(!!startPoint)) return null;
      if (points.length < 3 - Number(!!startPoint)) return genLinearSegments(points, params);
      const segContext = genSegContext("monotoneX", direction, points);
      return genMonotoneXTypeSegments(new MonotoneX(segContext, startPoint), points), segContext;
    }
    function genMonotoneYTypeSegments(path, points) {
      return genCurveSegments(path, points);
    }
    function genMonotoneYSegments(points) {
      let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      const {
        direction: direction,
        startPoint: startPoint
      } = params;
      if (points.length < 2 - Number(!!startPoint)) return null;
      if (points.length < 3 - Number(!!startPoint)) return genLinearSegments(points, params);
      const segContext = genSegContext("monotoneY", direction, points);
      return genMonotoneYTypeSegments(new MonotoneY(segContext, startPoint), points), segContext;
    }

    let Step$1 = class Step {
      constructor(context) {
        let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : .5;
        let startPoint = arguments.length > 2 ? arguments[2] : undefined;
        this.context = context, this._t = t, this.startPoint = startPoint;
      }
      areaStart() {
        this._line = 0;
      }
      areaEnd() {
        this._line = NaN;
      }
      lineStart() {
        this._x = this._y = NaN, this._point = 0, this.startPoint && this.point(this.startPoint);
      }
      lineEnd() {
        0 < this._t && this._t < 1 && 2 === this._point && this.context.lineTo(this._x, this._y, !1 !== this._lastDefined, this.lastPoint), (this._line || 0 !== this._line && 1 === this._point) && this.context.closePath(), this._line >= 0 && (this._t = 1 - this._t, this._line = 1 - this._line);
      }
      point(p) {
        const x = p.x,
          y = p.y;
        switch (this._point) {
          case 0:
            this._point = 1, this._line ? this.context.lineTo(x, y, !1 !== this._lastDefined && !1 !== p.defined, p) : this.context.moveTo(x, y, p);
            break;
          case 1:
            this._point = 2;
          default:
            if (this._t <= 0) this.context.lineTo(this._x, y, !1 !== this._lastDefined && !1 !== p.defined, this.lastPoint), this.context.lineTo(x, y, !1 !== this._lastDefined && !1 !== p.defined, p);else {
              const x1 = this._x * (1 - this._t) + x * this._t;
              .5 === this._t ? this.context.lineTo(x1, this._y, !1 !== this._lastDefined, this.lastPoint) : this.context.lineTo(x1, this._y, !1 !== this._lastDefined && !1 !== p.defined, this.lastPoint), this.context.lineTo(x1, y, !1 !== this._lastDefined && !1 !== p.defined, p);
            }
        }
        this._lastDefined = p.defined, this._x = x, this._y = y, this.lastPoint = p;
      }
      tryUpdateLength() {
        return this.context.tryUpdateLength();
      }
    };
    class StepClosed extends Step$1 {
      lineEnd() {
        this.context.closePath();
      }
    }
    function genStepSegments(points, t) {
      let params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      const {
        direction: direction,
        startPoint: startPoint
      } = params;
      if (points.length < 2 - Number(!!startPoint)) return null;
      const segContext = new SegContext("step", null != direction ? direction : abs(points[points.length - 1].x - points[0].x) > abs(points[points.length - 1].y - points[0].y) ? Direction$2.ROW : Direction$2.COLUMN);
      return genStepTypeSegments(new Step$1(segContext, t, startPoint), points), segContext;
    }
    function genStepTypeSegments(path, points) {
      return genCurveSegments(path, points);
    }
    function genStepClosedSegments(points, t) {
      let params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      const {
        direction: direction,
        startPoint: startPoint
      } = params;
      if (points.length < 2 - Number(!!startPoint)) return null;
      const segContext = new SegContext("step", null != direction ? direction : abs(points[points.length - 1].x - points[0].x) > abs(points[points.length - 1].y - points[0].y) ? Direction$2.ROW : Direction$2.COLUMN);
      return genStepTypeSegments(new StepClosed(segContext, t, startPoint), points), segContext;
    }

    class LinearClosed extends Linear {
      lineEnd() {
        this.context.closePath();
      }
    }
    function genLinearClosedSegments(points) {
      let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      const {
        direction: direction,
        startPoint: startPoint
      } = params;
      if (points.length < 2 - Number(!!startPoint)) return null;
      const segContext = genSegContext("linear", direction, points);
      return genLinearClosedTypeSegments(new LinearClosed(segContext, startPoint), points), segContext;
    }
    function genLinearClosedTypeSegments(path, points) {
      return genCurveSegments(path, points);
    }

    function point$1(curveClass, x, y, defined, p) {
      let x1 = curveClass._x1,
        y1 = curveClass._y1,
        x2 = curveClass._x2,
        y2 = curveClass._y2;
      if (curveClass._l01_a > epsilon) {
        const a = 2 * curveClass._l01_2a + 3 * curveClass._l01_a * curveClass._l12_a + curveClass._l12_2a,
          n = 3 * curveClass._l01_a * (curveClass._l01_a + curveClass._l12_a);
        x1 = (x1 * a - curveClass._x0 * curveClass._l12_2a + curveClass._x2 * curveClass._l01_2a) / n, y1 = (y1 * a - curveClass._y0 * curveClass._l12_2a + curveClass._y2 * curveClass._l01_2a) / n;
      }
      if (curveClass._l23_a > epsilon) {
        const b = 2 * curveClass._l23_2a + 3 * curveClass._l23_a * curveClass._l12_a + curveClass._l12_2a,
          m = 3 * curveClass._l23_a * (curveClass._l23_a + curveClass._l12_a);
        x2 = (x2 * b + curveClass._x1 * curveClass._l23_2a - x * curveClass._l12_2a) / m, y2 = (y2 * b + curveClass._y1 * curveClass._l23_2a - y * curveClass._l12_2a) / m;
      }
      curveClass.context.bezierCurveTo(x1, y1, x2, y2, curveClass._x2, curveClass._y2, defined, curveClass.lastPoint1);
    }
    class CatmullRom {
      constructor(context) {
        let alpha = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : .5;
        let startPoint = arguments.length > 2 ? arguments[2] : undefined;
        this.context = context, this.startPoint = startPoint, this._alpha = alpha;
      }
      areaStart() {
        this._line = 0;
      }
      areaEnd() {
        this._line = NaN;
      }
      lineStart() {
        this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
      }
      lineEnd() {
        switch (this._point) {
          case 2:
            this.context.lineTo(this._x2, this._y2, !1 !== this._lastDefined1 && !1 !== this._lastDefined2, this.lastPoint1);
            break;
          case 3:
            this.point({
              x: this._x2,
              y: this._y2
            });
        }
        (this._line || 0 !== this._line && 1 === this._point) && this.context.closePath(), this._line = 1 - this._line;
      }
      point(p) {
        const {
          x: x,
          y: y
        } = p;
        if (this._point) {
          const x23 = this._x2 - x,
            y23 = this._y2 - y;
          this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
        }
        switch (this._point) {
          case 0:
            this._point = 1, this._line ? this.context.lineTo(x, y, !1 !== this._lastDefined1 && !1 !== this._lastDefined2) : this.context.moveTo(x, y);
            break;
          case 1:
            this._point = 2;
            break;
          case 2:
            this._point = 3;
          default:
            point$1(this, x, y, !1 !== this._lastDefined1 && !1 !== this._lastDefined2);
        }
        this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = x, this._y0 = this._y1, this._y1 = this._y2, this._y2 = y, this._lastDefined1 = this._lastDefined2, this._lastDefined2 = p.defined, this.lastPoint0 = this.lastPoint1, this.lastPoint1 = p;
      }
      tryUpdateLength() {
        return this.context.tryUpdateLength();
      }
    }
    function commonGenCatmullRomSegments(type, cons) {
      return function (points, alpha) {
        let params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        const {
          direction: direction,
          startPoint: startPoint
        } = params;
        if (points.length < 2 - Number(!!startPoint)) return null;
        if (points.length < 3 - Number(!!startPoint)) return genLinearSegments(points, params);
        const segContext = genSegContext(type, direction, points),
          gatmullRom = new cons(segContext, alpha, startPoint);
        return genCurveSegments(gatmullRom, points), segContext;
      };
    }
    const genCatmullRomSegments = commonGenCatmullRomSegments("catmullRom", CatmullRom);

    class CatmullRomClosed {
      constructor(context) {
        let alpha = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : .5;
        let startPoint = arguments.length > 2 ? arguments[2] : undefined;
        this.context = context, this.startPoint = startPoint, this._alpha = alpha;
      }
      areaStart() {
        this._line = 0;
      }
      areaEnd() {
        this._line = NaN;
      }
      lineStart() {
        this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
      }
      lineEnd() {
        switch (this._point) {
          case 1:
            this.context.moveTo(this._x3, this._y3, this.lastPoint1), this.context.closePath();
            break;
          case 2:
            this.context.lineTo(this._x3, this._y3, !1 !== this._lastDefined1 && !1 !== this._lastDefined2, this.lastPoint1), this.context.closePath();
            break;
          case 3:
            this.point({
              x: this._x3,
              y: this._y3
            }), this.point({
              x: this._x4,
              y: this._y4
            }), this.point({
              x: this._x5,
              y: this._y5
            });
        }
      }
      point(p) {
        const {
          x: x,
          y: y
        } = p;
        if (this._point) {
          const x23 = this._x2 - x,
            y23 = this._y2 - y;
          this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
        }
        switch (this._point) {
          case 0:
            this._point = 1, this._x3 = x, this._y3 = y;
            break;
          case 1:
            this._point = 2, this.context.moveTo(this._x4 = x, this._y4 = y, p);
            break;
          case 2:
            this._point = 3, this._x5 = x, this._y5 = y;
            break;
          default:
            point$1(this, x, y, !1 !== this._lastDefined1 && !1 !== this._lastDefined2);
        }
        this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = x, this._y0 = this._y1, this._y1 = this._y2, this._y2 = y, this._lastDefined1 = this._lastDefined2, this._lastDefined2 = p.defined, this.lastPoint0 = this.lastPoint1, this.lastPoint1 = p;
      }
      tryUpdateLength() {
        return this.context.tryUpdateLength();
      }
    }
    const genCatmullRomClosedSegments = commonGenCatmullRomSegments("catmullRomClosed", CatmullRomClosed);

    class CurveContext {
      constructor(path) {
        this.path = path, this._lastX = this._lastY = this._startX = this._startY = 0;
      }
      moveTo(x, y) {
        return this._lastX = this._startX = x, this._lastY = this._startY = y, this;
      }
      lineTo(x, y) {
        const curve = this.addLinearCurve(x, y);
        this.path.addCurve(curve), this._lastX = x, this._lastY = y;
      }
      addLinearCurve(x, y) {
        return new LineCurve(new Point(this._lastX, this._lastY), new Point(x, y));
      }
      quadraticCurveTo(aCPx, aCPy, aX, aY) {
        const curve = new QuadraticBezierCurve(new Point(this._lastX, this._lastY), new Point(aCPx, aCPy), new Point(aX, aY));
        this.path.addCurve(curve), this._lastX = aX, this._lastY = aY;
      }
      bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
        const curve = new CubicBezierCurve(new Point(this._lastX, this._lastY), new Point(cp1x, cp1y), new Point(cp2x, cp2y), new Point(x, y));
        this.path.addCurve(curve), this._lastX = x, this._lastY = y;
      }
      arcTo(aX1, aY1, aX2, aY2, aRadius) {
        throw new Error("CurveContext不支持调用arcTo");
      }
      ellipse(aX, aY, xRadius, yRadius, aRotation, aStartAngle, aEndAngle, aClockwise) {
        throw new Error("CurveContext不支持调用ellipse");
      }
      rect(x, y, w, h) {
        throw new Error("CurveContext不支持调用rect");
      }
      arc(x, y, radius, startAngle, endAngle, counterclockwise) {
        throw new Error("CurveContext不支持调用arc");
      }
      closePath() {
        this.path.curves.length < 2 || this.lineTo(this._startX, this._startY);
      }
    }

    function calcLineCache(points, curveType, params) {
      var _a, _b;
      switch (curveType) {
        case "linear":
        default:
          return genLinearSegments(points, params);
        case "basis":
          return genBasisSegments(points, params);
        case "monotoneX":
          return genMonotoneXSegments(points, params);
        case "monotoneY":
          return genMonotoneYSegments(points, params);
        case "step":
          return genStepSegments(points, .5, params);
        case "stepClosed":
          return genStepClosedSegments(points, .5, params);
        case "stepBefore":
          return genStepSegments(points, 0, params);
        case "stepAfter":
          return genStepSegments(points, 1, params);
        case "catmullRom":
          return genCatmullRomSegments(points, null !== (_a = null == params ? void 0 : params.curveTension) && void 0 !== _a ? _a : .5, params);
        case "catmullRomClosed":
          return genCatmullRomClosedSegments(points, null !== (_b = null == params ? void 0 : params.curveTension) && void 0 !== _b ? _b : .5, params);
        case "linearClosed":
          return genLinearClosedSegments(points, params);
      }
    }

    class CustomPath2D extends CurvePath {
      constructor(ctx) {
        super(), this.commandList = [], ctx && (this._ctx = ctx), this._boundsContext = new BoundsContext(this.bounds);
      }
      get curves() {
        return this.tryBuildCurves();
      }
      setCtx(ctx) {
        this._ctx = ctx;
      }
      moveTo(x, y) {
        return this.commandList.push([enumCommandMap.M, x, y]), this._ctx && this._ctx.moveTo(x, y), this;
      }
      lineTo(x, y) {
        return this.commandList.push([enumCommandMap.L, x, y]), this._ctx && this._ctx.lineTo(x, y), this;
      }
      quadraticCurveTo(aCPx, aCPy, aX, aY) {
        return this.commandList.push([enumCommandMap.Q, aCPx, aCPy, aX, aY]), this._ctx && this._ctx.quadraticCurveTo(aCPx, aCPy, aX, aY), this;
      }
      bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
        return this.commandList.push([enumCommandMap.C, aCP1x, aCP1y, aCP2x, aCP2y, aX, aY]), this._ctx && this._ctx.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY), this;
      }
      arcTo(aX1, aY1, aX2, aY2, aRadius) {
        return this.commandList.push([enumCommandMap.AT, aX1, aY1, aX2, aY2, aRadius]), this._ctx && this._ctx.arcTo(aX1, aY1, aX2, aY2, aRadius), this;
      }
      ellipse(aX, aY, xRadius, yRadius, aRotation, aStartAngle, aEndAngle, aClockwise) {
        return this.commandList.push([enumCommandMap.E, aX, aY, xRadius, yRadius, aRotation, aStartAngle, aEndAngle, aClockwise]), this._ctx && this._ctx.ellipse(aX, aY, xRadius, yRadius, aRotation, aStartAngle, aEndAngle, aClockwise), this;
      }
      rect(x, y, w, h) {
        return this.commandList.push([enumCommandMap.R, x, y, w, h]), this._ctx && this._ctx.rect(x, y, w, h), this;
      }
      arc(x, y, radius, startAngle, endAngle, counterclockwise) {
        return this.commandList.push([enumCommandMap.A, x, y, radius, startAngle, endAngle, counterclockwise]), this._ctx && this._ctx.arc(x, y, radius, startAngle, endAngle, counterclockwise), this;
      }
      closePath() {
        return this.commandList.push([enumCommandMap.Z]), this._ctx && this._ctx.closePath(), this;
      }
      addCurve(curve) {
        this._curves.push(curve);
      }
      clear() {
        this.transformCbList = null, this.commandList.length = 0, this._curves.length = 0;
      }
      beginPath() {
        this.clear();
      }
      tryBuildCurves() {
        if (!this._curves || !this._curves.length) {
          const curveContext = new CurveContext(this);
          renderCommandList(this.commandList, curveContext, 0, 0, 1, 1);
        }
        return this._curves;
      }
      toString() {
        if (!this.toStringCbList) {
          const list = [];
          list[enumCommandMap.M] = cmd => `M${cmd[1]} ${cmd[2]}`, list[enumCommandMap.L] = cmd => `L${cmd[1]} ${cmd[2]}`, list[enumCommandMap.Q] = cmd => `Q${cmd[1]} ${cmd[2]} ${cmd[3]} ${cmd[4]}`, list[enumCommandMap.C] = cmd => `C${cmd[1]} ${cmd[2]} ${cmd[3]} ${cmd[4]} ${cmd[5]} ${cmd[6]}`, list[enumCommandMap.A] = cmd => {
            const bezierPathList = [];
            addArcToBezierPath$1(bezierPathList, cmd[4], cmd[5], cmd[1], cmd[2], cmd[3], cmd[3]);
            let path = "";
            for (let i = 0; i < bezierPathList.length; i += 6) path += `C${bezierPathList[i]} ${bezierPathList[i + 1]} ${bezierPathList[i + 2]} ${bezierPathList[i + 3]} ${bezierPathList[i + 4]} ${bezierPathList[i + 5]}`;
            return path;
          }, list[enumCommandMap.R] = cmd => `M${cmd[1]} ${cmd[2]} h${cmd[3]} v${cmd[4]} H${cmd[1]}Z`, list[enumCommandMap.Z] = cmd => "Z", this.toStringCbList = list;
        }
        const list = this.toStringCbList;
        let path = "";
        return this.commandList.forEach(c => {
          path += list[c[0]](c);
        }), path;
      }
      fromString(str, x, y, sX, sY) {
        this.clear();
        const commandStrList = parseSvgPath(str);
        return this._runCommandStrList(commandStrList, x, y, sX, sY), this._updateBounds(), this;
      }
      fromLine(line) {
        const {
          points: points,
          curveType: curveType,
          clipRangeByDimension: clipRangeByDimension
        } = line.attribute;
        if (!points) return;
        const cache = calcLineCache(points, curveType);
        "x" === clipRangeByDimension ? this.direction = Direction$2.ROW : "y" === clipRangeByDimension ? this.direction = Direction$2.COLUMN : "auto" === clipRangeByDimension && (this.direction = cache.direction), this._curves = cache.curves;
      }
      fromCustomPath2D(path, x, y, sX, sY) {
        return this.clear(), this._runCommandList(path.commandList, x, y, sX, sY), this._updateBounds(), this;
      }
      transform(x, y, sx, sy) {
        const commandList = this.commandList;
        if (!this.transformCbList) {
          const list = [];
          list[enumCommandMap.M] = this.moveToTransform, list[enumCommandMap.L] = this.lineToTransform, list[enumCommandMap.Q] = this.quadraticCurveToTransform, list[enumCommandMap.C] = this.bezierCurveToTransform, list[enumCommandMap.AT] = this.arcToTransform, list[enumCommandMap.E] = this.ellipseTransform, list[enumCommandMap.R] = this.rectTransform, list[enumCommandMap.A] = this.arcTransform, list[enumCommandMap.Z] = this.closePathTransform, this.transformCbList = list;
        }
        commandList.forEach(cmd => {
          this.transformCbList[cmd[0]](cmd, x, y, sx, sy);
        }), this._updateBounds();
      }
      moveToTransform(cmd, x, y, sx, sy) {
        cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y;
      }
      lineToTransform(cmd, x, y, sx, sy) {
        cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y;
      }
      quadraticCurveToTransform(cmd, x, y, sx, sy) {
        cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y, cmd[3] = cmd[3] * sx + x, cmd[4] = cmd[4] * sy + y;
      }
      bezierCurveToTransform(cmd, x, y, sx, sy) {
        cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y, cmd[3] = cmd[3] * sx + x, cmd[4] = cmd[4] * sy + y, cmd[5] = cmd[5] * sx + x, cmd[6] = cmd[6] * sy + y;
      }
      arcToTransform(cmd, x, y, sx, sy) {
        cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y, cmd[3] = cmd[3] * sx + x, cmd[4] = cmd[4] * sy + y, cmd[5] = cmd[5] * (sx + sy) / 2;
      }
      ellipseTransform(cmd, x, y, sx, sy) {
        cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y, cmd[3] = cmd[3] * sx, cmd[4] = cmd[4] * sy;
      }
      rectTransform(cmd, x, y, sx, sy) {
        cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y, cmd[3] = cmd[3] * sx, cmd[4] = cmd[4] * sy;
      }
      arcTransform(cmd, x, y, sx, sy) {
        cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y, cmd[3] = cmd[3] * (sx + sy) / 2;
      }
      closePathTransform() {}
      _runCommandStrList(commandStrList) {
        let l = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        let t = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        let sX = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
        let sY = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;
        let current,
          tempX,
          tempY,
          tempControlX,
          tempControlY,
          previous = null,
          x = 0,
          y = 0,
          controlX = 0,
          controlY = 0;
        for (let i = 0, len = commandStrList.length; i < len; ++i) {
          switch (current = commandStrList[i], 1 === sX && 1 === sY || (current = scale$1(current, sX, sY)), current[0]) {
            case "l":
              x += current[1], y += current[2], this.lineTo(x + l, y + t);
              break;
            case "L":
              x = current[1], y = current[2], this.lineTo(x + l, y + t);
              break;
            case "h":
              x += current[1], this.lineTo(x + l, y + t);
              break;
            case "H":
              x = current[1], this.lineTo(x + l, y + t);
              break;
            case "v":
              y += current[1], this.lineTo(x + l, y + t);
              break;
            case "V":
              y = current[1], this.lineTo(x + l, y + t);
              break;
            case "m":
              x += current[1], y += current[2], this.moveTo(x + l, y + t);
              break;
            case "M":
              x = current[1], y = current[2], this.moveTo(x + l, y + t);
              break;
            case "c":
              tempX = x + current[5], tempY = y + current[6], controlX = x + current[3], controlY = y + current[4], this.bezierCurveTo(x + current[1] + l, y + current[2] + t, controlX + l, controlY + t, tempX + l, tempY + t), x = tempX, y = tempY;
              break;
            case "C":
              x = current[5], y = current[6], controlX = current[3], controlY = current[4], this.bezierCurveTo(current[1] + l, current[2] + t, controlX + l, controlY + t, x + l, y + t);
              break;
            case "s":
              tempX = x + current[3], tempY = y + current[4], null === previous[0].match(/[CcSs]/) ? (controlX = x, controlY = y) : (controlX = 2 * x - controlX, controlY = 2 * y - controlY), tempControlX = x + current[1], tempControlY = y + current[2], this.bezierCurveTo(controlX + l, controlY + t, tempControlX + l, tempControlY + t, tempX + l, tempY + t), controlX = tempControlX, controlY = tempControlY, x = tempX, y = tempY;
              break;
            case "S":
              tempX = current[3], tempY = current[4], null === previous[0].match(/[CcSs]/) ? (controlX = x, controlY = y) : (controlX = 2 * x - controlX, controlY = 2 * y - controlY), tempControlX = current[1], tempControlY = current[2], this.bezierCurveTo(controlX + l, controlY + t, tempControlX + l, tempControlY + t, tempX + l, tempY + t), controlX = tempControlX, controlY = tempControlY, x = tempX, y = tempY;
              break;
            case "q":
              tempX = x + current[3], tempY = y + current[4], controlX = x + current[1], controlY = y + current[2], this.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t), x = tempX, y = tempY;
              break;
            case "Q":
              tempX = current[3], tempY = current[4], this.quadraticCurveTo(current[1] + l, current[2] + t, tempX + l, tempY + t), x = tempX, y = tempY, controlX = current[1], controlY = current[2];
              break;
            case "t":
              tempX = x + current[1], tempY = y + current[2], null === previous[0].match(/[QqTt]/) ? (controlX = x, controlY = y) : "t" === previous[0] ? (controlX = 2 * x - tempControlX, controlY = 2 * y - tempControlY) : "q" === previous[0] && (controlX = 2 * x - controlX, controlY = 2 * y - controlY), tempControlX = controlX, tempControlY = controlY, this.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t), x = tempX, y = tempY, controlX = x + current[1], controlY = y + current[2];
              break;
            case "T":
              tempX = current[1], tempY = current[2], controlX = 2 * x - controlX, controlY = 2 * y - controlY, this.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t), x = tempX, y = tempY;
              break;
            case "a":
              drawArc(this, x + l, y + t, [current[1], current[2], current[3], current[4], current[5], current[6] + x + l, current[7] + y + t]), x += current[6], y += current[7];
              break;
            case "A":
              drawArc(this, x + l, y + t, [current[1], current[2], current[3], current[4], current[5], current[6] + l, current[7] + t]), x = current[6], y = current[7];
              break;
            case "z":
            case "Z":
              this.closePath();
          }
          previous = current;
        }
      }
      _runCommandList(commandList) {
        let l = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        let t = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        let sX = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
        let sY = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;
        if (0 !== l || 0 !== t || 1 !== sX || 1 !== sY) for (let i = 0, len = commandList.length; i < len; ++i) {
          const current = commandList[i].slice();
          switch (current[0]) {
            case enumCommandMap.L:
              this.lineToTransform(current, l, t, sX, sY);
              break;
            case enumCommandMap.M:
              this.moveToTransform(current, l, t, sX, sY);
              break;
            case enumCommandMap.C:
              this.bezierCurveToTransform(current, l, t, sX, sY);
              break;
            case enumCommandMap.Q:
              this.quadraticCurveToTransform(current, l, t, sX, sY);
              break;
            case enumCommandMap.A:
              this.arcToTransform(current, l, t, sX, sY);
              break;
            case enumCommandMap.E:
              this.ellipseTransform(current, l, t, sX, sY);
              break;
            case enumCommandMap.R:
              this.rectTransform(current, l, t, sX, sY);
              break;
            case enumCommandMap.AT:
              this.arcToTransform(current, l, t, sX, sY);
              break;
            case enumCommandMap.Z:
              this.closePath();
          }
        } else this.commandList = commandList.map(entry => entry.slice());
      }
      _updateBounds() {
        this.bounds.clear(), renderCommandList(this.commandList, this._boundsContext);
      }
      release() {
        this.commandList = [], this._boundsContext = null, this._ctx = null;
      }
      getLength() {
        if (this.direction === Direction$2.COLUMN) {
          if (!this._curves.length) return 0;
          const sc = this._curves[0],
            ec = this._curves[this._curves.length - 1];
          return abs(sc.p0.y - ec.p1.y);
        }
        if (this.direction === Direction$2.ROW) {
          if (!this._curves.length) return 0;
          const sc = this._curves[0],
            ec = this._curves[this._curves.length - 1];
          return abs(sc.p0.x - ec.p1.x);
        }
        return this._curves.reduce((l, c) => l + c.getLength(), 0);
      }
      getYAt(x) {
        if (!this.curves) return 1 / 0;
        for (let i = 0; i < this.curves.length; i++) {
          const curve = this.curves[i];
          if (curve.includeX(x)) return curve.getYAt(x);
        }
        return 1 / 0;
      }
      getAttrAt(distance) {
        if (!this._curves) return {
          pos: {
            x: 0,
            y: 0
          },
          angle: 0
        };
        let curve,
          _dis = 0;
        for (let i = 0; i < this._curves.length; i++) {
          curve = this._curves[i];
          const cl = curve.getLength(this.direction);
          if (_dis + cl >= distance) break;
          _dis += cl;
        }
        const t = (distance - _dis) / curve.getLength(this.direction);
        return {
          pos: curve.getPointAt(t),
          angle: curve.getAngleAt(t)
        };
      }
      drawWithClipRange(ctx, size, x, y, clipRange) {
        this.tryBuildCurves();
        const totalLen = this.getLength() * clipRange;
        let currLen = 0;
        for (let i = 0; i < this._curves.length; i++) {
          const curve = this._curves[i],
            cl = curve.getLength(this.direction);
          if (!(currLen + cl <= totalLen)) {
            const percent = 1 - (currLen + cl - totalLen) / cl;
            curve.draw(ctx, x, y, size, size, percent);
            break;
          }
          curve.draw(ctx, x, y, size, size, 1), currLen += cl;
        }
      }
    }
    const temp = ["l", 0, 0, 0, 0, 0, 0, 0];
    function scale$1(current, sX, sY) {
      const c = temp[0] = current[0];
      if ("a" === c || "A" === c) temp[1] = sX * current[1], temp[2] = sY * current[2], temp[3] = current[3], temp[4] = current[4], temp[5] = current[5], temp[6] = sX * current[6], temp[7] = sY * current[7];else if ("h" === c || "H" === c) temp[1] = sX * current[1];else if ("v" === c || "V" === c) temp[1] = sY * current[1];else for (let i = 1, n = current.length; i < n; ++i) temp[i] = (i % 2 == 1 ? sX : sY) * current[i];
      return temp;
    }

    const DefaultLayout = {
      alignSelf: "auto"
    };
    const DefaultTransform = {
      x: 0,
      y: 0,
      z: 0,
      dx: 0,
      dy: 0,
      dz: 0,
      scrollX: 0,
      scrollY: 0,
      scaleX: 1,
      scaleY: 1,
      scaleZ: 1,
      angle: 0,
      alpha: 0,
      beta: 0,
      scaleCenter: [0, 0],
      anchor: [0, 0],
      anchor3d: [0, 0],
      postMatrix: new Matrix()
    };
    const DefaultFillStyle = {
      fillOpacity: 1,
      fill: !1,
      shadowBlur: 0,
      shadowColor: "black",
      shadowOffsetX: 0,
      shadowOffsetY: 0
    };
    const commonStroke = {
      strokeOpacity: 1,
      lineDash: [],
      lineDashOffset: 0,
      lineWidth: 1,
      lineCap: "butt",
      lineJoin: "miter",
      miterLimit: 10,
      strokeBoundsBuffer: 2,
      stroke: !1
    };
    const DefaultStrokeStyle = Object.assign({
      outerBorder: Object.assign(Object.assign({}, commonStroke), {
        distance: 0
      }),
      innerBorder: Object.assign(Object.assign({}, commonStroke), {
        distance: 0
      })
    }, commonStroke);
    const DefaultTextStyle = {
      text: "",
      maxLineWidth: 1 / 0,
      maxWidth: 1 / 0,
      textAlign: "left",
      textBaseline: "alphabetic",
      fontSize: 16,
      fontFamily: "PingFang SC,Microsoft Yahei,system-ui,-apple-system,segoe ui,\n    Roboto,Helvetica,Arial,sans-serif, apple color emoji,segoe ui emoji,segoe ui symbol",
      fontWeight: "",
      ellipsis: "…",
      fontVariant: "",
      fontStyle: "",
      lineHeight: void 0,
      underline: 0,
      lineThrough: 0,
      scaleIn3d: !1,
      direction: "horizontal",
      wordBreak: "break-all",
      ignoreBuf: !1,
      verticalMode: 0,
      wrap: !1,
      whiteSpace: "no-wrap",
      heightLimit: 1 / 0,
      lineClamp: 1 / 0,
      suffixPosition: "end",
      underlineDash: [],
      underlineOffset: 0,
      disableAutoClipedPoptip: void 0,
      measureMode: MeasureModeEnum.fontBounding,
      keepCenterInLine: !1
    };
    const DefaultPickStyle = {
      pickStrokeBuffer: 0
    };
    const DefaultStyle = Object.assign(Object.assign(Object.assign(Object.assign({
      forceBoundsWidth: void 0,
      forceBoundsHeight: void 0,
      opacity: 1,
      background: null,
      autoAnimateTexture: !1,
      textureRatio: 1,
      textureOptions: null,
      backgroundOpacity: 1,
      backgroundCornerRadius: 0,
      texture: null,
      textureColor: "black",
      textureSize: 10,
      texturePadding: 2,
      backgroundMode: "no-repeat",
      backgroundFit: !0,
      backgroundKeepAspectRatio: !1,
      backgroundClip: !0,
      backgroundScale: 1,
      backgroundOffsetX: 0,
      backgroundOffsetY: 0,
      blur: 0,
      filter: "",
      cursor: null,
      html: null,
      react: null,
      vue: null
    }, DefaultFillStyle), DefaultStrokeStyle), DefaultLayout), DefaultPickStyle);
    const DefaultConnectAttribute = {
      connectedType: "none",
      connectedStyle: {},
      connectedX: NaN,
      connectedY: NaN
    };
    const DefaultDebugAttribute = {
      _debug_bounds: !1
    };
    const DefaultAttribute = Object.assign(Object.assign(Object.assign({
      strokeSeg: null,
      renderable: !0,
      pickable: !0,
      shadowGraphic: void 0,
      childrenPickable: !0,
      fillPickable: !0,
      strokePickable: !0,
      visible: !0,
      zIndex: 0,
      layout: null,
      boundsPadding: 0,
      fillStrokeOrder: 0,
      renderStyle: "default",
      pickMode: "accurate",
      customPickShape: null,
      boundsMode: "accurate",
      keepDirIn3d: !0,
      shadowRootIdx: 1,
      globalZIndex: 1,
      globalCompositeOperation: "",
      overflow: "hidden",
      shadowPickMode: "graphic",
      keepStrokeScale: !1,
      clipConfig: null
    }, DefaultDebugAttribute), DefaultStyle), DefaultTransform);
    const DefaultArcAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
      startAngle: 0,
      endAngle: pi2,
      innerRadius: 0,
      outerRadius: 1,
      innerPadding: 0,
      outerPadding: 0,
      cornerRadius: 0,
      padRadius: 0,
      padAngle: 0,
      cap: !1,
      forceShowCap: !1
    });
    const DefaultAreaAttribute = Object.assign(Object.assign(Object.assign({}, DefaultAttribute), DefaultConnectAttribute), {
      points: [],
      segments: [],
      curveType: "linear",
      clipRange: 1,
      closePath: !1,
      curveTension: 1
    });
    const DefaultCircleAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
      radius: 1,
      startAngle: 0,
      endAngle: pi2
    });
    const DefaultGroupAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
      width: 0,
      height: 0,
      cornerRadius: 0,
      path: [],
      clip: !1,
      visibleAll: !0,
      display: "relative",
      flexDirection: "row",
      flexWrap: "wrap",
      justifyContent: "flex-start",
      alignItems: "flex-start",
      alignContent: "flex-start",
      baseOpacity: 1,
      cornerType: "round"
    });
    const DefaultGlyphAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
      path: "",
      width: 0,
      height: 0,
      cornerRadius: 0,
      clip: !1
    });
    const DefaultLineAttribute = Object.assign(Object.assign(Object.assign({}, DefaultAttribute), DefaultConnectAttribute), {
      points: [],
      segments: [],
      curveType: "linear",
      clipRange: 1,
      clipRangeByDimension: "default",
      closePath: !1,
      curveTension: 1
    });
    const DefaultPathAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
      path: new CustomPath2D(),
      fillStrokeOrder: 1,
      clipRange: 1,
      customPath: () => {
        Logger$1.getInstance().warn("空函数");
      }
    });
    const DefaultPolygonAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
      points: [],
      cornerRadius: 0,
      closePath: !0
    });
    const DefaultStarAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
      width: 100,
      height: 100,
      spikes: 5,
      thickness: .5
    });
    const DefaultRectAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
      width: 0,
      height: 0,
      x1: 0,
      y1: 0,
      strokeBoundsBuffer: 0,
      cornerRadius: 0,
      cornerType: "round"
    });
    Object.assign(Object.assign({}, DefaultAttribute), {
      width: 0,
      height: 0,
      x1: 0,
      y1: 0,
      cornerRadius: 0,
      length: 0,
      cornerType: "round"
    });
    const DefaultSymbolAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
      symbolType: "circle",
      size: 10,
      keepDirIn3d: !0,
      clipRange: 1
    });
    const DefaultTextAttribute = Object.assign(Object.assign(Object.assign({}, DefaultAttribute), DefaultTextStyle), {
      strokeBoundsBuffer: 0,
      keepDirIn3d: !0
    });
    const DefaultRichTextAttribute = Object.assign(Object.assign(Object.assign({}, DefaultAttribute), DefaultTextStyle), {
      upgradeAttrs: null,
      editable: !1,
      editOptions: null,
      ascentDescentMode: "actual",
      width: 300,
      height: 300,
      ellipsis: !0,
      wordBreak: "break-word",
      verticalDirection: "top",
      textAlign: "left",
      textBaseline: "top",
      layoutDirection: "horizontal",
      textConfig: [],
      disableAutoWrapLine: !1,
      maxHeight: void 0,
      maxWidth: void 0,
      singleLine: !1
    });
    const DefaultImageAttribute = Object.assign(Object.assign({
      repeatX: "no-repeat",
      repeatY: "no-repeat",
      image: "",
      width: 0,
      height: 0,
      maxWidth: 500,
      maxHeight: 500
    }, DefaultAttribute), {
      fill: !0,
      cornerRadius: 0,
      cornerType: "round"
    });
    const DefaultRichTextIconAttribute = Object.assign(Object.assign({}, DefaultImageAttribute), {
      backgroundShowMode: "never",
      backgroundWidth: 0,
      backgroundHeight: 0,
      textAlign: "left",
      textBaseline: "middle",
      direction: "horizontal",
      margin: 0,
      id: "",
      width: 20,
      height: 20,
      backgroundFill: "rgba(101, 117, 168, 0.1)",
      backgroundFillOpacity: 1,
      backgroundStroke: !1,
      backgroundStrokeOpacity: 1,
      backgroundRadius: 4,
      opacity: 1
    });

    class Application {}
    const application = new Application();

    const parse$4 = function () {
      const tokens = {
        linearGradient: /^(linear\-gradient)/i,
        radialGradient: /^(radial\-gradient)/i,
        conicGradient: /^(conic\-gradient)/i,
        sideOrCorner: /^to (left (top|bottom)|right (top|bottom)|top (left|right)|bottom (left|right)|left|right|top|bottom)/i,
        extentKeywords: /^(closest\-side|closest\-corner|farthest\-side|farthest\-corner|contain|cover)/,
        positionKeywords: /^(left|center|right|top|bottom)/i,
        pixelValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))px/,
        percentageValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))\%/,
        emValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))em/,
        angleValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))deg/,
        fromAngleValue: /^from\s*(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))deg/,
        startCall: /^\(/,
        endCall: /^\)/,
        comma: /^,/,
        hexColor: /(^\#[0-9a-fA-F]+)/,
        literalColor: /^([a-zA-Z]+)/,
        rgbColor: /^(rgb\(\d{1,3},\s*\d{1,3},\s*\d{1,3}\))/i,
        rgbaColor: /^(rgba\(\d{1,3},\s*\d{1,3},\s*\d{1,3},\s*((\d\.\d+)|\d{1,3})\))/i,
        number: /^(([0-9]*\.[0-9]+)|([0-9]+\.?))/
      };
      let input = "";
      function error(msg) {
        const err = new Error(input + ": " + msg);
        throw err.source = input, err;
      }
      function getAST() {
        const ast = matchListing(matchDefinition);
        return input.length > 0 && error("Invalid input not EOF"), ast;
      }
      function matchDefinition() {
        return matchGradient("linear", tokens.linearGradient, matchLinearOrientation) || matchGradient("radial", tokens.radialGradient, matchListRadialOrientations) || matchGradient("conic", tokens.conicGradient, matchConicalOrientation);
      }
      function matchGradient(gradientType, pattern, orientationMatcher) {
        return function (pattern, callback) {
          const captures = scan(pattern);
          if (captures) {
            scan(tokens.startCall) || error("Missing (");
            const result = callback(captures);
            return scan(tokens.endCall) || error("Missing )"), result;
          }
        }(pattern, function (captures) {
          const orientation = orientationMatcher();
          return orientation && (scan(tokens.comma) || error("Missing comma before color stops")), {
            type: gradientType,
            orientation: orientation,
            colorStops: matchListing(matchColorStop)
          };
        });
      }
      function matchLinearOrientation() {
        return match("directional", tokens.sideOrCorner, 1) || match("angular", tokens.angleValue, 1);
      }
      function matchConicalOrientation() {
        return match("angular", tokens.fromAngleValue, 1);
      }
      function matchListRadialOrientations() {
        let radialOrientations,
          lookaheadCache,
          radialOrientation = matchRadialOrientation();
        return radialOrientation && (radialOrientations = [], radialOrientations.push(radialOrientation), lookaheadCache = input, scan(tokens.comma) && (radialOrientation = matchRadialOrientation(), radialOrientation ? radialOrientations.push(radialOrientation) : input = lookaheadCache)), radialOrientations;
      }
      function matchRadialOrientation() {
        let radialType = function () {
          const circle = match("shape", /^(circle)/i, 0);
          circle && (circle.style = matchLength() || matchExtentKeyword());
          return circle;
        }() || function () {
          const ellipse = match("shape", /^(ellipse)/i, 0);
          ellipse && (ellipse.style = matchDistance() || matchExtentKeyword());
          return ellipse;
        }();
        if (radialType) radialType.at = matchAtPosition();else {
          const extent = matchExtentKeyword();
          if (extent) {
            radialType = extent;
            const positionAt = matchAtPosition();
            positionAt && (radialType.at = positionAt);
          } else {
            const defaultPosition = matchPositioning();
            defaultPosition && (radialType = {
              type: "default-radial",
              at: defaultPosition
            });
          }
        }
        return radialType;
      }
      function matchExtentKeyword() {
        return match("extent-keyword", tokens.extentKeywords, 1);
      }
      function matchAtPosition() {
        if (match("position", /^at/, 0)) {
          const positioning = matchPositioning();
          return positioning || error("Missing positioning value"), positioning;
        }
      }
      function matchPositioning() {
        const location = {
          x: matchDistance(),
          y: matchDistance()
        };
        if (location.x || location.y) return {
          type: "position",
          value: location
        };
      }
      function matchListing(matcher) {
        let captures = matcher();
        const result = [];
        if (captures) for (result.push(captures); scan(tokens.comma);) captures = matcher(), captures ? result.push(captures) : error("One extra comma");
        return result;
      }
      function matchColorStop() {
        const color = match("hex", tokens.hexColor, 1) || match("rgba", tokens.rgbaColor, 1) || match("rgb", tokens.rgbColor, 1) || match("literal", tokens.literalColor, 0);
        return color || error("Expected color definition"), color.length = matchDistance(), color;
      }
      function matchDistance() {
        return match("%", tokens.percentageValue, 1) || match("position-keyword", tokens.positionKeywords, 1) || matchLength();
      }
      function matchLength() {
        return match("px", tokens.pixelValue, 1) || match("em", tokens.emValue, 1);
      }
      function match(type, pattern, captureIndex) {
        const captures = scan(pattern);
        if (captures) return {
          type: type,
          value: captures[captureIndex]
        };
      }
      function scan(regexp) {
        const blankCaptures = /^[\n\r\t\s]+/.exec(input);
        blankCaptures && consume(blankCaptures[0].length);
        const captures = regexp.exec(input);
        return captures && consume(captures[0].length), captures;
      }
      function consume(size) {
        input = input.substr(size);
      }
      return function (code) {
        return input = code.toString(), getAST();
      };
    }();
    class GradientParser {
      static IsGradient(c) {
        return !("string" == typeof c && !c.includes("gradient"));
      }
      static IsGradientStr(c) {
        return "string" == typeof c && c.includes("gradient");
      }
      static Parse(c) {
        if (GradientParser.IsGradientStr(c)) try {
          const datum = parse$4(c)[0];
          if (datum) {
            if ("linear" === datum.type) return GradientParser.ParseLinear(datum);
            if ("radial" === datum.type) return GradientParser.ParseRadial(datum);
            if ("conic" === datum.type) return GradientParser.ParseConic(datum);
          }
        } catch (err) {
          return c;
        }
        return c;
      }
      static ParseConic(datum) {
        const {
            orientation: orientation,
            colorStops = []
          } = datum,
          halfPi = pi / 2,
          sa = parseFloat(orientation.value) / 180 * pi - halfPi;
        return {
          gradient: "conical",
          x: .5,
          y: .5,
          startAngle: sa,
          endAngle: sa + pi2,
          stops: colorStops.map(item => ({
            color: item.value,
            offset: parseFloat(item.length.value) / 100
          }))
        };
      }
      static ParseRadial(datum) {
        const {
          colorStops = []
        } = datum;
        return {
          gradient: "radial",
          x0: .5,
          y0: .5,
          x1: .5,
          y1: .5,
          r0: 0,
          r1: 1,
          stops: colorStops.map(item => ({
            color: item.value,
            offset: parseFloat(item.length.value) / 100
          }))
        };
      }
      static ParseLinear(datum) {
        const {
            orientation: orientation,
            colorStops = []
          } = datum,
          halfPi = pi / 2;
        let angle = "angular" === orientation.type ? parseFloat(orientation.value) / 180 * pi : 0;
        for (; angle < 0;) angle += pi2;
        for (; angle >= pi2;) angle -= pi2;
        let x0 = 0,
          y0 = 0,
          x1 = 0,
          y1 = 0;
        return angle < halfPi ? (x0 = 0, y0 = 1, x1 = Math.sin(angle), y1 = y0 - Math.cos(angle)) : angle < pi ? (x0 = 0, y0 = 0, x1 = Math.cos(angle - halfPi), y1 = Math.sin(angle - halfPi)) : angle < pi + halfPi ? (x0 = 1, y0 = 0, x1 = x0 - Math.sin(angle - pi), y1 = Math.cos(angle - pi)) : (x0 = 1, x1 = x0 - Math.cos(angle - halfPi - pi), y1 -= Math.sin(angle - halfPi - pi)), {
          gradient: "linear",
          x0: x0,
          y0: y0,
          x1: x1,
          y1: y1,
          stops: colorStops.map(item => ({
            color: item.value,
            offset: parseFloat(item.length.value) / 100
          }))
        };
      }
    }

    function getScaledStroke(context, width, dpr) {
      let strokeWidth = width;
      const {
          a: a,
          b: b,
          c: c,
          d: d
        } = context.currentMatrix,
        scaleX = Math.sign(a) * Math.sqrt(a * a + b * b),
        scaleY = Math.sign(d) * Math.sqrt(c * c + d * d);
      return scaleX + scaleY === 0 ? 0 : (strokeWidth = strokeWidth / Math.abs(scaleX + scaleY) * 2 * dpr, strokeWidth);
    }
    function createColor(context, c, params) {
      let offsetX = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      let offsetY = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
      var _a, _b, _c, _d;
      if (!c || !0 === c) return "black";
      let result, color;
      if (isArray$9(c)) for (let i = 0; i < c.length && (color = c[i], !color); i++);else color = c;
      if (color = GradientParser.Parse(color), "string" == typeof color) return color;
      if (params.AABBBounds && (!params.attribute || 0 !== params.attribute.scaleX || 0 !== params.attribute.scaleY)) {
        const bounds = params.AABBBounds;
        let w = bounds.x2 - bounds.x1,
          h = bounds.y2 - bounds.y1,
          x = bounds.x1 - offsetX,
          y = bounds.y1 - offsetY;
        if (params.attribute) {
          const {
            scaleX = 1,
            scaleY = 1,
            angle = 0
          } = params.attribute;
          w /= scaleX, h /= scaleY, x /= scaleX, y /= scaleY, (angle || 1 !== scaleX || 1 !== scaleY) && (x = null !== (_a = params.x1WithoutTransform) && void 0 !== _a ? _a : 0, y = null !== (_b = params.y1WithoutTransform) && void 0 !== _b ? _b : 0, w = null !== (_c = params.widthWithoutTransform) && void 0 !== _c ? _c : w, h = null !== (_d = params.heightWithoutTransform) && void 0 !== _d ? _d : h);
        }
        "linear" === color.gradient ? result = createLinearGradient(context, color, x, y, w, h) : "conical" === color.gradient ? result = createConicGradient(context, color, x, y, w, h) : "radial" === color.gradient && (result = createRadialGradient(context, color, x, y, w, h));
      }
      return result || "orange";
    }
    function createLinearGradient(context, color, x, y, w, h) {
      var _a, _b, _c, _d;
      const canvasGradient = context.createLinearGradient(x + (null !== (_a = color.x0) && void 0 !== _a ? _a : 0) * w, y + (null !== (_b = color.y0) && void 0 !== _b ? _b : 0) * h, x + (null !== (_c = color.x1) && void 0 !== _c ? _c : 1) * w, y + (null !== (_d = color.y1) && void 0 !== _d ? _d : 0) * h);
      return color.stops.forEach(stop => {
        canvasGradient.addColorStop(stop.offset, stop.color);
      }), canvasGradient;
    }
    function createRadialGradient(context, color, x, y, w, h) {
      var _a, _b, _c, _d, _e, _f;
      const canvasGradient = context.createRadialGradient(x + (null !== (_a = color.x0) && void 0 !== _a ? _a : .5) * w, y + (null !== (_b = color.y0) && void 0 !== _b ? _b : .5) * h, Math.max(w, h) * (null !== (_c = color.r0) && void 0 !== _c ? _c : 0), x + (null !== (_d = color.x1) && void 0 !== _d ? _d : .5) * w, y + (null !== (_e = color.y1) && void 0 !== _e ? _e : .5) * h, Math.max(w, h) * (null !== (_f = color.r1) && void 0 !== _f ? _f : .5));
      return color.stops.forEach(stop => {
        canvasGradient.addColorStop(stop.offset, stop.color);
      }), canvasGradient;
    }
    function createConicGradient(context, color, x, y, w, h) {
      var _a, _b;
      const canvasGradient = context.createConicGradient(x + (null !== (_a = color.x) && void 0 !== _a ? _a : 0) * w, y + (null !== (_b = color.y) && void 0 !== _b ? _b : 0) * h, color.startAngle, color.endAngle);
      return color.stops.forEach(stop => {
        canvasGradient.addColorStop(stop.offset, stop.color);
      }), canvasGradient.GetPattern ? canvasGradient.GetPattern(w + x, h + y, undefined) : canvasGradient;
    }

    const DIRECTION_KEY = {
      horizontal: {
        width: "width",
        height: "height",
        left: "left",
        top: "top",
        x: "x",
        y: "y",
        bottom: "bottom"
      },
      vertical: {
        width: "height",
        height: "width",
        left: "top",
        top: "left",
        x: "y",
        y: "x",
        bottom: "right"
      }
    };
    const defaultFormatting = {
        fontSize: 16,
        fontFamily: DEFAULT_TEXT_FONT_FAMILY$2,
        fill: !0,
        stroke: !1,
        fontWeight: "normal",
        lineHeight: "normal",
        fontStyle: "normal",
        textDecoration: "none",
        textAlign: "left",
        script: "normal"
      };
    const regLetter = /\w|\(|\)|-/;
    const regPunctuation = /[.?!,;:/，。？！、；：]/;
    const regFirstSpace = /\S/;
    const setTextStyle = (ctx, character) => {
      let fontSize = character.fontSize || 16;
      switch (character.script) {
        case "super":
        case "sub":
          fontSize *= .8;
      }
      ctx.setTextStyle({
        textAlign: "left",
        textBaseline: character.textBaseline || "alphabetic",
        fontStyle: character.fontStyle || "",
        fontWeight: character.fontWeight || "",
        fontSize: fontSize,
        fontFamily: character.fontFamily
      });
    };
    function applyFillStyle(ctx, character, b) {
      const fillStyle = character && character.fill || defaultFormatting.fill;
      if (!fillStyle) return void (ctx.globalAlpha = 0);
      const {
        fillOpacity = 1,
        opacity = 1
      } = character;
      ctx.globalAlpha = fillOpacity * opacity, ctx.fillStyle = b ? createColor(ctx, fillStyle, {
        AABBBounds: b
      }) : fillStyle, setTextStyle(ctx, character);
    }
    function applyStrokeStyle(ctx, character) {
      const strokeStyle = character && character.stroke || defaultFormatting.stroke;
      if (!strokeStyle) return void (ctx.globalAlpha = 0);
      const {
        strokeOpacity = 1,
        opacity = 1
      } = character;
      ctx.globalAlpha = strokeOpacity * opacity, ctx.lineWidth = character && "number" == typeof character.lineWidth ? character.lineWidth : 1, ctx.strokeStyle = strokeStyle, setTextStyle(ctx, character);
    }
    function getStrByWithCanvas(desc, width, character, guessIndex, needTestLetter) {
      if (desc.length <= 1) return 0;
      if (!width || width <= 0) return 0;
      const textMeasure = application.graphicUtil.textMeasure;
      let index = guessIndex,
        temp = desc.slice(0, index),
        tempWidth = Math.floor(textMeasure.measureText(temp, character).width),
        tempNext = desc.slice(0, index + 1),
        tempWidthNext = Math.floor(textMeasure.measureText(tempNext, character).width);
      for (; tempWidth > width || tempWidthNext <= width;) {
        if (tempWidth > width ? index-- : index++, index > desc.length) {
          index = desc.length;
          break;
        }
        if (index < 0) {
          index = 0;
          break;
        }
        temp = desc.slice(0, index), tempWidth = Math.floor(textMeasure.measureText(temp, character).width), tempNext = desc.slice(0, index + 1), tempWidthNext = Math.floor(textMeasure.measureText(tempNext, character).width);
      }
      return needTestLetter && (index = testLetter(desc, index)), index;
    }
    function testLetter(string, index) {
      let negativeWrongMatch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
      let i = index;
      for (; regLetter.test(string[i - 1]) && regLetter.test(string[i]) || regPunctuation.test(string[i]);) if (i--, i <= 0) return negativeWrongMatch ? testLetter2(string, index) : index;
      return i;
    }
    function testLetter2(string, index) {
      let i = index;
      for (; regLetter.test(string[i + 1]) && regLetter.test(string[i]) || regPunctuation.test(string[i]);) if (i++, i >= string.length) return i;
      return i + 1;
    }
    function measureTextCanvas(text, character) {
      let mode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "actual";
      var _a;
      if ("" === text) return {
        ascent: 0,
        height: 0,
        descent: 0,
        width: 0
      };
      const measurement = application.graphicUtil.textMeasure.measureText(text, character),
        result = {
          ascent: 0,
          height: 0,
          descent: 0,
          width: 0
        },
        ascent = "actual" === mode ? measurement.actualBoundingBoxAscent : measurement.fontBoundingBoxAscent,
        descent = "actual" === mode ? measurement.actualBoundingBoxDescent : measurement.fontBoundingBoxDescent;
      "number" != typeof ascent || "number" != typeof descent ? (result.width = Math.floor(measurement.width), result.height = character.fontSize || 0, result.ascent = result.height, result.descent = 0) : (result.width = Math.floor(measurement.width), result.height = Math.floor(ascent + descent), result.ascent = Math.floor(ascent), result.descent = result.height - result.ascent);
      const space = null !== (_a = character.space) && void 0 !== _a ? _a : 0;
      return result.width += space, result;
    }

    var __decorate$$ = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let ATextMeasure = class {
      configure(service, env) {
        this.canvas = service.canvas, this.context = service.context, service.bindTextMeasure(this);
      }
      _measureTextWithoutAlignBaseline(text, options, compatible) {
        this.context.setTextStyleWithoutAlignBaseline(options);
        const metrics = this.context.measureText(text);
        return compatible ? this.compatibleMetrics(metrics, options) : metrics;
      }
      _measureTextWithAlignBaseline(text, options, compatible) {
        this.context.setTextStyle(options);
        const metrics = this.context.measureText(text);
        return compatible ? this.compatibleMetrics(metrics, options) : metrics;
      }
      compatibleMetrics(metrics, options) {
        if (null == metrics.actualBoundingBoxAscent || null == metrics.actualBoundingBoxDescent || null == metrics.fontBoundingBoxAscent || null == metrics.fontBoundingBoxDescent) {
          metrics = {
            width: metrics.width
          };
          const {
            ascent: ascent,
            descent: descent
          } = this.measureTextBoundADscentEstimate(options);
          metrics.actualBoundingBoxAscent = ascent, metrics.actualBoundingBoxDescent = descent, metrics.fontBoundingBoxAscent = ascent, metrics.fontBoundingBoxDescent = descent;
        }
        if (null == metrics.actualBoundingBoxLeft || null == metrics.actualBoundingBoxRight) {
          metrics = {
            width: metrics.width,
            actualBoundingBoxAscent: metrics.actualBoundingBoxAscent,
            actualBoundingBoxDescent: metrics.actualBoundingBoxDescent,
            fontBoundingBoxAscent: metrics.fontBoundingBoxAscent,
            fontBoundingBoxDescent: metrics.fontBoundingBoxDescent
          };
          const {
            left: left,
            right: right
          } = this.measureTextBoundLeftRightEstimate(options);
          metrics.actualBoundingBoxLeft = left, metrics.actualBoundingBoxRight = right;
        }
        return metrics;
      }
      estimate(text, _ref) {
        let {
          fontSize = DefaultTextAttribute.fontSize
        } = _ref;
        let eCharLen = 0,
          cCharLen = 0;
        for (let i = 0; i < text.length; i++) text.charCodeAt(i) < 128 ? eCharLen++ : cCharLen++;
        return {
          width: ~~(.8 * eCharLen * fontSize + cCharLen * fontSize),
          height: fontSize
        };
      }
      measureTextWidth(text, options, textMeasure) {
        return this.context ? (textMeasure = null != textMeasure ? textMeasure : this._measureTextWithoutAlignBaseline(text, options)).width : this.estimate(text, options).width;
      }
      measureTextBoundsWidth(text, options, textMeasure) {
        return this.context ? (textMeasure = null != textMeasure ? textMeasure : this._measureTextWithoutAlignBaseline(text, options)).width : this.estimate(text, options).width;
      }
      measureTextBoundsLeftRight(text, options, textMeasure) {
        return this.context ? {
          left: (textMeasure = null != textMeasure ? textMeasure : this._measureTextWithAlignBaseline(text, options, !0)).actualBoundingBoxLeft,
          right: textMeasure.actualBoundingBoxRight
        } : this.measureTextBoundLeftRightEstimate(options);
      }
      measureTextPixelHeight(text, options, textMeasure) {
        var _a;
        return this.context ? (textMeasure = null != textMeasure ? textMeasure : this._measureTextWithoutAlignBaseline(text, options, !0), Math.abs(textMeasure.actualBoundingBoxAscent - textMeasure.actualBoundingBoxDescent)) : null !== (_a = options.fontSize) && void 0 !== _a ? _a : DefaultTextStyle.fontSize;
      }
      measureTextPixelADscent(text, options, textMeasure) {
        return this.context ? {
          ascent: (textMeasure = null != textMeasure ? textMeasure : this._measureTextWithAlignBaseline(text, options, !0)).actualBoundingBoxAscent,
          descent: textMeasure.actualBoundingBoxDescent
        } : this.measureTextBoundADscentEstimate(options);
      }
      measureTextBoundHieght(text, options, textMeasure) {
        var _a;
        return this.context ? (textMeasure = null != textMeasure ? textMeasure : this._measureTextWithoutAlignBaseline(text, options, !0), Math.abs(textMeasure.fontBoundingBoxAscent - textMeasure.fontBoundingBoxDescent)) : null !== (_a = options.fontSize) && void 0 !== _a ? _a : DefaultTextStyle.fontSize;
      }
      measureTextBoundADscent(text, options, textMeasure) {
        return this.context ? {
          ascent: (textMeasure = null != textMeasure ? textMeasure : this._measureTextWithAlignBaseline(text, options, !0)).fontBoundingBoxAscent,
          descent: textMeasure.fontBoundingBoxDescent
        } : this.measureTextBoundADscentEstimate(options);
      }
      measureTextBoundADscentEstimate(options) {
        var _a;
        const fontSize = null !== (_a = options.fontSize) && void 0 !== _a ? _a : DefaultTextStyle.fontSize;
        return {
          ascent: .79 * fontSize,
          descent: .21 * fontSize
        };
      }
      measureTextBoundLeftRightEstimate(options) {
        var _a;
        const fontSize = null !== (_a = options.fontSize) && void 0 !== _a ? _a : DefaultTextStyle.fontSize,
          {
            textAlign: textAlign
          } = options;
        return "center" === textAlign ? {
          left: fontSize / 2,
          right: fontSize / 2
        } : "right" === textAlign || "end" === textAlign ? {
          left: fontSize,
          right: 0
        } : {
          left: 0,
          right: fontSize
        };
      }
      measureTextPixelADscentAndWidth(text, options, mode) {
        if (!this.context) return Object.assign(Object.assign({}, this.measureTextBoundADscentEstimate(options)), {
          width: this.estimate(text, options).width
        });
        const out = this._measureTextWithoutAlignBaseline(text, options, !0);
        if (mode === MeasureModeEnum.actualBounding) return {
          ascent: out.actualBoundingBoxAscent,
          descent: out.actualBoundingBoxDescent,
          width: out.width
        };
        if (mode === MeasureModeEnum.estimate) return Object.assign(Object.assign({}, this.measureTextBoundADscentEstimate(options)), {
          width: out.width
        });
        if (mode === MeasureModeEnum.fontBounding) {
          let ascent = out.fontBoundingBoxAscent,
            descent = out.fontBoundingBoxDescent;
          if (out.actualBoundingBoxDescent && descent < out.actualBoundingBoxDescent) {
            const delta = out.actualBoundingBoxDescent - descent;
            descent += delta, ascent -= delta;
          } else if (out.actualBoundingBoxAscent && ascent < out.actualBoundingBoxAscent) {
            const delta = out.actualBoundingBoxAscent - ascent;
            ascent += delta, descent -= delta;
          }
          return {
            ascent: ascent,
            descent: descent,
            width: out.width
          };
        }
        return {
          ascent: out.actualBoundingBoxAscent,
          descent: out.actualBoundingBoxDescent,
          width: out.width
        };
      }
      measureText(text, options) {
        return this.context ? (this.context.setTextStyleWithoutAlignBaseline(options), this.context.measureText(text)) : this.estimate(text, options);
      }
      clipTextVertical(verticalList, options, width, wordBreak) {
        if (0 === verticalList.length) return {
          verticalList: verticalList,
          width: 0
        };
        const {
          fontSize = 12
        } = options;
        verticalList.forEach(item => {
          item.width = 0 === item.direction ? fontSize : this.measureTextWidth(item.text, options);
        });
        const out = [];
        let length = 0,
          i = 0;
        for (; i < verticalList.length && length + verticalList[i].width < width; i++) length += verticalList[i].width, out.push(verticalList[i]);
        if (verticalList[i] && verticalList[i].text.length > 1) {
          const clipedData = this._clipText(verticalList[i].text, options, width - length, 0, verticalList[i].text.length - 1, "end", !1);
          if (wordBreak && clipedData.str !== verticalList[i].text) {
            let text = "",
              length = 0;
            for (let j = 0; j < i; j++) {
              const item = verticalList[j];
              text += item.text, length += item.text.length;
            }
            text += verticalList[i].text;
            const totalLength = length + clipedData.str.length;
            let index = testLetter(text, totalLength);
            index -= length, index !== clipedData.str.length - 1 && (clipedData.str = clipedData.str.substring(0, index), clipedData.width = this.measureTextWidth(clipedData.str, options));
          }
          out.push(Object.assign(Object.assign({}, verticalList[i]), {
            text: clipedData.str,
            width: clipedData.width
          })), length += clipedData.width;
        }
        return {
          verticalList: out,
          width: length
        };
      }
      clipText(text, options, width, wordBreak, keepAllBreak) {
        if (0 === text.length) return {
          str: "",
          width: 0
        };
        let length = this.measureTextWidth(text, options);
        if (length <= width) return {
          str: text,
          width: length
        };
        if (length = this.measureTextWidth(text[0], options), length > width) return {
          str: "",
          width: 0
        };
        const data = this._clipText(text, options, width, 0, text.length - 1, "end", !1);
        if (wordBreak && data.str !== text) {
          let index = testLetter(text, data.str.length, keepAllBreak);
          index !== data.str.length && (index > data.str.length && (data.wordBreaked = index, index = data.str.length), data.str = text.substring(0, index), data.width = this.measureTextWidth(data.str, options));
        }
        return data;
      }
      _clipText(text, options, width, leftIdx, rightIdx, position, suffix) {
        let data;
        if ("start" === position) data = this._clipTextStart(text, options, width, leftIdx, rightIdx), suffix && (data.result = suffix + data.str);else if ("middle" === position) {
          const d = this._clipTextMiddle(text, options, width, "", "", 0, 0, 1);
          data = {
            str: "none",
            width: d.width,
            result: d.left + suffix + d.right
          };
        } else data = this._clipTextEnd(text, options, width, leftIdx, rightIdx), suffix && (data.result = data.str + suffix);
        return data;
      }
      _clipTextEnd(text, options, width, leftIdx, rightIdx) {
        if (leftIdx === rightIdx) {
          Logger$1.getInstance().warn(`【_clipTextEnd】不应该走到这里${text}, ${leftIdx}, ${rightIdx}`);
          const subText = text.substring(0, rightIdx + 1);
          return {
            str: subText,
            width: this.measureTextWidth(subText, options)
          };
        }
        const middleIdx = Math.floor((leftIdx + rightIdx) / 2),
          subText = text.substring(0, middleIdx + 1),
          strWidth = this.measureTextWidth(subText, options);
        let length;
        if (strWidth > width) {
          if (subText.length <= 1) return {
            str: "",
            width: 0
          };
          const str = text.substring(0, middleIdx);
          return length = this.measureTextWidth(str, options), length <= width ? {
            str: str,
            width: length
          } : this._clipTextEnd(text, options, width, leftIdx, middleIdx);
        }
        if (strWidth < width) {
          if (middleIdx >= text.length - 1) return {
            str: text,
            width: this.measureTextWidth(text, options)
          };
          const str = text.substring(0, middleIdx + 2);
          return length = this.measureTextWidth(str, options), length >= width ? {
            str: subText,
            width: strWidth
          } : this._clipTextEnd(text, options, width, middleIdx, rightIdx);
        }
        return {
          str: subText,
          width: strWidth
        };
      }
      _clipTextStart(text, options, width, leftIdx, rightIdx) {
        const middleIdx = Math.ceil((leftIdx + rightIdx) / 2),
          subText = text.substring(middleIdx - 1, text.length),
          strWidth = this.measureTextWidth(subText, options);
        let length;
        if (strWidth > width) {
          if (subText.length <= 1) return {
            str: "",
            width: 0
          };
          const str = text.substring(middleIdx, text.length);
          return length = this.measureTextWidth(str, options), length <= width ? {
            str: str,
            width: length
          } : this._clipTextStart(text, options, width, middleIdx, text.length);
        }
        if (strWidth < width) {
          if (middleIdx <= 0) return {
            str: text,
            width: this.measureTextWidth(text, options)
          };
          const str = text.substring(middleIdx - 2, text.length);
          return length = this.measureTextWidth(str, options), length >= width ? {
            str: subText,
            width: strWidth
          } : this._clipTextStart(text, options, width, leftIdx, middleIdx);
        }
        return {
          str: subText,
          width: strWidth
        };
      }
      _clipTextMiddle(text, options, width, left, right, leftW, rightW, buffer) {
        const subLeftText = text.substring(0, buffer),
          strLeftWidth = this.measureTextWidth(subLeftText, options);
        if (strLeftWidth + rightW > width) return {
          left: left,
          right: right,
          width: leftW + rightW
        };
        const subRightText = text.substring(text.length - buffer, text.length),
          strRightWidth = this.measureTextWidth(subRightText, options);
        return strLeftWidth + strRightWidth > width ? {
          left: subLeftText,
          right: right,
          width: strLeftWidth + rightW
        } : this._clipTextMiddle(text, options, width, subLeftText, subRightText, strLeftWidth, strRightWidth, buffer + 1);
      }
      clipTextWithSuffixVertical(verticalList, options, width, suffix, wordBreak, suffixPosition) {
        if ("" === suffix) return this.clipTextVertical(verticalList, options, width, wordBreak);
        if (0 === verticalList.length) return {
          verticalList: verticalList,
          width: 0
        };
        const output = this.clipTextVertical(verticalList, options, width, wordBreak);
        if (output.verticalList.length === verticalList.length && output.verticalList[output.verticalList.length - 1].width === verticalList[verticalList.length - 1].width) return output;
        const suffixWidth = this.measureTextWidth(suffix, options);
        if (suffixWidth > width) return output;
        let out;
        if (width -= suffixWidth, "start" === suffixPosition) {
          const nextVerticalList = this.revertVerticalList(verticalList);
          out = this.clipTextVertical(nextVerticalList, options, width, wordBreak);
          const v = this.revertVerticalList(out.verticalList);
          v.unshift({
            text: suffix,
            direction: 1,
            width: suffixWidth
          }), out.verticalList = v;
        } else if ("middle" === suffixPosition) {
          const leftOut = this.clipTextVertical(verticalList, options, width / 2, wordBreak),
            nextVerticalList = this.revertVerticalList(verticalList),
            rightOut = this.clipTextVertical(nextVerticalList, options, width / 2, wordBreak);
          leftOut.verticalList.push({
            text: suffix,
            direction: 1,
            width: suffixWidth
          }), this.revertVerticalList(rightOut.verticalList).forEach(v => leftOut.verticalList.push(v)), out = {
            verticalList: leftOut.verticalList,
            width: leftOut.width + rightOut.width
          };
        } else out = this.clipTextVertical(verticalList, options, width, wordBreak), out.verticalList.push({
          text: suffix,
          direction: 1,
          width: suffixWidth
        });
        return out.width += suffixWidth, out;
      }
      revertVerticalList(verticalList) {
        return verticalList.reverse().map(l => {
          const t = l.text.split("").reverse().join("");
          return Object.assign(Object.assign({}, l), {
            text: t
          });
        });
      }
      clipTextWithSuffix(text, options, width, suffix, wordBreak, position) {
        let forceSuffix = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : !1;
        if ("" === suffix) return this.clipText(text, options, width, wordBreak);
        if (0 === text.length) return {
          str: "",
          width: 0
        };
        const length = this.measureTextWidth(text, options);
        if (!forceSuffix && length <= width) return {
          str: text,
          width: length
        };
        const suffixWidth = this.measureTextWidth(suffix, options);
        if (suffixWidth > width) return {
          str: "",
          width: 0
        };
        if (forceSuffix && length + suffixWidth <= width) return {
          str: text + suffix,
          width: length + suffixWidth
        };
        width -= suffixWidth;
        const data = this._clipText(text, options, width, 0, text.length - 1, position, suffix);
        if (wordBreak && data.str !== text) {
          const index = testLetter(text, data.str.length);
          index !== data.str.length && (data.result = text.substring(0, index), data.width = this.measureTextWidth(data.str, options));
        } else forceSuffix && data.str === text && (data.result = text + suffix);
        return data.str = data.result, data.width += suffixWidth, data;
      }
    };
    ATextMeasure = __decorate$$([injectable()], ATextMeasure);

    var __decorate$_ = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    const TextMeasureContribution = Symbol.for("TextMeasureContribution");
    let DefaultTextMeasureContribution = class extends ATextMeasure {};
    DefaultTextMeasureContribution = __decorate$_([injectable()], DefaultTextMeasureContribution);

    const container = new Container$2();

    const CanvasFactory = Symbol.for("CanvasFactory");
    const Context2dFactory = Symbol.for("Context2dFactory");

    function wrapCanvas(params) {
      return container.getNamed(CanvasFactory, application.global.env)(params);
    }

    class DefaultCanvasAllocate {
      constructor() {
        this.pools = [], this.allocatedCanvas = [];
      }
      shareCanvas() {
        return this.allocatedCanvas.length ? this.allocatedCanvas[0] : this.getCommonCanvas();
      }
      getCommonCanvas() {
        return this._commonCanvas || (this._commonCanvas = this.allocate({
          width: 100,
          height: 100,
          dpr: 2
        })), this._commonCanvas;
      }
      allocate(data) {
        if (!this.pools.length) {
          const c = wrapCanvas(Object.assign({
            nativeCanvas: application.global.createCanvas(data)
          }, data));
          return this.allocatedCanvas.push(c), c;
        }
        const m = this.pools.pop();
        return m.resize(data.width, data.height), m.dpr = data.dpr, m;
      }
      allocateByObj(canvas) {
        if (!this.pools.length) {
          const data = {
              width: canvas.width / canvas.dpr,
              height: canvas.height / canvas.dpr,
              dpr: canvas.dpr
            },
            c = wrapCanvas(Object.assign({
              nativeCanvas: application.global.createCanvas(data)
            }, data));
          return this.allocatedCanvas.push(c), c;
        }
        const m = this.pools.pop();
        return m.width = canvas.width, m.height = canvas.height, m;
      }
      free(d) {
        this.pools.push(d);
      }
      get length() {
        return this.pools.length;
      }
      release() {
        this.pools = [];
      }
    }
    const canvasAllocate = new DefaultCanvasAllocate();

    var __decorate$Z = undefined && undefined.__decorate || function (decorators, target, key, desc) {
        var d,
          c = arguments.length,
          r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      },
      __metadata$M = undefined && undefined.__metadata || function (k, v) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
      };
    const VWindow = Symbol.for("VWindow");
    const WindowHandlerContribution = Symbol.for("WindowHandlerContribution");
    let DefaultWindow = class extends EventListenerManager {
      get width() {
        if (this._handler) {
          const wh = this._handler.getWH();
          return this._width = wh.width;
        }
        return this._width;
      }
      get height() {
        if (this._handler) {
          const wh = this._handler.getWH();
          return this._height = wh.height;
        }
        return this._height;
      }
      get dpr() {
        return this._handler.getDpr();
      }
      constructor() {
        super(), this.hooks = {
          onChange: new SyncHook(["x", "y", "width", "height"])
        }, this.active = () => {
          const global = this.global;
          if (!global.env || this.actived) return;
          container.getNamed(WindowHandlerContribution, global.env).configure(this, global), this.actived = !0;
        }, this._uid = Generator.GenAutoIncrementId(), this.global = application.global, this.postInit();
      }
      _nativeAddEventListener(type, listener, options) {
        return this._handler.addEventListener(type, listener, options);
      }
      _nativeRemoveEventListener(type, listener, options) {
        return this._handler.removeEventListener(type, listener, options);
      }
      _nativeDispatchEvent(event) {
        return this._handler.dispatchEvent(event);
      }
      postInit() {
        this.global.hooks.onSetEnv.tap("window", this.active), this.active();
      }
      get style() {
        var _a;
        return null !== (_a = this._handler.getStyle()) && void 0 !== _a ? _a : {};
      }
      set style(style) {
        this._handler.setStyle(style);
      }
      create(params) {
        var _a, _b;
        this._handler.createWindow(params);
        const windowWH = this._handler.getWH();
        this._width = windowWH.width, this._height = windowWH.height, params.viewBox ? this.setViewBox(params.viewBox) : !1 !== params.canvasControled ? this.setViewBox({
          x1: 0,
          y1: 0,
          x2: this._width,
          y2: this._height
        }) : this.setViewBox({
          x1: 0,
          y1: 0,
          x2: null !== (_a = params.width) && void 0 !== _a ? _a : this._width,
          y2: null !== (_b = params.height) && void 0 !== _b ? _b : this._height
        }), this.title = this._handler.getTitle(), this.resizable = !0;
      }
      setWindowHandler(handler) {
        this._handler = handler;
      }
      setDpr(dpr) {
        return this._handler.setDpr(dpr);
      }
      resize(w, h) {
        return this._handler.resizeWindow(w, h);
      }
      configure() {
        throw new Error("暂不支持");
      }
      release() {
        return this.global.hooks.onSetEnv.unTap("window", this.active), this.clearAllEventListeners(), this._handler.releaseWindow();
      }
      getContext() {
        return this._handler.getContext();
      }
      getNativeHandler() {
        return this._handler.getNativeHandler();
      }
      getImageBuffer(type) {
        return this._handler.getImageBuffer ? this._handler.getImageBuffer(type) : null;
      }
      getBoundingClientRect() {
        return this._handler.getBoundingClientRect();
      }
      getContainer() {
        return this._handler.container;
      }
      clearViewBox(color) {
        this._handler.clearViewBox(color);
      }
      setViewBox(viewBox) {
        this._handler.setViewBox(viewBox);
      }
      setViewBoxTransform(a, b, c, d, e, f) {
        this._handler.setViewBoxTransform(a, b, c, d, e, f);
      }
      getViewBox() {
        return this._handler.getViewBox();
      }
      getViewBoxTransform() {
        return this._handler.getViewBoxTransform();
      }
      pointTransform(x, y) {
        const vb = this._handler.getViewBox(),
          nextP = {
            x: x,
            y: y
          };
        return this._handler.getViewBoxTransform().transformPoint({
          x: x,
          y: y
        }, nextP), nextP.x -= vb.x1, nextP.y -= vb.y1, nextP;
      }
      hasSubView() {
        const viewBox = this._handler.getViewBox();
        return !(0 === viewBox.x1 && 0 === viewBox.y1 && isNumberClose$1(this.width, viewBox.width()) && isNumberClose$1(this.height, viewBox.height()));
      }
      isVisible(bbox) {
        return this._handler.isVisible(bbox);
      }
      onVisibleChange(cb) {
        return this._handler.onVisibleChange(cb);
      }
      getTopLeft(baseWindow) {
        return this._handler.getTopLeft(baseWindow);
      }
    };
    DefaultWindow = __decorate$Z([injectable(), __metadata$M("design:paramtypes", [])], DefaultWindow);

    var __decorate$Y = undefined && undefined.__decorate || function (decorators, target, key, desc) {
        var d,
          c = arguments.length,
          r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      },
      __metadata$L = undefined && undefined.__metadata || function (k, v) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
      },
      __param$A = undefined && undefined.__param || function (paramIndex, decorator) {
        return function (target, key) {
          decorator(target, key, paramIndex);
        };
      };
    let DefaultGraphicUtil = class {
      get canvas() {
        return this.tryInitCanvas(), this._canvas;
      }
      get context() {
        return this.tryInitCanvas(), this._context;
      }
      constructor(contributions) {
        this.contributions = contributions, this.configured = !1, this.global = application.global, this.global.hooks.onSetEnv.tap("graphic-util", (lastEnv, env, global) => {
          this.configured = !1, this.configure(global, env);
        });
      }
      get textMeasure() {
        return this._textMeasure || this.configure(this.global, this.global.env), this._textMeasure;
      }
      configure(global, env) {
        this.configured || (this.contributions.getContributions().forEach(contribution => {
          contribution.configure(this, env);
        }), this.configured = !0);
      }
      tryInitCanvas() {
        if (!this._canvas) {
          const canvas = canvasAllocate.shareCanvas();
          this._canvas = canvas, this._context = canvas.getContext("2d");
        }
      }
      bindTextMeasure(tm) {
        this._textMeasure = tm;
      }
      measureText(text, tc) {
        let method = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "native";
        var _a;
        this.configure(this.global, this.global.env);
        const m = this.global.measureTextMethod;
        this.global.measureTextMethod = method;
        const data = {
          width: this._textMeasure.measureTextWidth(text, tc),
          height: null !== (_a = tc.fontSize) && void 0 !== _a ? _a : DefaultTextStyle.fontSize
        };
        return this.global.measureTextMethod = m, data;
      }
      createTextMeasureInstance(textSpec, option, getCanvasForMeasure) {
        return this.configure(this.global, this.global.env), new TextMeasure$1(Object.assign({
          defaultFontParams: {
            fontFamily: DefaultTextStyle.fontFamily,
            fontSize: DefaultTextStyle.fontSize
          },
          getCanvasForMeasure: getCanvasForMeasure || (() => this.canvas),
          getTextBounds: void 0,
          specialCharSet: "-/: .,@%'\"~" + TextMeasure$1.ALPHABET_CHAR_SET + TextMeasure$1.ALPHABET_CHAR_SET.toUpperCase()
        }, null != option ? option : {}), textSpec);
      }
      drawGraphicToCanvas(graphic, stage, canvas) {
        if (!stage.defaultLayer) return null;
        const window = container.get(VWindow),
          bounds = graphic.AABBBounds,
          width = bounds.width(),
          height = bounds.height(),
          x1 = -bounds.x1,
          y1 = -bounds.y1;
        window.create({
          viewBox: {
            x1: x1,
            y1: y1,
            x2: bounds.x2,
            y2: bounds.y2
          },
          width: width,
          height: height,
          canvas: canvas,
          dpr: stage.window.dpr,
          canvasControled: !0,
          offscreen: !0,
          title: ""
        });
        const disableCheckGraphicWidthOutRange = stage.params.optimize.disableCheckGraphicWidthOutRange;
        stage.params.optimize.disableCheckGraphicWidthOutRange = !0, stage.defaultLayer.getNativeHandler().drawTo(window, [graphic], {
          transMatrix: window.getViewBoxTransform(),
          viewBox: window.getViewBox(),
          stage: stage,
          layer: stage.defaultLayer,
          renderService: stage.renderService,
          background: "transparent",
          clear: !0,
          updateBounds: !1
        }), stage.params.optimize.disableCheckGraphicWidthOutRange = disableCheckGraphicWidthOutRange;
        const c = window.getNativeHandler();
        return c.nativeCanvas ? c.nativeCanvas : null;
      }
    };
    DefaultGraphicUtil = __decorate$Y([injectable(), __param$A(0, inject(ContributionProvider)), __param$A(0, named(TextMeasureContribution)), __metadata$L("design:paramtypes", [Object])], DefaultGraphicUtil);
    var TransformMode;
    !function (TransformMode) {
      TransformMode[TransformMode.transform = 0] = "transform", TransformMode[TransformMode.matrix = 1] = "matrix";
    }(TransformMode || (TransformMode = {}));
    const _matrix = new Matrix();
    let DefaultTransformUtil = class {
      constructor() {
        this.matrix = new Matrix();
      }
      init(origin) {
        return this.mode = TransformMode.transform, this.originTransform = origin, this.matrix.reset(), this;
      }
      fromMatrix(source, target) {
        return this.mode = TransformMode.matrix, this.outSourceMatrix = source, this.outTargetMatrix = target, this;
      }
      scaleMatrix(sx, sy, center) {
        const sMatrix = this.outSourceMatrix;
        if (_matrix.setValue(sMatrix.a, sMatrix.b, sMatrix.c, sMatrix.d, sMatrix.e, sMatrix.f), this.outTargetMatrix.reset(), center) {
          const {
            x: x,
            y: y
          } = center;
          this.outTargetMatrix.translate(x, y), this.outTargetMatrix.scale(sx, sy), this.outTargetMatrix.translate(-x, -y);
        } else this.outTargetMatrix.scale(sx, sy);
        return this.outTargetMatrix.multiply(_matrix.a, _matrix.b, _matrix.c, _matrix.d, _matrix.e, _matrix.f), this;
      }
      rotateMatrix(angle, center) {
        const sMatrix = this.outSourceMatrix;
        if (_matrix.setValue(sMatrix.a, sMatrix.b, sMatrix.c, sMatrix.d, sMatrix.e, sMatrix.f), this.outTargetMatrix.reset(), center) {
          const {
            x: x,
            y: y
          } = center;
          this.outTargetMatrix.translate(x, y), this.outTargetMatrix.rotate(angle), this.outTargetMatrix.translate(-x, -y);
        } else this.outTargetMatrix.rotate(angle);
        return this.outTargetMatrix.multiply(_matrix.a, _matrix.b, _matrix.c, _matrix.d, _matrix.e, _matrix.f), this;
      }
      scale(sx, sy, center) {
        return this.mode === TransformMode.matrix ? this.scaleMatrix(sx, sy, center) : this;
      }
      rotate(angle, center) {
        return this.mode === TransformMode.matrix ? this.rotateMatrix(angle, center) : this;
      }
      translateMatrix(dx, dy) {
        const sMatrix = this.outSourceMatrix;
        return _matrix.setValue(sMatrix.a, sMatrix.b, sMatrix.c, sMatrix.d, sMatrix.e, sMatrix.f), this.outTargetMatrix.reset(), this.outTargetMatrix.translate(dx, dy), this.outTargetMatrix.multiply(_matrix.a, _matrix.b, _matrix.c, _matrix.d, _matrix.e, _matrix.f), this;
      }
      translate(dx, dy) {
        return this.mode === TransformMode.matrix ? this.translateMatrix(dx, dy) : this;
      }
      simplify(target) {
        return this.mode === TransformMode.matrix ? this.simplifyMatrix(target) : this;
      }
      simplifyMatrix(target) {
        return this;
      }
    };
    DefaultTransformUtil = __decorate$Y([injectable(), __metadata$L("design:paramtypes", [])], DefaultTransformUtil);

    const defaultThemeObj = {
        arc: DefaultArcAttribute,
        area: DefaultAreaAttribute,
        circle: DefaultCircleAttribute,
        line: DefaultLineAttribute,
        path: DefaultPathAttribute,
        symbol: DefaultSymbolAttribute,
        text: DefaultTextAttribute,
        rect: DefaultRectAttribute,
        polygon: DefaultPolygonAttribute,
        star: DefaultStarAttribute,
        richtext: DefaultRichTextAttribute,
        richtextIcon: DefaultRichTextIconAttribute,
        image: DefaultImageAttribute,
        group: DefaultGroupAttribute,
        glyph: DefaultGlyphAttribute
      },
      themeKeys = Object.keys(defaultThemeObj);
    function newThemeObj() {
      return {
        arc: Object.assign({}, defaultThemeObj.arc),
        area: Object.assign({}, defaultThemeObj.area),
        circle: Object.assign({}, defaultThemeObj.circle),
        line: Object.assign({}, defaultThemeObj.line),
        path: Object.assign({}, defaultThemeObj.path),
        symbol: Object.assign({}, defaultThemeObj.symbol),
        text: Object.assign({}, defaultThemeObj.text),
        rect: Object.assign({}, defaultThemeObj.rect),
        polygon: Object.assign({}, defaultThemeObj.polygon),
        star: Object.assign({}, defaultThemeObj.star),
        richtext: Object.assign({}, defaultThemeObj.richtext),
        richtextIcon: Object.assign({}, defaultThemeObj.richtextIcon),
        image: Object.assign({}, defaultThemeObj.image),
        group: Object.assign({}, defaultThemeObj.group),
        glyph: Object.assign({}, defaultThemeObj.glyph)
      };
    }
    function combine(out, t) {
      Object.keys(t).forEach(k => {
        out[k] = t[k];
      });
    }
    const globalThemeObj = newThemeObj();
    class Theme {
      constructor() {
        this.initTheme(), this.dirty = !1;
      }
      initTheme() {
        this._defaultTheme = {}, themeKeys.forEach(key => {
          this._defaultTheme[key] = Object.create(globalThemeObj[key]);
        }), this.combinedTheme = this._defaultTheme;
      }
      getTheme(group) {
        if (!group) return this.combinedTheme;
        if (!this.dirty) return this.combinedTheme;
        let parentTheme = {};
        const parentGroup = this.getParentWithTheme(group);
        return parentGroup && (parentTheme = parentGroup.theme), this.applyTheme(group, parentTheme), this.combinedTheme;
      }
      getParentWithTheme(group) {
        for (; group.parent;) if ((group = group.parent).theme) return group;
        return null;
      }
      applyTheme(group, pt) {
        let force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
        if (this.dirty) {
          const parentGroup = this.getParentWithTheme(group);
          if (parentGroup) {
            const parentTheme = parentGroup.theme;
            (parentTheme.dirty || force) && parentTheme.applyTheme(parentGroup, pt, !0);
          }
          this.userTheme ? this.doCombine(parentGroup && parentGroup.theme.combinedTheme) : (parentGroup ? this.combinedTheme = parentGroup.theme.combinedTheme : (this.combinedTheme = this._defaultTheme, Logger$1.getInstance().warn("未知错误，走到不应该走的区域里")), this.dirty = !1);
        }
        return this.combinedTheme;
      }
      doCombine(parentCombinedTheme) {
        const userTheme = this.userTheme,
          combinedTheme = this.combinedTheme;
        themeKeys.forEach(k => {
          const obj = Object.create(globalThemeObj[k]);
          parentCombinedTheme && parentCombinedTheme[k] && combine(obj, parentCombinedTheme[k]), combinedTheme[k] && combine(obj, combinedTheme[k]), userTheme[k] && combine(obj, userTheme[k]), this.combinedTheme[k] = obj;
        }), userTheme.common && themeKeys.forEach(k => {
          combine(this.combinedTheme[k], userTheme.common);
        }), this.dirty = !1;
      }
      setTheme(t, g) {
        let userTheme = this.userTheme;
        userTheme ? Object.keys(t).forEach(k => {
          userTheme[k] ? Object.assign(userTheme[k], t[k]) : userTheme[k] = Object.assign({}, t[k]);
        }) : userTheme = t, this.userTheme = userTheme, this.dirty = !0, this.dirtyChildren(g);
      }
      resetTheme(t, g) {
        this.userTheme = t, this.dirty = !0, this.dirtyChildren(g);
      }
      dirtyChildren(g) {
        g.forEachChildren(item => {
          item.isContainer && (item.theme && (item.theme.dirty = !0), this.dirtyChildren(item));
        });
      }
    }
    const globalTheme = new Theme();
    function getTheme(graphic, theme) {
      return graphic.glyphHost ? getTheme(graphic.glyphHost) : theme ? (graphic.isContainer, theme) : getThemeFromGroup(graphic) || graphic.attachedThemeGraphic && getTheme(graphic.attachedThemeGraphic) || globalTheme.getTheme();
    }
    function getThemeFromGroup(graphic) {
      let g;
      if (g = graphic.isContainer ? graphic : graphic.parent, g) {
        for (; g && !g.theme;) g = g.parent;
        return g ? (g.theme || g.createTheme(), g.theme.getTheme(g)) : globalTheme.getTheme();
      }
      return null;
    }

    var __awaiter$4 = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          var value;
          result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P(function (resolve) {
            resolve(value);
          })).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    class Node extends EventEmitter {
      get previousSibling() {
        return this._prev;
      }
      get nextSibling() {
        return this._next;
      }
      get children() {
        return this.getChildren();
      }
      get firstChild() {
        return this._firstChild;
      }
      get lastChild() {
        return this._lastChild;
      }
      get count() {
        return this._count;
      }
      get childrenCount() {
        return this._idMap ? this._idMap.size : 0;
      }
      constructor() {
        super(), this._uid = Generator.GenAutoIncrementId(), this._firstChild = null, this._lastChild = null, this.parent = null, this._count = 1;
      }
      forEachChildren(cb) {
        let reverse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
        if (reverse) {
          let child = this._lastChild,
            i = 0;
          for (; child;) {
            if (cb(child, i++)) return;
            child = child._prev;
          }
        } else {
          let child = this._firstChild,
            i = 0;
          for (; child;) {
            if (cb(child, i++)) return;
            child = child._next;
          }
        }
      }
      forEachChildrenAsync(cb) {
        let reverse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
        return __awaiter$4(this, void 0, void 0, function* () {
          if (reverse) {
            let child = this._lastChild,
              i = 0;
            for (; child;) {
              let breakTag = cb(child, i++);
              if (breakTag.then && (breakTag = yield breakTag), breakTag) return;
              child = child._prev;
            }
          } else {
            let child = this._firstChild,
              i = 0;
            for (; child;) {
              let breakTag = cb(child, i++);
              if (breakTag.then && (breakTag = yield breakTag), breakTag) return;
              child = child._next;
            }
          }
        });
      }
      forEach(cb) {
        return this.forEachChildren(cb);
      }
      appendChild(node) {
        let highPerformance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
        if (this._uid === node._uid) return null;
        if (!highPerformance && node.isAncestorsOf(this)) throw new Error("【Node::appendChild】不能将父辈元素append为子元素");
        return node.parent && node.parent.removeChild(node), node.parent = this, this._lastChild ? (this._lastChild._next = node, node._prev = this._lastChild, this._lastChild = node) : (this._firstChild = this._lastChild = node, node._prev = node._next = null), this._idMap || (this._idMap = new Map()), this._idMap.set(node._uid, node), this.setCount(node.count), this._structEdit = !0, node;
      }
      appendChildArrHighPerformance(nodes) {
        return nodes;
      }
      insertBefore(newNode, referenceNode) {
        if (!referenceNode) return this.appendChild(newNode);
        if (this === newNode || newNode === referenceNode) return null;
        if (newNode.isAncestorsOf(this)) throw new Error("【Node::insertBefore】不能将父辈元素insert为子元素");
        return referenceNode.parent !== this ? null : (newNode.parent && newNode.parent.removeChild(newNode), newNode.parent = this, newNode._prev = referenceNode._prev, referenceNode._prev ? referenceNode._prev._next = newNode : this._firstChild = newNode, referenceNode._prev = newNode, newNode._next = referenceNode, this._idMap || (this._idMap = new Map()), this._idMap.set(newNode._uid, newNode), this._structEdit = !0, this.setCount(newNode.count), newNode);
      }
      insertAfter(newNode, referenceNode) {
        if (!referenceNode) return this.appendChild(newNode);
        if (this === newNode || newNode === referenceNode) return null;
        if (newNode.isAncestorsOf(this)) throw new Error("【Node::insertAfter】不能将父辈元素insert为子元素");
        return referenceNode.parent !== this ? null : (newNode.parent && newNode.parent.removeChild(newNode), newNode.parent = this, referenceNode._next ? (referenceNode._next._prev = newNode, newNode._next = referenceNode._next) : this._lastChild = newNode, referenceNode._next = newNode, newNode._prev = referenceNode, this._idMap || (this._idMap = new Map()), this._idMap.set(newNode._uid, newNode), this._structEdit = !0, this.setCount(newNode.count), newNode);
      }
      insertInto(newNode, idx) {
        if (!this._ignoreWarn && this._nodeList && Logger$1.getInstance().warn("insertIntoKeepIdx和insertInto混用可能会存在错误"), idx >= this.childrenCount) return this.appendChild(newNode);
        if (this === newNode) return null;
        if (newNode.isAncestorsOf(this)) throw new Error("【Node::insertBefore】不能将父辈元素insert为子元素");
        if (newNode.parent && newNode.parent.removeChild(newNode), newNode.parent = this, 0 === idx) newNode._next = this._firstChild, this._firstChild && (this._firstChild._prev = newNode), newNode._prev = null, this._firstChild = newNode;else {
          let child = this._firstChild;
          for (let i = 0; i < idx; i++) {
            if (!child) return null;
            i > 0 && (child = child._next);
          }
          if (!child) return null;
          newNode._next = child._next, newNode._prev = child, child._next = newNode, newNode._next && (newNode._next._prev = newNode);
        }
        return this._idMap || (this._idMap = new Map()), this._idMap.set(newNode._uid, newNode), this._structEdit = !0, this.setCount(newNode.count), newNode;
      }
      insertIntoKeepIdx(newNode, idx) {
        if (this._nodeList || (this._nodeList = this.children), this._nodeList[idx]) {
          const node = this._nodeList[idx];
          return this._nodeList.splice(idx, 0, newNode), this.insertBefore(newNode, node);
        }
        let node;
        this._nodeList[idx] = newNode;
        for (let i = idx - 1; i >= 0 && (node = this._nodeList[i], !node); i--);
        if (node) return node._next ? this.insertBefore(newNode, node._next) : this.appendChild(newNode);
        this._ignoreWarn = !0;
        const data = this.insertInto(newNode, 0);
        return this._ignoreWarn = !1, data;
      }
      removeChild(child) {
        if (!this._idMap) return null;
        if (!this._idMap.has(child._uid)) return null;
        if (this._idMap.delete(child._uid), this._nodeList) {
          const idx = this._nodeList.findIndex(n => n === child);
          idx >= 0 && this._nodeList.splice(idx, 1);
        }
        return child._prev ? child._prev._next = child._next : this._firstChild = child._next, child._next ? child._next._prev = child._prev : this._lastChild = child._prev, child.parent = null, child._prev = null, child._next = null, this._structEdit = !0, this.setCount(-child.count), child;
      }
      delete() {
        this.parent && this.parent.removeChild(this);
      }
      removeAllChild(deep) {
        if (!this._idMap) return;
        this._nodeList && (this._nodeList.length = 0);
        let child = this._firstChild;
        for (; child;) {
          const next = child._next;
          child.parent = null, child._prev = null, child._next = null, child = child._next, child = next;
        }
        this._firstChild = null, this._lastChild = null, this._idMap.clear(), this._structEdit = !0, this.setCount(1 - this._count);
      }
      replaceChild(newChild, oldChild) {
        throw new Error("暂不支持");
      }
      find(callback) {
        let deep = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
        let target = null;
        return this.forEachChildren((node, index) => !(node === this || !callback(node, index)) && (target = node, !0)), deep && this.forEachChildren(child => {
          if (child.isContainer) {
            const node = child.find(callback, !0);
            if (node) return target = node, !0;
          }
          return !1;
        }), target;
      }
      findAll(callback) {
        let deep = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
        let nodes = [];
        return this.forEachChildren((node, index) => {
          node !== this && callback(node, index) && nodes.push(node);
        }), deep && this.forEachChildren(child => {
          if (child.isContainer) {
            const targets = child.findAll(callback, !0);
            targets.length && (nodes = nodes.concat(targets));
          }
        }), nodes;
      }
      getElementById(id) {
        return this.find(node => node.id === id, !0);
      }
      findChildById(id) {
        return this.getElementById(id);
      }
      findChildByUid(uid) {
        return this._idMap && this._idMap.get(uid) || null;
      }
      getElementsByName(name) {
        return this.findAll(node => node.name === name, !0);
      }
      findChildrenByName(name) {
        return this.getElementsByName(name);
      }
      getElementsByType(type) {
        return this.findAll(node => node.type === type, !0);
      }
      getChildByName(name) {
        let deep = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
        return this.find(node => node.name === name, deep);
      }
      getChildAt(idx) {
        let c = this._firstChild;
        if (!c) return null;
        for (let i = 0; i < idx; i++) {
          if (!c._next) return null;
          c = c._next;
        }
        return c;
      }
      at(idx) {
        return this.getChildAt(idx);
      }
      containNode(node) {
        if (!this._idMap) return !1;
        if (this._idMap.has(node._uid)) return !0;
        let child = this._firstChild;
        for (; child;) {
          if (child.containNode(node)) return !0;
          child = child._next;
        }
        return !1;
      }
      getRootNode() {
        let parent = this.parent;
        for (; null == parent ? void 0 : parent.parent;) parent = parent.parent;
        return parent || this;
      }
      hasChildNodes() {
        return null !== this._firstChild;
      }
      addChild(node) {
        return this.appendChild(node);
      }
      add(node) {
        return this.appendChild(node);
      }
      getChildren() {
        const nodes = [];
        let child = this._firstChild;
        for (; child;) nodes.push(child), child = child._next;
        return nodes;
      }
      isChildOf(node) {
        return !!this.parent && this.parent._uid === node._uid;
      }
      isParentOf(node) {
        return node.isChildOf(this);
      }
      isDescendantsOf(node) {
        let parent = this.parent;
        if (!parent) return !1;
        do {
          if (parent._uid === node._uid) return !0;
          parent = parent.parent;
        } while (null !== parent);
        return !1;
      }
      isAncestorsOf(node) {
        return node.isDescendantsOf(this);
      }
      getAncestor(idx) {
        throw new Error("暂不支持");
      }
      setAllDescendantsProps(propsName, propsValue) {
        let child = this._firstChild;
        for (; child;) child[propsName] = propsValue, child.setAllDescendantsProps(propsName, propsValue), child = child._next;
      }
      setCount(deltaCount) {
        this._count += deltaCount;
        let parent = this.parent;
        if (parent) do {
          parent._count += deltaCount, parent = parent.parent;
        } while (null !== parent);
      }
      clone() {
        throw new Error("暂不支持");
      }
      cloneTo(node) {
        throw new Error("暂不支持");
      }
      getParent() {
        return this.parent;
      }
      del(child) {
        return this.removeChild(child);
      }
      addEventListener(type, listener, options) {
        const capture = isBoolean$6(options, !0) && options || isObject$9(options) && options.capture,
          once = isObject$9(options) && options.once,
          context = isFunction$7(listener) ? void 0 : listener;
        return type = capture ? `${type}capture` : type, listener = isFunction$7(listener) ? listener : listener.handleEvent, once ? super.once(type, listener, context) : super.on(type, listener, context), this;
      }
      on(type, listener, options) {
        return this.addEventListener(type, listener, options);
      }
      removeEventListener(type, listener, options) {
        const capture = isBoolean$6(options, !0) && options || isObject$9(options) && options.capture,
          context = isFunction$7(listener) ? void 0 : listener;
        type = capture ? `${type}capture` : type, listener = isFunction$7(listener) ? listener : listener.handleEvent;
        const once = isObject$9(options) && options.once;
        return super.off(type, listener, context, once), this;
      }
      off(type, listener, options) {
        return this.removeEventListener(type, listener, options);
      }
      once(type, listener, options) {
        return isObject$9(options) ? (options.once = !0, this.addEventListener(type, listener, options)) : this.addEventListener(type, listener, {
          once: !0
        });
      }
      removeAllEventListeners() {
        return super.removeAllListeners(), this;
      }
      removeAllListeners() {
        return this.removeAllEventListeners();
      }
      dispatchEvent(event) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        return super.emit(event.type, event, ...args), !event.defaultPrevented;
      }
      emit(event, data) {
        return this.dispatchEvent(event, data);
      }
      release() {
        this.removeAllListeners();
      }
    }

    class FederatedEvent {
      get layerX() {
        return this.layer.x;
      }
      get layerY() {
        return this.layer.y;
      }
      get pageX() {
        return this.page.x;
      }
      get pageY() {
        return this.page.y;
      }
      get x() {
        return this.canvas.x;
      }
      get y() {
        return this.canvas.y;
      }
      get canvasX() {
        return this.canvas.x;
      }
      get canvasY() {
        return this.canvas.y;
      }
      get viewX() {
        return this.viewport.x;
      }
      get viewY() {
        return this.viewport.y;
      }
      constructor(manager) {
        this.bubbles = !0, this.cancelBubble = !0, this.cancelable = !1, this.composed = !1, this.defaultPrevented = !1, this.eventPhase = FederatedEvent.prototype.NONE, this.propagationStopped = !1, this.propagationImmediatelyStopped = !1, this.layer = {
          x: 0,
          y: 0
        }, this.page = {
          x: 0,
          y: 0
        }, this.canvas = {
          x: 0,
          y: 0
        }, this.viewport = {
          x: 0,
          y: 0
        }, this.NONE = 0, this.CAPTURING_PHASE = 1, this.AT_TARGET = 2, this.BUBBLING_PHASE = 3, this.manager = manager;
      }
      composedPath() {
        return !this.manager || this.path && this.path[this.path.length - 1] === this.target || (this.path = this.target ? this.manager.propagationPath(this.target) : []), this.composedDetailPath(), this.path;
      }
      composedDetailPath() {
        return this.pickParams && this.pickParams.graphic ? (this.detailPath = this.path.slice(), this._composedDetailPath(this.pickParams)) : this.detailPath = this.path.slice(), this.detailPath;
      }
      _composedDetailPath(params) {
        if (params && params.graphic) {
          const g = params.graphic;
          if (g.stage) {
            const path = g.stage.eventSystem.manager.propagationPath(g);
            this.detailPath.push(path), this._composedDetailPath(params.params);
          }
        }
      }
      preventDefault() {
        try {
          this.nativeEvent instanceof Event && this.nativeEvent.cancelable && this.nativeEvent.preventDefault();
        } catch (err) {
          this.nativeEvent.preventDefault && isFunction$7(this.nativeEvent.preventDefault) && this.nativeEvent.preventDefault();
        }
        this.defaultPrevented = !0;
      }
      stopImmediatePropagation() {
        this.propagationImmediatelyStopped = !0;
      }
      stopPropagation() {
        try {
          this.nativeEvent instanceof Event && this.nativeEvent.cancelable && this.nativeEvent.stopPropagation();
        } catch (err) {
          this.nativeEvent.stopPropagation && isFunction$7(this.nativeEvent.stopPropagation) && this.nativeEvent.stopPropagation();
        }
        this.propagationStopped = !0;
      }
      initEvent() {}
      initUIEvent() {}
      clone() {
        throw new Error("Method not implemented.");
      }
    }

    class FederatedMouseEvent extends FederatedEvent {
      constructor() {
        super(...arguments), this.client = {
          x: 0,
          y: 0
        }, this.movement = {
          x: 0,
          y: 0
        }, this.offset = {
          x: 0,
          y: 0
        }, this.global = {
          x: 0,
          y: 0
        }, this.screen = {
          x: 0,
          y: 0
        };
      }
      get clientX() {
        return this.client.x;
      }
      get clientY() {
        return this.client.y;
      }
      get movementX() {
        return this.movement.x;
      }
      get movementY() {
        return this.movement.y;
      }
      get offsetX() {
        return this.offset.x;
      }
      get offsetY() {
        return this.offset.y;
      }
      get globalX() {
        return this.global.x;
      }
      get globalY() {
        return this.global.y;
      }
      get screenX() {
        return this.screen.x;
      }
      get screenY() {
        return this.screen.y;
      }
      getModifierState(key) {
        return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(key);
      }
      initMouseEvent(_typeArg, _canBubbleArg, _cancelableArg, _viewArg, _detailArg, _screenXArg, _screenYArg, _clientXArg, _clientYArg, _ctrlKeyArg, _altKeyArg, _shiftKeyArg, _metaKeyArg, _buttonArg, _relatedTargetArg) {
        throw new Error("Method not implemented.");
      }
    }

    class FederatedPointerEvent extends FederatedMouseEvent {
      constructor() {
        super(...arguments), this.width = 0, this.height = 0, this.isPrimary = !1;
      }
      getCoalescedEvents() {
        return "pointermove" === this.type || "mousemove" === this.type || "touchmove" === this.type ? [this] : [];
      }
      getPredictedEvents() {
        throw new Error("getPredictedEvents is not supported!");
      }
      clone() {
        var _a, _b, _c;
        const event = new FederatedPointerEvent(this.manager);
        event.eventPhase = event.NONE, event.currentTarget = null, event.path = [], event.detailPath = [], event.target = null, event.nativeEvent = this.nativeEvent, event.originalEvent = this.originalEvent, null === (_a = this.manager) || void 0 === _a || _a.copyPointerData(this, event), null === (_b = this.manager) || void 0 === _b || _b.copyMouseData(this, event), null === (_c = this.manager) || void 0 === _c || _c.copyData(this, event), event.target = this.target, event.path = this.composedPath().slice();
        const p = this.composedDetailPath();
        return event.detailPath = p && p.slice(), event.type = this.type, event;
      }
    }

    class FederatedWheelEvent extends FederatedMouseEvent {
      constructor() {
        super(...arguments), this.DOM_DELTA_PIXEL = 0, this.DOM_DELTA_LINE = 1, this.DOM_DELTA_PAGE = 2;
      }
      clone() {
        var _a, _b, _c;
        const event = new FederatedWheelEvent(this.manager);
        event.eventPhase = event.NONE, event.currentTarget = null, event.path = [], event.detailPath = [], event.target = null, event.nativeEvent = this.nativeEvent, event.originalEvent = this.originalEvent, null === (_a = this.manager) || void 0 === _a || _a.copyWheelData(this, event), null === (_b = this.manager) || void 0 === _b || _b.copyMouseData(this, event), null === (_c = this.manager) || void 0 === _c || _c.copyData(this, event), event.target = this.target, event.path = this.composedPath().slice();
        const p = this.composedDetailPath();
        return event.detailPath = p && p.slice(), event.type = this.type, event;
      }
    }
    FederatedWheelEvent.DOM_DELTA_PIXEL = 0, FederatedWheelEvent.DOM_DELTA_LINE = 1, FederatedWheelEvent.DOM_DELTA_PAGE = 2;

    class CustomEvent extends FederatedEvent {
      constructor(eventName, object) {
        super(), this.type = eventName, this.detail = object;
      }
    }

    const WILDCARD = "*";

    const clock = "object" == typeof performance && performance.now ? performance : Date;

    function isMouseLike(pointerType) {
      return "mouse" === pointerType || "pen" === pointerType;
    }
    let EventManager$1 = class EventManager {
      constructor(root, config) {
        this.dispatch = new EventEmitter(), this.cursorTarget = null, this.pauseNotify = !1, this.mappingState = {
          trackingData: {}
        }, this.eventPool = new Map(), this.onPointerDown = (from, target) => {
          if (!(from instanceof FederatedPointerEvent)) return void Logger$1.getInstance().warn("EventManager cannot map a non-pointer event as a pointer event");
          const e = this.createPointerEvent(from, from.type, target);
          if (this.dispatchEvent(e, "pointerdown"), "touch" === e.pointerType) this.dispatchEvent(e, "touchstart");else if (isMouseLike(e.pointerType)) {
            const isRightButton = 2 === e.button;
            this.dispatchEvent(e, isRightButton ? "rightdown" : "mousedown");
          }
          this.trackingData(from.pointerId).pressTargetsByButton[from.button] = e.composedPath(), this.freeEvent(e);
        }, this.onPointerMove = (from, target) => {
          var _a, _b;
          if (!(from instanceof FederatedPointerEvent)) return void Logger$1.getInstance().warn("EventManager cannot map a non-pointer event as a pointer event");
          const e = this.createPointerEvent(from, from.type, target),
            isMouse = isMouseLike(e.pointerType),
            trackingData = this.trackingData(from.pointerId),
            outTarget = this.findMountedTarget(trackingData.overTargets);
          if (trackingData.overTargets && outTarget && outTarget !== this.rootTarget && outTarget !== e.target) {
            const outType = "mousemove" === from.type ? "mouseout" : "pointerout",
              outEvent = this.createPointerEvent(from, outType, outTarget || void 0);
            if (this.dispatchEvent(outEvent, "pointerout"), isMouse && this.dispatchEvent(outEvent, "mouseout"), !e.composedPath().includes(outTarget)) {
              const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget || void 0);
              for (leaveEvent.eventPhase = leaveEvent.AT_TARGET; leaveEvent.target && !e.composedPath().includes(leaveEvent.target);) leaveEvent.currentTarget = leaveEvent.target, this.notifyTarget(leaveEvent), isMouse && this.notifyTarget(leaveEvent, "mouseleave"), leaveEvent.target = leaveEvent.target.parent;
              this.freeEvent(leaveEvent);
            }
            this.freeEvent(outEvent);
          }
          if (outTarget !== e.target) {
            const overType = "mousemove" === from.type ? "mouseover" : "pointerover",
              overEvent = this.clonePointerEvent(e, overType);
            this.dispatchEvent(overEvent, "pointerover"), isMouse && this.dispatchEvent(overEvent, "mouseover");
            let overTargetAncestor = null == outTarget ? void 0 : outTarget.parent;
            for (; overTargetAncestor && overTargetAncestor !== this.rootTarget.parent && overTargetAncestor !== e.target;) overTargetAncestor = overTargetAncestor.parent;
            if (!overTargetAncestor || overTargetAncestor === this.rootTarget.parent) {
              const enterEvent = this.clonePointerEvent(e, "pointerenter");
              enterEvent.eventPhase = enterEvent.AT_TARGET;
              let currentTarget = enterEvent.target;
              const outTargetAncestors = new Set();
              let ancestor = outTarget;
              for (; ancestor && ancestor !== this.rootTarget;) outTargetAncestors.add(ancestor), ancestor = ancestor.parent;
              for (; currentTarget && currentTarget !== outTarget && currentTarget !== this.rootTarget.parent;) outTargetAncestors.has(currentTarget) || (enterEvent.currentTarget = currentTarget, this.notifyTarget(enterEvent), isMouse && this.notifyTarget(enterEvent, "mouseenter")), currentTarget = currentTarget.parent;
              this.freeEvent(enterEvent);
            }
            this.freeEvent(overEvent);
          }
          this.dispatchEvent(e, "pointermove"), "touch" === e.pointerType && this.dispatchEvent(e, "touchmove"), isMouse && (this.dispatchEvent(e, "mousemove"), this.cursorTarget = e.target, this.cursor = (null === (_b = null === (_a = e.target) || void 0 === _a ? void 0 : _a.attribute) || void 0 === _b ? void 0 : _b.cursor) || this.rootTarget.getCursor()), trackingData.overTargets = e.composedPath(), this.freeEvent(e);
        }, this.onPointerOver = (from, target) => {
          var _a, _b;
          if (!(from instanceof FederatedPointerEvent)) return void Logger$1.getInstance().warn("EventManager cannot map a non-pointer event as a pointer event");
          const trackingData = this.trackingData(from.pointerId),
            e = this.createPointerEvent(from, from.type, target),
            isMouse = isMouseLike(e.pointerType);
          this.dispatchEvent(e, "pointerover"), isMouse && this.dispatchEvent(e, "mouseover"), "mouse" === e.pointerType && (this.cursorTarget = e.target, this.cursor = (null === (_b = null === (_a = e.target) || void 0 === _a ? void 0 : _a.attribute) || void 0 === _b ? void 0 : _b.cursor) || this.rootTarget.getCursor());
          const enterEvent = this.clonePointerEvent(e, "pointerenter");
          for (enterEvent.eventPhase = enterEvent.AT_TARGET; enterEvent.target && enterEvent.target !== this.rootTarget.parent;) enterEvent.currentTarget = enterEvent.target, this.notifyTarget(enterEvent), isMouse && this.notifyTarget(enterEvent, "mouseenter"), enterEvent.target = enterEvent.target.parent;
          trackingData.overTargets = e.composedPath(), this.freeEvent(e), this.freeEvent(enterEvent);
        }, this.onPointerOut = (from, target) => {
          if (!(from instanceof FederatedPointerEvent)) return void Logger$1.getInstance().warn("EventManager cannot map a non-pointer event as a pointer event");
          const trackingData = this.trackingData(from.pointerId);
          if (trackingData.overTargets) {
            const isMouse = isMouseLike(from.pointerType),
              outTarget = this.findMountedTarget(trackingData.overTargets),
              outEvent = this.createPointerEvent(from, "pointerout", outTarget || void 0);
            this.dispatchEvent(outEvent), isMouse && this.dispatchEvent(outEvent, "mouseout");
            const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget || void 0);
            for (leaveEvent.eventPhase = leaveEvent.AT_TARGET; leaveEvent.target && leaveEvent.target !== this.rootTarget.parent;) leaveEvent.currentTarget = leaveEvent.target, this.notifyTarget(leaveEvent), isMouse && this.notifyTarget(leaveEvent, "mouseleave"), leaveEvent.target = leaveEvent.target.parent;
            trackingData.overTargets = [], this.freeEvent(outEvent), this.freeEvent(leaveEvent);
          }
          this.cursorTarget = null, this.cursor = "";
        }, this.onPointerUp = (from, target) => {
          var _a;
          if (!(from instanceof FederatedPointerEvent)) return void Logger$1.getInstance().warn("EventManager cannot map a non-pointer event as a pointer event");
          const now = clock.now(),
            e = this.createPointerEvent(from, from.type, target);
          if (this.dispatchEvent(e, "pointerup"), "touch" === e.pointerType) this.dispatchEvent(e, "touchend");else if (isMouseLike(e.pointerType)) {
            const isRightButton = 2 === e.button;
            this.dispatchEvent(e, isRightButton ? "rightup" : "mouseup");
          }
          const trackingData = this.trackingData(from.pointerId),
            pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
          let clickTarget = pressTarget;
          if (pressTarget && !e.composedPath().includes(pressTarget)) {
            let currentTarget = pressTarget;
            for (; currentTarget && !e.composedPath().includes(currentTarget);) {
              if (e.currentTarget = currentTarget, this.notifyTarget(e, "pointerupoutside"), "touch" === e.pointerType) this.notifyTarget(e, "touchendoutside");else if (isMouseLike(e.pointerType)) {
                const isRightButton = 2 === e.button;
                this.notifyTarget(e, isRightButton ? "rightupoutside" : "mouseupoutside");
              }
              currentTarget = currentTarget.parent;
            }
            delete trackingData.pressTargetsByButton[from.button], clickTarget = currentTarget;
          }
          if (clickTarget) {
            const clickEvent = this.clonePointerEvent(e, "click");
            clickEvent.target = clickTarget, clickEvent.path = [], clickEvent.detailPath = [], trackingData.clicksByButton[from.button] || (trackingData.clicksByButton[from.button] = {
              clickCount: 0,
              target: clickEvent.target,
              timeStamp: now
            });
            const clickHistory = trackingData.clicksByButton[from.button];
            clickHistory.target === clickEvent.target && now - clickHistory.timeStamp < (null !== (_a = this._config.clickInterval) && void 0 !== _a ? _a : 200) ? ++clickHistory.clickCount : clickHistory.clickCount = 1, clickHistory.target = clickEvent.target, clickHistory.timeStamp = now, clickEvent.detail = clickHistory.clickCount, isMouseLike(clickEvent.pointerType) ? (this.dispatchEvent(clickEvent, "click"), 2 === clickHistory.clickCount && this.dispatchEvent(clickEvent, "dblclick")) : "touch" === clickEvent.pointerType && this._config.supportsTouchEvents && (this.dispatchEvent(clickEvent, "tap"), 2 === clickHistory.clickCount && this.dispatchEvent(clickEvent, "dbltap")), this.dispatchEvent(clickEvent, "pointertap"), this.freeEvent(clickEvent);
          }
          this.freeEvent(e);
        }, this.onPointerUpOutside = (from, target) => {
          if (!(from instanceof FederatedPointerEvent)) return void Logger$1.getInstance().warn("EventManager cannot map a non-pointer event as a pointer event");
          const trackingData = this.trackingData(from.pointerId),
            pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]),
            e = this.createPointerEvent(from, from.type, target);
          if (pressTarget) {
            let currentTarget = pressTarget;
            for (; currentTarget;) e.currentTarget = currentTarget, this.notifyTarget(e, "pointerupoutside"), "touch" === e.pointerType ? this.notifyTarget(e, "touchendoutside") : isMouseLike(e.pointerType) && this.notifyTarget(e, 2 === e.button ? "rightupoutside" : "mouseupoutside"), currentTarget = currentTarget.parent;
            delete trackingData.pressTargetsByButton[from.button];
          }
          this.freeEvent(e);
        }, this.onWheel = (from, target) => {
          if (!(from instanceof FederatedWheelEvent)) return void Logger$1.getInstance().warn("EventManager cannot map a non-wheel event as a wheel event");
          const wheelEvent = this.createWheelEvent(from, target);
          this.dispatchEvent(wheelEvent), this.freeEvent(wheelEvent);
        }, this.rootTarget = root, this.mappingTable = {}, this._config = Object.assign({
          clickInterval: 200
        }, config), this.addEventMapping("pointerdown", this.onPointerDown), this.addEventMapping("pointermove", this.onPointerMove), this.addEventMapping("pointerout", this.onPointerOut), this.addEventMapping("pointerleave", this.onPointerOut), this.addEventMapping("pointerover", this.onPointerOver), this.addEventMapping("pointerup", this.onPointerUp), this.addEventMapping("pointerupoutside", this.onPointerUpOutside), this.addEventMapping("wheel", this.onWheel);
      }
      addEventMapping(type, fn) {
        this.mappingTable[type] || (this.mappingTable[type] = []), this.mappingTable[type].push({
          fn: fn,
          priority: 0
        }), this.mappingTable[type].sort((a, b) => a.priority - b.priority);
      }
      dispatchEvent(e, type) {
        e.propagationStopped = !1, e.propagationImmediatelyStopped = !1, this.propagate(e, type), this.dispatch.emit(type || e.type, e);
      }
      mapEvent(e) {
        var _a, _b, _c, _d, _e, _f, _g;
        if (!this.rootTarget) return;
        const mappers = this.mappingTable[e.type];
        let target;
        const cacheKey = `${e.canvasX}-${e.canvasY}`;
        if ((null === (_a = this._prePointTargetCache) || void 0 === _a ? void 0 : _a[cacheKey]) && (null === (_c = null === (_b = this._prePointTargetCache) || void 0 === _b ? void 0 : _b[cacheKey]) || void 0 === _c ? void 0 : _c.stage) && (null === (_e = null === (_d = this._prePointTargetCache) || void 0 === _d ? void 0 : _d[cacheKey]) || void 0 === _e ? void 0 : _e.stage.renderCount) === (null === (_f = this._prePointTargetCache) || void 0 === _f ? void 0 : _f.stageRenderCount) ? target = this._prePointTargetCache[cacheKey] : (target = this.pickTarget(e.viewX, e.viewY, e), e.pickParams || (this._prePointTargetCache = {
          [cacheKey]: target,
          stageRenderCount: null !== (_g = null == target ? void 0 : target.stage.renderCount) && void 0 !== _g ? _g : -1
        })), mappers) for (let i = 0, j = mappers.length; i < j; i++) mappers[i].fn(e, target);else Logger$1.getInstance().warn(`[EventManager]: Event mapping not defined for ${e.type}`);
      }
      propagate(e, type) {
        if (!e.target) return;
        const composedPath = e.composedPath();
        e.eventPhase = e.CAPTURING_PHASE;
        for (let i = 0, j = composedPath.length - 1; i < j; i++) if (e.currentTarget = composedPath[i], this.notifyTarget(e, type), e.propagationStopped || e.propagationImmediatelyStopped) return;
        if (e.eventPhase = e.AT_TARGET, e.currentTarget = e.target, this.notifyTarget(e, type), !e.propagationStopped && !e.propagationImmediatelyStopped) {
          e.eventPhase = e.BUBBLING_PHASE;
          for (let i = composedPath.length - 2; i >= 0; i--) if (e.currentTarget = composedPath[i], this.notifyTarget(e, type), e.propagationStopped || e.propagationImmediatelyStopped) return;
        }
      }
      propagationPath(target) {
        const propagationPath = [target];
        for (let i = 0; i < 2048 && target !== this.rootTarget && target.parent; i++) {
          if (!target.parent) throw new Error("Cannot find propagation path to disconnected target");
          propagationPath.push(target.parent), target = target.parent;
        }
        return propagationPath.reverse(), propagationPath;
      }
      notifyTarget(e, type) {
        if (this.pauseNotify) return;
        type = null != type ? type : e.type;
        const key = e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET ? `${type}capture` : type;
        this.notifyListeners(e, key), e.eventPhase === e.AT_TARGET && this.notifyListeners(e, type);
      }
      findMountedTarget(propagationPath) {
        if (!propagationPath) return null;
        let currentTarget = propagationPath[0];
        for (let i = 1; i < propagationPath.length && propagationPath[i].parent === currentTarget; i++) currentTarget = propagationPath[i];
        return currentTarget;
      }
      createPointerEvent(from, type, target) {
        var _a, _b;
        const event = this.allocateEvent(FederatedPointerEvent);
        return this.copyPointerData(from, event), this.copyMouseData(from, event), this.copyData(from, event), event.nativeEvent = from.nativeEvent, event.originalEvent = from, event.target = target || this.pickTarget(null !== (_a = event.viewX) && void 0 !== _a ? _a : event.global.x, null !== (_b = event.viewY) && void 0 !== _b ? _b : event.global.y, event), "string" == typeof type && (event.type = type), event;
      }
      createWheelEvent(from, target) {
        var _a, _b;
        const event = this.allocateEvent(FederatedWheelEvent);
        return this.copyWheelData(from, event), this.copyMouseData(from, event), this.copyData(from, event), event.nativeEvent = from.nativeEvent, event.originalEvent = from, event.target = target || this.pickTarget(null !== (_a = event.viewX) && void 0 !== _a ? _a : event.global.x, null !== (_b = event.viewY) && void 0 !== _b ? _b : event.global.y, event), event;
      }
      clonePointerEvent(from, type) {
        const event = this.allocateEvent(FederatedPointerEvent);
        event.nativeEvent = from.nativeEvent, event.originalEvent = from.originalEvent, this.copyPointerData(from, event), this.copyMouseData(from, event), this.copyData(from, event), event.target = from.target, event.path = from.composedPath().slice();
        const p = from.composedDetailPath();
        return event.detailPath = p && p.slice(), event.type = null != type ? type : event.type, event;
      }
      copyWheelData(from, to) {
        to.deltaMode = from.deltaMode, to.deltaX = from.deltaX, to.deltaY = from.deltaY, to.deltaZ = from.deltaZ;
      }
      copyPointerData(from, to) {
        from instanceof FederatedPointerEvent && to instanceof FederatedPointerEvent && (to.pointerId = from.pointerId, to.width = from.width, to.height = from.height, to.isPrimary = from.isPrimary, to.pointerType = from.pointerType, to.pressure = from.pressure, to.tangentialPressure = from.tangentialPressure, to.tiltX = from.tiltX, to.tiltY = from.tiltY, to.twist = from.twist);
      }
      copyMouseData(from, to) {
        from instanceof FederatedMouseEvent && to instanceof FederatedMouseEvent && (to.altKey = from.altKey, to.button = from.button, to.buttons = from.buttons, to.ctrlKey = from.ctrlKey, to.shiftKey = from.shiftKey, to.metaKey = from.metaKey, ["client", "movement", "canvas", "screen", "global", "offset", "viewport"].forEach(key => {
          to[key].x = from[key].x, to[key].y = from[key].y;
        }));
      }
      copyData(from, to) {
        to.isTrusted = from.isTrusted, to.srcElement = from.srcElement, to.timeStamp = clock.now(), to.type = from.type, to.detail = from.detail, to.view = from.view, to.which = from.which, to.layer.x = from.layer.x, to.layer.y = from.layer.y, to.page.x = from.page.x, to.page.y = from.page.y, to.pickParams = from.pickParams;
      }
      trackingData(id) {
        return this.mappingState.trackingData[id] || (this.mappingState.trackingData[id] = {
          pressTargetsByButton: {},
          clicksByButton: {},
          overTarget: null
        }), this.mappingState.trackingData[id];
      }
      allocateEvent(constructor) {
        var _a;
        this.eventPool.has(constructor) || this.eventPool.set(constructor, []);
        const event = (null === (_a = this.eventPool.get(constructor)) || void 0 === _a ? void 0 : _a.pop()) || new constructor(this);
        return event.eventPhase = event.NONE, event.currentTarget = null, event.path = [], event.detailPath = [], event.target = null, event;
      }
      freeEvent(event) {
        var _a;
        if (event.manager !== this) throw new Error("It is illegal to free an event not managed by this EventManager!");
        const constructor = event.constructor;
        this.eventPool.has(constructor) || this.eventPool.set(constructor, []), null === (_a = this.eventPool.get(constructor)) || void 0 === _a || _a.push(event);
      }
      notifyListeners(e, type) {
        const listeners = e.currentTarget._events[type];
        if (listeners) if ("fn" in listeners) listeners.once && e.currentTarget.removeEventListener(type, listeners.fn, {
          once: !0
        }), listeners.fn.call(listeners.context, e);else for (let i = 0, j = listeners.length; i < j && !e.propagationImmediatelyStopped; i++) listeners[i].once && e.currentTarget.removeEventListener(type, listeners[i].fn, {
          once: !0
        }), listeners[i].fn.call(listeners[i].context, e);
        this.emitDelegation(e, type);
      }
      emitDelegation(e, type) {
        const listeners = e.currentTarget._events[WILDCARD];
        if (listeners) if ("fn" in listeners) listeners.fn.call(listeners.context, e, type);else for (let i = 0, j = listeners.length; i < j && !e.propagationImmediatelyStopped; i++) listeners[i].fn.call(listeners[i].context, e, type);
      }
      pickTarget(x, y, e) {
        let target;
        const pickResult = this.rootTarget.pick(x, y);
        return target = pickResult && pickResult.graphic ? pickResult.graphic : pickResult && pickResult.group ? pickResult.group : this.rootTarget.AABBBounds.contains(x, y) ? this.rootTarget : null, e && (e.pickParams = pickResult.params), target;
      }
      release() {
        this.dispatch.removeAllListeners(), this.eventPool.clear(), this.rootTarget = null, this.mappingTable = null, this.mappingState = null, this.cursorTarget = null;
      }
    };

    const EventTarget$2 = {
      dispatchEvent(e) {
        var _a;
        if (!(e instanceof FederatedEvent)) throw new Error("DisplayObject cannot propagate events outside of the Federated Events API");
        return e.defaultPrevented = !1, e.path = [], e.detailPath && (e.detailPath = []), e.target = this, null === (_a = null == e ? void 0 : e.manager) || void 0 === _a || _a.dispatchEvent(e), !e.defaultPrevented;
      },
      emit(eventName, object) {
        return this.dispatchEvent(new CustomEvent(eventName, object));
      }
    };

    const TOUCH_TO_POINTER = {
        touchstart: "pointerdown",
        touchend: "pointerup",
        touchendoutside: "pointerupoutside",
        touchmove: "pointermove",
        touchcancel: "pointercancel"
      };
    class EventSystem {
      constructor(params) {
        this.resolution = 1, this.onPointerDown = nativeEvent => {
          if (this.supportsTouchEvents && "touch" === nativeEvent.pointerType) return;
          const events = this.normalizeToPointerData(nativeEvent);
          if (this.autoPreventDefault && events[0].isNormalized) {
            (nativeEvent.cancelable || !("cancelable" in nativeEvent)) && nativeEvent.preventDefault();
          }
          for (let i = 0, j = events.length; i < j; i++) {
            const nativeEvent = events[i],
              federatedEvent = this.bootstrapEvent(this.rootPointerEvent, nativeEvent);
            this.manager.mapEvent(federatedEvent);
          }
          this.setCursor(this.manager.cursor, this.manager.cursorTarget), this.rootPointerEvent.nativeEvent = null;
        }, this.onPointerMove = nativeEvent => {
          if (this.supportsTouchEvents && "touch" === nativeEvent.pointerType) return;
          if (this.isEventOutsideOfTargetElement(nativeEvent)) return;
          const normalizedEvents = this.normalizeToPointerData(nativeEvent);
          for (let i = 0, j = normalizedEvents.length; i < j; i++) {
            const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);
            this.manager.mapEvent(event);
          }
          this.setCursor(this.manager.cursor, this.manager.cursorTarget), this.rootPointerEvent.nativeEvent = null;
        }, this.onPointerUp = nativeEvent => {
          if (this.supportsTouchEvents && "touch" === nativeEvent.pointerType) return;
          const outside = this.isEventOutsideOfTargetViewPort(nativeEvent) ? "outside" : "",
            normalizedEvents = this.normalizeToPointerData(nativeEvent);
          for (let i = 0, j = normalizedEvents.length; i < j; i++) {
            const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);
            event.type += outside, this.manager.mapEvent(event);
          }
          this.setCursor(this.manager.cursor, this.manager.cursorTarget), this.rootPointerEvent.nativeEvent = null;
        }, this.onPointerOverOut = nativeEvent => {
          if (this.supportsTouchEvents && "touch" === nativeEvent.pointerType) return;
          const normalizedEvents = this.normalizeToPointerData(nativeEvent);
          for (let i = 0, j = normalizedEvents.length; i < j; i++) {
            const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);
            this.manager.mapEvent(event);
          }
          this.setCursor(this.manager.cursor, this.manager.cursorTarget), this.rootPointerEvent.nativeEvent = null;
        }, this.onWheel = nativeEvent => {
          const wheelEvent = this.normalizeWheelEvent(nativeEvent);
          this.manager.mapEvent(wheelEvent);
        };
        const {
          targetElement: targetElement,
          resolution: resolution,
          rootNode: rootNode,
          global: global,
          autoPreventDefault = !1,
          clickInterval: clickInterval,
          supportsTouchEvents = global.supportsTouchEvents,
          supportsPointerEvents = global.supportsPointerEvents
        } = params;
        this.manager = new EventManager$1(rootNode, {
          clickInterval: clickInterval,
          supportsTouchEvents: supportsTouchEvents
        }), this.globalObj = global, this.supportsPointerEvents = supportsPointerEvents, this.supportsTouchEvents = supportsTouchEvents, this.supportsMouseEvents = global.supportsMouseEvents, this.applyStyles = global.applyStyles, this.autoPreventDefault = autoPreventDefault, this.eventsAdded = !1, this.rootPointerEvent = new FederatedPointerEvent(), this.rootWheelEvent = new FederatedWheelEvent(), this.cursorStyles = {
          default: "inherit",
          pointer: "pointer"
        }, this.resolution = resolution, this.setTargetElement(targetElement);
      }
      release() {
        this.removeEvents(), this.manager && this.manager.release(), this.domElement = null, this.manager = null, this.globalObj = null;
      }
      setCursor(mode, target) {
        if (!target && !this.manager.rootTarget.window._handler.canvas.controled) return;
        mode || (mode = "default");
        const {
          applyStyles: applyStyles,
          domElement: domElement
        } = this;
        if (this.currentCursor === mode) return;
        this.currentCursor = mode;
        const style = this.cursorStyles[mode];
        style ? "string" == typeof style && applyStyles ? domElement.style.cursor = style : "function" == typeof style ? style(mode) : "object" == typeof style && applyStyles && Object.assign(domElement.style, style) : applyStyles && isString$6(mode) && !has$1(this.cursorStyles, mode) && (domElement.style.cursor = mode);
      }
      setTargetElement(element) {
        this.removeEvents(), this.domElement = element, this.addEvents();
      }
      addEvents() {
        if (this.eventsAdded || !this.domElement) return;
        const {
          globalObj: globalObj,
          domElement: domElement
        } = this;
        this.supportsPointerEvents ? (globalObj.getDocument() ? (globalObj.addEventListener("pointermove", this.onPointerMove, !0), globalObj.addEventListener("pointerup", this.onPointerUp, !0)) : (domElement.addEventListener("pointermove", this.onPointerMove, !0), domElement.addEventListener("pointerup", this.onPointerUp, !0)), domElement.addEventListener("pointerdown", this.onPointerDown, !0), domElement.addEventListener("pointerleave", this.onPointerOverOut, !0), domElement.addEventListener("pointerover", this.onPointerOverOut, !0)) : (globalObj.getDocument() ? (globalObj.addEventListener("mousemove", this.onPointerMove, !0), globalObj.addEventListener("mouseup", this.onPointerUp, !0)) : (domElement.addEventListener("mousemove", this.onPointerMove, !0), domElement.addEventListener("mouseup", this.onPointerUp, !0)), domElement.addEventListener("mousedown", this.onPointerDown, !0), domElement.addEventListener("mouseout", this.onPointerOverOut, !0), domElement.addEventListener("mouseover", this.onPointerOverOut, !0)), this.supportsTouchEvents && (domElement.addEventListener("touchstart", this.onPointerDown, !0), domElement.addEventListener("touchend", this.onPointerUp, !0), domElement.addEventListener("touchmove", this.onPointerMove, !0)), domElement.addEventListener("wheel", this.onWheel, {
          capture: !0
        }), this.eventsAdded = !0;
      }
      removeEvents() {
        if (!this.eventsAdded || !this.domElement) return;
        const {
          globalObj: globalObj,
          domElement: domElement
        } = this;
        this.supportsPointerEvents ? (globalObj.getDocument() ? (globalObj.removeEventListener("pointermove", this.onPointerMove, !0), globalObj.removeEventListener("pointerup", this.onPointerUp, !0)) : (domElement.removeEventListener("pointermove", this.onPointerMove, !0), domElement.removeEventListener("pointerup", this.onPointerUp, !0)), domElement.removeEventListener("pointerdown", this.onPointerDown, !0), domElement.removeEventListener("pointerleave", this.onPointerOverOut, !0), domElement.removeEventListener("pointerover", this.onPointerOverOut, !0)) : (globalObj.getDocument() ? (globalObj.removeEventListener("mousemove", this.onPointerMove, !0), globalObj.removeEventListener("mouseup", this.onPointerUp, !0)) : (domElement.removeEventListener("mousemove", this.onPointerMove, !0), domElement.removeEventListener("mouseup", this.onPointerUp, !0)), domElement.removeEventListener("mousedown", this.onPointerDown, !0), domElement.removeEventListener("mouseout", this.onPointerOverOut, !0), domElement.removeEventListener("mouseover", this.onPointerOverOut, !0)), this.supportsTouchEvents && (domElement.removeEventListener("touchstart", this.onPointerDown, !0), domElement.removeEventListener("touchend", this.onPointerUp, !0), domElement.removeEventListener("touchmove", this.onPointerMove, !0)), domElement.removeEventListener("wheel", this.onWheel, !0), this.domElement = null, this.eventsAdded = !1;
      }
      mapToViewportPoint(event) {
        return this.domElement.pointTransform ? this.domElement.pointTransform(event.x, event.y) : event;
      }
      mapToCanvasPoint(nativeEvent) {
        var _a, _b;
        const point = null === (_a = this.globalObj) || void 0 === _a ? void 0 : _a.mapToCanvasPoint(nativeEvent, this.domElement);
        if (point) return point;
        let x = 0,
          y = 0;
        if (nativeEvent.changedTouches) {
          const data = null !== (_b = nativeEvent.changedTouches[0]) && void 0 !== _b ? _b : {};
          x = data.clientX || 0, y = data.clientY || 0;
        } else x = nativeEvent.clientX || 0, y = nativeEvent.clientY || 0;
        const rect = this.domElement.getBoundingClientRect();
        return {
          x: x - rect.left,
          y: y - rect.top
        };
      }
      normalizeToPointerData(event) {
        const normalizedEvents = [];
        if (this.supportsTouchEvents && event.changedTouches && event.changedTouches.length) for (let i = 0, li = event.changedTouches.length; i < li; i++) {
          const touch = event.changedTouches[i];
          isUndefined$1(touch.button) && (touch.button = 0), isUndefined$1(touch.buttons) && (touch.buttons = 1), isUndefined$1(touch.isPrimary) && (touch.isPrimary = 1 === event.touches.length && "touchstart" === event.type), isUndefined$1(touch.width) && (touch.width = touch.radiusX || 1), isUndefined$1(touch.height) && (touch.height = touch.radiusY || 1), isUndefined$1(touch.tiltX) && (touch.tiltX = 0), isUndefined$1(touch.tiltY) && (touch.tiltY = 0), isUndefined$1(touch.pointerType) && (touch.pointerType = "touch"), isUndefined$1(touch.pointerId) && (touch.pointerId = touch.identifier || 0), isUndefined$1(touch.pressure) && (touch.pressure = touch.force || .5), isUndefined$1(touch.twist) && (touch.twist = 0), isUndefined$1(touch.tangentialPressure) && (touch.tangentialPressure = 0), isUndefined$1(touch.layerX) && (touch.layerX = touch.offsetX = touch.clientX), isUndefined$1(touch.layerY) && (touch.layerY = touch.offsetY = touch.clientY), touch.isNormalized = !0, touch.type = event.type, normalizedEvents.push(touch);
        } else if (this.globalObj.supportsMouseEvents && (!(event instanceof MouseEvent) || this.supportsPointerEvents && event instanceof PointerEvent)) normalizedEvents.push(event);else {
          const tempEvent = event;
          isUndefined$1(tempEvent.isPrimary) && (tempEvent.isPrimary = !0), isUndefined$1(tempEvent.width) && (tempEvent.width = 1), isUndefined$1(tempEvent.height) && (tempEvent.height = 1), isUndefined$1(tempEvent.tiltX) && (tempEvent.tiltX = 0), isUndefined$1(tempEvent.tiltY) && (tempEvent.tiltY = 0), isUndefined$1(tempEvent.pointerType) && (tempEvent.pointerType = "mouse"), isUndefined$1(tempEvent.pointerId) && (tempEvent.pointerId = 1), isUndefined$1(tempEvent.pressure) && (tempEvent.pressure = .5), isUndefined$1(tempEvent.twist) && (tempEvent.twist = 0), isUndefined$1(tempEvent.tangentialPressure) && (tempEvent.tangentialPressure = 0), tempEvent.isNormalized = !0, normalizedEvents.push(tempEvent);
        }
        return normalizedEvents;
      }
      normalizeWheelEvent(nativeEvent) {
        const event = this.rootWheelEvent;
        this.transferMouseData(event, nativeEvent), event.deltaMode = nativeEvent.deltaMode, event.deltaX = nativeEvent.deltaX, event.deltaY = nativeEvent.deltaY, event.deltaZ = nativeEvent.deltaZ;
        const {
          x: canvasX,
          y: canvasY
        } = this.mapToCanvasPoint(nativeEvent);
        event.canvas.x = canvasX, event.canvas.y = canvasY, event.global.x = canvasX, event.global.y = canvasY, event.offset.x = canvasX, event.offset.y = canvasY;
        const {
          x: viewX,
          y: viewY
        } = this.mapToViewportPoint(event);
        return event.viewport.x = viewX, event.viewport.y = viewY, event.nativeEvent = nativeEvent, event.type = nativeEvent.type, event;
      }
      bootstrapEvent(event, nativeEvent) {
        event.originalEvent = null, event.nativeEvent = nativeEvent, event.pointerId = nativeEvent.pointerId, event.width = nativeEvent.width, event.height = nativeEvent.height, event.isPrimary = nativeEvent.isPrimary, event.pointerType = nativeEvent.pointerType, event.pressure = nativeEvent.pressure, event.tangentialPressure = nativeEvent.tangentialPressure, event.tiltX = nativeEvent.tiltX, event.tiltY = nativeEvent.tiltY, event.twist = nativeEvent.twist, this.transferMouseData(event, nativeEvent);
        const {
          x: canvasX,
          y: canvasY
        } = this.mapToCanvasPoint(nativeEvent);
        event.canvas.x = canvasX, event.canvas.y = canvasY, event.global.x = canvasX, event.global.y = canvasY, event.offset.x = canvasX, event.offset.y = canvasY;
        const {
          x: viewX,
          y: viewY
        } = this.mapToViewportPoint(event);
        return event.viewport.x = viewX, event.viewport.y = viewY, event.isTrusted = nativeEvent.isTrusted, "pointerleave" === event.type && (event.type = "pointerout"), event.type.startsWith("mouse") && (event.type = event.type.replace("mouse", "pointer")), event.type.startsWith("touch") && (event.type = TOUCH_TO_POINTER[event.type] || event.type), event;
      }
      transferMouseData(event, nativeEvent) {
        event.isTrusted = nativeEvent.isTrusted, event.srcElement = nativeEvent.srcElement, event.timeStamp = clock.now(), event.type = nativeEvent.type, event.altKey = nativeEvent.altKey, event.button = nativeEvent.button, event.buttons = nativeEvent.buttons, event.client.x = nativeEvent.clientX, event.client.y = nativeEvent.clientY, event.ctrlKey = nativeEvent.ctrlKey, event.shiftKey = nativeEvent.shiftKey, event.metaKey = nativeEvent.metaKey, event.movement.x = nativeEvent.movementX, event.movement.y = nativeEvent.movementY, event.page.x = nativeEvent.pageX, event.page.y = nativeEvent.pageY, event.relatedTarget = null;
      }
      isEventOutsideOfTargetViewPort(nativeEvent) {
        if (this.isEventOutsideOfTargetElement(nativeEvent)) return !0;
        if (this.domElement.getViewBox) {
          const p = this.mapToViewportPoint(this.mapToCanvasPoint(nativeEvent)),
            b = this.domElement.getViewBox(),
            w = b.width(),
            h = b.height();
          return !(p.x < w && p.y < h && p.x > 0 && p.y > 0);
        }
        return !1;
      }
      isEventOutsideOfTargetElement(nativeEvent) {
        let target = nativeEvent.target;
        nativeEvent.composedPath && nativeEvent.composedPath().length > 0 && (target = nativeEvent.composedPath()[0]);
        return target !== (this.domElement.getNativeHandler ? this.domElement.getNativeHandler().nativeCanvas : this.domElement);
      }
      pauseTriggerEvent() {
        this.manager.pauseNotify = !0;
      }
      resumeTriggerEvent() {
        this.manager.pauseNotify = !1;
      }
    }

    var STATUS$1;
    !function (STATUS) {
      STATUS[STATUS.INITIAL = 0] = "INITIAL", STATUS[STATUS.RUNNING = 1] = "RUNNING", STATUS[STATUS.PAUSE = 2] = "PAUSE";
    }(STATUS$1 || (STATUS$1 = {}));

    class RAFTickHandler {
      static Avaliable() {
        return !!application.global.getRequestAnimationFrame();
      }
      avaliable() {
        return RAFTickHandler.Avaliable();
      }
      tick(interval, cb) {
        application.global.getRequestAnimationFrame()(() => {
          this.released || cb(this);
        });
      }
      release() {
        this.released = !0;
      }
      getTime() {
        return Date.now();
      }
    }

    class TimeOutTickHandler {
      static Avaliable() {
        return !0;
      }
      avaliable() {
        return TimeOutTickHandler.Avaliable();
      }
      tick(interval, cb) {
        this.timerId = setTimeout(() => {
          cb(this);
        }, interval);
      }
      release() {
        this.timerId > 0 && (clearTimeout(this.timerId), this.timerId = -1);
      }
      getTime() {
        return Date.now();
      }
    }

    class DefaultTicker extends EventEmitter {
      set mode(m) {
        this._mode !== m && (this._mode = m, this.setupTickHandler());
      }
      get mode() {
        return this._mode;
      }
      constructor() {
        let timelines = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        super(), this.handleTick = (handler, params) => {
          const {
            once = !1
          } = null != params ? params : {};
          this.ifCanStop() ? this.stop() : (this._handlerTick(), once || handler.tick(this.interval, this.handleTick));
        }, this._handlerTick = () => {
          const time = this.tickerHandler.getTime();
          let delta = 0;
          this.lastFrameTime >= 0 && (delta = time - this.lastFrameTime), this.lastFrameTime = time, this.status === STATUS$1.RUNNING && (this.tickCounts++, this.timelines.forEach(t => {
            t.tick(delta);
          }), this.emit("tick"));
        }, this.init(), this.lastFrameTime = -1, this.tickCounts = 0, this.timelines = timelines, this.autoStop = !0;
      }
      init() {
        this.interval = NaN, this.status = STATUS$1.INITIAL, application.global.hooks.onSetEnv.tap("default-ticker", () => {
          this.initHandler();
        }), application.global.env && this.initHandler();
      }
      addTimeline(timeline) {
        this.timelines.push(timeline);
      }
      remTimeline(timeline) {
        this.timelines = this.timelines.filter(t => t !== timeline);
      }
      getTimelines() {
        return this.timelines;
      }
      initHandler() {
        if (this._mode) return null;
        const ticks = [{
          mode: "raf",
          cons: RAFTickHandler
        }, {
          mode: "timeout",
          cons: TimeOutTickHandler
        }];
        for (let i = 0; i < ticks.length; i++) if (ticks[i].cons.Avaliable()) {
          this.mode = ticks[i].mode;
          break;
        }
        return null;
      }
      setupTickHandler() {
        let handler;
        switch (this._mode) {
          case "raf":
            handler = new RAFTickHandler();
            break;
          case "timeout":
            handler = new TimeOutTickHandler();
            break;
          default:
            Logger$1.getInstance().warn("非法的计时器模式"), handler = new RAFTickHandler();
        }
        return !!handler.avaliable() && (this.tickerHandler && this.tickerHandler.release(), this.tickerHandler = handler, !0);
      }
      setInterval(interval) {
        this.interval = interval;
      }
      getInterval() {
        return this.interval;
      }
      setFPS(fps) {
        this.setInterval(1e3 / fps);
      }
      getFPS() {
        return 1e3 / this.interval;
      }
      tick(interval) {
        this.tickerHandler.tick(interval, handler => {
          this.handleTick(handler, {
            once: !0
          });
        });
      }
      tickTo(t) {
        this.tickerHandler.tickTo && this.tickerHandler.tickTo(t, handler => {
          this.handleTick(handler, {
            once: !0
          });
        });
      }
      pause() {
        return this.status !== STATUS$1.INITIAL && (this.status = STATUS$1.PAUSE, !0);
      }
      resume() {
        return this.status !== STATUS$1.INITIAL && (this.status = STATUS$1.RUNNING, !0);
      }
      ifCanStop() {
        if (this.autoStop) {
          if (!this.timelines.length) return !0;
          if (0 === this.timelines.reduce((a, b) => a + b.animateCount, 0)) return !0;
        }
        return !1;
      }
      start() {
        let force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !1;
        if (this.status === STATUS$1.RUNNING) return !1;
        if (!this.tickerHandler) return !1;
        if (!force) {
          if (this.status === STATUS$1.PAUSE) return !1;
          if (!this.timelines.length) return !1;
          if (0 === this.timelines.reduce((a, b) => a + b.animateCount, 0)) return !1;
        }
        return this.status = STATUS$1.RUNNING, this.tickerHandler.tick(0, this.handleTick), !0;
      }
      stop() {
        this.status = STATUS$1.INITIAL, this.setupTickHandler(), this.lastFrameTime = -1;
      }
      release() {
        this.stop(), this.timelines = [], this.tickerHandler.release(), this.emit("afterTick");
      }
      trySyncTickStatus() {
        this.status === STATUS$1.RUNNING && this._handlerTick();
      }
    }

    class Easing {
      constructor() {}
      static linear(t) {
        return t;
      }
      static none() {
        return this.linear;
      }
      static get(amount) {
        return amount < -1 ? amount = -1 : amount > 1 && (amount = 1), function (t) {
          return 0 === amount ? t : amount < 0 ? t * (t * -amount + 1 + amount) : t * ((2 - t) * amount + (1 - amount));
        };
      }
      static getPowIn(pow) {
        return function (t) {
          return Math.pow(t, pow);
        };
      }
      static getPowOut(pow) {
        return function (t) {
          return 1 - Math.pow(1 - t, pow);
        };
      }
      static getPowInOut(pow) {
        return function (t) {
          return (t *= 2) < 1 ? .5 * Math.pow(t, pow) : 1 - .5 * Math.abs(Math.pow(2 - t, pow));
        };
      }
      static getBackIn(amount) {
        return function (t) {
          return t * t * ((amount + 1) * t - amount);
        };
      }
      static getBackOut(amount) {
        return function (t) {
          return --t * t * ((amount + 1) * t + amount) + 1;
        };
      }
      static getBackInOut(amount) {
        return amount *= 1.525, function (t) {
          return (t *= 2) < 1 ? t * t * ((amount + 1) * t - amount) * .5 : .5 * ((t -= 2) * t * ((amount + 1) * t + amount) + 2);
        };
      }
      static sineIn(t) {
        return 1 - Math.cos(t * Math.PI / 2);
      }
      static sineOut(t) {
        return Math.sin(t * Math.PI / 2);
      }
      static sineInOut(t) {
        return -(Math.cos(Math.PI * t) - 1) / 2;
      }
      static expoIn(t) {
        return 0 === t ? 0 : Math.pow(2, 10 * t - 10);
      }
      static expoOut(t) {
        return 1 === t ? 1 : 1 - Math.pow(2, -10 * t);
      }
      static expoInOut(t) {
        return 0 === t ? 0 : 1 === t ? 1 : t < .5 ? Math.pow(2, 20 * t - 10) / 2 : (2 - Math.pow(2, -20 * t + 10)) / 2;
      }
      static circIn(t) {
        return -(Math.sqrt(1 - t * t) - 1);
      }
      static circOut(t) {
        return Math.sqrt(1 - --t * t);
      }
      static circInOut(t) {
        return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
      }
      static bounceOut(t) {
        return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
      }
      static bounceIn(t) {
        return 1 - Easing.bounceOut(1 - t);
      }
      static bounceInOut(t) {
        return t < .5 ? .5 * Easing.bounceIn(2 * t) : .5 * Easing.bounceOut(2 * t - 1) + .5;
      }
      static getElasticIn(amplitude, period) {
        return function (t) {
          if (0 === t || 1 === t) return t;
          const s = period / pi2 * Math.asin(1 / amplitude);
          return -amplitude * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * pi2 / period);
        };
      }
      static getElasticOut(amplitude, period) {
        return function (t) {
          if (0 === t || 1 === t) return t;
          const s = period / pi2 * Math.asin(1 / amplitude);
          return amplitude * Math.pow(2, -10 * t) * Math.sin((t - s) * pi2 / period) + 1;
        };
      }
      static getElasticInOut(amplitude, period) {
        return function (t) {
          const s = period / pi2 * Math.asin(1 / amplitude);
          return (t *= 2) < 1 ? amplitude * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * pi2 / period) * -.5 : amplitude * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - s) * pi2 / period) * .5 + 1;
        };
      }
      static registerFunc(name, func) {
        Easing[name] = func;
      }
    }
    function flicker(t, n) {
      const step = 1 / n;
      let flag = 1;
      for (; t > step;) t -= step, flag *= -1;
      const v = flag * t / step;
      return v > 0 ? v : 1 + v;
    }
    Easing.quadIn = Easing.getPowIn(2), Easing.quadOut = Easing.getPowOut(2), Easing.quadInOut = Easing.getPowInOut(2), Easing.cubicIn = Easing.getPowIn(3), Easing.cubicOut = Easing.getPowOut(3), Easing.cubicInOut = Easing.getPowInOut(3), Easing.quartIn = Easing.getPowIn(4), Easing.quartOut = Easing.getPowOut(4), Easing.quartInOut = Easing.getPowInOut(4), Easing.quintIn = Easing.getPowIn(5), Easing.quintOut = Easing.getPowOut(5), Easing.quintInOut = Easing.getPowInOut(5), Easing.backIn = Easing.getBackIn(1.7), Easing.backOut = Easing.getBackOut(1.7), Easing.backInOut = Easing.getBackInOut(1.7), Easing.elasticIn = Easing.getElasticIn(1, .3), Easing.elasticOut = Easing.getElasticOut(1, .3), Easing.elasticInOut = Easing.getElasticInOut(1, .3 * 1.5), Easing.easeInOutQuad = t => (t /= .5) < 1 ? .5 * Math.pow(t, 2) : -.5 * ((t -= 2) * t - 2), Easing.easeOutElastic = x => {
      const c4 = 2 * Math.PI / 3;
      return 0 === x ? 0 : 1 === x ? 1 : Math.pow(2, -10 * x) * Math.sin((10 * x - .75) * c4) + 1;
    }, Easing.easeInOutElastic = x => {
      const c5 = 2 * Math.PI / 4.5;
      return 0 === x ? 0 : 1 === x ? 1 : x < .5 ? -Math.pow(2, 20 * x - 10) * Math.sin((20 * x - 11.125) * c5) / 2 : Math.pow(2, -20 * x + 10) * Math.sin((20 * x - 11.125) * c5) / 2 + 1;
    };
    for (let i = 0; i < 10; i++) Easing[`flicker${i}`] = t => flicker(t, i);
    for (let i = 2; i < 10; i++) Easing[`aIn${i}`] = t => i * t * t + (1 - i) * t;

    class DefaultTimeline {
      constructor() {
        this.id = Generator.GenAutoIncrementId(), this.animateHead = null, this.animateTail = null, this.animateCount = 0, this.paused = !1;
      }
      addAnimate(animate) {
        this.animateTail ? (this.animateTail.nextAnimate = animate, animate.prevAnimate = this.animateTail, this.animateTail = animate, animate.nextAnimate = null) : (this.animateHead = animate, this.animateTail = animate), this.animateCount++;
      }
      pause() {
        this.paused = !0;
      }
      resume() {
        this.paused = !1;
      }
      tick(delta) {
        if (this.paused) return;
        let animate = this.animateHead;
        for (this.animateCount = 0; animate;) animate.status === AnimateStatus.END ? this.removeAnimate(animate) : animate.status === AnimateStatus.RUNNING || animate.status === AnimateStatus.INITIAL ? (this.animateCount++, animate.advance(delta)) : animate.status === AnimateStatus.PAUSED && this.animateCount++, animate = animate.nextAnimate;
      }
      clear() {
        let animate = this.animateHead;
        for (; animate;) animate.release(), animate = animate.nextAnimate;
        this.animateHead = null, this.animateTail = null, this.animateCount = 0;
      }
      removeAnimate(animate) {
        let release = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
        animate._onRemove && animate._onRemove.forEach(cb => cb()), animate === this.animateHead ? (this.animateHead = animate.nextAnimate, animate === this.animateTail ? this.animateTail = null : this.animateHead.prevAnimate = null) : animate === this.animateTail ? (this.animateTail = animate.prevAnimate, this.animateTail.nextAnimate = null) : (animate.prevAnimate.nextAnimate = animate.nextAnimate, animate.nextAnimate.prevAnimate = animate.prevAnimate), release && animate.release();
      }
    }
    const defaultTimeline = new DefaultTimeline();

    class ACustomAnimate {
      constructor(from, to, duration, easing, params) {
        this.from = from, this.to = to, this.duration = duration, this.easing = easing, this.params = params, this.updateCount = 0;
      }
      bind(target, subAni) {
        this.target = target, this.subAnimate = subAni, this.onBind();
      }
      onBind() {}
      onFirstRun() {}
      onStart() {}
      onEnd() {}
      getEndProps() {
        return this.to;
      }
      getFromProps() {
        return this.from;
      }
      getMergedEndProps() {
        var _a;
        const thisEndProps = this.getEndProps();
        return thisEndProps ? this._endProps === thisEndProps ? this._mergedEndProps : (this._endProps = thisEndProps, void (this._mergedEndProps = Object.assign({}, null !== (_a = this.step.prev.getLastProps()) && void 0 !== _a ? _a : {}, thisEndProps))) : this.step.prev ? this.step.prev.getLastProps() : thisEndProps;
      }
      update(end, ratio, out) {
        if (0 === this.updateCount) {
          this.onFirstRun();
          const props = this.step.getLastProps();
          Object.keys(props).forEach(k => {
            this.subAnimate.animate.validAttr(k) && (out[k] = props[k]);
          });
        }
        this.updateCount += 1, this.onUpdate(end, ratio, out), end && this.onEnd();
      }
    }
    class CbAnimate extends ACustomAnimate {
      constructor(cb) {
        super(null, null, 0, "linear"), this.cb = cb;
      }
      onUpdate(end, ratio, out) {}
      onStart() {
        this.cb();
      }
    }
    class Animate {
      constructor() {
        let id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Generator.GenAutoIncrementId();
        let timeline = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultTimeline;
        let slience = arguments.length > 2 ? arguments[2] : undefined;
        this.id = id, this.timeline = timeline || defaultTimeline, this.status = AnimateStatus.INITIAL, this.tailAnimate = new SubAnimate(this), this.subAnimates = [this.tailAnimate], this.timeScale = 1, this.rawPosition = -1, this._startTime = 0, this._duringTime = 0, this.timeline.addAnimate(this), this.slience = slience;
      }
      setTimeline(timeline) {
        timeline !== this.timeline && (this.timeline.removeAnimate(this, !1), timeline.addAnimate(this));
      }
      getStartTime() {
        return this._startTime;
      }
      getDuration() {
        return this.subAnimates.reduce((t, subAnimate) => t + subAnimate.totalDuration, 0);
      }
      after(animate) {
        const t = animate.getDuration();
        return this._startTime = t, this;
      }
      afterAll(list) {
        let maxT = -1 / 0;
        return list.forEach(a => {
          maxT = max(a.getDuration(), maxT);
        }), this._startTime = maxT, this;
      }
      parallel(animate) {
        return this._startTime = animate.getStartTime(), this;
      }
      static AddInterpolate(name, cb) {
        Animate.interpolateMap.set(name, cb);
      }
      play(customAnimate) {
        if (this.tailAnimate.play(customAnimate), this.target) {
          const stage = this.target.stage;
          stage && stage.renderNextFrame();
        }
        return 1 === this.subAnimates.length && this.tailAnimate.totalDuration === customAnimate.duration && this.trySetAttribute(customAnimate.getFromProps(), customAnimate.mode), this;
      }
      trySetAttribute(attr) {
        let mode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Animate.mode;
        attr && mode & AnimateMode.SET_ATTR_IMMEDIATELY && this.target.setAttributes && this.target.setAttributes(attr, !1, {
          type: AttributeUpdateType.ANIMATE_PLAY
        });
      }
      runCb(cb) {
        const customAnimate = new CbAnimate(() => {
          cb(this, customAnimate.step.prev);
        });
        return this.tailAnimate.play(customAnimate), this;
      }
      customInterpolate(key, ratio, from, to, target, ret) {
        const func = Animate.interpolateMap.get(key) || Animate.interpolateMap.get("");
        return !!func && func(key, ratio, from, to, target, ret);
      }
      pause() {
        this.status === AnimateStatus.RUNNING && (this.status = AnimateStatus.PAUSED);
      }
      resume() {
        this.status === AnimateStatus.PAUSED && (this.status = AnimateStatus.RUNNING);
      }
      to(props, duration, easing, params) {
        if (this.tailAnimate.to(props, duration, easing, params), this.target) {
          const stage = this.target.stage;
          stage && stage.renderNextFrame();
        }
        return this;
      }
      from(props, duration, easing, params) {
        if (this.tailAnimate.from(props, duration, easing, params), this.target) {
          const stage = this.target.stage;
          stage && stage.renderNextFrame();
        }
        return this;
      }
      wait(duration) {
        if (this.tailAnimate.wait(duration), this.target) {
          const stage = this.target.stage;
          stage && stage.renderNextFrame();
        }
        return this;
      }
      startAt(t) {
        if (this.tailAnimate.startAt(t), this.target) {
          const stage = this.target.stage;
          stage && stage.renderNextFrame();
        }
        return this;
      }
      loop(l) {
        if (this.tailAnimate.loop = l, this.target) {
          const stage = this.target.stage;
          stage && stage.renderNextFrame();
        }
        return this;
      }
      reversed(r) {
        if (this.tailAnimate.reversed = r, this.target) {
          const stage = this.target.stage;
          stage && stage.renderNextFrame();
        }
        return this;
      }
      bounce(b) {
        if (this.tailAnimate.bounce = b, this.target) {
          const stage = this.target.stage;
          stage && stage.renderNextFrame();
        }
        return this;
      }
      subAnimate() {
        const sa = new SubAnimate(this, this.tailAnimate);
        return this.tailAnimate = sa, this.subAnimates.push(sa), sa.bind(this.target), this;
      }
      getStartProps() {
        return this.subAnimates[0].getStartProps();
      }
      getEndProps() {
        return this.tailAnimate.getEndProps();
      }
      depreventAttr(key) {
        this._preventAttrs && this._preventAttrs.delete(key);
      }
      preventAttr(key) {
        this._preventAttrs || (this._preventAttrs = new Set()), this._preventAttrs.add(key);
      }
      preventAttrs(keys) {
        keys.forEach(key => this.preventAttr(key));
      }
      validAttr(key) {
        return !this._preventAttrs || !this._preventAttrs.has(key);
      }
      bind(target) {
        return this.target = target, this.target.onAnimateBind && !this.slience && this.target.onAnimateBind(this), this.subAnimates.forEach(sa => {
          sa.bind(target);
        }), this;
      }
      advance(delta) {
        if (this._duringTime < this._startTime) {
          if (this._duringTime + delta * this.timeScale < this._startTime) return void (this._duringTime += delta * this.timeScale);
          delta = this._duringTime + delta * this.timeScale - this._startTime, this._duringTime = this._startTime;
        }
        this.status === AnimateStatus.INITIAL && (this.status = AnimateStatus.RUNNING, this._onStart && this._onStart.forEach(cb => cb()));
        this.setPosition(Math.max(this.rawPosition, 0) + delta * this.timeScale) && this.status === AnimateStatus.RUNNING && (this.status = AnimateStatus.END, this._onEnd && this._onEnd.forEach(cb => cb()));
      }
      setPosition(rawPosition) {
        let sa,
          d = 0;
        const prevRawPos = this.rawPosition,
          maxRawPos = this.subAnimates.reduce((a, b) => a + b.totalDuration, 0);
        rawPosition < 0 && (rawPosition = 0);
        const end = rawPosition >= maxRawPos;
        if (end && (rawPosition = maxRawPos), rawPosition === prevRawPos) return end;
        for (let i = 0; i < this.subAnimates.length && (sa = this.subAnimates[i], !(d + sa.totalDuration >= rawPosition)); i++) d += sa.totalDuration, sa = void 0;
        return this.rawPosition = rawPosition, sa.setPosition(rawPosition - d), end;
      }
      onStart(cb) {
        this._onStart || (this._onStart = []), this._onStart.push(cb);
      }
      onEnd(cb) {
        this._onEnd || (this._onEnd = []), this._onEnd.push(cb);
      }
      onRemove(cb) {
        this._onRemove || (this._onRemove = []), this._onRemove.push(cb);
      }
      onFrame(cb) {
        this._onFrame || (this._onFrame = []), this._onFrame.push(cb);
      }
      release() {
        this.status = AnimateStatus.END;
      }
      stop(nextVal) {
        nextVal || this.target.onStop(), "start" === nextVal ? this.target.onStop(this.getStartProps()) : "end" === nextVal ? this.target.onStop(this.getEndProps()) : this.target.onStop(nextVal), this.release();
      }
    }
    Animate.mode = AnimateMode.NORMAL, Animate.interpolateMap = new Map();
    class SubAnimate {
      get totalDuration() {
        return this.calcAttr(), this._totalDuration + this._startAt;
      }
      constructor(animate, lastSubAnimate) {
        this.rawPosition = -1, this.position = 0, this.loop = 0, this.duration = 0, this.animate = animate, this.stepHead = new Step(0, 0, lastSubAnimate ? Object.assign({}, lastSubAnimate.stepTail.props) : {}), this.stepTail = this.stepHead, this.dirty = !0, this._startAt = 0;
      }
      calcAttr() {
        this.dirty && (this._totalDuration = this.duration * (this.loop + 1));
      }
      bind(target) {
        return this.target = target, this;
      }
      play(customAnimate) {
        let duration = customAnimate.duration;
        (null == duration || duration < 0) && (duration = 0);
        const easing = customAnimate.easing,
          easingFunc = "string" == typeof easing ? Easing[easing] : easing,
          step = this._addStep(duration, null, easingFunc);
        return step.type = AnimateStepType.customAnimate, this._appendProps(customAnimate.getEndProps(), step, !1), this._appendCustomAnimate(customAnimate, step), this;
      }
      to(props, duration, easing, params) {
        (null == duration || duration < 0) && (duration = 0);
        const easingFunc = "string" == typeof easing ? Easing[easing] : easing,
          step = this._addStep(duration, null, easingFunc);
        return step.type = AnimateStepType.to, this._appendProps(props, step, !!params && params.tempProps), step.propKeys || (step.propKeys = Object.keys(step.props)), params && params.noPreventAttrs || this.target.animates && this.target.animates.forEach(a => {
          a.id !== this.animate.id && a.preventAttrs(step.propKeys);
        }), this;
      }
      from(props, duration, easing, params) {
        this.to(props, 0, easing, params);
        const toProps = {};
        this.stepTail.propKeys || (this.stepTail.propKeys = Object.keys(this.stepTail.props)), this.stepTail.propKeys.forEach(k => {
          toProps[k] = this.getLastPropByName(k, this.stepTail);
        }), this.to(toProps, duration, easing, params), this.stepTail.type = AnimateStepType.from;
      }
      startAt(t) {
        return t < 0 && (t = 0), this._startAt = t, this;
      }
      getStartProps() {
        var _a;
        return null === (_a = this.stepHead) || void 0 === _a ? void 0 : _a.props;
      }
      getEndProps() {
        return this.stepTail.props;
      }
      getLastStep() {
        return this._lastStep;
      }
      wait(duration) {
        if (duration > 0) {
          const step = this._addStep(+duration, null);
          step.type = AnimateStepType.wait, step.prev.customAnimate ? step.props = step.prev.customAnimate.getEndProps() : step.props = step.prev.props, this.target.onAddStep && this.target.onAddStep(step);
        }
        return this;
      }
      _addStep(duration, props, easingFunc) {
        const step = new Step(this.duration, duration, props, easingFunc);
        return this.duration += duration, this.stepTail.append(step), this.stepTail = step, step;
      }
      _appendProps(props, step, tempProps) {
        step.props = tempProps ? props : Object.assign({}, props);
        let lastStep = step.prev;
        const _props = step.props;
        for (step.propKeys || (step.propKeys = Object.keys(step.props)), step.propKeys.forEach(k => {
          void 0 === step.props[k] && (step.props[k] = this.target.getDefaultAttribute(k));
        }); lastStep.prev;) lastStep.props && (lastStep.propKeys || (lastStep.propKeys = Object.keys(lastStep.props)), lastStep.propKeys.forEach(key => {
          void 0 === _props[key] && (_props[key] = lastStep.props[key]);
        })), step.propKeys = Object.keys(step.props), lastStep = lastStep.prev;
        const initProps = this.stepHead.props;
        step.propKeys || (step.propKeys = Object.keys(_props)), step.propKeys.forEach(key => {
          if (void 0 === initProps[key]) {
            const parentAnimateInitProps = this.animate.getStartProps();
            initProps[key] = parentAnimateInitProps[key] = this.target.getComputedAttribute(key);
          }
        }), this.target.onAddStep && this.target.onAddStep(step);
      }
      _appendCustomAnimate(customAnimate, step) {
        step.customAnimate = customAnimate, customAnimate.step = step, customAnimate.bind(this.target, this);
      }
      setPosition(rawPosition) {
        var _a;
        const d = this.duration,
          loopCount = this.loop,
          prevRawPos = this.rawPosition;
        let loop,
          position,
          end = !1;
        const startAt = null !== (_a = this._startAt) && void 0 !== _a ? _a : 0;
        if (rawPosition < 0 && (rawPosition = 0), rawPosition < startAt) return this.rawPosition = rawPosition, !1;
        if (rawPosition -= startAt, d <= 0 && (end = !0, d < 0)) return end;
        if (loop = Math.floor(rawPosition / d), position = rawPosition - loop * d, end = rawPosition >= loopCount * d + d, end && (position = d, loop = loopCount, rawPosition = position * loop + d), rawPosition === prevRawPos) return end;
        const rev = !this.reversed != !(this.bounce && loop % 2);
        return rev && (position = d - position), this._deltaPosition = position - this.position, this.position = position, this.rawPosition = rawPosition + startAt, this.updatePosition(end, rev), end;
      }
      updatePosition(end, rev) {
        if (!this.stepHead) return;
        let step = this.stepHead.next;
        const position = this.position,
          duration = this.duration;
        if (this.target && step) {
          let stepNext = step.next;
          for (; stepNext && stepNext.position <= position;) step = stepNext, stepNext = step.next;
          let ratio = end ? 0 === duration ? 1 : position / duration : (position - step.position) / step.duration;
          step.easing && (ratio = step.easing(ratio)), this.tryCallCustomAnimateLifeCycle(step, this._lastStep || (rev ? this.stepTail : this.stepHead), rev), this.updateTarget(step, ratio, end), this._lastStep = step, this.animate._onFrame && this.animate._onFrame.forEach(cb => cb(step, ratio));
        }
      }
      tryCallCustomAnimateLifeCycle(step, lastStep, rev) {
        if (step !== lastStep) if (rev) {
          let _step = lastStep.prev;
          for (; _step && _step !== step;) _step.customAnimate && (_step.customAnimate.onStart && _step.customAnimate.onStart(), _step.customAnimate.onEnd && _step.customAnimate.onEnd()), _step = step.prev;
          lastStep && lastStep.customAnimate && lastStep.customAnimate.onEnd && lastStep.customAnimate.onEnd(), step && step.customAnimate && step.customAnimate.onStart && step.customAnimate.onStart();
        } else {
          let _step = lastStep.next;
          for (; _step && _step !== step;) _step.customAnimate && (_step.customAnimate.onStart && _step.customAnimate.onStart(), _step.customAnimate.onEnd && _step.customAnimate.onEnd()), _step = _step.next;
          lastStep && lastStep.customAnimate && lastStep.customAnimate.onEnd && lastStep.customAnimate.onEnd(), step && step.customAnimate && step.customAnimate.onStart && step.customAnimate.onStart();
        }
      }
      getLastPropByName(name, step) {
        let lastStep = step.prev;
        for (; lastStep;) {
          if (lastStep.props && void 0 !== lastStep.props[name]) return lastStep.props[name];
          if (lastStep.customAnimate) {
            const val = lastStep.customAnimate.getEndProps()[name];
            if (void 0 !== val) return val;
          }
          lastStep = lastStep.prev;
        }
        return Logger$1.getInstance().warn("未知错误，step中找不到属性"), step.props[name];
      }
      updateTarget(step, ratio, end) {
        null == step.props && null == step.customAnimate || this.target.onStep(this, this.animate, step, ratio, end);
      }
    }
    class Step {
      constructor(position, duration, props, easing) {
        this.duration = duration, this.position = position, this.props = props, this.easing = easing;
      }
      append(step) {
        step.prev = this, step.next = this.next, this.next = step;
      }
      getLastProps() {
        let step = this.prev;
        for (; step;) {
          if (step.props) return step.props;
          if (step.customAnimate) return step.customAnimate.getMergedEndProps();
          step = step.prev;
        }
        return null;
      }
    }

    const DefaultStateAnimateConfig = {
      duration: 200,
      easing: "cubicOut"
    };

    var Edge$1;
    !function (Edge) {
      Edge[Edge.Top = 1] = "Top", Edge[Edge.Right = 2] = "Right", Edge[Edge.Bottom = 4] = "Bottom", Edge[Edge.Left = 8] = "Left", Edge[Edge.ALL = 15] = "ALL";
    }(Edge$1 || (Edge$1 = {}));
    const _strokeVec4 = [!1, !1, !1, !1];
    const parseStroke = stroke => {
      var _a;
      let isFullStroke = !0;
      if (isBoolean$6(stroke, !0)) {
        for (let i = 0; i < 4; i++) _strokeVec4[i] = stroke, isFullStroke && (isFullStroke = !(null !== (_a = _strokeVec4[i]) && void 0 !== _a && !_a));
        isFullStroke = stroke;
      } else if (Array.isArray(stroke)) for (let i = 0; i < 4; i++) _strokeVec4[i] = !!stroke[i], isFullStroke && (isFullStroke = !!_strokeVec4[i]);else _strokeVec4[0] = !1, _strokeVec4[1] = !1, _strokeVec4[2] = !1, _strokeVec4[3] = !1;
      return {
        isFullStroke: isFullStroke,
        stroke: _strokeVec4
      };
    };
    const _paddingVec4 = [0, 0, 0, 0];
    const parsePadding = padding => padding ? isArray$9(padding) ? 0 === padding.length ? 0 : 1 === padding.length ? padding[0] : 2 === padding.length ? (_paddingVec4[0] = padding[0], _paddingVec4[2] = padding[0], _paddingVec4[1] = padding[1], _paddingVec4[3] = padding[1], _paddingVec4) : padding : padding : 0;
    const _coords = [{
        x: 0,
        y: 0
      }, {
        x: 0,
        y: 0
      }, {
        x: 0,
        y: 0
      }, {
        x: 0,
        y: 0
      }],
      indexList = [1, 2, 3, 0, 1, 2, 3, 0];
    function circleBounds(startAngle, endAngle, radius, bounds) {
      for (; startAngle >= pi2;) startAngle -= pi2;
      for (; startAngle < 0;) startAngle += pi2;
      for (; startAngle > endAngle;) endAngle += pi2;
      _coords[0].x = radius, _coords[1].y = radius, _coords[2].x = -radius, _coords[3].y = -radius;
      const startIdx = Math.ceil(startAngle / halfPi$1) % 4,
        endIdx = Math.ceil(endAngle / halfPi$1) % 4;
      if (bounds.add(cos(startAngle) * radius, sin(startAngle) * radius), bounds.add(cos(endAngle) * radius, sin(endAngle) * radius), startIdx !== endIdx || endAngle - startAngle > pi) {
        let match = !1;
        for (let i = 0; i < indexList.length; i++) if (match || startIdx !== indexList[i]) {
          if (match && endIdx === indexList[i]) break;
          if (match) {
            const p = _coords[indexList[i]];
            bounds.add(p.x, p.y);
          }
        } else {
          match = !0;
          const p = _coords[startIdx];
          bounds.add(p.x, p.y);
        }
      }
    }
    function pointInterpolation(pointA, pointB, ratio) {
      const {
          x: x,
          y: y
        } = pointAt(pointA.x, pointA.y, pointB.x, pointB.y, ratio),
        {
          x: x1,
          y: y1
        } = pointAt(pointA.x1, pointA.y1, pointB.x1, pointB.y1, ratio),
        point = new Point(x, y, x1, y1);
      return point.defined = pointB.defined, point;
    }
    function pointsInterpolation(pointsA, pointsB, ratio) {
      if (!pointsA || !pointsB) return [];
      Array.isArray(pointsA) || (pointsA = [pointsA]), Array.isArray(pointsB) || (pointsB = [pointsB]);
      let points = [];
      if (pointsA.length > pointsB.length) {
        points = pointsB.map(point => {
          const p = new Point(point.x, point.y, point.x1, point.y1);
          return p.defined = point.defined, p;
        });
        for (let i = 0; i < pointsB.length; i++) points[i] = pointInterpolation(pointsA[i], pointsB[i], ratio);
      } else {
        points = pointsB.map(point => {
          const p = new Point(point.x, point.y, point.x1, point.y1);
          return p.defined = point.defined, p;
        });
        for (let i = 0; i < pointsA.length; i++) points[i] = pointInterpolation(pointsA[i], pointsB[i], ratio);
      }
      return points;
    }
    function getAttributeFromDefaultAttrList(attr, key) {
      if (isArray$9(attr)) {
        let val;
        for (let i = 0; i < attr.length && void 0 === val; i++) val = attr[i][key];
        return val;
      }
      return attr[key];
    }
    class RafBasedSTO {
      constructor() {
        let timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : RafBasedSTO.TimeOut;
        this.durations = [], this.timeout = timeout, this.lastDate = 0, this.durationsListThreshold = 30;
      }
      call(cb) {
        return this.lastDate = Date.now(), setTimeout(() => {
          this.appendDuration(Date.now() - this.lastDate), cb(0);
        }, this.timeout, !0);
      }
      clear(h) {
        clearTimeout(h);
      }
      appendDuration(d) {
        this.durations.push(d), this.durations.length > this.durationsListThreshold && this.durations.shift(), this.timeout = Math.min(Math.max(this.durations.reduce((a, b) => a + b, 0) / this.durations.length, 1e3 / 60), 1e3 / 30);
      }
    }
    RafBasedSTO.TimeOut = 1e3 / 60;
    const rafBasedSto = new RafBasedSTO();
    const _calculateLineHeight = (lineHeight, fontSize) => {
      if (isString$6(lineHeight) && "%" === lineHeight[lineHeight.length - 1]) {
        return fontSize * (Number.parseFloat(lineHeight.substring(0, lineHeight.length - 1)) / 100);
      }
      return lineHeight;
    };
    const calculateLineHeight = (lineHeight, fontSize) => {
      const _lh = _calculateLineHeight(lineHeight, fontSize);
      return isNaN(_lh) ? _lh : Math.max(fontSize, _lh);
    };

    var Direction$1;
    !function (Direction) {
      Direction[Direction.LEFT_TO_RIGHT = 0] = "LEFT_TO_RIGHT", Direction[Direction.RIGHT_TO_LEFT = 1] = "RIGHT_TO_LEFT", Direction[Direction.TOP_TO_BOTTOM = 2] = "TOP_TO_BOTTOM", Direction[Direction.BOTTOM_TO_TOP = 3] = "BOTTOM_TO_TOP", Direction[Direction.STROKE = 4] = "STROKE";
    }(Direction$1 || (Direction$1 = {}));
    class InputText extends ACustomAnimate {
      constructor() {
        super(...arguments), this.fromText = "", this.toText = "";
      }
      getEndProps() {
        return !1 === this.valid ? {} : {
          text: this.to
        };
      }
      onBind() {
        var _a, _b, _c;
        this.fromText = null !== (_b = null === (_a = this.from) || void 0 === _a ? void 0 : _a.text) && void 0 !== _b ? _b : "", this.toText = (null === (_c = this.to) || void 0 === _c ? void 0 : _c.text) || "", (!this.toText || isArray$9(this.toText) && 0 === this.toText.length) && (this.valid = !1), isArray$9(this.toText) && (this.toText = this.toText.map(item => (item || "").toString()));
      }
      onEnd() {
        this.target.detachShadow();
      }
      onUpdate(end, ratio, out) {
        if (!1 === this.valid) return;
        const fromCount = this.fromText.length,
          toTextIsArray = isArray$9(this.toText),
          toCount = toTextIsArray ? this.toText.reduce((c, t) => c + (t || "").length, 0) : this.toText.length,
          count = Math.ceil(fromCount + (toCount - fromCount) * ratio);
        if (toTextIsArray) {
          out.text = [];
          let len = 0;
          this.toText.forEach(t => {
            len + t.length > count ? (out.text.push(t.substr(0, count - len)), len = count) : (out.text.push(t), len += t.length);
          });
        } else out.text = this.toText.substr(0, count);
      }
    }

    const normalizeRectAttributes = attribute => {
      if (!attribute) return {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      };
      let width = isNil$5(attribute.width) ? attribute.x1 - attribute.x : attribute.width,
        height = isNil$5(attribute.height) ? attribute.y1 - attribute.y : attribute.height,
        x = 0,
        y = 0;
      return width < 0 ? (x = width, width = -width) : Number.isNaN(width) && (width = 0), height < 0 ? (y = height, height = -height) : Number.isNaN(height) && (height = 0), {
        x: x,
        y: y,
        width: width,
        height: height
      };
    };

    var ColorType;
    !function (ColorType) {
      ColorType[ColorType.Color255 = 0] = "Color255", ColorType[ColorType.Color1 = 1] = "Color1";
    }(ColorType || (ColorType = {}));
    class ColorStore {
      static Get(str) {
        let size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ColorType.Color1;
        let arr = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [0, 0, 0, 1];
        if (size === ColorType.Color1) {
          const color = ColorStore.store1[str];
          if (color) return arr[0] = color[0], arr[1] = color[1], arr[2] = color[2], arr[3] = color[3], arr;
          const c = Color$1.parseColorString(str);
          if (c) {
            const data = [c.r / 255, c.g / 255, c.b / 255, c.opacity];
            ColorStore.store1[str] = data, ColorStore.store255[str] = [c.r, c.g, c.b, c.opacity], arr[0] = data[0], arr[1] = data[1], arr[2] = data[2], arr[3] = data[3];
          }
          return arr;
        }
        const color = ColorStore.store255[str];
        if (color) return arr[0] = color[0], arr[1] = color[1], arr[2] = color[2], arr[3] = color[3], arr;
        const c = Color$1.parseColorString(str);
        return c && (ColorStore.store1[str] = [c.r / 255, c.g / 255, c.b / 255, c.opacity], ColorStore.store255[str] = [c.r, c.g, c.b, c.opacity], arr[0] = c.r, arr[1] = c.g, arr[2] = c.b, arr[3] = c.opacity), arr;
      }
      static Set(str, size, arr) {
        if (size === ColorType.Color1) {
          if (ColorStore.store1[str]) return;
          ColorStore.store1[str] = arr, ColorStore.store255[str] = [Math.floor(255 * arr[0]), Math.floor(255 * arr[1]), Math.floor(255 * arr[2]), Math.floor(255 * arr[3])];
        } else {
          if (ColorStore.store255[str]) return;
          ColorStore.store255[str] = arr, ColorStore.store1[str] = [arr[0] / 255, arr[1] / 255, arr[2] / 255, arr[3]];
        }
      }
    }
    ColorStore.store255 = {}, ColorStore.store1 = {};

    function colorArrayToString(color) {
      let alphaChannel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
      return Array.isArray(color) && isNumber$6(color[0]) ? alphaChannel ? `rgb(${Math.round(color[0])},${Math.round(color[1])},${Math.round(color[2])},${color[3].toFixed(2)})` : `rgb(${Math.round(color[0])},${Math.round(color[1])},${Math.round(color[2])})` : color;
    }
    function interpolateColor(from, to, ratio, alphaChannel, cb) {
      if (Array.isArray(from) && !isNumber$6(from[0]) || Array.isArray(to) && !isNumber$6(to[0])) {
        return new Array(4).fill(0).map((_, index) => _interpolateColor(isArray$9(from) ? from[index] : from, isArray$9(to) ? to[index] : to, ratio, alphaChannel));
      }
      return _interpolateColor(from, to, ratio, alphaChannel, cb);
    }
    function _interpolateColor(from, to, ratio, alphaChannel, cb) {
      if (!from || !to) return from && colorArrayToString(from) || to && colorArrayToString(to) || !1;
      let fromArray,
        toArray,
        fromGradient = !1,
        toGradient = !1;
      if (Array.isArray(from) ? fromArray = from : "string" == typeof from ? fromArray = ColorStore.Get(from, ColorType.Color255) : fromGradient = !0, Array.isArray(to) ? toArray = to : "string" == typeof to ? toArray = ColorStore.Get(to, ColorType.Color255) : toGradient = !0, fromGradient !== toGradient) {
        const gradient = fromGradient ? from : to,
          pure = fromGradient ? to : from,
          gradientFromPure = Object.assign(Object.assign({}, gradient), {
            stops: gradient.stops.map(v => Object.assign(Object.assign({}, v), {
              color: colorArrayToString(pure)
            }))
          });
        return fromGradient ? interpolateColor(gradient, gradientFromPure, ratio, alphaChannel, cb) : interpolateColor(gradientFromPure, gradient, ratio, alphaChannel, cb);
      }
      if (fromGradient) {
        if (from.gradient === to.gradient) {
          const fc = from,
            tc = to,
            fromStops = fc.stops,
            toStops = tc.stops;
          if (fromStops.length !== toStops.length) return !1;
          if ("linear" === fc.gradient) return interpolateGradientLinearColor(fc, tc, ratio);
          if ("radial" === fc.gradient) return interpolateGradientRadialColor(fc, tc, ratio);
          if ("conical" === fc.gradient) return interpolateGradientConicalColor(fc, tc, ratio);
        }
        return !1;
      }
      cb && cb(fromArray, toArray);
      return colorArrayToString(interpolatePureColorArray(fromArray, toArray, ratio), alphaChannel);
    }
    function interpolateGradientLinearColor(fc, tc, ratio) {
      const fStops = fc.stops,
        tStops = tc.stops;
      return {
        gradient: "linear",
        x0: fc.x0 + (tc.x0 - fc.x0) * ratio,
        x1: fc.x1 + (tc.x1 - fc.x1) * ratio,
        y0: fc.y0 + (tc.y0 - fc.y0) * ratio,
        y1: fc.y1 + (tc.y1 - fc.y1) * ratio,
        stops: new Array(fStops.length).fill(0).map((_, i) => ({
          color: colorStringInterpolationToStr(fStops[i].color, tStops[i].color, ratio),
          offset: fStops[i].offset + (tStops[i].offset - fStops[i].offset) * ratio
        }))
      };
    }
    function interpolateGradientRadialColor(fc, tc, ratio) {
      const fStops = fc.stops,
        tStops = tc.stops;
      return {
        gradient: "radial",
        x0: fc.x0 + (tc.x0 - fc.x0) * ratio,
        x1: fc.x1 + (tc.x1 - fc.x1) * ratio,
        y0: fc.y0 + (tc.y0 - fc.y0) * ratio,
        y1: fc.y1 + (tc.y1 - fc.y1) * ratio,
        r0: fc.r0 + (tc.r0 - fc.r0) * ratio,
        r1: fc.r1 + (tc.r1 - fc.r1) * ratio,
        stops: new Array(fStops.length).fill(0).map((_, i) => ({
          color: colorStringInterpolationToStr(fStops[i].color, tStops[i].color, ratio),
          offset: fStops[i].offset + (tStops[i].offset - fStops[i].offset) * ratio
        }))
      };
    }
    function interpolateGradientConicalColor(fc, tc, ratio) {
      const fStops = fc.stops,
        tStops = tc.stops;
      return {
        gradient: "conical",
        startAngle: fc.startAngle + (tc.startAngle - fc.startAngle) * ratio,
        endAngle: fc.endAngle + (tc.endAngle - fc.endAngle) * ratio,
        x: fc.x + (tc.x - fc.x) * ratio,
        y: fc.y + (tc.y - fc.y) * ratio,
        stops: new Array(fStops.length).fill(0).map((_, i) => ({
          color: colorStringInterpolationToStr(fStops[i].color, tStops[i].color, ratio),
          offset: fStops[i].offset + (tStops[i].offset - fStops[i].offset) * ratio
        }))
      };
    }
    function interpolatePureColorArray(from, to, ratio) {
      return [from[0] + (to[0] - from[0]) * ratio, from[1] + (to[1] - from[1]) * ratio, from[2] + (to[2] - from[2]) * ratio, from[3] + (to[3] - from[3]) * ratio];
    }
    const _fromColorRGB = [0, 0, 0, 0],
      _toColorRGB = [0, 0, 0, 0];
    function colorStringInterpolationToStr(fromColor, toColor, ratio) {
      return ColorStore.Get(fromColor, ColorType.Color255, _fromColorRGB), ColorStore.Get(toColor, ColorType.Color255, _toColorRGB), `rgba(${Math.round(_fromColorRGB[0] + (_toColorRGB[0] - _fromColorRGB[0]) * ratio)},${Math.round(_fromColorRGB[1] + (_toColorRGB[1] - _fromColorRGB[1]) * ratio)},${Math.round(_fromColorRGB[2] + (_toColorRGB[2] - _fromColorRGB[2]) * ratio)},${_fromColorRGB[3] + (_toColorRGB[3] - _fromColorRGB[3]) * ratio})`;
    }

    class ResourceLoader {
      static GetImage(url, mark) {
        var _a;
        const data = ResourceLoader.cache.get(url);
        data ? "fail" === data.loadState ? application.global.getRequestAnimationFrame()(() => {
          mark.imageLoadFail(url);
        }) : "init" === data.loadState || "loading" === data.loadState ? null === (_a = data.waitingMark) || void 0 === _a || _a.push(mark) : mark && mark.imageLoadSuccess(url, data.data) : ResourceLoader.loadImage(url, mark);
      }
      static GetSvg(svgStr, mark) {
        var _a;
        let data = ResourceLoader.cache.get(svgStr);
        data ? "fail" === data.loadState ? application.global.getRequestAnimationFrame()(() => {
          mark.imageLoadFail(svgStr);
        }) : "init" === data.loadState || "loading" === data.loadState ? null === (_a = data.waitingMark) || void 0 === _a || _a.push(mark) : mark && mark.imageLoadSuccess(svgStr, data.data) : (data = {
          type: "image",
          loadState: "init"
        }, ResourceLoader.cache.set(svgStr, data), data.dataPromise = application.global.loadSvg(svgStr), data.dataPromise ? (data.waitingMark = [mark], data.dataPromise.then(res => {
          var _a;
          data.loadState = (null == res ? void 0 : res.data) ? "success" : "fail", data.data = null == res ? void 0 : res.data, null === (_a = data.waitingMark) || void 0 === _a || _a.map((mark, index) => {
            (null == res ? void 0 : res.data) ? (data.loadState = "success", data.data = res.data, mark.imageLoadSuccess(svgStr, res.data)) : (data.loadState = "fail", mark.imageLoadFail(svgStr));
          }), data.waitingMark && (data.waitingMark = []);
        })) : (data.loadState = "fail", mark.imageLoadFail(svgStr)));
      }
      static GetFile(url, type) {
        let data = ResourceLoader.cache.get(url);
        return data ? "fail" === data.loadState ? Promise.reject() : "init" === data.loadState || "loading" === data.loadState ? data.dataPromise.then(data => data.data) : Promise.resolve(data.data) : (data = {
          type: type,
          loadState: "init"
        }, ResourceLoader.cache.set(url, data), "arrayBuffer" === type ? data.dataPromise = application.global.loadArrayBuffer(url) : "blob" === type ? data.dataPromise = application.global.loadBlob(url) : "json" === type && (data.dataPromise = application.global.loadJson(url)), data.dataPromise.then(data => data.data));
      }
      static loading() {
        setTimeout(() => {
          if (!ResourceLoader.isLoading && ResourceLoader.toLoadAueue.length) {
            ResourceLoader.isLoading = !0;
            const tasks = ResourceLoader.toLoadAueue.splice(0, 10),
              promises = [];
            tasks.forEach(task => {
              const {
                  url: url,
                  marks: marks
                } = task,
                data = {
                  type: "image",
                  loadState: "init"
                };
              if (ResourceLoader.cache.set(url, data), data.dataPromise = application.global.loadImage(url), data.dataPromise) {
                data.waitingMark = marks;
                const end = data.dataPromise.then(res => {
                  var _a;
                  data.loadState = (null == res ? void 0 : res.data) ? "success" : "fail", data.data = null == res ? void 0 : res.data, null === (_a = data.waitingMark) || void 0 === _a || _a.map((mark, index) => {
                    (null == res ? void 0 : res.data) ? (data.loadState = "success", data.data = res.data, mark.imageLoadSuccess(url, res.data)) : (data.loadState = "fail", mark.imageLoadFail(url));
                  }), data.waitingMark && (data.waitingMark = []);
                });
                promises.push(end);
              } else data.loadState = "fail", marks.forEach(mark => mark.imageLoadFail(url));
            }), Promise.all(promises).then(() => {
              ResourceLoader.isLoading = !1, this.onLoadSuccessCb.forEach(cb => cb()), ResourceLoader.loading();
            }).catch(error => {
              ResourceLoader.isLoading = !1, this.onLoadSuccessCb.forEach(cb => cb()), ResourceLoader.loading();
            });
          }
        }, 0);
      }
      static loadImage(url, mark) {
        const index = getIndex(url, ResourceLoader.toLoadAueue);
        if (-1 !== index) return ResourceLoader.toLoadAueue[index].marks.push(mark), void ResourceLoader.loading();
        ResourceLoader.toLoadAueue.push({
          url: url,
          marks: [mark]
        }), ResourceLoader.loading();
      }
      static improveImageLoading(url) {
        const index = getIndex(url, ResourceLoader.toLoadAueue);
        if (-1 !== index) {
          const elememt = ResourceLoader.toLoadAueue.splice(index, 1);
          ResourceLoader.toLoadAueue.unshift(elememt[0]);
        }
      }
      static onLoadSuccess(cb) {
        this.onLoadSuccessCb.push(cb);
      }
    }
    function getIndex(url, arr) {
      for (let i = 0; i < arr.length; i++) if (arr[i].url === url) return i;
      return -1;
    }
    ResourceLoader.cache = new Map(), ResourceLoader.isLoading = !1, ResourceLoader.toLoadAueue = [], ResourceLoader.onLoadSuccessCb = [];

    class BaseSymbol {
      bounds(size, bounds) {
        if (isNumber$6(size)) {
          const halfS = size / 2;
          bounds.x1 = -halfS, bounds.x2 = halfS, bounds.y1 = -halfS, bounds.y2 = halfS;
        } else bounds.x1 = -size[0] / 2, bounds.x2 = size[0] / 2, bounds.y1 = -size[1] / 2, bounds.y2 = size[1] / 2;
      }
      parseSize(size) {
        return isNumber$6(size) ? size : Math.min(size[0], size[1]);
      }
    }

    function circle(ctx, r, x, y, z) {
      return z ? ctx.arc(x, y, r, 0, tau, !1, z) : ctx.arc(x, y, r, 0, tau), !1;
    }
    class CircleSymbol extends BaseSymbol {
      constructor() {
        super(...arguments), this.type = "circle", this.pathStr = "M0.5,0A0.5,0.5,0,1,1,-0.5,0A0.5,0.5,0,1,1,0.5,0";
      }
      draw(ctx, size, x, y, z) {
        return circle(ctx, this.parseSize(size) / 2, x, y, z);
      }
      drawOffset(ctx, size, x, y, offset, z) {
        return circle(ctx, this.parseSize(size) / 2 + offset, x, y, z);
      }
      drawToSvgPath(size, x, y, z) {
        const r = this.parseSize(size) / 2;
        return `M ${x - r}, ${y} a ${r},${r} 0 1,0 ${2 * r},0 a ${r},${r} 0 1,0 -${2 * r},0`;
      }
    }
    var circle$1 = new CircleSymbol();

    function cross(ctx, r, x, y, z) {
      return ctx.moveTo(-3 * r + x, -r + y, z), ctx.lineTo(-r + x, -r + y, z), ctx.lineTo(-r + x, -3 * r + y, z), ctx.lineTo(r + x, -3 * r + y, z), ctx.lineTo(r + x, -r + y, z), ctx.lineTo(3 * r + x, -r + y, z), ctx.lineTo(3 * r + x, r + y, z), ctx.lineTo(r + x, r + y, z), ctx.lineTo(r + x, 3 * r + y, z), ctx.lineTo(-r + x, 3 * r + y, z), ctx.lineTo(-r + x, r + y, z), ctx.lineTo(-3 * r + x, r + y, z), ctx.closePath(), !0;
    }
    function crossOffset(ctx, r, x, y, offset, z) {
      return ctx.moveTo(-3 * r + x - offset, -r + y - offset, z), ctx.lineTo(-r + x - offset, -r + y - offset, z), ctx.lineTo(-r + x - offset, -3 * r + y - offset, z), ctx.lineTo(r + x + offset, -3 * r + y - offset, z), ctx.lineTo(r + x + offset, -r + y - offset, z), ctx.lineTo(3 * r + x + offset, -r + y - offset, z), ctx.lineTo(3 * r + x + offset, r + y + offset, z), ctx.lineTo(r + x + offset, r + y + offset, z), ctx.lineTo(r + x + offset, 3 * r + y + offset, z), ctx.lineTo(-r + x - offset, 3 * r + y + offset, z), ctx.lineTo(-r + x - offset, r + y + offset, z), ctx.lineTo(-3 * r + x - offset, r + y + offset, z), ctx.closePath(), !0;
    }
    class CrossSymbol extends BaseSymbol {
      constructor() {
        super(...arguments), this.type = "cross", this.pathStr = "M-0.5,-0.2L-0.5,0.2L-0.2,0.2L-0.2,0.5L0.2,0.5L0.2,0.2L0.5,0.2L0.5,-0.2L0.2,-0.2L0.2,-0.5L-0.2,-0.5L-0.2,-0.2Z";
      }
      draw(ctx, size, x, y, z) {
        return cross(ctx, this.parseSize(size) / 6, x, y, z);
      }
      drawOffset(ctx, size, x, y, offset, z) {
        return crossOffset(ctx, this.parseSize(size) / 6, x, y, offset, z);
      }
    }
    var cross$1 = new CrossSymbol();

    function diamond(ctx, r, x, y, z) {
      return ctx.moveTo(x, y - r, z), ctx.lineTo(r + x, y, z), ctx.lineTo(x, y + r, z), ctx.lineTo(x - r, y, z), ctx.closePath(), !0;
    }
    class DiamondSymbol extends BaseSymbol {
      constructor() {
        super(...arguments), this.type = "diamond", this.pathStr = "M-0.5,0L0,-0.5L0.5,0L0,0.5Z";
      }
      draw(ctx, size, x, y, z) {
        return diamond(ctx, this.parseSize(size) / 2, x, y, z);
      }
      drawFitDir(ctx, size, x, y, z) {
        return diamond(ctx, this.parseSize(size) / 2, x, y, z);
      }
      drawOffset(ctx, size, x, y, offset, z) {
        return diamond(ctx, this.parseSize(size) / 2 + offset, x, y, z);
      }
    }
    var diamond$1 = new DiamondSymbol();

    function square(ctx, r, x, y) {
      const wh = 2 * r;
      return ctx.rect(x - r, y - r, wh, wh), !1;
    }
    class SquareSymbol extends BaseSymbol {
      constructor() {
        super(...arguments), this.type = "square", this.pathStr = "M-0.5,-0.5h1v1h-1Z";
      }
      draw(ctx, size, x, y) {
        return square(ctx, this.parseSize(size) / 2, x, y);
      }
      drawOffset(ctx, size, x, y, offset) {
        return square(ctx, this.parseSize(size) / 2 + offset, x, y);
      }
    }
    var square$1 = new SquareSymbol();

    function trianglUpOffset(ctx, r, x, y) {
      let offset = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
      return ctx.moveTo(x + r + 2 * offset, r + y + offset), ctx.lineTo(x - r - 2 * offset, r + y + offset), ctx.lineTo(x, y - r - 2 * offset), ctx.closePath(), !0;
    }
    class TriangleUpSymbol extends BaseSymbol {
      constructor() {
        super(...arguments), this.type = "triangleUp", this.pathStr = "M0.5,0.5 L-0.5,0.5 L0,-0.5 Z";
      }
      draw(ctx, size, x, y) {
        return trianglUpOffset(ctx, this.parseSize(size) / 2, x, y);
      }
      drawOffset(ctx, size, x, y, offset) {
        return trianglUpOffset(ctx, this.parseSize(size) / 2, x, y, offset);
      }
    }
    var triangleUp = new TriangleUpSymbol();

    class TriangleSymbol extends TriangleUpSymbol {
      constructor() {
        super(...arguments), this.type = "triangle";
      }
    }
    var triangle = new TriangleSymbol();

    const kr = Math.sin(Math.PI / 10) / Math.sin(7 * Math.PI / 10),
      kx = Math.sin(tau / 10) * kr,
      ky = -Math.cos(tau / 10) * kr;
    function star(ctx, r, transX, transY) {
      const x = kx * r,
        y = ky * r;
      ctx.moveTo(transX, -r + transY), ctx.lineTo(x + transX, y + transY);
      for (let i = 1; i < 5; ++i) {
        const a = tau * i / 5,
          c = Math.cos(a),
          s = Math.sin(a);
        ctx.lineTo(s * r + transX, -c * r + transY), ctx.lineTo(c * x - s * y + transX, s * x + c * y + transY);
      }
      return ctx.closePath(), !0;
    }
    class StarSymbol extends BaseSymbol {
      constructor() {
        super(...arguments), this.type = "star", this.pathStr = "M0 -1L0.22451398828979266 -0.3090169943749474L0.9510565162951535 -0.30901699437494745L0.3632712640026804 0.1180339887498948L0.5877852522924732 0.8090169943749473L8.326672684688674e-17 0.3819660112501051L-0.587785252292473 0.8090169943749476L-0.3632712640026804 0.11803398874989487L-0.9510565162951536 -0.30901699437494723L-0.22451398828979274 -0.30901699437494734Z";
      }
      draw(ctx, size, transX, transY) {
        return star(ctx, this.parseSize(size) / 2, transX, transY);
      }
      drawOffset(ctx, size, transX, transY, offset) {
        return star(ctx, this.parseSize(size) / 2 + offset, transX, transY);
      }
    }
    var star$1 = new StarSymbol();

    const sqrt3$1 = sqrt(3);
    function arrow(ctx, r, transX, transY) {
      const triangleH = r,
        trangleBottomSide = triangleH / sqrt3$1,
        rectW = trangleBottomSide / 5,
        rectH = r;
      return ctx.moveTo(0 + transX, -triangleH + transY), ctx.lineTo(trangleBottomSide / 2 + transX, transY), ctx.lineTo(rectW / 2 + transX, transY), ctx.lineTo(rectW / 2 + transX, rectH + transY), ctx.lineTo(-rectW / 2 + transX, rectH + transY), ctx.lineTo(-rectW / 2 + transX, transY), ctx.lineTo(-trangleBottomSide / 2 + transX, transY), ctx.closePath(), !0;
    }
    class ArrowSymbol extends BaseSymbol {
      constructor() {
        super(...arguments), this.type = "arrow", this.pathStr = "M-0.07142857142857142,0.5L0.07142857142857142,0.5L0.07142857142857142,-0.0625L0.2,-0.0625L0,-0.5L-0.2,-0.0625L-0.07142857142857142,-0.0625Z";
      }
      draw(ctx, size, transX, transY) {
        return arrow(ctx, this.parseSize(size) / 2, transX, transY);
      }
      drawOffset(ctx, size, transX, transY, offset) {
        return arrow(ctx, this.parseSize(size) / 2 + offset, transX, transY);
      }
    }
    var arrow$1 = new ArrowSymbol();

    function wedge(ctx, r, transX, transY) {
      const h = 2 * r;
      return ctx.moveTo(transX, -r + transY), ctx.lineTo(h / 3 / 2 + transX, r + transY), ctx.lineTo(-h / 3 / 2 + transX, r + transY), ctx.closePath(), !0;
    }
    class WedgeSymbol extends BaseSymbol {
      constructor() {
        super(...arguments), this.type = "wedge", this.pathStr = "M0,-0.5773502691896257L-0.125,0.28867513459481287L0.125,0.28867513459481287Z";
      }
      draw(ctx, size, transX, transY) {
        return wedge(ctx, this.parseSize(size) / 2, transX, transY);
      }
      drawOffset(ctx, size, transX, transY, offset) {
        return wedge(ctx, this.parseSize(size) / 2 + offset, transX, transY);
      }
    }
    var wedge$1 = new WedgeSymbol();

    function stroke(ctx, r, transX, transY) {
      return ctx.moveTo(-r + transX, transY), ctx.lineTo(transX, r + transY), !1;
    }
    class StrokeSymbol extends BaseSymbol {
      constructor() {
        super(...arguments), this.type = "stroke", this.pathStr = "";
      }
      draw(ctx, size, transX, transY) {
        return stroke(ctx, this.parseSize(size) / 2, transX, transY);
      }
      drawOffset(ctx, size, transX, transY, offset) {
        return stroke(ctx, this.parseSize(size) / 2 + offset, transX, transY);
      }
    }
    var stroke$1 = new StrokeSymbol();

    const c = -.5,
      s = sqrt(3) / 2,
      k = 1 / sqrt(12);
    function wye(ctx, r, transX, transY) {
      const x0 = r / 2,
        y0 = r * k,
        x1 = x0,
        y1 = r * k + r,
        x2 = -x1,
        y2 = y1;
      return ctx.moveTo(x0 + transX, y0 + transY), ctx.lineTo(x1 + transX, y1 + transY), ctx.lineTo(x2 + transX, y2 + transY), ctx.lineTo(c * x0 - s * y0 + transX, s * x0 + c * y0 + transY), ctx.lineTo(c * x1 - s * y1 + transX, s * x1 + c * y1 + transY), ctx.lineTo(c * x2 - s * y2 + transX, s * x2 + c * y2 + transY), ctx.lineTo(c * x0 + s * y0 + transX, c * y0 - s * x0 + transY), ctx.lineTo(c * x1 + s * y1 + transX, c * y1 - s * x1 + transY), ctx.lineTo(c * x2 + s * y2 + transX, c * y2 - s * x2 + transY), ctx.closePath(), !1;
    }
    class WyeSymbol extends BaseSymbol {
      constructor() {
        super(...arguments), this.type = "wye", this.pathStr = "M0.25 0.14433756729740646L0.25 0.6443375672974064L-0.25 0.6443375672974064L-0.25 0.14433756729740643L-0.6830127018922193 -0.10566243270259357L-0.4330127018922193 -0.5386751345948129L0 -0.28867513459481287L0.4330127018922193 -0.5386751345948129L0.6830127018922193 -0.10566243270259357Z";
      }
      draw(ctx, size, transX, transY) {
        return wye(ctx, this.parseSize(size) / 2, transX, transY);
      }
      drawOffset(ctx, size, transX, transY, offset) {
        return wye(ctx, this.parseSize(size) / 2 + offset, transX, transY);
      }
    }
    var wye$1 = new WyeSymbol();

    function trianglLeftOffset(ctx, r, x, y, offset) {
      return ctx.moveTo(-r + x - 2 * offset, y), ctx.lineTo(r + x + offset, r + y + 2 * offset), ctx.lineTo(r + x + offset, y - r - 2 * offset), ctx.closePath(), !0;
    }
    class TriangleLeftSymbol extends BaseSymbol {
      constructor() {
        super(...arguments), this.type = "triangleLeft", this.pathStr = "M-0.5,0 L0.5,0.5 L0.5,-0.5 Z";
      }
      draw(ctx, size, x, y) {
        return trianglLeftOffset(ctx, this.parseSize(size) / 2, x, y, 0);
      }
      drawOffset(ctx, size, x, y, offset) {
        return trianglLeftOffset(ctx, this.parseSize(size) / 2, x, y, offset);
      }
    }
    var triangleLeft = new TriangleLeftSymbol();

    function trianglRightOffset(ctx, r, x, y) {
      let offset = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
      return ctx.moveTo(x - r - offset, r + y + 2 * offset), ctx.lineTo(r + x + 2 * offset, y), ctx.lineTo(x - r - offset, y - r - 2 * offset), ctx.closePath(), !0;
    }
    class TriangleRightSymbol extends BaseSymbol {
      constructor() {
        super(...arguments), this.type = "triangleRight", this.pathStr = "M-0.5,0.5 L0.5,0 L-0.5,-0.5 Z";
      }
      draw(ctx, size, x, y) {
        return trianglRightOffset(ctx, this.parseSize(size) / 2, x, y);
      }
      drawOffset(ctx, size, x, y, offset) {
        return trianglRightOffset(ctx, this.parseSize(size) / 2, x, y, offset);
      }
    }
    var triangleRight = new TriangleRightSymbol();

    function trianglDownOffset(ctx, r, x, y) {
      let offset = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
      return ctx.moveTo(x - r - 2 * offset, y - r - offset), ctx.lineTo(x + r + 2 * offset, y - r - offset), ctx.lineTo(x, y + r + 2 * offset), ctx.closePath(), !0;
    }
    class TriangleDownSymbol extends BaseSymbol {
      constructor() {
        super(...arguments), this.type = "triangleDown", this.pathStr = "M-0.5,-0.5 L0.5,-0.5 L0,0.5 Z";
      }
      draw(ctx, size, x, y) {
        return trianglDownOffset(ctx, this.parseSize(size) / 2, x, y);
      }
      drawOffset(ctx, size, x, y, offset) {
        return trianglDownOffset(ctx, this.parseSize(size) / 2, x, y, offset);
      }
    }
    var triangleDown = new TriangleDownSymbol();

    const sqrt3 = sqrt(3);
    function thinTriangle(ctx, r, x, y) {
      const h = r * sqrt3;
      return ctx.moveTo(x, y + -h / 3 * 2), ctx.lineTo(r + x, y + h), ctx.lineTo(x - r, y + h), ctx.closePath(), !0;
    }
    class ThinTriangleSymbol extends BaseSymbol {
      constructor() {
        super(...arguments), this.type = "thinTriangle", this.pathStr = "M0,-0.5773502691896257L-0.5,0.28867513459481287L0.5,0.28867513459481287Z";
      }
      draw(ctx, size, x, y) {
        return thinTriangle(ctx, this.parseSize(size) / 2 / sqrt3, x, y);
      }
      drawOffset(ctx, size, x, y, offset) {
        return thinTriangle(ctx, this.parseSize(size) / 2 / sqrt3 + offset, x, y);
      }
    }
    var thinTriangle$1 = new ThinTriangleSymbol();

    function arrow2Left(ctx, r, transX, transY) {
      const r2 = 2 * r;
      return ctx.moveTo(r + transX, transY - r2), ctx.lineTo(transX - r, transY), ctx.lineTo(r + transX, r2 + transY), !0;
    }
    class Arrow2LeftSymbol extends BaseSymbol {
      constructor() {
        super(...arguments), this.type = "arrow2Left", this.pathStr = "M 0.25 -0.5 L -0.25 0 l 0.25 0.5";
      }
      draw(ctx, size, transX, transY) {
        return arrow2Left(ctx, this.parseSize(size) / 4, transX, transY);
      }
      drawOffset(ctx, size, transX, transY, offset) {
        return arrow2Left(ctx, this.parseSize(size) / 4 + offset, transX, transY);
      }
    }
    var arrow2Left$1 = new Arrow2LeftSymbol();

    function arrow2Right(ctx, r, transX, transY) {
      const r2 = 2 * r;
      return ctx.moveTo(transX - r, transY - r2), ctx.lineTo(transX + r, transY), ctx.lineTo(transX - r, r2 + transY), !0;
    }
    class Arrow2RightSymbol extends BaseSymbol {
      constructor() {
        super(...arguments), this.type = "arrow2Right", this.pathStr = "M -0.25 -0.5 l 0.25 0 l -0.25 0.5";
      }
      draw(ctx, size, transX, transY) {
        return arrow2Right(ctx, this.parseSize(size) / 4, transX, transY);
      }
      drawOffset(ctx, size, transX, transY, offset) {
        return arrow2Right(ctx, this.parseSize(size) / 4 + offset, transX, transY);
      }
    }
    var arrow2Right$1 = new Arrow2RightSymbol();

    function arrow2Up(ctx, r, transX, transY) {
      const r2 = 2 * r;
      return ctx.moveTo(transX - r2, transY + r), ctx.lineTo(transX, transY - r), ctx.lineTo(transX + r2, transY + r), !0;
    }
    class Arrow2UpSymbol extends BaseSymbol {
      constructor() {
        super(...arguments), this.type = "arrow2Up", this.pathStr = "M -0.5 0.25 L 0 -0.25 l 0.5 0.25";
      }
      draw(ctx, size, transX, transY) {
        return arrow2Up(ctx, this.parseSize(size) / 4, transX, transY);
      }
      drawOffset(ctx, size, transX, transY, offset) {
        return arrow2Up(ctx, this.parseSize(size) / 4 + offset, transX, transY);
      }
    }
    var arrow2Up$1 = new Arrow2UpSymbol();

    function arrow2Down(ctx, r, transX, transY) {
      const r2 = 2 * r;
      return ctx.moveTo(transX - r2, transY - r), ctx.lineTo(transX, transY + r), ctx.lineTo(transX + r2, transY - r), !0;
    }
    class Arrow2DownSymbol extends BaseSymbol {
      constructor() {
        super(...arguments), this.type = "arrow2Down", this.pathStr = "M -0.5 -0.25 L 0 0.25 l 0.5 -0.25";
      }
      draw(ctx, size, transX, transY) {
        return arrow2Down(ctx, this.parseSize(size) / 4, transX, transY);
      }
      drawOffset(ctx, size, transX, transY, offset) {
        return arrow2Down(ctx, this.parseSize(size) / 4 + offset, transX, transY);
      }
    }
    var arrow2Down$1 = new Arrow2DownSymbol();

    function lineV(ctx, r, x, y, z) {
      return ctx.moveTo(x, y - r), ctx.lineTo(x, y + r), !0;
    }
    class LineVSymbol extends BaseSymbol {
      constructor() {
        super(...arguments), this.type = "lineV", this.pathStr = "M0,-0.5L0,0.5";
      }
      draw(ctx, size, x, y, z) {
        return lineV(ctx, this.parseSize(size) / 2, x, y);
      }
      drawOffset(ctx, size, x, y, offset, z) {
        return lineV(ctx, this.parseSize(size) / 2 + offset, x, y);
      }
      drawToSvgPath(size, x, y, z) {
        const r = this.parseSize(size) / 2;
        return `M ${x}, ${y - r} L ${x},${y + r}`;
      }
    }
    var lineV$1 = new LineVSymbol();

    function lineH(ctx, r, x, y, z) {
      return ctx.moveTo(x - r, y), ctx.lineTo(x + r, y), !0;
    }
    class LineHSymbol extends BaseSymbol {
      constructor() {
        super(...arguments), this.type = "lineH", this.pathStr = "M-0.5,0L0.5,0";
      }
      draw(ctx, size, x, y, z) {
        return lineH(ctx, this.parseSize(size) / 2, x, y);
      }
      drawOffset(ctx, size, x, y, offset, z) {
        return lineH(ctx, this.parseSize(size) / 2 + offset, x, y);
      }
      drawToSvgPath(size, x, y, z) {
        const r = this.parseSize(size) / 2;
        return `M ${x - r}, ${y} L ${x + r},${y}`;
      }
    }
    var lineH$1 = new LineHSymbol();

    function close(ctx, r, x, y, z) {
      return ctx.moveTo(x - r, y - r), ctx.lineTo(x + r, y + r), ctx.moveTo(x + r, y - r), ctx.lineTo(x - r, y + r), !0;
    }
    class CloseSymbol extends BaseSymbol {
      constructor() {
        super(...arguments), this.type = "close", this.pathStr = "M-0.5,-0.5L0.5,0.5,M0.5,-0.5L-0.5,0.5";
      }
      draw(ctx, size, x, y, z) {
        return close(ctx, this.parseSize(size) / 2, x, y);
      }
      drawOffset(ctx, size, x, y, offset, z) {
        return close(ctx, this.parseSize(size) / 2 + offset, x, y);
      }
      drawToSvgPath(size, x, y, z) {
        const r = this.parseSize(size) / 2;
        return `M ${x - r}, ${y - r} L ${x + r},${y + r} M ${x + r}, ${y - r} L ${x - r},${y + r}`;
      }
    }
    var close$1 = new CloseSymbol();

    function rectSizeArray(ctx, size, x, y) {
      return ctx.rect(x - size[0] / 2, y - size[1] / 2, size[0], size[1]), !1;
    }
    function rectSize(ctx, size, x, y) {
      const w = size,
        h = size / 2;
      return ctx.rect(x - w / 2, y - h / 2, w, h), !1;
    }
    class RectSymbol extends BaseSymbol {
      constructor() {
        super(...arguments), this.type = "rect", this.pathStr = "M -0.5,0.25 L 0.5,0.25 L 0.5,-0.25,L -0.5,-0.25 Z";
      }
      draw(ctx, size, x, y) {
        return isNumber$6(size) ? rectSize(ctx, size, x, y) : rectSizeArray(ctx, size, x, y);
      }
      drawWithClipRange(ctx, size, x, y, clipRange, z, cb) {
        isNumber$6(size) && (size = [size, size / 2]);
        const drawLength = 2 * (size[0] + size[1]) * clipRange,
          points = [{
            x: x + size[0] / 2,
            y: y - size[1] / 2
          }, {
            x: x + size[0] / 2,
            y: y + size[1] / 2
          }, {
            x: x - size[0] / 2,
            y: y + size[1] / 2
          }, {
            x: x - size[0] / 2,
            y: y - size[1] / 2
          }];
        let currLength = 0,
          lastP = points[3];
        ctx.moveTo(lastP.x, lastP.y);
        for (let i = 0; i < points.length; i++) {
          const p = points[i],
            len = Math.sqrt((p.x - lastP.x) * (p.x - lastP.x) + (p.y - lastP.y) * (p.y - lastP.y));
          if (currLength + len > drawLength) {
            const dx = (p.x - lastP.x) * (drawLength - currLength) / len,
              dy = (p.y - lastP.y) * (drawLength - currLength) / len;
            ctx.lineTo(lastP.x + dx, lastP.y + dy);
            break;
          }
          ctx.lineTo(p.x, p.y), lastP = p, currLength += len;
        }
        return !1;
      }
      drawOffset(ctx, size, x, y, offset) {
        return isNumber$6(size) ? rectSize(ctx, size + 2 * offset, x, y) : rectSizeArray(ctx, [size[0] + 2 * offset, size[1] + 2 * offset], x, y);
      }
    }
    var rect = new RectSymbol();

    const tempBounds = new AABBBounds$1();
    class CustomSymbolClass {
      constructor(type, path) {
        let isSvg = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
        this.pathStr = "", this.type = type, isArray$9(path) ? this.svgCache = path : this.path = path, this.isSvg = isSvg;
      }
      drawOffset(ctx, size, x, y, offset, z, cb) {
        return size = this.parseSize(size), this.isSvg ? !!this.svgCache && (this.svgCache.forEach(item => {
          ctx.beginPath(), renderCommandList(item.path.commandList, ctx, x, y, size, size), cb && cb(item.path, item.attribute);
        }), !1) : (renderCommandList(this.path.commandList, ctx, x, y, size + offset, size + offset), !1);
      }
      draw(ctx, size, x, y, z, cb) {
        return size = this.parseSize(size), this.drawOffset(ctx, size, x, y, 0, z, cb);
      }
      parseSize(size) {
        return isNumber$6(size) ? size : Math.min(size[0], size[1]);
      }
      drawWithClipRange(ctx, size, x, y, clipRange, z, cb) {
        return size = this.parseSize(size), this.isSvg ? !!this.svgCache && (this.svgCache.forEach(item => {
          item.path.drawWithClipRange(ctx, size, x, y, clipRange), cb && cb(item.path, item.attribute);
        }), !1) : (this.path.drawWithClipRange(ctx, size, x, y, clipRange), !1);
      }
      bounds(size, bounds) {
        if (size = this.parseSize(size), this.isSvg) {
          if (!this.svgCache) return;
          return bounds.clear(), void this.svgCache.forEach(_ref => {
            let {
              path: path
            } = _ref;
            tempBounds.x1 = path.bounds.x1 * size, tempBounds.y1 = path.bounds.y1 * size, tempBounds.x2 = path.bounds.x2 * size, tempBounds.y2 = path.bounds.y2 * size, bounds.union(tempBounds);
          });
        }
        this.path.bounds && (bounds.x1 = this.path.bounds.x1 * size, bounds.y1 = this.path.bounds.y1 * size, bounds.x2 = this.path.bounds.x2 * size, bounds.y2 = this.path.bounds.y2 * size);
      }
    }

    const builtinSymbols = [circle$1, cross$1, diamond$1, square$1, thinTriangle$1, triangle, star$1, arrow$1, wedge$1, stroke$1, wye$1, triangleLeft, triangleRight, triangleUp, triangleDown, arrow2Left$1, arrow2Right$1, arrow2Up$1, arrow2Down$1, rect, lineV$1, lineH$1, close$1];
    const builtinSymbolsMap = {};
    builtinSymbols.forEach(symbol => {
      builtinSymbolsMap[symbol.type] = symbol;
    });
    const builtInSymbolStrMap = {
      arrowLeft: "M 0.25 -0.5 L -0.25 0 l 0.5 0.5",
      arrowRight: "M -0.25 -0.5 l 0.5 0.5 l -0.5 0.5",
      rectRound: "M 0.3 -0.5 C 0.41 -0.5 0.5 -0.41 0.5 -0.3 C 0.5 -0.3 0.5 0.3 0.5 0.3 C 0.5 0.41 0.41 0.5 0.3 0.5 C 0.3 0.5 -0.3 0.5 -0.3 0.5 C -0.41 0.5 -0.5 0.41 -0.5 0.3 C -0.5 0.3 -0.5 -0.3 -0.5 -0.3 C -0.5 -0.41 -0.41 -0.5 -0.3 -0.5 C -0.3 -0.5 0.3 -0.5 0.3 -0.5 Z",
      roundLine: "M 1.2392 -0.258 L -1.3432 -0.258 C -1.4784 -0.258 -1.588 -0.1436 -1.588 -0.002 c 0 0.1416 0.1096 0.256 0.2448 0.256 l 2.5824 0 c 0.1352 0 0.2448 -0.1144 0.2448 -0.256 C 1.484 -0.1436 1.3744 -0.258 1.2392 -0.258 z"
    };

    function getAllMatches(string, regex) {
      const matches = [];
      let match = regex.exec(string);
      for (; match;) {
        const allmatches = [];
        allmatches.startIndex = regex.lastIndex - match[0].length;
        const len = match.length;
        for (let index = 0; index < len; index++) allmatches.push(match[index]);
        matches.push(allmatches), match = regex.exec(string);
      }
      return matches;
    }

    class XmlNode {
      constructor(tagname) {
        this.tagname = tagname, this.child = [], this[":@"] = {};
      }
      add(key, val) {
        "__proto__" === key && (key = "#__proto__"), this.child.push({
          [key]: val
        });
      }
      addChild(node) {
        "__proto__" === node.tagname && (node.tagname = "#__proto__"), node[":@"] && Object.keys(node[":@"]).length > 0 ? this.child.push({
          [node.tagname]: node.child,
          ":@": node[":@"]
        }) : this.child.push({
          [node.tagname]: node.child
        });
      }
    }
    function findClosingIndex(xmlData, str, i, errMsg) {
      const closingIndex = xmlData.indexOf(str, i);
      if (-1 === closingIndex) throw new Error(errMsg);
      return closingIndex + str.length - 1;
    }
    function tagExpWithClosingIndex(xmlData, i) {
      let closingChar = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ">";
      let attrBoundary,
        tagExp = "";
      for (let index = i; index < xmlData.length; index++) {
        let ch = xmlData[index];
        if (attrBoundary) ch === attrBoundary && (attrBoundary = "");else if ('"' === ch || "'" === ch) attrBoundary = ch;else if (ch === closingChar[0]) {
          if (!closingChar[1]) return {
            data: tagExp,
            index: index
          };
          if (xmlData[index + 1] === closingChar[1]) return {
            data: tagExp,
            index: index
          };
        } else "\t" === ch && (ch = " ");
        tagExp += ch;
      }
    }
    function readTagExp(xmlData, i, removeNSPrefix) {
      let closingChar = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : ">";
      const result = tagExpWithClosingIndex(xmlData, i + 1, closingChar);
      if (!result) return;
      let tagExp = result.data;
      const closeIndex = result.index,
        separatorIndex = tagExp.search(/\s/);
      let tagName = tagExp,
        attrExpPresent = !0;
      -1 !== separatorIndex && (tagName = tagExp.substr(0, separatorIndex).replace(/\s\s*$/, ""), tagExp = tagExp.substr(separatorIndex + 1));
      const rawTagName = tagName;
      if (removeNSPrefix) {
        const colonIndex = tagName.indexOf(":");
        -1 !== colonIndex && (tagName = tagName.substr(colonIndex + 1), attrExpPresent = tagName !== result.data.substr(colonIndex + 1));
      }
      return {
        tagName: tagName,
        tagExp: tagExp,
        closeIndex: closeIndex,
        attrExpPresent: attrExpPresent,
        rawTagName: rawTagName
      };
    }
    const attrsRegx = new RegExp("([^\\s=]+)\\s*(=\\s*(['\"])([\\s\\S]*?)\\3)?", "gm");
    class OrderedObjParser {
      constructor(options) {
        this.currentNode = null, this.options = options, this.tagsNodeStack = [], this.docTypeEntities = {};
      }
      addChild(currentNode, childNode, jPath) {
        const result = childNode.tagname;
        "string" == typeof result ? (childNode.tagname = result, currentNode.addChild(childNode)) : currentNode.addChild(childNode);
      }
      buildAttributesMap(attrStr, jPath, tagName) {
        const attrs = {};
        if (!attrStr) return;
        const matches = getAllMatches(attrStr, attrsRegx),
          len = matches.length;
        for (let i = 0; i < len; i++) {
          const attrName = matches[i][1],
            oldVal = matches[i][4],
            aName = attrName;
          attrName && (attrs[aName] = void 0 === oldVal || (isNaN(oldVal) ? oldVal : Number(oldVal)));
        }
        return attrs;
      }
      parseXml(xmlData) {
        xmlData = xmlData.replace(/\r\n?/g, "\n");
        const xmlObj = new XmlNode("!xml");
        let currentNode = xmlObj,
          textData = "",
          jPath = "";
        for (let i = 0; i < xmlData.length; i++) {
          if ("<" === xmlData[i]) {
            if ("/" === xmlData[i + 1]) {
              const closeIndex = findClosingIndex(xmlData, ">", i, "Closing Tag is not closed."),
                propIndex = jPath.lastIndexOf(".");
              jPath = jPath.substring(0, propIndex), currentNode = this.tagsNodeStack.pop(), currentNode && currentNode.child && textData && currentNode.child[currentNode.child.length - 1][":@"] && (currentNode.child[currentNode.child.length - 1][":@"].text = textData), textData = "", i = closeIndex;
            } else if ("?" === xmlData[i + 1]) {
              i = readTagExp(xmlData, i, !1, "?>").closeIndex + 1;
            } else if ("!--" === xmlData.substr(i + 1, 3)) {
              i = findClosingIndex(xmlData, "--\x3e", i + 4, "Comment is not closed.");
            } else {
              const result = readTagExp(xmlData, i, !1);
              let tagName = result.tagName,
                tagExp = result.tagExp;
              const attrExpPresent = result.attrExpPresent,
                closeIndex = result.closeIndex;
              if (tagName !== xmlObj.tagname && (jPath += jPath ? "." + tagName : tagName), tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
                "/" === tagName[tagName.length - 1] ? (tagName = tagName.substr(0, tagName.length - 1), jPath = jPath.substr(0, jPath.length - 1), tagExp = tagName) : tagExp = tagExp.substr(0, tagExp.length - 1);
                const childNode = new XmlNode(tagName);
                tagName !== tagExp && attrExpPresent && (childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName)), this.addChild(currentNode, childNode, jPath), jPath = jPath.substr(0, jPath.lastIndexOf("."));
              } else {
                const childNode = new XmlNode(tagName);
                this.tagsNodeStack.push(currentNode), tagName !== tagExp && attrExpPresent && (childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName)), this.addChild(currentNode, childNode, jPath), currentNode = childNode;
              }
              textData = "", i = closeIndex;
            }
          } else textData += xmlData[i];
        }
        return xmlObj.child;
      }
    }

    function prettify(node, options) {
      return compress(node);
    }
    function compress(arr, jPath) {
      const compressedObj = {};
      for (let i = 0; i < arr.length; i++) {
        const tagObj = arr[i],
          property = propName(tagObj);
        if (void 0 !== property && tagObj[property]) {
          const val = compress(tagObj[property]);
          isLeafTag(val);
          tagObj[":@"] && assignAttributes(val, tagObj[":@"]), void 0 !== compressedObj[property] && compressedObj.hasOwnProperty(property) ? (Array.isArray(compressedObj[property]) || (compressedObj[property] = [compressedObj[property]]), compressedObj[property].push(val)) : compressedObj[property] = val;
        }
      }
      return compressedObj;
    }
    function propName(obj) {
      const keys = Object.keys(obj);
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        if (":@" !== key) return key;
      }
    }
    function assignAttributes(obj, attrMap, jpath) {
      if (attrMap) {
        const keys = Object.keys(attrMap),
          len = keys.length;
        for (let i = 0; i < len; i++) {
          const atrrName = keys[i];
          obj[atrrName] = attrMap[atrrName];
        }
      }
    }
    function isLeafTag(obj) {
      return 0 === Object.keys(obj).length;
    }

    class XMLParser {
      constructor(options) {
        this.options = Object.assign({}, XMLParser.defaultOptions, options);
      }
      valid(xml) {
        return xml.startsWith("<");
      }
      parse(xmlData) {
        if (!this.valid) return !1;
        const orderedResult = new OrderedObjParser(this.options).parseXml(xmlData);
        return prettify(orderedResult, this.options);
      }
    }
    XMLParser.defaultOptions = {};
    function isSvg(str) {
      return str.startsWith("<svg") || str.startsWith("<?xml");
    }

    undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          var value;
          result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P(function (resolve) {
            resolve(value);
          })).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    function boundStroke(bounds, halfW, miter) {
      let pad = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      return bounds.expand(halfW + (pad / 2 + (miter ? miterAdjustment(miter, halfW) : 0))), bounds;
    }
    function miterAdjustment(miter, strokeWidth) {
      return miter ? strokeWidth : 0;
    }
    let NUMBER_TYPE = 0;
    function genNumberType() {
      return NUMBER_TYPE++;
    }
    var TextDirection;
    !function (TextDirection) {
      TextDirection[TextDirection.HORIZONTAL = 0] = "HORIZONTAL", TextDirection[TextDirection.VERTICAL = 1] = "VERTICAL";
    }(TextDirection || (TextDirection = {}));
    function verticalLayout(text) {
      const nextCharacter = [];
      let flag = 0,
        currStr = "";
      for (let i = 0; i < text.length; i++) rotateText(text[i]) ? flag ? currStr += text[i] : (flag = 1, currStr = text[i]) : (flag && (nextCharacter.push({
        text: currStr,
        direction: TextDirection.VERTICAL
      }), currStr = "", flag = 0), nextCharacter.push({
        text: text[i],
        direction: TextDirection.HORIZONTAL
      }));
      return currStr && nextCharacter.push({
        text: currStr,
        direction: TextDirection.VERTICAL
      }), nextCharacter;
    }
    const rotateCharList = ["…", "（", "）", "—", "【", "】", "「", "」", "《", "》"],
      rotateCharMap = new Map();
    rotateCharList.forEach(c => rotateCharMap.set(c, !0));
    const noRotateCharList = [""],
      noRotateCharMap = new Map();
    function rotateText(c) {
      if (rotateCharMap.has(c)) return !0;
      if (noRotateCharMap.has(c)) return !1;
      let rotate = !1;
      return c.codePointAt(0) < 256 && (rotate = !0), rotate;
    }
    noRotateCharList.forEach(c => noRotateCharMap.set(c, !0));

    const ARC_NUMBER_TYPE = genNumberType();
    const ARC3D_NUMBER_TYPE = genNumberType();
    const AREA_NUMBER_TYPE = genNumberType();
    const CIRCLE_NUMBER_TYPE = genNumberType();
    genNumberType();
    const GROUP_NUMBER_TYPE = genNumberType();
    const IMAGE_NUMBER_TYPE = genNumberType();
    const LINE_NUMBER_TYPE = genNumberType();
    const PATH_NUMBER_TYPE = genNumberType();
    const POLYGON_NUMBER_TYPE = genNumberType();
    genNumberType();
    const RECT_NUMBER_TYPE = genNumberType();
    genNumberType();
    const RICHTEXT_NUMBER_TYPE = genNumberType();
    genNumberType();
    const SYMBOL_NUMBER_TYPE = genNumberType();
    const TEXT_NUMBER_TYPE = genNumberType();
    const GraphicService = Symbol.for("GraphicService");
    const GraphicCreator$1 = Symbol.for("GraphicCreator");
    const SVG_PARSE_ATTRIBUTE_MAP = {
      "stroke-linecap": "lineCap",
      "stroke-linejoin": "lineJoin",
      "stroke-dasharray": "lineDash",
      "stroke-dashoffset": "lineDashOffset",
      "stroke-width": "lineWidth",
      "fill-opacity": "fillOpacity",
      "stroke-opacity": "strokeOpacity",
      stroke: "stroke",
      fill: "fill"
    };
    const SVG_PARSE_ATTRIBUTE_MAP_KEYS = Object.keys(SVG_PARSE_ATTRIBUTE_MAP);

    const _tempBounds$1 = new AABBBounds$1(),
      tempMatrix = new Matrix();
      new AABBBounds$1();
    const GRAPHIC_UPDATE_TAG_KEY = ["lineWidth", "scaleX", "scaleY", "angle", "anchor", "visible"];
    const tempConstantXYKey = ["x", "y"],
      tempConstantScaleXYKey = ["scaleX", "scaleY"],
      tempConstantAngleKey = ["angle"],
      point = new Point();
    const NOWORK_ANIMATE_ATTR = {
      strokeSeg: 1,
      boundsPadding: 2,
      pickMode: 1,
      boundsMode: 1,
      customPickShape: 1,
      pickable: 1,
      childrenPickable: 1,
      visible: 1,
      zIndex: 1,
      layout: 1,
      keepDirIn3d: 1,
      globalZIndex: 1,
      outerBorder: 1,
      innerBorder: 1,
      lineDash: 1,
      lineCap: 1,
      lineJoin: 1,
      miterLimit: 2,
      strokeBoundsBuffer: 2,
      scaleCenter: 1,
      anchor: 1,
      anchor3d: 1,
      postMatrix: 1,
      backgroundMode: 2,
      background: 1,
      texture: 1,
      cursor: 1,
      html: 1
    };
    class Graphic extends Node {
      static mixin(source) {
        const keys = Object.keys(source);
        for (let i = 0; i < keys.length; ++i) {
          const propertyName = keys[i];
          Object.defineProperty(Graphic.prototype, propertyName, Object.getOwnPropertyDescriptor(source, propertyName));
        }
      }
      get AABBBounds() {
        return this.tryUpdateAABBBounds();
      }
      get OBBBounds() {
        return this.tryUpdateOBBBounds();
      }
      get globalAABBBounds() {
        return this.tryUpdateGlobalAABBBounds();
      }
      get transMatrix() {
        return this.tryUpdateLocalTransMatrix(!0);
      }
      get globalTransMatrix() {
        return this.tryUpdateGlobalTransMatrix(!0);
      }
      constructor() {
        let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var _a;
        super(), this._AABBBounds = new AABBBounds$1(), this._updateTag = UpdateTag.INIT, this.attribute = params, this.valid = this.isValid(), this.updateAABBBoundsStamp = 0, params.background ? this.loadImage(null !== (_a = params.background.background) && void 0 !== _a ? _a : params.background, !0) : params.shadowGraphic && this.setShadowGraphic(params.shadowGraphic);
      }
      setMode(mode) {
        "3d" === mode ? this.set3dMode() : this.set2dMode();
      }
      set3dMode() {
        this.in3dMode = !0;
      }
      set2dMode() {
        this.in3dMode = !1;
      }
      getOffsetXY(attr) {
        let includeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
        var _a, _b;
        const {
          dx = attr.dx,
          dy = attr.dy
        } = this.attribute;
        if (includeScroll && this.parent) {
          const attribute = this.parent.attribute;
          point.x = dx + (null !== (_a = attribute.scrollX) && void 0 !== _a ? _a : 0), point.y = dy + (null !== (_b = attribute.scrollY) && void 0 !== _b ? _b : 0);
        } else point.x = dx, point.y = dy;
        return point;
      }
      onAnimateBind(animate) {
        this._emitCustomEvent("animate-bind", animate);
      }
      tryUpdateAABBBounds() {
        const full = "imprecise" === this.attribute.boundsMode;
        if (!this.shouldUpdateAABBBounds()) return this._AABBBounds;
        if (!this.valid) return this._AABBBounds.clear(), this._AABBBounds;
        application.graphicService.beforeUpdateAABBBounds(this, this.stage, !0, this._AABBBounds);
        const bounds = this.doUpdateAABBBounds(full);
        return application.graphicService.afterUpdateAABBBounds(this, this.stage, this._AABBBounds, this, !0), "empty" === this.attribute.boundsMode && bounds.clear(), bounds;
      }
      tryUpdateOBBBounds() {
        if (this._OBBBounds || (this._OBBBounds = new OBBBounds()), this.tryUpdateAABBBounds(), this.updateOBBBoundsStamp === this.updateAABBBoundsStamp) return this._OBBBounds;
        if (this.updateOBBBoundsStamp = this.updateAABBBoundsStamp, !this.valid) return this._OBBBounds.clear(), this._OBBBounds;
        return this.doUpdateOBBBounds();
      }
      combindShadowAABBBounds(bounds) {
        if (this.shadowRoot) {
          const b = this.shadowRoot.AABBBounds.clone();
          bounds.union(b);
        }
      }
      doUpdateOBBBounds() {
        return this._OBBBounds;
      }
      getClipPath() {
        const {
          clipConfig: clipConfig
        } = this.attribute;
        if (!clipConfig) return null;
        this.clipPathMap || (this.clipPathMap = new Map());
        const {
          shape: shape
        } = clipConfig;
        let path = this.clipPathMap.get(shape) || null;
        return path || (this.clipPathMap.size > 10 && this.clipPathMap.clear(), path = this.parsePath(shape), path && this.clipPathMap.set(shape, path)), path;
      }
      parsePath(symbolType) {
        if (!symbolType) return null;
        let path = builtinSymbolsMap[symbolType];
        if (path) return path;
        if (path = Graphic.userSymbolMap[symbolType], path) return path;
        const _symbolType = builtInSymbolStrMap[symbolType];
        if (!0 === isSvg(symbolType = _symbolType || symbolType)) {
          const parser = new XMLParser(),
            {
              svg: svg
            } = parser.parse(symbolType);
          if (!svg) return null;
          const path = isArray$9(svg.path) ? svg.path : [svg.path];
          _tempBounds$1.clear();
          const cacheList = [];
          path.forEach(item => {
            const cache = new CustomPath2D().fromString(item.d),
              attribute = {};
            SVG_PARSE_ATTRIBUTE_MAP_KEYS.forEach(k => {
              item[k] && (attribute[SVG_PARSE_ATTRIBUTE_MAP[k]] = item[k]);
            }), cacheList.push({
              path: cache,
              attribute: attribute
            }), _tempBounds$1.union(cache.bounds);
          });
          const width = _tempBounds$1.width(),
            height = _tempBounds$1.height(),
            scale = 1 / max(width, height);
          cacheList.forEach(cache => cache.path.transform(0, 0, scale, scale));
          const _parsedPath = new CustomSymbolClass(symbolType, cacheList, !0);
          return Graphic.userSymbolMap[symbolType] = _parsedPath, _parsedPath;
        }
        const cache = new CustomPath2D().fromString(symbolType),
          width = cache.bounds.width(),
          height = cache.bounds.height(),
          scale = 1 / max(width, height);
        cache.transform(0, 0, scale, scale);
        const _parsedPath = new CustomSymbolClass(symbolType, cache);
        return Graphic.userSymbolMap[symbolType] = _parsedPath, _parsedPath;
      }
      doUpdateAABBBounds(full) {
        this.updateAABBBoundsStamp++;
        const graphicTheme = this.getGraphicTheme();
        this._AABBBounds.clear();
        const attribute = this.attribute,
          bounds = this.updateAABBBounds(attribute, graphicTheme, this._AABBBounds, full),
          {
            boundsPadding = graphicTheme.boundsPadding
          } = attribute,
          paddingArray = parsePadding(boundsPadding);
        return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), bounds;
      }
      updatePathProxyAABBBounds(aabbBounds) {
        const path = "function" == typeof this.pathProxy ? this.pathProxy(this.attribute) : this.pathProxy;
        if (!path) return !1;
        const boundsContext = new BoundsContext(aabbBounds);
        return renderCommandList(path.commandList, boundsContext, 0, 0), !0;
      }
      tryUpdateGlobalAABBBounds() {
        const b = this.AABBBounds;
        return this._globalAABBBounds ? this._globalAABBBounds.setValue(b.x1, b.y1, b.x2, b.y2) : this._globalAABBBounds = b.clone(), this._globalAABBBounds.empty() || this.parent && this._globalAABBBounds.transformWithMatrix(this.parent.globalTransMatrix), this._globalAABBBounds;
      }
      tryUpdateGlobalTransMatrix() {
        if (this._globalTransMatrix) {
          if (this.parent) {
            const m = this.parent.globalTransMatrix;
            this._globalTransMatrix.setValue(m.a, m.b, m.c, m.d, m.e, m.f);
          }
        } else this._globalTransMatrix = this.parent ? this.parent.globalTransMatrix.clone() : this.transMatrix.clone();
        return this.shouldUpdateGlobalMatrix() && this.doUpdateGlobalMatrix(), this._globalTransMatrix;
      }
      shouldUpdateGlobalMatrix() {
        return !0;
      }
      tryUpdateLocalTransMatrix() {
        let clearTag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !0;
        return this._transMatrix || (this._transMatrix = new Matrix()), this.shouldUpdateLocalMatrix() && (this.doUpdateLocalMatrix(), clearTag && this.clearUpdateLocalPositionTag()), this._transMatrix;
      }
      shouldUpdateAABBBounds() {
        return this.shadowRoot ? (!!(this._updateTag & UpdateTag.UPDATE_BOUNDS) || this.shadowRoot.shouldUpdateAABBBounds()) && application.graphicService.validCheck(this.attribute, this.getGraphicTheme(), this._AABBBounds, this) : !!(this._updateTag & UpdateTag.UPDATE_BOUNDS) && application.graphicService.validCheck(this.attribute, this.getGraphicTheme(), this._AABBBounds, this);
      }
      shouldSelfChangeUpdateAABBBounds() {
        return this.shadowRoot ? !!(this._updateTag & UpdateTag.UPDATE_BOUNDS) || this.shadowRoot.shouldUpdateAABBBounds() : !!(this._updateTag & UpdateTag.UPDATE_BOUNDS);
      }
      shouldUpdateLocalMatrix() {
        return !!(this._updateTag & UpdateTag.UPDATE_LOCAL_MATRIX);
      }
      isValid() {
        var _a, _b;
        const attribute = this.attribute;
        return Number.isFinite((null !== (_a = attribute.x) && void 0 !== _a ? _a : 0) + (null !== (_b = attribute.y) && void 0 !== _b ? _b : 0));
      }
      _validNumber(num) {
        return null == num || Number.isFinite(num);
      }
      shouldUpdateShape() {
        return !!(this._updateTag & UpdateTag.UPDATE_SHAPE);
      }
      clearUpdateShapeTag() {
        this._updateTag &= UpdateTag.CLEAR_SHAPE;
      }
      containsPoint(x, y, mode, picker) {
        if (!picker) return !1;
        if (mode === IContainPointMode.GLOBAL) {
          const point = new Point(x, y);
          this.parent && this.parent.globalTransMatrix.transformPoint(point, point), x = point.x, y = point.y;
        }
        return picker.containsPoint(this, {
          x: x,
          y: y
        });
      }
      setWidthHeightWithoutTransform(aabbBounds) {
        this.widthWithoutTransform = aabbBounds.x2 - aabbBounds.x1, this.heightWithoutTransform = aabbBounds.y2 - aabbBounds.y1;
      }
      setAttributes(params) {
        let forceUpdateTag = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
        let context = arguments.length > 2 ? arguments[2] : undefined;
        (params = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate(params, this.attribute, null, context) || params).background ? this.loadImage(params.background, !0) : params.shadowGraphic && this.setShadowGraphic(params.shadowGraphic), this._setAttributes(params, forceUpdateTag, context);
      }
      _setAttributes(params) {
        let forceUpdateTag = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
        let context = arguments.length > 2 ? arguments[2] : undefined;
        const keys = Object.keys(params);
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          this.attribute[key] = params[key];
        }
        this.valid = this.isValid(), this.updateShapeAndBoundsTagSetted() || !forceUpdateTag && !this.needUpdateTags(keys) ? this.addUpdateBoundTag() : this.addUpdateShapeAndBoundsTag(), this.addUpdatePositionTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context);
      }
      setAttribute(key, value, forceUpdateTag, context) {
        var _a;
        const params = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({
          [key]: value
        }, this.attribute, key, context);
        params ? this._setAttributes(params, forceUpdateTag, context) : isNil$5(null === (_a = this.normalAttrs) || void 0 === _a ? void 0 : _a[key]) ? (this.attribute[key] = value, this.valid = this.isValid(), this.updateShapeAndBoundsTagSetted() || !forceUpdateTag && !this.needUpdateTag(key) ? this.addUpdateBoundTag() : this.addUpdateShapeAndBoundsTag(), this.addUpdatePositionTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context)) : this.normalAttrs[key] = value, "background" === key ? this.loadImage(value, !0) : "shadowGraphic" === key && this.setShadowGraphic(value);
      }
      needUpdateTags(keys) {
        let k = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : GRAPHIC_UPDATE_TAG_KEY;
        for (let i = 0; i < k.length; i++) {
          const attrKey = k[i];
          if (-1 !== keys.indexOf(attrKey)) return !0;
        }
        return !1;
      }
      needUpdateTag(key) {
        let k = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : GRAPHIC_UPDATE_TAG_KEY;
        for (let i = 0; i < k.length; i++) {
          if (key === k[i]) return !0;
        }
        return !1;
      }
      initAttributes(params) {
        const context = {
          type: AttributeUpdateType.INIT
        };
        params = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate(params, this.attribute, null, context) || params, this.attribute = params, params.background ? this.loadImage(params.background, !0) : params.shadowGraphic && this.setShadowGraphic(params.shadowGraphic), this._updateTag = UpdateTag.INIT, this.valid = this.isValid(), this.onAttributeUpdate(context);
      }
      translate(x, y) {
        var _a, _b;
        if (0 === x && 0 === y) return this;
        const context = {
            type: AttributeUpdateType.TRANSLATE
          },
          params = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({
            x: x,
            y: y
          }, this.attribute, tempConstantXYKey, context);
        params && (x = params.x, y = params.y, delete params.x, delete params.y, this._setAttributes(params));
        const attribute = this.attribute,
          postMatrix = attribute.postMatrix;
        return postMatrix ? application.transformUtil.fromMatrix(postMatrix, postMatrix).translate(x, y) : (attribute.x = (null !== (_a = attribute.x) && void 0 !== _a ? _a : DefaultTransform.x) + x, attribute.y = (null !== (_b = attribute.y) && void 0 !== _b ? _b : DefaultTransform.y) + y), this.addUpdatePositionTag(), this.addUpdateBoundTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context), this;
      }
      translateTo(x, y) {
        const attribute = this.attribute;
        if (attribute.x === x && attribute.y === y) return this;
        const context = {
            type: AttributeUpdateType.TRANSLATE_TO
          },
          params = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({
            x: x,
            y: y
          }, this.attribute, tempConstantXYKey, context);
        return params ? (this._setAttributes(params, !1, context), this) : (attribute.x = x, attribute.y = y, this.addUpdatePositionTag(), this.addUpdateBoundTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context), this);
      }
      scale(scaleX, scaleY, scaleCenter) {
        var _a, _b;
        if (1 === scaleX && 1 === scaleY) return this;
        const context = {
            type: AttributeUpdateType.SCALE
          },
          params = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({
            scaleX: scaleX,
            scaleY: scaleY,
            scaleCenter: scaleCenter
          }, this.attribute, tempConstantScaleXYKey, context);
        params && (scaleX = params.scaleX, scaleY = params.scaleY, delete params.scaleX, delete params.scaleY, this._setAttributes(params));
        const attribute = this.attribute;
        if (scaleCenter) {
          let {
            postMatrix: postMatrix
          } = this.attribute;
          postMatrix || (postMatrix = new Matrix(), attribute.postMatrix = postMatrix), application.transformUtil.fromMatrix(postMatrix, postMatrix).scale(scaleX, scaleY, scaleCenter);
        } else attribute.scaleX = (null !== (_a = attribute.scaleX) && void 0 !== _a ? _a : DefaultTransform.scaleX) * scaleX, attribute.scaleY = (null !== (_b = attribute.scaleY) && void 0 !== _b ? _b : DefaultTransform.scaleY) * scaleY;
        return this.addUpdatePositionTag(), this.addUpdateBoundTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context), this;
      }
      scaleTo(scaleX, scaleY) {
        const attribute = this.attribute;
        if (attribute.scaleX === scaleX && attribute.scaleY === scaleY) return this;
        const context = {
            type: AttributeUpdateType.SCALE_TO
          },
          params = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({
            scaleX: scaleX,
            scaleY: scaleY
          }, this.attribute, tempConstantScaleXYKey, context);
        return params ? (this._setAttributes(params, !1, context), this) : (attribute.scaleX = scaleX, attribute.scaleY = scaleY, this.addUpdatePositionTag(), this.addUpdateBoundTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context), this);
      }
      rotate(angle, rotateCenter) {
        var _a;
        if (0 === angle) return this;
        const context = {
            type: AttributeUpdateType.ROTATE
          },
          params = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({
            angle: angle,
            rotateCenter: rotateCenter
          }, this.attribute, tempConstantAngleKey, context);
        params && (delete params.angle, this._setAttributes(params, !1, context));
        const attribute = this.attribute;
        if (rotateCenter) {
          let {
            postMatrix: postMatrix
          } = this.attribute;
          postMatrix || (postMatrix = new Matrix(), attribute.postMatrix = postMatrix), application.transformUtil.fromMatrix(postMatrix, postMatrix).rotate(angle, rotateCenter);
        } else attribute.angle = (null !== (_a = attribute.angle) && void 0 !== _a ? _a : DefaultTransform.angle) + angle;
        return this.addUpdatePositionTag(), this.addUpdateBoundTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context), this;
      }
      rotateTo(angle) {
        const attribute = this.attribute;
        if (attribute.angle === angle) return this;
        const context = {
            type: AttributeUpdateType.ROTATE_TO
          },
          params = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate(angle, this.attribute, tempConstantAngleKey, context);
        return params ? (this._setAttributes(params, !1, context), this) : (attribute.angle = angle, this.addUpdatePositionTag(), this.addUpdateBoundTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context), this);
      }
      skewTo(b, c) {
        return this;
      }
      animate(params) {
        var _a;
        this.animates || (this.animates = new Map());
        const animate = new Animate(null == params ? void 0 : params.id, null !== (_a = null == params ? void 0 : params.timeline) && void 0 !== _a ? _a : this.stage && this.stage.getTimeline(), null == params ? void 0 : params.slience);
        if (animate.bind(this), params) {
          const {
            onStart: onStart,
            onFrame: onFrame,
            onEnd: onEnd,
            onRemove: onRemove
          } = params;
          null != onStart && animate.onStart(onStart), null != onFrame && animate.onFrame(onFrame), null != onEnd && animate.onEnd(onEnd), null != onRemove && animate.onRemove(onRemove), animate.interpolateFunc = params.interpolate;
        }
        return this.animates.set(animate.id, animate), animate.onRemove(() => {
          animate.stop(), this.animates.delete(animate.id);
        }), animate;
      }
      onAttributeUpdate(context) {
        context && context.skipUpdateCallback || (application.graphicService.onAttributeUpdate(this), this._emitCustomEvent("afterAttributeUpdate", context));
      }
      update(d) {
        d ? (d.bounds && this.tryUpdateAABBBounds(), d.trans && this.tryUpdateLocalTransMatrix()) : (this.tryUpdateAABBBounds(), this.tryUpdateLocalTransMatrix());
      }
      hasState(stateName) {
        return !(!this.currentStates || !this.currentStates.length) && (!!isNil$5(stateName) || this.currentStates.includes(stateName));
      }
      getState(stateName) {
        var _a;
        return null === (_a = this.states) || void 0 === _a ? void 0 : _a[stateName];
      }
      applyStateAttrs(attrs, stateNames, hasAnimation, isClear) {
        var _a, _b, _c, _d;
        if (hasAnimation) {
          const keys = Object.keys(attrs),
            noWorkAttrs = this.getNoWorkAnimateAttr(),
            animateAttrs = {};
          let noAnimateAttrs;
          keys.forEach(key => {
            noWorkAttrs[key] ? (noAnimateAttrs || (noAnimateAttrs = {}), noAnimateAttrs[key] = attrs[key]) : animateAttrs[key] = isClear && void 0 === attrs[key] ? this.getDefaultAttribute(key) : attrs[key];
          });
          const animate = this.animate({
            slience: !0
          });
          animate.stateNames = stateNames, animate.to(animateAttrs, null !== (_b = null === (_a = this.stateAnimateConfig) || void 0 === _a ? void 0 : _a.duration) && void 0 !== _b ? _b : DefaultStateAnimateConfig.duration, null !== (_d = null === (_c = this.stateAnimateConfig) || void 0 === _c ? void 0 : _c.easing) && void 0 !== _d ? _d : DefaultStateAnimateConfig.easing), noAnimateAttrs && this.setAttributes(noAnimateAttrs, !1, {
            type: AttributeUpdateType.STATE
          });
        } else this.stopStateAnimates(), this.setAttributes(attrs, !1, {
          type: AttributeUpdateType.STATE
        });
      }
      updateNormalAttrs(stateAttrs) {
        const newNormalAttrs = {};
        this.normalAttrs ? (Object.keys(stateAttrs).forEach(key => {
          key in this.normalAttrs ? (newNormalAttrs[key] = this.normalAttrs[key], delete this.normalAttrs[key]) : newNormalAttrs[key] = this.getNormalAttribute(key);
        }), Object.keys(this.normalAttrs).forEach(key => {
          stateAttrs[key] = this.normalAttrs[key];
        })) : Object.keys(stateAttrs).forEach(key => {
          newNormalAttrs[key] = this.getNormalAttribute(key);
        }), this.normalAttrs = newNormalAttrs;
      }
      stopStateAnimates() {
        let type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "end";
        this.animates && this.animates.forEach(animate => {
          animate.stateNames && (animate.stop(type), this.animates.delete(animate.id));
        });
      }
      getNormalAttribute(key) {
        let value = this.attribute[key];
        return this.animates && this.animates.forEach(animate => {
          if (animate.stateNames) {
            const endProps = animate.getEndProps();
            has$1(endProps, key) && (value = endProps[key]);
          }
        }), value;
      }
      clearStates(hasAnimation) {
        this.hasState() && this.normalAttrs ? (this.currentStates = [], this.applyStateAttrs(this.normalAttrs, this.currentStates, hasAnimation, !0)) : this.currentStates = [], this.normalAttrs = null;
      }
      removeState(stateName, hasAnimation) {
        if (this.currentStates) {
          const filter = isArray$9(stateName) ? s => !stateName.includes(s) : s => s !== stateName,
            newStates = this.currentStates.filter(filter);
          newStates.length !== this.currentStates.length && this.useStates(newStates, hasAnimation);
        }
      }
      toggleState(stateName, hasAnimation) {
        if (this.hasState(stateName)) this.removeState(stateName, hasAnimation);else {
          if ((this.currentStates ? this.currentStates.indexOf(stateName) : -1) < 0) {
            const nextStates = this.currentStates ? this.currentStates.slice() : [];
            nextStates.push(stateName), this.useStates(nextStates, hasAnimation);
          }
        }
      }
      addState(stateName, keepCurrentStates, hasAnimation) {
        var _a;
        if (this.currentStates && this.currentStates.includes(stateName) && (keepCurrentStates || 1 === this.currentStates.length)) return;
        const newStates = keepCurrentStates && (null === (_a = this.currentStates) || void 0 === _a ? void 0 : _a.length) ? this.currentStates.concat([stateName]) : [stateName];
        this.useStates(newStates, hasAnimation);
      }
      useStates(states, hasAnimation) {
        var _a;
        if (!states.length) return void this.clearStates(hasAnimation);
        if (!((null === (_a = this.currentStates) || void 0 === _a ? void 0 : _a.length) !== states.length || states.some((stateName, index) => this.currentStates[index] !== stateName))) return;
        const stateAttrs = {};
        states.forEach(stateName => {
          var _a;
          const attrs = this.stateProxy ? this.stateProxy(stateName, states) : null === (_a = this.states) || void 0 === _a ? void 0 : _a[stateName];
          attrs && Object.assign(stateAttrs, attrs);
        }), this.updateNormalAttrs(stateAttrs), this.currentStates = states, this.applyStateAttrs(stateAttrs, states, hasAnimation);
      }
      addUpdateBoundTag() {
        this._updateTag |= UpdateTag.UPDATE_BOUNDS, this.parent && this.parent.addChildUpdateBoundTag(), this.glyphHost && this.glyphHost.addUpdateBoundTag();
      }
      addUpdateShapeTag() {
        this._updateTag |= UpdateTag.UPDATE_SHAPE;
      }
      addUpdateShapeAndBoundsTag() {
        this._updateTag |= UpdateTag.UPDATE_SHAPE_AND_BOUNDS, this.parent && this.parent.addChildUpdateBoundTag(), this.glyphHost && this.glyphHost.addUpdateBoundTag();
      }
      updateShapeAndBoundsTagSetted() {
        return (this._updateTag & UpdateTag.UPDATE_SHAPE_AND_BOUNDS) === UpdateTag.UPDATE_SHAPE_AND_BOUNDS;
      }
      clearUpdateBoundTag() {
        this._updateTag &= UpdateTag.CLEAR_BOUNDS;
      }
      addUpdatePositionTag() {
        this.shadowRoot && this.shadowRoot.addUpdateGlobalPositionTag(), this._updateTag |= UpdateTag.UPDATE_GLOBAL_LOCAL_MATRIX;
      }
      addUpdateGlobalPositionTag() {
        this.shadowRoot && this.shadowRoot.addUpdateGlobalPositionTag(), this._updateTag |= UpdateTag.UPDATE_GLOBAL_MATRIX;
      }
      clearUpdateLocalPositionTag() {
        this._updateTag &= UpdateTag.CLEAR_LOCAL_MATRIX;
      }
      clearUpdateGlobalPositionTag() {
        this._updateTag &= UpdateTag.CLEAR_GLOBAL_MATRIX;
      }
      addUpdateLayoutTag() {
        this._updateTag |= UpdateTag.UPDATE_LAYOUT;
      }
      clearUpdateLayoutTag() {
        this._updateTag &= UpdateTag.CLEAR_LAYOUT;
      }
      needUpdateLayout() {
        return !!(this._updateTag & UpdateTag.UPDATE_LAYOUT);
      }
      getAnchor(anchor, params, resetScale) {
        const _anchor = [0, 0],
          getBounds = () => {
            if (params.b) return params.b;
            const graphic = this.clone();
            return graphic.attribute.angle = 0, graphic.attribute.scaleCenter = null, resetScale && (graphic.attribute.scaleX = 1, graphic.attribute.scaleY = 1), params.b = graphic.AABBBounds, params.b;
          };
        if ("string" == typeof anchor[0]) {
          const ratio = parseFloat(anchor[0]) / 100,
            bounds = getBounds();
          _anchor[0] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
        } else _anchor[0] = anchor[0];
        if ("string" == typeof anchor[1]) {
          const ratio = parseFloat(anchor[1]) / 100,
            bounds = getBounds();
          _anchor[1] = bounds.y1 + (bounds.y2 - bounds.y1) * ratio;
        } else _anchor[1] = anchor[1];
        return _anchor;
      }
      doUpdateLocalMatrix() {
        const {
          x = DefaultTransform.x,
          y = DefaultTransform.y,
          scaleX = DefaultTransform.scaleX,
          scaleY = DefaultTransform.scaleY,
          angle = DefaultTransform.angle,
          scaleCenter: scaleCenter,
          anchor: anchor,
          postMatrix: postMatrix
        } = this.attribute;
        let _anchor = [0, 0];
        const params = {};
        if (anchor && angle && (_anchor = this.getAnchor(anchor, params)), !scaleCenter || 1 === scaleX && 1 === scaleY) normalTransform(this._transMatrix, this._transMatrix.reset(), x, y, scaleX, scaleY, angle, anchor && _anchor);else {
          const m = this._transMatrix;
          m.reset(), m.translate(_anchor[0], _anchor[1]), m.rotate(angle), m.translate(-_anchor[0], -_anchor[1]), m.translate(x, y), _anchor = this.getAnchor(scaleCenter, params, !0), application.transformUtil.fromMatrix(m, m).scale(scaleX, scaleY, {
            x: _anchor[0],
            y: _anchor[1]
          });
        }
        const p = this.getOffsetXY(DefaultTransform);
        if (this._transMatrix.e += p.x, this._transMatrix.f += p.y, postMatrix) {
          const m1 = tempMatrix.setValue(postMatrix.a, postMatrix.b, postMatrix.c, postMatrix.d, postMatrix.e, postMatrix.f),
            m2 = this._transMatrix;
          m1.multiply(m2.a, m2.b, m2.c, m2.d, m2.e, m2.f), m2.setValue(m1.a, m1.b, m1.c, m1.d, m1.e, m1.f);
        }
      }
      doUpdateGlobalMatrix() {
        if (this.parent) {
          this._globalTransMatrix.multiply(this.transMatrix.a, this.transMatrix.b, this.transMatrix.c, this.transMatrix.d, this.transMatrix.e, this.transMatrix.f);
          const {
            scrollX = 0,
            scrollY = 0
          } = this.parent.attribute;
          this._globalTransMatrix.translate(scrollX, scrollY);
        }
      }
      setStage(stage, layer) {
        if (this.stage !== stage) {
          if (this.stage = stage, this.layer = layer, this.setStageToShadowRoot(stage, layer), this.animates && this.animates.size) {
            const timeline = stage.getTimeline();
            this.animates.forEach(a => {
              a.timeline === defaultTimeline && a.setTimeline(timeline);
            });
          }
          this._onSetStage && this._onSetStage(this, stage, layer), application.graphicService.onSetStage(this, stage);
        }
      }
      setStageToShadowRoot(stage, layer) {
        this.shadowRoot && this.shadowRoot.setStage(stage, layer);
      }
      onAddStep(step) {}
      onStop(props) {
        props && this.setAttributes(props, !1, {
          type: AttributeUpdateType.ANIMATE_END
        });
      }
      onStep(subAnimate, animate, step, ratio, end) {
        const nextAttributes = {};
        if (step.customAnimate) step.customAnimate.update(end, ratio, nextAttributes);else {
          const nextProps = step.props,
            nextParsedProps = step.parsedProps,
            propKeys = step.propKeys;
          this.stepInterpolate(subAnimate, animate, nextAttributes, step, ratio, end, nextProps, void 0, nextParsedProps, propKeys);
        }
        this.setAttributes(nextAttributes, !1, {
          type: AttributeUpdateType.ANIMATE_UPDATE,
          animationState: {
            ratio: ratio,
            end: end,
            step: step,
            isFirstFrameOfStep: subAnimate.getLastStep() !== step
          }
        }), this.stage && this.stage.renderNextFrame();
      }
      stepInterpolate(subAnimate, animate, nextAttributes, step, ratio, end, nextProps, lastProps, nextParsedProps, propKeys) {
        propKeys || (propKeys = Object.keys(nextProps), step.propKeys = propKeys), end ? step.propKeys.forEach(key => {
          animate.validAttr(key) && (nextAttributes[key] = nextProps[key]);
        }) : propKeys.forEach(key => {
          var _a;
          if (!animate.validAttr(key)) return;
          const nextStepVal = nextProps[key],
            lastStepVal = null !== (_a = lastProps && lastProps[key]) && void 0 !== _a ? _a : subAnimate.getLastPropByName(key, step);
          if (null == nextStepVal || null == lastStepVal || nextStepVal === lastStepVal) return void (nextAttributes[key] = nextStepVal);
          let match;
          match = animate.interpolateFunc && animate.interpolateFunc(key, ratio, lastStepVal, nextStepVal, nextAttributes), match || (match = animate.customInterpolate(key, ratio, lastStepVal, nextStepVal, this, nextAttributes), match || this.defaultInterpolate(nextStepVal, lastStepVal, key, nextAttributes, nextParsedProps, ratio) || this._interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes));
        }), step.parsedProps = nextParsedProps;
      }
      defaultInterpolate(nextStepVal, lastStepVal, key, nextAttributes, nextParsedProps, ratio) {
        if (Number.isFinite(nextStepVal) && Number.isFinite(lastStepVal)) return nextAttributes[key] = lastStepVal + (nextStepVal - lastStepVal) * ratio, !0;
        if ("fill" === key) {
          nextParsedProps || (nextParsedProps = {});
          const fillColorArray = nextParsedProps.fillColorArray,
            color = interpolateColor(lastStepVal, null != fillColorArray ? fillColorArray : nextStepVal, ratio, !1, (fArray, tArray) => {
              nextParsedProps.fillColorArray = tArray;
            });
          return color && (nextAttributes[key] = color), !0;
        }
        if ("stroke" === key) {
          nextParsedProps || (nextParsedProps = {});
          const strokeColorArray = nextParsedProps.strokeColorArray,
            color = interpolateColor(lastStepVal, null != strokeColorArray ? strokeColorArray : nextStepVal, ratio, !1, (fArray, tArray) => {
              nextParsedProps.strokeColorArray = tArray;
            });
          return color && (nextAttributes[key] = color), !0;
        }
        if ("shadowColor" === key) {
          nextParsedProps || (nextParsedProps = {});
          const shadowColorArray = nextParsedProps.shadowColorArray,
            color = interpolateColor(lastStepVal, null != shadowColorArray ? shadowColorArray : nextStepVal, ratio, !0, (fArray, tArray) => {
              nextParsedProps.shadowColorArray = tArray;
            });
          return color && (nextAttributes[key] = color), !0;
        }
        if (Array.isArray(nextStepVal) && nextStepVal.length === lastStepVal.length) {
          const nextList = [];
          let valid = !0;
          for (let i = 0; i < nextStepVal.length; i++) {
            const v = lastStepVal[i],
              val = v + (nextStepVal[i] - v) * ratio;
            if (!Number.isFinite(val)) {
              valid = !1;
              break;
            }
            nextList.push(val);
          }
          valid && (nextAttributes[key] = nextList);
        }
        return !1;
      }
      _interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes) {}
      getDefaultAttribute(name) {
        return this.getGraphicTheme()[name];
      }
      getComputedAttribute(name) {
        var _a;
        return null !== (_a = this.attribute[name]) && void 0 !== _a ? _a : this.getDefaultAttribute(name);
      }
      onSetStage(cb) {
        let immediate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
        this._onSetStage = cb, immediate && this.stage && cb(this, this.stage);
      }
      attachShadow(shadowRoot) {
        return shadowRoot && (shadowRoot.shadowHost = this), this.shadowRoot = null != shadowRoot ? shadowRoot : application.graphicService.creator.shadowRoot(this), this.addUpdateBoundTag(), this.shadowRoot.setStage(this.stage, this.layer), this.shadowRoot;
      }
      detachShadow() {
        this.shadowRoot && (this.addUpdateBoundTag(), this.shadowRoot.release(!0), this.shadowRoot = null);
      }
      toJson() {
        return {
          attribute: this.attribute,
          _uid: this._uid,
          type: this.type,
          name: this.name,
          children: this.children.map(item => item.toJson())
        };
      }
      createPathProxy(path) {
        return isString$6(path, !0) ? this.pathProxy = new CustomPath2D().fromString(path) : this.pathProxy = new CustomPath2D(), this.pathProxy;
      }
      loadImage(image) {
        let background = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
        if (!image || background && backgroundNotImage(image)) return;
        const url = image;
        this.resources || (this.resources = new Map());
        const cache = {
          data: "init",
          state: null
        };
        this.resources.set(url, cache), "string" == typeof image ? (cache.state = "loading", image.startsWith("<svg") ? (ResourceLoader.GetSvg(image, this), this.backgroundImg = this.backgroundImg || background) : (isValidUrl$1(image) || image.includes("/") || isBase64$1(image)) && (ResourceLoader.GetImage(image, this), this.backgroundImg = this.backgroundImg || background)) : isObject$9(image) ? (cache.state = "success", cache.data = image, this.backgroundImg = this.backgroundImg || background) : cache.state = "fail";
      }
      setShadowGraphic(graphic) {
        if (graphic) {
          this.attachShadow().add(graphic);
        } else this.detachShadow();
      }
      imageLoadSuccess(url, image, cb) {
        if (!this.resources) return;
        const res = this.resources.get(url);
        res && (res.state = "success", res.data = image, cb && cb(), this.addUpdateBoundTag(), this.stage && this.stage.renderNextFrame());
      }
      imageLoadFail(url, cb) {
        if (!this.resources) return;
        const res = this.resources.get(url);
        res && (res.state = "fail", cb && cb());
      }
      _stopAnimates(animates) {
        animates && animates.forEach(animate => {
          animate.stop();
        });
      }
      stopAnimates() {
        let stopChildren = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !1;
        this._stopAnimates(this.animates), this.shadowRoot && this.shadowRoot.stopAnimates(!0), this.isContainer && stopChildren && this.forEachChildren(c => {
          c.stopAnimates(stopChildren);
        });
      }
      release() {
        this.releaseStatus = "released", this.stopAnimates(), application.graphicService.onRelease(this);
      }
      _emitCustomEvent(type, context) {
        var _a, _b;
        if (this._events && type in this._events) {
          const changeEvent = new CustomEvent(type, context);
          changeEvent.bubbles = !1, changeEvent.manager = null === (_b = null === (_a = this.stage) || void 0 === _a ? void 0 : _a.eventSystem) || void 0 === _b ? void 0 : _b.manager, this.dispatchEvent(changeEvent);
        }
      }
    }
    function backgroundNotImage(image) {
      return !(!image.fill && !image.stroke);
    }
    Graphic.userSymbolMap = {}, Graphic.mixin(EventTarget$2);

    var GroupUpdateAABBBoundsMode;
    !function (GroupUpdateAABBBoundsMode) {
      GroupUpdateAABBBoundsMode[GroupUpdateAABBBoundsMode.LESS_GROUP = 0] = "LESS_GROUP", GroupUpdateAABBBoundsMode[GroupUpdateAABBBoundsMode.MORE_GROUP = 1] = "MORE_GROUP";
    }(GroupUpdateAABBBoundsMode || (GroupUpdateAABBBoundsMode = {}));
    let Group$2 = class Group extends Graphic {
      constructor(params) {
        super(params), this.type = "group", this.parent = null, this.isContainer = !0, this.numberType = GROUP_NUMBER_TYPE, this._childUpdateTag = UpdateTag.UPDATE_BOUNDS;
      }
      setMode(mode) {
        "3d" === mode ? this.set3dMode() : this.set2dMode();
      }
      set3dMode() {
        this.in3dMode = !0;
      }
      set2dMode() {
        this.in3dMode = !1;
      }
      setTheme(t) {
        return this.theme || (this.theme = new Theme()), this.theme.setTheme(t, this);
      }
      createTheme() {
        this.theme || (this.theme = new Theme());
      }
      visibleAll(visible) {
        this.setAttribute("visible", visible), this.forEachChildren(item => {
          item.isContainer && item.visibleAll ? item.visibleAll(visible) : item.setAttribute("visible", visible);
        });
      }
      hideAll() {
        this.visibleAll(!1);
      }
      showAll() {
        this.visibleAll(!0);
      }
      containsPoint(x, y, mode) {
        if (mode === IContainPointMode.GLOBAL) {
          const point = new Point(x, y);
          return this.parent && this.parent.globalTransMatrix.transformPoint(point, point), this.AABBBounds.contains(point.x, point.y);
        }
        return this.AABBBounds.contains(x, y);
      }
      shouldUpdateAABBBounds() {
        return !!super.shouldUpdateAABBBounds() || !!(this._childUpdateTag & UpdateTag.UPDATE_BOUNDS);
      }
      tryUpdateAABBBounds() {
        if (!this.shouldUpdateAABBBounds()) return this._AABBBounds;
        application.graphicService.beforeUpdateAABBBounds(this, this.stage, !0, this._AABBBounds);
        const selfChange = this.shouldSelfChangeUpdateAABBBounds(),
          bounds = this.doUpdateAABBBounds();
        return this.addUpdateLayoutTag(), application.graphicService.afterUpdateAABBBounds(this, this.stage, this._AABBBounds, this, selfChange), "empty" === this.attribute.boundsMode && bounds.clear(), bounds;
      }
      doUpdateLocalMatrix() {
        const {
          x = DefaultTransform.x,
          y = DefaultTransform.y,
          dx = DefaultTransform.dx,
          dy = DefaultTransform.dy,
          scaleX = DefaultTransform.scaleX,
          scaleY = DefaultTransform.scaleY,
          angle = DefaultTransform.angle,
          postMatrix: postMatrix
        } = this.attribute;
        if (0 !== x || 0 !== y || 0 !== dx || 0 !== dy || 1 !== scaleX || 1 !== scaleY || 0 !== angle || postMatrix) return super.doUpdateLocalMatrix();
        this._transMatrix.reset();
      }
      getGraphicTheme() {
        return getTheme(this).group;
      }
      updateAABBBounds(attribute, groupTheme, aabbBounds) {
        const originalAABBBounds = aabbBounds;
        aabbBounds = aabbBounds.clone();
        const {
          width: width,
          height: height,
          path: path,
          clip = groupTheme.clip
        } = attribute;
        if (path && path.length ? path.forEach(g => {
          aabbBounds.union(g.AABBBounds);
        }) : null != width && null != height && aabbBounds.set(0, 0, Math.max(0, width), Math.max(0, height)), !clip) {
          this.forEachChildren(node => {
            aabbBounds.union(node.AABBBounds);
          });
          const {
            scrollX = 0,
            scrollY = 0
          } = attribute;
          aabbBounds.translate(scrollX, scrollY);
        }
        return application.graphicService.updateTempAABBBounds(aabbBounds), application.graphicService.transformAABBBounds(attribute, aabbBounds, groupTheme, !1, this), originalAABBBounds.copy(aabbBounds), originalAABBBounds;
      }
      doUpdateAABBBounds() {
        this.updateAABBBoundsStamp++;
        const bounds = super.doUpdateAABBBounds();
        return this.parent && this.parent.addChildUpdateBoundTag(), this._emitCustomEvent("AAABBBoundsChange"), bounds;
      }
      clearUpdateBoundTag() {
        this._updateTag &= UpdateTag.CLEAR_BOUNDS, this._childUpdateTag &= UpdateTag.CLEAR_BOUNDS;
      }
      addUpdateBoundTag() {
        this._updateTag |= UpdateTag.UPDATE_BOUNDS, this.parent && this.parent.addChildUpdateBoundTag();
      }
      addChildUpdateBoundTag() {
        this._childUpdateTag & UpdateTag.UPDATE_BOUNDS || (this._childUpdateTag |= UpdateTag.UPDATE_BOUNDS, this.parent && this.parent.addChildUpdateBoundTag());
      }
      getTheme() {
        return this.theme.getTheme(this);
      }
      incrementalAppendChild(node) {
        const data = super.appendChild(node);
        return this.stage && data && (data.stage = this.stage, data.layer = this.layer), this.addUpdateBoundTag(), application.graphicService.onAddIncremental(node, this, this.stage), data;
      }
      incrementalClearChild() {
        super.removeAllChild(), this.addUpdateBoundTag(), application.graphicService.onClearIncremental(this, this.stage);
      }
      _updateChildToStage(child) {
        return this.stage && child && child.setStage(this.stage, this.layer), this.addUpdateBoundTag(), child;
      }
      appendChild(node) {
        let addStage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
        const data = super.appendChild(node);
        return addStage && this.stage && data && data.setStage(this.stage, this.layer), this.addUpdateBoundTag(), data;
      }
      insertBefore(newNode, referenceNode) {
        return this._updateChildToStage(super.insertBefore(newNode, referenceNode));
      }
      insertAfter(newNode, referenceNode) {
        return this._updateChildToStage(super.insertAfter(newNode, referenceNode));
      }
      insertInto(newNode, idx) {
        return this._updateChildToStage(super.insertInto(newNode, idx));
      }
      removeChild(child) {
        const data = super.removeChild(child);
        return child.stage = null, application.graphicService.onRemove(child), this.addUpdateBoundTag(), data;
      }
      removeAllChild() {
        let deep = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !1;
        this.forEachChildren(child => {
          application.graphicService.onRemove(child), deep && child.isContainer && child.removeAllChild(deep);
        }), super.removeAllChild(), this.addUpdateBoundTag();
      }
      setStage(stage, layer) {
        this.stage !== stage && (this.stage = stage, this.layer = layer, this.setStageToShadowRoot(stage, layer), this._onSetStage && this._onSetStage(this, stage, layer), application.graphicService.onSetStage(this, stage), this.forEachChildren(item => {
          item.setStage(stage, this.layer);
        }));
      }
      addUpdatePositionTag() {
        super.addUpdatePositionTag(), this.forEachChildren(g => {
          g.isContainer && g.addUpdateGlobalPositionTag();
        });
      }
      addUpdateGlobalPositionTag() {
        super.addUpdateGlobalPositionTag(), this.forEachChildren(g => {
          g.isContainer && g.addUpdateGlobalPositionTag();
        });
      }
      tryUpdateGlobalTransMatrix() {
        let clearTag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !0;
        if (this.shouldUpdateGlobalMatrix()) {
          if (this._globalTransMatrix) {
            if (this.parent) {
              const m = this.parent.globalTransMatrix;
              this._globalTransMatrix.setValue(m.a, m.b, m.c, m.d, m.e, m.f);
            }
          } else this._globalTransMatrix = this.parent ? this.parent.globalTransMatrix.clone() : this.transMatrix.clone();
          this.doUpdateGlobalMatrix(), clearTag && this.clearUpdateGlobalPositionTag();
        }
        return this._globalTransMatrix;
      }
      shouldUpdateGlobalMatrix() {
        return !!(this._updateTag & UpdateTag.UPDATE_GLOBAL_MATRIX);
      }
      _getChildByName(name, deep) {
        return this.find(node => node.name === name, deep);
      }
      createOrUpdateChild(graphicName, attributes, graphicType) {
        let graphic = this._getChildByName(graphicName);
        return graphic ? graphic.setAttributes(attributes) : (graphic = application.graphicService.creator[graphicType](attributes), graphic.name = graphicName, this.add(graphic)), graphic;
      }
      clone() {
        return new Group(Object.assign({}, this.attribute));
      }
      getNoWorkAnimateAttr() {
        return Group.NOWORK_ANIMATE_ATTR;
      }
      release(all) {
        all && this.forEachChildren(g => {
          g.release(all);
        }), super.release();
      }
    };
    Group$2.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
    function createGroup(attributes) {
      return new Group$2(attributes);
    }

    class Layer extends Group$2 {
      get offscreen() {
        return this.layerHandler.offscreen;
      }
      get layerMode() {
        return this.layerHandler.type;
      }
      get width() {
        return this.stage ? this.stage.width : 0;
      }
      get height() {
        return this.stage ? this.stage.height : 0;
      }
      get viewWidth() {
        return this.stage ? this.stage.viewWidth : 0;
      }
      get viewHeight() {
        return this.stage ? this.stage.viewHeight : 0;
      }
      get dirtyBound() {
        throw new Error("暂不支持");
      }
      get dpr() {
        return this._dpr;
      }
      constructor(stage, global, window, params) {
        var _a;
        super({}), this.stage = stage, this.global = global, this.window = window, this.main = params.main, this.layerHandler = params.layerHandler, this.layerHandler.init(this, window, {
          main: params.main,
          canvasId: params.canvasId,
          width: this.viewWidth,
          height: this.viewHeight,
          zIndex: null !== (_a = params.zIndex) && void 0 !== _a ? _a : 0
        }), this.layer = this, this.subLayers = new Map(), this.theme = new Theme(), this.background = "rgba(0, 0, 0, 0)", this.afterDrawCbs = [];
      }
      combineSubLayer() {
        let removeIncrementalKey = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !0;
        const subLayers = Array.from(this.subLayers.values()).sort((a, b) => a.zIndex - b.zIndex);
        this.layerHandler.merge(subLayers.map(l => (l.layer.subLayers.size && l.layer.combineSubLayer(removeIncrementalKey), l.layer.getNativeHandler()))), removeIncrementalKey && subLayers.forEach(l => {
          l.group && (l.group.incremental = 0);
        }), subLayers.forEach(l => {
          application.layerService.releaseLayer(this.stage, l.layer);
        }), this.subLayers.clear();
      }
      getNativeHandler() {
        return this.layerHandler;
      }
      setStage(stage, layer) {
        super.setStage(stage, this);
      }
      pick(x, y) {
        throw new Error("暂不支持");
      }
      tryRenderSecondaryLayer(params, userParams) {
        this.layerHandler.secondaryHandlers && this.layerHandler.secondaryHandlers.length && this.layerHandler.secondaryHandlers.forEach(h => {
          h.layer.renderCount = this.renderCount, h.layer.render(params, userParams);
        });
      }
      render(params, userParams) {
        var _a;
        this.layerHandler.render([this], {
          renderService: params.renderService,
          stage: this.stage,
          layer: this,
          viewBox: params.viewBox,
          transMatrix: params.transMatrix,
          background: null !== (_a = params.background) && void 0 !== _a ? _a : this.background,
          updateBounds: params.updateBounds
        }, userParams), this.afterDrawCbs.forEach(c => c(this)), this.tryRenderSecondaryLayer(params, userParams);
      }
      resize(w, h) {
        this.layerHandler.resize(w, h);
      }
      resizeView(w, h) {
        this.layerHandler.resizeView(w, h);
      }
      setDpr(dpr) {
        this.layerHandler.setDpr(dpr);
      }
      afterDraw(cb) {
        this.afterDrawCbs.push(cb);
      }
      startAnimate(t) {
        throw new Error("暂不支持");
      }
      setToFrame(t) {
        throw new Error("暂不支持");
      }
      prepare(dirtyBounds, params) {}
      release() {
        super.release(), this.layerHandler.release(), this.subLayers && this.subLayers.forEach(l => {
          application.layerService.releaseLayer(this.stage, l.layer);
        });
      }
      drawTo(target, params) {
        var _a;
        this.layerHandler.drawTo(target, [this], Object.assign({
          background: null !== (_a = params.background) && void 0 !== _a ? _a : this.background,
          renderService: params.renderService,
          viewBox: params.viewBox,
          transMatrix: params.transMatrix,
          stage: this.stage,
          layer: this
        }, params)), this.afterDrawCbs.forEach(c => c(this));
      }
    }

    const TransformUtil = Symbol.for("TransformUtil");
    const GraphicUtil = Symbol.for("GraphicUtil");
    const LayerService = Symbol.for("LayerService");
    const StaticLayerHandlerContribution = Symbol.for("StaticLayerHandlerContribution");
    const DynamicLayerHandlerContribution = Symbol.for("DynamicLayerHandlerContribution");
    const VirtualLayerHandlerContribution = Symbol.for("VirtualLayerHandlerContribution");

    var DefaultLayerService_1,
      __decorate$X = undefined && undefined.__decorate || function (decorators, target, key, desc) {
        var d,
          c = arguments.length,
          r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      },
      __metadata$K = undefined && undefined.__metadata || function (k, v) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
      };
    let DefaultLayerService = DefaultLayerService_1 = class {
      static GenerateLayerId() {
        return `${DefaultLayerService_1.idprefix}_${DefaultLayerService_1.prefix_count++}`;
      }
      constructor() {
        this.layerMap = new Map(), this.global = application.global;
      }
      tryInit() {
        this.inited || (this.staticLayerCountInEnv = this.global.getStaticCanvasCount(), this.dynamicLayerCountInEnv = this.global.getDynamicCanvasCount(), this.inited = !0);
      }
      getStageLayer(stage) {
        return this.layerMap.get(stage);
      }
      getRecommendedLayerType(layerMode) {
        return layerMode || (0 !== this.staticLayerCountInEnv ? "static" : 0 !== this.dynamicLayerCountInEnv ? "dynamic" : "virtual");
      }
      getLayerHandler(layerMode) {
        let layerHandler;
        return layerHandler = "static" === layerMode ? container.get(StaticLayerHandlerContribution) : "dynamic" === layerMode ? container.get(DynamicLayerHandlerContribution) : container.get(VirtualLayerHandlerContribution), layerHandler;
      }
      createLayer(stage) {
        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
          main: !1
        };
        var _a;
        this.tryInit();
        let layerMode = this.getRecommendedLayerType(options.layerMode);
        layerMode = options.main || options.canvasId ? "static" : layerMode;
        const layerHandler = this.getLayerHandler(layerMode),
          layer = new Layer(stage, this.global, stage.window, Object.assign(Object.assign({
            main: !1
          }, options), {
            layerMode: layerMode,
            canvasId: null !== (_a = options.canvasId) && void 0 !== _a ? _a : DefaultLayerService_1.GenerateLayerId(),
            layerHandler: layerHandler
          })),
          stageLayers = this.layerMap.get(stage) || [];
        return stageLayers.push(layer), this.layerMap.set(stage, stageLayers), this.staticLayerCountInEnv--, layer;
      }
      prepareStageLayer(stage) {
        let mainHandler;
        stage.forEachChildren(l => {
          const handler = l.getNativeHandler();
          "virtual" === handler.type ? (handler.mainHandler = mainHandler, mainHandler.secondaryHandlers.push(handler)) : (mainHandler = handler, mainHandler.secondaryHandlers = []);
        });
      }
      releaseLayer(stage, layer) {
        layer.release();
        const stageLayers = this.layerMap.get(stage) || [];
        this.layerMap.set(stage, stageLayers.filter(l => l !== layer));
      }
      layerCount(stage) {
        return (this.layerMap.get(stage) || []).length;
      }
      restLayerCount(stage) {
        return "browser" === this.global.env ? 10 : 0;
      }
      releaseStage(stage) {
        this.layerMap.delete(stage);
      }
    };
    DefaultLayerService.idprefix = "visactor_layer", DefaultLayerService.prefix_count = 0, DefaultLayerService = DefaultLayerService_1 = __decorate$X([injectable(), __metadata$K("design:paramtypes", [])], DefaultLayerService);

    var coreModule = new ContainerModule(bind => {
      bind(VGlobal).to(DefaultGlobal).inSingletonScope(), bind(VWindow).to(DefaultWindow), bind(GraphicUtil).to(DefaultGraphicUtil).inSingletonScope(), bind(TransformUtil).to(DefaultTransformUtil).inSingletonScope(), bind(LayerService).to(DefaultLayerService).inSingletonScope();
    });

    function runFill(fill, background) {
      return !(!fill && !background);
    }
    function runStroke(stroke, lineWidth) {
      let s;
      return s = isArray$9(stroke) ? stroke.some(item => item || void 0 === item) : !!stroke, s && lineWidth > 0;
    }
    function fillVisible(opacity, fillOpacity, fill) {
      return fill && opacity * fillOpacity > 0;
    }
    function rectFillVisible(opacity, fillOpacity, width, height, fill) {
      return fill && opacity * fillOpacity > 0 && 0 !== width && 0 !== height;
    }
    function strokeVisible(opacity, strokeOpacity) {
      return opacity * strokeOpacity > 0;
    }
    function rectStrokeVisible(opacity, strokeOpacity, width, height) {
      return opacity * strokeOpacity > 0 && 0 !== width && 0 !== height;
    }
    function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
      const x10 = x1 - x0,
        y10 = y1 - y0,
        x32 = x3 - x2,
        y32 = y3 - y2;
      let t = y32 * x10 - x32 * y10;
      return t * t < epsilon ? [] : (t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t, [x0 + t * x10, y0 + t * y10]);
    }
    function cornerTangents(x0, y0, x1, y1, r1, rc, clockwise) {
      const x01 = x0 - x1,
        y01 = y0 - y1,
        lo = (clockwise ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01),
        ox = lo * y01,
        oy = -lo * x01,
        x11 = x0 + ox,
        y11 = y0 + oy,
        x10 = x1 + ox,
        y10 = y1 + oy,
        x00 = (x11 + x10) / 2,
        y00 = (y11 + y10) / 2,
        dx = x10 - x11,
        dy = y10 - y11,
        d2 = dx * dx + dy * dy,
        r = r1 - rc,
        D = x11 * y10 - x10 * y11,
        d = (dy < 0 ? -1 : 1) * Math.sqrt(Math.max(0, r * r * d2 - D * D));
      let cx0 = (D * dy - dx * d) / d2,
        cy0 = (-D * dx - dy * d) / d2;
      const cx1 = (D * dy + dx * d) / d2,
        cy1 = (-D * dx + dy * d) / d2,
        dx0 = cx0 - x00,
        dy0 = cy0 - y00,
        dx1 = cx1 - x00,
        dy1 = cy1 - y00;
      return dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1 && (cx0 = cx1, cy0 = cy1), {
        cx: cx0,
        cy: cy0,
        x01: -ox,
        y01: -oy,
        x11: cx0 * (r1 / r - 1),
        y11: cy0 * (r1 / r - 1)
      };
    }
    function calculateArcCornerRadius(arc, startAngle, endAngle, innerRadius, outerRadius) {
      const deltaAngle = abs(endAngle - startAngle),
        cornerRadius = arc.getParsedCornerRadius(),
        cornerRadiusIsArray = isArray$9(cornerRadius),
        {
          outerDeltaAngle: outerDeltaAngle,
          innerDeltaAngle: innerDeltaAngle,
          outerStartAngle: outerStartAngle,
          outerEndAngle: outerEndAngle,
          innerEndAngle: innerEndAngle,
          innerStartAngle: innerStartAngle
        } = arc.getParsePadAngle(startAngle, endAngle),
        outerCornerRadiusStart = cornerRadiusIsArray ? cornerRadius[0] : cornerRadius,
        outerCornerRadiusEnd = cornerRadiusIsArray ? cornerRadius[1] : cornerRadius,
        innerCornerRadiusEnd = cornerRadiusIsArray ? cornerRadius[2] : cornerRadius,
        innerCornerRadiusStart = cornerRadiusIsArray ? cornerRadius[3] : cornerRadius,
        maxOuterCornerRadius = Math.max(outerCornerRadiusEnd, outerCornerRadiusStart),
        maxInnerCornerRadius = Math.max(innerCornerRadiusEnd, innerCornerRadiusStart);
      let limitedOcr = maxOuterCornerRadius,
        limitedIcr = maxInnerCornerRadius;
      const xors = outerRadius * cos(outerStartAngle),
        yors = outerRadius * sin(outerStartAngle),
        xire = innerRadius * cos(innerEndAngle),
        yire = innerRadius * sin(innerEndAngle);
      let xore, yore, xirs, yirs;
      if ((maxInnerCornerRadius > epsilon || maxOuterCornerRadius > epsilon) && (xore = outerRadius * cos(outerEndAngle), yore = outerRadius * sin(outerEndAngle), xirs = innerRadius * cos(innerStartAngle), yirs = innerRadius * sin(innerStartAngle), deltaAngle < pi)) {
        const oc = intersect(xors, yors, xirs, yirs, xore, yore, xire, yire);
        if (oc) {
          const ax = xors - oc[0],
            ay = yors - oc[1],
            bx = xore - oc[0],
            by = yore - oc[1],
            kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2),
            lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
          limitedIcr = min(maxInnerCornerRadius, (innerRadius - lc) / (kc - 1)), limitedOcr = min(maxOuterCornerRadius, (outerRadius - lc) / (kc + 1));
        }
      }
      return {
        outerDeltaAngle: outerDeltaAngle,
        xors: xors,
        yors: yors,
        xirs: xirs,
        yirs: yirs,
        xore: xore,
        yore: yore,
        xire: xire,
        yire: yire,
        limitedOcr: limitedOcr,
        limitedIcr: limitedIcr,
        outerCornerRadiusStart: outerCornerRadiusStart,
        outerCornerRadiusEnd: outerCornerRadiusEnd,
        maxOuterCornerRadius: maxOuterCornerRadius,
        maxInnerCornerRadius: maxInnerCornerRadius,
        outerStartAngle: outerStartAngle,
        outerEndAngle: outerEndAngle,
        innerDeltaAngle: innerDeltaAngle,
        innerEndAngle: innerEndAngle,
        innerStartAngle: innerStartAngle,
        innerCornerRadiusStart: innerCornerRadiusStart,
        innerCornerRadiusEnd: innerCornerRadiusEnd
      };
    }
    function drawArcPath(arc, context, cx, cy, outerRadius, innerRadius, partStroke) {
      const {
          startAngle: startAngle,
          endAngle: endAngle
        } = arc.getParsedAngle(),
        deltaAngle = abs(endAngle - startAngle),
        clockwise = endAngle > startAngle;
      let collapsedToLine = !1;
      if (outerRadius < innerRadius) {
        const temp = outerRadius;
        outerRadius = innerRadius, innerRadius = temp;
      }
      if (outerRadius <= epsilon) context.moveTo(cx, cy);else if (deltaAngle >= pi2 - epsilon) context.moveTo(cx + outerRadius * cos(startAngle), cy + outerRadius * sin(startAngle)), context.arc(cx, cy, outerRadius, startAngle, endAngle, !clockwise), innerRadius > epsilon && (context.moveTo(cx + innerRadius * cos(endAngle), cy + innerRadius * sin(endAngle)), context.arc(cx, cy, innerRadius, endAngle, startAngle, clockwise));else {
        const {
          outerDeltaAngle: outerDeltaAngle,
          xors: xors,
          yors: yors,
          xirs: xirs,
          yirs: yirs,
          limitedOcr: limitedOcr,
          outerCornerRadiusStart: outerCornerRadiusStart,
          outerCornerRadiusEnd: outerCornerRadiusEnd,
          maxOuterCornerRadius: maxOuterCornerRadius,
          xore: xore,
          yore: yore,
          xire: xire,
          yire: yire,
          outerStartAngle: outerStartAngle,
          outerEndAngle: outerEndAngle,
          limitedIcr: limitedIcr,
          innerDeltaAngle: innerDeltaAngle,
          innerEndAngle: innerEndAngle,
          innerStartAngle: innerStartAngle,
          innerCornerRadiusStart: innerCornerRadiusStart,
          innerCornerRadiusEnd: innerCornerRadiusEnd,
          maxInnerCornerRadius: maxInnerCornerRadius
        } = calculateArcCornerRadius(arc, startAngle, endAngle, innerRadius, outerRadius);
        if (outerDeltaAngle < .001) partStroke && (partStroke[3] || partStroke[1]) && context.moveTo(cx + xors, cy + yors), collapsedToLine = !0;else if (limitedOcr > epsilon) {
          const cornerRadiusStart = min(outerCornerRadiusStart, limitedOcr),
            cornerRadiusEnd = min(outerCornerRadiusEnd, limitedOcr),
            t0 = cornerTangents(xirs, yirs, xors, yors, outerRadius, cornerRadiusStart, Number(clockwise)),
            t1 = cornerTangents(xore, yore, xire, yire, outerRadius, cornerRadiusEnd, Number(clockwise));
          limitedOcr < maxOuterCornerRadius && cornerRadiusStart === cornerRadiusEnd ? !partStroke || partStroke[0] ? (context.moveTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01), context.arc(cx + t0.cx, cy + t0.cy, limitedOcr, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !clockwise)) : context.moveTo(cx + t0.cx + limitedOcr * cos(atan2(t1.y01, t1.x01)), cy + t0.cy + limitedOcr * sin(atan2(t1.y01, t1.x01))) : !partStroke || partStroke[0] ? (context.moveTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01), cornerRadiusStart > 0 && context.arc(cx + t0.cx, cy + t0.cy, cornerRadiusStart, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !clockwise), context.arc(cx, cy, outerRadius, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), !clockwise), cornerRadiusEnd > 0 && context.arc(cx + t1.cx, cy + t1.cy, cornerRadiusEnd, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !clockwise)) : cornerRadiusEnd > 0 ? context.moveTo(cx + t1.cx + cornerRadiusEnd * cos(atan2(t1.y01, t1.x01)), cy + t1.cy + cornerRadiusEnd * sin(atan2(t1.y01, t1.x01))) : context.moveTo(cx + xore, cy + outerRadius * sin(outerEndAngle));
        } else !partStroke || partStroke[0] ? (context.moveTo(cx + xors, cy + yors), context.arc(cx, cy, outerRadius, outerStartAngle, outerEndAngle, !clockwise)) : context.moveTo(cx + outerRadius * cos(outerEndAngle), cy + outerRadius * sin(outerEndAngle));
        if (!(innerRadius > epsilon) || innerDeltaAngle < .001) !partStroke || partStroke[1] ? context.lineTo(cx + xire, cy + yire) : context.moveTo(cx + xire, cy + yire), collapsedToLine = !0;else if (limitedIcr > epsilon) {
          const cornerRadiusStart = min(innerCornerRadiusStart, limitedIcr),
            cornerRadiusEnd = min(innerCornerRadiusEnd, limitedIcr),
            t0 = cornerTangents(xire, yire, xore, yore, innerRadius, -cornerRadiusEnd, Number(clockwise)),
            t1 = cornerTangents(xors, yors, xirs, yirs, innerRadius, -cornerRadiusStart, Number(clockwise));
          if (!partStroke || partStroke[1] ? context.lineTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01) : context.moveTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01), limitedIcr < maxInnerCornerRadius && cornerRadiusStart === cornerRadiusEnd) {
            const arcEndAngle = atan2(t1.y01, t1.x01);
            !partStroke || partStroke[2] ? context.arc(cx + t0.cx, cy + t0.cy, limitedIcr, atan2(t0.y01, t0.x01), arcEndAngle, !clockwise) : context.moveTo(cx + t0.cx + cos(arcEndAngle), cy + t0.cy + sin(arcEndAngle));
          } else !partStroke || partStroke[2] ? (cornerRadiusEnd > 0 && context.arc(cx + t0.cx, cy + t0.cy, cornerRadiusEnd, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !clockwise), context.arc(cx, cy, innerRadius, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), clockwise), cornerRadiusStart > 0 && context.arc(cx + t1.cx, cy + t1.cy, cornerRadiusStart, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !clockwise)) : cornerRadiusStart > 0 ? context.moveTo(cx + t1.cx + cornerRadiusStart * cos(atan2(t1.y01, t1.x01)), cy + t1.cy + cornerRadiusStart * sin(atan2(t1.y01, t1.x01))) : context.moveTo(cx + xirs, cy + yirs);
        } else !partStroke || partStroke[1] ? context.lineTo(cx + xire, cy + yire) : context.moveTo(cx + xire, cy + yire), !partStroke || partStroke[2] ? context.arc(cx, cy, innerRadius, innerEndAngle, innerStartAngle, clockwise) : context.moveTo(cx + innerRadius * cos(innerStartAngle), cy + innerRadius * sin(innerStartAngle));
      }
      return partStroke ? partStroke[3] && context.lineTo(cx + outerRadius * cos(startAngle), cy + outerRadius * sin(startAngle)) : context.closePath(), collapsedToLine;
    }

    class ConicalCanvas {
      static GetCanvas() {
        try {
          return ConicalCanvas.canvas || (ConicalCanvas.canvas = application.global.createCanvas({})), ConicalCanvas.canvas;
        } catch (err) {
          return null;
        }
      }
      static GetCtx() {
        if (!ConicalCanvas.ctx) {
          const conicalCanvas = ConicalCanvas.GetCanvas();
          ConicalCanvas.ctx = conicalCanvas.getContext("2d");
        }
        return ConicalCanvas.ctx;
      }
    }
    class ColorInterpolate extends LRU {
      static getInstance() {
        return ColorInterpolate._instance || (ColorInterpolate._instance = new ColorInterpolate()), ColorInterpolate._instance;
      }
      constructor() {
        let stops = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        let precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;
        super(), this.cacheParams = {
          CLEAN_THRESHOLD: 100,
          L_TIME: 1e3
        }, this.dataMap = new Map();
        const canvas = ConicalCanvas.GetCanvas(),
          conicalCtx = ConicalCanvas.GetCtx();
        if (canvas.width = precision, canvas.height = 1, !conicalCtx) return;
        if (conicalCtx.translate(0, 0), !conicalCtx) throw new Error("获取ctx发生错误");
        const gradient = conicalCtx.createLinearGradient(0, 0, precision, 0);
        stops.forEach(stop => {
          gradient.addColorStop(stop[0], stop[1]);
        }), conicalCtx.fillStyle = gradient, conicalCtx.fillRect(0, 0, precision, 1), this.rgbaSet = conicalCtx.getImageData(0, 0, precision, 1).data;
      }
      getColor(offset) {
        const rgba = this.rgbaSet.slice(4 * offset, 4 * offset + 4);
        return `rgba(${rgba[0]}, ${rgba[1]}, ${rgba[2]}, ${rgba[3] / 255})`;
      }
      GetOrCreate(x, y, w, h) {
        let stops = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];
        let precision = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 100;
        let str = `${x}${y}${w}${h}`;
        stops.forEach(item => str += item.join()), str += precision;
        let colorInter = this.dataMap.get(str);
        if (!colorInter) {
          colorInter = {
            data: new ColorInterpolate(stops, precision),
            timestamp: []
          }, this.addLimitedTimestamp(colorInter, Date.now(), {}), this.dataMap.set(str, colorInter);
        }
        return this.clearCache(this.dataMap, this.cacheParams), colorInter.data;
      }
    }
    class ConicalPatternStore {
      static GetSize(minSize) {
        for (let i = 0; i < ConicalPatternStore.ImageSize.length; i++) if (ConicalPatternStore.ImageSize[i] >= minSize) return ConicalPatternStore.ImageSize[i];
        return minSize;
      }
      static Get(stops, x, y, startAngle, endAngle, w, h) {
        const key = ConicalPatternStore.GenKey(stops, x, y, startAngle, endAngle),
          data = ConicalPatternStore.cache[key];
        if (!data || 0 === data.length) return null;
        for (let i = 0; i < data.length; i++) if (data[i].width >= w && data[i].height >= h) return data[i].pattern;
        return null;
      }
      static Set(stops, x, y, startAngle, endAngle, pattern, w, h) {
        const key = ConicalPatternStore.GenKey(stops, x, y, startAngle, endAngle);
        ConicalPatternStore.cache[key] ? ConicalPatternStore.cache[key].push({
          width: w,
          height: h,
          pattern: pattern
        }) : ConicalPatternStore.cache[key] = [{
          width: w,
          height: h,
          pattern: pattern
        }];
      }
      static GenKey(stops, x, y, startAngle, endAngle) {
        return `${x},${y},${startAngle},${endAngle},${stops.join()}`;
      }
    }
    ConicalPatternStore.cache = {}, ConicalPatternStore.ImageSize = [20, 40, 80, 160, 320, 640, 1280, 2560];
    function getConicGradientAt(x, y, angle, color) {
      const {
        stops: stops,
        startAngle: startAngle,
        endAngle: endAngle
      } = color;
      for (; angle < 0;) angle += pi2;
      for (; angle > pi2;) angle -= pi2;
      if (angle < startAngle) return stops[0].color;
      if (angle > endAngle) return stops[0].color;
      let startStop,
        endStop,
        percent = (angle - startAngle) / (endAngle - startAngle);
      for (let i = 0; i < stops.length; i++) if (stops[i].offset >= percent) {
        startStop = stops[i - 1], endStop = stops[i];
        break;
      }
      return percent = (percent - startStop.offset) / (endStop.offset - startStop.offset), interpolateColor(startStop.color, endStop.color, percent, !1);
    }
    function createConicalGradient(context, stops, x, y, deltaAngle, startAngle, endAngle, minW, minH) {
      const deltaDeg = Math.floor(180 * deltaAngle / Math.PI),
        conicalCanvas = ConicalCanvas.GetCanvas(),
        conicalCtx = ConicalCanvas.GetCtx();
      if (!conicalCtx) return null;
      const width = ConicalPatternStore.GetSize(minW),
        height = ConicalPatternStore.GetSize(minH);
      let pattern = ConicalPatternStore.Get(stops, x, y, startAngle, endAngle, width, height);
      if (pattern) return pattern;
      const r = Math.sqrt(Math.max(Math.max(Math.pow(x, 2) + Math.pow(y, 2), Math.pow(width - x, 2) + Math.pow(y, 2)), Math.max(Math.pow(width - x, 2) + Math.pow(height - y, 2), Math.pow(x, 2) + Math.pow(height - y, 2)))),
        stepNum = deltaDeg + 1,
        step = deltaAngle / Math.max(1, stepNum - 1),
        colorInter = ColorInterpolate.getInstance().GetOrCreate(x, y, width, height, stops, stepNum),
        lineWidth = 2 * Math.PI * r / 360;
      conicalCanvas.width = width, conicalCanvas.height = height, conicalCtx.setTransform(1, 0, 0, 1, 0, 0), conicalCtx.clearRect(0, 0, width, height), conicalCtx.translate(x, y), conicalCtx.rotate(startAngle);
      for (let i = 0, len = stepNum - 1; i < len && !(startAngle + i * step > endAngle); i++) {
        const color = colorInter.getColor(i);
        conicalCtx.beginPath(), conicalCtx.rotate(step), conicalCtx.moveTo(0, 0), conicalCtx.lineTo(r, -2 * lineWidth), conicalCtx.lineTo(r, 0), conicalCtx.fillStyle = color, conicalCtx.closePath(), conicalCtx.fill();
      }
      const imageData = conicalCtx.getImageData(0, 0, width, height);
      return conicalCanvas.width = imageData.width, conicalCanvas.height = imageData.height, conicalCtx.putImageData(imageData, 0, 0), pattern = context.createPattern(conicalCanvas, "no-repeat"), pattern && ConicalPatternStore.Set(stops, x, y, startAngle, endAngle, pattern, width, height), pattern;
    }

    const ArcRenderContribution = Symbol.for("ArcRenderContribution");
    const AreaRenderContribution = Symbol.for("AreaRenderContribution");
    const CircleRenderContribution = Symbol.for("CircleRenderContribution");
    const GroupRenderContribution = Symbol.for("GroupRenderContribution");
    const ImageRenderContribution = Symbol.for("ImageRenderContribution");
    const PathRenderContribution = Symbol.for("PathRenderContribution");
    const PolygonRenderContribution = Symbol.for("PolygonRenderContribution");
    const RectRenderContribution = Symbol.for("RectRenderContribution");
    const SymbolRenderContribution = Symbol.for("SymbolRenderContribution");
    const TextRenderContribution = Symbol.for("TextRenderContribution");
    const InteractiveSubRenderContribution = Symbol.for("InteractiveSubRenderContribution");

    function textDrawOffsetX(textAlign, width) {
      return "end" === textAlign || "right" === textAlign ? -width : "center" === textAlign ? -width / 2 : 0;
    }
    function textLayoutOffsetY(baseline, lineHeight, fontSize) {
      let buf = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      return "middle" === baseline ? -lineHeight / 2 : "top" === baseline ? 0 : "bottom" === baseline ? buf - lineHeight : baseline && "alphabetic" !== baseline ? 0 : (fontSize || (fontSize = lineHeight), -(lineHeight - fontSize) / 2 - .79 * fontSize);
    }

    function identityMat4(out) {
      return out[0] = 1, out[1] = 0, out[2] = 0, out[3] = 0, out[4] = 0, out[5] = 1, out[6] = 0, out[7] = 0, out[8] = 0, out[9] = 0, out[10] = 1, out[11] = 0, out[12] = 0, out[13] = 0, out[14] = 0, out[15] = 1, out;
    }
    function rotateX(out, a, rad) {
      const s = Math.sin(rad),
        c = Math.cos(rad),
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];
      return a !== out && (out[0] = a[0], out[1] = a[1], out[2] = a[2], out[3] = a[3], out[12] = a[12], out[13] = a[13], out[14] = a[14], out[15] = a[15]), out[4] = a10 * c + a20 * s, out[5] = a11 * c + a21 * s, out[6] = a12 * c + a22 * s, out[7] = a13 * c + a23 * s, out[8] = a20 * c - a10 * s, out[9] = a21 * c - a11 * s, out[10] = a22 * c - a12 * s, out[11] = a23 * c - a13 * s, out;
    }
    function rotateY(out, a, rad) {
      const s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];
      return a !== out && (out[4] = a[4], out[5] = a[5], out[6] = a[6], out[7] = a[7], out[12] = a[12], out[13] = a[13], out[14] = a[14], out[15] = a[15]), out[0] = a00 * c - a20 * s, out[1] = a01 * c - a21 * s, out[2] = a02 * c - a22 * s, out[3] = a03 * c - a23 * s, out[8] = a00 * s + a20 * c, out[9] = a01 * s + a21 * c, out[10] = a02 * s + a22 * c, out[11] = a03 * s + a23 * c, out;
    }
    function rotateZ(out, a, rad) {
      const s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];
      return a !== out && (out[8] = a[8], out[9] = a[9], out[10] = a[10], out[11] = a[11], out[12] = a[12], out[13] = a[13], out[14] = a[14], out[15] = a[15]), out[0] = a00 * c + a10 * s, out[1] = a01 * c + a11 * s, out[2] = a02 * c + a12 * s, out[3] = a03 * c + a13 * s, out[4] = a10 * c - a00 * s, out[5] = a11 * c - a01 * s, out[6] = a12 * c - a02 * s, out[7] = a13 * c - a03 * s, out;
    }
    function translate(out, a, v) {
      const x = v[0],
        y = v[1],
        z = v[2];
      let a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23;
      return a === out ? (out[12] = a[0] * x + a[4] * y + a[8] * z + a[12], out[13] = a[1] * x + a[5] * y + a[9] * z + a[13], out[14] = a[2] * x + a[6] * y + a[10] * z + a[14], out[15] = a[3] * x + a[7] * y + a[11] * z + a[15]) : (a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11], out[0] = a00, out[1] = a01, out[2] = a02, out[3] = a03, out[4] = a10, out[5] = a11, out[6] = a12, out[7] = a13, out[8] = a20, out[9] = a21, out[10] = a22, out[11] = a23, out[12] = a00 * x + a10 * y + a20 * z + a[12], out[13] = a01 * x + a11 * y + a21 * z + a[13], out[14] = a02 * x + a12 * y + a22 * z + a[14], out[15] = a03 * x + a13 * y + a23 * z + a[15]), out;
    }
    function mat3Tomat4(out, b) {
      out[0] = b.a, out[1] = b.b, out[2] = 0, out[3] = 0, out[4] = b.c, out[5] = b.d, out[6] = 0, out[7] = 0, out[8] = 0, out[9] = 0, out[10] = 1, out[11] = 0, out[12] = b.e, out[13] = b.f, out[14] = 0, out[15] = 1;
    }
    function scaleMat4(out, a, v) {
      const x = v[0],
        y = v[1],
        z = v[2];
      return out[0] = a[0] * x, out[1] = a[1] * x, out[2] = a[2] * x, out[3] = a[3] * x, out[4] = a[4] * y, out[5] = a[5] * y, out[6] = a[6] * y, out[7] = a[7] * y, out[8] = a[8] * z, out[9] = a[9] * z, out[10] = a[10] * z, out[11] = a[11] * z, out[12] = a[12], out[13] = a[13], out[14] = a[14], out[15] = a[15], out;
    }
    function multiplyMat4Mat4(out, a, b) {
      const a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11],
        a30 = a[12],
        a31 = a[13],
        a32 = a[14],
        a33 = a[15];
      let b0 = b[0],
        b1 = b[1],
        b2 = b[2],
        b3 = b[3];
      return out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, b0 = b[4], b1 = b[5], b2 = b[6], b3 = b[7], out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, b0 = b[8], b1 = b[9], b2 = b[10], b3 = b[11], out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, b0 = b[12], b1 = b[13], b2 = b[14], b3 = b[15], out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, out;
    }
    function transformMat4(out, a, m) {
      const x = a[0],
        y = a[1],
        z = a[2];
      let w = m[3] * x + m[7] * y + m[11] * z + m[15];
      return w = w || 1, out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w, out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w, out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w, out;
    }

    function createMat4() {
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    }
    class DefaultMatrixAllocate {
      constructor() {
        this.pools = [];
      }
      allocate(a, b, c, d, e, f) {
        if (!this.pools.length) return new Matrix(a, b, c, d, e, f);
        const m = this.pools.pop();
        return m.a = a, m.b = b, m.c = c, m.d = d, m.e = e, m.f = f, m;
      }
      allocateByObj(matrix) {
        if (!this.pools.length) return new Matrix(matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f);
        const m = this.pools.pop();
        return m.a = matrix.a, m.b = matrix.b, m.c = matrix.c, m.d = matrix.d, m.e = matrix.e, m.f = matrix.f, m;
      }
      free(d) {
        this.pools.push(d);
      }
      get length() {
        return this.pools.length;
      }
      release() {
        this.pools = [];
      }
    }
    class DefaultMat4Allocate {
      constructor() {
        this.pools = [];
      }
      static identity(out) {
        return identityMat4(out);
      }
      allocate() {
        if (!this.pools.length) return createMat4();
        const m = this.pools.pop();
        return DefaultMat4Allocate.identity(m), m;
      }
      allocateByObj(d) {
        let m;
        m = this.pools.length ? this.pools.pop() : createMat4();
        for (let i = 0; i < m.length; i++) m[i] = d[i];
        return m;
      }
      free(m) {
        m && this.pools.push(m);
      }
      get length() {
        return this.pools.length;
      }
      release() {
        this.pools = [];
      }
    }
    const matrixAllocate = new DefaultMatrixAllocate();
    const mat4Allocate = new DefaultMat4Allocate();

    var __decorate$W = undefined && undefined.__decorate || function (decorators, target, key, desc) {
        var d,
          c = arguments.length,
          r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      },
      __metadata$J = undefined && undefined.__metadata || function (k, v) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
      },
      __param$z = undefined && undefined.__param || function (paramIndex, decorator) {
        return function (target, key) {
          decorator(target, key, paramIndex);
        };
      };
    function getModelMatrix(out, graphic, theme) {
      var _a;
      const {
          x = theme.x,
          y = theme.y,
          z = theme.z,
          dx = theme.dx,
          dy = theme.dy,
          dz = theme.dz,
          scaleX = theme.scaleX,
          scaleY = theme.scaleY,
          scaleZ = theme.scaleZ,
          alpha = theme.alpha,
          beta = theme.beta,
          angle = theme.angle,
          anchor3d = graphic.attribute.anchor,
          anchor: anchor
        } = graphic.attribute,
        _anchor = [0, 0, 0];
      if (anchor3d) {
        if ("string" == typeof anchor3d[0]) {
          const ratio = parseFloat(anchor3d[0]) / 100,
            bounds = graphic.AABBBounds;
          _anchor[0] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
        } else _anchor[0] = anchor3d[0];
        if ("string" == typeof anchor3d[1]) {
          const ratio = parseFloat(anchor3d[1]) / 100,
            bounds = graphic.AABBBounds;
          _anchor[1] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
        } else _anchor[1] = anchor3d[1];
        _anchor[2] = null !== (_a = anchor3d[2]) && void 0 !== _a ? _a : 0;
      }
      if (identityMat4(out), translate(out, out, [x + dx, y + dy, z + dz]), translate(out, out, [_anchor[0], _anchor[1], _anchor[2]]), rotateX(out, out, beta), rotateY(out, out, alpha), translate(out, out, [-_anchor[0], -_anchor[1], _anchor[2]]), scaleMat4(out, out, [scaleX, scaleY, scaleZ]), angle) {
        const m = mat4Allocate.allocate(),
          _anchor = [0, 0];
        if (anchor) {
          if ("string" == typeof anchor3d[0]) {
            const ratio = parseFloat(anchor3d[0]) / 100,
              bounds = graphic.AABBBounds;
            _anchor[0] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
          } else _anchor[0] = anchor3d[0];
          if ("string" == typeof anchor3d[1]) {
            const ratio = parseFloat(anchor3d[1]) / 100,
              bounds = graphic.AABBBounds;
            _anchor[1] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
          } else _anchor[1] = anchor3d[1];
        }
        translate(m, m, [_anchor[0], _anchor[1], 0]), rotateZ(m, m, angle), translate(m, m, [-_anchor[0], -_anchor[1], 0]), multiplyMat4Mat4(out, out, m);
      }
    }
    function shouldUseMat4(graphic) {
      const {
        alpha: alpha,
        beta: beta
      } = graphic.attribute;
      return alpha || beta;
    }
    let DefaultGraphicService = class {
      constructor(creator) {
        this.creator = creator, this.hooks = {
          onAttributeUpdate: new SyncHook(["graphic"]),
          onSetStage: new SyncHook(["graphic", "stage"]),
          onRemove: new SyncHook(["graphic"]),
          onRelease: new SyncHook(["graphic"]),
          onAddIncremental: new SyncHook(["graphic", "group", "stage"]),
          onClearIncremental: new SyncHook(["graphic", "group", "stage"]),
          beforeUpdateAABBBounds: new SyncHook(["graphic", "stage", "willUpdate", "aabbBounds"]),
          afterUpdateAABBBounds: new SyncHook(["graphic", "stage", "aabbBounds", "globalAABBBounds", "selfChange"]),
          clearAABBBounds: new SyncHook(["graphic", "stage", "aabbBounds"])
        }, this.tempAABBBounds1 = new AABBBounds$1(), this.tempAABBBounds2 = new AABBBounds$1();
      }
      onAttributeUpdate(graphic) {
        this.hooks.onAttributeUpdate.taps.length && this.hooks.onAttributeUpdate.call(graphic);
      }
      onSetStage(graphic, stage) {
        this.hooks.onSetStage.taps.length && this.hooks.onSetStage.call(graphic, stage);
      }
      onRemove(graphic) {
        this.hooks.onRemove.taps.length && this.hooks.onRemove.call(graphic);
      }
      onRelease(graphic) {
        this.hooks.onRelease.taps.length && this.hooks.onRelease.call(graphic);
      }
      onAddIncremental(graphic, group, stage) {
        this.hooks.onAddIncremental.taps.length && this.hooks.onAddIncremental.call(graphic, group, stage);
      }
      onClearIncremental(group, stage) {
        this.hooks.onClearIncremental.taps.length && this.hooks.onClearIncremental.call(group, stage);
      }
      beforeUpdateAABBBounds(graphic, stage, willUpdate, bounds) {
        this.hooks.beforeUpdateAABBBounds.taps.length && this.hooks.beforeUpdateAABBBounds.call(graphic, stage, willUpdate, bounds);
      }
      afterUpdateAABBBounds(graphic, stage, bounds, params, selfChange) {
        this.hooks.afterUpdateAABBBounds.taps.length && this.hooks.afterUpdateAABBBounds.call(graphic, stage, bounds, params, selfChange);
      }
      clearAABBBounds(graphic, stage, b) {
        this.hooks.clearAABBBounds.taps.length && this.hooks.clearAABBBounds.call(graphic, stage, b);
      }
      updatePathProxyAABBBounds(aabbBounds, graphic) {
        const path = "function" == typeof graphic.pathProxy ? graphic.pathProxy(graphic.attribute) : graphic.pathProxy;
        if (!path) return !1;
        const boundsContext = new BoundsContext(aabbBounds);
        return renderCommandList(path.commandList, boundsContext, 0, 0), !0;
      }
      updateHTMLTextAABBBounds(attribute, textTheme, aabbBounds, graphic) {
        const {
          textAlign: textAlign,
          textBaseline: textBaseline
        } = attribute;
        if (null != attribute.forceBoundsHeight) {
          const h = isNumber$6(attribute.forceBoundsHeight) ? attribute.forceBoundsHeight : attribute.forceBoundsHeight(),
            dy = textLayoutOffsetY(textBaseline, h, h);
          aabbBounds.set(aabbBounds.x1, dy, aabbBounds.x2, dy + h);
        }
        if (null != attribute.forceBoundsWidth) {
          const w = isNumber$6(attribute.forceBoundsWidth) ? attribute.forceBoundsWidth : attribute.forceBoundsWidth(),
            dx = textDrawOffsetX(textAlign, w);
          aabbBounds.set(dx, aabbBounds.y1, dx + w, aabbBounds.y2);
        }
      }
      combindShadowAABBBounds(bounds, graphic) {
        if (graphic && graphic.shadowRoot) {
          const b = graphic.shadowRoot.AABBBounds;
          bounds.union(b);
        }
      }
      transformAABBBounds(attribute, aabbBounds, theme, miter, graphic) {
        if (!aabbBounds.empty()) {
          const {
              scaleX = theme.scaleX,
              scaleY = theme.scaleY,
              stroke = theme.stroke,
              shadowBlur = theme.shadowBlur,
              lineWidth = theme.lineWidth,
              pickStrokeBuffer = theme.pickStrokeBuffer,
              strokeBoundsBuffer = theme.strokeBoundsBuffer
            } = attribute,
            tb1 = this.tempAABBBounds1,
            tb2 = this.tempAABBBounds2;
          if (stroke && lineWidth) {
            const scaledHalfLineWidth = (lineWidth + pickStrokeBuffer) / Math.abs(scaleX + scaleY);
            boundStroke(tb1, scaledHalfLineWidth, miter, strokeBoundsBuffer), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2);
          }
          if (shadowBlur) {
            const {
                shadowOffsetX = theme.shadowOffsetX,
                shadowOffsetY = theme.shadowOffsetY
              } = attribute,
              shadowBlurWidth = shadowBlur / Math.abs(scaleX + scaleY) * 2;
            boundStroke(tb1, shadowBlurWidth, !1, strokeBoundsBuffer + 1), tb1.translate(shadowOffsetX, shadowOffsetY), aabbBounds.union(tb1);
          }
        }
        if (this.combindShadowAABBBounds(aabbBounds, graphic), aabbBounds.empty()) return;
        let updateMatrix = !0;
        const m = graphic.transMatrix;
        graphic && graphic.isContainer && (updateMatrix = !(1 === m.a && 0 === m.b && 0 === m.c && 1 === m.d && 0 === m.e && 0 === m.f)), updateMatrix && transformBoundsWithMatrix$1(aabbBounds, aabbBounds, m);
      }
      validCheck(attribute, theme, aabbBounds, graphic) {
        if (!graphic) return !0;
        if (null != attribute.forceBoundsHeight || null != attribute.forceBoundsWidth) return !0;
        if (graphic.shadowRoot || graphic.isContainer) return !0;
        const {
          visible = theme.visible
        } = attribute;
        return !(!graphic.valid || !visible) || (aabbBounds.empty() || (graphic.parent && aabbBounds.transformWithMatrix(graphic.parent.globalTransMatrix), application.graphicService.clearAABBBounds(graphic, graphic.stage, aabbBounds), aabbBounds.clear()), !1);
      }
      updateTempAABBBounds(aabbBounds) {
        const tb1 = this.tempAABBBounds1,
          tb2 = this.tempAABBBounds2;
        return tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), {
          tb1: tb1,
          tb2: tb2
        };
      }
    };
    DefaultGraphicService = __decorate$W([injectable(), __param$z(0, inject(GraphicCreator$1)), __metadata$J("design:paramtypes", [Object])], DefaultGraphicService);

    const updateBoundsOfCommonOuterBorder = (attribute, theme, aabbBounds) => {
      const {
        outerBorder: outerBorder,
        shadowBlur = theme.shadowBlur
      } = attribute;
      if (outerBorder) {
        const defaultOuterBorder = theme.outerBorder,
          {
            distance = defaultOuterBorder.distance,
            lineWidth = defaultOuterBorder.lineWidth
          } = outerBorder;
        aabbBounds.expand(distance + (shadowBlur + lineWidth) / 2);
      }
      return aabbBounds;
    };

    const CIRCLE_UPDATE_TAG_KEY = ["radius", "startAngle", "endAngle", ...GRAPHIC_UPDATE_TAG_KEY];
    let Circle$1 = class Circle extends Graphic {
      constructor() {
        let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
          radius: 1
        };
        super(params), this.type = "circle", this.numberType = CIRCLE_NUMBER_TYPE;
      }
      isValid() {
        return super.isValid() && this._isValid();
      }
      _isValid() {
        const {
          startAngle: startAngle,
          endAngle: endAngle,
          radius: radius
        } = this.attribute;
        return this._validNumber(startAngle) && this._validNumber(endAngle) && this._validNumber(radius);
      }
      getGraphicTheme() {
        return getTheme(this).circle;
      }
      updateAABBBounds(attribute, circleTheme, aabbBounds, full) {
        this.updatePathProxyAABBBounds(aabbBounds) || (full ? this.updateCircleAABBBoundsImprecise(attribute, circleTheme, aabbBounds) : this.updateCircleAABBBoundsAccurate(attribute, circleTheme, aabbBounds));
        const {
          tb1: tb1,
          tb2: tb2
        } = application.graphicService.updateTempAABBBounds(aabbBounds);
        return updateBoundsOfCommonOuterBorder(attribute, circleTheme, tb1), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2), this.widthWithoutTransform = aabbBounds.x2 - aabbBounds.x1, this.heightWithoutTransform = aabbBounds.y2 - aabbBounds.y1, application.graphicService.transformAABBBounds(attribute, aabbBounds, circleTheme, !1, this), aabbBounds;
      }
      updateCircleAABBBoundsImprecise(attribute, circleTheme, aabbBounds) {
        const {
          radius = circleTheme.radius
        } = attribute;
        return aabbBounds.set(-radius, -radius, radius, radius), aabbBounds;
      }
      updateCircleAABBBoundsAccurate(attribute, circleTheme, aabbBounds) {
        const {
          startAngle = circleTheme.startAngle,
          endAngle = circleTheme.endAngle,
          radius = circleTheme.radius
        } = attribute;
        return endAngle - startAngle > pi2 - epsilon ? aabbBounds.set(-radius, -radius, radius, radius) : circleBounds(startAngle, endAngle, radius, aabbBounds), aabbBounds;
      }
      needUpdateTags(keys) {
        return super.needUpdateTags(keys, CIRCLE_UPDATE_TAG_KEY);
      }
      needUpdateTag(key) {
        return super.needUpdateTag(key, CIRCLE_UPDATE_TAG_KEY);
      }
      toCustomPath() {
        var _a, _b, _c;
        const attribute = this.attribute,
          radius = null !== (_a = attribute.radius) && void 0 !== _a ? _a : this.getDefaultAttribute("radius"),
          startAngle = null !== (_b = attribute.startAngle) && void 0 !== _b ? _b : this.getDefaultAttribute("startAngle"),
          endAngle = null !== (_c = attribute.endAngle) && void 0 !== _c ? _c : this.getDefaultAttribute("endAngle"),
          path = new CustomPath2D();
        return path.arc(0, 0, radius, startAngle, endAngle), path;
      }
      clone() {
        return new Circle(Object.assign({}, this.attribute));
      }
      getNoWorkAnimateAttr() {
        return Circle.NOWORK_ANIMATE_ATTR;
      }
    };
    Circle$1.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
    function createCircle(attributes) {
      return new Circle$1(attributes);
    }

    class CanvasTextLayout {
      constructor(fontFamily, options, textMeasure) {
        this.fontFamily = fontFamily, this.textOptions = options, this.textMeasure = textMeasure;
      }
      LayoutBBox(bbox, textAlign, textBaseline, linesLayout) {
        if (bbox.xOffset = "left" === textAlign || "start" === textAlign ? 0 : "center" === textAlign ? bbox.width / -2 : "right" === textAlign || "end" === textAlign ? -bbox.width : 0, "top" === textBaseline) bbox.yOffset = 0;else if ("middle" === textBaseline) bbox.yOffset = bbox.height / -2;else if ("alphabetic" === textBaseline) {
          let percent = .79;
          if (1 === linesLayout.length) {
            const lineInfo = linesLayout[0];
            percent = lineInfo.ascent / (lineInfo.ascent + lineInfo.descent);
          }
          bbox.yOffset = bbox.height * -percent;
        } else bbox.yOffset = -bbox.height;
        return bbox;
      }
      GetLayoutByLines(lines, textAlign, textBaseline, lineHeight) {
        let suffix = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "";
        let wordBreak = arguments.length > 5 ? arguments[5] : undefined;
        let params = arguments.length > 6 ? arguments[6] : undefined;
        const {
          lineWidth: lineWidth,
          suffixPosition = "end",
          measureMode = MeasureModeEnum.actualBounding,
          keepCenterInLine = !1
        } = null != params ? params : {};
        lines = lines.map(l => l.toString());
        const linesLayout = [],
          bboxWH = [0, 0];
        if ("number" == typeof lineWidth && lineWidth !== 1 / 0) {
          let width;
          for (let i = 0, len = lines.length; i < len; i++) {
            const metrics = this.textMeasure.measureTextPixelADscentAndWidth(lines[i], this.textOptions, measureMode);
            let str = lines[i].toString();
            if (metrics.width > lineWidth) {
              const data = this.textMeasure.clipTextWithSuffix(lines[i], this.textOptions, lineWidth, suffix, wordBreak, suffixPosition);
              str = data.str, width = data.width;
            } else width = metrics.width;
            linesLayout.push({
              str: str,
              width: width,
              ascent: metrics.ascent,
              descent: metrics.descent,
              keepCenterInLine: keepCenterInLine
            });
          }
          bboxWH[0] = lineWidth;
        } else {
          let width,
            text,
            _lineWidth = 0;
          for (let i = 0, len = lines.length; i < len; i++) {
            text = lines[i];
            const metrics = this.textMeasure.measureTextPixelADscentAndWidth(lines[i], this.textOptions, measureMode);
            width = metrics.width, _lineWidth = Math.max(_lineWidth, width), linesLayout.push({
              str: text,
              width: width,
              ascent: metrics.ascent,
              descent: metrics.descent,
              keepCenterInLine: keepCenterInLine
            });
          }
          bboxWH[0] = _lineWidth;
        }
        bboxWH[1] = linesLayout.length * lineHeight, bboxWH[0] = linesLayout.reduce((a, b) => Math.max(a, b.width), 0);
        const bbox = {
          xOffset: 0,
          yOffset: 0,
          width: bboxWH[0],
          height: bboxWH[1]
        };
        return this.LayoutBBox(bbox, textAlign, textBaseline, linesLayout), this.layoutWithBBox(bbox, linesLayout, textAlign, textBaseline, lineHeight);
      }
      layoutWithBBox(bbox, lines, textAlign, textBaseline, lineHeight) {
        const origin = [0, 0],
          totalLineHeight = lines.length * lineHeight;
        "top" === textBaseline || ("middle" === textBaseline ? origin[1] = (bbox.height - totalLineHeight) / 2 : "bottom" === textBaseline && (origin[1] = bbox.height - totalLineHeight));
        for (let i = 0; i < lines.length; i++) this.lineOffset(bbox, lines[i], textAlign, textBaseline, lineHeight, origin);
        return {
          bbox: bbox,
          lines: lines,
          fontFamily: this.fontFamily,
          fontSize: this.textOptions.fontSize,
          fontWeight: this.textOptions.fontWeight,
          lineHeight: lineHeight,
          textAlign: textAlign,
          textBaseline: textBaseline
        };
      }
      lineOffset(bbox, line, textAlign, textBaseline, lineHeight, origin) {
        if ("left" === textAlign || "start" === textAlign ? line.leftOffset = 0 : "center" === textAlign ? line.leftOffset = (bbox.width - line.width) / 2 : "right" !== textAlign && "end" !== textAlign || (line.leftOffset = bbox.width - line.width), line.topOffset = lineHeight / 2 + (line.ascent - line.descent) / 2 + origin[1], !line.keepCenterInLine) {
          const buf = 0,
            actualHeightWithBuf = line.ascent + line.descent + buf;
          if (actualHeightWithBuf < lineHeight - buf && ("bottom" === textBaseline ? line.topOffset += (lineHeight - actualHeightWithBuf) / 2 : "top" === textBaseline && (line.topOffset -= (lineHeight - actualHeightWithBuf) / 2)), "alphabetic" === textBaseline) {
            const ratio = lineHeight / (line.ascent + line.descent);
            line.topOffset = lineHeight / 2 + (line.ascent - line.descent) / 2 * ratio + origin[1];
          }
        }
        return origin[1] += lineHeight, line;
      }
    }

    const TEXT_UPDATE_TAG_KEY = ["text", "maxLineWidth", "maxWidth", "textAlign", "textBaseline", "heightLimit", "lineClamp", "fontSize", "fontFamily", "fontWeight", "ellipsis", "lineHeight", "direction", "wordBreak", "heightLimit", "lineClamp", ...GRAPHIC_UPDATE_TAG_KEY];
    let Text$1 = class Text extends Graphic {
      get font() {
        const textTheme = this.getGraphicTheme();
        return this._font || (this._font = getContextFont$1(this.attribute, textTheme)), this._font;
      }
      get clipedText() {
        var _a;
        const attribute = this.attribute,
          textTheme = this.getGraphicTheme(),
          maxWidth = this.getMaxWidth(textTheme);
        return Number.isFinite(maxWidth) ? (this.tryUpdateAABBBounds(), this.cache.clipedText) : (null !== (_a = attribute.text) && void 0 !== _a ? _a : textTheme.text).toString();
      }
      get clipedWidth() {
        return this.tryUpdateAABBBounds(), this.cache.clipedWidth;
      }
      get cliped() {
        var _a, _b;
        const textTheme = this.getGraphicTheme(),
          attribute = this.attribute,
          maxWidth = this.getMaxWidth(textTheme);
        if (!Number.isFinite(maxWidth)) return !1;
        const {
          text: text
        } = this.attribute;
        if (this.tryUpdateAABBBounds(), null === (_b = null === (_a = this.cache) || void 0 === _a ? void 0 : _a.layoutData) || void 0 === _b ? void 0 : _b.lines) {
          let mergedText = "";
          this.cache.layoutData.lines.forEach(item => {
            mergedText += item.str;
          });
          return (Array.isArray(text) ? text.join("") : text) !== mergedText;
        }
        return "vertical" === attribute.direction && this.cache.verticalList && this.cache.verticalList[0] ? this.cache.verticalList[0].map(item => item.text).join("") !== attribute.text.toString() : null != this.clipedText && this.clipedText !== attribute.text.toString();
      }
      get multilineLayout() {
        return this.tryUpdateAABBBounds(), this.cache.layoutData;
      }
      get isMultiLine() {
        return Array.isArray(this.attribute.text) || "normal" === this.attribute.whiteSpace;
      }
      constructor() {
        let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
          text: "",
          fontSize: 16
        };
        super(params), this.type = "text", this.numberType = TEXT_NUMBER_TYPE, this.cache = {};
      }
      isValid() {
        return super.isValid() && this._isValid();
      }
      _isValid() {
        const {
          text: text
        } = this.attribute;
        return isArray$9(text) ? !text.every(t => null == t || "" === t) : null != text && "" !== text;
      }
      getGraphicTheme() {
        return getTheme(this).text;
      }
      doUpdateOBBBounds() {
        const graphicTheme = this.getGraphicTheme();
        this._OBBBounds.clear();
        const attribute = this.attribute,
          {
            angle = graphicTheme.angle
          } = attribute;
        if (!angle) {
          const b = this.AABBBounds;
          return this._OBBBounds.setValue(b.x1, b.y1, b.x2, b.y2), this._OBBBounds;
        }
        this.obbText || (this.obbText = new Text({})), this.obbText.setAttributes(Object.assign(Object.assign({}, attribute), {
          angle: 0
        }));
        const bounds1 = this.obbText.AABBBounds,
          {
            x: x,
            y: y
          } = attribute,
          boundsCenter = {
            x: (bounds1.x1 + bounds1.x2) / 2,
            y: (bounds1.y1 + bounds1.y2) / 2
          },
          center = rotatePoint(boundsCenter, angle, {
            x: x,
            y: y
          });
        return this._OBBBounds.copy(bounds1), this._OBBBounds.translate(center.x - boundsCenter.x, center.y - boundsCenter.y), this._OBBBounds.angle = angle, this._OBBBounds;
      }
      updateAABBBounds(attribute, textTheme, aabbBounds) {
        const {
          text = textTheme.text
        } = this.attribute;
        Array.isArray(text) ? this.updateMultilineAABBBounds(text) : this.updateSingallineAABBBounds(text);
        const {
            tb1: tb1
          } = application.graphicService.updateTempAABBBounds(aabbBounds),
          {
            scaleX = textTheme.scaleX,
            scaleY = textTheme.scaleY,
            shadowBlur = textTheme.shadowBlur,
            strokeBoundsBuffer = textTheme.strokeBoundsBuffer
          } = attribute;
        if (shadowBlur) {
          const shadowBlurHalfWidth = shadowBlur / Math.abs(scaleX + scaleY);
          boundStroke(tb1, shadowBlurHalfWidth, !0, strokeBoundsBuffer), aabbBounds.union(tb1);
        }
        return application.graphicService.combindShadowAABBBounds(aabbBounds, this), null == attribute.forceBoundsHeight && null == attribute.forceBoundsWidth || application.graphicService.updateHTMLTextAABBBounds(attribute, textTheme, aabbBounds), this.widthWithoutTransform = aabbBounds.x2 - aabbBounds.x1, this.heightWithoutTransform = aabbBounds.y2 - aabbBounds.y1, transformBoundsWithMatrix$1(aabbBounds, aabbBounds, this.transMatrix), aabbBounds;
      }
      updateSingallineAABBBounds(text) {
        this.updateMultilineAABBBounds([text]);
        const layoutData = this.cache.layoutData;
        if (layoutData && layoutData.lines && layoutData.lines.length) {
          const line = layoutData.lines[0];
          this.cache.clipedText = line.str, this.cache.clipedWidth = line.width;
        }
        return this._AABBBounds;
      }
      updateMultilineAABBBounds(text) {
        const textTheme = this.getGraphicTheme(),
          {
            direction = textTheme.direction,
            underlineOffset = textTheme.underlineOffset
          } = this.attribute,
          b = "horizontal" === direction ? this.updateHorizontalMultilineAABBBounds(text) : this.updateVerticalMultilineAABBBounds(text);
        return "horizontal" === direction && underlineOffset && this._AABBBounds.add(this._AABBBounds.x1, this._AABBBounds.y2 + underlineOffset), b;
      }
      guessLineHeightBuf(fontSize) {
        return fontSize ? .1 * fontSize : 0;
      }
      updateHorizontalMultilineAABBBounds(text) {
        var _a;
        const textTheme = this.getGraphicTheme(),
          attribute = this.attribute,
          {
            fontFamily = textTheme.fontFamily,
            textAlign = textTheme.textAlign,
            textBaseline = textTheme.textBaseline,
            fontSize = textTheme.fontSize,
            fontWeight = textTheme.fontWeight,
            ellipsis = textTheme.ellipsis,
            maxLineWidth: maxLineWidth,
            stroke = textTheme.stroke,
            wrap = textTheme.wrap,
            measureMode = textTheme.measureMode,
            lineWidth = textTheme.lineWidth,
            whiteSpace = textTheme.whiteSpace,
            suffixPosition = textTheme.suffixPosition,
            ignoreBuf = textTheme.ignoreBuf,
            keepCenterInLine = textTheme.keepCenterInLine
          } = attribute,
          buf = ignoreBuf ? 0 : this.guessLineHeightBuf(fontSize),
          lineHeight = this.getLineHeight(attribute, textTheme, buf);
        if ("normal" === whiteSpace || wrap) return this.updateWrapAABBBounds(text);
        if (!this.shouldUpdateShape() && (null === (_a = this.cache) || void 0 === _a ? void 0 : _a.layoutData)) {
          const bbox = this.cache.layoutData.bbox;
          return this._AABBBounds.set(bbox.xOffset, bbox.yOffset, bbox.xOffset + bbox.width, bbox.yOffset + bbox.height), stroke && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
        }
        const textMeasure = application.graphicUtil.textMeasure,
          layoutData = new CanvasTextLayout(fontFamily, {
            fontSize: fontSize,
            fontWeight: fontWeight,
            fontFamily: fontFamily,
            lineHeight: lineHeight
          }, textMeasure).GetLayoutByLines(text, textAlign, textBaseline, lineHeight, !0 === ellipsis ? textTheme.ellipsis : ellipsis || void 0, !1, {
            lineWidth: maxLineWidth,
            suffixPosition: suffixPosition,
            measureMode: measureMode,
            keepCenterInLine: keepCenterInLine
          }),
          {
            bbox: bbox
          } = layoutData;
        return this.cache.layoutData = layoutData, this.clearUpdateShapeTag(), this._AABBBounds.set(bbox.xOffset, bbox.yOffset, bbox.xOffset + bbox.width, bbox.yOffset + bbox.height), stroke && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
      }
      updateWrapAABBBounds(text) {
        var _a, _b, _c;
        const textTheme = this.getGraphicTheme(),
          {
            fontFamily = textTheme.fontFamily,
            textAlign = textTheme.textAlign,
            textBaseline = textTheme.textBaseline,
            fontSize = textTheme.fontSize,
            ellipsis = textTheme.ellipsis,
            maxLineWidth: maxLineWidth,
            stroke = textTheme.stroke,
            lineWidth = textTheme.lineWidth,
            wordBreak = textTheme.wordBreak,
            fontWeight = textTheme.fontWeight,
            ignoreBuf = textTheme.ignoreBuf,
            measureMode = textTheme.measureMode,
            suffixPosition = textTheme.suffixPosition,
            heightLimit = 0,
            lineClamp: lineClamp,
            keepCenterInLine = textTheme.keepCenterInLine
          } = this.attribute,
          buf = ignoreBuf ? 0 : this.guessLineHeightBuf(fontSize),
          lineHeight = this.getLineHeight(this.attribute, textTheme, buf);
        if (!this.shouldUpdateShape() && (null === (_a = this.cache) || void 0 === _a ? void 0 : _a.layoutData)) {
          const bbox = this.cache.layoutData.bbox;
          return this._AABBBounds.set(bbox.xOffset, bbox.yOffset, bbox.xOffset + bbox.width, bbox.yOffset + bbox.height), stroke && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
        }
        const textMeasure = application.graphicUtil.textMeasure,
          textOptions = {
            fontSize: fontSize,
            fontWeight: fontWeight,
            fontFamily: fontFamily,
            lineHeight: lineHeight
          },
          layoutObj = new CanvasTextLayout(fontFamily, textOptions, textMeasure),
          lines = isArray$9(text) ? text.map(l => l.toString()) : [text.toString()],
          linesLayout = [],
          bboxWH = [0, 0];
        let lineCountLimit = 1 / 0;
        if (heightLimit > 0 && (lineCountLimit = Math.max(Math.floor(heightLimit / lineHeight), 1)), lineClamp && (lineCountLimit = Math.min(lineCountLimit, lineClamp)), "number" == typeof maxLineWidth && maxLineWidth !== 1 / 0) {
          if (maxLineWidth > 0) for (let i = 0; i < lines.length; i++) {
            const str = lines[i];
            let needCut = !0;
            if (i === lineCountLimit - 1) {
              const clip = textMeasure.clipTextWithSuffix(str, textOptions, maxLineWidth, ellipsis, !1, suffixPosition, i !== lines.length - 1),
                matrics = textMeasure.measureTextPixelADscentAndWidth(clip.str, textOptions, measureMode);
              linesLayout.push({
                str: clip.str,
                width: clip.width,
                ascent: matrics.ascent,
                descent: matrics.descent,
                keepCenterInLine: keepCenterInLine
              });
              break;
            }
            const clip = textMeasure.clipText(str, textOptions, maxLineWidth, "break-all" !== wordBreak, "keep-all" === wordBreak);
            if ("" !== str && "" === clip.str || clip.wordBreaked) {
              if (ellipsis) {
                const clipEllipsis = textMeasure.clipTextWithSuffix(str, textOptions, maxLineWidth, ellipsis, !1, suffixPosition);
                clip.str = null !== (_b = clipEllipsis.str) && void 0 !== _b ? _b : "", clip.width = null !== (_c = clipEllipsis.width) && void 0 !== _c ? _c : 0;
              } else clip.str = "", clip.width = 0;
              needCut = !1;
            }
            const matrics = textMeasure.measureTextPixelADscentAndWidth(clip.str, textOptions, measureMode);
            linesLayout.push({
              str: clip.str,
              width: clip.width,
              ascent: matrics.ascent,
              descent: matrics.descent,
              keepCenterInLine: keepCenterInLine
            });
            let cutLength = clip.str.length;
            if (!clip.wordBreaked || "" !== str && "" === clip.str || (needCut = !0, cutLength = clip.wordBreaked), clip.str.length === str.length) ;else if (needCut) {
              let newStr = str.substring(cutLength);
              "keep-all" === wordBreak && (newStr = newStr.replace(/^\s+/g, "")), lines.splice(i + 1, 0, newStr);
            }
          }
          let maxWidth = 0;
          linesLayout.forEach(layout => {
            maxWidth = Math.max(maxWidth, layout.width);
          }), bboxWH[0] = maxWidth;
        } else {
          let width,
            text,
            lineWidth = 0;
          for (let i = 0, len = lines.length; i < len; i++) {
            if (i === lineCountLimit - 1) {
              const clip = textMeasure.clipTextWithSuffix(lines[i], textOptions, maxLineWidth, ellipsis, !1, suffixPosition),
                matrics = textMeasure.measureTextPixelADscentAndWidth(clip.str, textOptions, measureMode);
              linesLayout.push({
                str: clip.str,
                width: clip.width,
                ascent: matrics.ascent,
                descent: matrics.descent,
                keepCenterInLine: keepCenterInLine
              }), lineWidth = Math.max(lineWidth, clip.width);
              break;
            }
            text = lines[i], width = textMeasure.measureTextWidth(text, textOptions), lineWidth = Math.max(lineWidth, width);
            const matrics = textMeasure.measureTextPixelADscentAndWidth(text, textOptions, measureMode);
            linesLayout.push({
              str: text,
              width: width,
              ascent: matrics.ascent,
              descent: matrics.descent,
              keepCenterInLine: keepCenterInLine
            });
          }
          bboxWH[0] = lineWidth;
        }
        bboxWH[1] = linesLayout.length * lineHeight;
        const bbox = {
          xOffset: 0,
          yOffset: 0,
          width: bboxWH[0],
          height: bboxWH[1]
        };
        layoutObj.LayoutBBox(bbox, textAlign, textBaseline, linesLayout);
        const layoutData = layoutObj.layoutWithBBox(bbox, linesLayout, textAlign, textBaseline, lineHeight);
        return this.cache.layoutData = layoutData, this.clearUpdateShapeTag(), this._AABBBounds.set(bbox.xOffset, bbox.yOffset, bbox.xOffset + bbox.width, bbox.yOffset + bbox.height), stroke && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
      }
      updateVerticalMultilineAABBBounds(text) {
        var _a, _b;
        const textTheme = this.getGraphicTheme(),
          textMeasure = application.graphicUtil.textMeasure;
        let width;
        const attribute = this.attribute,
          {
            maxLineWidth = textTheme.maxLineWidth,
            ellipsis = textTheme.ellipsis,
            fontFamily = textTheme.fontFamily,
            fontSize = textTheme.fontSize,
            fontWeight = textTheme.fontWeight,
            stroke = textTheme.stroke,
            lineWidth = textTheme.lineWidth,
            verticalMode = textTheme.verticalMode,
            suffixPosition = textTheme.suffixPosition
          } = attribute,
          lineHeight = this.getLineHeight(attribute, textTheme, 0);
        let {
          textAlign = textTheme.textAlign,
          textBaseline = textTheme.textBaseline
        } = attribute;
        if (!verticalMode) {
          const t = textAlign;
          textAlign = null !== (_a = Text.baselineMapAlign[textBaseline]) && void 0 !== _a ? _a : "left", textBaseline = null !== (_b = Text.alignMapBaseline[t]) && void 0 !== _b ? _b : "top";
        }
        if (width = 0, !this.shouldUpdateShape() && this.cache) {
          this.cache.verticalList.forEach(item => {
            const w = item.reduce((a, b) => a + b.width, 0);
            width = max(w, width);
          });
          const dx = textDrawOffsetX(textAlign, width),
            height = this.cache.verticalList.length * lineHeight,
            dy = textLayoutOffsetY(textBaseline, height, fontSize);
          return this._AABBBounds.set(dy, dx, dy + height, dx + width), stroke && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
        }
        const verticalLists = text.map(str => verticalLayout(str.toString()));
        verticalLists.forEach((verticalData, i) => {
          if (Number.isFinite(maxLineWidth)) {
            if (ellipsis) {
              const strEllipsis = !0 === ellipsis ? textTheme.ellipsis : ellipsis,
                data = textMeasure.clipTextWithSuffixVertical(verticalData, {
                  fontSize: fontSize,
                  fontWeight: fontWeight,
                  fontFamily: fontFamily
                }, maxLineWidth, strEllipsis, !1, suffixPosition);
              verticalLists[i] = data.verticalList, width = data.width;
            } else {
              const data = textMeasure.clipTextVertical(verticalData, {
                fontSize: fontSize,
                fontWeight: fontWeight,
                fontFamily: fontFamily
              }, maxLineWidth, !1);
              verticalLists[i] = data.verticalList, width = data.width;
            }
          } else width = 0, verticalData.forEach(t => {
            const w = t.direction === TextDirection.HORIZONTAL ? fontSize : textMeasure.measureTextWidth(t.text, {
              fontSize: fontSize,
              fontWeight: fontWeight,
              fontFamily: fontFamily
            });
            width += w, t.width = w;
          });
        }), this.cache.verticalList = verticalLists, this.clearUpdateShapeTag(), this.cache.verticalList.forEach(item => {
          const w = item.reduce((a, b) => a + b.width, 0);
          width = max(w, width);
        });
        const dx = textDrawOffsetX(textAlign, width),
          height = this.cache.verticalList.length * lineHeight,
          dy = textLayoutOffsetY(textBaseline, height, fontSize);
        return this._AABBBounds.set(dy, dx, dy + height, dx + width), stroke && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
      }
      getMaxWidth(theme) {
        var _a, _b;
        const attribute = this.attribute;
        return null !== (_b = null !== (_a = attribute.maxLineWidth) && void 0 !== _a ? _a : attribute.maxWidth) && void 0 !== _b ? _b : theme.maxWidth;
      }
      getLineHeight(attribute, textTheme, buf) {
        var _a;
        return null !== (_a = calculateLineHeight(attribute.lineHeight, attribute.fontSize || textTheme.fontSize)) && void 0 !== _a ? _a : (attribute.fontSize || textTheme.fontSize) + buf;
      }
      needUpdateTags(keys) {
        let k = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TEXT_UPDATE_TAG_KEY;
        return super.needUpdateTags(keys, k);
      }
      needUpdateTag(key) {
        let k = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TEXT_UPDATE_TAG_KEY;
        return super.needUpdateTag(key, k);
      }
      _interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes) {
        "text" === key && (nextAttributes.text = nextStepVal);
      }
      clone() {
        return new Text(Object.assign({}, this.attribute));
      }
      getNoWorkAnimateAttr() {
        return Text.NOWORK_ANIMATE_ATTR;
      }
      getBaselineMapAlign() {
        return Text.baselineMapAlign;
      }
      getAlignMapBaseline() {
        return Text.alignMapBaseline;
      }
    };
    Text$1.NOWORK_ANIMATE_ATTR = Object.assign({
      ellipsis: 1,
      wordBreak: 1,
      direction: 1,
      textAlign: 1,
      textBaseline: 1,
      fontFamily: 1,
      fontWeight: 1
    }, NOWORK_ANIMATE_ATTR), Text$1.baselineMapAlign = {
      top: "left",
      bottom: "right",
      middle: "center"
    }, Text$1.alignMapBaseline = {
      left: "top",
      right: "bottom",
      center: "middle"
    };
    function createText(attributes) {
      return new Text$1(attributes);
    }

    const WRAP_TEXT_UPDATE_TAG_KEY = ["heightLimit", "lineClamp"];
    class WrapText extends Text$1 {
      constructor(params) {
        super(Object.assign(Object.assign({}, params), {
          wrap: !0
        }));
      }
      _isValid() {
        const {
          text: text
        } = this.attribute;
        return isArray$9(text) ? !text.every(t => null == t || "" === t) : null != text && "" !== text;
      }
      updateMultilineAABBBounds(text) {
        var _a, _b, _c, _d;
        const textTheme = this.getGraphicTheme(),
          {
            fontFamily = textTheme.fontFamily,
            textAlign = textTheme.textAlign,
            textBaseline = textTheme.textBaseline,
            fontSize = textTheme.fontSize,
            ellipsis = textTheme.ellipsis,
            maxLineWidth: maxLineWidth,
            stroke = textTheme.stroke,
            lineWidth = textTheme.lineWidth,
            wordBreak = textTheme.wordBreak,
            fontWeight = textTheme.fontWeight,
            ignoreBuf = textTheme.ignoreBuf,
            heightLimit = 0,
            suffixPosition = textTheme.suffixPosition,
            lineClamp: lineClamp
          } = this.attribute,
          lineHeight = null !== (_a = calculateLineHeight(this.attribute.lineHeight, this.attribute.fontSize || textTheme.fontSize)) && void 0 !== _a ? _a : this.attribute.fontSize || textTheme.fontSize,
          buf = ignoreBuf ? 0 : 2;
        if (!this.shouldUpdateShape() && (null === (_b = this.cache) || void 0 === _b ? void 0 : _b.layoutData)) {
          const bbox = this.cache.layoutData.bbox;
          return this._AABBBounds.set(bbox.xOffset, bbox.yOffset, bbox.xOffset + bbox.width, bbox.yOffset + bbox.height), stroke && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
        }
        const textMeasure = application.graphicUtil.textMeasure,
          layoutObj = new CanvasTextLayout(fontFamily, {
            fontSize: fontSize,
            fontWeight: fontWeight,
            fontFamily: fontFamily
          }, textMeasure),
          lines = text.map(l => l.toString()),
          linesLayout = [],
          bboxWH = [0, 0];
        let lineCountLimit = 1 / 0;
        if (heightLimit > 0 && (lineCountLimit = Math.max(Math.floor(heightLimit / lineHeight), 1)), lineClamp && (lineCountLimit = Math.min(lineCountLimit, lineClamp)), "number" == typeof maxLineWidth && maxLineWidth !== 1 / 0) {
          if (maxLineWidth > 0) for (let i = 0; i < lines.length; i++) {
            const str = lines[i];
            let needCut = !0;
            if (i === lineCountLimit - 1) {
              const clip = layoutObj.textMeasure.clipTextWithSuffix(str, layoutObj.textOptions, maxLineWidth, ellipsis, !1, suffixPosition);
              linesLayout.push({
                str: clip.str,
                width: clip.width,
                ascent: 0,
                descent: 0,
                keepCenterInLine: !1
              });
              break;
            }
            const clip = layoutObj.textMeasure.clipText(str, layoutObj.textOptions, maxLineWidth, "break-word" === wordBreak);
            if ("" !== str && "" === clip.str) {
              if (ellipsis) {
                const clipEllipsis = layoutObj.textMeasure.clipTextWithSuffix(str, layoutObj.textOptions, maxLineWidth, ellipsis, !1, suffixPosition);
                clip.str = null !== (_c = clipEllipsis.str) && void 0 !== _c ? _c : "", clip.width = null !== (_d = clipEllipsis.width) && void 0 !== _d ? _d : 0;
              } else clip.str = "", clip.width = 0;
              needCut = !1;
            }
            if (linesLayout.push({
              str: clip.str,
              width: clip.width,
              ascent: 0,
              descent: 0,
              keepCenterInLine: !1
            }), clip.str.length === str.length) ;else if (needCut) {
              const newStr = str.substring(clip.str.length);
              lines.splice(i + 1, 0, newStr);
            }
          }
          let maxWidth = 0;
          linesLayout.forEach(layout => {
            maxWidth = Math.max(maxWidth, layout.width);
          }), bboxWH[0] = maxWidth;
        } else {
          let width,
            text,
            lineWidth = 0;
          for (let i = 0, len = lines.length; i < len; i++) {
            if (i === lineCountLimit - 1) {
              const clip = layoutObj.textMeasure.clipTextWithSuffix(lines[i], layoutObj.textOptions, maxLineWidth, ellipsis, !1, suffixPosition);
              linesLayout.push({
                str: clip.str,
                width: clip.width,
                ascent: 0,
                descent: 0,
                keepCenterInLine: !1
              }), lineWidth = Math.max(lineWidth, clip.width);
              break;
            }
            text = lines[i], width = layoutObj.textMeasure.measureTextWidth(text, layoutObj.textOptions, "break-word" === wordBreak), lineWidth = Math.max(lineWidth, width), linesLayout.push({
              str: text,
              width: width,
              ascent: 0,
              descent: 0,
              keepCenterInLine: !1
            });
          }
          bboxWH[0] = lineWidth;
        }
        bboxWH[1] = linesLayout.length * (lineHeight + buf);
        const bbox = {
          xOffset: 0,
          yOffset: 0,
          width: bboxWH[0],
          height: bboxWH[1]
        };
        layoutObj.LayoutBBox(bbox, textAlign, textBaseline);
        const layoutData = layoutObj.layoutWithBBox(bbox, linesLayout, textAlign, textBaseline, lineHeight);
        return this.cache.layoutData = layoutData, this.clearUpdateShapeTag(), this._AABBBounds.set(bbox.xOffset, bbox.yOffset, bbox.xOffset + bbox.width, bbox.yOffset + bbox.height), stroke && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
      }
      needUpdateTags(keys) {
        for (let i = 0; i < WRAP_TEXT_UPDATE_TAG_KEY.length; i++) {
          const attrKey = WRAP_TEXT_UPDATE_TAG_KEY[i];
          if (-1 !== keys.indexOf(attrKey)) return !0;
        }
        return super.needUpdateTags(keys);
      }
      needUpdateTag(key) {
        for (let i = 0; i < WRAP_TEXT_UPDATE_TAG_KEY.length; i++) {
          if (key === WRAP_TEXT_UPDATE_TAG_KEY[i]) return !0;
        }
        return super.needUpdateTag(key);
      }
      getNoWorkAnimateAttr() {
        return WrapText.NOWORK_ANIMATE_ATTR;
      }
    }
    function createWrapText(attributes) {
      return new WrapText(attributes);
    }

    const updateBoundsOfSymbolOuterBorder = (attribute, symbolTheme, aabbBounds) => {
      const {
        outerBorder: outerBorder,
        shadowBlur = symbolTheme.shadowBlur,
        strokeBoundsBuffer = symbolTheme.strokeBoundsBuffer
      } = attribute;
      if (outerBorder) {
        const defaultOuterBorder = symbolTheme.outerBorder,
          {
            distance = defaultOuterBorder.distance,
            lineWidth = defaultOuterBorder.lineWidth
          } = outerBorder;
        boundStroke(aabbBounds, distance + (shadowBlur + lineWidth) / 2, !0, strokeBoundsBuffer);
      }
      return aabbBounds;
    };

    const SYMBOL_UPDATE_TAG_KEY = ["symbolType", "size", ...GRAPHIC_UPDATE_TAG_KEY];
    let Symbol$5 = class Symbol extends Graphic {
      constructor() {
        let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
          symbolType: "circle"
        };
        super(params), this.type = "symbol", this.numberType = SYMBOL_NUMBER_TYPE;
      }
      getParsedPath() {
        return this.shouldUpdateShape() && (this._parsedPath = this.doUpdateParsedPath(), this.clearUpdateShapeTag()), this._parsedPath;
      }
      getParsedPath2D() {
        let x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        let y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        let size = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
        let path = null;
        try {
          path = new Path2D();
        } catch (err) {
          return null;
        }
        const parsedPath = this.getParsedPath();
        if (!parsedPath) return null;
        parsedPath.draw(path, size, x, y);
      }
      isValid() {
        return super.isValid() && this._isValid();
      }
      _isValid() {
        const {
          size: size
        } = this.attribute;
        return isArray$9(size) ? 2 === size.length && size.every(this._validNumber) : this._validNumber(size);
      }
      doUpdateParsedPath() {
        const {
          symbolType = "circle"
        } = this.attribute;
        return super.parsePath(symbolType);
      }
      getGraphicTheme() {
        return getTheme(this).symbol;
      }
      updateAABBBounds(attribute, symbolTheme, aabbBounds, full) {
        this.updatePathProxyAABBBounds(aabbBounds) || (full ? this.updateSymbolAABBBoundsImprecise(attribute, symbolTheme, aabbBounds) : this.updateSymbolAABBBoundsAccurate(attribute, symbolTheme, aabbBounds));
        const {
          tb1: tb1,
          tb2: tb2
        } = application.graphicService.updateTempAABBBounds(aabbBounds);
        updateBoundsOfSymbolOuterBorder(attribute, symbolTheme, tb1), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2), this.widthWithoutTransform = aabbBounds.x2 - aabbBounds.x1, this.heightWithoutTransform = aabbBounds.y2 - aabbBounds.y1, this.x1WithoutTransform = aabbBounds.x1, this.y1WithoutTransform = aabbBounds.y1;
        const {
          lineJoin = symbolTheme.lineJoin
        } = attribute;
        return application.graphicService.transformAABBBounds(attribute, aabbBounds, symbolTheme, "miter" === lineJoin, this), aabbBounds;
      }
      updateSymbolAABBBoundsImprecise(attribute, symbolTheme, aabbBounds) {
        const {
          size = symbolTheme.size
        } = attribute;
        if (isArray$9(size)) aabbBounds.set(-size[0] / 2, -size[1] / 2, size[0] / 2, size[1] / 2);else {
          const halfWH = size / 2;
          aabbBounds.set(-halfWH, -halfWH, halfWH, halfWH);
        }
        return aabbBounds;
      }
      updateSymbolAABBBoundsAccurate(attribute, symbolTheme, aabbBounds) {
        const {
          size = symbolTheme.size
        } = attribute;
        return this.getParsedPath().bounds(size, aabbBounds), aabbBounds;
      }
      needUpdateTags(keys) {
        return super.needUpdateTags(keys, SYMBOL_UPDATE_TAG_KEY);
      }
      needUpdateTag(key) {
        return super.needUpdateTag(key, SYMBOL_UPDATE_TAG_KEY);
      }
      toCustomPath() {
        const symbolInstance = this.getParsedPath(),
          size = this.attribute.size,
          formattedSize = isArray$9(size) ? size : [size, size];
        return symbolInstance.path ? new CustomPath2D().fromCustomPath2D(symbolInstance.path, 0, 0, formattedSize[0], formattedSize[1]) : new CustomPath2D().fromString(symbolInstance.pathStr, 0, 0, formattedSize[0], formattedSize[1]);
      }
      clone() {
        return new Symbol(Object.assign({}, this.attribute));
      }
      getNoWorkAnimateAttr() {
        return Symbol.NOWORK_ANIMATE_ATTR;
      }
    };
    Symbol$5.NOWORK_ANIMATE_ATTR = Object.assign({
      symbolType: 1
    }, NOWORK_ANIMATE_ATTR);
    function createSymbol(attributes) {
      return new Symbol$5(attributes);
    }

    const LINE_UPDATE_TAG_KEY = ["segments", "points", "curveType", "curveTension", ...GRAPHIC_UPDATE_TAG_KEY];
    let Line$1 = class Line extends Graphic {
      constructor() {
        let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        super(params), this.type = "line", this.numberType = LINE_NUMBER_TYPE;
      }
      isValid() {
        return super.isValid() && this._isValid();
      }
      _isValid() {
        if (this.pathProxy) return !0;
        const {
          points: points,
          segments: segments
        } = this.attribute;
        return segments ? 0 !== segments.length : !!points && !(points.length <= 1);
      }
      _interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes) {
        "points" === key && (nextAttributes.points = pointsInterpolation(lastStepVal, nextStepVal, ratio));
      }
      getGraphicTheme() {
        return getTheme(this).line;
      }
      updateAABBBounds(attribute, lineTheme, aabbBounds) {
        this.updatePathProxyAABBBounds(aabbBounds) || (attribute.segments ? this.updateLineAABBBoundsBySegments(attribute, lineTheme, aabbBounds) : this.updateLineAABBBoundsByPoints(attribute, lineTheme, aabbBounds)), application.graphicService.updateTempAABBBounds(aabbBounds), this.widthWithoutTransform = aabbBounds.x2 - aabbBounds.x1, this.heightWithoutTransform = aabbBounds.y2 - aabbBounds.y1;
        const {
          lineJoin = lineTheme.lineJoin
        } = attribute;
        return application.graphicService.transformAABBBounds(attribute, aabbBounds, lineTheme, "miter" === lineJoin, this), aabbBounds;
      }
      updateLineAABBBoundsByPoints(attribute, lineTheme, aabbBounds, graphic) {
        const {
            points = lineTheme.points,
            connectedType: connectedType
          } = attribute,
          b = aabbBounds;
        return points.forEach(p => {
          !1 === p.defined && "connect" !== connectedType || b.add(p.x, p.y);
        }), b;
      }
      updateLineAABBBoundsBySegments(attribute, lineTheme, aabbBounds, graphic) {
        const {
            segments = lineTheme.segments,
            connectedType: connectedType
          } = attribute,
          b = aabbBounds;
        return segments.forEach(s => {
          s.points.forEach(p => {
            !1 === p.defined && "connect" !== connectedType || b.add(p.x, p.y);
          });
        }), b;
      }
      needUpdateTags(keys) {
        return super.needUpdateTags(keys, LINE_UPDATE_TAG_KEY);
      }
      needUpdateTag(key) {
        return super.needUpdateTag(key, LINE_UPDATE_TAG_KEY);
      }
      toCustomPath() {
        const attribute = this.attribute,
          path = new CustomPath2D(),
          segments = attribute.segments,
          parsePoints = points => {
            if (points && points.length) {
              let isFirst = !0;
              points.forEach(point => {
                !1 !== point.defined && (isFirst ? path.moveTo(point.x, point.y) : path.lineTo(point.x, point.y), isFirst = !1);
              });
            }
          };
        return segments && segments.length ? segments.forEach(seg => {
          parsePoints(seg.points);
        }) : attribute.points && parsePoints(attribute.points), path;
      }
      clone() {
        return new Line(Object.assign({}, this.attribute));
      }
      getNoWorkAnimateAttr() {
        return Line.NOWORK_ANIMATE_ATTR;
      }
    };
    Line$1.NOWORK_ANIMATE_ATTR = Object.assign({
      segments: 1,
      curveType: 1
    }, NOWORK_ANIMATE_ATTR);
    function createLine(attributes) {
      return new Line$1(attributes);
    }

    const RECT_UPDATE_TAG_KEY = ["width", "x1", "y1", "height", "cornerRadius", ...GRAPHIC_UPDATE_TAG_KEY];
    let Rect$2 = class Rect extends Graphic {
      constructor(params) {
        super(params), this.type = "rect", this.numberType = RECT_NUMBER_TYPE;
      }
      isValid() {
        return super.isValid() && this._isValid();
      }
      _isValid() {
        return !0;
      }
      getGraphicTheme() {
        return getTheme(this).rect;
      }
      updateAABBBounds(attribute, rectTheme, aabbBounds) {
        if (!this.updatePathProxyAABBBounds(aabbBounds)) {
          let {
            width: width,
            height: height
          } = attribute;
          const {
            x1: x1,
            y1: y1,
            x: x,
            y: y
          } = attribute;
          width = null != width ? width : x1 - x, height = null != height ? height : y1 - y, (isFinite(width) || isFinite(height) || isFinite(x) || isFinite(y)) && aabbBounds.set(0, 0, width || 0, height || 0);
        }
        const {
          tb1: tb1,
          tb2: tb2
        } = application.graphicService.updateTempAABBBounds(aabbBounds);
        return updateBoundsOfCommonOuterBorder(attribute, rectTheme, tb1), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2), this.widthWithoutTransform = aabbBounds.x2 - aabbBounds.x1, this.heightWithoutTransform = aabbBounds.y2 - aabbBounds.y1, application.graphicService.transformAABBBounds(attribute, aabbBounds, rectTheme, !1, this), aabbBounds;
      }
      needUpdateTags(keys) {
        return super.needUpdateTags(keys, RECT_UPDATE_TAG_KEY);
      }
      needUpdateTag(key) {
        return super.needUpdateTag(key, RECT_UPDATE_TAG_KEY);
      }
      toCustomPath() {
        const attribute = this.attribute,
          {
            x: x,
            y: y,
            width: width,
            height: height
          } = normalizeRectAttributes(attribute),
          path = new CustomPath2D();
        return path.moveTo(x, y), path.rect(x, y, width, height), path;
      }
      clone() {
        return new Rect(Object.assign({}, this.attribute));
      }
      getNoWorkAnimateAttr() {
        return Rect.NOWORK_ANIMATE_ATTR;
      }
    };
    Rect$2.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
    function createRect(attributes) {
      return new Rect$2(attributes);
    }

    class Frame {
      constructor(left, top, width, height, ellipsis, wordBreak, verticalDirection, globalAlign, globalBaseline, layoutDirection, isWidthMax, isHeightMax, singleLine, icons) {
        this.left = left, this.top = top, this.width = width, this.height = height, this.actualHeight = 0, this.bottom = top + height, this.right = left + width, this.ellipsis = ellipsis, this.wordBreak = wordBreak, this.verticalDirection = verticalDirection, this.lines = [], this.globalAlign = globalAlign, this.globalBaseline = globalBaseline, this.layoutDirection = layoutDirection, this.directionKey = DIRECTION_KEY[this.layoutDirection], this.isWidthMax = isWidthMax, this.isHeightMax = isHeightMax, this.singleLine = singleLine, icons ? (icons.clear(), this.icons = icons) : this.icons = new Map();
      }
      draw(ctx, drawIcon) {
        const {
            width: actualWidth,
            height: actualHeight
          } = this.getActualSize(),
          width = this.isWidthMax ? Math.min(this.width, actualWidth) : this.width || actualWidth || 0;
        let height = this.isHeightMax ? Math.min(this.height, actualHeight) : this.height || actualHeight || 0;
        height = Math.min(height, actualHeight);
        let deltaY = 0;
        switch (this.globalBaseline) {
          case "top":
            deltaY = 0;
            break;
          case "middle":
            deltaY = -height / 2;
            break;
          case "bottom":
            deltaY = -height;
        }
        let deltaX = 0;
        "right" === this.globalAlign || "end" === this.globalAlign ? deltaX = -width : "center" === this.globalAlign && (deltaX = -width / 2);
        let frameHeight = this[this.directionKey.height];
        this.singleLine && (frameHeight = this.lines[0].height + 1);
        let lastLineTag = !1;
        if ("middle" === this.verticalDirection) {
          if (this.actualHeight >= frameHeight && 0 !== frameHeight) for (let i = 0; i < this.lines.length; i++) {
            const {
              top: top,
              height: height
            } = this.lines[i];
            if (top + height < this[this.directionKey.top] || top + height > this[this.directionKey.top] + frameHeight) return lastLineTag;
            let lastLine = !1;
            this.ellipsis && this.lines[i + 1] && this.lines[i + 1].top + this.lines[i + 1].height > this[this.directionKey.top] + frameHeight && (lastLine = !0, lastLineTag = !0), this.lines[i].draw(ctx, lastLine, this.lines[i][this.directionKey.left] + deltaX, this.lines[i][this.directionKey.top] + deltaY, this.ellipsis, drawIcon);
          } else {
            const detalHeight = Math.floor((frameHeight - this.actualHeight) / 2);
            "vertical" === this.layoutDirection ? deltaX += detalHeight : deltaY += detalHeight;
            for (let i = 0; i < this.lines.length; i++) this.lines[i].draw(ctx, !1, this.lines[i][this.directionKey.left] + deltaX, this.lines[i][this.directionKey.top] + deltaY, this.ellipsis, drawIcon);
          }
        } else if ("bottom" === this.verticalDirection && "vertical" !== this.layoutDirection) for (let i = 0; i < this.lines.length; i++) {
          const {
              top: top,
              height: height
            } = this.lines[i],
            y = frameHeight - this.lines[i].top - this.lines[i].height;
          if (0 === frameHeight) this.lines[i].draw(ctx, !1, deltaX, y + deltaY, this.ellipsis, drawIcon);else {
            if (y + height > this[this.directionKey.top] + frameHeight || y < this[this.directionKey.top]) return lastLineTag;
            {
              let lastLine = !1;
              this.ellipsis && this.lines[i + 1] && y - this.lines[i + 1].height < this[this.directionKey.top] && (lastLine = !0, lastLineTag = !0), this.lines[i].draw(ctx, lastLine, deltaX, y + deltaY, this.ellipsis, drawIcon);
            }
          }
        } else {
          "bottom" === this.verticalDirection && "vertical" === this.layoutDirection && this.singleLine && this.isWidthMax && (deltaX += this.lines[0].height + 1);
          for (let i = 0; i < this.lines.length; i++) {
            "bottom" === this.verticalDirection && "vertical" === this.layoutDirection && (deltaX -= this.lines[i].height + this.lines[i].top);
            const {
              top: top,
              height: height
            } = this.lines[i];
            if (0 === frameHeight) this.lines[i].draw(ctx, !1, this.lines[i][this.directionKey.left] + deltaX, this.lines[i][this.directionKey.top] + deltaY, this.ellipsis, drawIcon);else {
              if (top + height < this[this.directionKey.top] || top + height > this[this.directionKey.top] + frameHeight) return lastLineTag;
              {
                let lastLine = !1;
                this.ellipsis && this.lines[i + 1] && this.lines[i + 1].top + this.lines[i + 1].height > this[this.directionKey.top] + frameHeight && (lastLine = !0, lastLineTag = !0), this.lines[i].draw(ctx, lastLine, this.lines[i][this.directionKey.left] + deltaX, this.lines[i][this.directionKey.top] + deltaY, this.ellipsis, drawIcon);
              }
            }
          }
        }
        return lastLineTag;
      }
      getActualSize() {
        return this.ellipsis ? this.getActualSizeWidthEllipsis() : this.getRawActualSize();
      }
      getRawActualSize() {
        let width = 0,
          height = 0;
        for (let i = 0; i < this.lines.length; i++) {
          const line = this.lines[i];
          line.actualWidth > width && (width = line.actualWidth), height += line.height;
        }
        return {
          width: "vertical" === this.layoutDirection ? height : width,
          height: "vertical" === this.layoutDirection ? width : height
        };
      }
      getActualSizeWidthEllipsis() {
        let widthBound = 0,
          heightBound = 0;
        const {
          width: actualWidth,
          height: actualHeight
        } = this.getRawActualSize();
        this.width;
        this.height || actualHeight || 0;
        let frameHeight = this[this.directionKey.height];
        if (this.singleLine && (frameHeight = this.lines[0].height + 1), "middle" === this.verticalDirection) {
          if (this.actualHeight >= frameHeight && 0 !== frameHeight) for (let i = 0; i < this.lines.length; i++) {
            const {
              top: top,
              height: height
            } = this.lines[i];
            if (top + height < this[this.directionKey.top] || top + height > this[this.directionKey.top] + frameHeight) ;else if (this.ellipsis && this.lines[i + 1] && this.lines[i + 1].top + this.lines[i + 1].height > this[this.directionKey.top] + frameHeight) {
              const ellipsis = !0 === this.ellipsis ? "..." : this.ellipsis || "",
                lineWidth = this.lines[i].getWidthWithEllips(ellipsis);
              lineWidth > widthBound && (widthBound = lineWidth), heightBound += this.lines[i].height;
            } else this.lines[i].actualWidth > widthBound && (widthBound = this.lines[i].actualWidth), heightBound += this.lines[i].height;
          } else {
            Math.floor((frameHeight - this.actualHeight) / 2);
            for (let i = 0; i < this.lines.length; i++) this.lines[i].actualWidth > widthBound && (widthBound = this.lines[i].actualWidth), heightBound += this.lines[i].height;
          }
        } else if ("bottom" === this.verticalDirection) for (let i = 0; i < this.lines.length; i++) {
          const {
              top: top,
              height: height
            } = this.lines[i],
            y = frameHeight - this.lines[i].top - this.lines[i].height;
          if (0 === frameHeight) this.lines[i].actualWidth > widthBound && (widthBound = this.lines[i].actualWidth), heightBound += this.lines[i].height;else if (y + height > this[this.directionKey.top] + frameHeight || y < this[this.directionKey.top]) ;else {
            if (this.ellipsis && this.lines[i + 1] && y - this.lines[i + 1].height < this[this.directionKey.top]) {
              const ellipsis = !0 === this.ellipsis ? "..." : this.ellipsis || "",
                lineWidth = this.lines[i].getWidthWithEllips(ellipsis);
              lineWidth > widthBound && (widthBound = lineWidth), heightBound += this.lines[i].height;
            } else this.lines[i].actualWidth > widthBound && (widthBound = this.lines[i].actualWidth), heightBound += this.lines[i].height;
          }
        } else for (let i = 0; i < this.lines.length; i++) {
          const {
            top: top,
            height: height
          } = this.lines[i];
          if (0 === frameHeight) this.lines[i].actualWidth > widthBound && (widthBound = this.lines[i].actualWidth), heightBound += this.lines[i].height;else if (top + height < this[this.directionKey.top] || top + height > this[this.directionKey.top] + frameHeight) ;else {
            if (this.ellipsis && this.lines[i + 1] && this.lines[i + 1].top + this.lines[i + 1].height > this[this.directionKey.top] + frameHeight) {
              const ellipsis = !0 === this.ellipsis ? "..." : this.ellipsis || "",
                lineWidth = this.lines[i].getWidthWithEllips(ellipsis);
              lineWidth > widthBound && (widthBound = lineWidth), heightBound += this.lines[i].height;
            } else this.lines[i].actualWidth > widthBound && (widthBound = this.lines[i].actualWidth), heightBound += this.lines[i].height;
          }
        }
        return {
          width: "vertical" === this.layoutDirection ? heightBound : widthBound,
          height: "vertical" === this.layoutDirection ? widthBound : heightBound
        };
      }
    }

    function getFixedLRTB(left, right, top, bottom) {
      const leftInt = Math.round(left),
        topInt = Math.round(top),
        rightInt = Math.round(right),
        bottomInt = Math.round(bottom);
      return {
        left: left > leftInt ? leftInt : leftInt - .5,
        top: top > topInt ? topInt : topInt - .5,
        right: rightInt > right ? rightInt : rightInt + .5,
        bottom: bottomInt > bottom ? bottomInt : bottomInt + .5
      };
    }
    class Paragraph {
      constructor(text, newLine, character, ascentDescentMode) {
        var _a, _b;
        this.fontSize = character.fontSize || 16, this.textBaseline = character.textBaseline || "alphabetic", this.ascentDescentMode = ascentDescentMode;
        const lineHeight = calculateLineHeight(character.lineHeight, this.fontSize);
        this.lineHeight = "number" == typeof lineHeight ? lineHeight > this.fontSize ? lineHeight : this.fontSize : Math.floor(1.2 * this.fontSize), this.height = this.lineHeight;
        const {
          ascent: ascent,
          height: height,
          descent: descent,
          width: width
        } = measureTextCanvas(text, character, this.ascentDescentMode);
        let halfDetaHeight = 0,
          deltaAscent = 0,
          deltaDescent = 0;
        this.height > height && (halfDetaHeight = (this.height - height) / 2, deltaAscent = Math.ceil(halfDetaHeight), deltaDescent = Math.floor(halfDetaHeight)), "top" === this.textBaseline ? (this.ascent = halfDetaHeight, this.descent = height - halfDetaHeight) : "bottom" === this.textBaseline ? (this.ascent = height - halfDetaHeight, this.descent = halfDetaHeight) : "middle" === this.textBaseline ? (this.ascent = this.height / 2, this.descent = this.height / 2) : (this.ascent = ascent + deltaAscent, this.descent = descent + deltaDescent), this.length = text.length, this.width = width || 0, this.text = text || "", this.newLine = newLine || !1, this.character = character, this.left = 0, this.top = 0, this.ellipsis = "normal", this.ellipsisWidth = 0, this.ellipsisOtherParagraphWidth = 0, this.space = character.space, this.dx = null !== (_a = character.dx) && void 0 !== _a ? _a : 0, this.dy = null !== (_b = character.dy) && void 0 !== _b ? _b : 0, "vertical" === character.direction && (this.direction = character.direction, this.widthOrigin = this.width, this.heightOrigin = this.height, this.width = this.heightOrigin, this.height = this.widthOrigin, this.lineHeight = this.height), this.ellipsisStr = "...";
      }
      updateWidth() {
        const {
          width: width
        } = measureTextCanvas(this.text, this.character, this.ascentDescentMode);
        this.width = width, "vertical" === this.direction && (this.widthOrigin = this.width, this.width = this.heightOrigin, this.height = this.widthOrigin);
      }
      drawBackground(ctx, top, ascent, deltaLeft, isLineFirst, textAlign, lineHeight) {
        if ("" === this.text || "\n" === this.text || !this.character.background || this.character.backgroundOpacity && !(this.character.backgroundOpacity > 0)) return;
        let baseline = top + ascent,
          text = this.text,
          left = this.left + deltaLeft;
        baseline += this.top;
        let direction = this.direction;
        if (this.verticalEllipsis) text = this.ellipsisStr, direction = "vertical", baseline -= this.ellipsisWidth / 2;else {
          if ("hide" === this.ellipsis) return;
          if ("add" === this.ellipsis) text += this.ellipsisStr, "right" !== textAlign && "end" !== textAlign || (left -= this.ellipsisWidth);else if ("replace" === this.ellipsis) {
            const index = getStrByWithCanvas(text, ("vertical" === direction ? this.height : this.width) - this.ellipsisWidth + this.ellipsisOtherParagraphWidth, this.character, text.length - 1);
            if (text = text.slice(0, index), text += this.ellipsisStr, "right" === textAlign || "end" === textAlign) if ("vertical" === direction) ;else {
              const {
                width: width
              } = measureTextCanvas(this.text.slice(index), this.character, this.ascentDescentMode);
              left -= this.ellipsisWidth - width;
            }
          }
        }
        const lrtb = getFixedLRTB(left, left + (this.widthOrigin || this.width), top, top + lineHeight);
        return Object.assign(Object.assign({}, lrtb), {
          fillStyle: this.character.background,
          globalAlpha: this.character.backgroundOpacity
        });
      }
      draw(ctx, top, ascent, deltaLeft, isLineFirst, textAlign, lineHeight) {
        var _a;
        let baseline = top + ascent,
          text = this.text,
          left = this.left + deltaLeft + (null !== (_a = this.space) && void 0 !== _a ? _a : 0) / 2;
        baseline += this.top;
        let direction = this.direction;
        if (this.verticalEllipsis) text = this.ellipsisStr, direction = "vertical", baseline -= this.ellipsisWidth / 2;else {
          if ("hide" === this.ellipsis) return;
          if ("add" === this.ellipsis) text += this.ellipsisStr, "right" !== textAlign && "end" !== textAlign || (left -= this.ellipsisWidth);else if ("replace" === this.ellipsis) {
            const index = getStrByWithCanvas(text, ("vertical" === direction ? this.height : this.width) - this.ellipsisWidth + this.ellipsisOtherParagraphWidth, this.character, text.length - 1);
            if (text = text.slice(0, index), text += this.ellipsisStr, "right" === textAlign || "end" === textAlign) if ("vertical" === direction) ;else {
              const {
                width: width
              } = measureTextCanvas(this.text.slice(index), this.character, this.ascentDescentMode);
              left -= this.ellipsisWidth - width;
            }
          }
        }
        switch (this.character.script) {
          case "super":
            baseline -= this.ascent * (1 / 3);
            break;
          case "sub":
            baseline += this.descent / 2;
        }
        "vertical" === direction && (ctx.save(), ctx.rotateAbout(Math.PI / 2, left, baseline), ctx.translate(-this.heightOrigin || -this.lineHeight / 2, -this.descent / 2), ctx.translate(left, baseline), left = 0, baseline = 0);
        const {
          lineWidth = 1
        } = this.character;
        if (this.character.stroke && lineWidth && ctx.strokeText(text, left, baseline + this.dy), this.character.fill && ctx.fillText(text, left, baseline + this.dy), this.character.fill) if (this.character.lineThrough || this.character.underline) {
          if (this.character.underline) {
            const top = 1 + baseline,
              lrtb = getFixedLRTB(left, left + (this.widthOrigin || this.width), top, top + (this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1));
            ctx.fillRect(lrtb.left, 1 + baseline, lrtb.right - lrtb.left, this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1);
          }
          if (this.character.lineThrough) {
            const top = 1 + baseline - this.ascent / 2,
              lrtb = getFixedLRTB(left, left + (this.widthOrigin || this.width), top, top + (this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1));
            ctx.fillRect(lrtb.left, 1 + baseline - this.ascent / 2, lrtb.right - lrtb.left, this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1);
          }
        } else if ("underline" === this.character.textDecoration) {
          const top = 1 + baseline,
            lrtb = getFixedLRTB(left, left + (this.widthOrigin || this.width), top, top + (this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1));
          ctx.fillRect(lrtb.left, 1 + baseline, lrtb.right - lrtb.left, this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1);
        } else if ("line-through" === this.character.textDecoration) {
          const top = 1 + baseline - this.ascent / 2,
            lrtb = getFixedLRTB(left, left + (this.widthOrigin || this.width), top, top + (this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1));
          ctx.fillRect(lrtb.left, 1 + baseline - this.ascent / 2, lrtb.right - lrtb.left, this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1);
        }
        "vertical" === direction && ctx.restore();
      }
      getWidthWithEllips(direction) {
        let text = this.text;
        const width = "vertical" === direction ? this.height : this.width;
        if ("hide" === this.ellipsis) return width;
        if ("add" === this.ellipsis) return width + this.ellipsisWidth;
        if ("replace" === this.ellipsis) {
          const index = getStrByWithCanvas(text, width - this.ellipsisWidth + this.ellipsisOtherParagraphWidth, this.character, text.length - 1);
          text = text.slice(0, index), text += this.ellipsisStr;
          const {
            width: measureWidth
          } = measureTextCanvas(this.text.slice(index), this.character, this.ascentDescentMode);
          return width + this.ellipsisWidth - measureWidth;
        }
        return width;
      }
    }
    function seperateParagraph(paragraph, index) {
      const text1 = paragraph.text.slice(0, index),
        text2 = paragraph.text.slice(index);
      return [new Paragraph(text1, paragraph.newLine, paragraph.character, paragraph.ascentDescentMode), new Paragraph(text2, !0, paragraph.character, paragraph.ascentDescentMode)];
    }

    const IMAGE_UPDATE_TAG_KEY = ["width", "height", "image", ...GRAPHIC_UPDATE_TAG_KEY];
    let Image$2 = class Image extends Graphic {
      constructor(params) {
        super(params), this.type = "image", this.numberType = IMAGE_NUMBER_TYPE, this.loadImage(this.attribute.image);
      }
      getImageElement() {
        const {
          image: image
        } = this.attribute;
        if (!image || !this.resources) return null;
        const res = this.resources.get(image);
        return "success" !== res.state ? null : res.data;
      }
      get width() {
        return this.tryUpdateAABBBounds(), this._actualWidth;
      }
      get height() {
        return this.tryUpdateAABBBounds(), this._actualHeight;
      }
      get repeatX() {
        var _a;
        return null !== (_a = this.attribute.repeatX) && void 0 !== _a ? _a : "no-repeat";
      }
      set repeatX(repeatX) {
        this.attribute.repeatX === repeatX && (this.attribute.repeatX = repeatX);
      }
      get repeatY() {
        var _a;
        return null !== (_a = this.attribute.repeatY) && void 0 !== _a ? _a : "no-repeat";
      }
      set repeatY(repeatY) {
        this.attribute.repeatY === repeatY && (this.attribute.repeatY = repeatY);
      }
      get image() {
        return this.attribute.image;
      }
      set image(image) {
        image !== this.attribute.image && (this.attribute.image = image, this.loadImage(this.attribute.image));
      }
      imageLoadSuccess(url, image, cb) {
        super.imageLoadSuccess(url, image, () => {
          this.successCallback && this.successCallback();
        }), this.addUpdateBoundTag();
      }
      imageLoadFail(url, cb) {
        super.imageLoadFail(url, () => {
          this.failCallback && this.failCallback();
        });
      }
      setAttributes(params, forceUpdateTag, context) {
        return params.image && this.loadImage(params.image), super.setAttributes(params, forceUpdateTag, context);
      }
      setAttribute(key, value, forceUpdateTag, context) {
        return "image" === key && this.loadImage(value), super.setAttribute(key, value, forceUpdateTag, context);
      }
      getGraphicTheme() {
        return getTheme(this).image;
      }
      updateAABBBounds(attribute, imageTheme, aabbBounds) {
        if (!this.updatePathProxyAABBBounds(aabbBounds)) {
          const {
            maxWidth = imageTheme.maxWidth,
            maxHeight = imageTheme.maxHeight
          } = attribute;
          let {
            width: width,
            height: height
          } = attribute;
          if (null == width || null == height) {
            const imageElement = this.getImageElement();
            if (imageElement) {
              const imageWidth = imageElement.width,
                imageHeight = imageElement.height;
              if (null != width) height = width * (imageHeight / imageWidth);else if (null != height) width = height * (imageWidth / imageHeight);else {
                const imageRatio = imageWidth / imageHeight;
                imageRatio > maxWidth / maxHeight ? (width = maxWidth, height = maxWidth / imageRatio) : (height = maxHeight, width = maxHeight * imageRatio);
              }
            } else width = maxWidth, height = maxHeight;
          }
          this._actualWidth = width, this._actualHeight = height, aabbBounds.set(0, 0, width, height);
        }
        const {
          tb1: tb1,
          tb2: tb2
        } = application.graphicService.updateTempAABBBounds(aabbBounds);
        return updateBoundsOfCommonOuterBorder(attribute, imageTheme, tb1), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2), this.widthWithoutTransform = aabbBounds.x2 - aabbBounds.x1, this.heightWithoutTransform = aabbBounds.y2 - aabbBounds.y1, application.graphicService.transformAABBBounds(attribute, aabbBounds, imageTheme, !1, this), aabbBounds;
      }
      getDefaultAttribute(name) {
        return DefaultImageAttribute[name];
      }
      needUpdateTags(keys) {
        return super.needUpdateTags(keys, IMAGE_UPDATE_TAG_KEY);
      }
      needUpdateTag(key) {
        return super.needUpdateTag(key, IMAGE_UPDATE_TAG_KEY);
      }
      clone() {
        return new Image(Object.assign({}, this.attribute));
      }
      getNoWorkAnimateAttr() {
        return Image.NOWORK_ANIMATE_ATTR;
      }
    };
    Image$2.NOWORK_ANIMATE_ATTR = Object.assign({
      image: 1,
      repeatX: 1,
      repeatY: 1
    }, NOWORK_ANIMATE_ATTR);
    function createImage(attributes) {
      return new Image$2(attributes);
    }

    class RichTextIcon extends Image$2 {
      constructor(params) {
        if (super(params), this._x = 0, this._y = 0, this._hovered = !1, this._marginArray = [0, 0, 0, 0], "always" === params.backgroundShowMode && (this._hovered = !0), params.margin) {
          const marginArray = parsePadding(params.margin);
          this._marginArray = "number" == typeof marginArray ? [marginArray, marginArray, marginArray, marginArray] : marginArray;
        }
        this.onBeforeAttributeUpdate = (val, attributes, key) => {
          if (isArray$9(key) && -1 !== key.indexOf("margin") || "margin" === key) if (attributes.margin) {
            const marginArray = parsePadding(attributes.margin);
            this._marginArray = "number" == typeof marginArray ? [marginArray, marginArray, marginArray, marginArray] : marginArray;
          } else this._marginArray = [0, 0, 0, 0];
        };
      }
      get width() {
        var _a;
        return (null !== (_a = this.attribute.width) && void 0 !== _a ? _a : 0) + this._marginArray[1] + this._marginArray[3];
      }
      get height() {
        var _a;
        return (null !== (_a = this.attribute.height) && void 0 !== _a ? _a : 0) + this._marginArray[0] + this._marginArray[2];
      }
      tryUpdateAABBBounds() {
        if (!this.shouldUpdateAABBBounds()) return this._AABBBounds;
        this.doUpdateAABBBounds();
        const {
            width = DefaultImageAttribute.width,
            height = DefaultImageAttribute.height
          } = this.attribute,
          {
            backgroundWidth = width,
            backgroundHeight = height
          } = this.attribute,
          expandX = (backgroundWidth - width) / 2,
          expandY = (backgroundHeight - height) / 2;
        return this._AABBBounds.expand([0, 2 * expandX, 2 * expandY, 0]), this._AABBBounds;
      }
      setHoverState(hovered) {
        "hover" === this.attribute.backgroundShowMode && this._hovered !== hovered && (this._hovered = hovered);
      }
    }

    class Line {
      constructor(left, width, baseline, ascent, descent, lineBuffer, direction, isWidthMax) {
        this.left = left, this.width = width, this.baseline = baseline, this.ascent = ascent, this.descent = descent, this.top = baseline - ascent, this.paragraphs = lineBuffer.map(p => p), this.textAlign = (this.paragraphs[0] instanceof RichTextIcon ? this.paragraphs[0].attribute.textAlign : this.paragraphs[0].character.textAlign) || "left", this.direction = direction, this.directionKey = DIRECTION_KEY[this.direction], this.actualWidth = 0;
        let maxHeight = 0;
        this.paragraphs.forEach((word, index) => {
          if (0 === index && word instanceof Paragraph) {
            const result = regFirstSpace.exec(word.text);
            0 !== (null == result ? void 0 : result.index) && (word.text = word.text.slice(null == result ? void 0 : result.index), word.updateWidth());
          }
          this.actualWidth += word[this.directionKey.width], maxHeight = Math.max(word[this.directionKey.height], maxHeight);
        }), this.height = maxHeight, this.blankWidth = isWidthMax ? 0 : this.width - this.actualWidth, this.calcOffset(width, isWidthMax);
      }
      calcOffset(width, isWidthMax) {
        const directionKey = this.directionKey,
          maxHeight = this.height;
        let x = this.left,
          spacing = 0;
        this.actualWidth < width && !isWidthMax && ("right" === this.textAlign || "end" === this.textAlign ? x = width - this.actualWidth : "center" === this.textAlign ? x = (width - this.actualWidth) / 2 : "justify" === this.textAlign && (this.paragraphs.length < 2 ? x = (width - this.actualWidth) / 2 : spacing = (width - this.actualWidth) / (this.paragraphs.length - 1))), this.paragraphs.map(function (paragraph) {
          paragraph instanceof RichTextIcon ? (paragraph["_" + directionKey.x] = x, x += paragraph[directionKey.width] + spacing, paragraph["_" + directionKey.y] = "top" === paragraph.attribute.textBaseline ? 0 : "bottom" === paragraph.attribute.textBaseline ? maxHeight - paragraph.height : (maxHeight - paragraph.height) / 2) : (paragraph[directionKey.left] = x, x += paragraph[directionKey.width] + spacing);
        });
      }
      draw(ctx, lastLine, x, y, drawEllipsis, drawIcon) {
        if (drawEllipsis && (lastLine || this.paragraphs.some(p => p.overflow))) {
          let emptyOverflow = !0,
            skipEllipsis = !1;
          for (let i = this.paragraphs.length - 1; i >= 0; i--) {
            const paragraph = this.paragraphs[i];
            if (paragraph.overflow) emptyOverflow = emptyOverflow && "" === paragraph.text;else if (emptyOverflow) {
              skipEllipsis = !0;
              break;
            }
          }
          let otherParagraphWidth = 0;
          if (!skipEllipsis) for (let i = this.paragraphs.length - 1; i >= 0; i--) {
            const paragraph = this.paragraphs[i];
            if (paragraph.overflow) {
              if ("" === paragraph.text) break;
              continue;
            }
            if (paragraph instanceof RichTextIcon) break;
            if ("vertical" === this.direction && "vertical" !== paragraph.direction) {
              paragraph.verticalEllipsis = !0;
              break;
            }
            const ellipsis = !0 === drawEllipsis ? "..." : drawEllipsis || "";
            paragraph.ellipsisStr = ellipsis;
            const {
                width: width
              } = measureTextCanvas(ellipsis, paragraph.character, paragraph.ascentDescentMode),
              ellipsisWidth = width || 0;
            if (ellipsisWidth <= this.blankWidth + otherParagraphWidth) {
              lastLine && (paragraph.ellipsis = "add");
              break;
            }
            if (ellipsisWidth <= this.blankWidth + otherParagraphWidth + paragraph.width) {
              paragraph.ellipsis = "replace", paragraph.ellipsisWidth = ellipsisWidth, paragraph.ellipsisOtherParagraphWidth = this.blankWidth + otherParagraphWidth;
              break;
            }
            paragraph.ellipsis = "hide", otherParagraphWidth += paragraph.width;
          }
        }
        let fillStyle = "",
          globalAlpha = -1,
          currBgList = [];
        const bgList = [currBgList];
        this.paragraphs.forEach((paragraph, index) => {
          if (paragraph instanceof RichTextIcon) return;
          const data = paragraph.drawBackground(ctx, y, this.ascent, x, 0 === index, this.textAlign, this.height);
          data && (fillStyle === data.fillStyle && globalAlpha === data.globalAlpha || (currBgList = [], bgList.push(currBgList), fillStyle = data.fillStyle, globalAlpha = data.globalAlpha), currBgList.push(data));
        }), bgList.forEach(bg => {
          if (0 === bg.length) return;
          const data = bg[0],
            end = bg[bg.length - 1];
          ctx.fillStyle = data.fillStyle, ctx.globalAlpha = data.globalAlpha, ctx.fillRect(data.left, data.top, end.right - data.left, end.bottom - data.top);
        }), this.paragraphs.forEach((paragraph, index) => {
          if (paragraph instanceof RichTextIcon) return paragraph.setAttributes({
            x: x + paragraph._x,
            y: y + paragraph._y
          }), void drawIcon(paragraph, ctx, x + paragraph._x, y + paragraph._y, this.ascent);
          const b = {
            x1: this.left,
            y1: this.top,
            x2: this.left + this.actualWidth,
            y2: this.top + this.height
          };
          applyStrokeStyle(ctx, paragraph.character), applyFillStyle(ctx, paragraph.character, b), paragraph.draw(ctx, y, this.ascent, x, 0 === index, this.textAlign, this.height);
        });
      }
      getWidthWithEllips(ellipsis) {
        let otherParagraphWidth = 0;
        for (let i = this.paragraphs.length - 1; i >= 0; i--) {
          const paragraph = this.paragraphs[i];
          if (paragraph instanceof RichTextIcon) break;
          const {
              width: width
            } = measureTextCanvas(ellipsis, paragraph.character, paragraph.ascentDescentMode),
            ellipsisWidth = width || 0;
          if (ellipsisWidth <= this.blankWidth + otherParagraphWidth) {
            paragraph.ellipsis = "add", paragraph.ellipsisWidth = ellipsisWidth;
            break;
          }
          if (ellipsisWidth <= this.blankWidth + otherParagraphWidth + paragraph.width) {
            paragraph.ellipsis = "replace", paragraph.ellipsisWidth = ellipsisWidth, paragraph.ellipsisOtherParagraphWidth = this.blankWidth + otherParagraphWidth;
            break;
          }
          paragraph.ellipsis = "hide", otherParagraphWidth += paragraph.width;
        }
        let width = 0;
        return this.paragraphs.forEach((paragraph, index) => {
          width += paragraph instanceof RichTextIcon ? paragraph.width : paragraph.getWidthWithEllips(this.direction);
        }), width;
      }
    }

    class Wrapper {
      constructor(frame) {
        this.frame = frame, this.width = this.frame.width, this.height = this.frame.height, this.lineWidth = 0, this.y = this.frame.top, this.maxAscent = 0, this.maxDescent = 0, this.maxAscentForBlank = 0, this.maxDescentForBlank = 0, this.lineBuffer = [], this.direction = frame.layoutDirection, this.directionKey = DIRECTION_KEY[this.direction];
      }
      store(paragraph) {
        if (paragraph instanceof RichTextIcon) {
          this.frame.icons.set(paragraph.richtextId, paragraph), this.lineBuffer.push(paragraph), this.lineWidth += paragraph[this.directionKey.width];
          let iconAscent = 0,
            iconDescent = 0;
          "top" === paragraph.attribute.textBaseline ? (iconAscent = 0, iconDescent = paragraph.height) : "bottom" === paragraph.attribute.textBaseline ? (iconAscent = paragraph.height, iconDescent = 0) : (iconAscent = paragraph.height / 2, iconDescent = paragraph.height / 2), this.maxAscent = Math.max(this.maxAscent, iconAscent), this.maxDescent = Math.max(this.maxDescent, iconDescent);
        } else this.lineBuffer.push(paragraph), 0 !== paragraph.text.length ? (this.lineWidth += paragraph[this.directionKey.width], this.maxAscent = Math.max(this.maxAscent, paragraph.ascent), this.maxDescent = Math.max(this.maxDescent, paragraph.descent)) : (this.maxAscentForBlank = Math.max(this.maxAscentForBlank, paragraph.ascent), this.maxDescentForBlank = Math.max(this.maxDescentForBlank, paragraph.descent));
      }
      send() {
        if (0 === this.lineBuffer.length) return;
        const maxAscent = 0 === this.maxAscent ? this.maxAscentForBlank : this.maxAscent,
          maxDescent = 0 === this.maxDescent ? this.maxDescentForBlank : this.maxDescent,
          line = new Line(this.frame.left, this[this.directionKey.width], this.y + maxAscent, maxAscent, maxDescent, this.lineBuffer, this.direction, "horizontal" === this.direction ? this.frame.isWidthMax : this.frame.isHeightMax);
        this.frame.lines.push(line), this.frame.actualHeight += line.height, this.y += line.height, this.lineBuffer.length = 0, this.lineWidth = this.maxAscent = this.maxDescent = this.maxAscentForBlank = this.maxDescentForBlank = 0;
      }
      deal(paragraph) {
        let singleLine = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
        paragraph instanceof RichTextIcon ? "horizontal" === this.direction && 0 === this.width || "vertical" === this.direction && 0 === this.height || this.lineWidth + paragraph[this.directionKey.width] <= this[this.directionKey.width] ? this.store(paragraph) : 0 === this.lineBuffer.length ? (this.store(paragraph), this.send()) : (this.send(), this.deal(paragraph)) : "number" != typeof this.width || this.width < 0 || (paragraph.newLine && this.send(), (0 !== paragraph.text.length || this.newLine) && ("horizontal" === this.direction && 0 === this.width || "vertical" === this.direction && 0 === this.height || this.lineWidth + paragraph[this.directionKey.width] <= this[this.directionKey.width] ? this.store(paragraph) : this.lineWidth === this[this.directionKey.width] ? (this.send(), this.deal(paragraph)) : this.cut(paragraph, singleLine)));
      }
      cut(paragraph, singleLine) {
        const availableWidth = this[this.directionKey.width] - this.lineWidth || 0,
          guessIndex = Math.ceil(availableWidth / paragraph[this.directionKey.width] * paragraph.length) || 0,
          index = getStrByWithCanvas(paragraph.text, availableWidth, paragraph.character, guessIndex, "break-word" === this.frame.wordBreak);
        if (0 !== index) {
          const [p1, p2] = seperateParagraph(paragraph, index);
          this.store(p1), singleLine ? this.send() : this.deal(p2);
        } else 0 !== this.lineBuffer.length && (this.send(), this.deal(paragraph));
      }
    }

    let supportIntl = !1;
    try {
      supportIntl = Intl && "function" == typeof Intl.Segmenter;
    } catch (e) {
      supportIntl = !1;
    }
    const RICHTEXT_UPDATE_TAG_KEY = ["width", "height", "ellipsis", "wordBreak", "verticalDirection", "maxHeight", "maxWidth", "textAlign", "textBaseline", "textConfig", "layoutDirection", "fill", "stroke", "fontSize", "fontFamily", "fontStyle", "fontWeight", "lineWidth", "opacity", "fillOpacity", "strokeOpacity", ...GRAPHIC_UPDATE_TAG_KEY];
    class RichText extends Graphic {
      constructor(params) {
        super(params), this.type = "richtext", this._currentHoverIcon = null, this.numberType = RICHTEXT_NUMBER_TYPE, this.onBeforeAttributeUpdate = (val, attributes, key) => {
          for (const key in val) if ("hoverIconId" === key) {
            if (val[key] === attributes[key]) continue;
            const icon = this._frameCache.icons.get(val[key]);
            this.updateHoverIconState(icon);
          }
        };
      }
      get width() {
        var _a;
        return null !== (_a = this.attribute.width) && void 0 !== _a ? _a : DefaultRichTextAttribute.width;
      }
      set width(w) {
        this.attribute.width !== w && (this.attribute.width = w, this.addUpdateShapeAndBoundsTag());
      }
      get height() {
        var _a;
        return null !== (_a = this.attribute.height) && void 0 !== _a ? _a : DefaultRichTextAttribute.height;
      }
      set height(h) {
        this.attribute.height !== h && (this.attribute.height = h, this.addUpdateShapeAndBoundsTag());
      }
      get maxWidth() {
        return this.attribute.maxWidth;
      }
      set maxWidth(mw) {
        this.attribute.maxWidth !== mw && (this.attribute.maxWidth = mw, this.addUpdateShapeAndBoundsTag());
      }
      get maxHeight() {
        return this.attribute.maxHeight;
      }
      set maxHeight(mh) {
        this.attribute.maxHeight !== mh && (this.attribute.maxHeight = mh, this.addUpdateShapeAndBoundsTag());
      }
      get ellipsis() {
        var _a;
        return null !== (_a = this.attribute.ellipsis) && void 0 !== _a ? _a : DefaultRichTextAttribute.ellipsis;
      }
      set ellipsis(e) {
        this.attribute.ellipsis !== e && (this.attribute.ellipsis = e, this.addUpdateShapeAndBoundsTag());
      }
      get wordBreak() {
        var _a;
        return null !== (_a = this.attribute.wordBreak) && void 0 !== _a ? _a : DefaultRichTextAttribute.wordBreak;
      }
      set wordBreak(wb) {
        this.attribute.wordBreak !== wb && (this.attribute.wordBreak = wb, this.addUpdateShapeAndBoundsTag());
      }
      get verticalDirection() {
        var _a;
        return null !== (_a = this.attribute.verticalDirection) && void 0 !== _a ? _a : DefaultRichTextAttribute.verticalDirection;
      }
      set verticalDirection(vd) {
        this.attribute.verticalDirection !== vd && (this.attribute.verticalDirection = vd, this.addUpdateShapeAndBoundsTag());
      }
      get textAlign() {
        var _a;
        return null !== (_a = this.attribute.textAlign) && void 0 !== _a ? _a : DefaultRichTextAttribute.textAlign;
      }
      set textAlign(align) {
        this.attribute.textAlign !== align && (this.attribute.textAlign = align, this.addUpdateShapeAndBoundsTag());
      }
      get textBaseline() {
        var _a;
        return null !== (_a = this.attribute.textBaseline) && void 0 !== _a ? _a : DefaultRichTextAttribute.textBaseline;
      }
      set textBaseline(baseline) {
        this.attribute.textBaseline !== baseline && (this.attribute.textBaseline = baseline, this.addUpdateShapeAndBoundsTag());
      }
      get textConfig() {
        var _a;
        return null !== (_a = this.attribute.textConfig) && void 0 !== _a ? _a : DefaultRichTextAttribute.textConfig;
      }
      set textConfig(config) {
        this.attribute.textConfig = config, this.addUpdateShapeAndBoundsTag();
      }
      getGraphicTheme() {
        return getTheme(this).richtext;
      }
      static AllSingleCharacter(cache) {
        if (cache.lines) {
          return cache.lines.every(line => line.paragraphs.every(item => !(item.text && isString$6(item.text) && RichText.splitText(item.text).length > 1)));
        }
        return cache.every(item => item.isComposing || !(item.text && isString$6(item.text) && RichText.splitText(item.text).length > 1));
      }
      static splitText(text) {
        if (supportIntl) {
          const segmenter = new Intl.Segmenter(void 0, {
              granularity: "grapheme"
            }),
            segments = [];
          for (const {
            segment: segment
          } of segmenter.segment(text)) segments.push(segment);
          return segments;
        }
        return Array.from(text);
      }
      static TransformTextConfig2SingleCharacter(textConfig) {
        const tc = [];
        return textConfig.forEach(item => {
          const textList = RichText.splitText(item.text.toString());
          if (isString$6(item.text) && textList.length > 1) for (let i = 0; i < textList.length; i++) {
            const t = textList[i];
            tc.push(Object.assign(Object.assign({}, item), {
              text: t
            }));
          } else tc.push(item);
        }), tc;
      }
      updateAABBBounds(attribute, richtextTheme, aabbBounds) {
        var _a, _b, _c, _d;
        const {
          width = richtextTheme.width,
          height = richtextTheme.height,
          maxWidth = richtextTheme.maxWidth,
          maxHeight = richtextTheme.maxHeight,
          textAlign = richtextTheme.textAlign,
          textBaseline = null !== (_b = null !== (_a = attribute.textBaseline) && void 0 !== _a ? _a : richtextTheme.textBaseline) && void 0 !== _b ? _b : "top",
          editOptions: editOptions
        } = attribute;
        if (width > 0 && height > 0) aabbBounds.set(0, 0, width, height);else {
          const frameCache = this.getFrameCache(),
            {
              width: actualWidth,
              height: actualHeight
            } = frameCache.getActualSize();
          let contentWidth = width || actualWidth || 0,
            contentHeight = height || actualHeight || 0;
          contentHeight = "number" == typeof maxHeight && contentHeight > maxHeight ? maxHeight : contentHeight || 0, contentWidth = "number" == typeof maxWidth && contentWidth > maxWidth ? maxWidth : contentWidth || 0, aabbBounds.set(0, 0, contentWidth, contentHeight);
        }
        editOptions && editOptions.keepHeightWhileEmpty && !aabbBounds.height() && !(null === (_c = attribute.textConfig) || void 0 === _c ? void 0 : _c.length) && (aabbBounds.y2 = aabbBounds.y1 + (null !== (_d = attribute.fontSize) && void 0 !== _d ? _d : 12), aabbBounds.x2 = aabbBounds.x1 + 2);
        let deltaY = 0;
        switch (textBaseline) {
          case "top":
            deltaY = 0;
            break;
          case "middle":
            deltaY = -aabbBounds.height() / 2;
            break;
          case "bottom":
            deltaY = -aabbBounds.height();
        }
        let deltaX = 0;
        switch (textAlign) {
          case "left":
            deltaX = 0;
            break;
          case "center":
            deltaX = -aabbBounds.width() / 2;
            break;
          case "right":
            deltaX = -aabbBounds.width();
        }
        return aabbBounds.translate(deltaX, deltaY), application.graphicService.updateTempAABBBounds(aabbBounds), null == attribute.forceBoundsHeight && null == attribute.forceBoundsWidth || application.graphicService.updateHTMLTextAABBBounds(attribute, richtextTheme, aabbBounds), this.widthWithoutTransform = aabbBounds.x2 - aabbBounds.x1, this.heightWithoutTransform = aabbBounds.y2 - aabbBounds.y1, application.graphicService.transformAABBBounds(attribute, aabbBounds, richtextTheme, !1, this), 0 === aabbBounds.width() && 0 === aabbBounds.height() && aabbBounds.clear(), aabbBounds;
      }
      needUpdateTags(keys) {
        return super.needUpdateTags(keys, RICHTEXT_UPDATE_TAG_KEY);
      }
      needUpdateTag(key) {
        return super.needUpdateTag(key, RICHTEXT_UPDATE_TAG_KEY);
      }
      getFrameCache() {
        return this.shouldUpdateShape() && (this.doUpdateFrameCache(), this.clearUpdateShapeTag()), this._frameCache;
      }
      get cliped() {
        const frameCache = this.getFrameCache();
        if (frameCache.actualHeight > frameCache.height) return !0;
        const {
          disableAutoWrapLine: disableAutoWrapLine
        } = this.attribute;
        if (disableAutoWrapLine) for (let i = 0; i < frameCache.lines.length; i++) {
          const l = frameCache.lines[i];
          for (let j = 0; j < l.paragraphs.length; j++) {
            const p = l.paragraphs[j];
            if (p.overflow && "" !== p.text) return !0;
          }
        }
        return !1;
      }
      combinedStyleToCharacter(config) {
        const {
            fill: fill,
            stroke: stroke,
            fontSize: fontSize,
            fontFamily: fontFamily,
            fontStyle: fontStyle,
            fontWeight: fontWeight,
            lineWidth: lineWidth,
            opacity: opacity,
            fillOpacity: fillOpacity,
            lineHeight: lineHeight,
            strokeOpacity: strokeOpacity,
            upgradeAttrs: upgradeAttrs
          } = this.attribute,
          out = Object.assign({
            fill: fill,
            stroke: stroke,
            fontSize: fontSize,
            fontFamily: fontFamily,
            fontStyle: fontStyle,
            fontWeight: fontWeight,
            lineWidth: lineWidth,
            opacity: opacity,
            fillOpacity: fillOpacity,
            strokeOpacity: strokeOpacity
          }, config);
        return (null == upgradeAttrs ? void 0 : upgradeAttrs.lineHeight) && (out.lineHeight = lineHeight), out;
      }
      doUpdateFrameCache(tc) {
        var _a;
        const {
            maxWidth: maxWidth,
            maxHeight: maxHeight,
            width: width,
            height: height,
            ellipsis: ellipsis,
            wordBreak: wordBreak,
            verticalDirection: verticalDirection,
            textAlign: textAlign,
            textBaseline: textBaseline,
            layoutDirection: layoutDirection,
            singleLine: singleLine,
            disableAutoWrapLine: disableAutoWrapLine,
            editable: editable,
            ascentDescentMode: ascentDescentMode,
            upgradeAttrs: upgradeAttrs
          } = this.attribute,
          enableMultiBreakLine = upgradeAttrs && upgradeAttrs.multiBreakLine;
        let {
          textConfig: _tc = []
        } = this.attribute;
        editable && _tc.length > 0 && !RichText.AllSingleCharacter(_tc) && (_tc = RichText.TransformTextConfig2SingleCharacter(_tc), this.attribute.textConfig = _tc);
        const paragraphs = [],
          textConfig = null != tc ? tc : _tc;
        for (let i = 0; i < textConfig.length; i++) if ("image" in textConfig[i]) {
          const config = this.combinedStyleToCharacter(textConfig[i]);
          config.lineWidth = void 0;
          const iconCache = config.id && this._frameCache && this._frameCache.icons && this._frameCache.icons.get(config.id);
          if (iconCache) paragraphs.push(iconCache);else {
            const icon = new RichTextIcon(config);
            icon.successCallback = () => {
              var _a;
              this.addUpdateBoundTag(), null === (_a = this.stage) || void 0 === _a || _a.renderNextFrame();
            }, icon.richtextId = config.id, paragraphs.push(icon);
          }
        } else {
          const richTextConfig = this.combinedStyleToCharacter(textConfig[i]);
          if (isNumber$6(richTextConfig.text) && (richTextConfig.text = `${richTextConfig.text}`), richTextConfig.text && richTextConfig.text.includes("\n")) {
            const textParts = richTextConfig.text.split("\n");
            for (let j = 0; j < textParts.length; j++) if (0 === j) paragraphs.push(new Paragraph(textParts[j], !1, richTextConfig, ascentDescentMode));else if (textParts[j] || i === textConfig.length - 1) paragraphs.push(new Paragraph(textParts[j], !0, richTextConfig, ascentDescentMode));else {
              const nextRichTextConfig = this.combinedStyleToCharacter(textConfig[i + 1]);
              paragraphs.push(new Paragraph(textParts[j], !0, nextRichTextConfig, ascentDescentMode));
            }
          } else richTextConfig.text && paragraphs.push(new Paragraph(richTextConfig.text, !1, richTextConfig, ascentDescentMode));
        }
        const maxWidthFinite = "number" == typeof maxWidth && Number.isFinite(maxWidth) && maxWidth > 0,
          maxHeightFinite = "number" == typeof maxHeight && Number.isFinite(maxHeight) && maxHeight > 0,
          richTextWidthEnable = "number" == typeof width && Number.isFinite(width) && width > 0 && (!maxWidthFinite || width <= maxWidth),
          richTextHeightEnable = "number" == typeof height && Number.isFinite(height) && height > 0 && (!maxHeightFinite || height <= maxHeight),
          frame = new Frame(0, 0, (richTextWidthEnable ? width : maxWidthFinite ? maxWidth : 0) || 0, (richTextHeightEnable ? height : maxHeightFinite ? maxHeight : 0) || 0, ellipsis, wordBreak, verticalDirection, textAlign, textBaseline, layoutDirection || "horizontal", !richTextWidthEnable && maxWidthFinite, !richTextHeightEnable && maxHeightFinite, singleLine || !1, null === (_a = this._frameCache) || void 0 === _a ? void 0 : _a.icons),
          wrapper = new Wrapper(frame);
        if (wrapper.newLine = enableMultiBreakLine, disableAutoWrapLine) {
          let lineCount = 0,
            skip = !1;
          for (let i = 0; i < paragraphs.length; i++) {
            const p = paragraphs[i];
            skip ? (p.overflow = !0, p.left = 1 / 0, p.top = 1 / 0, !p.newLine && frame.lines[frame.lines.length - 1].paragraphs.push(p)) : wrapper.deal(p, !0), frame.lines.length !== lineCount && (lineCount = frame.lines.length, wrapper.lineBuffer.length = 0, p.overflow = !0, p.left = 1e3, p.top = 1e3, frame.lines[frame.lines.length - 1].paragraphs.push(p), skip = !0), p.newLine && (skip = !1, wrapper.lineWidth = 0), wrapper.send();
          }
        } else for (let i = 0; i < paragraphs.length; i++) wrapper.deal(paragraphs[i]);
        wrapper.send();
        if (!("horizontal" === frame.layoutDirection ? richTextWidthEnable : richTextHeightEnable)) {
          const frameSize = frame.getActualSizeWidthEllipsis();
          let offsetSize = "horizontal" === frame.layoutDirection ? frameSize.width : frameSize.height;
          ("horizontal" === frame.layoutDirection ? maxWidthFinite : maxHeightFinite) && (offsetSize = Math.min(offsetSize, "horizontal" === frame.layoutDirection ? maxWidth : maxHeight)), frame.lines.forEach(function (l) {
            l.calcOffset(offsetSize, !1);
          });
        }
        enableMultiBreakLine && frame.lines.forEach(item => {
          const lastParagraphs = item.paragraphs;
          item.paragraphs = item.paragraphs.filter(p => "" !== p.text), 0 === item.paragraphs.length && lastParagraphs.length && (lastParagraphs[0].text = "\n", item.paragraphs.push(lastParagraphs[0]));
        }), this._frameCache = frame;
      }
      clone() {
        return new RichText(Object.assign({}, this.attribute));
      }
      setStage(stage, layer) {
        super.setStage(stage, layer);
        this.getFrameCache().icons.forEach(icon => {
          icon.setStage(stage, layer);
        });
      }
      bindIconEvent() {
        this.addEventListener("pointermove", e => {
          const pickedIcon = this.pickIcon(e.global);
          pickedIcon && pickedIcon === this._currentHoverIcon || (pickedIcon ? this.setAttribute("hoverIconId", pickedIcon.richtextId) : !pickedIcon && this._currentHoverIcon && this.setAttribute("hoverIconId", void 0));
        }), this.addEventListener("pointerleave", e => {
          this._currentHoverIcon && this.setAttribute("hoverIconId", void 0);
        });
      }
      updateHoverIconState(pickedIcon) {
        var _a, _b, _c, _d, _e;
        pickedIcon ? (null === (_a = this._currentHoverIcon) || void 0 === _a || _a.setHoverState(!1), this._currentHoverIcon = pickedIcon, this._currentHoverIcon.setHoverState(!0), null === (_b = this.stage) || void 0 === _b || _b.setCursor(pickedIcon.attribute.cursor), null === (_c = this.stage) || void 0 === _c || _c.renderNextFrame()) : (this._currentHoverIcon.setHoverState(!1), this._currentHoverIcon = null, null === (_d = this.stage) || void 0 === _d || _d.setCursor(), null === (_e = this.stage) || void 0 === _e || _e.renderNextFrame());
      }
      pickIcon(point) {
        const frameCache = this.getFrameCache(),
          {
            e: x,
            f: y
          } = this.globalTransMatrix;
        let pickIcon;
        return frameCache.icons.forEach((icon, key) => {
          var _a, _b;
          const bounds = icon.AABBBounds.clone();
          bounds.translate(icon._marginArray[3], icon._marginArray[0]), bounds.containsPoint({
            x: point.x - x,
            y: point.y - y
          }) && (pickIcon = icon, pickIcon.globalX = (null !== (_a = pickIcon.attribute.x) && void 0 !== _a ? _a : 0) + x + icon._marginArray[3], pickIcon.globalY = (null !== (_b = pickIcon.attribute.y) && void 0 !== _b ? _b : 0) + y + icon._marginArray[0]);
        }), pickIcon;
      }
      getNoWorkAnimateAttr() {
        return RichText.NOWORK_ANIMATE_ATTR;
      }
    }
    RichText.NOWORK_ANIMATE_ATTR = Object.assign({
      ellipsis: 1,
      wordBreak: 1,
      verticalDirection: 1,
      textAlign: 1,
      textBaseline: 1,
      textConfig: 1,
      layoutDirection: 1
    }, NOWORK_ANIMATE_ATTR);
    function createRichText(attributes) {
      return new RichText(attributes);
    }

    const PATH_UPDATE_TAG_KEY = ["path", "customPath", ...GRAPHIC_UPDATE_TAG_KEY];
    class Path extends Graphic {
      constructor(params) {
        super(params), this.type = "path", this.numberType = PATH_NUMBER_TYPE;
      }
      get pathShape() {
        return this.tryUpdateAABBBounds(), this.getParsedPathShape();
      }
      isValid() {
        return super.isValid() && this._isValid();
      }
      _isValid() {
        const {
          path: path
        } = this.attribute;
        return null != path && "" !== path;
      }
      getParsedPathShape() {
        const pathTheme = this.getGraphicTheme();
        if (!this.valid) return pathTheme.path;
        const attribute = this.attribute;
        return attribute.path instanceof CustomPath2D ? attribute.path : (isNil$5(this.cache) && this.doUpdatePathShape(), this.cache instanceof CustomPath2D ? this.cache : pathTheme.path);
      }
      getGraphicTheme() {
        return getTheme(this).path;
      }
      updateAABBBounds(attribute, pathTheme, aabbBounds) {
        if (!this.updatePathProxyAABBBounds(aabbBounds)) {
          const pathShape = this.getParsedPathShape();
          aabbBounds.union(pathShape.getBounds());
        }
        const {
          tb1: tb1,
          tb2: tb2
        } = application.graphicService.updateTempAABBBounds(aabbBounds);
        updateBoundsOfCommonOuterBorder(attribute, pathTheme, tb1), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2), this.widthWithoutTransform = aabbBounds.x2 - aabbBounds.x1, this.heightWithoutTransform = aabbBounds.y2 - aabbBounds.y1;
        const {
          lineJoin = pathTheme.lineJoin
        } = attribute;
        return application.graphicService.transformAABBBounds(attribute, aabbBounds, pathTheme, "miter" === lineJoin, this), aabbBounds;
      }
      doUpdateAABBBounds(full) {
        return this.doUpdatePathShape(), super.doUpdateAABBBounds(full);
      }
      doUpdatePathShape() {
        const attribute = this.attribute;
        isString$6(attribute.path, !0) ? this.cache = new CustomPath2D().fromString(attribute.path) : attribute.customPath && (this.cache = new CustomPath2D(), attribute.customPath(this.cache, this));
      }
      needUpdateTags(keys) {
        return super.needUpdateTags(keys, PATH_UPDATE_TAG_KEY);
      }
      needUpdateTag(key) {
        return super.needUpdateTag(key, PATH_UPDATE_TAG_KEY);
      }
      toCustomPath() {
        return new CustomPath2D().fromCustomPath2D(this.getParsedPathShape(), 0, 0);
      }
      clone() {
        return new Path(Object.assign({}, this.attribute));
      }
      getNoWorkAnimateAttr() {
        return Path.NOWORK_ANIMATE_ATTR;
      }
    }
    Path.NOWORK_ANIMATE_ATTR = Object.assign({
      path: 1,
      customPath: 1
    }, NOWORK_ANIMATE_ATTR);
    function createPath(attributes) {
      return new Path(attributes);
    }

    const ARC_UPDATE_TAG_KEY = ["innerRadius", "outerRadius", "startAngle", "endAngle", "cornerRadius", "padAngle", "padRadius", "cap", ...GRAPHIC_UPDATE_TAG_KEY];
    let Arc$1 = class Arc extends Graphic {
      constructor(params) {
        super(params), this.type = "arc", this.numberType = ARC_NUMBER_TYPE;
      }
      isValid() {
        return super.isValid() && this._isValid();
      }
      _isValid() {
        const {
          startAngle: startAngle,
          endAngle: endAngle,
          outerRadius: outerRadius,
          innerRadius: innerRadius
        } = this.attribute;
        return this._validNumber(startAngle) && this._validNumber(endAngle) && this._validNumber(outerRadius) && this._validNumber(innerRadius);
      }
      getParsedCornerRadius() {
        const arcTheme = this.getGraphicTheme(),
          {
            cornerRadius = arcTheme.cornerRadius,
            innerPadding = arcTheme.innerPadding,
            outerPadding = arcTheme.outerPadding
          } = this.attribute;
        let {
          outerRadius = arcTheme.outerRadius,
          innerRadius = arcTheme.innerRadius
        } = this.attribute;
        if (outerRadius += outerPadding, innerRadius -= innerPadding, 0 === cornerRadius || "0%" === cornerRadius) return 0;
        const deltaRadius = Math.abs(outerRadius - innerRadius),
          parseCR = cornerRadius => Math.min(isNumber$6(cornerRadius, !0) ? cornerRadius : deltaRadius * parseFloat(cornerRadius) / 100, deltaRadius / 2);
        if (isArray$9(cornerRadius)) {
          const crList = cornerRadius.map(cr => parseCR(cr) || 0);
          return 0 === crList.length ? [crList[0], crList[0], crList[0], crList[0]] : 2 === crList.length ? [crList[0], crList[1], crList[0], crList[1]] : (3 === crList.length && crList.push(0), crList);
        }
        return parseCR(cornerRadius);
      }
      getParsedAngle() {
        const arcTheme = this.getGraphicTheme();
        let {
          startAngle = arcTheme.startAngle,
          endAngle = arcTheme.endAngle
        } = this.attribute;
        const {
            cap = arcTheme.cap
          } = this.attribute,
          sign = endAngle - startAngle >= 0 ? 1 : -1,
          deltaAngle = endAngle - startAngle;
        if (startAngle = clampAngleByRadian(startAngle), endAngle = startAngle + deltaAngle, cap && abs(deltaAngle) < pi2 - epsilon) {
          let startCap = 1,
            endCap = 1;
          cap.length && (startCap = Number(cap[0]), endCap = Number(cap[1]));
          let {
            outerRadius = arcTheme.outerRadius,
            innerRadius = arcTheme.innerRadius
          } = this.attribute;
          const {
            outerPadding = arcTheme.outerPadding,
            innerPadding = arcTheme.innerPadding
          } = this.attribute;
          outerRadius += outerPadding, innerRadius -= innerPadding;
          const capWidth = Math.abs(outerRadius - innerRadius) / 2,
            capAngle = capWidth / outerRadius;
          if (capWidth > epsilon && outerRadius > epsilon) return {
            startAngle: startAngle - sign * capAngle * startCap,
            endAngle: endAngle + sign * capAngle * endCap,
            sc: sign * capAngle * startCap,
            ec: sign * capAngle * endCap
          };
        }
        return {
          startAngle: startAngle,
          endAngle: endAngle
        };
      }
      getParsePadAngle(startAngle, endAngle) {
        const arcTheme = this.getGraphicTheme(),
          {
            innerPadding = arcTheme.innerPadding,
            outerPadding = arcTheme.outerPadding,
            padAngle = arcTheme.padAngle
          } = this.attribute;
        let {
          outerRadius = arcTheme.outerRadius,
          innerRadius = arcTheme.innerRadius
        } = this.attribute;
        outerRadius += outerPadding, innerRadius -= innerPadding;
        const {
            padRadius = sqrt(outerRadius * outerRadius + innerRadius * innerRadius)
          } = this.attribute,
          deltaAngle = abs(endAngle - startAngle);
        let outerStartAngle = startAngle,
          outerEndAngle = endAngle,
          innerStartAngle = startAngle,
          innerEndAngle = endAngle;
        const halfPadAngle = padAngle / 2;
        let innerDeltaAngle = deltaAngle,
          outerDeltaAngle = deltaAngle;
        if (halfPadAngle > epsilon && padRadius > epsilon) {
          const sign = endAngle > startAngle ? 1 : -1;
          let p0 = asin(Number(padRadius) / innerRadius * sin(halfPadAngle)),
            p1 = asin(Number(padRadius) / outerRadius * sin(halfPadAngle));
          return (innerDeltaAngle -= 2 * p0) > epsilon ? (p0 *= sign, innerStartAngle += p0, innerEndAngle -= p0) : (innerDeltaAngle = 0, innerStartAngle = innerEndAngle = (startAngle + endAngle) / 2), (outerDeltaAngle -= 2 * p1) > epsilon ? (p1 *= sign, outerStartAngle += p1, outerEndAngle -= p1) : (outerDeltaAngle = 0, outerStartAngle = outerEndAngle = (startAngle + endAngle) / 2), {
            outerStartAngle: outerStartAngle,
            outerEndAngle: outerEndAngle,
            innerStartAngle: innerStartAngle,
            innerEndAngle: innerEndAngle,
            innerDeltaAngle: innerDeltaAngle,
            outerDeltaAngle: outerDeltaAngle
          };
        }
        return {
          outerStartAngle: outerStartAngle,
          outerEndAngle: outerEndAngle,
          innerStartAngle: innerStartAngle,
          innerEndAngle: innerEndAngle,
          innerDeltaAngle: innerDeltaAngle,
          outerDeltaAngle: outerDeltaAngle
        };
      }
      getGraphicTheme() {
        return getTheme(this).arc;
      }
      updateAABBBounds(attribute, arcTheme, aabbBounds, full) {
        this.updatePathProxyAABBBounds(aabbBounds) || (full ? this.updateArcAABBBoundsImprecise(attribute, arcTheme, aabbBounds) : this.updateArcAABBBoundsAccurate(attribute, arcTheme, aabbBounds));
        const {
          tb1: tb1,
          tb2: tb2
        } = application.graphicService.updateTempAABBBounds(aabbBounds);
        updateBoundsOfCommonOuterBorder(attribute, arcTheme, tb1), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2), this.setWidthHeightWithoutTransform(aabbBounds);
        const {
          lineJoin = arcTheme.lineJoin
        } = attribute;
        return application.graphicService.transformAABBBounds(attribute, aabbBounds, arcTheme, "miter" === lineJoin, this), aabbBounds;
      }
      updateArcAABBBoundsImprecise(attribute, arcTheme, aabbBounds) {
        let {
          outerRadius = arcTheme.outerRadius,
          innerRadius = arcTheme.innerRadius
        } = attribute;
        const {
          outerPadding = arcTheme.outerPadding,
          innerPadding = arcTheme.innerPadding
        } = attribute;
        return outerRadius += outerPadding, innerRadius -= innerPadding, outerRadius < innerRadius && (outerRadius = innerRadius), aabbBounds.set(-outerRadius, -outerRadius, outerRadius, outerRadius), aabbBounds;
      }
      updateArcAABBBoundsAccurate(attribute, arcTheme, aabbBounds) {
        let {
          outerRadius = arcTheme.outerRadius,
          innerRadius = arcTheme.innerRadius
        } = attribute;
        const {
          outerPadding = arcTheme.outerPadding,
          innerPadding = arcTheme.innerPadding
        } = attribute;
        if (outerRadius += outerPadding, innerRadius -= innerPadding, outerRadius < innerRadius) {
          const temp = outerRadius;
          outerRadius = innerRadius, innerRadius = temp;
        }
        let {
          endAngle = arcTheme.endAngle,
          startAngle = arcTheme.startAngle
        } = attribute;
        if (startAngle > endAngle) {
          const temp = startAngle;
          startAngle = endAngle, endAngle = temp;
        }
        return outerRadius <= epsilon ? aabbBounds.set(0, 0, 0, 0) : Math.abs(endAngle - startAngle) > pi2 - epsilon ? aabbBounds.set(-outerRadius, -outerRadius, outerRadius, outerRadius) : (circleBounds(startAngle, endAngle, outerRadius, aabbBounds), circleBounds(startAngle, endAngle, innerRadius, aabbBounds)), aabbBounds;
      }
      needUpdateTags(keys) {
        return super.needUpdateTags(keys, ARC_UPDATE_TAG_KEY);
      }
      needUpdateTag(key) {
        return super.needUpdateTag(key, ARC_UPDATE_TAG_KEY);
      }
      toCustomPath() {
        var _a, _b, _c, _d;
        const attribute = this.attribute,
          {
            startAngle: startAngle,
            endAngle: endAngle
          } = this.getParsedAngle();
        let innerRadius = (null !== (_a = attribute.innerRadius) && void 0 !== _a ? _a : 0) - (null !== (_b = attribute.innerPadding) && void 0 !== _b ? _b : 0),
          outerRadius = (null !== (_c = attribute.outerRadius) && void 0 !== _c ? _c : 0) - (null !== (_d = attribute.outerPadding) && void 0 !== _d ? _d : 0);
        const deltaAngle = abs(endAngle - startAngle),
          clockwise = endAngle > startAngle;
        if (outerRadius < innerRadius) {
          const temp = outerRadius;
          outerRadius = innerRadius, innerRadius = temp;
        }
        const path = new CustomPath2D();
        if (outerRadius <= epsilon) path.moveTo(0, 0);else if (deltaAngle >= pi2 - epsilon) path.moveTo(0 + outerRadius * cos(startAngle), 0 + outerRadius * sin(startAngle)), path.arc(0, 0, outerRadius, startAngle, endAngle, !clockwise), innerRadius > epsilon && (path.moveTo(0 + innerRadius * cos(endAngle), 0 + innerRadius * sin(endAngle)), path.arc(0, 0, innerRadius, endAngle, startAngle, clockwise));else {
          const xors = outerRadius * cos(startAngle),
            yors = outerRadius * sin(startAngle),
            xire = innerRadius * cos(endAngle),
            yire = innerRadius * sin(endAngle);
          path.moveTo(0 + xors, 0 + yors), path.arc(0, 0, outerRadius, startAngle, endAngle, !clockwise), path.lineTo(0 + xire, 0 + yire), path.arc(0, 0, innerRadius, endAngle, startAngle, clockwise), path.closePath();
        }
        return path;
      }
      clone() {
        return new Arc(Object.assign({}, this.attribute));
      }
      getNoWorkAnimateAttr() {
        return Arc.NOWORK_ANIMATE_ATTR;
      }
    };
    Arc$1.NOWORK_ANIMATE_ATTR = Object.assign({
      cap: 1
    }, NOWORK_ANIMATE_ATTR);
    function createArc(attributes) {
      return new Arc$1(attributes);
    }

    const POLYGON_UPDATE_TAG_KEY = ["points", "cornerRadius", ...GRAPHIC_UPDATE_TAG_KEY];
    class Polygon extends Graphic {
      constructor(params) {
        super(params), this.type = "polygon", this.numberType = POLYGON_NUMBER_TYPE;
      }
      isValid() {
        return super.isValid() && this._isValid();
      }
      _isValid() {
        const {
          points: points
        } = this.attribute;
        return points && points.length >= 2;
      }
      getGraphicTheme() {
        return getTheme(this).polygon;
      }
      updateAABBBounds(attribute, polygonTheme, aabbBounds) {
        this.updatePathProxyAABBBounds(aabbBounds) || this.updatePolygonAABBBoundsImprecise(attribute, polygonTheme, aabbBounds), application.graphicService.updateTempAABBBounds(aabbBounds), this.widthWithoutTransform = aabbBounds.x2 - aabbBounds.x1, this.heightWithoutTransform = aabbBounds.y2 - aabbBounds.y1;
        const {
          lineJoin = polygonTheme.lineJoin
        } = attribute;
        return application.graphicService.transformAABBBounds(attribute, aabbBounds, polygonTheme, "miter" === lineJoin, this), aabbBounds;
      }
      updatePolygonAABBBoundsImprecise(attribute, polygonTheme, aabbBounds) {
        const {
          points = polygonTheme.points
        } = attribute;
        return points.forEach(p => {
          aabbBounds.add(p.x, p.y);
        }), aabbBounds;
      }
      _interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes) {
        "points" === key && (nextAttributes.points = pointsInterpolation(lastStepVal, nextStepVal, ratio));
      }
      needUpdateTags(keys) {
        return super.needUpdateTags(keys, POLYGON_UPDATE_TAG_KEY);
      }
      needUpdateTag(key) {
        return super.needUpdateTag(key, POLYGON_UPDATE_TAG_KEY);
      }
      toCustomPath() {
        const points = this.attribute.points,
          path = new CustomPath2D();
        return points.forEach((point, index) => {
          0 === index ? path.moveTo(point.x, point.y) : path.lineTo(point.x, point.y);
        }), path.closePath(), path;
      }
      clone() {
        return new Polygon(Object.assign({}, this.attribute));
      }
      getNoWorkAnimateAttr() {
        return Polygon.NOWORK_ANIMATE_ATTR;
      }
    }
    Polygon.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
    function createPolygon(attributes) {
      return new Polygon(attributes);
    }

    class ShadowRoot extends Group$2 {
      constructor(graphic) {
        super({
          x: 0,
          y: 0
        }), this.type = "shadowroot", this.shadowHost = graphic;
      }
      clearUpdateBoundTag() {
        super.clearUpdateBoundTag(), this.shadowHost && this.shadowHost.clearUpdateBoundTag();
      }
      addUpdateBoundTag() {
        super.addUpdateBoundTag(), this.shadowHost && this.shadowHost.addUpdateBoundTag();
      }
      addUpdateShapeAndBoundsTag() {
        super.addUpdateShapeAndBoundsTag(), this.shadowHost && this.shadowHost.addUpdateBoundTag();
      }
      tryUpdateGlobalTransMatrix() {
        let clearTag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !0;
        if (this.shouldUpdateGlobalMatrix()) {
          const m = this.transMatrix;
          this._globalTransMatrix ? this._globalTransMatrix.setValue(m.a, m.b, m.c, m.d, m.e, m.f) : this._globalTransMatrix = m.clone(), this.doUpdateGlobalMatrix(), clearTag && this.clearUpdateGlobalPositionTag();
        }
        return this._globalTransMatrix;
      }
      doUpdateGlobalMatrix() {
        if (this.shadowHost) {
          const parentMatrix = this.shadowHost.globalTransMatrix;
          this._globalTransMatrix.multiply(parentMatrix.a, parentMatrix.b, parentMatrix.c, parentMatrix.d, parentMatrix.e, parentMatrix.f);
        }
      }
      tryUpdateGlobalAABBBounds() {
        return this._globalAABBBounds ? this._globalAABBBounds.setValue(this._AABBBounds.x1, this._AABBBounds.y1, this._AABBBounds.x2, this._AABBBounds.y2) : this._globalAABBBounds = this._AABBBounds.clone(), this.shadowHost && this._globalAABBBounds.transformWithMatrix(this.shadowHost.globalTransMatrix), this._globalAABBBounds;
      }
    }
    function createShadowRoot(graphic) {
      return new ShadowRoot(graphic);
    }

    class GraphicCreator {
      constructor() {
        this.store = new Map();
      }
      RegisterGraphicCreator(name, cb) {
        this.store.set(name, cb), this[name] = cb;
      }
      CreateGraphic(name, params) {
        const cb = this.store.get(name);
        return cb ? cb(params) : null;
      }
    }
    const graphicCreator = new GraphicCreator();

    let text;
    function getTextBounds(params) {
      return text || (text = graphicCreator.CreateGraphic("text", {})), text.initAttributes(params), text.AABBBounds;
    }

    var __decorate$V = undefined && undefined.__decorate || function (decorators, target, key, desc) {
        var d,
          c = arguments.length,
          r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      },
      __metadata$I = undefined && undefined.__metadata || function (k, v) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
      },
      __param$y = undefined && undefined.__param || function (paramIndex, decorator) {
        return function (target, key) {
          decorator(target, key, paramIndex);
        };
      };
    class DefaultBaseBackgroundRenderContribution {
      constructor() {
        this.time = BaseRenderContributionTime.beforeFillStroke, this.useStyle = !0, this.order = 0;
      }
      drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options) {
        var _a;
        const {
          background: background,
          backgroundOpacity = null !== (_a = graphic.attribute.fillOpacity) && void 0 !== _a ? _a : graphicAttribute.backgroundOpacity,
          opacity = graphicAttribute.opacity,
          backgroundMode = graphicAttribute.backgroundMode,
          backgroundFit = graphicAttribute.backgroundFit,
          backgroundKeepAspectRatio = graphicAttribute.backgroundKeepAspectRatio,
          backgroundScale = graphicAttribute.backgroundScale,
          backgroundOffsetX = graphicAttribute.backgroundOffsetX,
          backgroundOffsetY = graphicAttribute.backgroundOffsetY,
          backgroundClip = graphicAttribute.backgroundClip
        } = graphic.attribute;
        if (background) if (graphic.backgroundImg && graphic.resources) {
          const res = graphic.resources.get(background);
          if ("success" !== res.state || !res.data) return;
          if (context.save(), graphic.parent && !graphic.transMatrix.onlyTranslate()) {
            const groupAttribute = getTheme(graphic.parent).group,
              {
                scrollX = groupAttribute.scrollX,
                scrollY = groupAttribute.scrollY
              } = graphic.parent.attribute;
            context.setTransformFromMatrix(graphic.parent.globalTransMatrix, !0), context.translate(scrollX, scrollY);
          }
          backgroundClip && context.clip();
          const b = graphic.AABBBounds;
          context.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute), context.globalAlpha = backgroundOpacity * opacity, this.doDrawImage(context, res.data, b, {
            backgroundMode: backgroundMode,
            backgroundFit: backgroundFit,
            backgroundKeepAspectRatio: backgroundKeepAspectRatio,
            backgroundScale: backgroundScale,
            backgroundOffsetX: backgroundOffsetX,
            backgroundOffsetY: backgroundOffsetY
          }), context.restore(), graphic.transMatrix.onlyTranslate() || context.setTransformForCurrent();
        } else context.highPerformanceSave(), context.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute), context.globalAlpha = backgroundOpacity * opacity, context.fillStyle = background, context.fill(), context.highPerformanceRestore();
      }
      doDrawImage(context, data, b, params) {
        const {
            backgroundMode: backgroundMode,
            backgroundFit: backgroundFit,
            backgroundKeepAspectRatio: backgroundKeepAspectRatio,
            backgroundScale = 1,
            backgroundOffsetX = 0,
            backgroundOffsetY = 0
          } = params,
          targetW = b.width(),
          targetH = b.height();
        let w = targetW,
          h = targetH;
        if ("no-repeat" === backgroundMode) {
          if (backgroundFit) {
            if (backgroundKeepAspectRatio) {
              const maxScale = Math.max(targetW / data.width, targetH / data.height);
              context.drawImage(data, b.x1 + backgroundOffsetX, b.y1 + backgroundOffsetY, data.width * maxScale * backgroundScale, data.height * maxScale * backgroundScale);
            } else context.drawImage(data, b.x1, b.y1, b.width(), b.height());
          } else {
            const resW = data.width * backgroundScale,
              resH = data.height * backgroundScale;
            context.drawImage(data, b.x1 + backgroundOffsetX, b.y1 + backgroundOffsetY, resW, resH);
          }
        } else {
          if (backgroundFit && "repeat" !== backgroundMode && (data.width || data.height)) {
            const resW = data.width,
              resH = data.height;
            if ("repeat-x" === backgroundMode) {
              w = resW * (targetH / resH), h = targetH;
            } else if ("repeat-y" === backgroundMode) {
              h = resH * (targetW / resW), w = targetW;
            }
            const dpr = context.dpr,
              canvas = canvasAllocate.allocate({
                width: w,
                height: h,
                dpr: dpr
              }),
              ctx = canvas.getContext("2d");
            ctx && (ctx.inuse = !0, ctx.clearMatrix(), ctx.setTransformForCurrent(!0), ctx.clearRect(0, 0, w, h), ctx.drawImage(data, 0, 0, w, h), data = canvas.nativeCanvas), canvasAllocate.free(canvas);
          }
          const dpr = context.dpr,
            pattern = context.createPattern(data, backgroundMode);
          pattern.setTransform && pattern.setTransform(new DOMMatrix([1 / dpr, 0, 0, 1 / dpr, 0, 0])), context.fillStyle = pattern, context.translate(b.x1, b.y1), context.fillRect(0, 0, targetW, targetH), context.translate(-b.x1, -b.y1);
        }
      }
    }
    const defaultBaseBackgroundRenderContribution = new DefaultBaseBackgroundRenderContribution();
    let DefaultBaseInteractiveRenderContribution = class {
      constructor(subRenderContribitions) {
        this.subRenderContribitions = subRenderContribitions, this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = !0, this.order = 0;
      }
      drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options) {
        this._subRenderContribitions || (this._subRenderContribitions = this.subRenderContribitions.getContributions()), this._subRenderContribitions.forEach(c => {
          c.render(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options);
        });
      }
    };
    DefaultBaseInteractiveRenderContribution = __decorate$V([injectable(), __param$y(0, inject(ContributionProvider)), __param$y(0, named(InteractiveSubRenderContribution)), __metadata$I("design:paramtypes", [Object])], DefaultBaseInteractiveRenderContribution);
    class DefaultBaseClipRenderBeforeContribution {
      constructor() {
        this.time = BaseRenderContributionTime.beforeFillStroke, this.useStyle = !0, this.order = 0;
      }
      drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options) {
        var _a, _b;
        const {
          clipConfig: clipConfig
        } = graphic.attribute;
        if (!clipConfig) return;
        const clipPath = graphic.getClipPath();
        if (!clipPath) return;
        const draw = !(fillCb || strokeCb),
          b = graphic.AABBBounds,
          width = null !== (_a = graphic.attribute.width) && void 0 !== _a ? _a : b.width(),
          height = null !== (_b = graphic.attribute.height) && void 0 !== _b ? _b : b.height();
        draw && context.save(), context.beginPath(), !1 === clipPath.draw(context, [width, height], x + width / 2, y + height / 2, 0) && context.closePath(), fillCb && fillCb(context, graphic.attribute, graphicAttribute, !0), draw && context.clip();
      }
    }
    const defaultBaseClipRenderBeforeContribution = new DefaultBaseClipRenderBeforeContribution();
    class DefaultBaseClipRenderAfterContribution {
      constructor() {
        this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = !0, this.order = 0;
      }
      drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options) {
        const {
          clipConfig: clipConfig
        } = graphic.attribute;
        if (!clipConfig) return;
        graphic.getClipPath() && (fillCb || strokeCb || context.restore());
      }
    }
    const defaultBaseClipRenderAfterContribution = new DefaultBaseClipRenderAfterContribution();

    function formatRatio(ratio) {
      return ratio <= .5 ? 4 * ratio - 1 : -4 * ratio + 3;
    }
    function drawWave(ctx, ratio, boundsWidth, boundsHeight, textureOptions, offsetX, offsetY) {
      const {
        fill = "orange",
        percent = .6,
        frequency = 4,
        opacity: opacity,
        phi = 0
      } = textureOptions;
      let {
        amplitude = 10
      } = textureOptions;
      amplitude *= formatRatio(ratio);
      const height = boundsHeight * (1 - percent),
        width = boundsWidth,
        step = Math.max(Math.round(width / 70), 2);
      ctx.beginPath(), ctx.moveTo(0 + offsetX, boundsHeight + offsetY), ctx.lineTo(0 + offsetX, height + offsetY);
      const delta = width / frequency * ratio,
        c = width / Math.PI / (2 * frequency);
      for (let i = 0; i < width; i += step) {
        const y = amplitude * Math.sin((i + delta + phi) / c + phi);
        ctx.lineTo(i + offsetX, height + y + offsetY);
      }
      ctx.lineTo(width + offsetX, boundsHeight + offsetY), ctx.closePath(), ctx.fillStyle = fill, isFinite(opacity) && (ctx.globalAlpha = opacity), ctx.fill();
    }
    class DefaultBaseTextureRenderContribution {
      constructor() {
        this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = !0, this.order = 10, this._tempSymbolGraphic = null;
      }
      createCommonPattern(size, padding, color, targetContext, cb) {
        const r = (size - 2 * padding) / 2,
          dpr = targetContext.dpr,
          canvas = canvasAllocate.allocate({
            width: size,
            height: size,
            dpr: dpr
          }),
          ctx = canvas.getContext("2d");
        if (!ctx) return null;
        ctx.inuse = !0, ctx.clearMatrix(), ctx.setTransformForCurrent(!0), ctx.clearRect(0, 0, size, size), cb(r, ctx);
        const pattern = targetContext.createPattern(canvas.nativeCanvas, "repeat");
        return pattern.setTransform && pattern.setTransform(new DOMMatrix([1 / dpr, 0, 0, 1 / dpr, 0, 0])), canvasAllocate.free(canvas), pattern;
      }
      createCirclePattern(size, padding, color, targetContext) {
        return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
          ctx.fillStyle = color, ctx.arc(r, r, r, 0, pi2), ctx.fill();
        });
      }
      createDiamondPattern(size, padding, color, targetContext) {
        return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
          const x = size / 2,
            y = x;
          ctx.fillStyle = color, ctx.moveTo(x, y - r), ctx.lineTo(r + x, y), ctx.lineTo(x, y + r), ctx.lineTo(x - r, y), ctx.closePath(), ctx.fill();
        });
      }
      createRectPattern(size, padding, color, targetContext) {
        return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
          const x = padding,
            y = x;
          ctx.fillStyle = color, ctx.fillRect(x, y, 2 * r, 2 * r);
        });
      }
      createVerticalLinePattern(size, padding, color, targetContext) {
        return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
          const x = padding;
          ctx.fillStyle = color, ctx.fillRect(x, 0, 2 * r, size);
        });
      }
      createHorizontalLinePattern(size, padding, color, targetContext) {
        return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
          const y = padding;
          ctx.fillStyle = color, ctx.fillRect(0, y, size, 2 * r);
        });
      }
      createBiasLRLinePattern(size, padding, color, targetContext) {
        return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
          ctx.strokeStyle = color, ctx.lineWidth = r, ctx.moveTo(0, 0), ctx.lineTo(size, size);
          const dx = size / 2,
            dy = -dx;
          ctx.moveTo(dx, dy), ctx.lineTo(dx + size, dy + size), ctx.moveTo(-dx, -dy), ctx.lineTo(-dx + size, -dy + size), ctx.stroke();
        });
      }
      createBiasRLLinePattern(size, padding, color, targetContext) {
        return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
          ctx.strokeStyle = color, ctx.lineWidth = r, ctx.moveTo(size, 0), ctx.lineTo(0, size);
          const dx = size / 2,
            dy = dx;
          ctx.moveTo(size + dx, dy), ctx.lineTo(dx, dy + size), ctx.moveTo(size - dx, -dy), ctx.lineTo(-dx, -dy + size), ctx.stroke();
        });
      }
      createGridPattern(size, padding, color, targetContext) {
        return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
          const x = padding,
            y = x;
          ctx.fillStyle = color, ctx.fillRect(x, y, r, r), ctx.fillRect(x + r, y + r, r, r);
        });
      }
      initTextureMap(ctx, stage) {
        this.textureMap = new Map();
      }
      drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options) {
        this.textureMap || this.initTextureMap(context, graphic.stage);
        const {
          texture = graphicAttribute.texture,
          textureColor = graphicAttribute.textureColor,
          textureSize = graphicAttribute.textureSize,
          texturePadding = graphicAttribute.texturePadding
        } = graphic.attribute;
        texture && this.drawTexture(texture, graphic, context, x, y, graphicAttribute, textureColor, textureSize, texturePadding);
      }
      drawTexture(texture, graphic, context, x, y, graphicAttribute, textureColor, textureSize, texturePadding) {
        var _a;
        const {
          textureRatio = graphicAttribute.textureRatio,
          textureOptions = null
        } = graphic.attribute;
        let pattern = this.textureMap.get(texture);
        if (!pattern) switch (texture) {
          case "circle":
            pattern = this.createCirclePattern(textureSize, texturePadding, textureColor, context);
            break;
          case "diamond":
            pattern = this.createDiamondPattern(textureSize, texturePadding, textureColor, context);
            break;
          case "rect":
            pattern = this.createRectPattern(textureSize, texturePadding, textureColor, context);
            break;
          case "vertical-line":
            pattern = this.createVerticalLinePattern(textureSize, texturePadding, textureColor, context);
            break;
          case "horizontal-line":
            pattern = this.createHorizontalLinePattern(textureSize, texturePadding, textureColor, context);
            break;
          case "bias-lr":
            pattern = this.createBiasLRLinePattern(textureSize, texturePadding, textureColor, context);
            break;
          case "bias-rl":
            pattern = this.createBiasRLLinePattern(textureSize, texturePadding, textureColor, context);
            break;
          case "grid":
            pattern = this.createGridPattern(textureSize, texturePadding, textureColor, context);
        }
        if (textureOptions && textureOptions.dynamicTexture) {
          const {
              gridConfig = {},
              useNewCanvas: useNewCanvas
            } = textureOptions,
            b = graphic.AABBBounds;
          x = b.x1, y = b.y1;
          const originalContext = context;
          let newCanvas;
          if (useNewCanvas) {
            newCanvas = canvasAllocate.allocate({
              width: b.width(),
              height: b.height(),
              dpr: context.dpr
            });
            const ctx = newCanvas.getContext("2d");
            ctx.clearRect(0, 0, b.width(), b.height()), x = 0, y = 0, context = ctx;
          }
          if (originalContext.save(), graphic.parent && !graphic.transMatrix.onlyTranslate()) {
            const {
              scrollX = 0,
              scrollY = 0
            } = graphic.parent.attribute;
            originalContext.setTransformFromMatrix(graphic.parent.globalTransMatrix), originalContext.translate(scrollX, scrollY, !0);
          }
          originalContext.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute), originalContext.clip();
          const width = b.width(),
            height = b.height(),
            padding = texturePadding,
            cellSize = textureSize,
            gridColumns = gridConfig.columns ? gridConfig.columns : Math.ceil(width / cellSize),
            gridRows = gridConfig.rows ? gridConfig.rows : Math.ceil(height / cellSize),
            gutterColumn = gridConfig.gutterColumn ? gridConfig.gutterColumn : 2 * padding,
            gutterRow = gridConfig.gutterRow ? gridConfig.gutterRow : 2 * padding;
          this._tempSymbolGraphic || (this._tempSymbolGraphic = createSymbol({}));
          const sizeW = gridConfig.columns ? width / gridConfig.columns : cellSize,
            sizeH = gridConfig.rows ? height / gridConfig.rows : cellSize;
          this._tempSymbolGraphic.setAttributes({
            size: [sizeW - gutterColumn, sizeH - gutterRow],
            symbolType: texture
          });
          const parsedPath = this._tempSymbolGraphic.getParsedPath();
          for (let i = 0; i < gridRows; i++) for (let j = 0; j < gridColumns; j++) {
            const _x = x + cellSize / 2 + j * cellSize,
              _y = y + cellSize / 2 + i * cellSize;
            null === (_a = textureOptions.beforeDynamicTexture) || void 0 === _a || _a.call(textureOptions, context, i, j, gridRows, gridColumns, textureRatio, graphic, b.width(), b.height()), context.beginPath(), !1 === parsedPath.draw(context, Math.min(sizeW - gutterColumn, sizeH - gutterRow), _x, _y, 0) && context.closePath(), context.fillStyle = textureColor, textureOptions.dynamicTexture(context, i, j, gridRows, gridColumns, textureRatio, graphic, b.width(), b.height());
          }
          useNewCanvas && (originalContext.globalAlpha = 1, originalContext.drawImage(newCanvas.nativeCanvas, 0, 0, newCanvas.nativeCanvas.width, newCanvas.nativeCanvas.height, b.x1, b.y1, b.width() * originalContext.dpr, b.height() * originalContext.dpr)), originalContext.restore();
        } else if (pattern) context.highPerformanceSave(), context.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute), context.fillStyle = pattern, context.fill(), context.highPerformanceRestore();else if ("wave" === texture) {
          context.save(), context.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute), context.clip();
          const b = graphic.AABBBounds;
          drawWave(context, textureRatio, b.width(), b.height(), Object.assign(Object.assign({}, textureOptions || {}), {
            fill: textureColor
          }), x + b.x1 - x, y + b.y1 - y), context.restore();
        }
      }
    }
    const defaultBaseTextureRenderContribution = new DefaultBaseTextureRenderContribution();

    class DefaultArcRenderContribution {
      constructor() {
        this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = !0, this.order = 0;
      }
      drawShape(arc, context, x, y, doFill, doStroke, fVisible, sVisible, arcAttribute, drawContext, fillCb, strokeCb) {
        const {
            outerBorder: outerBorder,
            innerBorder: innerBorder
          } = arc.attribute,
          doOuterBorder = outerBorder && !1 !== outerBorder.visible,
          doInnerBorder = innerBorder && !1 !== innerBorder.visible;
        if (!doOuterBorder && !doInnerBorder) return;
        const {
          innerPadding = arcAttribute.innerPadding,
          outerPadding = arcAttribute.outerPadding,
          startAngle = arcAttribute.startAngle,
          endAngle = arcAttribute.endAngle,
          opacity = arcAttribute.opacity,
          x: originX = arcAttribute.x,
          y: originY = arcAttribute.y,
          scaleX = arcAttribute.scaleX,
          scaleY = arcAttribute.scaleY,
          keepStrokeScale = arcAttribute.keepStrokeScale
        } = arc.attribute;
        let {
          innerRadius = arcAttribute.innerRadius,
          outerRadius = arcAttribute.outerRadius
        } = arc.attribute;
        outerRadius += outerPadding, innerRadius -= innerPadding;
        const renderBorder = (borderStyle, key) => {
          const doStroke = !(!borderStyle || !borderStyle.stroke),
            {
              distance = arcAttribute[key].distance
            } = borderStyle,
            d = keepStrokeScale ? distance : getScaledStroke(context, distance, context.dpr),
            deltaAngle = distance / outerRadius,
            sign = "outerBorder" === key ? 1 : -1;
          if (arc.setAttributes({
            outerRadius: outerRadius + sign * d,
            innerRadius: innerRadius - sign * d,
            startAngle: startAngle - sign * deltaAngle,
            endAngle: endAngle + sign * deltaAngle
          }), context.beginPath(), drawArcPath(arc, context, x, y, outerRadius + sign * d, innerRadius - sign * d), context.setShadowBlendStyle && context.setShadowBlendStyle(arc, arc.attribute, arcAttribute), strokeCb) strokeCb(context, borderStyle, arcAttribute[key]);else if (doStroke) {
            const lastOpacity = arcAttribute[key].opacity;
            arcAttribute[key].opacity = opacity, context.setStrokeStyle(arc, borderStyle, (originX - x) / scaleX, (originY - y) / scaleY, arcAttribute[key]), arcAttribute[key].opacity = lastOpacity, context.stroke();
          }
        };
        doOuterBorder && renderBorder(outerBorder, "outerBorder"), doInnerBorder && renderBorder(innerBorder, "innerBorder"), arc.setAttributes({
          outerRadius: outerRadius,
          innerRadius: innerRadius,
          startAngle: startAngle,
          endAngle: endAngle
        });
      }
    }
    const defaultArcRenderContribution = new DefaultArcRenderContribution();
    const defaultArcTextureRenderContribution = defaultBaseTextureRenderContribution;
    const defaultArcBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

    class DefaultCircleRenderContribution {
      constructor() {
        this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = !0, this.order = 0;
      }
      drawShape(circle, context, x, y, doFill, doStroke, fVisible, sVisible, circleAttribute, drawContext, fillCb, strokeCb) {
        const {
            outerBorder: outerBorder,
            innerBorder: innerBorder
          } = circle.attribute,
          doOuterBorder = outerBorder && !1 !== outerBorder.visible,
          doInnerBorder = innerBorder && !1 !== innerBorder.visible;
        if (!doOuterBorder && !doInnerBorder) return;
        const {
            radius = circleAttribute.radius,
            startAngle = circleAttribute.startAngle,
            endAngle = circleAttribute.endAngle,
            opacity = circleAttribute.opacity,
            x: originX = circleAttribute.x,
            y: originY = circleAttribute.y,
            scaleX = circleAttribute.scaleX,
            scaleY = circleAttribute.scaleY,
            keepStrokeScale = circleAttribute.keepStrokeScale
          } = circle.attribute,
          renderBorder = (borderStyle, key) => {
            const doStroke = !(!borderStyle || !borderStyle.stroke),
              {
                distance = circleAttribute[key].distance
              } = borderStyle,
              d = keepStrokeScale ? distance : getScaledStroke(context, distance, context.dpr),
              sign = "outerBorder" === key ? 1 : -1;
            if (context.beginPath(), context.arc(x, y, radius + sign * d, startAngle, endAngle), context.closePath(), context.setShadowBlendStyle && context.setShadowBlendStyle(circle, circle.attribute, circleAttribute), strokeCb) strokeCb(context, borderStyle, circleAttribute[key]);else if (doStroke) {
              const lastOpacity = circleAttribute[key].opacity;
              circleAttribute[key].opacity = opacity, context.setStrokeStyle(circle, borderStyle, (originX - x) / scaleX, (originY - y) / scaleY, circleAttribute[key]), circleAttribute[key].opacity = lastOpacity, context.stroke();
            }
          };
        doOuterBorder && renderBorder(outerBorder, "outerBorder"), doInnerBorder && renderBorder(innerBorder, "innerBorder");
      }
    }
    const defaultCircleRenderContribution = new DefaultCircleRenderContribution();
    const defaultCircleTextureRenderContribution = defaultBaseTextureRenderContribution;
    const defaultCircleBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

    class DefaultGroupBackgroundRenderContribution extends DefaultBaseBackgroundRenderContribution {
      constructor() {
        super(...arguments), this.time = BaseRenderContributionTime.beforeFillStroke;
      }
      drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb) {
        const {
          background: background,
          backgroundMode = graphicAttribute.backgroundMode,
          backgroundFit = graphicAttribute.backgroundFit,
          backgroundKeepAspectRatio = graphicAttribute.backgroundKeepAspectRatio,
          backgroundScale = graphicAttribute.backgroundScale,
          backgroundOffsetX = graphicAttribute.backgroundOffsetX,
          backgroundOffsetY = graphicAttribute.backgroundOffsetY
        } = graphic.attribute;
        if (background) if (graphic.backgroundImg && graphic.resources) {
          const res = graphic.resources.get(background);
          if ("success" !== res.state || !res.data) return;
          context.highPerformanceSave(), context.setTransformFromMatrix(graphic.parent.globalTransMatrix, !0);
          const b = graphic.AABBBounds;
          this.doDrawImage(context, res.data, b, {
            backgroundMode: backgroundMode,
            backgroundFit: backgroundFit,
            backgroundKeepAspectRatio: backgroundKeepAspectRatio,
            backgroundScale: backgroundScale,
            backgroundOffsetX: backgroundOffsetX,
            backgroundOffsetY: backgroundOffsetY
          }), context.highPerformanceRestore(), context.setTransformForCurrent();
        } else context.highPerformanceSave(), context.fillStyle = background, context.fill(), context.highPerformanceRestore();
      }
    }
    const defaultGroupBackgroundRenderContribution = new DefaultGroupBackgroundRenderContribution();

    const halfPi = pi / 2;
    function createRectPath(path, x, y, width, height, rectCornerRadius) {
      let roundCorner = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : !0;
      let edgeCb = arguments.length > 7 ? arguments[7] : undefined;
      let cornerRadius;
      if (Array.isArray(roundCorner) && (edgeCb = roundCorner, roundCorner = !0), width < 0 && (x += width, width = -width), height < 0 && (y += height, height = -height), isNumber$6(rectCornerRadius, !0)) cornerRadius = [rectCornerRadius = abs(rectCornerRadius), rectCornerRadius, rectCornerRadius, rectCornerRadius];else if (Array.isArray(rectCornerRadius)) {
        const cornerRadiusArr = rectCornerRadius;
        let cr0, cr1;
        switch (cornerRadiusArr.length) {
          case 0:
            cornerRadius = [0, 0, 0, 0];
            break;
          case 1:
            cr0 = abs(cornerRadiusArr[0]), cornerRadius = [cr0, cr0, cr0, cr0];
            break;
          case 2:
          case 3:
            cr0 = abs(cornerRadiusArr[0]), cr1 = abs(cornerRadiusArr[1]), cornerRadius = [cr0, cr1, cr0, cr1];
            break;
          default:
            cornerRadius = cornerRadiusArr, cornerRadius[0] = abs(cornerRadius[0]), cornerRadius[1] = abs(cornerRadius[1]), cornerRadius[2] = abs(cornerRadius[2]), cornerRadius[3] = abs(cornerRadius[3]);
        }
      } else cornerRadius = [0, 0, 0, 0];
      if (width < 0 || cornerRadius[0] + cornerRadius[1] + cornerRadius[2] + cornerRadius[3] < 1e-12) return path.rect(x, y, width, height);
      const [leftTop, rightTop, rightBottom, leftBottom] = [[x, y], [x + width, y], [x + width, y + height], [x, y + height]],
        maxCornerRadius = Math.min(width / 2, height / 2),
        _cornerRadius = [Math.min(maxCornerRadius, cornerRadius[0]), Math.min(maxCornerRadius, cornerRadius[1]), Math.min(maxCornerRadius, cornerRadius[2]), Math.min(maxCornerRadius, cornerRadius[3])],
        leftTopPoint1 = [leftTop[0] + _cornerRadius[0], leftTop[1]],
        leftTopPoint2 = [leftTop[0], leftTop[1] + _cornerRadius[0]],
        rightTopPoint1 = [rightTop[0] - _cornerRadius[1], rightTop[1]],
        rightTopPoint2 = [rightTop[0], rightTop[1] + _cornerRadius[1]],
        rightBottomPoint1 = [rightBottom[0] - _cornerRadius[2], rightBottom[1]],
        rightBottomPoint2 = [rightBottom[0], rightBottom[1] - _cornerRadius[2]],
        leftBottomPoint1 = [leftBottom[0] + _cornerRadius[3], leftBottom[1]],
        leftBottomPoint2 = [leftBottom[0], leftBottom[1] - _cornerRadius[3]];
      if (path.moveTo(leftTopPoint1[0], leftTopPoint1[1]), roundCorner) {
        if (edgeCb && edgeCb[0] ? edgeCb[0](leftTopPoint1[0], leftTopPoint1[1], rightTopPoint1[0], rightTopPoint1[1]) : path.lineTo(rightTopPoint1[0], rightTopPoint1[1]), !arrayEqual$1(rightTopPoint1, rightTopPoint2)) {
          edgeCb && edgeCb[0] && path.moveTo(rightTopPoint1[0], rightTopPoint1[1]);
          const centerX = rightTopPoint1[0],
            centerY = rightTopPoint1[1] + _cornerRadius[1];
          path.arc(centerX, centerY, _cornerRadius[1], -halfPi, 0, !1);
        }
        if (edgeCb && edgeCb[1] ? edgeCb[1](rightTopPoint2[0], rightTopPoint2[1], rightBottomPoint2[0], rightBottomPoint2[1]) : path.lineTo(rightBottomPoint2[0], rightBottomPoint2[1]), !arrayEqual$1(rightBottomPoint1, rightBottomPoint2)) {
          const centerX = rightBottomPoint2[0] - _cornerRadius[2],
            centerY = rightBottomPoint2[1];
          edgeCb && edgeCb[1] && path.moveTo(rightBottomPoint2[0], rightBottomPoint2[1]), path.arc(centerX, centerY, _cornerRadius[2], 0, halfPi, !1);
        }
        if (edgeCb && edgeCb[2] ? edgeCb[2](rightBottomPoint1[0], rightBottomPoint1[1], leftBottomPoint1[0], leftBottomPoint1[1]) : path.lineTo(leftBottomPoint1[0], leftBottomPoint1[1]), !arrayEqual$1(leftBottomPoint1, leftBottomPoint2)) {
          const centerX = leftBottomPoint1[0],
            centerY = leftBottomPoint1[1] - _cornerRadius[3];
          edgeCb && edgeCb[2] && path.moveTo(leftBottomPoint1[0], leftBottomPoint1[1]), path.arc(centerX, centerY, _cornerRadius[3], halfPi, pi, !1);
        }
        if (edgeCb && edgeCb[3] ? edgeCb[3](leftBottomPoint2[0], leftBottomPoint2[1], leftTopPoint2[0], leftTopPoint2[1]) : path.lineTo(leftTopPoint2[0], leftTopPoint2[1]), !arrayEqual$1(leftTopPoint1, leftTopPoint2)) {
          const centerX = leftTopPoint1[0],
            centerY = leftTopPoint1[1] + _cornerRadius[0];
          edgeCb && edgeCb[3] && path.moveTo(leftTopPoint2[0], leftTopPoint2[1]), path.arc(centerX, centerY, _cornerRadius[0], pi, pi + halfPi, !1);
        }
      } else edgeCb && edgeCb[0] ? edgeCb[0](leftTopPoint1[0], leftTopPoint1[1], rightTopPoint1[0], rightTopPoint1[1]) : path.lineTo(rightTopPoint1[0], rightTopPoint1[1]), edgeCb && edgeCb[1] ? edgeCb[1](rightTopPoint1[0], rightTopPoint1[1], rightBottomPoint1[0], rightBottomPoint1[1]) : path.lineTo(rightBottomPoint1[0], rightBottomPoint1[1]), edgeCb && edgeCb[2] ? edgeCb[2](rightBottomPoint1[0], rightBottomPoint1[1], leftBottomPoint1[0], leftBottomPoint1[1]) : path.lineTo(leftBottomPoint1[0], leftBottomPoint1[1]), edgeCb && edgeCb[2] ? edgeCb[2](leftBottomPoint1[0], leftBottomPoint1[1], leftTopPoint1[0], leftTopPoint1[1]) : path.lineTo(leftTopPoint1[0], leftTopPoint1[1]);
      return !edgeCb && path.closePath(), path;
    }

    var __decorate$U = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    class DefaultRectRenderContribution {
      constructor() {
        this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = !0, this.order = 0;
      }
      drawShape(rect, context, x, y, doFill, doStroke, fVisible, sVisible, rectAttribute, drawContext, fillCb, strokeCb) {
        const {
            outerBorder: outerBorder,
            innerBorder: innerBorder
          } = rect.attribute,
          doOuterBorder = outerBorder && !1 !== outerBorder.visible,
          doInnerBorder = innerBorder && !1 !== innerBorder.visible;
        if (!doOuterBorder && !doInnerBorder) return;
        const {
          cornerRadius = rectAttribute.cornerRadius,
          cornerType = rectAttribute.cornerType,
          opacity = rectAttribute.opacity,
          x: originX = rectAttribute.x,
          y: originY = rectAttribute.y,
          scaleX = rectAttribute.scaleX,
          scaleY = rectAttribute.scaleY,
          x1: x1,
          y1: y1,
          keepStrokeScale = rectAttribute.keepStrokeScale
        } = rect.attribute;
        let {
          width: width,
          height: height
        } = rect.attribute;
        width = (null != width ? width : x1 - x) || 0, height = (null != height ? height : y1 - y) || 0;
        const renderBorder = (borderStyle, key) => {
          const doStroke = !(!borderStyle || !borderStyle.stroke),
            sign = "outerBorder" === key ? -1 : 1,
            {
              distance = rectAttribute[key].distance
            } = borderStyle,
            d = keepStrokeScale ? distance : getScaledStroke(context, distance, context.dpr),
            nextX = x + sign * d,
            nextY = y + sign * d,
            dw = 2 * d;
          if (0 === cornerRadius || isArray$9(cornerRadius) && cornerRadius.every(num => 0 === num) ? (context.beginPath(), context.rect(nextX, nextY, width - sign * dw, height - sign * dw)) : (context.beginPath(), createRectPath(context, nextX, nextY, width - sign * dw, height - sign * dw, cornerRadius, "bevel" !== cornerType)), context.setShadowBlendStyle && context.setShadowBlendStyle(rect, rect.attribute, rectAttribute), strokeCb) strokeCb(context, borderStyle, rectAttribute[key]);else if (doStroke) {
            const lastOpacity = rectAttribute[key].opacity;
            rectAttribute[key].opacity = opacity, context.setStrokeStyle(rect, borderStyle, (originX - x) / scaleX, (originY - y) / scaleY, rectAttribute[key]), rectAttribute[key].opacity = lastOpacity, context.stroke();
          }
        };
        doOuterBorder && renderBorder(outerBorder, "outerBorder"), doInnerBorder && renderBorder(innerBorder, "innerBorder");
      }
    }
    let SplitRectBeforeRenderContribution$1 = class SplitRectBeforeRenderContribution {
      constructor() {
        this.time = BaseRenderContributionTime.beforeFillStroke, this.useStyle = !0, this.order = 0;
      }
      drawShape(group, context, x, y, doFill, doStroke, fVisible, sVisible, groupAttribute, drawContext, fillCb, strokeCb, doFillOrStroke) {
        const {
          stroke = groupAttribute.stroke
        } = group.attribute;
        Array.isArray(stroke) && stroke.some(s => !1 === s) && (doFillOrStroke.doStroke = !1);
      }
    };
    SplitRectBeforeRenderContribution$1 = __decorate$U([injectable()], SplitRectBeforeRenderContribution$1);
    let SplitRectAfterRenderContribution$1 = class SplitRectAfterRenderContribution {
      constructor() {
        this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = !0, this.order = 0;
      }
      drawShape(rect, context, x, y, doFill, doStroke, fVisible, sVisible, groupAttribute, drawContext, fillCb, strokeCb) {
        const {
          x1: x1,
          y1: y1,
          x: originX = groupAttribute.x,
          y: originY = groupAttribute.y,
          stroke = groupAttribute.stroke,
          cornerRadius = groupAttribute.cornerRadius,
          cornerType = groupAttribute.cornerType
        } = rect.attribute;
        let {
          width: width,
          height: height
        } = rect.attribute;
        if (width = (null != width ? width : x1 - originX) || 0, height = (null != height ? height : y1 - originY) || 0, Array.isArray(stroke) && stroke.some(s => !1 === s)) {
          if (context.setStrokeStyle(rect, rect.attribute, x, y, groupAttribute), !(0 === cornerRadius || isArray$9(cornerRadius) && cornerRadius.every(num => 0 === num))) {
            let lastStroke,
              lastStrokeI = 0;
            return createRectPath(context, x, y, width, height, cornerRadius, "bevel" !== cornerType, new Array(4).fill(0).map((_, i) => (x1, y1, x2, y2) => {
              stroke[i] && (lastStrokeI === i - 1 && stroke[i] === lastStroke || (context.setStrokeStyle(rect, Object.assign(Object.assign({}, rect.attribute), {
                stroke: stroke[i]
              }), x, y, groupAttribute), context.beginPath(), context.moveTo(x1, y1), lastStroke = stroke[i]), lastStrokeI = i, context.lineTo(x2, y2), context.stroke(), 3 === i && context.beginPath());
            })), void context.stroke();
          }
          if (context.beginPath(), context.moveTo(x, y), stroke[0] ? context.lineTo(x + width, y) : context.moveTo(x + width, y), stroke[1] ? context.lineTo(x + width, y + height) : context.moveTo(x + width, y + height), stroke[2] ? context.lineTo(x, y + height) : context.moveTo(x, y + height), stroke[3]) {
            const adjustY = stroke[0] ? y - context.lineWidth / 2 : y;
            context.lineTo(x, adjustY);
          } else context.moveTo(x, y);
          context.stroke();
        }
      }
    };
    SplitRectAfterRenderContribution$1 = __decorate$U([injectable()], SplitRectAfterRenderContribution$1);
    const defaultRectRenderContribution = new DefaultRectRenderContribution();
    const defaultRectTextureRenderContribution = defaultBaseTextureRenderContribution;
    const defaultRectBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

    class DefaultImageRenderContribution extends DefaultRectRenderContribution {
      constructor() {
        super(...arguments), this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = !0, this.order = 0;
      }
      drawShape(image, context, x, y, doFill, doStroke, fVisible, sVisible, rectAttribute, drawContext, fillCb, strokeCb) {
        return super.drawShape(image, context, x, y, doFill, doStroke, fVisible, sVisible, rectAttribute, drawContext, fillCb, strokeCb);
      }
    }
    const defaultImageRenderContribution = new DefaultImageRenderContribution();
    const defaultImageBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

    class DefaultSymbolRenderContribution {
      constructor() {
        this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = !0, this.order = 0;
      }
      drawShape(symbol, context, x, y, doFill, doStroke, fVisible, sVisible, symbolAttribute, drawContext, fillCb, strokeCb) {
        const parsedPath = symbol.getParsedPath();
        if (!parsedPath) return;
        const {
            outerBorder: outerBorder,
            innerBorder: innerBorder
          } = symbol.attribute,
          doOuterBorder = outerBorder && !1 !== outerBorder.visible,
          doInnerBorder = innerBorder && !1 !== innerBorder.visible;
        if (!doOuterBorder && !doInnerBorder) return;
        const {
            size = symbolAttribute.size,
            opacity = symbolAttribute.opacity,
            x: originX = symbolAttribute.x,
            y: originY = symbolAttribute.y,
            scaleX = symbolAttribute.scaleX,
            scaleY = symbolAttribute.scaleY,
            keepStrokeScale = symbolAttribute.keepStrokeScale
          } = symbol.attribute,
          renderBorder = (borderStyle, key) => {
            const doStroke = !(!borderStyle || !borderStyle.stroke),
              {
                distance = symbolAttribute[key].distance
              } = borderStyle,
              d = keepStrokeScale ? distance : getScaledStroke(context, distance, context.dpr),
              sign = "outerBorder" === key ? 1 : -1;
            if (context.beginPath(), !1 === parsedPath.drawOffset(context, size, x, y, sign * d) && context.closePath(), context.setShadowBlendStyle && context.setShadowBlendStyle(symbol, symbol.attribute, symbolAttribute), strokeCb) strokeCb(context, borderStyle, symbolAttribute[key]);else if (doStroke) {
              const lastOpacity = symbolAttribute[key].opacity;
              symbolAttribute[key].opacity = opacity, context.setStrokeStyle(symbol, borderStyle, (originX - x) / scaleX, (originY - y) / scaleY, symbolAttribute[key]), symbolAttribute[key].opacity = lastOpacity, context.stroke();
            }
          };
        doOuterBorder && renderBorder(outerBorder, "outerBorder"), doInnerBorder && renderBorder(innerBorder, "innerBorder");
      }
    }
    class DefaultSymbolClipRangeStrokeRenderContribution {
      constructor() {
        this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = !0, this.order = 0;
      }
      drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options) {
        const {
            clipRange = graphicAttribute.clipRange,
            x: originX = graphicAttribute.x,
            y: originY = graphicAttribute.y,
            z = graphicAttribute.z,
            size = graphicAttribute.size,
            scaleX = graphicAttribute.scaleX,
            scaleY = graphicAttribute.scaleY
          } = graphic.attribute,
          parsedPath = graphic.getParsedPath();
        if (!(parsedPath && clipRange < 1 && clipRange > 0)) return;
        context.beginPath(), parsedPath.drawWithClipRange && parsedPath.drawWithClipRange(context, size, x, y, clipRange, z, (p, a) => {
          var _a, _b, _c, _d;
          if (graphic._parsedPath.svgCache) {
            const obj = Object.assign({}, a);
            obj.fill = null !== (_a = a.fill) && void 0 !== _a ? _a : graphic.attribute.fill, obj.opacity = null !== (_b = a.opacity) && void 0 !== _b ? _b : graphic.attribute.opacity, obj.fillOpacity = graphic.attribute.fillOpacity, obj.stroke = null !== (_c = a.stroke) && void 0 !== _c ? _c : graphic.attribute.stroke, obj.lineWidth = null !== (_d = a.lineWidth) && void 0 !== _d ? _d : graphic.attribute.lineWidth, a = obj;
          }
          a.stroke && (strokeCb ? strokeCb(context, graphic.attribute, graphicAttribute) : sVisible && (context.setStrokeStyle(graphic, a, (originX - x) / scaleX, (originY - y) / scaleY, graphicAttribute), context.stroke()));
        }), doStroke && !parsedPath.isSvg && (strokeCb ? strokeCb(context, graphic.attribute, graphicAttribute) : sVisible && (context.setStrokeStyle(graphic, graphic.attribute, (originX - x) / scaleX, (originY - y) / scaleY, graphicAttribute), context.stroke()));
      }
    }
    const defaultSymbolRenderContribution = new DefaultSymbolRenderContribution();
    const defaultSymbolClipRangeStrokeRenderContribution = new DefaultSymbolClipRangeStrokeRenderContribution();
    const defaultSymbolTextureRenderContribution = defaultBaseTextureRenderContribution;
    const defaultSymbolBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

    class DefaultAreaTextureRenderContribution extends DefaultBaseTextureRenderContribution {
      constructor() {
        super(...arguments), this.time = BaseRenderContributionTime.afterFillStroke;
      }
      drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options) {
        var _a, _b, _c, _d;
        this.textureMap || this.initTextureMap(context, graphic.stage);
        const {
            attribute = graphic.attribute
          } = options || {},
          {
            texture = null !== (_a = graphic.attribute.texture) && void 0 !== _a ? _a : getAttributeFromDefaultAttrList(graphicAttribute, "texture"),
            textureColor = null !== (_b = graphic.attribute.textureColor) && void 0 !== _b ? _b : getAttributeFromDefaultAttrList(graphicAttribute, "textureColor"),
            textureSize = null !== (_c = graphic.attribute.textureSize) && void 0 !== _c ? _c : getAttributeFromDefaultAttrList(graphicAttribute, "textureSize"),
            texturePadding = null !== (_d = graphic.attribute.texturePadding) && void 0 !== _d ? _d : getAttributeFromDefaultAttrList(graphicAttribute, "texturePadding")
          } = attribute;
        texture && this.drawTexture(texture, graphic, context, x, y, graphicAttribute, textureColor, textureSize, texturePadding);
      }
    }

    const result = {
      x: 0,
      y: 0,
      z: 0,
      lastModelMatrix: null
    };
    class BaseRender {
      init(contributions) {
        contributions && (this._renderContribitions = contributions.getContributions()), this._renderContribitions || (this._renderContribitions = []), this.builtinContributions || (this.builtinContributions = []), this.builtinContributions.push(defaultBaseClipRenderBeforeContribution), this.builtinContributions.push(defaultBaseClipRenderAfterContribution), this.builtinContributions.forEach(item => this._renderContribitions.push(item)), this._renderContribitions.length && (this._renderContribitions.sort((a, b) => b.order - a.order), this._beforeRenderContribitions = this._renderContribitions.filter(c => c.time === BaseRenderContributionTime.beforeFillStroke), this._afterRenderContribitions = this._renderContribitions.filter(c => c.time === BaseRenderContributionTime.afterFillStroke));
      }
      reInit() {
        this.init(this.graphicRenderContributions);
      }
      beforeRenderStep(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, params) {
        this._beforeRenderContribitions && this._beforeRenderContribitions.forEach(c => {
          if (c.supportedAppName && graphic.stage && graphic.stage.params && graphic.stage.params.context && graphic.stage.params.context.appName) {
            if (!(Array.isArray(c.supportedAppName) ? c.supportedAppName : [c.supportedAppName]).includes(graphic.stage.params.context.appName)) return;
          }
          c.drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, params);
        });
      }
      afterRenderStep(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, params) {
        this._afterRenderContribitions && this._afterRenderContribitions.forEach(c => {
          if (c.supportedAppName && graphic.stage && graphic.stage.params && graphic.stage.params.context && graphic.stage.params.context.appName) {
            if (!(Array.isArray(c.supportedAppName) ? c.supportedAppName : [c.supportedAppName]).includes(graphic.stage.params.context.appName)) return;
          }
          c.drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, params);
        });
      }
      drawPathProxy(graphic, context, x, y, drawContext, params, fillCb, strokeCb) {
        if (!graphic.pathProxy) return !1;
        const themeAttributes = getTheme(graphic, null == params ? void 0 : params.theme)[graphic.type.replace("3d", "")],
          {
            fill = themeAttributes.fill,
            stroke = themeAttributes.stroke,
            opacity = themeAttributes.opacity,
            fillOpacity = themeAttributes.fillOpacity,
            lineWidth = themeAttributes.lineWidth,
            strokeOpacity = themeAttributes.strokeOpacity,
            visible = themeAttributes.visible,
            x: originX = themeAttributes.x,
            y: originY = themeAttributes.y
          } = graphic.attribute,
          fVisible = fillVisible(opacity, fillOpacity, fill),
          sVisible = strokeVisible(opacity, strokeOpacity),
          doFill = runFill(fill),
          doStroke = runStroke(stroke, lineWidth);
        if (!visible) return !0;
        if (!doFill && !doStroke) return !0;
        if (!(fVisible || sVisible || fillCb || strokeCb)) return !0;
        context.beginPath();
        const path = "function" == typeof graphic.pathProxy ? graphic.pathProxy(graphic.attribute) : graphic.pathProxy;
        return renderCommandList(path.commandList, context, x, y), context.setShadowBlendStyle && context.setShadowBlendStyle(graphic, graphic.attribute, themeAttributes), this.beforeRenderStep(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, themeAttributes, drawContext, fillCb, strokeCb), doStroke && (strokeCb ? strokeCb(context, graphic.attribute, themeAttributes) : sVisible && (context.setStrokeStyle(graphic, graphic.attribute, x - originX, y - originY, themeAttributes), context.stroke())), doFill && (fillCb ? fillCb(context, graphic.attribute, themeAttributes) : fVisible && (context.setCommonStyle(graphic, graphic.attribute, x - originX, y - originY, themeAttributes), context.fill())), this.afterRenderStep(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, themeAttributes, drawContext, fillCb, strokeCb), !0;
      }
      valid(graphic, defaultAttribute, fillCb, strokeCb) {
        const {
            fill = defaultAttribute.fill,
            background: background,
            stroke = defaultAttribute.stroke,
            opacity = defaultAttribute.opacity,
            fillOpacity = defaultAttribute.fillOpacity,
            lineWidth = defaultAttribute.lineWidth,
            strokeOpacity = defaultAttribute.strokeOpacity,
            visible = defaultAttribute.visible
          } = graphic.attribute,
          fVisible = fillVisible(opacity, fillOpacity, fill),
          sVisible = strokeVisible(opacity, strokeOpacity),
          doFill = runFill(fill, background),
          doStroke = runStroke(stroke, lineWidth);
        return !(!graphic.valid || !visible) && !(!doFill && !doStroke) && !!(fVisible || sVisible || fillCb || strokeCb || background) && {
          fVisible: fVisible,
          sVisible: sVisible,
          doFill: doFill,
          doStroke: doStroke
        };
      }
      transform(graphic, graphicAttribute, context) {
        let use3dMatrixIn3dMode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
        const {
            x = graphicAttribute.x,
            y = graphicAttribute.y,
            z = graphicAttribute.z,
            scaleX = graphicAttribute.scaleX,
            scaleY = graphicAttribute.scaleY,
            angle = graphicAttribute.angle,
            postMatrix: postMatrix
          } = graphic.attribute,
          lastModelMatrix = context.modelMatrix,
          camera = context.camera;
        result.x = x, result.y = y, result.z = z, result.lastModelMatrix = lastModelMatrix;
        const shouldTransform3d = camera && (use3dMatrixIn3dMode || shouldUseMat4(graphic)),
          onlyTranslate = shouldTransform3d ? graphic.transMatrix.onlyTranslate() && !postMatrix : 1 === scaleX && 1 === scaleY && 0 === angle && !postMatrix;
        if (shouldTransform3d) {
          const nextModelMatrix = mat4Allocate.allocate(),
            modelMatrix = mat4Allocate.allocate();
          getModelMatrix(modelMatrix, graphic, graphicAttribute), multiplyMat4Mat4(nextModelMatrix, lastModelMatrix || nextModelMatrix, modelMatrix), result.x = 0, result.y = 0, result.z = 0, context.modelMatrix = nextModelMatrix, context.setTransform(1, 0, 0, 1, 0, 0, !0), mat4Allocate.free(modelMatrix);
        }
        if (onlyTranslate && !lastModelMatrix) {
          const point = graphic.getOffsetXY(graphicAttribute);
          result.x += point.x, result.y += point.y, result.z = z, context.setTransformForCurrent();
        } else if (shouldTransform3d) result.x = 0, result.y = 0, result.z = 0, context.setTransform(1, 0, 0, 1, 0, 0, !0);else if (camera && context.project) {
          const point = graphic.getOffsetXY(graphicAttribute);
          result.x += point.x, result.y += point.y, this.transformWithoutTranslate(context, result.x, result.y, result.z, scaleX, scaleY, angle);
        } else context.transformFromMatrix(graphic.transMatrix, !0), result.x = 0, result.y = 0, result.z = 0;
        return result;
      }
      transformUseContext2d(graphic, graphicAttribute, z, context) {
        const camera = context.camera;
        if (this.camera = camera, camera) {
          const bounds = graphic.AABBBounds,
            width = bounds.x2 - bounds.x1,
            height = bounds.y2 - bounds.y1,
            p1 = context.project(0, 0, z),
            p2 = context.project(width, 0, z),
            p3 = context.project(width, height, z),
            _p1 = {
              x: 0,
              y: 0
            },
            _p2 = {
              x: width,
              y: 0
            },
            _p3 = {
              x: width,
              y: height
            };
          context.camera = null;
          const denom = 1 / (_p1.x * (_p3.y - _p2.y) - _p2.x * _p3.y + _p3.x * _p2.y + (_p2.x - _p3.x) * _p1.y),
            m11 = -(_p1.y * (p3.x - p2.x) - _p2.y * p3.x + _p3.y * p2.x + (_p2.y - _p3.y) * p1.x) * denom,
            m12 = (_p2.y * p3.y + _p1.y * (p2.y - p3.y) - _p3.y * p2.y + (_p3.y - _p2.y) * p1.y) * denom,
            m21 = (_p1.x * (p3.x - p2.x) - _p2.x * p3.x + _p3.x * p2.x + (_p2.x - _p3.x) * p1.x) * denom,
            m22 = -(_p2.x * p3.y + _p1.x * (p2.y - p3.y) - _p3.x * p2.y + (_p3.x - _p2.x) * p1.y) * denom,
            dx = (_p1.x * (_p3.y * p2.x - _p2.y * p3.x) + _p1.y * (_p2.x * p3.x - _p3.x * p2.x) + (_p3.x * _p2.y - _p2.x * _p3.y) * p1.x) * denom,
            dy = (_p1.x * (_p3.y * p2.y - _p2.y * p3.y) + _p1.y * (_p2.x * p3.y - _p3.x * p2.y) + (_p3.x * _p2.y - _p2.x * _p3.y) * p1.y) * denom;
          context.setTransform(m11, m12, m21, m22, dx, dy, !0);
        }
      }
      restoreTransformUseContext2d(graphic, graphicAttribute, z, context) {
        this.camera && (context.camera = this.camera);
      }
      transformWithoutTranslate(context, x, y, z, scaleX, scaleY, angle) {
        const p = context.project(x, y, z);
        context.translate(p.x, p.y, !1), context.scale(scaleX, scaleY, !1), context.rotate(angle, !1), context.translate(-p.x, -p.y, !1), context.setTransformForCurrent();
      }
      _draw(graphic, defaultAttr, computed3dMatrix, drawContext, params) {
        const {
          context: context
        } = drawContext;
        if (!context) return;
        const {
          renderable: renderable
        } = graphic.attribute;
        if (!1 === renderable) return;
        context.highPerformanceSave();
        const data = this.transform(graphic, defaultAttr, context, computed3dMatrix),
          {
            x: x,
            y: y,
            z: z,
            lastModelMatrix: lastModelMatrix
          } = data;
        this.z = z, this.drawPathProxy(graphic, context, x, y, drawContext, params) || (this.drawShape(graphic, context, x, y, drawContext, params), this.z = 0, context.modelMatrix !== lastModelMatrix && mat4Allocate.free(context.modelMatrix), context.modelMatrix = lastModelMatrix), context.highPerformanceRestore();
      }
    }

    var __decorate$T = undefined && undefined.__decorate || function (decorators, target, key, desc) {
        var d,
          c = arguments.length,
          r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      },
      __metadata$H = undefined && undefined.__metadata || function (k, v) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
      },
      __param$x = undefined && undefined.__param || function (paramIndex, decorator) {
        return function (target, key) {
          decorator(target, key, paramIndex);
        };
      };
    let DefaultCanvasArcRender = class extends BaseRender {
      constructor(graphicRenderContributions) {
        super(), this.graphicRenderContributions = graphicRenderContributions, this.numberType = ARC_NUMBER_TYPE, this.builtinContributions = [defaultArcRenderContribution, defaultArcBackgroundRenderContribution, defaultArcTextureRenderContribution], this.init(graphicRenderContributions);
      }
      drawArcTailCapPath(arc, context, cx, cy, outerRadius, innerRadius, _sa, _ea) {
        const capAngle = _ea - _sa,
          data = arc.getParsedAngle(),
          startAngle = data.startAngle;
        let endAngle = data.endAngle;
        endAngle = _ea;
        const clockwise = endAngle > startAngle;
        let collapsedToLine = !1;
        if (outerRadius < innerRadius) {
          const temp = outerRadius;
          outerRadius = innerRadius, innerRadius = temp;
        }
        const {
          outerDeltaAngle: outerDeltaAngle,
          xors: xors,
          yors: yors,
          xirs: xirs,
          yirs: yirs,
          limitedOcr: limitedOcr,
          outerCornerRadiusStart: outerCornerRadiusStart,
          outerCornerRadiusEnd: outerCornerRadiusEnd,
          maxOuterCornerRadius: maxOuterCornerRadius,
          xore: xore,
          yore: yore,
          xire: xire,
          yire: yire,
          limitedIcr: limitedIcr,
          innerDeltaAngle: innerDeltaAngle,
          innerStartAngle: innerStartAngle,
          innerCornerRadiusStart: innerCornerRadiusStart,
          innerCornerRadiusEnd: innerCornerRadiusEnd,
          maxInnerCornerRadius: maxInnerCornerRadius
        } = calculateArcCornerRadius(arc, startAngle, endAngle, innerRadius, outerRadius);
        if (limitedOcr > epsilon) {
          const cornerRadiusStart = min(outerCornerRadiusStart, limitedOcr),
            cornerRadiusEnd = min(outerCornerRadiusEnd, limitedOcr),
            t0 = cornerTangents(xirs, yirs, xors, yors, outerRadius, cornerRadiusStart, Number(clockwise)),
            t1 = cornerTangents(xore, yore, xire, yire, outerRadius, cornerRadiusEnd, Number(clockwise));
          if (limitedOcr < maxOuterCornerRadius && cornerRadiusStart === cornerRadiusEnd) context.moveTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01), context.arc(cx + t0.cx, cy + t0.cy, limitedOcr, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !clockwise);else {
            const a1 = endAngle - capAngle - .03,
              a2 = atan2(t1.y11, t1.x11);
            context.arc(cx, cy, outerRadius, a1, a2, !clockwise), cornerRadiusEnd > 0 && context.arc(cx + t1.cx, cy + t1.cy, cornerRadiusEnd, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !clockwise);
          }
        } else context.moveTo(cx + xors, cy + yors);
        if (!(innerRadius > epsilon) || innerDeltaAngle < .001) context.lineTo(cx + xire, cy + yire), collapsedToLine = !0;else if (limitedIcr > epsilon) {
          const cornerRadiusStart = min(innerCornerRadiusStart, limitedIcr),
            cornerRadiusEnd = min(innerCornerRadiusEnd, limitedIcr),
            t0 = cornerTangents(xire, yire, xore, yore, innerRadius, -cornerRadiusEnd, Number(clockwise)),
            t1 = cornerTangents(xors, yors, xirs, yirs, innerRadius, -cornerRadiusStart, Number(clockwise));
          if (context.lineTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01), limitedIcr < maxInnerCornerRadius && cornerRadiusStart === cornerRadiusEnd) {
            const arcEndAngle = atan2(t1.y01, t1.x01);
            context.arc(cx + t0.cx, cy + t0.cy, limitedIcr, atan2(t0.y01, t0.x01), arcEndAngle, !clockwise);
          } else {
            cornerRadiusEnd > 0 && context.arc(cx + t0.cx, cy + t0.cy, cornerRadiusEnd, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !clockwise);
            const a1 = atan2(t0.cy + t0.y11, t0.cx + t0.x11),
              a2 = endAngle - capAngle - .03;
            context.arc(cx, cy, innerRadius, a1, a2, clockwise);
          }
        } else context.lineTo(cx + innerRadius * cos(innerStartAngle), cy + innerRadius * sin(innerStartAngle));
        return collapsedToLine;
      }
      drawShape(arc, context, x, y, drawContext, params, fillCb, strokeCb) {
        const arcAttribute = getTheme(arc, null == params ? void 0 : params.theme).arc,
          {
            fill = arcAttribute.fill,
            stroke = arcAttribute.stroke,
            x: originX = arcAttribute.x,
            y: originY = arcAttribute.y,
            fillStrokeOrder = arcAttribute.fillStrokeOrder
          } = arc.attribute,
          data = this.valid(arc, arcAttribute, fillCb, strokeCb);
        if (!data) return;
        const {
            fVisible: fVisible,
            sVisible: sVisible,
            doFill: doFill,
            doStroke: doStroke
          } = data,
          {
            outerPadding = arcAttribute.outerPadding,
            innerPadding = arcAttribute.innerPadding,
            cap = arcAttribute.cap,
            forceShowCap = arcAttribute.forceShowCap
          } = arc.attribute;
        let {
          outerRadius = arcAttribute.outerRadius,
          innerRadius = arcAttribute.innerRadius
        } = arc.attribute;
        outerRadius += outerPadding, innerRadius -= innerPadding;
        let conicalOffset = 0;
        const tempChangeConicalColor = (isBoolean$6(cap) && cap || cap[0]) && "conical" === fill.gradient;
        if (tempChangeConicalColor) {
          const {
            sc: sc,
            startAngle: startAngle,
            endAngle: endAngle
          } = arc.getParsedAngle();
          abs(endAngle - startAngle) < pi2 - epsilon && (conicalOffset = sc || 0, fill.startAngle -= conicalOffset, fill.endAngle -= conicalOffset);
        }
        let beforeRenderContribitionsRuned = !1;
        const {
          isFullStroke: isFullStroke,
          stroke: arrayStroke
        } = parseStroke(stroke);
        if (doFill || isFullStroke) {
          context.beginPath(), drawArcPath(arc, context, x, y, outerRadius, innerRadius), beforeRenderContribitionsRuned = !0, context.setShadowBlendStyle && context.setShadowBlendStyle(arc, arc.attribute, arcAttribute), this.beforeRenderStep(arc, context, x, y, doFill, doStroke, fVisible, sVisible, arcAttribute, drawContext, fillCb, strokeCb);
          const _runFill = () => {
              doFill && (fillCb ? fillCb(context, arc.attribute, arcAttribute) : fVisible && (context.setCommonStyle(arc, arc.attribute, originX - x, originY - y, arcAttribute), context.fill()));
            },
            _runStroke = () => {
              doStroke && isFullStroke && (strokeCb ? strokeCb(context, arc.attribute, arcAttribute) : sVisible && (context.setStrokeStyle(arc, arc.attribute, originX - x, originY - y, arcAttribute), context.stroke()));
            };
          fillStrokeOrder ? (_runStroke(), _runFill()) : (_runFill(), _runStroke());
        }
        if (!isFullStroke && doStroke) {
          context.beginPath();
          drawArcPath(arc, context, x, y, outerRadius, innerRadius, arrayStroke);
          beforeRenderContribitionsRuned || this.beforeRenderStep(arc, context, x, y, doFill, doStroke, fVisible, sVisible, arcAttribute, drawContext, fillCb, strokeCb), strokeCb ? strokeCb(context, arc.attribute, arcAttribute) : sVisible && (context.setStrokeStyle(arc, arc.attribute, x, y, arcAttribute), context.stroke());
        }
        if ((isBoolean$6(cap) && cap || cap[1]) && forceShowCap) {
          const {
            startAngle: sa,
            endAngle: ea
          } = arc.getParsedAngle();
          if (abs(ea - sa) >= pi2 - epsilon) {
            context.beginPath();
            const capAngle = Math.abs(outerRadius - innerRadius) / 2 / outerRadius,
              {
                endAngle = arcAttribute.endAngle,
                fill = arcAttribute.fill
              } = arc.attribute,
              startAngle = endAngle;
            this.drawArcTailCapPath(arc, context, x, y, outerRadius, innerRadius, startAngle, startAngle + capAngle), beforeRenderContribitionsRuned || this.beforeRenderStep(arc, context, x, y, doFill, doStroke, fVisible, sVisible, arcAttribute, drawContext, fillCb, strokeCb);
            const _runFill = () => {
                if (doFill) {
                  const color = fill;
                  if ("conical" === color.gradient) {
                    const lastColor = getConicGradientAt(0, 0, endAngle, color);
                    fillCb || fillVisible && (context.setCommonStyle(arc, arc.attribute, x, y, arcAttribute), context.fillStyle = lastColor, context.fill());
                  }
                }
              },
              _runStroke = () => {
                doStroke && (strokeCb || sVisible && (context.setStrokeStyle(arc, arc.attribute, x, y, arcAttribute), context.stroke()));
              };
            _runFill(), _runStroke();
          }
        }
        this.afterRenderStep(arc, context, x, y, doFill, doStroke, fVisible, sVisible, arcAttribute, drawContext, fillCb, strokeCb), tempChangeConicalColor && (fill.startAngle += conicalOffset, fill.endAngle += conicalOffset);
      }
      draw(arc, renderService, drawContext, params) {
        const arcAttribute = getTheme(arc, null == params ? void 0 : params.theme).arc;
        this._draw(arc, arcAttribute, !1, drawContext, params);
      }
    };
    DefaultCanvasArcRender = __decorate$T([injectable(), __param$x(0, inject(ContributionProvider)), __param$x(0, named(ArcRenderContribution)), __metadata$H("design:paramtypes", [Object])], DefaultCanvasArcRender);

    var __decorate$S = undefined && undefined.__decorate || function (decorators, target, key, desc) {
        var d,
          c = arguments.length,
          r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      },
      __metadata$G = undefined && undefined.__metadata || function (k, v) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
      },
      __param$w = undefined && undefined.__param || function (paramIndex, decorator) {
        return function (target, key) {
          decorator(target, key, paramIndex);
        };
      };
    let DefaultCanvasCircleRender = class extends BaseRender {
      constructor(graphicRenderContributions) {
        super(), this.graphicRenderContributions = graphicRenderContributions, this.numberType = CIRCLE_NUMBER_TYPE, this.builtinContributions = [defaultCircleRenderContribution, defaultCircleBackgroundRenderContribution, defaultCircleTextureRenderContribution], this.init(graphicRenderContributions);
      }
      drawShape(circle, context, x, y, drawContext, params, fillCb, strokeCb) {
        const circleAttribute = getTheme(circle, null == params ? void 0 : params.theme).circle,
          {
            radius = circleAttribute.radius,
            startAngle = circleAttribute.startAngle,
            endAngle = circleAttribute.endAngle,
            x: originX = circleAttribute.x,
            y: originY = circleAttribute.y,
            fillStrokeOrder = circleAttribute.fillStrokeOrder
          } = circle.attribute,
          data = this.valid(circle, circleAttribute, fillCb, strokeCb);
        if (!data) return;
        const {
          fVisible: fVisible,
          sVisible: sVisible,
          doFill: doFill,
          doStroke: doStroke
        } = data;
        context.beginPath(), context.arc(x, y, radius, startAngle, endAngle), context.closePath(), context.setShadowBlendStyle && context.setShadowBlendStyle(circle, circle.attribute, circleAttribute), this.beforeRenderStep(circle, context, x, y, doFill, doStroke, fVisible, sVisible, circleAttribute, drawContext, fillCb, strokeCb);
        const _runFill = () => {
            doFill && (fillCb ? fillCb(context, circle.attribute, circleAttribute) : fVisible && (context.setCommonStyle(circle, circle.attribute, originX - x, originY - y, circleAttribute), context.fill()));
          },
          _runStroke = () => {
            doStroke && (strokeCb ? strokeCb(context, circle.attribute, circleAttribute) : sVisible && (context.setStrokeStyle(circle, circle.attribute, originX - x, originY - y, circleAttribute), context.stroke()));
          };
        fillStrokeOrder ? (_runStroke(), _runFill()) : (_runFill(), _runStroke()), this.afterRenderStep(circle, context, x, y, doFill, doStroke, fVisible, sVisible, circleAttribute, drawContext, fillCb, strokeCb);
      }
      draw(circle, renderService, drawContext, params) {
        const circleAttribute = getTheme(circle, null == params ? void 0 : params.theme).circle;
        this._draw(circle, circleAttribute, !1, drawContext, params);
      }
    };
    DefaultCanvasCircleRender = __decorate$S([injectable(), __param$w(0, inject(ContributionProvider)), __param$w(0, named(CircleRenderContribution)), __metadata$G("design:paramtypes", [Object])], DefaultCanvasCircleRender);

    function drawSegItem(ctx, curve, endPercent, params) {
      if (!curve.p1) return;
      const {
        offsetX = 0,
        offsetY = 0,
        offsetZ = 0
      } = params || {};
      if (1 === endPercent) curve.p2 && curve.p3 ? ctx.bezierCurveTo(offsetX + curve.p1.x, offsetY + curve.p1.y, offsetX + curve.p2.x, offsetY + curve.p2.y, offsetX + curve.p3.x, offsetY + curve.p3.y, offsetZ) : ctx.lineTo(offsetX + curve.p1.x, offsetY + curve.p1.y, offsetZ);else if (curve.p2 && curve.p3) {
        const [curve1] = divideCubic(curve, endPercent);
        ctx.bezierCurveTo(offsetX + curve1.p1.x, offsetY + curve1.p1.y, offsetX + curve1.p2.x, offsetY + curve1.p2.y, offsetX + curve1.p3.x, offsetY + curve1.p3.y, offsetZ);
      } else {
        const p = curve.getPointAt(endPercent);
        ctx.lineTo(offsetX + p.x, offsetY + p.y, offsetZ);
      }
    }

    function drawEachCurve(path, curve, lastCurve, defined0, offsetX, offsetY, offsetZ) {
      var _a;
      let p0 = curve.p0,
        newDefined0 = defined0;
      if (lastCurve && lastCurve.originP1 === lastCurve.originP2 && (p0 = lastCurve.p0), curve.defined) defined0 || (path.lineTo(p0.x + offsetX, p0.y + offsetY, offsetZ), newDefined0 = !defined0);else {
        const {
          originP1: originP1,
          originP2: originP2
        } = curve;
        let validP;
        if (originP1 && !1 !== originP1.defined && !lastCurve ? validP = p0 : originP1 && !1 !== originP2.defined && (validP = null !== (_a = curve.p3) && void 0 !== _a ? _a : curve.p1), defined0) {
          newDefined0 = !defined0;
          const x = validP ? validP.x : curve.p0.x,
            y = validP ? validP.y : curve.p0.y;
          path.moveTo(x + offsetX, y + offsetY, offsetZ);
        } else validP && (newDefined0 = !defined0, path.lineTo(validP.x + offsetX, validP.y + offsetY, offsetZ));
      }
      return newDefined0;
    }
    function drawSegments(path, segPath, percent, clipRangeByDimension, params) {
      const {
        offsetX = 0,
        offsetY = 0,
        offsetZ = 0,
        mode = "none",
        drawConnect = !1
      } = params || {};
      if (drawConnect && "none" === mode) return;
      if (!segPath) return;
      let needMoveTo = !0;
      const {
        curves: curves
      } = segPath;
      if (percent >= 1) {
        if (drawConnect) {
          let lastCurve,
            defined0 = !0;
          curves.forEach((curve, i) => {
            curve.originP1 !== curve.originP2 ? (defined0 = drawEachCurve(path, curve, lastCurve, defined0, offsetX, offsetY, offsetZ), lastCurve = curve) : lastCurve = curve;
          });
        } else curves.forEach(curve => {
          curve.defined ? (needMoveTo && path.moveTo(curve.p0.x + offsetX, curve.p0.y + offsetY, offsetZ), drawSegItem(path, curve, 1, params), needMoveTo = !1) : needMoveTo = !0;
        });
        return;
      }
      if (percent <= 0) return;
      let direction;
      "x" === clipRangeByDimension ? direction = Direction$2.ROW : "y" === clipRangeByDimension ? direction = Direction$2.COLUMN : "auto" === clipRangeByDimension && (direction = segPath.direction);
      const totalDrawLength = percent * segPath.tryUpdateLength(direction);
      let drawedLengthUntilLast = 0,
        defined0 = !0,
        lastCurve = null;
      for (let i = 0, n = curves.length; i < n; i++) {
        const curve = curves[i],
          curCurveLength = curve.getLength(direction),
          _p = (totalDrawLength - drawedLengthUntilLast) / curCurveLength;
        if (drawedLengthUntilLast += curCurveLength, _p < 0) break;
        if (drawConnect) {
          if (curve.originP1 === curve.originP2) {
            lastCurve = curve;
            continue;
          }
          defined0 = drawEachCurve(path, curve, lastCurve, defined0, offsetX, offsetY, offsetZ), lastCurve = curve;
        } else {
          if (!curve.defined) {
            needMoveTo = !0;
            continue;
          }
          needMoveTo && path.moveTo(curve.p0.x + offsetX, curve.p0.y + offsetY, offsetZ), drawSegItem(path, curve, min(_p, 1), params), needMoveTo = !1;
        }
      }
    }
    function drawIncrementalSegments(path, lastSeg, segments, params) {
      const {
          offsetX = 0,
          offsetY = 0
        } = params || {},
        startP = lastSeg ? lastSeg.points[lastSeg.points.length - 1] : segments.points[0];
      path.moveTo(startP.x + offsetX, startP.y + offsetY), segments.points.forEach(p => {
        !1 !== p.defined ? path.lineTo(p.x + offsetX, p.y + offsetY) : path.moveTo(p.x + offsetX, p.y + offsetY);
      });
    }
    function drawIncrementalAreaSegments(path, lastSeg, segments, params) {
      const {
          offsetX = 0,
          offsetY = 0
        } = params || {},
        {
          points: points
        } = segments,
        definedPointsList = [];
      for (let i = 0; i < points.length; i++) !1 === points[i].defined && (i);
      definedPointsList.push(points), definedPointsList.forEach((points, i) => {
        var _a, _b, _c, _d;
        const startP = lastSeg && 0 === i ? lastSeg.points[lastSeg.points.length - 1] : points[0];
        path.moveTo(startP.x + offsetX, startP.y + offsetY), points.forEach(p => {
          !1 !== p.defined ? path.lineTo(p.x + offsetX, p.y + offsetY) : path.moveTo(p.x + offsetX, p.y + offsetY);
        });
        for (let i = points.length - 1; i >= 0; i--) {
          const p = points[i];
          path.lineTo(null !== (_a = p.x1) && void 0 !== _a ? _a : p.x, null !== (_b = p.y1) && void 0 !== _b ? _b : p.y);
        }
        path.lineTo(null !== (_c = startP.x1) && void 0 !== _c ? _c : startP.x, null !== (_d = startP.y1) && void 0 !== _d ? _d : startP.y), path.closePath();
      });
    }

    var __decorate$R = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let DefaultCanvasLineRender = class extends BaseRender {
      constructor() {
        super(...arguments), this.numberType = LINE_NUMBER_TYPE;
      }
      draw(line, renderService, drawContext, params) {
        const lineAttribute = getTheme(line, null == params ? void 0 : params.theme).line;
        this._draw(line, lineAttribute, !1, drawContext, params);
      }
      drawSegmentItem(context, cache, fill, stroke, fillOpacity, strokeOpacity, attribute, defaultAttribute, clipRange, clipRangeByDimension, offsetX, offsetY, line, fillCb, strokeCb) {
        var _a;
        if (!cache) return;
        context.beginPath();
        const z = null !== (_a = this.z) && void 0 !== _a ? _a : 0;
        drawSegments(context.camera ? context : context.nativeContext, cache, clipRange, clipRangeByDimension, {
          offsetX: offsetX,
          offsetY: offsetY,
          offsetZ: z
        }), line.cache && !isArray$9(line.cache) && line.cache.curves.every(c => c.defined) && line.attribute.curveType && line.attribute.curveType.includes("Closed") && context.closePath(), context.setShadowBlendStyle && context.setShadowBlendStyle(line, attribute, defaultAttribute);
        const {
          x: originX = 0,
          x: originY = 0
        } = attribute;
        return !1 !== fill && (fillCb ? fillCb(context, attribute, defaultAttribute) : fillOpacity && (context.setCommonStyle(line, attribute, originX - offsetX, originY - offsetY, defaultAttribute), context.fill())), !1 !== stroke && (strokeCb ? strokeCb(context, attribute, defaultAttribute) : strokeOpacity && (context.setStrokeStyle(line, attribute, originX - offsetX, originY - offsetY, defaultAttribute), context.stroke())), !1;
      }
      drawLinearLineHighPerformance(line, context, fill, stroke, fillOpacity, strokeOpacity, offsetX, offsetY, lineAttribute, drawContext, params, fillCb, strokeCb) {
        var _a;
        context.beginPath();
        const z = null !== (_a = this.z) && void 0 !== _a ? _a : 0,
          {
            points: points
          } = line.attribute,
          startP = points[0];
        context.moveTo(startP.x + offsetX, startP.y + offsetY, z);
        for (let i = 1; i < points.length; i++) {
          const p = points[i];
          context.lineTo(p.x + offsetX, p.y + offsetY, z);
        }
        context.setShadowBlendStyle && context.setShadowBlendStyle(line, line.attribute, lineAttribute);
        const {
          x: originX = 0,
          x: originY = 0
        } = line.attribute;
        !1 !== fill && (fillCb ? fillCb(context, line.attribute, lineAttribute) : fillOpacity && (context.setCommonStyle(line, line.attribute, originX - offsetX, originY - offsetY, lineAttribute), context.fill())), !1 !== stroke && (strokeCb ? strokeCb(context, line.attribute, lineAttribute) : strokeOpacity && (context.setStrokeStyle(line, line.attribute, originX - offsetX, originY - offsetY, lineAttribute), context.stroke()));
      }
      drawShape(line, context, x, y, drawContext, params, fillCb, strokeCb) {
        const lineAttribute = getTheme(line, null == params ? void 0 : params.theme).line,
          {
            fill = lineAttribute.fill,
            stroke = lineAttribute.stroke,
            fillOpacity = lineAttribute.fillOpacity,
            strokeOpacity = lineAttribute.strokeOpacity,
            segments: segments,
            points: points,
            closePath: closePath,
            curveTension = lineAttribute.curveTension,
            connectedType = lineAttribute.connectedType
          } = line.attribute;
        if (!this.valid(line, lineAttribute, fillCb, strokeCb)) return;
        let {
          curveType = lineAttribute.curveType
        } = line.attribute;
        closePath && "linear" === curveType && (curveType = "linearClosed");
        const {
          clipRange = lineAttribute.clipRange,
          clipRangeByDimension = lineAttribute.clipRangeByDimension
        } = line.attribute;
        if (1 === clipRange && !segments && !points.some(p => !1 === p.defined) && "linear" === curveType) return this.drawLinearLineHighPerformance(line, context, !!fill, !!stroke, fillOpacity, strokeOpacity, x, y, lineAttribute, drawContext, params, fillCb, strokeCb);
        function parsePoint(points, connectedType) {
          return "none" === connectedType ? points : points.filter(p => !1 !== p.defined);
        }
        if (line.shouldUpdateShape()) {
          const {
              points: points,
              segments: segments
            } = line.attribute,
            _points = points;
          if (segments && segments.length) {
            let startPoint, lastSeg;
            if (line.cache = segments.map((seg, index) => {
              if (seg.points.length <= 1 && 0 === index) return seg.points[0] && (lastSeg = {
                endX: seg.points[0].x,
                endY: seg.points[0].y,
                curves: [{
                  defined: !1 !== seg.points[0].defined
                }]
              }), null;
              1 === index ? startPoint = {
                x: lastSeg.endX,
                y: lastSeg.endY,
                defined: lastSeg.curves[lastSeg.curves.length - 1].defined
              } : index > 1 && (startPoint.x = lastSeg.endX, startPoint.y = lastSeg.endY, startPoint.defined = lastSeg.curves[lastSeg.curves.length - 1].defined);
              const data = calcLineCache(parsePoint(seg.points, connectedType), curveType, {
                startPoint: startPoint,
                curveTension: curveTension
              });
              return lastSeg = data, data;
            }).filter(item => !!item), "linearClosed" === curveType) {
              let startP;
              for (let i = 0; i < line.cache.length; i++) {
                const cacheItem = line.cache[i];
                for (let i = 0; i < cacheItem.curves.length; i++) if (cacheItem.curves[i].defined) {
                  startP = cacheItem.curves[i].p0;
                  break;
                }
                if (startP) break;
              }
              line.cache[line.cache.length - 1] && line.cache[line.cache.length - 1].lineTo(startP.x, startP.y, !0);
            }
          } else {
            if (!points || !points.length) return line.cache = null, void line.clearUpdateShapeTag();
            line.cache = calcLineCache(parsePoint(_points, connectedType), curveType, {
              curveTension: curveTension
            });
          }
          line.clearUpdateShapeTag();
        }
        if (Array.isArray(line.cache)) {
          const segments = line.attribute.segments.filter(item => item.points.length);
          if (1 === segments[0].points.length && segments.shift(), 1 === clipRange) {
            let skip = !1;
            line.cache.forEach((cache, index) => {
              skip || (skip = this.drawSegmentItem(context, cache, !!fill, !!stroke, fillOpacity, strokeOpacity, segments[index], [lineAttribute, line.attribute], clipRange, clipRangeByDimension, x, y, line, fillCb, strokeCb));
            });
          } else {
            const totalLength = line.cache.reduce((l, c) => l + c.getLength(), 0),
              totalDrawLength = clipRange * totalLength;
            let drawedLengthUntilLast = 0,
              skip = !1;
            line.cache.forEach((cache, index) => {
              if (skip) return;
              const curSegLength = cache.getLength(),
                _cr = (totalDrawLength - drawedLengthUntilLast) / curSegLength;
              drawedLengthUntilLast += curSegLength, _cr > 0 && (skip = this.drawSegmentItem(context, cache, !!fill, !!stroke, fillOpacity, strokeOpacity, segments[index], [lineAttribute, line.attribute], min(_cr, 1), clipRangeByDimension, x, y, line, fillCb, strokeCb));
            });
          }
        } else this.drawSegmentItem(context, line.cache, !!fill, !!stroke, fillOpacity, strokeOpacity, line.attribute, lineAttribute, clipRange, clipRangeByDimension, x, y, line, fillCb, strokeCb);
      }
    };
    DefaultCanvasLineRender = __decorate$R([injectable()], DefaultCanvasLineRender);

    function drawAreaSegments(path, segPath, percent, params) {
      var _a;
      const {
        top: top,
        bottom: bottom
      } = segPath;
      if (top.curves.length !== bottom.curves.length) return;
      if (percent >= 1) {
        const topList = [],
          bottomList = [];
        let lastDefined = !0;
        for (let i = 0, n = top.curves.length; i < n; i++) {
          const topCurve = top.curves[i];
          lastDefined !== topCurve.defined ? (lastDefined ? (drawAreaBlock(path, topList, bottomList, params), topList.length = 0, bottomList.length = 0) : (topList.push(topCurve), bottomList.push(bottom.curves[n - i - 1])), lastDefined = !lastDefined) : lastDefined && (topList.push(topCurve), bottomList.push(bottom.curves[n - i - 1]));
        }
        return void drawAreaBlock(path, topList, bottomList, params);
      }
      if (percent <= 0) return;
      let {
        direction: direction
      } = params || {};
      const {
          curves: topCurves
        } = top,
        endP = null !== (_a = topCurves[topCurves.length - 1].p3) && void 0 !== _a ? _a : topCurves[topCurves.length - 1].p1,
        xTotalLength = abs(endP.x - topCurves[0].p0.x),
        yTotalLength = abs(endP.y - topCurves[0].p0.y);
      direction = null != direction ? direction : xTotalLength > yTotalLength ? Direction$2.ROW : Direction$2.COLUMN, Number.isFinite(xTotalLength) || (direction = Direction$2.COLUMN), Number.isFinite(yTotalLength) || (direction = Direction$2.ROW);
      const totalDrawLength = percent * (direction === Direction$2.ROW ? xTotalLength : yTotalLength);
      let drawedLengthUntilLast = 0,
        lastDefined = !0;
      const topList = [],
        bottomList = [];
      for (let i = 0, n = top.curves.length; i < n; i++) {
        const topCurve = top.curves[i],
          curCurveLength = topCurve.getLength(direction),
          percent = (totalDrawLength - drawedLengthUntilLast) / curCurveLength;
        if (percent < 0) break;
        drawedLengthUntilLast += curCurveLength;
        let tc = null,
          bc = null;
        lastDefined !== topCurve.defined ? (lastDefined ? (drawAreaBlock(path, topList, bottomList, params), topList.length = 0, bottomList.length = 0) : (tc = topCurve, bc = bottom.curves[n - i - 1]), lastDefined = !lastDefined) : lastDefined && (tc = topCurve, bc = bottom.curves[n - i - 1]), tc && bc && (percent < 1 && (tc = tc.p2 && tc.p3 ? divideCubic(tc, percent)[0] : divideLinear(tc, percent)[0], bc = bc.p2 && bc.p3 ? divideCubic(bc, 1 - percent)[1] : divideLinear(bc, 1 - percent)[1]), tc.defined = lastDefined, bc.defined = lastDefined, topList.push(tc), bottomList.push(bc)), tc = null, bc = null;
      }
      drawAreaBlock(path, topList, bottomList, params);
    }
    function drawAreaBlock(path, topList, bottomList, params) {
      const {
        offsetX = 0,
        offsetY = 0,
        offsetZ = 0
      } = params || {};
      let needMoveTo = !0;
      topList.forEach(curve => {
        curve.defined ? (needMoveTo && path.moveTo(curve.p0.x + offsetX, curve.p0.y + offsetY, offsetZ), drawSegItem(path, curve, 1, params), needMoveTo = !1) : needMoveTo = !0;
      }), needMoveTo = !0;
      for (let i = bottomList.length - 1; i >= 0; i--) {
        const curve = bottomList[i];
        curve.defined ? (needMoveTo && path.lineTo(curve.p0.x + offsetX, curve.p0.y + offsetY, offsetZ), drawSegItem(path, curve, 1, params), needMoveTo = !1) : needMoveTo = !0;
      }
      path.closePath();
    }

    const defaultAreaTextureRenderContribution = new DefaultAreaTextureRenderContribution();
    const defaultAreaBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

    var __decorate$Q = undefined && undefined.__decorate || function (decorators, target, key, desc) {
        var d,
          c = arguments.length,
          r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      },
      __metadata$F = undefined && undefined.__metadata || function (k, v) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
      },
      __param$v = undefined && undefined.__param || function (paramIndex, decorator) {
        return function (target, key) {
          decorator(target, key, paramIndex);
        };
      };
    let DefaultCanvasAreaRender = class extends BaseRender {
      constructor(graphicRenderContributions) {
        super(), this.graphicRenderContributions = graphicRenderContributions, this.numberType = AREA_NUMBER_TYPE, this.builtinContributions = [defaultAreaTextureRenderContribution, defaultAreaBackgroundRenderContribution], this.init(graphicRenderContributions);
      }
      drawLinearAreaHighPerformance(area, context, fill, stroke, fillOpacity, strokeOpacity, offsetX, offsetY, areaAttribute, drawContext, params, fillCb, strokeCb) {
        var _a, _b, _c;
        const {
          points: points
        } = area.attribute;
        if (points.length < 2) return;
        context.beginPath();
        const z = null !== (_a = this.z) && void 0 !== _a ? _a : 0,
          startP = points[0];
        context.moveTo(startP.x + offsetX, startP.y + offsetY, z);
        for (let i = 1; i < points.length; i++) {
          const p = points[i];
          context.lineTo(p.x + offsetX, p.y + offsetY, z);
        }
        for (let i = points.length - 1; i >= 0; i--) {
          const p = points[i];
          context.lineTo((null !== (_b = p.x1) && void 0 !== _b ? _b : p.x) + offsetX, (null !== (_c = p.y1) && void 0 !== _c ? _c : p.y) + offsetY, z);
        }
        context.closePath(), context.setShadowBlendStyle && context.setShadowBlendStyle(area, area.attribute, areaAttribute), this.beforeRenderStep(area, context, offsetX, offsetY, !!fillOpacity, !1, fill, !1, areaAttribute, drawContext, fillCb, null, {
          attribute: area.attribute
        });
        const {
          x: originX = 0,
          x: originY = 0
        } = area.attribute;
        !1 !== fill && (fillCb ? fillCb(context, area.attribute, areaAttribute) : fillOpacity && (context.setCommonStyle(area, area.attribute, originX - offsetX, originY - offsetY, areaAttribute), context.fill())), this.afterRenderStep(area, context, offsetX, offsetY, !!fillOpacity, !1, fill, !1, areaAttribute, drawContext, fillCb, null, {
          attribute: area.attribute
        }), (() => {
          var _a, _b;
          if (stroke) {
            const {
              stroke = areaAttribute && areaAttribute.stroke
            } = area.attribute;
            if (isArray$9(stroke) && (stroke[0] || stroke[2]) && !1 === stroke[1]) if (context.beginPath(), stroke[0]) {
              context.moveTo(startP.x + offsetX, startP.y + offsetY, z);
              for (let i = 1; i < points.length; i++) {
                const p = points[i];
                context.lineTo(p.x + offsetX, p.y + offsetY, z);
              }
            } else if (stroke[2]) {
              const endP = points[points.length - 1];
              context.moveTo(endP.x + offsetX, endP.y + offsetY, z);
              for (let i = points.length - 2; i >= 0; i--) {
                const p = points[i];
                context.lineTo((null !== (_a = p.x1) && void 0 !== _a ? _a : p.x) + offsetX, (null !== (_b = p.y1) && void 0 !== _b ? _b : p.y) + offsetY, z);
              }
            }
            strokeCb ? strokeCb(context, area.attribute, areaAttribute) : (context.setStrokeStyle(area, area.attribute, originX - offsetX, originY - offsetY, areaAttribute), context.stroke());
          }
        })();
      }
      drawShape(area, context, x, y, drawContext, params, fillCb, strokeCb) {
        var _a, _b, _c, _d, _e, _f;
        const areaAttribute = getTheme(area, null == params ? void 0 : params.theme).area,
          {
            fill = areaAttribute.fill,
            stroke = areaAttribute.stroke,
            fillOpacity = areaAttribute.fillOpacity,
            z = areaAttribute.z,
            strokeOpacity = areaAttribute.strokeOpacity,
            curveTension = areaAttribute.curveTension,
            connectedType = areaAttribute.connectedType
          } = area.attribute,
          data = this.valid(area, areaAttribute, fillCb, strokeCb);
        if (!data) return;
        const {
            doFill: doFill
          } = data,
          doStroke = data.doStroke && data.sVisible,
          {
            clipRange = areaAttribute.clipRange,
            closePath: closePath,
            points: points,
            segments: segments
          } = area.attribute;
        let {
          curveType = areaAttribute.curveType
        } = area.attribute;
        function parsePoint(points, connectedType) {
          return "connect" !== connectedType ? points : points.filter(p => !1 !== p.defined);
        }
        if (closePath && "linear" === curveType && (curveType = "linearClosed"), 1 === clipRange && !segments && !points.some(p => !1 === p.defined) && "linear" === curveType) return this.drawLinearAreaHighPerformance(area, context, !!fill, doStroke, fillOpacity, strokeOpacity, x, y, areaAttribute, drawContext, params, fillCb, strokeCb);
        if (area.shouldUpdateShape()) {
          if (segments && segments.length) {
            let startPoint, lastTopSeg;
            const topCaches = segments.map((seg, index) => {
              if (seg.points.length <= 1 && 0 === index) return seg.points[0] && (lastTopSeg = {
                endX: seg.points[0].x,
                endY: seg.points[0].y
              }), null;
              1 === index ? startPoint = {
                x: lastTopSeg.endX,
                y: lastTopSeg.endY
              } : index > 1 && (startPoint.x = lastTopSeg.endX, startPoint.y = lastTopSeg.endY);
              const data = calcLineCache(parsePoint(seg.points, connectedType), curveType, {
                startPoint: startPoint,
                curveTension: curveTension
              });
              return lastTopSeg = data, data;
            }).filter(item => !!item);
            let lastBottomSeg;
            const bottomCaches = [];
            for (let i = segments.length - 1; i >= 0; i--) {
              const points = segments[i].points,
                bottomPoints = [];
              for (let i = points.length - 1; i >= 0; i--) bottomPoints.push({
                x: null !== (_a = points[i].x1) && void 0 !== _a ? _a : points[i].x,
                y: null !== (_b = points[i].y1) && void 0 !== _b ? _b : points[i].y
              });
              if (0 !== i) {
                const lastSegmentPoints = segments[i - 1].points,
                  endPoint = lastSegmentPoints[lastSegmentPoints.length - 1];
                endPoint && bottomPoints.push({
                  x: null !== (_c = endPoint.x1) && void 0 !== _c ? _c : endPoint.x,
                  y: null !== (_d = endPoint.y1) && void 0 !== _d ? _d : endPoint.y
                });
              }
              bottomPoints.length > 1 && (lastBottomSeg = calcLineCache(parsePoint(bottomPoints, connectedType), "stepBefore" === curveType ? "stepAfter" : "stepAfter" === curveType ? "stepBefore" : curveType, {
                curveTension: curveTension
              }), bottomCaches.unshift(lastBottomSeg));
            }
            area.cacheArea = bottomCaches.map((item, index) => ({
              top: topCaches[index],
              bottom: item
            }));
          } else {
            if (!points || !points.length) return area.cacheArea = null, void area.clearUpdateShapeTag();
            {
              const topPoints = parsePoint(points, connectedType),
                bottomPoints = [];
              for (let i = topPoints.length - 1; i >= 0; i--) bottomPoints.push({
                x: null !== (_e = topPoints[i].x1) && void 0 !== _e ? _e : topPoints[i].x,
                y: null !== (_f = topPoints[i].y1) && void 0 !== _f ? _f : topPoints[i].y
              });
              const topCache = calcLineCache(topPoints, curveType, {
                  curveTension: curveTension
                }),
                bottomCache = calcLineCache(bottomPoints, "stepBefore" === curveType ? "stepAfter" : "stepAfter" === curveType ? "stepBefore" : curveType, {
                  curveTension: curveTension
                });
              area.cacheArea = {
                top: topCache,
                bottom: bottomCache
              };
            }
          }
          area.clearUpdateShapeTag();
        }
        if (Array.isArray(area.cacheArea)) {
          const segments = area.attribute.segments.filter(item => item.points.length);
          if (1 === segments[0].points.length && segments.shift(), 1 === clipRange) {
            let skip = !1;
            area.cacheArea.forEach((cache, index) => {
              skip || (skip = this.drawSegmentItem(context, cache, doFill, fillOpacity, doStroke, strokeOpacity, segments[index], [areaAttribute, area.attribute], clipRange, x, y, z, area, drawContext, fillCb, strokeCb));
            });
          } else {
            const totalLength = area.cacheArea.reduce((l, c) => l + c.top.getLength(), 0),
              totalDrawLength = clipRange * totalLength;
            let drawedLengthUntilLast = 0,
              skip = !1;
            area.cacheArea.forEach((cache, index) => {
              if (skip) return;
              const curSegLength = cache.top.getLength(),
                _cr = (totalDrawLength - drawedLengthUntilLast) / curSegLength;
              drawedLengthUntilLast += curSegLength, _cr > 0 && (skip = this.drawSegmentItem(context, cache, doFill, fillOpacity, doStroke, strokeOpacity, segments[index], [areaAttribute, area.attribute], min(_cr, 1), x, y, z, area, drawContext, fillCb, strokeCb));
            });
          }
        } else this.drawSegmentItem(context, area.cacheArea, doFill, fillOpacity, doStroke, strokeOpacity, area.attribute, areaAttribute, clipRange, x, y, z, area, drawContext, fillCb, strokeCb);
      }
      draw(area, renderService, drawContext, params) {
        const areaAttribute = getTheme(area, null == params ? void 0 : params.theme).area;
        this._draw(area, areaAttribute, !1, drawContext, params);
      }
      drawSegmentItem(context, cache, fill, fillOpacity, stroke, strokeOpacity, attribute, defaultAttribute, clipRange, offsetX, offsetY, offsetZ, area, drawContext, fillCb, strokeCb) {
        return this._drawSegmentItem(context, cache, fill, fillOpacity, stroke, strokeOpacity, attribute, defaultAttribute, clipRange, offsetX, offsetY, offsetZ, area, drawContext, fillCb, strokeCb);
      }
      _drawSegmentItem(context, cache, fill, fillOpacity, stroke, strokeOpacity, attribute, defaultAttribute, clipRange, offsetX, offsetY, offsetZ, area, drawContext, fillCb, strokeCb) {
        if (!(cache && cache.top && cache.bottom && cache.top.curves && cache.top.curves.length && cache.bottom.curves && cache.bottom.curves.length)) return;
        context.beginPath();
        const {
          points: points,
          segments: segments
        } = area.attribute;
        let endP,
          startP,
          direction = Direction$2.ROW;
        if (segments) {
          const endSeg = segments[segments.length - 1];
          startP = segments[0].points[0], endP = endSeg.points[endSeg.points.length - 1];
        } else startP = points[0], endP = points[points.length - 1];
        const xTotalLength = abs(endP.x - startP.x),
          yTotalLength = abs(endP.y - startP.y);
        direction = null == endP.x1 ? Direction$2.ROW : null == endP.y1 ? Direction$2.COLUMN : Number.isFinite(xTotalLength + yTotalLength) ? xTotalLength > yTotalLength ? Direction$2.ROW : Direction$2.COLUMN : Direction$2.ROW, drawAreaSegments(context.camera ? context : context.nativeContext, cache, clipRange, {
          offsetX: offsetX,
          offsetY: offsetY,
          offsetZ: offsetZ,
          direction: direction
        }), this.beforeRenderStep(area, context, offsetX, offsetY, !!fillOpacity, !1, fill, !1, defaultAttribute, drawContext, fillCb, null, {
          attribute: attribute
        }), context.setShadowBlendStyle && context.setShadowBlendStyle(area, attribute, defaultAttribute);
        const {
          x: originX = 0,
          x: originY = 0
        } = attribute;
        return !1 !== fill && (fillCb ? fillCb(context, attribute, defaultAttribute) : fillOpacity && (context.setCommonStyle(area, attribute, originX - offsetX, originY - offsetY, defaultAttribute), context.fill())), this.afterRenderStep(area, context, offsetX, offsetY, !!fillOpacity, !1, fill, !1, defaultAttribute, drawContext, fillCb, null, {
          attribute: attribute
        }), (() => {
          if (!1 !== stroke) if (strokeCb) strokeCb(context, attribute, defaultAttribute);else {
            const {
              stroke = defaultAttribute && defaultAttribute[1] && defaultAttribute[1].stroke
            } = attribute;
            isArray$9(stroke) && (stroke[0] || stroke[2]) && !1 === stroke[1] && (context.beginPath(), drawSegments(context.camera ? context : context.nativeContext, stroke[0] ? cache.top : cache.bottom, clipRange, direction === Direction$2.ROW ? "x" : "y", {
              offsetX: offsetX,
              offsetY: offsetY,
              offsetZ: offsetZ
            })), context.setStrokeStyle(area, attribute, originX - offsetX, originY - offsetY, defaultAttribute), context.stroke();
          }
        })(), !1;
      }
    };
    DefaultCanvasAreaRender = __decorate$Q([injectable(), __param$v(0, inject(ContributionProvider)), __param$v(0, named(AreaRenderContribution)), __metadata$F("design:paramtypes", [Object])], DefaultCanvasAreaRender);

    const defaultPathTextureRenderContribution = defaultBaseTextureRenderContribution;
    const defaultPathBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

    var __decorate$P = undefined && undefined.__decorate || function (decorators, target, key, desc) {
        var d,
          c = arguments.length,
          r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      },
      __metadata$E = undefined && undefined.__metadata || function (k, v) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
      },
      __param$u = undefined && undefined.__param || function (paramIndex, decorator) {
        return function (target, key) {
          decorator(target, key, paramIndex);
        };
      };
    let DefaultCanvasPathRender = class extends BaseRender {
      constructor(graphicRenderContributions) {
        super(), this.graphicRenderContributions = graphicRenderContributions, this.numberType = PATH_NUMBER_TYPE, this.builtinContributions = [defaultPathBackgroundRenderContribution, defaultPathTextureRenderContribution], this.init(graphicRenderContributions);
      }
      drawShape(path, context, x, y, drawContext, params, fillCb, strokeCb) {
        var _a, _b, _c;
        const pathAttribute = null !== (_a = this.tempTheme) && void 0 !== _a ? _a : getTheme(path, null == params ? void 0 : params.theme).path,
          {
            x: originX = pathAttribute.x,
            y: originY = pathAttribute.y,
            fillStrokeOrder = pathAttribute.fillStrokeOrder
          } = path.attribute,
          z = null !== (_b = this.z) && void 0 !== _b ? _b : 0,
          data = this.valid(path, pathAttribute, fillCb, strokeCb);
        if (!data) return;
        const {
          fVisible: fVisible,
          sVisible: sVisible,
          doFill: doFill,
          doStroke: doStroke
        } = data;
        if (context.beginPath(), path.pathShape) renderCommandList(path.pathShape.commandList, context, x, y, 1, 1, z);else {
          const path2D = null !== (_c = path.attribute.path) && void 0 !== _c ? _c : pathAttribute.path;
          renderCommandList(path2D.commandList, context, x, y, 1, 1, z);
        }
        context.setShadowBlendStyle && context.setShadowBlendStyle(path, path.attribute, pathAttribute), this.beforeRenderStep(path, context, x, y, doFill, doStroke, fVisible, sVisible, pathAttribute, drawContext, fillCb, strokeCb);
        const _runStroke = () => {
            doStroke && (strokeCb ? strokeCb(context, path.attribute, pathAttribute) : sVisible && (context.setStrokeStyle(path, path.attribute, originX - x, originY - y, pathAttribute), context.stroke()));
          },
          _runFill = () => {
            doFill && (fillCb ? fillCb(context, path.attribute, pathAttribute) : fVisible && (context.setCommonStyle(path, path.attribute, originX - x, originY - y, pathAttribute), context.fill()));
          };
        fillStrokeOrder ? (_runStroke(), _runFill()) : (_runFill(), _runStroke()), this.afterRenderStep(path, context, x, y, doFill, doStroke, fVisible, sVisible, pathAttribute, drawContext, fillCb, strokeCb);
      }
      draw(path, renderService, drawContext, params) {
        const pathAttribute = getTheme(path, null == params ? void 0 : params.theme).path;
        this.tempTheme = pathAttribute, this._draw(path, pathAttribute, !1, drawContext, params), this.tempTheme = null;
      }
    };
    DefaultCanvasPathRender = __decorate$P([injectable(), __param$u(0, inject(ContributionProvider)), __param$u(0, named(PathRenderContribution)), __metadata$E("design:paramtypes", [Object])], DefaultCanvasPathRender);

    var __decorate$O = undefined && undefined.__decorate || function (decorators, target, key, desc) {
        var d,
          c = arguments.length,
          r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      },
      __metadata$D = undefined && undefined.__metadata || function (k, v) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
      },
      __param$t = undefined && undefined.__param || function (paramIndex, decorator) {
        return function (target, key) {
          decorator(target, key, paramIndex);
        };
      };
    let DefaultCanvasRectRender = class extends BaseRender {
      constructor(graphicRenderContributions) {
        super(), this.graphicRenderContributions = graphicRenderContributions, this.type = "rect", this.numberType = RECT_NUMBER_TYPE, this.builtinContributions = [defaultRectRenderContribution, defaultRectBackgroundRenderContribution, defaultRectTextureRenderContribution], this.init(graphicRenderContributions);
      }
      drawShape(rect, context, x, y, drawContext, params, fillCb, strokeCb) {
        var _a;
        const rectAttribute = null !== (_a = this.tempTheme) && void 0 !== _a ? _a : getTheme(rect, null == params ? void 0 : params.theme).rect,
          {
            fill = rectAttribute.fill,
            background: background,
            stroke = rectAttribute.stroke,
            cornerRadius = rectAttribute.cornerRadius,
            cornerType = rectAttribute.cornerType,
            opacity = rectAttribute.opacity,
            fillOpacity = rectAttribute.fillOpacity,
            lineWidth = rectAttribute.lineWidth,
            strokeOpacity = rectAttribute.strokeOpacity,
            visible = rectAttribute.visible,
            x1: x1,
            y1: y1,
            x: originX = rectAttribute.x,
            y: originY = rectAttribute.y,
            fillStrokeOrder = rectAttribute.fillStrokeOrder
          } = rect.attribute;
        let {
          width: width,
          height: height
        } = rect.attribute;
        width = (null != width ? width : x1 - originX) || 0, height = (null != height ? height : y1 - originY) || 0;
        const fVisible = rectFillVisible(opacity, fillOpacity, width, height, fill),
          sVisible = rectStrokeVisible(opacity, strokeOpacity, width, height),
          doFill = runFill(fill, background),
          doStroke = runStroke(stroke, lineWidth);
        if (!rect.valid || !visible) return;
        if (!doFill && !doStroke) return;
        if (!(fVisible || sVisible || fillCb || strokeCb || background)) return;
        0 === cornerRadius || isArray$9(cornerRadius) && cornerRadius.every(num => 0 === num) ? (context.beginPath(), context.rect(x, y, width, height)) : (context.beginPath(), createRectPath(context, x, y, width, height, cornerRadius, "bevel" !== cornerType));
        const doFillOrStroke = {
          doFill: doFill,
          doStroke: doStroke
        };
        context.setShadowBlendStyle && context.setShadowBlendStyle(rect, rect.attribute, rectAttribute), this.beforeRenderStep(rect, context, x, y, doFill, doStroke, fVisible, sVisible, rectAttribute, drawContext, fillCb, strokeCb, doFillOrStroke);
        const _runFill = () => {
            doFillOrStroke.doFill && (fillCb ? fillCb(context, rect.attribute, rectAttribute) : fVisible && (context.setCommonStyle(rect, rect.attribute, originX - x, originY - y, rectAttribute), context.fill()));
          },
          _runStroke = () => {
            doFillOrStroke.doStroke && (strokeCb ? strokeCb(context, rect.attribute, rectAttribute) : sVisible && (context.setStrokeStyle(rect, rect.attribute, originX - x, originY - y, rectAttribute), context.stroke()));
          };
        fillStrokeOrder ? (_runStroke(), _runFill()) : (_runFill(), _runStroke()), this.afterRenderStep(rect, context, x, y, doFill, doStroke, fVisible, sVisible, rectAttribute, drawContext, fillCb, strokeCb);
      }
      draw(rect, renderService, drawContext, params) {
        const rectAttribute = getTheme(rect, null == params ? void 0 : params.theme).rect;
        this.tempTheme = rectAttribute, this._draw(rect, rectAttribute, !1, drawContext, params), this.tempTheme = null;
      }
    };
    DefaultCanvasRectRender = __decorate$O([injectable(), __param$t(0, inject(ContributionProvider)), __param$t(0, named(RectRenderContribution)), __metadata$D("design:paramtypes", [Object])], DefaultCanvasRectRender);

    var __decorate$N = undefined && undefined.__decorate || function (decorators, target, key, desc) {
        var d,
          c = arguments.length,
          r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      },
      __metadata$C = undefined && undefined.__metadata || function (k, v) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
      },
      __param$s = undefined && undefined.__param || function (paramIndex, decorator) {
        return function (target, key) {
          decorator(target, key, paramIndex);
        };
      };
    let DefaultCanvasSymbolRender = class extends BaseRender {
      constructor(graphicRenderContributions) {
        super(), this.graphicRenderContributions = graphicRenderContributions, this.numberType = SYMBOL_NUMBER_TYPE, this.builtinContributions = [defaultSymbolRenderContribution, defaultSymbolBackgroundRenderContribution, defaultSymbolTextureRenderContribution, defaultSymbolClipRangeStrokeRenderContribution], this.init(graphicRenderContributions);
      }
      drawShape(symbol, context, x, y, drawContext, params, fillCb, strokeCb) {
        var _a;
        const symbolAttribute = getTheme(symbol, null == params ? void 0 : params.theme).symbol,
          {
            size = symbolAttribute.size,
            x: originX = symbolAttribute.x,
            y: originY = symbolAttribute.y,
            scaleX = symbolAttribute.scaleX,
            scaleY = symbolAttribute.scaleY,
            fillStrokeOrder = symbolAttribute.fillStrokeOrder,
            clipRange = symbolAttribute.clipRange
          } = symbol.attribute,
          data = this.valid(symbol, symbolAttribute, fillCb, strokeCb);
        if (!data) return;
        const {
            fVisible: fVisible,
            sVisible: sVisible,
            doFill: doFill,
            doStroke: doStroke
          } = data,
          parsedPath = symbol.getParsedPath();
        if (!parsedPath) return;
        const {
            keepDirIn3d = symbolAttribute.keepDirIn3d
          } = symbol.attribute,
          z = null !== (_a = this.z) && void 0 !== _a ? _a : 0;
        context.beginPath();
        let _x = x,
          _y = y,
          _z = z;
        const camera = context.camera;
        if (keepDirIn3d && camera && context.project) {
          const p = context.project(x, y, z);
          context.camera = null, isArray$9(size) ? [size[0] * scaleX, size[1] * scaleY] : size * scaleX, _x = p.x, _y = p.y, _z = void 0;
        }
        !1 === parsedPath.draw(context, size, _x, _y, _z, (p, a) => {
          var _a, _b, _c, _d;
          if (symbol._parsedPath.svgCache) {
            const obj = Object.assign({}, a);
            obj.fill = null !== (_a = a.fill) && void 0 !== _a ? _a : symbol.attribute.fill, obj.opacity = null !== (_b = a.opacity) && void 0 !== _b ? _b : symbol.attribute.opacity, obj.fillOpacity = symbol.attribute.fillOpacity, obj.stroke = null !== (_c = a.stroke) && void 0 !== _c ? _c : symbol.attribute.stroke, obj.lineWidth = null !== (_d = a.lineWidth) && void 0 !== _d ? _d : symbol.attribute.lineWidth, a = obj;
          }
          const _runFill = () => {
              a.fill && (fillCb ? fillCb(context, symbol.attribute, symbolAttribute) : (context.setCommonStyle(symbol, a, originX - x, originY - y, symbolAttribute), context.fill()));
            },
            _runStroke = () => {
              a.stroke && (strokeCb ? strokeCb(context, symbol.attribute, symbolAttribute) : sVisible && clipRange >= 1 && (context.setStrokeStyle(symbol, a, (originX - x) / scaleX, (originY - y) / scaleY, symbolAttribute), context.stroke()));
            };
          fillStrokeOrder ? (_runStroke(), _runFill()) : (_runFill(), _runStroke());
        }) && context.closePath(), context.camera = camera, context.setShadowBlendStyle && context.setShadowBlendStyle(symbol, symbol.attribute, symbolAttribute), this.beforeRenderStep(symbol, context, x, y, doFill, doStroke, fVisible, sVisible, symbolAttribute, drawContext, fillCb, strokeCb);
        const _runFill = () => {
            doFill && !parsedPath.isSvg && (fillCb ? fillCb(context, symbol.attribute, symbolAttribute) : fVisible && (context.setCommonStyle(symbol, symbol.attribute, originX - x, originY - y, symbolAttribute), context.fill()));
          },
          _runStroke = () => {
            doStroke && !parsedPath.isSvg && (strokeCb ? strokeCb(context, symbol.attribute, symbolAttribute) : sVisible && clipRange >= 1 && (context.setStrokeStyle(symbol, symbol.attribute, (originX - x) / scaleX, (originY - y) / scaleY, symbolAttribute), context.stroke()));
          };
        fillStrokeOrder ? (_runStroke(), _runFill()) : (_runFill(), _runStroke()), this.afterRenderStep(symbol, context, x, y, doFill, doStroke, fVisible, sVisible, symbolAttribute, drawContext, fillCb, strokeCb);
      }
      draw(symbol, renderService, drawContext, params) {
        const symbolAttribute = getTheme(symbol, null == params ? void 0 : params.theme).symbol;
        this._draw(symbol, symbolAttribute, !1, drawContext, params);
      }
    };
    DefaultCanvasSymbolRender = __decorate$N([injectable(), __param$s(0, inject(ContributionProvider)), __param$s(0, named(SymbolRenderContribution)), __metadata$C("design:paramtypes", [Object])], DefaultCanvasSymbolRender);

    class DefaultBoundsAllocate {
      constructor() {
        this.pools = [];
        for (let i = 0; i < 10; i++) this.pools.push(new AABBBounds$1());
      }
      allocate(x1, y1, x2, y2) {
        if (!this.pools.length) return new AABBBounds$1().setValue(x1, y1, x2, y2);
        const b = this.pools.pop();
        return b.x1 = x1, b.y1 = y1, b.x2 = x2, b.y2 = y2, b;
      }
      allocateByObj(b) {
        if (!this.pools.length) return new AABBBounds$1(b);
        const _b = this.pools.pop();
        return _b.x1 = b.x1, _b.y1 = b.y1, _b.x2 = b.x2, _b.y2 = b.y2, _b;
      }
      free(b) {
        this.pools.push(b);
      }
      get length() {
        return this.pools.length;
      }
      release() {
        this.pools = [];
      }
    }
    const boundsAllocate = new DefaultBoundsAllocate();

    class DefaultTextBackgroundRenderContribution extends DefaultBaseBackgroundRenderContribution {
      constructor() {
        super(...arguments), this.time = BaseRenderContributionTime.beforeFillStroke;
      }
      drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb) {
        var _a, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        const {
          backgroundMode = graphicAttribute.backgroundMode,
          backgroundFit = graphicAttribute.backgroundFit,
          backgroundKeepAspectRatio = graphicAttribute.backgroundKeepAspectRatio
        } = graphic.attribute;
        let matrix,
          {
            background: background
          } = graphic.attribute;
        if (!background) return;
        const restore = () => {
          "richtext" === graphic.type && (context.restore(), context.save(), matrix && context.setTransformFromMatrix(matrix, !0, 1));
        };
        let b;
        "richtext" === graphic.type && (matrix = context.currentMatrix.clone(), context.restore(), context.save(), context.setTransformForCurrent());
        const shouldReCalBounds = isObject$9(background) && background.background,
          onlyTranslate = graphic.transMatrix.onlyTranslate();
        if (shouldReCalBounds) {
          const _b = graphic.AABBBounds,
            x = (null !== (_a = background.x) && void 0 !== _a ? _a : _b.x1) + (null !== (_c = background.dx) && void 0 !== _c ? _c : 0),
            y = (null !== (_d = background.y) && void 0 !== _d ? _d : _b.y1) + (null !== (_e = background.dy) && void 0 !== _e ? _e : 0),
            w = null !== (_f = background.width) && void 0 !== _f ? _f : _b.width(),
            h = null !== (_g = background.height) && void 0 !== _g ? _g : _b.height();
          if (b = boundsAllocate.allocate(x, y, x + w, y + h), background = background.background, !onlyTranslate) {
            const w = b.width(),
              h = b.height();
            b.set((null !== (_h = background.x) && void 0 !== _h ? _h : 0) + (null !== (_j = background.dx) && void 0 !== _j ? _j : 0), (null !== (_k = background.y) && void 0 !== _k ? _k : 0) + (null !== (_l = background.dy) && void 0 !== _l ? _l : 0), w, h);
          }
        } else b = graphic.AABBBounds, onlyTranslate || (b = getTextBounds(Object.assign(Object.assign({}, graphic.attribute), {
          angle: 0,
          scaleX: 1,
          scaleY: 1,
          x: 0,
          y: 0,
          dx: 0,
          dy: 0
        })).clone());
        if (graphic.backgroundImg && graphic.resources) {
          const res = graphic.resources.get(background);
          if ("success" !== res.state || !res.data) return void restore();
          context.highPerformanceSave(), onlyTranslate && context.setTransformFromMatrix(graphic.parent.globalTransMatrix, !0), context.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute), this.doDrawImage(context, res.data, b, {
            backgroundMode: backgroundMode,
            backgroundFit: backgroundFit,
            backgroundKeepAspectRatio: backgroundKeepAspectRatio
          }), context.highPerformanceRestore(), context.setTransformForCurrent();
        } else {
          const {
            backgroundCornerRadius: backgroundCornerRadius
          } = graphic.attribute;
          context.highPerformanceSave(), context.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute), context.fillStyle = background, backgroundCornerRadius ? (createRectPath(context, b.x1, b.y1, b.width(), b.height(), backgroundCornerRadius, !0), context.fill()) : context.fillRect(b.x1, b.y1, b.width(), b.height()), context.highPerformanceRestore();
        }
        shouldReCalBounds && boundsAllocate.free(b), restore();
      }
    }
    const defaultTextBackgroundRenderContribution = new DefaultTextBackgroundRenderContribution();

    var __decorate$M = undefined && undefined.__decorate || function (decorators, target, key, desc) {
        var d,
          c = arguments.length,
          r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      },
      __metadata$B = undefined && undefined.__metadata || function (k, v) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
      },
      __param$r = undefined && undefined.__param || function (paramIndex, decorator) {
        return function (target, key) {
          decorator(target, key, paramIndex);
        };
      };
    let DefaultCanvasTextRender = class extends BaseRender {
      constructor(graphicRenderContributions) {
        super(), this.graphicRenderContributions = graphicRenderContributions, this.numberType = TEXT_NUMBER_TYPE, this.builtinContributions = [defaultTextBackgroundRenderContribution], this.init(graphicRenderContributions);
      }
      drawShape(text, context, x, y, drawContext, params, fillCb, strokeCb) {
        var _a, _b, _c;
        const textAttribute = getTheme(text, null == params ? void 0 : params.theme).text,
          {
            text: str,
            underline = textAttribute.underline,
            lineThrough = textAttribute.lineThrough,
            keepDirIn3d = textAttribute.keepDirIn3d,
            direction = textAttribute.direction,
            fontSize = textAttribute.fontSize,
            verticalMode = textAttribute.verticalMode,
            x: originX = textAttribute.x,
            y: originY = textAttribute.y
          } = text.attribute,
          lineHeight = null !== (_a = calculateLineHeight(text.attribute.lineHeight, fontSize)) && void 0 !== _a ? _a : fontSize,
          data = this.valid(text, textAttribute, fillCb, strokeCb);
        if (!data) return;
        const {
            fVisible: fVisible,
            sVisible: sVisible,
            doFill: doFill,
            doStroke: doStroke
          } = data,
          transform3dMatrixToContextMatrix = !keepDirIn3d,
          z = this.z || 0;
        context.beginPath(), context.setShadowBlendStyle && context.setShadowBlendStyle(text, text.attribute, textAttribute), this.beforeRenderStep(text, context, x, y, doFill, doStroke, fVisible, sVisible, textAttribute, drawContext, fillCb, strokeCb), transform3dMatrixToContextMatrix && this.transformUseContext2d(text, textAttribute, z, context);
        const drawText = (t, offsetX, offsetY, direction) => {
          let _x = x + offsetX;
          const _y = y + offsetY;
          if (direction) {
            context.highPerformanceSave(), _x += fontSize;
            const matrix = matrixAllocate.allocate(1, 0, 0, 1, 0, 0);
            matrix.rotateByCenter(Math.PI / 2, _x, _y), context.transformFromMatrix(matrix, !0), matrixAllocate.free(matrix);
          }
          doStroke && (strokeCb ? strokeCb(context, text.attribute, textAttribute) : sVisible && (context.setStrokeStyle(text, text.attribute, originX - x, originY - y, textAttribute), context.strokeText(t, _x, _y, z))), doFill && (fillCb ? fillCb(context, text.attribute, textAttribute) : fVisible && (context.setCommonStyle(text, text.attribute, originX - x, originY - y, textAttribute), context.fillText(t, _x, _y, z))), direction && (context.highPerformanceRestore(), context.setTransformForCurrent());
        };
        if (context.setTextStyleWithoutAlignBaseline(text.attribute, textAttribute, z), "horizontal" === direction) {
          const {
            multilineLayout: multilineLayout
          } = text;
          if (!multilineLayout) return void context.highPerformanceRestore();
          const {
            xOffset: xOffset,
            yOffset: yOffset
          } = multilineLayout.bbox;
          doStroke && (strokeCb ? strokeCb(context, text.attribute, textAttribute) : sVisible && (context.setStrokeStyle(text, text.attribute, originX - x, originY - y, textAttribute), multilineLayout.lines.forEach(line => {
            context.strokeText(line.str, (line.leftOffset || 0) + xOffset + x, (line.topOffset || 0) + yOffset + y, z);
          }))), doFill && (fillCb ? fillCb(context, text.attribute, textAttribute) : fVisible && (context.setCommonStyle(text, text.attribute, originX - x, originY - y, textAttribute), multilineLayout.lines.forEach(line => {
            context.fillText(line.str, (line.leftOffset || 0) + xOffset + x, (line.topOffset || 0) + yOffset + y, z), this.drawUnderLine(underline, lineThrough, text, (line.leftOffset || 0) + xOffset + x, (line.topOffset || 0) + yOffset + y, line.descent, (line.descent - line.ascent) / 2, z, textAttribute, context, {
              width: line.width
            });
          })));
        } else {
          let {
            textAlign = textAttribute.textAlign,
            textBaseline = textAttribute.textBaseline
          } = text.attribute;
          if (!verticalMode) {
            const t = textAlign;
            textAlign = null !== (_b = text.getBaselineMapAlign()[textBaseline]) && void 0 !== _b ? _b : "left", textBaseline = null !== (_c = text.getAlignMapBaseline()[t]) && void 0 !== _c ? _c : "top";
          }
          text.tryUpdateAABBBounds();
          const cache = text.cache,
            {
              verticalList: verticalList
            } = cache;
          context.textAlign = "left", context.textBaseline = "top";
          const totalHeight = lineHeight * verticalList.length;
          let totalW = 0;
          verticalList.forEach(verticalData => {
            const _w = verticalData.reduce((a, b) => a + (b.width || 0), 0);
            totalW = max(_w, totalW);
          });
          let offsetY = 0,
            offsetX = 0;
          "bottom" === textBaseline ? offsetX = -totalHeight : "middle" === textBaseline && (offsetX = -totalHeight / 2), "center" === textAlign ? offsetY -= totalW / 2 : "right" === textAlign && (offsetY -= totalW), verticalList.forEach((verticalData, i) => {
            const currentW = verticalData.reduce((a, b) => a + (b.width || 0), 0),
              dw = totalW - currentW;
            let currentOffsetY = offsetY;
            "center" === textAlign ? currentOffsetY += dw / 2 : "right" === textAlign && (currentOffsetY += dw), verticalData.forEach(item => {
              const {
                text: text,
                width: width,
                direction: direction
              } = item;
              drawText(text, totalHeight - (i + 1) * lineHeight + offsetX, currentOffsetY, direction), currentOffsetY += width;
            });
          });
        }
        transform3dMatrixToContextMatrix && this.restoreTransformUseContext2d(text, textAttribute, z, context), this.afterRenderStep(text, context, x, y, doFill, doStroke, fVisible, sVisible, textAttribute, drawContext, fillCb, strokeCb);
      }
      draw(text, renderService, drawContext, params) {
        const textAttribute = getTheme(text, null == params ? void 0 : params.theme).text,
          {
            keepDirIn3d = textAttribute.keepDirIn3d
          } = text.attribute,
          computed3dMatrix = !keepDirIn3d;
        this._draw(text, textAttribute, computed3dMatrix, drawContext, params);
      }
      drawUnderLine(underline, lineThrough, text, anchorX, anchorY, offsetUnderLineY, offsetThroughLineY, z, textAttribute, context, multiOption) {
        if (lineThrough + underline <= 0) return;
        const {
            textAlign = textAttribute.textAlign,
            fill = textAttribute.fill,
            opacity = textAttribute.opacity,
            underlineOffset = textAttribute.underlineOffset,
            underlineDash = textAttribute.underlineDash,
            fillOpacity = textAttribute.fillOpacity
          } = text.attribute,
          isMulti = !isNil$5(multiOption),
          w = isMulti ? multiOption.width : text.clipedWidth,
          offsetX = isMulti ? 0 : textDrawOffsetX(textAlign, w),
          attribute = {
            lineWidth: 0,
            stroke: fill,
            opacity: opacity,
            strokeOpacity: fillOpacity
          };
        if (underline) {
          attribute.lineWidth = underline, context.setStrokeStyle(text, attribute, anchorX, anchorY, textAttribute), underlineDash && context.setLineDash(underlineDash), context.beginPath();
          const dy = anchorY + offsetUnderLineY + underlineOffset;
          context.moveTo(anchorX + offsetX, dy, z), context.lineTo(anchorX + offsetX + w, dy, z), context.stroke();
        }
        if (lineThrough) {
          attribute.lineWidth = lineThrough, context.setStrokeStyle(text, attribute, anchorX, anchorY, textAttribute), context.beginPath();
          const dy = anchorY + offsetThroughLineY;
          context.moveTo(anchorX + offsetX, dy, z), context.lineTo(anchorX + offsetX + w, dy, z), context.stroke();
        }
      }
    };
    DefaultCanvasTextRender = __decorate$M([injectable(), __param$r(0, inject(ContributionProvider)), __param$r(0, named(TextRenderContribution)), __metadata$B("design:paramtypes", [Object])], DefaultCanvasTextRender);

    function drawPolygon(path, points, x, y) {
      path.moveTo(points[0].x + x, points[0].y + y);
      for (let i = 1; i < points.length; i++) path.lineTo(points[i].x + x, points[i].y + y);
    }
    function drawRoundedPolygon(path, points, x, y, cornerRadius) {
      let closePath = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : !0;
      var _a;
      if (points.length < 3) return void drawPolygon(path, points, x, y);
      let startI = 0,
        endI = points.length - 1;
      closePath || (startI += 1, endI -= 1, path.moveTo(points[0].x + x, points[0].y + y));
      for (let i = startI; i <= endI; i++) {
        const p1 = points[0 === i ? endI : (i - 1) % points.length],
          angularPoint = points[i % points.length],
          p2 = points[(i + 1) % points.length],
          dx1 = angularPoint.x - p1.x,
          dy1 = angularPoint.y - p1.y,
          dx2 = angularPoint.x - p2.x,
          dy2 = angularPoint.y - p2.y,
          angle = (Math.atan2(dy1, dx1) - Math.atan2(dy2, dx2)) / 2,
          tan = Math.abs(Math.tan(angle));
        let radius = Array.isArray(cornerRadius) ? null !== (_a = cornerRadius[i % points.length]) && void 0 !== _a ? _a : 0 : cornerRadius,
          segment = radius / tan;
        const length1 = getLength(dx1, dy1),
          length2 = getLength(dx2, dy2),
          length = Math.min(length1, length2);
        segment > length && (segment = length, radius = length * tan);
        const p1Cross = getProportionPoint(angularPoint, segment, length1, dx1, dy1),
          p2Cross = getProportionPoint(angularPoint, segment, length2, dx2, dy2),
          dx = 2 * angularPoint.x - p1Cross.x - p2Cross.x,
          dy = 2 * angularPoint.y - p1Cross.y - p2Cross.y,
          L = getLength(dx, dy),
          circlePoint = getProportionPoint(angularPoint, getLength(segment, radius), L, dx, dy);
        let startAngle = Math.atan2(p1Cross.y - circlePoint.y, p1Cross.x - circlePoint.x);
        const endAngle = Math.atan2(p2Cross.y - circlePoint.y, p2Cross.x - circlePoint.x);
        let sweepAngle = endAngle - startAngle;
        sweepAngle < 0 && (startAngle = endAngle, sweepAngle = -sweepAngle), sweepAngle > Math.PI && (sweepAngle -= Math.PI), 0 === i ? path.moveTo(p1Cross.x + x, p1Cross.y + y) : path.lineTo(p1Cross.x + x, p1Cross.y + y), sweepAngle && path.arcTo(angularPoint.x + x, angularPoint.y + y, p2Cross.x + x, p2Cross.y + y, radius), path.lineTo(p2Cross.x + x, p2Cross.y + y);
      }
      closePath || path.lineTo(points[endI + 1].x + x, points[endI + 1].y + y);
    }
    function getLength(dx, dy) {
      return Math.sqrt(dx * dx + dy * dy);
    }
    function getProportionPoint(point, segment, length, dx, dy) {
      const factor = segment / length;
      return {
        x: point.x - dx * factor,
        y: point.y - dy * factor
      };
    }

    const defaultPolygonTextureRenderContribution = defaultBaseTextureRenderContribution;
    const defaultPolygonBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

    var __decorate$L = undefined && undefined.__decorate || function (decorators, target, key, desc) {
        var d,
          c = arguments.length,
          r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      },
      __metadata$A = undefined && undefined.__metadata || function (k, v) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
      },
      __param$q = undefined && undefined.__param || function (paramIndex, decorator) {
        return function (target, key) {
          decorator(target, key, paramIndex);
        };
      };
    let DefaultCanvasPolygonRender = class extends BaseRender {
      constructor(graphicRenderContributions) {
        super(), this.graphicRenderContributions = graphicRenderContributions, this.numberType = POLYGON_NUMBER_TYPE, this.builtinContributions = [defaultPolygonBackgroundRenderContribution, defaultPolygonTextureRenderContribution], this.init(graphicRenderContributions);
      }
      drawShape(polygon, context, x, y, drawContext, params, fillCb, strokeCb) {
        const polygonAttribute = getTheme(polygon, null == params ? void 0 : params.theme).polygon,
          {
            points = polygonAttribute.points,
            cornerRadius = polygonAttribute.cornerRadius,
            x: originX = polygonAttribute.x,
            y: originY = polygonAttribute.y,
            closePath = polygonAttribute.closePath,
            fillStrokeOrder = polygonAttribute.fillStrokeOrder
          } = polygon.attribute,
          data = this.valid(polygon, polygonAttribute, fillCb, strokeCb);
        if (!data) return;
        const {
          fVisible: fVisible,
          sVisible: sVisible,
          doFill: doFill,
          doStroke: doStroke
        } = data;
        context.beginPath(), cornerRadius <= 0 || isArray$9(cornerRadius) && cornerRadius.every(num => 0 === num) ? drawPolygon(context.camera ? context : context.nativeContext, points, x, y) : drawRoundedPolygon(context.camera ? context : context.nativeContext, points, x, y, cornerRadius, closePath), closePath && context.closePath(), context.setShadowBlendStyle && context.setShadowBlendStyle(polygon, polygon.attribute, polygonAttribute), this.beforeRenderStep(polygon, context, x, y, doFill, doStroke, fVisible, sVisible, polygonAttribute, drawContext, fillCb, strokeCb);
        const _runFill = () => {
            doFill && (fillCb ? fillCb(context, polygon.attribute, polygonAttribute) : fVisible && (context.setCommonStyle(polygon, polygon.attribute, originX - x, originY - y, polygonAttribute), context.fill()));
          },
          _runStroke = () => {
            doStroke && (strokeCb ? strokeCb(context, polygon.attribute, polygonAttribute) : sVisible && (context.setStrokeStyle(polygon, polygon.attribute, originX - x, originY - y, polygonAttribute), context.stroke()));
          };
        fillStrokeOrder ? (_runStroke(), _runFill()) : (_runFill(), _runStroke()), this.afterRenderStep(polygon, context, x, y, doFill, doStroke, fVisible, sVisible, polygonAttribute, drawContext, fillCb, strokeCb);
      }
      draw(polygon, renderService, drawContext, params) {
        const polygonAttribute = getTheme(polygon, null == params ? void 0 : params.theme).polygon;
        this._draw(polygon, polygonAttribute, !1, drawContext, params);
      }
    };
    DefaultCanvasPolygonRender = __decorate$L([injectable(), __param$q(0, inject(ContributionProvider)), __param$q(0, named(PolygonRenderContribution)), __metadata$A("design:paramtypes", [Object])], DefaultCanvasPolygonRender);

    var __decorate$K = undefined && undefined.__decorate || function (decorators, target, key, desc) {
        var d,
          c = arguments.length,
          r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      },
      __metadata$z = undefined && undefined.__metadata || function (k, v) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
      },
      __param$p = undefined && undefined.__param || function (paramIndex, decorator) {
        return function (target, key) {
          decorator(target, key, paramIndex);
        };
      };
    let DefaultCanvasGroupRender = class {
      constructor(groupRenderContribitions) {
        this.groupRenderContribitions = groupRenderContribitions, this.numberType = GROUP_NUMBER_TYPE;
      }
      reInit() {
        this._groupRenderContribitions = this.groupRenderContribitions.getContributions() || [], this._groupRenderContribitions.push(defaultGroupBackgroundRenderContribution);
      }
      drawShape(group, context, x, y, drawContext, params, fillCb, strokeCb) {
        const groupAttribute = getTheme(group, null == params ? void 0 : params.theme).group,
          {
            fill = groupAttribute.fill,
            background: background,
            stroke = groupAttribute.stroke,
            opacity = groupAttribute.opacity,
            width = groupAttribute.width,
            height = groupAttribute.height,
            clip = groupAttribute.clip,
            fillOpacity = groupAttribute.fillOpacity,
            strokeOpacity = groupAttribute.strokeOpacity,
            cornerRadius = groupAttribute.cornerRadius,
            path = groupAttribute.path,
            lineWidth = groupAttribute.lineWidth,
            visible = groupAttribute.visible,
            fillStrokeOrder = groupAttribute.fillStrokeOrder,
            cornerType = groupAttribute.cornerType,
            x: originX = groupAttribute.x,
            y: originY = groupAttribute.y
          } = group.attribute,
          fVisible = rectFillVisible(opacity, fillOpacity, width, height, fill),
          sVisible = rectStrokeVisible(opacity, strokeOpacity, width, height),
          doFill = runFill(fill, background),
          doStroke = runStroke(stroke, lineWidth);
        if (!group.valid || !visible) return;
        if (!clip) {
          if (!doFill && !doStroke) return;
          if (!(fVisible || sVisible || fillCb || strokeCb || background)) return;
        }
        if (path && path.length && drawContext.drawContribution) {
          const disableFill = context.disableFill,
            disableStroke = context.disableStroke,
            disableBeginPath = context.disableBeginPath;
          context.disableFill = !0, context.disableStroke = !0, context.disableBeginPath = !0, path.forEach(g => {
            drawContext.drawContribution.getRenderContribution(g).draw(g, drawContext.renderService, drawContext, params);
          }), context.disableFill = disableFill, context.disableStroke = disableStroke, context.disableBeginPath = disableBeginPath;
        } else 0 === cornerRadius || isArray$9(cornerRadius) && cornerRadius.every(num => 0 === num) ? (context.beginPath(), context.rect(x, y, width, height)) : (context.beginPath(), createRectPath(context, x, y, width, height, cornerRadius, "bevel" !== cornerType));
        this._groupRenderContribitions || (this._groupRenderContribitions = this.groupRenderContribitions.getContributions() || [], this._groupRenderContribitions.push(defaultGroupBackgroundRenderContribution));
        const doFillOrStroke = {
          doFill: doFill,
          doStroke: doStroke
        };
        context.setShadowBlendStyle && context.setShadowBlendStyle(group, group.attribute, groupAttribute), this._groupRenderContribitions.forEach(c => {
          c.time === BaseRenderContributionTime.beforeFillStroke && c.drawShape(group, context, x, y, doFill, doStroke, fVisible, sVisible, groupAttribute, drawContext, fillCb, strokeCb, doFillOrStroke);
        }), clip && context.clip();
        const _runFill = () => {
            doFillOrStroke.doFill && (fillCb ? fillCb(context, group.attribute, groupAttribute) : fVisible && (context.setCommonStyle(group, group.attribute, originX - x, originY - y, groupAttribute), context.fill()));
          },
          _runStroke = () => {
            doFillOrStroke.doStroke && (strokeCb ? strokeCb(context, group.attribute, groupAttribute) : sVisible && (context.setStrokeStyle(group, group.attribute, originX - x, originY - y, groupAttribute), context.stroke()));
          };
        fillStrokeOrder ? (_runStroke(), _runFill()) : (_runFill(), _runStroke()), this._groupRenderContribitions.forEach(c => {
          c.time === BaseRenderContributionTime.afterFillStroke && c.drawShape(group, context, x, y, doFill, doStroke, fVisible, sVisible, groupAttribute, drawContext, fillCb, strokeCb);
        });
      }
      draw(group, renderService, drawContext, params) {
        const {
          context: context
        } = drawContext;
        if (!context) return;
        const {
            clip: clip,
            baseOpacity = 1,
            drawMode: drawMode,
            x: x,
            y: y,
            width: width,
            height: height
          } = group.attribute,
          lastNativeContext = context.nativeContext,
          lastNativeCanvas = context.canvas.nativeCanvas;
        if (drawMode > 0) {
          const canvas = context.canvas,
            newCanvas = vglobal.createCanvas({
              width: canvas.width,
              height: canvas.height,
              dpr: 1
            }),
            newContext = newCanvas.getContext("2d"),
            transform = context.nativeContext.getTransform();
          newContext.setTransform(transform.a, transform.b, transform.c, transform.d, transform.e, transform.f), 1 === drawMode && (newContext.save(), newContext.clearRect(0, 0, canvas.width, canvas.height), newContext.beginPath(), newContext.rect(x, y, width, height), newContext.clip(), newContext.drawImage(canvas.nativeCanvas, 0, 0, canvas.width, canvas.height, 0, 0, canvas.displayWidth, canvas.displayHeight), newContext.restore()), context.nativeContext = newContext, canvas.nativeCanvas = newCanvas;
        }
        clip ? context.save() : context.highPerformanceSave();
        const baseGlobalAlpha = context.baseGlobalAlpha;
        context.baseGlobalAlpha *= baseOpacity;
        const groupAttribute = getTheme(group, null == params ? void 0 : params.theme).group,
          lastModelMatrix = context.modelMatrix;
        if (context.camera) {
          const nextModelMatrix = mat4Allocate.allocate(),
            modelMatrix = mat4Allocate.allocate();
          getModelMatrix(modelMatrix, group, groupAttribute), multiplyMat4Mat4(nextModelMatrix, lastModelMatrix || nextModelMatrix, modelMatrix), context.modelMatrix = nextModelMatrix, mat4Allocate.free(modelMatrix), context.setTransform(1, 0, 0, 1, 0, 0, !0);
        } else context.transformFromMatrix(group.transMatrix, !0);
        context.beginPath(), params.skipDraw ? this.drawShape(group, context, 0, 0, drawContext, params, () => !1, () => !1) : this.drawShape(group, context, 0, 0, drawContext);
        const {
          scrollX = groupAttribute.scrollX,
          scrollY = groupAttribute.scrollY
        } = group.attribute;
        let p;
        if ((scrollX || scrollY) && context.translate(scrollX, scrollY), params && params.drawingCb && (p = params.drawingCb()), context.modelMatrix !== lastModelMatrix && mat4Allocate.free(context.modelMatrix), context.modelMatrix = lastModelMatrix, context.baseGlobalAlpha = baseGlobalAlpha, drawMode > 0) {
          const newContext = context.nativeContext,
            newCanvas = context.canvas.nativeCanvas;
          lastNativeContext.save(), lastNativeContext.setTransform(context.dpr, 0, 0, context.dpr, 0, 0, !0), 1 === drawMode && newContext.rect(x, y, width, height), lastNativeContext.drawImage(newCanvas, 0, 0, newCanvas.width, newCanvas.height, 0, 0, context.canvas.displayWidth, context.canvas.displayHeight);
          const transform = newContext.getTransform();
          lastNativeContext.setTransform(transform.a, transform.b, transform.c, transform.d, transform.e, transform.f), context.nativeContext = lastNativeContext, context.canvas.nativeCanvas = lastNativeCanvas, lastNativeContext.restore();
        }
        p && p.then ? p.then(() => {
          clip ? context.restore() : context.highPerformanceRestore();
        }) : clip ? context.restore() : context.highPerformanceRestore();
      }
    };
    DefaultCanvasGroupRender = __decorate$K([injectable(), __param$p(0, inject(ContributionProvider)), __param$p(0, named(GroupRenderContribution)), __metadata$z("design:paramtypes", [Object])], DefaultCanvasGroupRender);

    var __decorate$J = undefined && undefined.__decorate || function (decorators, target, key, desc) {
        var d,
          c = arguments.length,
          r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      },
      __metadata$y = undefined && undefined.__metadata || function (k, v) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
      },
      __param$o = undefined && undefined.__param || function (paramIndex, decorator) {
        return function (target, key) {
          decorator(target, key, paramIndex);
        };
      };
    const repeatStr = ["", "repeat-x", "repeat-y", "repeat"];
    let DefaultCanvasImageRender = class extends BaseRender {
      constructor(graphicRenderContributions) {
        super(), this.graphicRenderContributions = graphicRenderContributions, this.numberType = IMAGE_NUMBER_TYPE, this.builtinContributions = [defaultImageRenderContribution, defaultImageBackgroundRenderContribution], this.init(graphicRenderContributions);
      }
      drawShape(image, context, x, y, drawContext, params, fillCb, strokeCb) {
        const imageAttribute = getTheme(image).image,
          {
            repeatX = imageAttribute.repeatX,
            repeatY = imageAttribute.repeatY,
            x: originX = imageAttribute.x,
            y: originY = imageAttribute.y,
            cornerRadius = imageAttribute.cornerRadius,
            fillStrokeOrder = imageAttribute.fillStrokeOrder,
            cornerType = imageAttribute.cornerType,
            image: url
          } = image.attribute,
          data = this.valid(image, imageAttribute, fillCb);
        if (!data) return;
        const {
          fVisible: fVisible,
          sVisible: sVisible,
          doFill: doFill,
          doStroke: doStroke
        } = data;
        if (!url || !image.resources) return;
        const res = image.resources.get(url);
        if ("success" !== res.state) return;
        const width = image.width,
          height = image.height;
        context.beginPath();
        let needRestore = !1;
        0 === cornerRadius || isArray$9(cornerRadius) && cornerRadius.every(num => 0 === num) ? context.rect(x, y, width, height) : (createRectPath(context, x, y, width, height, cornerRadius, "bevel" !== cornerType), needRestore = !0), context.setShadowBlendStyle && context.setShadowBlendStyle(image, image.attribute, imageAttribute);
        const _runFill = () => {
            if (doFill) if (fillCb) fillCb(context, image.attribute, imageAttribute);else if (fVisible) {
              context.setCommonStyle(image, image.attribute, x, y, imageAttribute);
              let repeat = 0;
              if ("repeat" === repeatX && (repeat |= 1), "repeat" === repeatY && (repeat |= 2), repeat) {
                const pattern = context.createPattern(res.data, repeatStr[repeat]);
                context.fillStyle = pattern, context.translate(x, y, !0), context.fillRect(0, 0, width, height), context.translate(-x, -y, !0);
              } else context.drawImage(res.data, x, y, width, height);
            }
          },
          _runStroke = () => {
            doStroke && (strokeCb ? strokeCb(context, image.attribute, imageAttribute) : sVisible && (context.setStrokeStyle(image, image.attribute, originX - x, originY - y, imageAttribute), context.stroke()));
          };
        fillStrokeOrder ? (_runStroke(), needRestore && (context.save(), context.clip()), this.beforeRenderStep(image, context, x, y, doFill, !1, fVisible, !1, imageAttribute, drawContext, fillCb), _runFill(), needRestore && context.restore()) : (needRestore && (context.save(), context.clip()), this.beforeRenderStep(image, context, x, y, doFill, !1, fVisible, !1, imageAttribute, drawContext, fillCb), _runFill(), needRestore && context.restore(), _runStroke()), this.afterRenderStep(image, context, x, y, doFill, !1, fVisible, !1, imageAttribute, drawContext, fillCb);
      }
      draw(image, renderService, drawContext) {
        const {
          image: url
        } = image.attribute;
        if (!url || !image.resources) return;
        const res = image.resources.get(url);
        if ("loading" === res.state && isString$6(url)) return void ResourceLoader.improveImageLoading(url);
        if ("success" !== res.state) return;
        const {
          context: context
        } = renderService.drawParams;
        if (!context) return;
        const imageAttribute = getTheme(image).image;
        this._draw(image, imageAttribute, !1, drawContext);
      }
    };
    DefaultCanvasImageRender = __decorate$J([injectable(), __param$o(0, inject(ContributionProvider)), __param$o(0, named(ImageRenderContribution)), __metadata$y("design:paramtypes", [Object])], DefaultCanvasImageRender);

    const IncrementalDrawContribution = Symbol.for("IncrementalDrawContribution");
    const ArcRender = Symbol.for("ArcRender");
    const CircleRender = Symbol.for("CircleRender");
    const GraphicRender = Symbol.for("GraphicRender");
    const GroupRender = Symbol.for("GroupRender");
    const LineRender = Symbol.for("LineRender");
    const PathRender = Symbol.for("PathRender");
    const PolygonRender = Symbol.for("PolygonRender");
    const RectRender = Symbol.for("RectRender");
    const SymbolRender = Symbol.for("SymbolRender");
    const TextRender = Symbol.for("TextRender");
    const RichTextRender = Symbol.for("RichTextRender");
    const ImageRender = Symbol.for("ImageRender");
    const DrawContribution = Symbol.for("DrawContribution");

    const draw3dItem = (context, graphic, callback, output) => {
      let result,
        isPie = !1,
        is3d = !1;
      if (graphic.forEachChildren(c => (isPie = c.numberType === ARC3D_NUMBER_TYPE, !isPie)), graphic.forEachChildren(c => (is3d = !!c.findFace, !is3d)), isPie) {
        const children = graphic.getChildren(),
          sortedChildren = [...children];
        sortedChildren.sort((a, b) => {
          var _a, _b, _c, _d;
          let angle1 = (null !== (_b = null !== (_a = a.attribute.startAngle) && void 0 !== _a ? _a : 0 + a.attribute.endAngle) && void 0 !== _b ? _b : 0) / 2,
            angle2 = (null !== (_d = null !== (_c = b.attribute.startAngle) && void 0 !== _c ? _c : 0 + b.attribute.endAngle) && void 0 !== _d ? _d : 0) / 2;
          for (; angle1 < 0;) angle1 += pi2;
          for (; angle2 < 0;) angle2 += pi2;
          return angle2 - angle1;
        }), sortedChildren.forEach(c => {
          c._next = null, c._prev = null;
        }), graphic.removeAllChild(), graphic.update(), sortedChildren.forEach(c => {
          graphic.appendChild(c);
        }), output.hack_pieFace = "outside", result = callback(isPie, is3d), result && result.graphic || (output.hack_pieFace = "inside", result = callback(isPie, is3d)), result && result.graphic || (output.hack_pieFace = "top", result = callback(isPie, is3d)), graphic.removeAllChild(), children.forEach(c => {
          c._next = null, c._prev = null;
        }), children.forEach(c => {
          graphic.appendChild(c);
        });
      } else if (is3d) {
        const children = graphic.getChildren(),
          zChildren = children.map(g => ({
            ave_z: g.findFace().vertices.map(v => {
              var _a;
              return context.view(v[0], v[1], null !== (_a = v[2] + g.attribute.z) && void 0 !== _a ? _a : 0)[2];
            }).reduce((a, b) => a + b, 0),
            g: g
          }));
        zChildren.sort((a, b) => b.ave_z - a.ave_z), graphic.removeAllChild(), zChildren.forEach(i => {
          i.g._next = null, i.g._prev = null;
        }), graphic.update(), zChildren.forEach(i => {
          graphic.add(i.g);
        }), result = callback(isPie, is3d), graphic.removeAllChild(), children.forEach(g => {
          g._next = null, g._prev = null;
        }), graphic.update(), children.forEach(g => {
          graphic.add(g);
        });
      } else result = callback(isPie, is3d);
      return result;
    };

    var __decorate$I = undefined && undefined.__decorate || function (decorators, target, key, desc) {
        var d,
          c = arguments.length,
          r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      },
      __metadata$x = undefined && undefined.__metadata || function (k, v) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
      };
    const DrawItemInterceptor = Symbol.for("DrawItemInterceptor");
    const tempDirtyBounds = new AABBBounds$1(),
      tempBackupDirtyBounds = new AABBBounds$1();
    class ShadowRootDrawItemInterceptorContribution {
      constructor() {
        this.order = 1;
      }
      afterDrawItem(graphic, renderService, drawContext, drawContribution, params) {
        return null == graphic.attribute.shadowRootIdx && graphic.shadowRoot && graphic.shadowRoot.attribute.shadowRootIdx < 0 || (graphic.attribute.shadowRootIdx > 0 || !graphic.attribute.shadowRootIdx || graphic.shadowRoot && graphic.shadowRoot.attribute.shadowRootIdx > 0) && this.drawItem(graphic, renderService, drawContext, drawContribution, params), !1;
      }
      beforeDrawItem(graphic, renderService, drawContext, drawContribution, params) {
        return null == graphic.attribute.shadowRootIdx && graphic.shadowRoot && graphic.shadowRoot.attribute.shadowRootIdx > 0 || (graphic.attribute.shadowRootIdx < 0 || graphic.shadowRoot && graphic.shadowRoot.attribute.shadowRootIdx < 0) && this.drawItem(graphic, renderService, drawContext, drawContribution, params), !1;
      }
      drawItem(graphic, renderService, drawContext, drawContribution, params) {
        if (!graphic.shadowRoot) return !1;
        const {
          context: context
        } = drawContext;
        if (context.highPerformanceSave(), context.transformFromMatrix(graphic.transMatrix, !0), drawContribution.dirtyBounds && drawContribution.backupDirtyBounds) {
          tempDirtyBounds.copy(drawContribution.dirtyBounds), tempBackupDirtyBounds.copy(drawContribution.backupDirtyBounds);
          const m = graphic.globalTransMatrix.getInverse();
          drawContribution.dirtyBounds.copy(drawContribution.backupDirtyBounds).transformWithMatrix(m), drawContribution.backupDirtyBounds.copy(drawContribution.dirtyBounds);
        }
        return drawContribution.renderGroup(graphic.shadowRoot, drawContext, matrixAllocate.allocate(1, 0, 0, 1, 0, 0)), context.highPerformanceRestore(), drawContribution.dirtyBounds && drawContribution.backupDirtyBounds && (drawContribution.dirtyBounds.copy(tempDirtyBounds), drawContribution.backupDirtyBounds.copy(tempBackupDirtyBounds)), !0;
      }
    }
    class DebugDrawItemInterceptorContribution {
      constructor() {
        this.order = 1;
      }
      afterDrawItem(graphic, renderService, drawContext, drawContribution, params) {
        return graphic.attribute._debug_bounds && this.drawItem(graphic, renderService, drawContext, drawContribution, params), !1;
      }
      drawItem(graphic, renderService, drawContext, drawContribution, params) {
        if (!graphic.attribute._debug_bounds) return !1;
        const {
          context: context
        } = drawContext;
        context.highPerformanceSave(), graphic.parent && context.setTransformFromMatrix(graphic.parent.globalTransMatrix, !0), graphic.glyphHost && graphic.glyphHost.parent && context.setTransformFromMatrix(graphic.glyphHost.parent.globalTransMatrix, !0);
        const b = graphic.AABBBounds;
        return !0 !== graphic.attribute._debug_bounds && graphic.attribute._debug_bounds(context, graphic), context.strokeRect(b.x1, b.y1, b.width(), b.height()), context.highPerformanceRestore(), !0;
      }
    }
    let CommonDrawItemInterceptorContribution = class {
      constructor() {
        this.order = 1, this.interceptors = [new ShadowRootDrawItemInterceptorContribution(), new Canvas3DDrawItemInterceptor(), new InteractiveDrawItemInterceptorContribution(), new DebugDrawItemInterceptorContribution()];
      }
      afterDrawItem(graphic, renderService, drawContext, drawContribution, params) {
        for (let i = 0; i < this.interceptors.length; i++) if (this.interceptors[i].afterDrawItem && this.interceptors[i].afterDrawItem(graphic, renderService, drawContext, drawContribution, params)) return !0;
        return !1;
      }
      beforeDrawItem(graphic, renderService, drawContext, drawContribution, params) {
        if ((!graphic.in3dMode || drawContext.in3dInterceptor) && !graphic.shadowRoot && !(graphic.baseGraphic || graphic.attribute.globalZIndex || graphic.interactiveGraphic)) return !1;
        for (let i = 0; i < this.interceptors.length; i++) if (this.interceptors[i].beforeDrawItem && this.interceptors[i].beforeDrawItem(graphic, renderService, drawContext, drawContribution, params)) return !0;
        return !1;
      }
    };
    CommonDrawItemInterceptorContribution = __decorate$I([injectable(), __metadata$x("design:paramtypes", [])], CommonDrawItemInterceptorContribution);
    class InteractiveDrawItemInterceptorContribution {
      constructor() {
        this.order = 1;
      }
      beforeDrawItem(graphic, renderService, drawContext, drawContribution, params) {
        return !this.processing && (graphic.baseGraphic ? this.beforeDrawInteractive(graphic, renderService, drawContext, drawContribution, params) : this.beforeSetInteractive(graphic, renderService, drawContext, drawContribution, params));
      }
      beforeSetInteractive(graphic, renderService, drawContext, drawContribution, params) {
        let interactiveGraphic = graphic.interactiveGraphic;
        if (graphic.attribute.globalZIndex) {
          interactiveGraphic || (interactiveGraphic = graphic.clone(), graphic.interactiveGraphic = interactiveGraphic, interactiveGraphic.baseGraphic = graphic), interactiveGraphic.setAttributes({
            globalZIndex: 0,
            zIndex: graphic.attribute.globalZIndex
          }, !1, {
            skipUpdateCallback: !0
          }), drawContext.stage.tryInitInteractiveLayer();
          const interactiveLayer = drawContext.stage.getLayer("_builtin_interactive");
          if (interactiveLayer) {
            this.getShadowRoot(interactiveLayer).add(interactiveGraphic);
          }
          return !0;
        }
        if (interactiveGraphic) {
          drawContext.stage.tryInitInteractiveLayer();
          const interactiveLayer = drawContext.stage.getLayer("_builtin_interactive");
          if (interactiveLayer) {
            this.getShadowRoot(interactiveLayer).removeChild(interactiveGraphic);
          }
          graphic.interactiveGraphic = null, interactiveGraphic.baseGraphic = null;
        }
        return !1;
      }
      beforeDrawInteractive(graphic, renderService, drawContext, drawContribution, params) {
        const baseGraphic = graphic.baseGraphic;
        let intree = !!baseGraphic.stage,
          _g = baseGraphic.parent;
        for (; intree && _g && _g.stage !== _g;) intree = !!_g.stage, _g = _g.parent;
        if (!intree) {
          const interactiveLayer = drawContext.stage.getLayer("_builtin_interactive");
          if (interactiveLayer) {
            this.getShadowRoot(interactiveLayer).removeChild(graphic);
          }
          return !0;
        }
        if (baseGraphic) {
          this.processing = !0;
          const {
            context: context
          } = drawContext;
          return context.highPerformanceSave(), context.setTransformFromMatrix(baseGraphic.parent.globalTransMatrix, !0), baseGraphic.isContainer ? drawContribution.renderGroup(baseGraphic, drawContext, baseGraphic.parent.globalTransMatrix) : drawContribution.renderItem(baseGraphic, drawContext), context.highPerformanceRestore(), this.processing = !1, !0;
        }
        return !1;
      }
      getShadowRoot(interactiveLayer) {
        var _a;
        let group = interactiveLayer.getElementById("_interactive_group");
        return group || (group = graphicCreator.CreateGraphic("group", {}), group.id = "_interactive_group", interactiveLayer.add(group)), null !== (_a = group.shadowRoot) && void 0 !== _a ? _a : group.attachShadow();
      }
    }
    class Canvas3DDrawItemInterceptor {
      constructor() {
        this.order = 1;
      }
      beforeDrawItem(graphic, renderService, drawContext, drawContribution, params) {
        if (!graphic.in3dMode || drawContext.in3dInterceptor) return !1;
        drawContext.in3dInterceptor = !0;
        const {
          context: context,
          stage: stage
        } = renderService.drawParams;
        context.canvas;
        context.save(), this.initCanvasCtx(context), context.camera = stage.camera;
        const m = context.currentMatrix;
        m.a /= context.dpr, m.b /= context.dpr, m.c /= context.dpr, m.d /= context.dpr, m.e /= context.dpr, m.f /= context.dpr;
        const matrix = mat4Allocate.allocate();
        mat3Tomat4(matrix, m);
        const lastModelMatrix = context.modelMatrix;
        if (lastModelMatrix) {
          if (matrix) {
            const m = mat4Allocate.allocate();
            context.modelMatrix = multiplyMat4Mat4(m, lastModelMatrix, matrix);
          }
        } else context.modelMatrix = matrix;
        return context.setTransform(1, 0, 0, 1, 0, 0, !0), graphic.isContainer ? draw3dItem(context, graphic, (isPie, is3d) => drawContribution.renderGroup(graphic, drawContext, graphic.parent.globalTransMatrix, !isPie && is3d), drawContext) : drawContribution.renderItem(graphic, drawContext), context.camera = null, context.restore(), context.modelMatrix !== lastModelMatrix && mat4Allocate.free(context.modelMatrix), context.modelMatrix = lastModelMatrix, drawContext.in3dInterceptor = !1, !0;
      }
      initCanvasCtx(context) {
        context.setTransformForCurrent();
      }
    }

    var __decorate$H = undefined && undefined.__decorate || function (decorators, target, key, desc) {
        var d,
          c = arguments.length,
          r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      },
      __metadata$w = undefined && undefined.__metadata || function (k, v) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
      },
      __param$n = undefined && undefined.__param || function (paramIndex, decorator) {
        return function (target, key) {
          decorator(target, key, paramIndex);
        };
      };
    const RenderService = Symbol.for("RenderService");
    let DefaultRenderService = class {
      constructor(drawContribution) {
        this.drawContribution = drawContribution;
      }
      prepare(updateBounds) {
        updateBounds && this.renderTreeRoots.forEach(g => {
          this._prepare(g, updateBounds);
        });
      }
      _prepare(g, updateBounds) {
        g.forEachChildren(g => {
          this._prepare(g, updateBounds);
        }), g.update({
          bounds: updateBounds,
          trans: !0
        });
      }
      prepareRenderList() {}
      beforeDraw(params) {}
      draw(params) {
        this.drawContribution.draw(this, Object.assign({}, this.drawParams));
      }
      afterDraw(params) {
        this.drawContribution.afterDraw && this.drawContribution.afterDraw(this, Object.assign({}, this.drawParams));
      }
      reInit() {
        this.drawContribution.reInit();
      }
      render(groups, params) {
        this.renderTreeRoots = groups, this.drawParams = params;
        const updateBounds = params.updateBounds;
        this.prepare(updateBounds), this.prepareRenderList(), this.beforeDraw(params), this.draw(params), this.afterDraw(params), this.drawParams = null;
      }
    };
    DefaultRenderService = __decorate$H([injectable(), __param$n(0, inject(DrawContribution)), __metadata$w("design:paramtypes", [Object])], DefaultRenderService);

    var renderModule$1 = new ContainerModule(bind => {
      bind(RenderService).to(DefaultRenderService);
    });

    const PickerService = Symbol.for("PickerService");
    const GlobalPickerService = Symbol.for("GlobalPickerService");
    const PickItemInterceptor = Symbol.for("PickItemInterceptor");
    const PickServiceInterceptor = Symbol.for("PickServiceInterceptor");

    var __decorate$G = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let ShadowPickServiceInterceptorContribution = class {
      constructor() {
        this.order = 1;
      }
      afterPickItem(result, pickerService, point, pickParams, params) {
        if (result.graphic) {
          let g = result.graphic;
          for (; g.parent;) g = g.parent;
          g.shadowHost && (result.params = {
            shadowTarget: result.graphic
          }, result.graphic = g.shadowHost);
        }
        return result;
      }
    };
    ShadowPickServiceInterceptorContribution = __decorate$G([injectable()], ShadowPickServiceInterceptorContribution);
    let ShadowRootPickItemInterceptorContribution = class {
      constructor() {
        this.order = 1;
      }
      afterPickItem(graphic, pickerService, point, pickParams, params) {
        return graphic.attribute.shadowRootIdx > 0 || !graphic.attribute.shadowRootIdx ? this._pickItem(graphic, pickerService, point, pickParams, params) : null;
      }
      beforePickItem(graphic, pickerService, point, pickParams, params) {
        return graphic.attribute.shadowRootIdx < 0 ? this._pickItem(graphic, pickerService, point, pickParams, params) : null;
      }
      _pickItem(graphic, pickerService, point, pickParams, params) {
        var _a;
        if (!graphic.shadowRoot) return null;
        const {
          parentMatrix: parentMatrix
        } = params || {};
        if (!parentMatrix) return null;
        const context = pickerService.pickContext;
        context.highPerformanceSave();
        const theme = null === (_a = getTheme(graphic)) || void 0 === _a ? void 0 : _a[graphic.type],
          {
            shadowPickMode = null == theme ? void 0 : theme.shadowPickMode
          } = graphic.attribute,
          g = graphic.shadowRoot,
          currentGroupMatrix = matrixAllocate.allocateByObj(parentMatrix),
          newPoint = new Point(currentGroupMatrix.a * point.x + currentGroupMatrix.c * point.y + currentGroupMatrix.e, currentGroupMatrix.b * point.x + currentGroupMatrix.d * point.y + currentGroupMatrix.f),
          result = pickerService.pickGroup(g, newPoint, currentGroupMatrix, pickParams);
        return context.highPerformanceRestore(), !result.graphic && result.group && "full" === shadowPickMode && (result.graphic = result.group), result;
      }
    };
    ShadowRootPickItemInterceptorContribution = __decorate$G([injectable()], ShadowRootPickItemInterceptorContribution);
    let InteractivePickItemInterceptorContribution = class {
      constructor() {
        this.order = 1;
      }
      beforePickItem(graphic, pickerService, point, pickParams, params) {
        const originGraphic = graphic.baseGraphic;
        if (originGraphic && originGraphic.parent) {
          const newPoint = new Point(point.x, point.y),
            context = pickerService.pickContext;
          context.highPerformanceSave();
          const parentMatrix = originGraphic.parent.globalTransMatrix;
          parentMatrix.transformPoint(newPoint, newPoint);
          const result = originGraphic.isContainer ? pickerService.pickGroup(originGraphic, newPoint.clone(), parentMatrix, pickParams) : pickerService.pickItem(originGraphic, newPoint.clone(), parentMatrix, pickParams);
          return context.highPerformanceRestore(), result;
        }
        return null;
      }
    };
    InteractivePickItemInterceptorContribution = __decorate$G([injectable()], InteractivePickItemInterceptorContribution);
    let Canvas3DPickItemInterceptor = class {
      constructor() {
        this.order = 1;
      }
      beforePickItem(graphic, pickerService, point, pickParams, params) {
        if (!graphic.in3dMode || pickParams.in3dInterceptor) return null;
        const context = pickerService.pickContext,
          stage = graphic.stage;
        if (!context || !stage) return null;
        if (pickParams.in3dInterceptor = !0, context.save(), this.initCanvasCtx(context), context.camera = stage.camera, graphic.isContainer) {
          const result = draw3dItem(context, graphic, () => pickerService.pickGroup(graphic, point, params.parentMatrix, pickParams), pickParams);
          return context.camera = null, pickParams.in3dInterceptor = !1, context.restore(), result;
        }
        return context.restore(), null;
      }
      initCanvasCtx(context) {
        context.setTransformForCurrent();
      }
    };
    Canvas3DPickItemInterceptor = __decorate$G([injectable()], Canvas3DPickItemInterceptor);

    var pickModule = new ContainerModule((bind, unbind, isBound) => {
      isBound(PickerService) || (bind(GlobalPickerService).toSelf(), bind(PickerService).toService(GlobalPickerService)), bind(Canvas3DPickItemInterceptor).toSelf().inSingletonScope(), bind(PickItemInterceptor).toService(Canvas3DPickItemInterceptor), bind(ShadowRootPickItemInterceptorContribution).toSelf().inSingletonScope(), bind(PickItemInterceptor).toService(ShadowRootPickItemInterceptorContribution), bind(InteractivePickItemInterceptorContribution).toSelf().inSingletonScope(), bind(PickItemInterceptor).toService(InteractivePickItemInterceptorContribution), bindContributionProvider(bind, PickItemInterceptor), bind(ShadowPickServiceInterceptorContribution).toSelf().inSingletonScope(), bind(PickServiceInterceptor).toService(ShadowPickServiceInterceptorContribution), bindContributionProvider(bind, PickServiceInterceptor);
    });

    var graphicModule = new ContainerModule(bind => {
      bind(GraphicService).to(DefaultGraphicService).inSingletonScope(), bind(GraphicCreator$1).toConstantValue(graphicCreator);
    });

    const AutoEnablePlugins = Symbol.for("AutoEnablePlugins");
    const PluginService = Symbol.for("PluginService");

    var __decorate$F = undefined && undefined.__decorate || function (decorators, target, key, desc) {
        var d,
          c = arguments.length,
          r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      },
      __metadata$v = undefined && undefined.__metadata || function (k, v) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
      },
      __param$m = undefined && undefined.__param || function (paramIndex, decorator) {
        return function (target, key) {
          decorator(target, key, paramIndex);
        };
      };
    let DefaultPluginService = class {
      constructor(autoEnablePlugins) {
        this.autoEnablePlugins = autoEnablePlugins, this.onStartupFinishedPlugin = [], this.onRegisterPlugin = [], this.actived = !1;
      }
      active(stage, params) {
        this.stage = stage, this.actived = !0;
        const {
          pluginList: pluginList
        } = params;
        pluginList && container.isBound(AutoEnablePlugins) && this.autoEnablePlugins.getContributions().forEach(p => {
          pluginList.includes(p.name) && this.register(p);
        });
      }
      findPluginsByName(name) {
        const arr = [];
        return this.onStartupFinishedPlugin.forEach(plugin => {
          plugin.name === name && arr.push(plugin);
        }), this.onRegisterPlugin.forEach(plugin => {
          plugin.name === name && arr.push(plugin);
        }), arr;
      }
      register(plugin) {
        "onStartupFinished" === plugin.activeEvent ? this.onStartupFinishedPlugin.push(plugin) : "onRegister" === plugin.activeEvent && (this.onRegisterPlugin.push(plugin), plugin.activate(this));
      }
      unRegister(plugin) {
        "onStartupFinished" === plugin.activeEvent ? this.onStartupFinishedPlugin.splice(this.onStartupFinishedPlugin.indexOf(plugin), 1) : "onRegister" === plugin.activeEvent && this.onRegisterPlugin.splice(this.onStartupFinishedPlugin.indexOf(plugin), 1), plugin.deactivate(this);
      }
      release() {
        this.onStartupFinishedPlugin.forEach(plugin => {
          plugin.deactivate(this);
        }), this.onStartupFinishedPlugin = [], this.onRegisterPlugin.forEach(plugin => {
          plugin.deactivate(this);
        }), this.onRegisterPlugin = [];
      }
    };
    DefaultPluginService = __decorate$F([injectable(), __param$m(0, inject(ContributionProvider)), __param$m(0, named(AutoEnablePlugins)), __metadata$v("design:paramtypes", [Object])], DefaultPluginService);

    var pluginModule = new ContainerModule(bind => {
      bind(PluginService).to(DefaultPluginService), bindContributionProviderNoSingletonScope(bind, AutoEnablePlugins);
    });

    var envModules = new ContainerModule(bind => {
      bindContributionProvider(bind, EnvContribution);
    });

    var textMeasureModules = new ContainerModule(bind => {
      bind(TextMeasureContribution).to(DefaultTextMeasureContribution).inSingletonScope(), bindContributionProvider(bind, TextMeasureContribution);
    });

    var __decorate$E = undefined && undefined.__decorate || function (decorators, target, key, desc) {
        var d,
          c = arguments.length,
          r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      },
      __metadata$u = undefined && undefined.__metadata || function (k, v) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
      };
    let CanvasLayerHandlerContribution = class {
      constructor() {
        this.type = "static", this.offscreen = !1, this.global = application.global;
      }
      setDpr(dpr) {
        this.canvas.dpr = dpr;
      }
      init(layer, window, params) {
        if (this.layer = layer, this.window = window, params.main) this.main = !0, this.context = window.getContext(), this.canvas = this.context.getCanvas();else {
          let nativeCanvas;
          this.main = !1, params.canvasId && (nativeCanvas = this.global.getElementById(params.canvasId)), nativeCanvas || (nativeCanvas = this.global.createCanvas({
            width: window.width,
            height: window.height
          })), nativeCanvas.style && (nativeCanvas.style["pointer-events"] = "none");
          const windowCanvas = window.getContext().getCanvas().nativeCanvas,
            canvas = wrapCanvas({
              nativeCanvas: nativeCanvas,
              width: window.width,
              height: window.height,
              dpr: window.dpr,
              id: params.canvasId,
              canvasControled: !0,
              container: window.getContainer(),
              x: windowCanvas.offsetLeft,
              y: windowCanvas.offsetTop
            });
          canvas.applyPosition(), this.canvas = canvas, this.context = canvas.getContext();
        }
      }
      resize(w, h) {
        this.canvas.resize(w, h);
      }
      resizeView(w, h) {}
      render(group, params, userParams) {
        var _a;
        if (!this.main) {
          const windowCanvas = this.window.getContext().getCanvas().nativeCanvas;
          !windowCanvas || this.canvas.x === windowCanvas.offsetLeft && this.canvas.y === windowCanvas.offsetTop || (this.canvas.x = windowCanvas.offsetLeft, this.canvas.y = windowCanvas.offsetTop, this.canvas.applyPosition());
        }
        params.renderService.render(group, Object.assign(Object.assign({
          context: this.context,
          clear: null !== (_a = params.background) && void 0 !== _a ? _a : "#ffffff"
        }, params), userParams));
      }
      merge(layerHandlers) {
        layerHandlers.forEach(l => {
          const canvas = l.getContext().canvas.nativeCanvas;
          this.context.drawImage(canvas, 0, 0);
        });
      }
      prepare(dirtyBounds, params) {}
      drawTo(target, group, params) {
        var _a;
        const context = target.getContext();
        params.renderService.render(group, Object.assign(Object.assign({
          context: context
        }, params), {
          clear: params.clear ? null !== (_a = params.background) && void 0 !== _a ? _a : "#fff" : void 0
        }));
      }
      getContext() {
        return this.context;
      }
      release() {
        this.canvas.release();
      }
    };
    CanvasLayerHandlerContribution = __decorate$E([injectable(), __metadata$u("design:paramtypes", [])], CanvasLayerHandlerContribution);

    var layerHandlerModules = new ContainerModule(bind => {
      bind(CanvasLayerHandlerContribution).toSelf(), bind(StaticLayerHandlerContribution).toService(CanvasLayerHandlerContribution);
    });

    function load$1(container) {
      container.load(envModules), container.load(textMeasureModules), container.load(layerHandlerModules);
    }

    var __awaiter$3 = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          var value;
          result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P(function (resolve) {
            resolve(value);
          })).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    function parseChildMap(graphic, defaultZIndex, reverse) {
      const childMap = {},
        zIdxArray = [];
      return graphic.forEachChildren(item => {
        const {
          zIndex = defaultZIndex
        } = item.attribute;
        childMap[zIndex] ? childMap[zIndex].push(item) : (childMap[zIndex] = [item], zIdxArray.push(zIndex));
      }, reverse), zIdxArray.sort((a, b) => reverse ? b - a : a - b), {
        childMap: childMap,
        zIdxArray: zIdxArray
      };
    }
    function foreach(graphic, defaultZIndex, cb) {
      let reverse = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
      let sort3d = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !1;
      let needSort = !1;
      if (sort3d) needSort = !0;else {
        let lastZIndex;
        graphic.forEachChildren((item, i) => {
          const {
            zIndex = defaultZIndex
          } = item.attribute;
          if (0 === i) lastZIndex = zIndex;else if (lastZIndex !== zIndex) return needSort = !0, !0;
          return !1;
        }, reverse);
      }
      if (needSort) {
        const {
          childMap: childMap,
          zIdxArray: zIdxArray
        } = parseChildMap(graphic, defaultZIndex, reverse);
        let skip = !1;
        for (let i = 0; i < zIdxArray.length && !skip; i++) {
          const children = childMap[zIdxArray[i]];
          sort3d && children.sort((a, b) => {
            var _a, _b;
            return (reverse ? -1 : 1) * ((null !== (_a = b.attribute.z) && void 0 !== _a ? _a : 0) - (null !== (_b = a.attribute.z) && void 0 !== _b ? _b : 0));
          });
          for (let i = 0; i < children.length; i++) if (cb(children[i], i)) {
            skip = !0;
            break;
          }
        }
      } else graphic.forEachChildren(cb, reverse);
    }
    function foreachAsync(graphic, defaultZIndex, cb) {
      let reverse = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
      return __awaiter$3(this, void 0, void 0, function* () {
        yield graphic.forEachChildrenAsync(cb, reverse);
      });
    }
    function findNextGraphic(graphic, id, defaultZIndex) {
      let reverse = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
      let needSort = !1;
      graphic.forEachChildren((item, i) => {
        const {
          zIndex = defaultZIndex
        } = item.attribute;
        if (0 === i) ;else if (undefined !== zIndex) return needSort = !0, !0;
        return !1;
      }, reverse);
      let result = null,
        next = !1;
      if (needSort) {
        const {
          childMap: childMap,
          zIdxArray: zIdxArray
        } = parseChildMap(graphic, defaultZIndex, reverse);
        let skip = !1;
        for (let i = 0; i < zIdxArray.length && !skip; i++) {
          const children = childMap[zIdxArray[i]];
          for (let i = 0; i < children.length; i++) {
            if (next) {
              skip = !0, result = children[i];
              break;
            }
            children[i]._uid !== id || (next = !0);
          }
        }
      } else graphic.forEachChildren(item => next ? (result = item, !0) : (item._uid === id && (next = !0), !1), reverse);
      return result;
    }

    var __decorate$D = undefined && undefined.__decorate || function (decorators, target, key, desc) {
        var d,
          c = arguments.length,
          r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      },
      __metadata$t = undefined && undefined.__metadata || function (k, v) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
      },
      __param$l = undefined && undefined.__param || function (paramIndex, decorator) {
        return function (target, key) {
          decorator(target, key, paramIndex);
        };
      };
    let DefaultDrawContribution = class {
      constructor(contributions, drawItemInterceptorContributions) {
        this.contributions = contributions, this.drawItemInterceptorContributions = drawItemInterceptorContributions, this.currentRenderMap = new Map(), this.defaultRenderMap = new Map(), this.styleRenderMap = new Map(), this.dirtyBounds = new Bounds$1(), this.backupDirtyBounds = new Bounds$1(), this.global = application.global, this.layerService = application.layerService, isArray$9(this.contributions) || (this.contributions = [this.contributions]), this.init();
      }
      reInit() {
        this.init(), this.contributions.forEach(item => {
          item.reInit();
        });
      }
      init() {
        this.contributions.forEach(item => {
          if (item.style) {
            const map = this.styleRenderMap.get(item.style) || new Map();
            map.set(item.numberType, item), this.styleRenderMap.set(item.style, map);
          } else this.defaultRenderMap.set(item.numberType, item);
        }), this.InterceptorContributions = this.drawItemInterceptorContributions.getContributions().sort((a, b) => a.order - b.order);
      }
      prepareForDraw(renderService, drawContext) {
        drawContext.updateBounds ? this.useDirtyBounds = !0 : this.useDirtyBounds = !drawContext.stage.params.optimize.disableCheckGraphicWidthOutRange;
      }
      draw(renderService, drawContext) {
        this.prepareForDraw(renderService, drawContext), drawContext.drawContribution = this, this.currentRenderMap = this.styleRenderMap.get(drawContext.renderStyle) || this.defaultRenderMap, this.currentRenderService = renderService;
        const {
          context: context,
          stage: stage,
          viewBox: viewBox,
          transMatrix: transMatrix
        } = drawContext;
        if (!context) return;
        const dirtyBounds = this.dirtyBounds.setValue(0, 0, viewBox.width(), viewBox.height());
        if (stage.dirtyBounds && !stage.dirtyBounds.empty()) {
          const b = getRectIntersect(dirtyBounds, stage.dirtyBounds, !1);
          dirtyBounds.x1 = Math.floor(b.x1), dirtyBounds.y1 = Math.floor(b.y1), dirtyBounds.x2 = Math.ceil(b.x2), dirtyBounds.y2 = Math.ceil(b.y2);
        }
        const d = context.dpr % 1;
        (d || .5 !== d) && (dirtyBounds.x1 = Math.floor(dirtyBounds.x1 * context.dpr) / context.dpr, dirtyBounds.y1 = Math.floor(dirtyBounds.y1 * context.dpr) / context.dpr, dirtyBounds.x2 = Math.ceil(dirtyBounds.x2 * context.dpr) / context.dpr, dirtyBounds.y2 = Math.ceil(dirtyBounds.y2 * context.dpr) / context.dpr), this.backupDirtyBounds.copy(dirtyBounds), context.inuse = !0, context.setClearMatrix(transMatrix.a, transMatrix.b, transMatrix.c, transMatrix.d, transMatrix.e, transMatrix.f), context.clearMatrix(), context.setTransformForCurrent(!0), context.translate(viewBox.x1, viewBox.y1, !0), context.beginPath(), context.rect(dirtyBounds.x1, dirtyBounds.y1, dirtyBounds.width(), dirtyBounds.height()), context.clip(), stage.camera && (this.dirtyBounds.setValue(-1 / 0, -1 / 0, 1 / 0, 1 / 0), this.backupDirtyBounds.setValue(-1 / 0, -1 / 0, 1 / 0, 1 / 0)), this.clearScreen(renderService, context, drawContext), context.save(), renderService.renderTreeRoots.sort((a, b) => {
          var _a, _b;
          return (null !== (_a = a.attribute.zIndex) && void 0 !== _a ? _a : DefaultAttribute.zIndex) - (null !== (_b = b.attribute.zIndex) && void 0 !== _b ? _b : DefaultAttribute.zIndex);
        }).forEach(group => {
          group.isContainer ? this.renderGroup(group, drawContext, matrixAllocate.allocate(1, 0, 0, 1, 0, 0)) : this.renderItem(group, drawContext);
        }), context.restore(), context.setClearMatrix(1, 0, 0, 1, 0, 0), context.inuse = !1, context.draw();
      }
      doRegister() {
        throw new Error("暂不支持");
      }
      _findNextGraphic(group) {
        let parent = group.parent,
          id = group._uid;
        for (; parent;) {
          const g = findNextGraphic(parent, id, DefaultAttribute.zIndex);
          if (g) return g;
          id = parent._uid, parent = parent.parent;
        }
        return null;
      }
      renderGroup(group, drawContext, parentMatrix, skipSort) {
        if (drawContext.break || !1 === group.attribute.visibleAll) return;
        if (group.incremental && (null == drawContext.startAtId || drawContext.startAtId === group._uid)) return drawContext.break = !0, void this._increaseRender(group, drawContext);
        if (this.useDirtyBounds && !isRectIntersect(group.AABBBounds, this.dirtyBounds, !1) && "empty" !== group.attribute.boundsMode) return;
        let tempBounds,
          nextM = parentMatrix;
        if (this.useDirtyBounds) {
          tempBounds = boundsAllocate.allocateByObj(this.dirtyBounds);
          const gm = group.transMatrix;
          nextM = matrixAllocate.allocateByObj(parentMatrix).multiply(gm.a, gm.b, gm.c, gm.d, gm.e, gm.f), this.dirtyBounds.copy(this.backupDirtyBounds).transformWithMatrix(nextM.getInverse());
        }
        this.renderItem(group, drawContext, {
          drawingCb: () => {
            var _a;
            skipSort ? group.forEachChildren(item => {
              drawContext.break || (item.isContainer ? this.renderGroup(item, drawContext, nextM) : this.renderItem(item, drawContext));
            }) : foreach(group, DefaultAttribute.zIndex, item => {
              drawContext.break || (item.isContainer ? this.renderGroup(item, drawContext, nextM) : this.renderItem(item, drawContext));
            }, !1, !!(null === (_a = drawContext.context) || void 0 === _a ? void 0 : _a.camera));
          }
        }), this.useDirtyBounds && (this.dirtyBounds.copy(tempBounds), boundsAllocate.free(tempBounds), matrixAllocate.free(nextM));
      }
      _increaseRender(group, drawContext) {
        const {
            layer: layer,
            stage: stage
          } = drawContext,
          {
            subLayers: subLayers
          } = layer;
        let incrementalLayer = subLayers.get(group._uid);
        incrementalLayer || (incrementalLayer = {
          layer: this.layerService.createLayer(stage),
          zIndex: subLayers.size,
          group: group
        }, subLayers.set(group._uid, incrementalLayer));
        const incrementalContext = incrementalLayer.layer.getNativeHandler().getContext(),
          idc = incrementalLayer.drawContribution || container.get(IncrementalDrawContribution);
        idc.dirtyBounds.setValue(-1 / 0, -1 / 0, 1 / 0, 1 / 0), idc.backupDirtyBounds.setValue(-1 / 0, -1 / 0, 1 / 0, 1 / 0), idc.draw(this.currentRenderService, Object.assign(Object.assign({}, drawContext), {
          drawContribution: idc,
          clear: "transparent",
          layer: incrementalLayer.layer,
          context: incrementalContext,
          startAtId: group._uid,
          break: !1
        })), incrementalLayer.drawContribution = idc;
        const nextGraphic = this._findNextGraphic(group);
        if (nextGraphic) if (nextGraphic.isContainer && nextGraphic.incremental) this._increaseRender(nextGraphic, drawContext);else {
          let afterLayer = subLayers.get(nextGraphic._uid);
          afterLayer || (afterLayer = {
            layer: this.layerService.createLayer(stage),
            zIndex: subLayers.size
          }, subLayers.set(nextGraphic._uid, afterLayer));
          const afterContext = afterLayer.layer.getNativeHandler().getContext();
          this.draw(this.currentRenderService, Object.assign(Object.assign({}, drawContext), {
            drawContribution: idc,
            clear: "transparent",
            layer: afterLayer.layer,
            context: afterContext,
            startAtId: nextGraphic._uid,
            break: !1
          }));
        }
      }
      getRenderContribution(graphic) {
        let renderer;
        return renderer || (renderer = this.selectRenderByNumberType(graphic.numberType, graphic)), renderer || (renderer = this.selectRenderByType(graphic.type)), renderer;
      }
      renderItem(graphic, drawContext, params) {
        if (this.InterceptorContributions.length) for (let i = 0; i < this.InterceptorContributions.length; i++) {
          const drawContribution = this.InterceptorContributions[i];
          if (drawContribution.beforeDrawItem && drawContribution.beforeDrawItem(graphic, this.currentRenderService, drawContext, this, params)) return;
        }
        const renderer = this.getRenderContribution(graphic);
        if (!renderer) return;
        let tempBounds,
          retrans = this.scrollMatrix && (0 !== this.scrollMatrix.e || 0 !== this.scrollMatrix.f);
        if (graphic.parent) {
          const {
            scrollX = 0,
            scrollY = 0
          } = graphic.parent.attribute;
          (scrollX || scrollY) && (retrans = !0, this.scrollMatrix || (this.scrollMatrix = matrixAllocate.allocate(1, 0, 0, 1, 0, 0)), this.scrollMatrix.translate(-scrollX, -scrollY));
        }
        if (retrans && (tempBounds = this.dirtyBounds.clone().transformWithMatrix(this.scrollMatrix)), this.useDirtyBounds && !graphic.isContainer && "empty" !== graphic.attribute.boundsMode && !isRectIntersect(graphic.AABBBounds, null != tempBounds ? tempBounds : this.dirtyBounds, !1)) {
          if (retrans && graphic.parent) {
            const {
              scrollX = 0,
              scrollY = 0
            } = graphic.parent.attribute;
            this.scrollMatrix && this.scrollMatrix.translate(scrollX, scrollY);
          }
          return;
        }
        const skipDraw = null != drawContext.startAtId && graphic._uid !== drawContext.startAtId;
        if (graphic._uid === drawContext.startAtId && (drawContext.startAtId = null), params && (params.skipDraw = skipDraw), skipDraw ? graphic.isContainer && renderer.draw(graphic, this.currentRenderService, drawContext, params) : renderer.draw(graphic, this.currentRenderService, drawContext, params), retrans && graphic.parent) {
          const {
            scrollX = 0,
            scrollY = 0
          } = graphic.parent.attribute;
          this.scrollMatrix && this.scrollMatrix.translate(scrollX, scrollY);
        }
        if (this.InterceptorContributions.length) for (let i = 0; i < this.InterceptorContributions.length; i++) {
          const drawContribution = this.InterceptorContributions[i];
          if (drawContribution.afterDrawItem && drawContribution.afterDrawItem(graphic, this.currentRenderService, drawContext, this)) return;
        }
      }
      selectRenderByType(type) {
        return Logger$1.getInstance().warn("未知错误，不应该走到这里"), null;
      }
      selectRenderByNumberType(type, graphic) {
        let data;
        if (graphic.attribute.renderStyle) {
          const currentRenderMap = this.styleRenderMap.get(graphic.attribute.renderStyle);
          data = currentRenderMap && currentRenderMap.get(type);
        }
        return data || this.currentRenderMap.get(type) || this.defaultRenderMap.get(type);
      }
      clearScreen(renderService, context, drawContext) {
        var _a, _b;
        const {
            clear: clear,
            viewBox: viewBox
          } = drawContext,
          width = viewBox.width(),
          height = viewBox.height();
        if (clear) {
          context.clearRect(0, 0, width, height);
          const stage = null === (_a = renderService.drawParams) || void 0 === _a ? void 0 : _a.stage;
          if (stage && (context.globalAlpha = null !== (_b = stage.attribute.opacity) && void 0 !== _b ? _b : 1), stage && stage.backgroundImg && stage.resources) {
            const res = stage.resources.get(clear);
            res && "success" === res.state && res.data && context.drawImage(res.data, 0, 0, width, height);
          } else context.fillStyle = createColor(context, clear, {
            AABBBounds: {
              x1: 0,
              y1: 0,
              x2: 0 + width,
              y2: 0 + height
            }
          }, 0, 0), context.fillRect(0, 0, width, height);
        }
      }
      afterDraw(renderService, drawParams) {}
    };
    DefaultDrawContribution = __decorate$D([injectable(), __param$l(0, multiInject(GraphicRender)), __param$l(1, inject(ContributionProvider)), __param$l(1, named(DrawItemInterceptor)), __metadata$t("design:paramtypes", [Array, Object])], DefaultDrawContribution);

    var __decorate$C = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let DefaultIncrementalCanvasLineRender = class extends DefaultCanvasLineRender {
      constructor() {
        super(...arguments), this.numberType = LINE_NUMBER_TYPE;
      }
      drawShape(line, context, x, y, drawContext, params, fillCb, strokeCb) {
        if (line.incremental && drawContext.multiGraphicOptions) {
          const {
              startAtIdx: startAtIdx,
              length: length
            } = drawContext.multiGraphicOptions,
            {
              segments = []
            } = line.attribute;
          if (startAtIdx > segments.length) return;
          const lineAttribute = getTheme(line).line,
            {
              fill = lineAttribute.fill,
              stroke = lineAttribute.stroke,
              opacity = lineAttribute.opacity,
              fillOpacity = lineAttribute.fillOpacity,
              strokeOpacity = lineAttribute.strokeOpacity,
              lineWidth = lineAttribute.lineWidth,
              visible = lineAttribute.visible
            } = line.attribute,
            fVisible = fillVisible(opacity, fillOpacity, fill),
            sVisible = strokeVisible(opacity, strokeOpacity),
            doFill = runFill(fill),
            doStroke = runStroke(stroke, lineWidth);
          if (!line.valid || !visible) return;
          if (!doFill && !doStroke) return;
          if (!(fVisible || sVisible || fillCb || strokeCb)) return;
          const {
            context: context
          } = drawContext;
          for (let i = startAtIdx; i < startAtIdx + length; i++) this.drawIncreaseSegment(line, context, segments[i - 1], segments[i], line.attribute.segments[i], [lineAttribute, line.attribute], x, y);
        } else super.drawShape(line, context, x, y, drawContext, params, fillCb, strokeCb);
      }
      drawIncreaseSegment(line, context, lastSeg, seg, attribute, defaultAttribute, offsetX, offsetY) {
        seg && (context.beginPath(), drawIncrementalSegments(context.nativeContext, lastSeg, seg, {
          offsetX: offsetX,
          offsetY: offsetY
        }), context.setShadowBlendStyle && context.setShadowBlendStyle(line, attribute, defaultAttribute), context.setStrokeStyle(line, attribute, offsetX, offsetY, defaultAttribute), context.stroke());
      }
    };
    DefaultIncrementalCanvasLineRender = __decorate$C([injectable()], DefaultIncrementalCanvasLineRender);

    var __decorate$B = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let DefaultIncrementalCanvasAreaRender = class extends DefaultCanvasAreaRender {
      constructor() {
        super(...arguments), this.numberType = AREA_NUMBER_TYPE;
      }
      drawShape(area, context, x, y, drawContext, params, fillCb) {
        if (area.incremental && drawContext.multiGraphicOptions) {
          const {
              startAtIdx: startAtIdx,
              length: length
            } = drawContext.multiGraphicOptions,
            {
              segments = []
            } = area.attribute;
          if (startAtIdx > segments.length) return;
          const areaAttribute = getTheme(area).area,
            {
              fill = areaAttribute.fill,
              fillOpacity = areaAttribute.fillOpacity,
              opacity = areaAttribute.opacity,
              visible = areaAttribute.visible
            } = area.attribute,
            fVisible = fillVisible(opacity, fillOpacity, fill),
            doFill = runFill(fill);
          if (!area.valid || !visible) return;
          if (!doFill) return;
          if (!fVisible && !fillCb) return;
          for (let i = startAtIdx; i < startAtIdx + length; i++) this.drawIncreaseSegment(area, context, segments[i - 1], segments[i], area.attribute.segments[i], [areaAttribute, area.attribute], x, y);
        } else super.drawShape(area, context, x, y, drawContext, params, fillCb);
      }
      drawIncreaseSegment(area, context, lastSeg, seg, attribute, defaultAttribute, offsetX, offsetY) {
        seg && (context.beginPath(), drawIncrementalAreaSegments(context.camera ? context : context.nativeContext, lastSeg, seg, {
          offsetX: offsetX,
          offsetY: offsetY
        }), context.setShadowBlendStyle && context.setShadowBlendStyle(area, attribute, defaultAttribute), context.setCommonStyle(area, attribute, offsetX, offsetY, defaultAttribute), context.fill());
      }
    };
    DefaultIncrementalCanvasAreaRender = __decorate$B([injectable()], DefaultIncrementalCanvasAreaRender);

    var STATUS,
      __decorate$A = undefined && undefined.__decorate || function (decorators, target, key, desc) {
        var d,
          c = arguments.length,
          r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      },
      __metadata$s = undefined && undefined.__metadata || function (k, v) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
      },
      __param$k = undefined && undefined.__param || function (paramIndex, decorator) {
        return function (target, key) {
          decorator(target, key, paramIndex);
        };
      },
      __awaiter$2 = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator.throw(value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            var value;
            result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P(function (resolve) {
              resolve(value);
            })).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
    !function (STATUS) {
      STATUS[STATUS.NORMAL = 0] = "NORMAL", STATUS[STATUS.STOP = 1] = "STOP";
    }(STATUS || (STATUS = {}));
    let DefaultIncrementalDrawContribution = class extends DefaultDrawContribution {
      constructor(contributions, lineRender, areaRender, drawItemInterceptorContributions) {
        super(contributions, drawItemInterceptorContributions), this.contributions = contributions, this.lineRender = lineRender, this.areaRender = areaRender, this.drawItemInterceptorContributions = drawItemInterceptorContributions, this.rendering = !1, this.currFrameStartAt = 0, this.currentIdx = 0, this.status = STATUS.NORMAL, this.checkingForDrawPromise = null, this.hooks = {
          completeDraw: new SyncHook([])
        }, this.defaultRenderMap.set(this.lineRender.numberType, this.lineRender), this.defaultRenderMap.set(this.areaRender.numberType, this.areaRender);
      }
      draw(renderService, drawContext) {
        return __awaiter$2(this, void 0, void 0, function* () {
          if (this.checkingForDrawPromise) return;
          this.lastRenderService = renderService, this.lastDrawContext = drawContext, this.checkingForDrawPromise = this.checkForDraw(drawContext);
          const skipDraw = yield this.checkingForDrawPromise;
          if (this.checkingForDrawPromise = null, skipDraw) return;
          this.currentRenderService = renderService;
          const {
            context: context,
            viewBox: viewBox
          } = drawContext;
          context && (context.inuse = !0, context.clearMatrix(), context.setTransformForCurrent(!0), context.save(), drawContext.restartIncremental && this.clearScreen(this.currentRenderService, context, drawContext), context.translate(viewBox.x1, viewBox.y1, !0), context.save(), renderService.renderTreeRoots.sort((a, b) => {
            var _a, _b;
            return (null !== (_a = a.attribute.zIndex) && void 0 !== _a ? _a : DefaultAttribute.zIndex) - (null !== (_b = b.attribute.zIndex) && void 0 !== _b ? _b : DefaultAttribute.zIndex);
          }).forEach(group => {
            this.renderGroup(group, drawContext);
          }), this.hooks.completeDraw.tap("top-draw", () => {
            context.restore(), context.restore(), context.draw(), context.inuse = !1, this.rendering = !1;
          }));
        });
      }
      _increaseRender(group, drawContext) {
        return __awaiter$2(this, void 0, void 0, function* () {
          this.rendering = !0, yield this._renderIncrementalGroup(group, drawContext);
        });
      }
      _renderIncrementalGroup(group, drawContext) {
        return __awaiter$2(this, void 0, void 0, function* () {
          this.count = group.count, yield new Promise(resolve => {
            this.renderItem(group, drawContext, {
              drawingCb: () => __awaiter$2(this, void 0, void 0, function* () {
                if (2 !== group.count) yield foreachAsync(group, DefaultAttribute.zIndex, (item, i) => {
                  if (this.status === STATUS.STOP) return !0;
                  if (item.isContainer) return !1;
                  if (i < this.currentIdx) return !1;
                  const frameTail = this.currFrameStartAt + group.incremental;
                  return i < frameTail && (this.currentIdx = i + 1, this.renderItem(item, drawContext)), i === frameTail - 1 && (this.currFrameStartAt = this.currentIdx, this.waitToNextFrame());
                }), resolve(!1);else {
                  const graphic = group.getChildAt(0);
                  if (graphic.incremental && graphic.attribute.segments) for (graphic.incrementalAt || (graphic.incrementalAt = 0); graphic.incrementalAt < graphic.attribute.segments.length;) drawContext.multiGraphicOptions = {
                    startAtIdx: graphic.incrementalAt,
                    length: graphic.incremental
                  }, this.renderItem(graphic, drawContext), graphic.incrementalAt += graphic.incremental, yield this.waitToNextFrame();else this.renderItem(graphic, drawContext);
                  resolve(!1);
                }
              })
            });
          }), this.hooks.completeDraw.call();
        });
      }
      waitToNextFrame() {
        return __awaiter$2(this, void 0, void 0, function* () {
          return new Promise(resolve => {
            this.global.getRequestAnimationFrame()(() => {
              resolve(!1);
            });
          });
        });
      }
      checkForDraw(drawContext) {
        return __awaiter$2(this, void 0, void 0, function* () {
          let skip = this.rendering;
          return drawContext.restartIncremental && (skip = !1, yield this.forceStop(), this.resetToInit()), skip;
        });
      }
      forceStop() {
        return __awaiter$2(this, void 0, void 0, function* () {
          this.rendering && (this.status = STATUS.STOP, yield new Promise(resolve => {
            this.hooks.completeDraw.tap("stopCb", () => {
              this.status = STATUS.NORMAL, this.hooks.completeDraw.taps = this.hooks.completeDraw.taps.filter(item => "stopCb" !== item.name), resolve(!1);
            });
          }));
        });
      }
      resetToInit() {
        this.currFrameStartAt = 0, this.currentIdx = 0;
      }
      renderGroup(group, drawContext) {
        return __awaiter$2(this, void 0, void 0, function* () {
          if (!drawContext.break && !1 !== group.attribute.visibleAll) return group.incremental && drawContext.startAtId === group._uid ? (yield this._increaseRender(group, drawContext), void (drawContext.break = !0)) : void (yield new Promise(resolve => {
            this.renderItem(group, drawContext, {
              drawingCb: () => __awaiter$2(this, void 0, void 0, function* () {
                yield foreachAsync(group, DefaultAttribute.zIndex, item => __awaiter$2(this, void 0, void 0, function* () {
                  drawContext.break || item.isContainer && (yield this.renderGroup(item, drawContext));
                })), resolve(!1);
              })
            });
          }));
        });
      }
    };
    DefaultIncrementalDrawContribution = __decorate$A([injectable(), __param$k(0, multiInject(GraphicRender)), __param$k(1, inject(DefaultIncrementalCanvasLineRender)), __param$k(2, inject(DefaultIncrementalCanvasAreaRender)), __param$k(3, inject(ContributionProvider)), __param$k(3, named(DrawItemInterceptor)), __metadata$s("design:paramtypes", [Array, Object, Object, Object])], DefaultIncrementalDrawContribution);

    var renderModule = new ContainerModule(bind => {
      bind(DefaultBaseBackgroundRenderContribution).toSelf().inSingletonScope(), bind(DefaultBaseTextureRenderContribution).toSelf().inSingletonScope(), bind(DrawContribution).to(DefaultDrawContribution), bind(IncrementalDrawContribution).to(DefaultIncrementalDrawContribution), bind(GroupRender).to(DefaultCanvasGroupRender).inSingletonScope(), bind(GraphicRender).toService(GroupRender), bindContributionProvider(bind, GroupRenderContribution), bind(DefaultBaseInteractiveRenderContribution).toSelf().inSingletonScope(), bindContributionProvider(bind, InteractiveSubRenderContribution), bindContributionProvider(bind, GraphicRender), bind(CommonDrawItemInterceptorContribution).toSelf().inSingletonScope(), bind(DrawItemInterceptor).toService(CommonDrawItemInterceptorContribution), bindContributionProvider(bind, DrawItemInterceptor);
    });

    function load(container) {
      container.load(renderModule);
    }

    function preLoadAllModule() {
      preLoadAllModule.__loaded || (preLoadAllModule.__loaded = !0, container.load(coreModule), container.load(graphicModule), container.load(renderModule$1), container.load(pickModule), container.load(pluginModule), load$1(container), load(container));
    }
    preLoadAllModule.__loaded = !1, preLoadAllModule();
    const vglobal = container.get(VGlobal);
    application.global = vglobal;
    const graphicUtil = container.get(GraphicUtil);
    application.graphicUtil = graphicUtil;
    const transformUtil = container.get(TransformUtil);
    application.transformUtil = transformUtil;
    const graphicService = container.get(GraphicService);
    application.graphicService = graphicService;
    const layerService = container.get(LayerService);
    application.layerService = layerService;

    class AutoRenderPlugin {
      constructor() {
        this.name = "AutoRenderPlugin", this.activeEvent = "onRegister", this._uid = Generator.GenAutoIncrementId(), this.key = this.name + this._uid, this.handleChange = graphic => {
          graphic.glyphHost && (graphic = graphic.glyphHost), graphic.stage === this.pluginService.stage && null != graphic.stage && graphic.stage.renderNextFrame();
        };
      }
      activate(context) {
        this.pluginService = context, application.graphicService.hooks.onAttributeUpdate.tap(this.key, this.handleChange), application.graphicService.hooks.onSetStage.tap(this.key, this.handleChange), application.graphicService.hooks.onRemove.tap(this.key, this.handleChange);
      }
      deactivate(context) {
        const filterByName = taps => taps.filter(item => item.name !== this.key);
        application.graphicService.hooks.onAttributeUpdate.taps = filterByName(application.graphicService.hooks.onAttributeUpdate.taps), application.graphicService.hooks.onSetStage.taps = filterByName(application.graphicService.hooks.onSetStage.taps), application.graphicService.hooks.onRemove.taps = filterByName(application.graphicService.hooks.onRemove.taps);
      }
    }

    class AutoRefreshPlugin {
      constructor() {
        this.name = "AutoRefreshPlugin", this.activeEvent = "onRegister", this._uid = Generator.GenAutoIncrementId(), this.key = this.name + this._uid, this.handleChange = graphic => {
          graphic.glyphHost && (graphic = graphic.glyphHost), graphic.stage === this.pluginService.stage && null != graphic.stage && graphic.stage.renderNextFrame();
        };
      }
      activate(context) {
        this.pluginService = context, this.dpr = application.global.devicePixelRatio, this.refresh();
      }
      refresh() {
        this._refreshByMediaQuery() || this._refreshByRaf();
      }
      _refreshByRaf() {
        const raf = application.global.getRequestAnimationFrame();
        this.rafId = raf(() => {
          application.global.devicePixelRatio !== this.dpr && (this.dpr = application.global.devicePixelRatio, this.pluginService.stage.setDpr(this.dpr, !0)), this.refresh();
        });
      }
      _refreshByMediaQuery() {
        try {
          const mqString = `(resolution: ${window.devicePixelRatio}dppx)`,
            updatePixelRatio = () => {
              window.devicePixelRatio !== this.dpr && (this.dpr = window.devicePixelRatio, this.pluginService.stage.setDpr(this.dpr, !0));
            },
            dom = matchMedia(mqString);
          dom && dom.addEventListener("change", updatePixelRatio), this.autoRefreshCbs || (this.autoRefreshCbs = []), this.autoRefreshCbs.push(() => {
            dom && dom.removeEventListener("change", updatePixelRatio);
          });
        } catch (err) {
          return !1;
        }
        return !0;
      }
      deactivate(context) {
        var _a;
        const craf = application.global.getCancelAnimationFrame();
        craf && this.rafId && craf(this.rafId), null === (_a = this.autoRefreshCbs) || void 0 === _a || _a.forEach(cb => {
          cb();
        }), this.autoRefreshCbs = void 0;
      }
    }

    class IncrementalAutoRenderPlugin {
      constructor() {
        this.name = "IncrementalAutoRenderPlugin", this.activeEvent = "onRegister", this.nextFrameRenderGroupSet = new Set(), this.willNextFrameRender = !1, this.nextUserParams = {}, this._uid = Generator.GenAutoIncrementId(), this.key = this.name + this._uid;
      }
      activate(context) {
        this.pluginService = context, application.graphicService.hooks.onAddIncremental.tap(this.key, (graphic, group, stage) => {
          graphic.glyphHost && (graphic = graphic.glyphHost), graphic.stage === context.stage && null != graphic.stage && (this.nextUserParams.startAtId = group._uid, this.renderNextFrame(group));
        }), application.graphicService.hooks.onClearIncremental.tap(this.key, (group, stage) => {
          group.stage === context.stage && null != group.stage && (this.nextUserParams.startAtId = group._uid, this.nextUserParams.restartIncremental = !0, this.renderNextFrame(group));
        });
      }
      deactivate(context) {
        application.graphicService.hooks.onAddIncremental.taps = application.graphicService.hooks.onAddIncremental.taps.filter(item => item.name !== this.key), application.graphicService.hooks.onClearIncremental.taps = application.graphicService.hooks.onClearIncremental.taps.filter(item => item.name !== this.key);
      }
      renderNextFrame(group) {
        this.nextFrameRenderGroupSet.add(group), this.willNextFrameRender || (this.willNextFrameRender = !0, application.global.getRequestAnimationFrame()(() => {
          this._doRenderInThisFrame(), this.willNextFrameRender = !1;
        }));
      }
      _doRenderInThisFrame() {
        const stage = this.pluginService.stage;
        this.nextFrameRenderGroupSet.size && (this.nextFrameRenderGroupSet.forEach(group => {
          const layer = group.layer;
          if (!layer || !group.layer.subLayers) return;
          const subLayer = group.layer.subLayers.get(group._uid);
          subLayer && subLayer.drawContribution && subLayer.drawContribution.draw(stage.renderService, Object.assign({
            stage: stage,
            layer: layer,
            viewBox: stage.window.getViewBox(),
            transMatrix: stage.window.getViewBoxTransform(),
            clear: "transparent",
            renderService: stage.renderService,
            updateBounds: !1,
            startAtId: group._uid,
            context: subLayer.layer.getNativeHandler().getContext()
          }, this.nextUserParams));
        }), this.nextUserParams = {}, this.nextFrameRenderGroupSet.clear());
      }
    }

    const globalBounds = new AABBBounds$1();
    class DirtyBoundsPlugin {
      constructor() {
        this.name = "DirtyBoundsPlugin", this.activeEvent = "onRegister", this._uid = Generator.GenAutoIncrementId(), this.key = this.name + this._uid;
      }
      activate(context) {
        this.pluginService = context, context.stage.hooks.afterRender.tap(this.key, stage => {
          stage && stage === this.pluginService.stage && stage.dirtyBounds.clear();
        }), application.graphicService.hooks.beforeUpdateAABBBounds.tap(this.key, (graphic, stage, willUpdate, bounds) => {
          graphic.glyphHost && (graphic = graphic.glyphHost), stage && stage === this.pluginService.stage && stage.renderCount && (graphic.isContainer && !graphic.shouldSelfChangeUpdateAABBBounds() || willUpdate && (globalBounds.setValue(bounds.x1, bounds.y1, bounds.x2, bounds.y2), stage.dirty(globalBounds, graphic.parent && graphic.parent.globalTransMatrix)));
        }), application.graphicService.hooks.afterUpdateAABBBounds.tap(this.key, (graphic, stage, bounds, params, selfChange) => {
          stage && stage === this.pluginService.stage && stage.renderCount && (graphic.isContainer && !selfChange || stage.dirty(params.globalAABBBounds));
        }), application.graphicService.hooks.clearAABBBounds.tap(this.key, (graphic, stage, bounds) => {
          stage && stage === this.pluginService.stage && stage.renderCount && stage && stage.dirty(bounds);
        }), application.graphicService.hooks.onRemove.tap(this.key, graphic => {
          const stage = graphic.stage;
          stage && stage === this.pluginService.stage && stage.renderCount && stage && stage.dirty(graphic.globalAABBBounds);
        });
      }
      deactivate(context) {
        application.graphicService.hooks.beforeUpdateAABBBounds.taps = application.graphicService.hooks.beforeUpdateAABBBounds.taps.filter(item => item.name !== this.key), application.graphicService.hooks.afterUpdateAABBBounds.taps = application.graphicService.hooks.afterUpdateAABBBounds.taps.filter(item => item.name !== this.key), application.graphicService.hooks.clearAABBBounds.taps = application.graphicService.hooks.clearAABBBounds.taps.filter(item => item.name !== this.key), context.stage.hooks.afterRender.taps = context.stage.hooks.afterRender.taps.filter(item => item.name !== this.key), application.graphicService.hooks.onRemove.taps = application.graphicService.hooks.onRemove.taps.filter(item => item.name !== this.key);
      }
    }

    const defaultTicker = new DefaultTicker();
    defaultTicker.addTimeline(defaultTimeline);
    defaultTicker.setFPS(60);

    let _isBrowserEnv;
    function initIsBrowserEnv() {
      if (null == _isBrowserEnv) try {
        const canvas = document.createElement("canvas"),
          ctx = canvas.getContext("2d");
        _isBrowserEnv = !!(window && canvas.getBoundingClientRect && requestAnimationFrame && window.devicePixelRatio && ctx && ctx.isPointInPath && ctx.isPointInStroke), _isBrowserEnv && (_isBrowserEnv = !!document.createElement);
      } catch (err) {
        _isBrowserEnv = !1;
      }
    }
    function isBrowserEnv() {
      initIsBrowserEnv();
      const env = application.global && application.global.env;
      return env ? "browser" === env : _isBrowserEnv;
    }
    function isNodeEnv() {
      initIsBrowserEnv();
      const env = application.global && application.global.env;
      return env ? "node" === env : !_isBrowserEnv;
    }

    let Factory$1 = class Factory {
      static registerPlugin(pluginKey, pluginClass) {
        Factory._pluginClasses[pluginKey] = pluginClass;
      }
      static getPlugin(pluginKey) {
        return Factory._pluginClasses[pluginKey];
      }
    };
    Factory$1._pluginClasses = {};

    const DefaultConfig$1 = {
      WIDTH: 500,
      HEIGHT: 500,
      X: 0,
      Y: 0,
      BACKGROUND: "white"
    };
    class Stage extends Group$2 {
      set viewBox(b) {
        this.window.setViewBox(b);
      }
      get viewBox() {
        return this.window.getViewBox();
      }
      get x() {
        return this.window.getViewBox().x1;
      }
      set x(x) {
        const b = this.window.getViewBox();
        b.translate(x - b.x1, 0), this.window.setViewBox(b);
      }
      get y() {
        return this.window.getViewBox().y1;
      }
      set y(y) {
        const b = this.window.getViewBox();
        b.translate(0, y - b.y1), this.window.setViewBox(b);
      }
      get width() {
        return this.window.width;
      }
      set width(w) {
        this.resize(w, this.height);
      }
      get viewWidth() {
        return this.window.getViewBox().width();
      }
      set viewWidth(w) {
        this.resizeView(w, this.viewHeight);
      }
      get viewHeight() {
        return this.window.getViewBox().height();
      }
      set viewHeight(h) {
        this.resizeView(this.viewWidth, h);
      }
      get height() {
        return this.window.height;
      }
      set height(h) {
        this.resize(this.width, h);
      }
      get dpr() {
        return this.window.dpr;
      }
      set dpr(r) {
        this.setDpr(r);
      }
      get background() {
        var _a;
        return null !== (_a = this._background) && void 0 !== _a ? _a : DefaultConfig$1.BACKGROUND;
      }
      set background(b) {
        this._background = b;
      }
      get defaultLayer() {
        return this.at(0);
      }
      get eventSystem() {
        return this._eventSystem;
      }
      constructor() {
        let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var _a;
        super({}), this.tickedBeforeRender = !0, this._onVisibleChange = visible => {
          if (!(this._skipRender < 0)) if (visible) {
            if (this.dirtyBounds) {
              const b = this.window.getViewBox();
              this.dirtyBounds.setValue(b.x1, b.y1, b.width(), b.height());
            }
            this._skipRender > 1 && this.renderNextFrame(), this._skipRender = 0;
          } else this._skipRender = 1;
        }, this.beforeRender = stage => {
          this._beforeRender && this._beforeRender(stage);
        }, this.afterRender = stage => {
          this.renderCount++, this._afterRender && this._afterRender(stage), this._afterNextRenderCbs && this._afterNextRenderCbs.forEach(cb => cb(stage)), this._afterNextRenderCbs = null, this.tickedBeforeRender = !1;
        }, this.afterTickCb = () => {
          var _a;
          this.tickedBeforeRender = !0, "performance" === (null === (_a = this.params.optimize) || void 0 === _a ? void 0 : _a.tickRenderMode) || "rendering" !== this.state && this.render();
        }, this.params = params, this.theme = new Theme(), this.hooks = {
          beforeRender: new SyncHook(["stage"]),
          afterRender: new SyncHook(["stage"])
        }, this.global = application.global, !this.global.env && isBrowserEnv() && this.global.setEnv("browser"), this.window = container.get(VWindow), this.renderService = container.get(RenderService), this.pluginService = container.get(PluginService), this.layerService = container.get(LayerService), this.pluginService.active(this, params), this.window.create({
          width: params.width,
          height: params.height,
          viewBox: params.viewBox,
          container: params.container,
          dpr: params.dpr || this.global.devicePixelRatio,
          canvasControled: !1 !== params.canvasControled,
          title: params.title || "",
          canvas: params.canvas
        }), this.state = "normal", this.renderCount = 0, this.tryInitEventSystem(), this._background = null !== (_a = params.background) && void 0 !== _a ? _a : DefaultConfig$1.BACKGROUND, this.appendChild(this.layerService.createLayer(this, {
          main: !0
        })), this.nextFrameRenderLayerSet = new Set(), this.willNextFrameRender = !1, this.stage = this, this.renderStyle = params.renderStyle, params.autoRender && this.enableAutoRender(), params.autoRefresh && this.enableAutoRefresh(), !1 === params.disableDirtyBounds && this.enableDirtyBounds(), params.enableHtmlAttribute && this.enableHtmlAttribute(params.enableHtmlAttribute), params.ReactDOM && this.enableReactAttribute(params.ReactDOM), params.enableLayout && this.enableLayout(), this.hooks.beforeRender.tap("constructor", this.beforeRender), this.hooks.afterRender.tap("constructor", this.afterRender), this._beforeRender = params.beforeRender, this._afterRender = params.afterRender, this.ticker = params.ticker || defaultTicker, this.supportInteractiveLayer = !1 !== params.interactiveLayer, this.timeline = new DefaultTimeline(), this.ticker.addTimeline(this.timeline), this.timeline.pause(), params.optimize || (params.optimize = {}), this.optmize(params.optimize), params.background && isString$6(this._background) && this._background.includes("/") && this.setAttributes({
          background: this._background
        }), this.ticker.on("afterTick", this.afterTickCb);
      }
      pauseRender() {
        let sr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;
        this._skipRender = sr;
      }
      resumeRender() {
        this._skipRender = 0;
      }
      tryInitEventSystem() {
        this.global.supportEvent && !this._eventSystem && (this._eventSystem = new EventSystem(Object.assign({
          targetElement: this.window,
          resolution: this.window.dpr || this.global.devicePixelRatio,
          rootNode: this,
          global: this.global,
          supportsPointerEvents: this.params.supportsPointerEvents,
          supportsTouchEvents: this.params.supportsTouchEvents
        }, this.params.event)));
      }
      preventRender(prevent) {
        prevent ? this._skipRender = -1 / 0 : !1 !== this.params.optimize.skipRenderWithOutRange ? this._skipRender = this.window.isVisible() ? 0 : 1 : this._skipRender = 0;
      }
      optmize(params) {
        this.optmizeRender(params.skipRenderWithOutRange), this.params.optimize = params;
      }
      optmizeRender() {
        let skipRenderWithOutRange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !1;
        skipRenderWithOutRange && (this._skipRender = this._skipRender < 0 ? this._skipRender : this.window.isVisible() ? 0 : 1, this.window.onVisibleChange(this._onVisibleChange));
      }
      getTimeline() {
        return this.timeline;
      }
      get3dOptions(options) {
        const {
          center = {
            x: this.width / 2,
            y: this.height / 2,
            z: 0,
            dx: 0,
            dy: 0,
            dz: 0
          },
          light = {},
          alpha = 0,
          beta = 0,
          camera: camera,
          fieldRatio = 1,
          fieldDepth: fieldDepth
        } = options;
        return Object.assign(Object.assign({}, options), {
          center: center,
          light: light,
          alpha: alpha,
          beta: beta,
          camera: camera,
          fieldRatio: fieldRatio,
          fieldDepth: fieldDepth
        });
      }
      set3dOptions(options) {
        var _a, _b, _d, _e, _f, _g;
        this.option3d = options;
        const options3d = this.get3dOptions(options),
          {
            light: light,
            center: center,
            camera: camera,
            alpha: alpha,
            beta: beta,
            fieldRatio: fieldRatio,
            fieldDepth: fieldDepth
          } = options3d,
          {
            dir = [1, 1, -1],
            color = "white",
            ambient: ambient
          } = light,
          centerX = (null !== (_a = center.x) && void 0 !== _a ? _a : this.width / 2) + (null !== (_b = center.dx) && void 0 !== _b ? _b : 0),
          centerY = (null !== (_d = center.y) && void 0 !== _d ? _d : this.height / 2) + (null !== (_e = center.dy) && void 0 !== _e ? _e : 0),
          centerVec3 = [centerX, centerY, (null !== (_f = center.z) && void 0 !== _f ? _f : 0) + (null !== (_g = center.dz) && void 0 !== _g ? _g : 0)];
        let cameraX = 0,
          cameraY = 0,
          cameraZ = 0;
        camera || (cameraX = Math.sin(alpha) + centerX, cameraY = Math.sin(beta) + centerY, cameraZ = Math.cos(alpha) * Math.cos(beta) * 1);
        const DirectionalLight = Factory$1.getPlugin("DirectionalLight");
        DirectionalLight && (this.light = new DirectionalLight(dir, color, ambient));
        const cameraParams = {
          left: 0,
          right: this.width,
          top: 0,
          bottom: this.height,
          fieldRatio: fieldRatio,
          fieldDepth: fieldDepth,
          viewParams: {
            pos: [cameraX, cameraY, cameraZ],
            center: centerVec3,
            up: [0, 1, 0]
          }
        };
        if (this.camera) this.camera.params = cameraParams;else {
          const OrthoCamera = Factory$1.getPlugin("OrthoCamera");
          OrthoCamera && (this.camera = new OrthoCamera(cameraParams));
        }
        options.enableView3dTransform && this.enableView3dTransform();
      }
      setBeforeRender(cb) {
        this._beforeRender = cb;
      }
      setAfterRender(cb) {
        this._afterRender = cb;
      }
      afterNextRender(cb) {
        this._afterNextRenderCbs || (this._afterNextRenderCbs = []), this._afterNextRenderCbs.push(cb);
      }
      enableView3dTransform() {
        if (this.view3dTranform) return;
        this.view3dTranform = !0;
        const ViewTransform3dPlugin = Factory$1.getPlugin("ViewTransform3dPlugin");
        ViewTransform3dPlugin && this.pluginService.register(new ViewTransform3dPlugin());
      }
      disableView3dTranform() {
        this.view3dTranform && (this.view3dTranform = !1, this.pluginService.findPluginsByName("ViewTransform3dPlugin").forEach(plugin => {
          this.pluginService.unRegister(plugin);
        }));
      }
      enableAutoRender() {
        this.autoRender || (this.autoRender = !0, this.pluginService.register(new AutoRenderPlugin()));
      }
      disableAutoRender() {
        this.autoRender && (this.autoRender = !1, this.pluginService.findPluginsByName("AutoRenderPlugin").forEach(plugin => {
          this.pluginService.unRegister(plugin);
        }));
      }
      enableAutoRefresh() {
        this.autoRefresh || (this.autoRefresh = !0, this.pluginService.register(new AutoRefreshPlugin()));
      }
      disableAutoRefresh() {
        this.autoRefresh && (this.autoRefresh = !1, this.pluginService.findPluginsByName("AutoRefreshPlugin").forEach(plugin => {
          this.pluginService.unRegister(plugin);
        }));
      }
      enableIncrementalAutoRender() {
        this.increaseAutoRender || (this.increaseAutoRender = !0, this.pluginService.register(new IncrementalAutoRenderPlugin()));
      }
      disableIncrementalAutoRender() {
        this.increaseAutoRender && (this.increaseAutoRender = !1, this.pluginService.findPluginsByName("IncrementalAutoRenderPlugin").forEach(plugin => {
          this.pluginService.unRegister(plugin);
        }));
      }
      enableDirtyBounds() {
        if (this.dirtyBounds) return;
        this.dirtyBounds = new Bounds$1();
        let plugin = this.pluginService.findPluginsByName("DirtyBoundsPlugin")[0];
        plugin ? plugin.activate(this.pluginService) : (plugin = new DirtyBoundsPlugin(), this.pluginService.register(plugin));
      }
      disableDirtyBounds() {
        this.dirtyBounds && (this.dirtyBounds = null, this.pluginService.findPluginsByName("DirtyBoundsPlugin").forEach(plugin => {
          this.pluginService.unRegister(plugin);
        }));
      }
      enableLayout() {
        if (this._enableLayout) return;
        this._enableLayout = !0;
        const FlexLayoutPlugin = Factory$1.getPlugin("FlexLayoutPlugin");
        FlexLayoutPlugin && this.pluginService.register(new FlexLayoutPlugin());
      }
      disableLayout() {
        this._enableLayout && (this._enableLayout = !1, this.pluginService.findPluginsByName("FlexLayoutPlugin").forEach(plugin => {
          this.pluginService.unRegister(plugin);
        }));
      }
      enableHtmlAttribute(container) {
        if (this.htmlAttribute) return;
        const HtmlAttributePlugin = Factory$1.getPlugin("HtmlAttributePlugin");
        HtmlAttributePlugin && (this.htmlAttribute = container, this.pluginService.register(new HtmlAttributePlugin()));
      }
      disableHtmlAttribute() {
        this.htmlAttribute && (this.htmlAttribute = !1, this.pluginService.findPluginsByName("HtmlAttributePlugin").forEach(plugin => {
          this.pluginService.unRegister(plugin);
        }));
      }
      enableReactAttribute(container) {
        if (this.reactAttribute) return;
        const ReactAttributePlugin = Factory$1.getPlugin("ReactAttributePlugin");
        ReactAttributePlugin && (this.reactAttribute = container, this.pluginService.register(new ReactAttributePlugin()));
      }
      disableReactAttribute() {
        this.reactAttribute && (this.reactAttribute = !1, this.pluginService.findPluginsByName("ReactAttributePlugin").forEach(plugin => {
          this.pluginService.unRegister(plugin);
        }));
      }
      getPluginsByName(name) {
        return this.pluginService.findPluginsByName(name);
      }
      tryUpdateAABBBounds() {
        const viewBox = this.window.getViewBox();
        return this._AABBBounds.setValue(viewBox.x1, viewBox.y1, viewBox.x2, viewBox.y2), this._AABBBounds;
      }
      combineLayer(ILayer1, ILayer2) {
        throw new Error("暂不支持");
      }
      createLayer(canvasId, layerMode) {
        if ("released" === this.releaseStatus) return;
        const layer = this.layerService.createLayer(this, {
          main: !1,
          layerMode: layerMode,
          canvasId: canvasId
        });
        return this.appendChild(layer), layer;
      }
      sortLayer(cb) {
        const children = this.children;
        children.sort(cb), this.removeAllChild(), children.forEach(c => {
          this.appendChild(c);
        });
      }
      removeLayer(ILayerId) {
        return this.removeChild(this.findChildByUid(ILayerId));
      }
      tryInitInteractiveLayer() {
        "released" !== this.releaseStatus && this.supportInteractiveLayer && !this.interactiveLayer && (this.interactiveLayer = this.createLayer(), this.interactiveLayer.name = "_builtin_interactive", this.interactiveLayer.attribute.pickable = !1, this.nextFrameRenderLayerSet.add(this.interactiveLayer));
      }
      clearViewBox(color) {
        this.window.clearViewBox(color);
      }
      render(layers, params) {
        if ("released" === this.releaseStatus) return;
        this.ticker.start(), this.timeline.resume();
        const state = this.state;
        this.state = "rendering", this.tickedBeforeRender || this.ticker.trySyncTickStatus(), this.layerService.prepareStageLayer(this), this._skipRender || (this.lastRenderparams = params, this.hooks.beforeRender.call(this), this._skipRender || (this.renderLayerList(this.children), this.combineLayersToWindow(), this.nextFrameRenderLayerSet.clear()), this.hooks.afterRender.call(this)), this.state = state, this._skipRender && this._skipRender++;
      }
      combineLayersToWindow() {
        if ("harmony" === this.global.env) {
          const ctx = this.window.getContext().nativeContext;
          this.forEachChildren((layer, i) => {
            if (i > 0) {
              const image = layer.getNativeHandler().getContext().canvas.nativeCanvas.nativeCanvas._c.transferToImageBitmap();
              ctx.transferFromImageBitmap(image);
            }
          });
        }
      }
      renderNextFrame(layers, force) {
        this.nextFrameRenderLayerSet.size !== this.childrenCount && (layers || this).forEach(layer => {
          this.nextFrameRenderLayerSet.add(layer);
        }), this.willNextFrameRender || (this.willNextFrameRender = !0, this.global.getRequestAnimationFrame()(() => {
          this._doRenderInThisFrame(), this.willNextFrameRender = !1;
        }));
      }
      _doRenderInThisFrame() {
        if ("released" === this.releaseStatus) return;
        this.timeline.resume(), this.ticker.start();
        const state = this.state;
        this.state = "rendering", this.layerService.prepareStageLayer(this), this.nextFrameRenderLayerSet.size && !this._skipRender && (this.hooks.beforeRender.call(this), this._skipRender || (this.renderLayerList(Array.from(this.nextFrameRenderLayerSet.values()), this.lastRenderparams || {}), this.combineLayersToWindow(), this.nextFrameRenderLayerSet.clear()), this.hooks.afterRender.call(this)), this.state = state, this._skipRender && this._skipRender++;
      }
      renderLayerList(layerList, params) {
        const list = [];
        for (let i = 0; i < layerList.length; i++) {
          let l = layerList[i];
          "virtual" === l.layerMode && (l = l.getNativeHandler().mainHandler.layer), list.includes(l) || list.push(l);
        }
        list.forEach(layer => {
          layer.renderCount > this.renderCount || (layer.renderCount = this.renderCount + 1, layer === this.interactiveLayer && this.dirtyBounds && this.dirtyBounds.clear(), layer.render({
            renderService: this.renderService,
            background: layer === this.defaultLayer ? this.background : void 0,
            updateBounds: !(!this.dirtyBounds || this.dirtyBounds.empty()),
            viewBox: this.window.getViewBox(),
            transMatrix: this.window.getViewBoxTransform()
          }, Object.assign({
            renderStyle: this.renderStyle
          }, params)));
        }), this.interactiveLayer && !layerList.includes(this.interactiveLayer) && (this.dirtyBounds && this.dirtyBounds.clear(), this.interactiveLayer.render({
          renderService: this.renderService,
          updateBounds: !(!this.dirtyBounds || this.dirtyBounds.empty()),
          viewBox: this.window.getViewBox(),
          transMatrix: this.window.getViewBoxTransform()
        }, Object.assign({
          renderStyle: this.renderStyle
        }, params)));
      }
      resizeWindow(w, h) {
        let rerender = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !0;
        this.window.resize(w, h), rerender && this.render();
      }
      resize(w, h) {
        let rerender = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !0;
        "released" !== this.releaseStatus && (this.window.hasSubView() || this.viewBox.setValue(this.viewBox.x1, this.viewBox.y1, this.viewBox.x1 + w, this.viewBox.y1 + h), this.window.resize(w, h), this.forEachChildren(c => {
          c.resize(w, h);
        }), this.camera && this.option3d && this.set3dOptions(this.option3d), rerender && this.render());
      }
      resizeView(w, h) {
        let rerender = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !0;
        "released" !== this.releaseStatus && (this.viewBox.setValue(this.viewBox.x1, this.viewBox.y1, this.viewBox.x1 + w, this.viewBox.y1 + h), this.forEachChildren(c => {
          c.resizeView(w, h);
        }), this.camera && (this.camera.params = Object.assign(Object.assign({}, this.camera.params), {
          right: this.width,
          bottom: this.height
        })), rerender && this.render());
      }
      setViewBox(x, y, w, h, rerender) {
        let isRerender = !0;
        "object" == typeof x ? (this.viewBox.setValue(x.x1, x.y1, x.x2, x.y2), !1 === y && (isRerender = !1)) : (this.viewBox.setValue(x, y, x + w, y + h), !1 === rerender && (isRerender = !1)), this.forEachChildren(c => {
          c.resizeView(this.viewBox.width(), this.viewBox.height());
        }), isRerender && this.render();
      }
      setDpr(dpr) {
        let rerender = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
        this.forEachChildren(c => {
          c.setDpr(dpr);
        }), rerender && this.render();
      }
      setOrigin(x, y) {
        throw new Error("暂不支持");
      }
      export(type) {
        throw new Error("暂不支持");
      }
      pick(x, y) {
        if ("released" === this.releaseStatus) return;
        const result = this.getPickerService().pick(this.children, new Point(x, y), {
          bounds: this.AABBBounds
        });
        return !(!(null == result ? void 0 : result.graphic) && !(null == result ? void 0 : result.group)) && result;
      }
      startAnimate(t) {
        throw new Error("暂不支持");
      }
      setToFrame(t) {
        throw new Error("暂不支持");
      }
      release() {
        super.release(), this.hooks.beforeRender.unTap("constructor", this.beforeRender), this.hooks.afterRender.unTap("constructor", this.afterRender), this.eventSystem && this.eventSystem.release(), this.layerService.releaseStage(this), this.pluginService.release(), this.forEach(layer => {
          layer.release();
        }), this.interactiveLayer && (this.interactiveLayer.forEachChildren(item => {
          item.setStage && item.setStage(null, null), this.interactiveLayer.removeChild(item);
        }), this.interactiveLayer.release()), this.window.release(), this.ticker.remTimeline(this.timeline), this.ticker.removeListener("afterTick", this.afterTickCb), this.renderService.renderTreeRoots = [];
      }
      setStage(stage) {}
      dirty(b, matrix) {
        "released" !== this.releaseStatus && (matrix && b.transformWithMatrix(matrix), this.dirtyBounds.empty() && this.dirtyBounds.setValue(b.x1, b.y1, b.x2, b.y2), this.dirtyBounds.union(b));
      }
      getLayer(name) {
        return this.children.filter(layer => layer.name === name)[0];
      }
      renderTo(window) {
        "released" !== this.releaseStatus && this.forEachChildren((layer, i) => {
          layer.drawTo(window, {
            renderService: this.renderService,
            viewBox: window.getViewBox(),
            transMatrix: window.getViewBoxTransform(),
            background: layer === this.defaultLayer ? this.background : void 0,
            clear: 0 === i,
            updateBounds: !(!this.dirtyBounds || this.dirtyBounds.empty())
          });
        });
      }
      renderToNewWindow() {
        let viewBox = arguments.length > 1 ? arguments[1] : undefined;
        if ("released" === this.releaseStatus) return;
        const window = container.get(VWindow),
          x1 = viewBox ? -viewBox.x1 : 0,
          y1 = viewBox ? -viewBox.y1 : 0,
          x2 = viewBox ? viewBox.x2 : this.viewWidth,
          y2 = viewBox ? viewBox.y2 : this.viewHeight,
          width = viewBox ? viewBox.width() : this.viewWidth,
          height = viewBox ? viewBox.height() : this.viewHeight;
        return window.create({
          viewBox: {
            x1: x1,
            y1: y1,
            x2: x2,
            y2: y2
          },
          width: width,
          height: height,
          dpr: this.window.dpr,
          canvasControled: !0,
          offscreen: !0,
          title: ""
        }), this.renderTo(window), window;
      }
      toCanvas() {
        let fullImage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !0;
        let viewBox = arguments.length > 1 ? arguments[1] : undefined;
        if ("released" === this.releaseStatus) return;
        const c = this.renderToNewWindow(fullImage, viewBox).getNativeHandler();
        return c.nativeCanvas ? c.nativeCanvas : null;
      }
      setCursor(mode) {
        this._cursor = mode, this.eventSystem.setCursor(mode, "ignore");
      }
      getCursor() {
        return this._cursor;
      }
      eventPointTransform(e) {
        const point = this.global.mapToCanvasPoint(e, this.window.getContext().canvas.nativeCanvas);
        return this.stage.window.pointTransform(point.x, point.y);
      }
      pauseTriggerEvent() {
        this._eventSystem && this._eventSystem.pauseTriggerEvent();
      }
      resumeTriggerEvent() {
        this._eventSystem && this._eventSystem.resumeTriggerEvent();
      }
      getPickerService() {
        return this.pickerService || (this.pickerService = container.get(PickerService)), this.pickerService;
      }
      reInit() {
        this.renderService.reInit(), this.pickerService.reInit();
      }
    }

    function createStage(params) {
      return new Stage(params);
    }

    const DefaultConfig = {
      WIDTH: 500,
      HEIGHT: 500,
      DPR: 1
    };
    class BaseCanvas {
      get displayWidth() {
        return this._pixelWidth / this._dpr;
      }
      get displayHeight() {
        return this._pixelHeight / this._dpr;
      }
      get id() {
        return this._id;
      }
      get x() {
        return this._x;
      }
      set x(_x) {
        this._x = _x;
      }
      get y() {
        return this._y;
      }
      set y(_y) {
        this._y = _y;
      }
      get nativeCanvas() {
        return this._nativeCanvas;
      }
      set nativeCanvas(nativeCanvas) {
        this._nativeCanvas = nativeCanvas;
      }
      get width() {
        return this._pixelWidth;
      }
      set width(width) {
        this._pixelWidth = width, this._displayWidth = width / (this._dpr || 1);
      }
      get height() {
        return this._pixelHeight;
      }
      set height(height) {
        this._pixelHeight = height, this._displayHeight = height / (this._dpr || 1);
      }
      getContext(str) {
        return this._context;
      }
      get visiable() {
        return this._visiable;
      }
      set visiable(visiable) {
        this._visiable = visiable, visiable ? this.show() : this.hide();
      }
      get dpr() {
        return this._dpr;
      }
      set dpr(dpr) {
        this._dpr = dpr, this.resize(this._displayWidth, this._displayHeight);
      }
      constructor(params) {
        var _a;
        const {
          nativeCanvas: nativeCanvas,
          width = DefaultConfig.WIDTH,
          height = DefaultConfig.HEIGHT,
          dpr = DefaultConfig.DPR,
          x: x,
          y: y,
          id: id,
          canvasControled = !0
        } = params;
        this._x = null != x ? x : 0, this._y = null != y ? y : 0, this._pixelWidth = width * dpr, this._pixelHeight = height * dpr, this._visiable = !1 !== params.visiable, this.controled = canvasControled, this._displayWidth = width, this._displayHeight = height, this._dpr = dpr, this._nativeCanvas = nativeCanvas, this._id = null !== (_a = nativeCanvas.id) && void 0 !== _a ? _a : id, id && (nativeCanvas.id = id), this.init(params);
      }
      getNativeCanvas() {
        return this._nativeCanvas;
      }
      hide() {}
      show() {}
      applyPosition() {}
      resetStyle(params) {}
      resize(width, height) {}
      toDataURL(mimeType, quality) {
        return "";
      }
      readPixels(x, y, w, h) {
        return this._context.getImageData(x, y, w, h);
      }
      convertToBlob(options) {
        throw new Error("暂未实现");
      }
      transferToImageBitmap() {
        throw new Error("暂未实现");
      }
      release() {
        this.controled && this._nativeCanvas.parentElement && this._nativeCanvas.parentElement.removeChild(this._nativeCanvas);
      }
    }
    BaseCanvas.env = "browser";

    var __decorate$z = undefined && undefined.__decorate || function (decorators, target, key, desc) {
        var d,
          c = arguments.length,
          r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      },
      __awaiter$1 = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator.throw(value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            var value;
            result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P(function (resolve) {
              resolve(value);
            })).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
    let BaseEnvContribution = class {
      configure(service) {
        service.env === this.type && service.setActiveEnvContribution(this);
      }
      getNativeAABBBounds(dom) {
        return new AABBBounds$1();
      }
      removeDom(dom) {
        return !1;
      }
      createDom(params) {
        return null;
      }
      updateDom(dom, params) {
        return !1;
      }
      getDynamicCanvasCount() {
        return 999;
      }
      getStaticCanvasCount() {
        return 999;
      }
      getElementById(str) {
        return document.getElementById(str);
      }
      getRootElement() {
        return document.body;
      }
      loadJson(url) {
        const jsonPromise = fetch(url).then(data => data.json());
        return jsonPromise.then(json => ({
          data: json,
          state: "success"
        })).catch(() => ({
          data: null,
          state: "fail"
        })), jsonPromise;
      }
      loadArrayBuffer(url) {
        return fetch(url).then(data => data.arrayBuffer()).then(arrayBuffer => ({
          data: arrayBuffer,
          loadState: "success"
        })).catch(() => ({
          data: null,
          loadState: "fail"
        }));
      }
      loadBlob(url) {
        return fetch(url).then(data => data.blob()).then(blob => ({
          data: blob,
          loadState: "success"
        })).catch(() => ({
          data: null,
          loadState: "fail"
        }));
      }
      getElementTop(dom, baseWindow) {
        return 0;
      }
      getElementLeft(dom, baseWindow) {
        return 0;
      }
      getElementTopLeft(dom, baseWindow) {
        return {
          top: 0,
          left: 0
        };
      }
      loadFont(font, source, descriptors) {
        return __awaiter$1(this, void 0, void 0, function* () {
          return {
            loadState: "fail"
          };
        });
      }
      isMacOS() {
        return !1;
      }
      copyToClipBoard(text) {
        return Promise.resolve(null);
      }
    };
    BaseEnvContribution = __decorate$z([injectable()], BaseEnvContribution);

    var __decorate$y = undefined && undefined.__decorate || function (decorators, target, key, desc) {
        var d,
          c = arguments.length,
          r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      },
      __metadata$r = undefined && undefined.__metadata || function (k, v) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
      };
    let BaseWindowHandlerContribution = class {
      constructor() {
        this._uid = Generator.GenAutoIncrementId(), this.viewBox = new AABBBounds$1(), this.modelMatrix = new Matrix(1, 0, 0, 1, 0, 0);
      }
      onChange(cb) {
        this._onChangeCb = cb;
      }
      configure(window, global) {
        global.env === this.type && window.setWindowHandler(this);
      }
      release() {
        this.releaseWindow();
      }
      isVisible(bbox) {
        return !0;
      }
      onVisibleChange(cb) {}
      getTopLeft(baseWindow) {
        return {
          top: 0,
          left: 0
        };
      }
      setViewBox(vb) {
        this.viewBox.setValue(vb.x1, vb.y1, vb.x2, vb.y2);
      }
      getViewBox() {
        return this.viewBox;
      }
      setViewBoxTransform(a, b, c, d, e, f) {
        this.modelMatrix.setValue(a, b, c, d, e, f);
      }
      getViewBoxTransform() {
        return this.modelMatrix;
      }
    };
    BaseWindowHandlerContribution = __decorate$y([injectable(), __metadata$r("design:paramtypes", [])], BaseWindowHandlerContribution);

    var __decorate$x = undefined && undefined.__decorate || function (decorators, target, key, desc) {
        var d,
          c = arguments.length,
          r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      },
      __metadata$q = undefined && undefined.__metadata || function (k, v) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
      },
      __param$j = undefined && undefined.__param || function (paramIndex, decorator) {
        return function (target, key) {
          decorator(target, key, paramIndex);
        };
      };
    let DefaultPickService = class {
      constructor(pickItemInterceptorContributions, pickServiceInterceptorContributions) {
        this.pickItemInterceptorContributions = pickItemInterceptorContributions, this.pickServiceInterceptorContributions = pickServiceInterceptorContributions, this.type = "default", this.global = application.global;
      }
      reInit() {
        this._init();
      }
      _init() {
        this.InterceptorContributions = this.pickItemInterceptorContributions.getContributions().sort((a, b) => a.order - b.order), this.pickerServiceInterceptorContributions = this.pickServiceInterceptorContributions.getContributions().sort((a, b) => a.order - b.order);
      }
      pick(graphics, point, params) {
        let result = {
          graphic: null,
          group: null
        };
        params.pickerService = this;
        const w = params.bounds.width(),
          h = params.bounds.height();
        if (!new AABBBounds$1().setValue(0, 0, w, h).containsPoint(point)) return result;
        this.pickContext && (this.pickContext.inuse = !0), params.pickContext = this.pickContext, this.pickContext && this.pickContext.clearMatrix(!0, 1);
        const parentMatrix = new Matrix(1, 0, 0, 1, 0, 0);
        let group;
        for (let i = graphics.length - 1; i >= 0 && (result = graphics[i].isContainer ? this.pickGroup(graphics[i], point, parentMatrix, params) : this.pickItem(graphics[i], point, parentMatrix, params), !result.graphic); i--) group || (group = result.group);
        if (result.graphic || (result.group = group), this.pickContext && (this.pickContext.inuse = !1), this.pickerServiceInterceptorContributions.length) for (let i = 0; i < this.pickerServiceInterceptorContributions.length; i++) {
          const drawContribution = this.pickerServiceInterceptorContributions[i];
          drawContribution.afterPickItem && (result = drawContribution.afterPickItem(result, this, point, params, {
            parentMatrix: parentMatrix
          }));
        }
        return result;
      }
      containsPoint(graphic, point, params) {
        var _a;
        return !!(null === (_a = this.pickItem(graphic, point, null, null != params ? params : {
          pickContext: this.pickContext,
          pickerService: this
        })) || void 0 === _a ? void 0 : _a.graphic);
      }
      pickGroup(group, point, parentMatrix, params) {
        let result = {
          group: null,
          graphic: null
        };
        if (!1 === group.attribute.visibleAll) return result;
        const context = params.pickContext,
          lastMatrix = context.modelMatrix;
        if (context.camera) {
          const m = group.transMatrix,
            matrix = mat4Allocate.allocate();
          if (mat3Tomat4(matrix, m), lastMatrix) {
            if (matrix) {
              const m = mat4Allocate.allocate();
              context.modelMatrix = multiplyMat4Mat4(m, lastMatrix, matrix), mat4Allocate.free(matrix);
            }
          } else mat3Tomat4(matrix, group.globalTransMatrix), context.modelMatrix = matrix;
        }
        if (this.InterceptorContributions.length) for (let i = 0; i < this.InterceptorContributions.length; i++) {
          const drawContribution = this.InterceptorContributions[i];
          if (drawContribution.beforePickItem) {
            const result = drawContribution.beforePickItem(group, this, point, params, {
              parentMatrix: parentMatrix
            });
            if (result) return context.modelMatrix !== lastMatrix && mat4Allocate.free(context.modelMatrix), context.modelMatrix = lastMatrix, result;
          }
        }
        const transMatrix = group.transMatrix,
          currentGroupMatrix = matrixAllocate.allocateByObj(parentMatrix),
          newPoint = new Point(point.x, point.y);
        currentGroupMatrix.transformPoint(newPoint, newPoint);
        const insideGroup = group.AABBBounds.containsPoint(newPoint);
        if (!insideGroup && !group.stage.camera) return result;
        const pickedItem = this.pickItem(group, newPoint.clone(), parentMatrix, params);
        pickedItem && pickedItem.graphic && (result.graphic = pickedItem.graphic, result.params = pickedItem.params);
        const groupPicked = !1 !== group.attribute.pickable && insideGroup;
        return currentGroupMatrix.multiply(transMatrix.a, transMatrix.b, transMatrix.c, transMatrix.d, transMatrix.e, transMatrix.f), !1 === group.attribute.childrenPickable || pickedItem && pickedItem.graphic || foreach(group, DefaultAttribute.zIndex, graphic => {
          if (graphic.isContainer) {
            const newPoint = new Point(point.x, point.y),
              theme = getTheme(group).group,
              {
                scrollX = theme.scrollX,
                scrollY = theme.scrollY
              } = group.attribute;
            newPoint.x -= scrollX, newPoint.y -= scrollY, result = this.pickGroup(graphic, newPoint, currentGroupMatrix, params);
          } else {
            const newPoint = new Point(point.x, point.y);
            currentGroupMatrix.transformPoint(newPoint, newPoint);
            const theme = getTheme(group).group,
              {
                scrollX = theme.scrollX,
                scrollY = theme.scrollY
              } = group.attribute;
            newPoint.x -= scrollX, newPoint.y -= scrollY;
            const pickedItem = this.pickItem(graphic, newPoint, parentMatrix, params);
            pickedItem && pickedItem.graphic && (result.graphic = pickedItem.graphic, result.params = pickedItem.params);
          }
          return !!result.graphic || !!result.group;
        }, !0, !!context.camera), context.modelMatrix !== lastMatrix && mat4Allocate.free(context.modelMatrix), context.modelMatrix = lastMatrix, result.graphic || result.group || !groupPicked || group.stage.camera || (result.group = group), matrixAllocate.free(currentGroupMatrix), result;
      }
      selectPicker(graphic) {
        const picker = this.pickerMap.get(graphic.numberType);
        return picker || null;
      }
    };
    DefaultPickService = __decorate$x([injectable(), __param$j(0, inject(ContributionProvider)), __param$j(0, named(PickItemInterceptor)), __param$j(1, inject(ContributionProvider)), __param$j(1, named(PickServiceInterceptor)), __metadata$q("design:paramtypes", [Object, Object])], DefaultPickService);

    let loadArcModule = !1;
    const arcModule = new ContainerModule(bind => {
      loadArcModule || (loadArcModule = !0, bind(DefaultCanvasArcRender).toSelf().inSingletonScope(), bind(ArcRender).to(DefaultCanvasArcRender).inSingletonScope(), bind(GraphicRender).toService(ArcRender), bind(ArcRenderContribution).toService(DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, ArcRenderContribution));
    });

    let loadRectModule = !1;
    const rectModule = new ContainerModule(bind => {
      loadRectModule || (loadRectModule = !0, bind(DefaultCanvasRectRender).toSelf().inSingletonScope(), bind(RectRender).to(DefaultCanvasRectRender).inSingletonScope(), bind(GraphicRender).toService(RectRender), bind(SplitRectAfterRenderContribution$1).toSelf(), bind(SplitRectBeforeRenderContribution$1).toSelf(), bind(RectRenderContribution).toService(SplitRectAfterRenderContribution$1), bind(RectRenderContribution).toService(SplitRectBeforeRenderContribution$1), bind(RectRenderContribution).toService(DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, RectRenderContribution));
    });

    let loadLineModule = !1;
    const lineModule = new ContainerModule(bind => {
      loadLineModule || (loadLineModule = !0, bind(DefaultCanvasLineRender).toSelf().inSingletonScope(), bind(DefaultIncrementalCanvasLineRender).toSelf().inSingletonScope(), bind(LineRender).to(DefaultCanvasLineRender).inSingletonScope(), bind(GraphicRender).toService(LineRender));
    });

    let loadSymbolModule = !1;
    const symbolModule = new ContainerModule(bind => {
      loadSymbolModule || (loadSymbolModule = !0, bind(DefaultCanvasSymbolRender).toSelf().inSingletonScope(), bind(SymbolRender).to(DefaultCanvasSymbolRender).inSingletonScope(), bind(GraphicRender).toService(SymbolRender), bind(SymbolRenderContribution).toService(DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, SymbolRenderContribution));
    });

    let loadCircleModule = !1;
    const circleModule = new ContainerModule(bind => {
      loadCircleModule || (loadCircleModule = !0, bind(DefaultCanvasCircleRender).toSelf().inSingletonScope(), bind(CircleRender).to(DefaultCanvasCircleRender).inSingletonScope(), bind(GraphicRender).toService(CircleRender), bind(CircleRenderContribution).toService(DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, CircleRenderContribution));
    });

    let loadTextModule = !1;
    const textModule = new ContainerModule(bind => {
      loadTextModule || (loadTextModule = !0, bind(TextRender).to(DefaultCanvasTextRender).inSingletonScope(), bind(GraphicRender).toService(TextRender), bind(TextRenderContribution).toService(DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, TextRenderContribution));
    });

    let loadPathModule = !1;
    const pathModule = new ContainerModule(bind => {
      loadPathModule || (loadPathModule = !0, bind(DefaultCanvasPathRender).toSelf().inSingletonScope(), bind(PathRender).to(DefaultCanvasPathRender).inSingletonScope(), bind(GraphicRender).toService(PathRender), bind(PathRenderContribution).toService(DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, PathRenderContribution));
    });

    let loadPolygonModule = !1;
    const polygonModule = new ContainerModule(bind => {
      loadPolygonModule || (loadPolygonModule = !0, bind(PolygonRender).to(DefaultCanvasPolygonRender).inSingletonScope(), bind(GraphicRender).toService(PolygonRender), bind(PolygonRenderContribution).toService(DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, PolygonRenderContribution));
    });

    var __decorate$w = undefined && undefined.__decorate || function (decorators, target, key, desc) {
        var d,
          c = arguments.length,
          r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      },
      __metadata$p = undefined && undefined.__metadata || function (k, v) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
      };
    let DefaultCanvasRichTextRender = class extends BaseRender {
      constructor() {
        super(), this.numberType = RICHTEXT_NUMBER_TYPE, this.builtinContributions = [defaultTextBackgroundRenderContribution], this.init();
      }
      drawShape(richtext, context, x, y, drawContext) {
        const richtextAttribute = getTheme(richtext).richtext,
          {
            strokeOpacity = richtextAttribute.strokeOpacity,
            opacity = richtextAttribute.opacity,
            fillOpacity = richtextAttribute.fillOpacity,
            visible = richtextAttribute.visible
          } = richtext.attribute;
        if (!richtext.valid || !visible) return;
        const fVisible = fillVisible(opacity, fillOpacity, !0),
          sVisible = fillVisible(opacity, strokeOpacity, !0);
        if (!fVisible) return;
        context.setShadowBlendStyle && context.setShadowBlendStyle(richtext, richtext.attribute, richtextAttribute), context.translate(x, y), this.beforeRenderStep(richtext, context, x, y, fVisible, sVisible, fVisible, sVisible, richtextAttribute, drawContext);
        richtext.getFrameCache().draw(context, this.drawIcon), this.afterRenderStep(richtext, context, x, y, fVisible, sVisible, fVisible, sVisible, richtextAttribute, drawContext);
      }
      drawIcon(icon, context, x, y, baseline) {
        var _a;
        const richtextIconAttribute = getTheme(icon).richtextIcon,
          {
            width = richtextIconAttribute.width,
            height = richtextIconAttribute.height,
            opacity = richtextIconAttribute.opacity,
            image: url,
            backgroundFill = richtextIconAttribute.backgroundFill,
            backgroundFillOpacity = richtextIconAttribute.backgroundFillOpacity,
            backgroundStroke = richtextIconAttribute.backgroundStroke,
            backgroundStrokeOpacity = richtextIconAttribute.backgroundStrokeOpacity,
            backgroundRadius = richtextIconAttribute.backgroundRadius,
            margin: margin
          } = icon.attribute,
          {
            backgroundWidth = width,
            backgroundHeight = height
          } = icon.attribute;
        if (margin && (x += icon._marginArray[3], y += icon._marginArray[0]), icon._hovered) {
          const expandX = (backgroundWidth - width) / 2,
            expandY = (backgroundHeight - height) / 2;
          0 === backgroundRadius ? (context.beginPath(), context.rect(x - expandX, y - expandY, backgroundWidth, backgroundHeight)) : (context.beginPath(), createRectPath(context, x - expandX, y - expandY, backgroundWidth, backgroundHeight, backgroundRadius, !0)), backgroundFill && (context.globalAlpha = backgroundFillOpacity, context.fillStyle = backgroundFill, context.fill()), backgroundStroke && (context.globalAlpha = backgroundStrokeOpacity, context.strokeStyle = backgroundStroke, context.stroke());
        }
        const res = url && (null === (_a = null == icon ? void 0 : icon.resources) || void 0 === _a ? void 0 : _a.get(url));
        res && "success" === res.state && (context.globalAlpha = opacity, context.drawImage(res.data, x, y, width, height));
      }
      draw(richtext, renderService, drawContext) {
        const richtextAttribute = getTheme(richtext).richtext;
        this._draw(richtext, richtextAttribute, !1, drawContext);
      }
    };
    DefaultCanvasRichTextRender = __decorate$w([injectable(), __metadata$p("design:paramtypes", [])], DefaultCanvasRichTextRender);

    let loadRichtextModule = !1;
    const richtextModule = new ContainerModule(bind => {
      loadRichtextModule || (loadRichtextModule = !0, bind(RichTextRender).to(DefaultCanvasRichTextRender).inSingletonScope(), bind(GraphicRender).toService(RichTextRender));
    });

    let loadImageModule = !1;
    const imageModule = new ContainerModule(bind => {
      loadImageModule || (loadImageModule = !0, bind(ImageRender).to(DefaultCanvasImageRender).inSingletonScope(), bind(GraphicRender).toService(ImageRender), bind(ImageRenderContribution).toService(DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, ImageRenderContribution));
    });

    function registerArcGraphic() {
      graphicCreator.RegisterGraphicCreator("arc", createArc);
    }

    function registerCircleGraphic() {
      graphicCreator.RegisterGraphicCreator("circle", createCircle);
    }

    function registerGroupGraphic() {
      graphicCreator.RegisterGraphicCreator("group", createGroup);
    }

    function registerImageGraphic() {
      graphicCreator.RegisterGraphicCreator("image", createImage);
    }

    function registerLineGraphic() {
      graphicCreator.RegisterGraphicCreator("line", createLine);
    }

    function registerPathGraphic() {
      graphicCreator.RegisterGraphicCreator("path", createPath);
    }

    function registerPolygonGraphic() {
      graphicCreator.RegisterGraphicCreator("polygon", createPolygon);
    }

    function registerRectGraphic() {
      graphicCreator.RegisterGraphicCreator("rect", createRect);
    }

    function registerRichtextGraphic() {
      graphicCreator.RegisterGraphicCreator("richtext", createRichText);
    }

    function registerSymbolGraphic() {
      graphicCreator.RegisterGraphicCreator("symbol", createSymbol);
    }

    function registerTextGraphic() {
      graphicCreator.RegisterGraphicCreator("text", createText);
    }

    function registerShadowRootGraphic() {
      graphicCreator.RegisterGraphicCreator("shadowRoot", createShadowRoot);
    }

    function registerWrapTextGraphic() {
      graphicCreator.RegisterGraphicCreator("wrapText", createWrapText);
    }

    const _tempBounds = new AABBBounds$1();
    class FlexLayoutPlugin {
      constructor() {
        this.name = "FlexLayoutPlugin", this.activeEvent = "onRegister", this.id = Generator.GenAutoIncrementId(), this.key = this.name + this.id, this.tempBounds = new AABBBounds$1();
      }
      pauseLayout(p) {
        this.pause = p;
      }
      tryLayoutChildren(graphic) {
        graphic.firstChild && this.tryLayout(graphic.firstChild);
      }
      tryLayout(graphic) {
        let force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
        if (this.pause) return;
        const p = graphic.parent;
        if (!(force || p && graphic.needUpdateLayout())) return;
        const theme = getTheme(p).group,
          {
            display = theme.display
          } = p.attribute;
        if ("flex" !== display) return;
        const {
            flexDirection = theme.flexDirection,
            flexWrap = theme.flexWrap,
            alignItems = theme.alignItems,
            clip = theme.clip
          } = p.attribute,
          {
            alignContent = null != alignItems ? alignItems : theme.alignContent
          } = p.attribute;
        let {
          width: width,
          height: height,
          justifyContent = theme.justifyContent
        } = p.attribute;
        const children = p.getChildren();
        if (null == width || null == height) {
          let childrenWidth = 0,
            childrenHeight = 0,
            boundsLegal = 0;
          if (children.forEach(child => {
            const bounds = this.getAABBBounds(child);
            bounds.empty() || ("column" === flexDirection || "column-reverse" === flexDirection ? (childrenHeight += bounds.height(), childrenWidth = Math.max(childrenWidth, bounds.width())) : (childrenWidth += bounds.width(), childrenHeight = Math.max(childrenHeight, bounds.height())), boundsLegal += bounds.x1, boundsLegal += bounds.y1, boundsLegal += bounds.x2, boundsLegal += bounds.y2);
          }), !isFinite(boundsLegal)) return;
          width = childrenWidth, height = childrenHeight;
        }
        null == p.attribute.width ? p.attribute.width = width : width = p.attribute.width, null == p.attribute.height ? p.attribute.height = height : height = p.attribute.height, this.tempBounds.copy(p._AABBBounds);
        const result = {
            main: {
              len: width,
              field: "x"
            },
            cross: {
              len: height,
              field: "y"
            }
          },
          main = result.main,
          cross = result.cross;
        "column" !== flexDirection && "column-reverse" !== flexDirection || (main.len = height, cross.len = width, main.field = "y", cross.field = "x"), "row-reverse" !== flexDirection && "column-reverse" !== flexDirection || ("flex-start" === justifyContent ? justifyContent = "flex-end" : "flex-end" === justifyContent ? justifyContent = "flex-start" : children.reverse());
        let mainLen = 0,
          crossLen = 0;
        const mianLenArray = [];
        children.forEach(c => {
          const b = this.getAABBBounds(c);
          if (b.empty()) return;
          const ml = "x" === main.field ? b.width() : b.height(),
            cl = "x" === cross.field ? b.width() : b.height();
          mianLenArray.push({
            mainLen: ml,
            crossLen: cl
          }), mainLen += ml, crossLen = Math.max(crossLen, cl);
        });
        const mainList = [];
        if (mainLen > main.len && "wrap" === flexWrap) {
          let tempMainL = 0,
            tempCrossL = 0;
          mianLenArray.forEach((_ref, i) => {
            let {
              mainLen: mainLen,
              crossLen: crossLen
            } = _ref;
            tempMainL + mainLen > main.len ? 0 === tempMainL ? (mainList.push({
              idx: i,
              mainLen: tempMainL + mainLen,
              crossLen: crossLen
            }), tempMainL = 0, tempCrossL = 0) : (mainList.push({
              idx: i - 1,
              mainLen: tempMainL,
              crossLen: tempCrossL
            }), tempMainL = mainLen, tempCrossL = crossLen) : (tempMainL += mainLen, tempCrossL = Math.max(tempCrossL, crossLen));
          }), mainList.push({
            idx: mianLenArray.length - 1,
            mainLen: tempMainL,
            crossLen: tempCrossL
          });
        } else mainList.push({
          idx: mianLenArray.length - 1,
          mainLen: mainLen,
          crossLen: crossLen
        });
        let lastIdx = 0;
        if (mainList.forEach(s => {
          this.layoutMain(p, children, justifyContent, main, mianLenArray, lastIdx, s), lastIdx = s.idx + 1;
        }), crossLen = mainList.reduce((a, b) => a + b.crossLen, 0), 1 === mainList.length) {
          const anchorPosMap = {
            "flex-start": 0,
            "flex-end": cross.len,
            center: cross.len / 2
          };
          this.layoutCross(children, alignItems, cross, anchorPosMap, mianLenArray, mainList[0], 0);
        } else if ("flex-start" === alignContent) {
          lastIdx = 0;
          let anchorPos = 0;
          mainList.forEach((s, i) => {
            const anchorPosMap = {
              "flex-start": anchorPos,
              "flex-end": anchorPos + s.crossLen,
              center: anchorPos + s.crossLen / 2
            };
            this.layoutCross(children, "flex-start", cross, anchorPosMap, mianLenArray, mainList[i], lastIdx), lastIdx = s.idx + 1, anchorPos += s.crossLen;
          });
        } else if ("center" === alignContent) {
          lastIdx = 0;
          let anchorPos = Math.max(0, (cross.len - crossLen) / 2);
          mainList.forEach((s, i) => {
            const anchorPosMap = {
              "flex-start": anchorPos,
              "flex-end": anchorPos + s.crossLen,
              center: anchorPos + s.crossLen / 2
            };
            this.layoutCross(children, "center", cross, anchorPosMap, mianLenArray, mainList[i], lastIdx), lastIdx = s.idx + 1, anchorPos += s.crossLen;
          });
        } else if ("space-around" === alignContent) {
          lastIdx = 0;
          const padding = Math.max(0, (cross.len - crossLen) / mainList.length / 2);
          let anchorPos = padding;
          mainList.forEach((s, i) => {
            const anchorPosMap = {
              "flex-start": anchorPos,
              "flex-end": anchorPos + s.crossLen,
              center: anchorPos + s.crossLen / 2
            };
            this.layoutCross(children, "flex-start", cross, anchorPosMap, mianLenArray, mainList[i], lastIdx), lastIdx = s.idx + 1, anchorPos += s.crossLen + 2 * padding;
          });
        } else if ("space-between" === alignContent) {
          lastIdx = 0;
          const padding = Math.max(0, (cross.len - crossLen) / (2 * mainList.length - 2));
          let anchorPos = 0;
          mainList.forEach((s, i) => {
            const anchorPosMap = {
              "flex-start": anchorPos,
              "flex-end": anchorPos + s.crossLen,
              center: anchorPos + s.crossLen / 2
            };
            this.layoutCross(children, "flex-start", cross, anchorPosMap, mianLenArray, mainList[i], lastIdx), lastIdx = s.idx + 1, anchorPos += s.crossLen + 2 * padding;
          });
        }
        children.forEach((child, idx) => {
          child.addUpdateBoundTag(), child.addUpdatePositionTag(), child.clearUpdateLayoutTag();
        }), p.addUpdateLayoutTag();
        const b = this.getAABBBounds(p);
        clip || this.tempBounds.equals(b) || this.tryLayout(p, !1);
      }
      getAABBBounds(graphic) {
        this.skipBoundsTrigger = !0;
        const b = graphic.AABBBounds;
        return this.skipBoundsTrigger = !1, b;
      }
      updateChildPos(posBaseLeftTop, lastP, lastBP) {
        return posBaseLeftTop + (null != lastP ? lastP : 0) - lastBP;
      }
      layoutMain(p, children, justifyContent, main, mianLenArray, lastIdx, currSeg) {
        if ("flex-start" === justifyContent) {
          let pos = 0;
          for (let i = lastIdx; i <= currSeg.idx; i++) {
            const posBaseLeftTop = pos + getPadding(children[i], main.field),
              b = this.getAABBBounds(children[i]);
            !b.empty() && (children[i].attribute[main.field] = this.updateChildPos(posBaseLeftTop, children[i].attribute[main.field], b[`${main.field}1`])), pos += mianLenArray[i].mainLen;
          }
        } else if ("flex-end" === justifyContent) {
          let pos = main.len;
          for (let i = currSeg.idx; i >= lastIdx; i--) {
            pos -= mianLenArray[i].mainLen;
            const posBaseLeftTop = pos + getPadding(children[i], main.field),
              b = this.getAABBBounds(children[i]);
            !b.empty() && (children[i].attribute[main.field] = this.updateChildPos(posBaseLeftTop, children[i].attribute[main.field], b[`${main.field}1`]));
          }
        } else if ("space-around" === justifyContent) {
          if (currSeg.mainLen >= main.len) {
            let pos = 0;
            for (let i = lastIdx; i <= currSeg.idx; i++) {
              const posBaseLeftTop = pos + getPadding(children[i], main.field),
                b = this.getAABBBounds(children[i]);
              !b.empty() && (children[i].attribute[main.field] = this.updateChildPos(posBaseLeftTop, children[i].attribute[main.field], b[`${main.field}1`])), pos += mianLenArray[i].mainLen;
            }
          } else {
            const size = currSeg.idx - lastIdx + 1,
              padding = (main.len - currSeg.mainLen) / size / 2;
            let pos = padding;
            for (let i = lastIdx; i <= currSeg.idx; i++) {
              const posBaseLeftTop = pos + getPadding(children[i], main.field),
                b = this.getAABBBounds(children[i]);
              !b.empty() && (children[i].attribute[main.field] = this.updateChildPos(posBaseLeftTop, children[i].attribute[main.field], b[`${main.field}1`])), pos += mianLenArray[i].mainLen + 2 * padding;
            }
          }
        } else if ("space-between" === justifyContent) {
          if (currSeg.mainLen >= main.len) {
            let pos = 0;
            for (let i = lastIdx; i <= currSeg.idx; i++) {
              const posBaseLeftTop = pos + getPadding(children[i], main.field),
                b = this.getAABBBounds(children[i]);
              !b.empty() && (children[i].attribute[main.field] = this.updateChildPos(posBaseLeftTop, children[i].attribute[main.field], b[`${main.field}1`])), pos += mianLenArray[i].mainLen;
            }
          } else {
            const size = currSeg.idx - lastIdx + 1,
              padding = (main.len - currSeg.mainLen) / (2 * size - 2);
            let pos = 0;
            for (let i = lastIdx; i <= currSeg.idx; i++) {
              const posBaseLeftTop = pos + getPadding(children[i], main.field),
                b = this.getAABBBounds(children[i]);
              !b.empty() && (children[i].attribute[main.field] = this.updateChildPos(posBaseLeftTop, children[i].attribute[main.field], b[`${main.field}1`])), pos += mianLenArray[i].mainLen + 2 * padding;
            }
          }
        } else if ("center" === justifyContent) {
          let pos = (main.len - currSeg.mainLen) / 2;
          for (let i = lastIdx; i <= currSeg.idx; i++) {
            const posBaseLeftTop = pos + getPadding(children[i], main.field),
              b = this.getAABBBounds(children[i]);
            !b.empty() && (children[i].attribute[main.field] = this.updateChildPos(posBaseLeftTop, children[i].attribute[main.field], b[`${main.field}1`])), pos += mianLenArray[i].mainLen;
          }
        }
      }
      layoutCross(children, alignItem, cross, anchorPosMap, lenArray, currSeg, lastIdx) {
        var _a;
        for (let i = lastIdx; i <= currSeg.idx; i++) {
          const child = children[i];
          let {
            alignSelf: alignSelf
          } = child.attribute;
          alignSelf && "auto" !== alignSelf || (alignSelf = alignItem);
          const b = this.getAABBBounds(child),
            anchorPos = null !== (_a = anchorPosMap[alignSelf]) && void 0 !== _a ? _a : anchorPosMap["flex-start"];
          "flex-end" === alignSelf ? !b.empty() && (child.attribute[cross.field] = this.updateChildPos(anchorPos - lenArray[i].crossLen + getPadding(child, cross.field), child.attribute[cross.field], b[`${cross.field}1`])) : "center" === alignSelf ? !b.empty() && (child.attribute[cross.field] = this.updateChildPos(anchorPos - lenArray[i].crossLen / 2 + getPadding(child, cross.field), child.attribute[cross.field], b[`${cross.field}1`])) : !b.empty() && (child.attribute[cross.field] = this.updateChildPos(anchorPos + getPadding(child, cross.field), child.attribute[cross.field], b[`${cross.field}1`]));
        }
      }
      activate(context) {
        this.pluginService = context, application.graphicService.hooks.onAttributeUpdate.tap(this.key, graphic => {
          graphic.glyphHost && (graphic = graphic.glyphHost), graphic.stage && graphic.stage === this.pluginService.stage && this.tryLayout(graphic, !1);
        }), application.graphicService.hooks.beforeUpdateAABBBounds.tap(this.key, (graphic, stage, willUpdate, bounds) => {
          graphic.glyphHost && (graphic = graphic.glyphHost), stage && stage === this.pluginService.stage && graphic.isContainer && !this.skipBoundsTrigger && _tempBounds.copy(bounds);
        }), application.graphicService.hooks.afterUpdateAABBBounds.tap(this.key, (graphic, stage, bounds, params, selfChange) => {
          stage && stage === this.pluginService.stage && graphic.isContainer && !this.skipBoundsTrigger && (_tempBounds.equals(bounds) || this.tryLayout(graphic, !1));
        }), application.graphicService.hooks.onSetStage.tap(this.key, graphic => {
          graphic.glyphHost && (graphic = graphic.glyphHost), this.tryLayout(graphic, !1);
        });
      }
      deactivate(context) {
        application.graphicService.hooks.onAttributeUpdate.taps = application.graphicService.hooks.onAttributeUpdate.taps.filter(item => item.name !== this.key), application.graphicService.hooks.beforeUpdateAABBBounds.taps = application.graphicService.hooks.beforeUpdateAABBBounds.taps.filter(item => item.name !== this.key), application.graphicService.hooks.afterUpdateAABBBounds.taps = application.graphicService.hooks.afterUpdateAABBBounds.taps.filter(item => item.name !== this.key), application.graphicService.hooks.onSetStage.taps = application.graphicService.hooks.onSetStage.taps.filter(item => item.name !== this.key);
      }
    }
    function getPadding(graphic, field) {
      return 0;
    }
    const registerFlexLayoutPlugin = () => {
      Factory$1.registerPlugin("FlexLayoutPlugin", FlexLayoutPlugin);
    };

    const GROUP_ATTRIBUTES = ["x", "y", "dx", "dy", "scaleX", "scaleY", "angle", "anchor", "postMatrix", "visible", "clip", "pickable", "childrenPickable", "zIndex", "cursor"];
    class AbstractComponent extends Group$2 {
      constructor(attributes, options) {
        super(attributes), this._skipRenderAttributes = GROUP_ATTRIBUTES, (null == options ? void 0 : options.mode) && (this.mode = options.mode, this.setMode(options.mode)), (null == options ? void 0 : options.skipDefault) && (this.skipDefault = !0), this.setTheme({
          common: {
            strokeBoundsBuffer: 0
          }
        }), this.attribute = attributes, this.onSetStage(() => {
          this.render(), this.bindEvents();
        });
      }
      setAttribute(key, value, forceUpdateTag, context) {
        const params = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({
          [key]: value
        }, this.attribute, key, context);
        if (params) return this._setAttributes(params, forceUpdateTag);
        isPlainObject$5(this.attribute[key]) && isPlainObject$5(value) && !isFunction$7(this.attribute[key]) && !isFunction$7(value) ? merge$2(this.attribute[key], value) : this.attribute[key] = value, this._skipRenderAttributes.includes(key) || this.render(), this.valid = this.isValid(), this.updateShapeAndBoundsTagSetted() || !forceUpdateTag && !this.needUpdateTag(key) ? this.addUpdateBoundTag() : this.addUpdateShapeAndBoundsTag(), this.addUpdatePositionTag(), this.onAttributeUpdate();
      }
      setAttributes(params, forceUpdateTag, context) {
        return params = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate(params, this.attribute, null, context) || params, this._setAttributes(params, forceUpdateTag);
      }
      _setAttributes(params, forceUpdateTag) {
        const keys = Object.keys(params);
        this._mergeAttributes(params, keys), keys.every(key => this._skipRenderAttributes.includes(key)) || this.render(), this.valid = this.isValid(), this.updateShapeAndBoundsTagSetted() || !forceUpdateTag && !this.needUpdateTags(keys) ? this.addUpdateBoundTag() : this.addUpdateShapeAndBoundsTag(), this.addUpdatePositionTag(), this.onAttributeUpdate();
      }
      _mergeAttributes(params, keys) {
        isNil$5(keys) && (keys = Object.keys(params));
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          !isPlainObject$5(this.attribute[key]) || isFunction$7(this.attribute[key]) || isFunction$7(params[key]) ? this.attribute[key] = params[key] : merge$2(this.attribute[key], params[key]);
        }
      }
      bindEvents() {}
      _getNodeId(id) {
        var _a;
        return `${null !== (_a = this.id) && void 0 !== _a ? _a : this._uid}-${this.name}-${id}`;
      }
      _dispatchEvent(eventName, details) {
        var _a;
        const changeEvent = new CustomEvent(eventName, details);
        changeEvent.manager = null === (_a = this.stage) || void 0 === _a ? void 0 : _a.eventSystem.manager, this.dispatchEvent(changeEvent);
      }
    }

    const MathPickerContribution = Symbol.for("MathPickerContribution");
    const MathArcPicker = Symbol.for("MathArcPicker");
    const MathCirclePicker = Symbol.for("MathCirclePicker");
    const MathImagePicker = Symbol.for("MathImagePicker");
    const MathLinePicker = Symbol.for("MathLinePicker");
    const MathPathPicker = Symbol.for("MathPathPicker");
    const MathRectPicker = Symbol.for("MathRectPicker");
    const MathSymbolPicker = Symbol.for("MathSymbolPicker");
    const MathTextPicker = Symbol.for("MathTextPicker");
    const MathPolygonPicker = Symbol.for("MathPolygonPicker");
    const CanvasArcPicker = Symbol.for("CanvasArcPicker");
    const CanvasCirclePicker = Symbol.for("CanvasCirclePicker");
    const CanvasImagePicker = Symbol.for("CanvasImagePicker");
    const CanvasLinePicker = Symbol.for("CanvasLinePicker");
    const CanvasPathPicker = Symbol.for("CanvasPathPicker");
    const CanvasRectPicker = Symbol.for("CanvasRectPicker");
    const CanvasSymbolPicker = Symbol.for("CanvasSymbolPicker");
    const CanvasTextPicker = Symbol.for("CanvasTextPicker");
    const CanvasPolygonPicker = Symbol.for("CanvasPolygonPicker");
    const CanvasRichTextPicker = Symbol.for("CanvasRichTextPicker");
    const CanvasGroupPicker = Symbol.for("CanvasGroupPicker");
    const CanvasPickerContribution = Symbol.for("CanvasPickerContribution");

    const REACT_TO_CANOPUS_EVENTS = {
      onPointerDown: "pointerdown",
      onPointerUp: "pointerup",
      onPointerUpOutside: "pointerupoutside",
      onPointerTap: "pointertap",
      onPointerOver: "pointerover",
      onPointerMove: "pointermove",
      onPointerEnter: "pointerenter",
      onPointerLeave: "pointerleave",
      onPointerOut: "pointerout",
      onMouseDown: "mousedown",
      onMouseUp: "mouseup",
      onMouseUpOutside: "mouseupoutside",
      onMouseMove: "mousemove",
      onMouseOver: "mouseover",
      onMouseOut: "mouseout",
      onMouseEnter: "mouseenter",
      onMouseLeave: "mouseleave",
      onPinch: "pinch",
      onPinchStart: "pinchstart",
      onPinchEnd: "pinchend",
      onPan: "pan",
      onPanStart: "panstart",
      onPanEnd: "panend",
      onDrag: "drag",
      onDragStart: "dragstart",
      onDragEnter: "dragenter",
      onDragLeave: "dragleave",
      onDragOver: "dragover",
      onDragEnd: "dragend",
      onRightDown: "rightdown",
      onRightUp: "rightup",
      onRightUpOutside: "rightupoutside",
      onTouchStart: "touchstart",
      onTouchEnd: "touchend",
      onTouchEndOutside: "touchendoutside",
      onTouchMove: "touchmove",
      onTouchCancel: "touchcancel",
      onPress: "press",
      onPressUp: "pressup",
      onPressEnd: "pressend",
      onSwipe: "swipe",
      onDrop: "drop",
      onWeel: "wheel",
      onClick: "click",
      onDblClick: "dblclick"
    };
    function VArc(params) {
      return graphicCreator.arc(params ? params.attribute : {});
    }
    function VArea(params) {
      return graphicCreator.area(params ? params.attribute : {});
    }
    function VCircle(params) {
      return graphicCreator.circle(params ? params.attribute : {});
    }
    function VGroup(params) {
      return graphicCreator.group(params ? params.attribute : {});
    }
    function VGlyph(params) {
      return graphicCreator.glyph(params ? params.attribute : {});
    }
    function VImage(params) {
      return graphicCreator.image(params ? params.attribute : {});
    }
    function VLine(params) {
      return graphicCreator.line(params ? params.attribute : {});
    }
    function VPath(params) {
      return graphicCreator.path(params ? params.attribute : {});
    }
    function VPolygon(params) {
      return graphicCreator.polygon(params ? params.attribute : {});
    }
    function VRect(params) {
      return graphicCreator.rect(params ? params.attribute : {});
    }
    function VSymbol(params) {
      return graphicCreator.symbol(params ? params.attribute : {});
    }
    function VText(params) {
      return graphicCreator.text(params ? params.attribute : {});
    }

    var __rest$4 = undefined && undefined.__rest || function (s, e) {
      var t = {};
      for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0 && (t[p] = s[p]);
      if (null != s && "function" == typeof Object.getOwnPropertySymbols) {
        var i = 0;
        for (p = Object.getOwnPropertySymbols(s); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t[p[i]] = s[p[i]]);
      }
      return t;
    };
    function flatten(list, out) {
      if (isArray$9(list)) return list.forEach(i => flatten(i, out));
      out.push(list);
    }
    function jsx(type, config) {
      const _a = config || {},
        {
          key: key,
          name: name,
          id: id,
          attribute: attribute,
          stateProxy: stateProxy,
          animation: animation,
          timeline: timeline
        } = _a,
        props = __rest$4(_a, ["key", "name", "id", "attribute", "stateProxy", "animation", "timeline"]);
      let c = type;
      isString$6(type) && (c = graphicCreator[type]);
      const childrenList = [];
      for (var _len = arguments.length, children = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        children[_key - 2] = arguments[_key];
      }
      children.length && flatten(1 === children.length ? children[0] : children, childrenList);
      const g = "Group" === c.name ? new c(attribute) : c(config);
      if (parseToGraphic$1(g, childrenList, props), stateProxy && (g.stateProxy = stateProxy), name && (g.name = name), isArray$9(animation)) {
        const animate = g.animate();
        timeline && animate.setTimeline(timeline), animation.forEach(item => {
          animate[item[0]](...item.slice(1));
        });
      }
      return g;
    }
    function parseToGraphic$1(g, childrenList, props) {
      let out,
        isGraphic = !1;
      switch (g.type) {
        case "richtext":
        case "rich/image":
          break;
        case "rich/text":
          out = g.attribute || {}, childrenList[0] && (out.text = childrenList[0]);
          break;
        default:
          isGraphic = !0;
      }
      isGraphic ? (childrenList.forEach(c => {
        c && g.add(c);
      }), Object.keys(props).forEach(k => {
        const en = REACT_TO_CANOPUS_EVENTS[k];
        en && g.on(en, props[k]);
      })) : "richtext" === g.type && (g.attribute.textConfig = childrenList.map(item => item.attribute).filter(item => item));
    }

    const calcDirection = (start, end) => {
        const xDistance = end.x - start.x,
          yDistance = end.y - start.y;
        return Math.abs(xDistance) > Math.abs(yDistance) ? xDistance > 0 ? "right" : "left" : yDistance > 0 ? "down" : "up";
      },
      calcDistance = (point1, point2) => {
        const xDistance = Math.abs(point2.x - point1.x),
          yDistance = Math.abs(point2.y - point1.y);
        return Math.sqrt(xDistance * xDistance + yDistance * yDistance);
      },
      getCenter = points => {
        const pointersLength = points.length;
        if (1 === pointersLength) return {
          x: Math.round(points[0].x),
          y: Math.round(points[0].y)
        };
        let x = 0,
          y = 0,
          i = 0;
        for (; i < pointersLength;) x += points[i].x, y += points[i].y, i++;
        return {
          x: Math.round(x / pointersLength),
          y: Math.round(y / pointersLength)
        };
      };
    class Gesture extends EventEmitter {
      constructor(element) {
        let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        super(), this.cachedEvents = [], this.startPoints = [], this.processEvent = {}, this.throttleTimer = 0, this.emitThrottles = [], this.lastTapTarget = null, this.onStart = ev => {
          this.startTime = clock.now();
          const {
            cachedEvents: cachedEvents,
            startPoints: startPoints
          } = this;
          ev && cachedEvents.push(ev.clone()), startPoints.length = cachedEvents.length;
          for (let i = 0; i < cachedEvents.length; i++) {
            const {
                x: x,
                y: y
              } = cachedEvents[i],
              point = {
                x: x,
                y: y
              };
            startPoints[i] = point;
          }
          if (1 !== startPoints.length) this.startDistance = calcDistance(startPoints[0], startPoints[1]), this.center = getCenter([startPoints[0], startPoints[1]]);else {
            const event = cachedEvents[0];
            this.pressTimeout = setTimeout(() => {
              event.direction = "none", event.deltaX = 0, event.deltaY = 0, event.points = startPoints, this.triggerStartEvent("press", event), this.triggerEvent("press", event), this.eventType = "press", this.direction = "none", this.pressTimeout = null;
            }, this.config.press.time);
          }
        }, this.onMove = ev => {
          this.clearPressTimeout();
          const {
            startPoints: startPoints,
            cachedEvents: cachedEvents
          } = this;
          if (!startPoints.length) return;
          const moveEvent = ev.clone(),
            {
              x: x,
              y: y,
              pointerId: pointerId
            } = moveEvent;
          for (let i = 0, len = cachedEvents.length; i < len; i++) if (pointerId === cachedEvents[i].pointerId) {
            cachedEvents[i] = moveEvent;
            break;
          }
          const point = {
              x: x,
              y: y
            },
            points = cachedEvents.map(cachedEvent => ({
              x: cachedEvent.x,
              y: cachedEvent.y
            })),
            now = clock.now();
          if (this.prevMoveTime = this.lastMoveTime, this.prevMovePoint = this.lastMovePoint, this.lastMoveTime = now, this.lastMovePoint = point, 1 === startPoints.length) {
            const startPoint = startPoints[0],
              deltaX = x - startPoint.x,
              deltaY = y - startPoint.y,
              direction = this.direction || calcDirection(startPoint, point);
            this.direction = direction;
            const eventType = this.getEventType(point);
            return moveEvent.direction = direction, moveEvent.deltaX = deltaX, moveEvent.deltaY = deltaY, moveEvent.points = points, this.triggerStartEvent(eventType, moveEvent), void this.triggerEvent(eventType, moveEvent);
          }
          const {
              startDistance: startDistance
            } = this,
            currentDistance = calcDistance(points[0], points[1]);
          moveEvent.scale = currentDistance / startDistance, moveEvent.center = this.center, moveEvent.points = points, this.triggerStartEvent("pinch", moveEvent), this.triggerEvent("pinch", moveEvent);
        }, this.onEnd = ev => {
          const endEvent = ev.clone(),
            {
              cachedEvents: cachedEvents,
              startPoints: startPoints
            } = this,
            points = cachedEvents.map(ev => ({
              x: ev.x,
              y: ev.y
            }));
          if (endEvent.points = points, this.triggerEndEvent(endEvent), 1 === cachedEvents.length) {
            const now = clock.now(),
              lastMoveTime = this.lastMoveTime;
            if (now - lastMoveTime < 100) {
              const intervalTime = lastMoveTime - (this.prevMoveTime || this.startTime);
              if (intervalTime > 0) {
                const prevMovePoint = this.prevMovePoint || startPoints[0],
                  lastMovePoint = this.lastMovePoint || startPoints[0],
                  distance = calcDistance(prevMovePoint, lastMovePoint),
                  velocity = distance / intervalTime;
                if (velocity > this.config.swipe.velocity && distance > this.config.swipe.threshold) return endEvent.velocity = velocity, endEvent.direction = calcDirection(prevMovePoint, lastMovePoint), this.triggerEvent("swipe", endEvent), this.cachedEvents = [], this.startPoints = [], void this.reset();
              }
            }
            now - this.startTime < this.config.press.time && (now - this.lastTapTime < this.config.tap.interval && ev.target === this.lastTapTarget ? this.tapCount++ : this.tapCount = 1, this.lastTapTime = now, this.lastTapTarget = ev.target, 1 === this.tapCount ? this.triggerEvent("tap", endEvent) : 2 === this.tapCount && (this.triggerEvent("doubletap", endEvent), this.tapCount = 0));
          }
          for (let i = 0, len = cachedEvents.length; i < len; i++) if (cachedEvents[i].pointerId === endEvent.pointerId) {
            cachedEvents.splice(i, 1), startPoints.splice(i, 1);
            break;
          }
          this.reset(), cachedEvents.length > 0 && this.onStart();
        }, this.element = element, this.tapCount = 0, this.lastTapTime = 0, this.config = {
          press: {
            time: null !== (_b = null === (_a = null == config ? void 0 : config.press) || void 0 === _a ? void 0 : _a.time) && void 0 !== _b ? _b : 251,
            threshold: null !== (_d = null === (_c = null == config ? void 0 : config.press) || void 0 === _c ? void 0 : _c.threshold) && void 0 !== _d ? _d : 9
          },
          swipe: {
            threshold: null !== (_f = null === (_e = null == config ? void 0 : config.swipe) || void 0 === _e ? void 0 : _e.threshold) && void 0 !== _f ? _f : 10,
            velocity: null !== (_h = null === (_g = null == config ? void 0 : config.swipe) || void 0 === _g ? void 0 : _g.velocity) && void 0 !== _h ? _h : .3
          },
          tap: {
            interval: null !== (_k = null === (_j = null == config ? void 0 : config.tap) || void 0 === _j ? void 0 : _j.interval) && void 0 !== _k ? _k : 300
          }
        }, this.initEvents();
      }
      initEvents() {
        const {
          element: element
        } = this;
        element && (element.addEventListener("pointerdown", this.onStart), element.addEventListener("pointermove", this.onMove), element.addEventListener("pointerup", this.onEnd), element.addEventListener("pointerleave", this.onEnd), element.addEventListener("pointerupoutside", this.onEnd));
      }
      removeEvents() {
        const {
          element: element
        } = this;
        element && (element.removeEventListener("pointerdown", this.onStart), element.removeEventListener("pointermove", this.onMove), element.removeEventListener("pointerup", this.onEnd), element.removeEventListener("pointerleave", this.onEnd), element.removeEventListener("pointerupoutside", this.onEnd));
      }
      release() {
        this.removeEvents(), this.element = null;
      }
      getEventType(point) {
        const {
          eventType: eventType,
          startTime: startTime,
          startPoints: startPoints
        } = this;
        if ("press" === eventType) return eventType;
        let type;
        return type = clock.now() - startTime > this.config.press.time && calcDistance(startPoints[0], point) < this.config.press.threshold ? "press" : "pan", this.eventType = type, type;
      }
      enable(eventType) {
        this.processEvent[eventType] = !0;
      }
      isProcess(eventType) {
        return this.processEvent[eventType];
      }
      pushEvent(type, ev) {
        const {
            emitThrottles: emitThrottles
          } = this,
          newEvent = {
            type: type,
            ev: ev
          };
        for (let i = 0, len = emitThrottles.length; i < len; i++) if (emitThrottles[i].type === type) return void emitThrottles.splice(i, 1, newEvent);
        emitThrottles.push(newEvent);
      }
      clearPressTimeout() {
        this.pressTimeout && (clearTimeout(this.pressTimeout), this.pressTimeout = null);
      }
      reset() {
        this.clearPressTimeout(), this.startTime = 0, this.startDistance = 0, this.direction = null, this.eventType = null, this.prevMoveTime = 0, this.prevMovePoint = null, this.lastMoveTime = 0, this.lastMovePoint = null;
      }
      triggerEvent(type, ev) {
        this.pushEvent(type, ev);
        const {
          throttleTimer: throttleTimer,
          emitThrottles: emitThrottles
        } = this;
        throttleTimer || (this.throttleTimer = application.global.getRequestAnimationFrame()(() => {
          application.global.getCancelAnimationFrame()(this.throttleTimer), this.throttleTimer = null;
          for (let i = 0, len = emitThrottles.length; i < len; i++) {
            const {
              type: type,
              ev: ev
            } = emitThrottles[i];
            this.emitEvent(type, ev);
          }
          this.emitThrottles.length = 0;
        }));
      }
      triggerStartEvent(type, ev) {
        this.isProcess(type) || (this.enable(type), this.triggerEvent(`${type}start`, ev));
      }
      triggerEndEvent(ev) {
        const processEvent = this.processEvent;
        Object.keys(processEvent).forEach(type => {
          this.triggerEvent(`${type}end`, ev), "press" === type && this.triggerEvent(`${type}up`, ev), delete processEvent[type];
        });
      }
      emitEvent(type, e) {
        if (!this.element) return;
        const listeners = this.element._events[WILDCARD];
        if (listeners) if ("fn" in listeners) listeners.fn.call(listeners.context, e, type);else for (let i = 0, j = listeners.length; i < j && !e.propagationImmediatelyStopped; i++) listeners[i].fn.call(listeners[i].context, e, type);
        this.emit(type, e);
      }
    }

    var __decorate$v = undefined && undefined.__decorate || function (decorators, target, key, desc) {
        var d,
          c = arguments.length,
          r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      },
      __metadata$o = undefined && undefined.__metadata || function (k, v) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
      };
    const outP = [0, 0, 0],
      addArcToBezierPath = (bezierPath, startAngle, endAngle, cx, cy, rx, ry, clockwise) => {
        if (clockwise) for (; endAngle > startAngle;) endAngle -= pi2;else for (; endAngle < startAngle;) endAngle += pi2;
        const step = pi / 3 * (endAngle > startAngle ? 1 : -1);
        let sa = startAngle,
          ea = sa;
        for (; ea !== endAngle;) {
          ea = step > 0 ? Math.min(ea + step, endAngle) : Math.max(ea + step, endAngle);
          const delta = Math.abs(ea - sa),
            len = 4 * Math.tan(delta / 4) / 3,
            dir = ea < sa ? -1 : 1,
            c1 = Math.cos(sa),
            s1 = Math.sin(sa),
            c2 = Math.cos(ea),
            s2 = Math.sin(ea),
            x1 = c1 * rx + cx,
            y1 = s1 * ry + cy,
            x4 = c2 * rx + cx,
            y4 = s2 * ry + cy,
            hx = rx * len * dir,
            hy = ry * len * dir;
          bezierPath.push([x1 - hx * s1, y1 + hy * c1, x4 + hx * s2, y4 - hy * c2, x4, y4]), sa = ea;
        }
      };
    let BrowserContext2d = class {
      set fillStyle(d) {
        this.nativeContext.fillStyle = d;
      }
      get fillStyle() {
        return this.nativeContext.fillStyle;
      }
      set font(d) {
        this.nativeContext.font = d;
      }
      get font() {
        return this.nativeContext.font;
      }
      set globalAlpha(d) {
        this.nativeContext.globalAlpha = d * this.baseGlobalAlpha;
      }
      get globalAlpha() {
        return this.nativeContext.globalAlpha;
      }
      set lineCap(d) {
        this.nativeContext.lineCap = d;
      }
      get lineCap() {
        return this.nativeContext.lineCap;
      }
      set lineDashOffset(d) {
        this.nativeContext.lineDashOffset = d;
      }
      get lineDashOffset() {
        return this.nativeContext.lineDashOffset;
      }
      set lineJoin(d) {
        this.nativeContext.lineJoin = d;
      }
      get lineJoin() {
        return this.nativeContext.lineJoin;
      }
      set lineWidth(d) {
        this.nativeContext.lineWidth = d;
      }
      get lineWidth() {
        return this.nativeContext.lineWidth;
      }
      set miterLimit(d) {
        this.nativeContext.miterLimit = d;
      }
      get miterLimit() {
        return this.nativeContext.miterLimit;
      }
      set shadowBlur(d) {
        this.nativeContext.shadowBlur = d;
      }
      get shadowBlur() {
        return this.nativeContext.shadowBlur;
      }
      set shadowColor(d) {
        this.nativeContext.shadowColor = d;
      }
      get shadowColor() {
        return this.nativeContext.shadowColor;
      }
      set shadowOffsetX(d) {
        this.nativeContext.shadowOffsetX = d;
      }
      get shadowOffsetX() {
        return this.nativeContext.shadowOffsetX;
      }
      set shadowOffsetY(d) {
        this.nativeContext.shadowOffsetY = d;
      }
      get shadowOffsetY() {
        return this.nativeContext.shadowOffsetY;
      }
      set strokeStyle(d) {
        this.nativeContext.strokeStyle = d;
      }
      get strokeStyle() {
        return this.nativeContext.strokeStyle;
      }
      set textAlign(d) {
        this.nativeContext.textAlign = d;
      }
      get textAlign() {
        return this.nativeContext.textAlign;
      }
      set textBaseline(d) {
        this.nativeContext.textBaseline = d;
      }
      get textBaseline() {
        return this.nativeContext.textBaseline;
      }
      get inuse() {
        return !!this._inuse;
      }
      set inuse(use) {
        use !== !!this._inuse && (this._inuse = use, use ? (this.nativeContext.save(), this.reset()) : this.nativeContext.restore());
      }
      constructor(canvas, dpr) {
        this.fillAttributes = Object.assign(Object.assign({}, DefaultFillStyle), {
          opacity: 1
        }), this.strokeAttributes = Object.assign(Object.assign({}, DefaultStrokeStyle), {
          opacity: 1
        }), this.textAttributes = Object.assign(Object.assign({}, DefaultTextStyle), {
          opacity: 1
        }), this._clearShadowStyle = !1, this._clearFilterStyle = !1, this._clearGlobalCompositeOperationStyle = !1;
        const context = canvas.nativeCanvas.getContext("2d");
        if (!context) throw new Error("发生错误，获取2d上下文失败");
        this.nativeContext = context, this.canvas = canvas, this.matrix = new Matrix(1, 0, 0, 1, 0, 0), this.stack = [], this.dpr = dpr, this.applyedMatrix = new Matrix(1, 0, 0, 1, 0, 0), this._clearMatrix = new Matrix(1, 0, 0, 1, 0, 0), this.baseGlobalAlpha = 1;
      }
      reset() {
        this.stack.length && Logger$1.getInstance().warn("可能存在bug，matrix没有清空"), this.matrix.setValue(1, 0, 0, 1, 0, 0), this.applyedMatrix = new Matrix(1, 0, 0, 1, 0, 0), this.stack.length = 0, this.nativeContext.setTransform(1, 0, 0, 1, 0, 0);
      }
      getCanvas() {
        return this.canvas;
      }
      getContext() {
        return this.nativeContext;
      }
      setTransformForCurrent() {
        let force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !1;
        !force && this.applyedMatrix.equalToMatrix(this.matrix) || (this.applyedMatrix.setValue(this.matrix.a, this.matrix.b, this.matrix.c, this.matrix.d, this.matrix.e, this.matrix.f), this.nativeContext.setTransform(this.matrix.a, this.matrix.b, this.matrix.c, this.matrix.d, this.matrix.e, this.matrix.f));
      }
      get currentMatrix() {
        return this.matrix;
      }
      cloneMatrix(m) {
        return matrixAllocate.allocateByObj(m);
      }
      clear() {
        this.save(), this.resetTransform(), this.nativeContext.clearRect(0, 0, this.canvas.width, this.canvas.height), this.restore();
      }
      restore() {
        this.nativeContext.restore(), this.stack.length > 0 && (matrixAllocate.free(this.matrix), this.matrix = this.stack.pop(), this.setTransformForCurrent(!0));
      }
      highPerformanceRestore() {
        this.stack.length > 0 && (matrixAllocate.free(this.matrix), this.matrix = this.stack.pop());
      }
      rotate(rad) {
        let setTransform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
        this.matrix.rotate(rad), setTransform && this.setTransformForCurrent();
      }
      save() {
        const matrix = this.cloneMatrix(this.matrix);
        this.stack.push(matrix), this.nativeContext.save();
      }
      highPerformanceSave() {
        const matrix = this.cloneMatrix(this.matrix);
        this.stack.push(matrix);
      }
      scale(sx, sy) {
        let setTransform = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !0;
        this.matrix.scale(sx, sy), setTransform && this.setTransformForCurrent();
      }
      setScale(sx, sy) {
        let setTransform = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !0;
        this.matrix.setScale(sx, sy), setTransform && this.setTransformForCurrent();
      }
      scalePoint(sx, sy, px, py) {
        let setTransform = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !0;
        this.translate(px, py, !1), this.scale(sx, sy, !1), this.translate(-px, -py, !1), setTransform && this.setTransformForCurrent();
      }
      setTransform(a, b, c, d, e, f) {
        let setTransform = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : !0;
        let dpr = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : this.dpr;
        this.matrix.setValue(dpr * a, dpr * b, dpr * c, dpr * d, dpr * e, dpr * f), setTransform && this.setTransformForCurrent();
      }
      setTransformFromMatrix(matrix) {
        let setTransform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
        let dpr = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.dpr;
        this.matrix.setValue(matrix.a * dpr, matrix.b * dpr, matrix.c * dpr, matrix.d * dpr, matrix.e * dpr, matrix.f * dpr), setTransform && this.setTransformForCurrent();
      }
      resetTransform() {
        let setTransform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !0;
        let dpr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.dpr;
        this.setTransform(dpr, 0, 0, dpr, 0, 0), setTransform && this.setTransformForCurrent();
      }
      transform(a, b, c, d, e, f) {
        let setTransform = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : !0;
        this.matrix.multiply(a, b, c, d, e, f), setTransform && this.setTransformForCurrent();
      }
      transformFromMatrix(matrix, setTransform) {
        this.matrix.multiply(matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f), setTransform && this.setTransformForCurrent();
      }
      translate(x, y) {
        let setTransform = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !0;
        this.matrix.translate(x, y), setTransform && this.setTransformForCurrent();
      }
      rotateDegrees(deg) {
        let setTransform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
        const rad = deg * Math.PI / 180;
        this.rotate(rad, setTransform);
      }
      rotateAbout(rad, x, y) {
        let setTransform = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !0;
        this.translate(x, y, !1), this.rotate(rad, !1), this.translate(-x, -y, !1), setTransform && this.setTransformForCurrent();
      }
      rotateDegreesAbout(deg, x, y) {
        let setTransform = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !0;
        this.translate(x, y, !1), this.rotateDegrees(deg, !1), this.translate(-x, -y, !1), setTransform && this.setTransformForCurrent();
      }
      beginPath() {
        this.disableBeginPath || this.nativeContext.beginPath();
      }
      clip(path, fillRule) {
        path ? "string" == typeof path ? this.nativeContext.clip(path) : this.nativeContext.clip(path, fillRule) : this.nativeContext.clip();
      }
      arc(x, y, radius, startAngle, endAngle, anticlockwise, z) {
        if (z = z || 0, this.camera) {
          const arr = [];
          addArcToBezierPath(arr, startAngle, endAngle, x, y, radius, radius, anticlockwise);
          for (let i = 0; i < arr.length; ++i) {
            const bez = arr[i];
            this.bezierCurveTo(bez[0], bez[1], bez[2], bez[3], bez[4], bez[5], z);
          }
        } else this.nativeContext.arc(x, y, Math.max(0, radius), startAngle, endAngle, anticlockwise);
      }
      arcTo(x1, y1, x2, y2, radiusX) {
        this.nativeContext.arcTo(x1, y1, x2, y2, radiusX);
      }
      bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, z) {
        if (z = z || 0, this.camera) {
          let cp1z = z,
            cp2z = z;
          this.modelMatrix && (transformMat4(outP, [cp1x, cp1y, z], this.modelMatrix), cp1x = outP[0], cp1y = outP[1], cp1z = outP[2], transformMat4(outP, [cp2x, cp2y, z], this.modelMatrix), cp2x = outP[0], cp2y = outP[1], cp2z = outP[2], transformMat4(outP, [x, y, z], this.modelMatrix), x = outP[0], y = outP[1], z = outP[2]);
          let data = this.camera.vp(x, y, z);
          x = data.x, y = data.y, data = this.camera.vp(cp1x, cp1y, cp1z), cp1x = data.x, cp1y = data.y, data = this.camera.vp(cp2x, cp2y, cp2z), cp2x = data.x, cp2y = data.y;
        }
        this.nativeContext.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
      }
      closePath() {
        this.nativeContext.closePath();
      }
      ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise) {
        null == anticlockwise ? this.nativeContext.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle) : this.nativeContext.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise);
      }
      lineTo(x, y, z) {
        if (z = z || 0, this.camera) {
          this.modelMatrix && (transformMat4(outP, [x, y, z], this.modelMatrix), x = outP[0], y = outP[1], z = outP[2]);
          const data = this.camera.vp(x, y, z);
          x = data.x, y = data.y;
        }
        this.nativeContext.lineTo(x, y);
      }
      moveTo(x, y, z) {
        if (z = z || 0, this.camera) {
          this.modelMatrix && (transformMat4(outP, [x, y, z], this.modelMatrix), x = outP[0], y = outP[1], z = outP[2]);
          const data = this.camera.vp(x, y, z);
          x = data.x, y = data.y;
        }
        this.nativeContext.moveTo(x, y);
      }
      quadraticCurveTo(cpx, cpy, x, y, z) {
        if (z = z || 0, this.camera) {
          let cpz = z;
          this.modelMatrix && (transformMat4(outP, [cpx, cpy, z], this.modelMatrix), cpx = outP[0], cpy = outP[1], cpz = outP[2], transformMat4(outP, [x, y, z], this.modelMatrix), x = outP[0], y = outP[1], z = outP[2]);
          let data = this.camera.vp(x, y, z);
          x = data.x, y = data.y, data = this.camera.vp(cpx, cpy, cpz), cpx = data.x, cpy = data.y;
        }
        this.nativeContext.quadraticCurveTo(cpx, cpy, x, y);
      }
      rect(x, y, w, h, z) {
        z = z || 0, this.camera ? (this.moveTo(x, y, z), this.lineTo(x + w, y, z), this.lineTo(x + w, y + h, z), this.lineTo(x, y + h, z), this.closePath()) : this.nativeContext.rect(x, y, w, h);
      }
      createImageData() {
        const a = arguments;
        return 2 === a.length ? this.nativeContext.createImageData(a[0], a[1]) : 1 === a.length ? this.nativeContext.createImageData(a[0]) : null;
      }
      createLinearGradient(x0, y0, x1, y1) {
        return isFinite(x0 + y0 + x1 + y1) || (x0 = 0, y0 = 0, x1 = 0, y1 = 0), this.nativeContext.createLinearGradient(x0, y0, x1, y1);
      }
      createPattern(image, repetition) {
        return 0 === image.width || 0 === image.height ? null : this.nativeContext.createPattern(image, repetition);
      }
      createRadialGradient(x0, y0, r0, x1, y1, r1) {
        return this.nativeContext.createRadialGradient(x0, y0, r0, x1, y1, r1);
      }
      createConicGradient(x, y, startAngle, endAngle) {
        if (this.nativeContext.createConicGradient && Math.abs(endAngle - startAngle - 2 * Math.PI) < .001) return this.nativeContext.createConicGradient(startAngle, x, y);
        let pattern,
          edit = !1;
        const ctx = this;
        return {
          stops: [],
          addColorStop(offset, color) {
            this.stops.push([offset, color]), edit = !0;
          },
          GetPattern(minW, minH, deltaAngle) {
            return edit && (deltaAngle || (deltaAngle = endAngle - startAngle), pattern = createConicalGradient(ctx, this.stops, x, y, deltaAngle, startAngle, endAngle, minW, minH), edit = !1), pattern;
          }
        };
      }
      fill(path, fillRule) {
        this.disableFill || (path ? this.nativeContext.fill(path) : this.nativeContext.fill());
      }
      fillRect(x, y, width, height) {
        this.nativeContext.fillRect(x, y, width, height);
      }
      clearRect(x, y, w, h) {
        this.nativeContext.clearRect(x, y, w, h);
      }
      project(x, y, z) {
        if (z = z || 0, this.camera) {
          this.modelMatrix && (transformMat4(outP, [x, y, z], this.modelMatrix), x = outP[0], y = outP[1], z = outP[2]);
          const data = this.camera.vp(x, y, z);
          x = data.x, y = data.y;
        }
        return {
          x: x,
          y: y
        };
      }
      view(x, y, z) {
        return z = z || 0, this.camera ? (this.modelMatrix && (transformMat4(outP, [x, y, z], this.modelMatrix), x = outP[0], y = outP[1], z = outP[2]), this.camera.view(x, y, z)) : [x, y, z];
      }
      fillText(text, x, y, z) {
        if (z = z || 0, this.camera) {
          this.modelMatrix && (transformMat4(outP, [x, y, z], this.modelMatrix), x = outP[0], y = outP[1], z = outP[2]);
          const data = this.camera.vp(x, y, z);
          x = data.x, y = data.y;
        }
        this.nativeContext.fillText(text, x, y);
      }
      getImageData(sx, sy, sw, sh) {
        return this.nativeContext.getImageData(sx, sy, sw, sh);
      }
      getLineDash() {
        return this.nativeContext.getLineDash();
      }
      isPointInPath(x, y) {
        return this.nativeContext.isPointInPath(x, y);
      }
      isPointInStroke(x, y) {
        return this.nativeContext.isPointInStroke(x, y);
      }
      measureText(text) {
        let method = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : application.global.measureTextMethod;
        var _a, _b;
        if (!method || "native" === method) return this.nativeContext.measureText(text);
        this.mathTextMeasure || (this.mathTextMeasure = application.graphicUtil.createTextMeasureInstance({}, {}, () => this.canvas.nativeCanvas));
        const fontFamily = null !== (_a = this.fontFamily) && void 0 !== _a ? _a : DefaultTextStyle.fontFamily,
          fontSize = null !== (_b = this.fontSize) && void 0 !== _b ? _b : DefaultTextStyle.fontSize;
        return this.mathTextMeasure.textSpec.fontFamily === fontFamily && this.mathTextMeasure.textSpec.fontSize === fontSize || (this.mathTextMeasure.textSpec.fontFamily = fontFamily, this.mathTextMeasure.textSpec.fontSize = fontSize, this.mathTextMeasure._numberCharSize = null, this.mathTextMeasure._fullCharSize = null, this.mathTextMeasure._letterCharSize = null, this.mathTextMeasure._specialCharSizeMap = {}), this.mathTextMeasure.measure(text, method);
      }
      putImageData(imagedata, dx, dy) {
        this.nativeContext.putImageData(imagedata, dx, dy);
      }
      setLineDash(segments) {
        const a = arguments,
          _context = this.nativeContext;
        this.nativeContext.setLineDash ? a[0] && _context.setLineDash(a[0]) : "mozDash" in _context ? _context.mozDash = a[0] : "webkitLineDash" in _context && (_context.webkitLineDash = a[0]);
      }
      stroke(path) {
        this.disableStroke || (path ? this.nativeContext.stroke(path) : this.nativeContext.stroke());
      }
      strokeRect(x, y, width, height) {
        this.nativeContext.strokeRect(x, y, width, height);
      }
      strokeText(text, x, y, z) {
        if (z = z || 0, this.camera) {
          this.modelMatrix && (transformMat4(outP, [x, y, z], this.modelMatrix), x = outP[0], y = outP[1], z = outP[2]);
          const data = this.camera.vp(x, y, z);
          x = data.x, y = data.y;
        }
        this.nativeContext.strokeText(text, x, y);
      }
      drawImage() {
        const _context = this.nativeContext,
          a = arguments;
        3 === a.length ? _context.drawImage(a[0], a[1], a[2]) : 5 === a.length ? _context.drawImage(a[0], a[1], a[2], a[3], a[4]) : 9 === a.length && _context.drawImage(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);
      }
      setCommonStyle(params, attribute, offsetX, offsetY, defaultParams) {
        if (Array.isArray(defaultParams)) {
          if (defaultParams.length <= 1) return this._setCommonStyle(params, attribute, offsetX, offsetY, defaultParams[0]);
          const dp = Object.create(defaultParams[0]);
          return defaultParams.forEach((p, i) => {
            0 !== i && Object.assign(dp, p);
          }), this._setCommonStyle(params, attribute, offsetX, offsetY, dp);
        }
        return this._setCommonStyle(params, attribute, offsetX, offsetY, defaultParams);
      }
      _setCommonStyle(params, attribute, offsetX, offsetY, defaultParams) {
        const _context = this.nativeContext;
        defaultParams || (defaultParams = this.fillAttributes);
        const {
          fillOpacity = defaultParams.fillOpacity,
          opacity = defaultParams.opacity,
          fill = defaultParams.fill
        } = attribute;
        _context.globalAlpha = fillOpacity * opacity * this.baseGlobalAlpha, fillOpacity > 1e-12 && opacity > 1e-12 && (_context.fillStyle = createColor(this, fill, params, offsetX, offsetY));
      }
      setShadowBlendStyle(params, attribute, defaultParams) {
        if (Array.isArray(defaultParams)) {
          if (defaultParams.length <= 1) return this._setShadowBlendStyle(params, defaultParams[0]);
          const dp = Object.create(defaultParams[0]);
          return defaultParams.forEach((p, i) => {
            0 !== i && Object.assign(dp, p);
          }), this._setShadowBlendStyle(params, attribute, dp);
        }
        return this._setShadowBlendStyle(params, attribute, defaultParams);
      }
      _setShadowBlendStyle(params, attribute, defaultParams) {
        const _context = this.nativeContext;
        defaultParams || (defaultParams = this.fillAttributes);
        const {
          opacity = defaultParams.opacity,
          shadowBlur = defaultParams.shadowBlur,
          shadowColor = defaultParams.shadowColor,
          shadowOffsetX = defaultParams.shadowOffsetX,
          shadowOffsetY = defaultParams.shadowOffsetY,
          blur = defaultParams.blur,
          filter = defaultParams.filter,
          globalCompositeOperation = defaultParams.globalCompositeOperation
        } = attribute;
        opacity <= 1e-12 || (shadowBlur || shadowOffsetX || shadowOffsetY ? (_context.shadowBlur = shadowBlur * this.dpr, _context.shadowColor = shadowColor, _context.shadowOffsetX = shadowOffsetX * this.dpr, _context.shadowOffsetY = shadowOffsetY * this.dpr, this._clearShadowStyle = !0) : this._clearShadowStyle && (_context.shadowBlur = 0, _context.shadowOffsetX = 0, _context.shadowOffsetY = 0), blur ? (_context.filter = `blur(${blur}px)`, this._clearFilterStyle = !0) : filter ? (_context.filter = filter, this._clearFilterStyle = !0) : this._clearFilterStyle && (_context.filter = "blur(0px)", this._clearFilterStyle = !1), globalCompositeOperation ? (_context.globalCompositeOperation = globalCompositeOperation, this._clearGlobalCompositeOperationStyle = !0) : this._clearGlobalCompositeOperationStyle && (_context.globalCompositeOperation = "source-over", this._clearGlobalCompositeOperationStyle = !1));
      }
      setStrokeStyle(params, attribute, offsetX, offsetY, defaultParams) {
        if (Array.isArray(defaultParams)) {
          if (defaultParams.length <= 1) return this._setStrokeStyle(params, attribute, offsetX, offsetY, defaultParams[0]);
          const dp = Object.create(defaultParams[0]);
          return defaultParams.forEach((p, i) => {
            0 !== i && Object.assign(dp, p);
          }), this._setStrokeStyle(params, attribute, offsetX, offsetY, dp);
        }
        return this._setStrokeStyle(params, attribute, offsetX, offsetY, defaultParams);
      }
      _setStrokeStyle(params, attribute, offsetX, offsetY, defaultParams) {
        const _context = this.nativeContext;
        defaultParams || (defaultParams = this.strokeAttributes);
        const {
          strokeOpacity = defaultParams.strokeOpacity,
          opacity = defaultParams.opacity
        } = attribute;
        if (_context.globalAlpha = strokeOpacity * opacity * this.baseGlobalAlpha, strokeOpacity > 1e-12 && opacity > 1e-12) {
          const {
            lineWidth = defaultParams.lineWidth,
            stroke = defaultParams.stroke,
            lineJoin = defaultParams.lineJoin,
            lineDash = defaultParams.lineDash,
            lineDashOffset = defaultParams.lineDashOffset,
            lineCap = defaultParams.lineCap,
            miterLimit = defaultParams.miterLimit,
            keepStrokeScale = defaultParams.keepStrokeScale
          } = attribute;
          _context.lineWidth = keepStrokeScale ? lineWidth : getScaledStroke(this, lineWidth, this.dpr), _context.strokeStyle = createColor(this, stroke, params, offsetX, offsetY), _context.lineJoin = lineJoin, lineDash && (_context.setLineDash(lineDash), _context.lineDashOffset = lineDashOffset), _context.lineCap = lineCap, _context.miterLimit = miterLimit;
        }
      }
      setTextStyleWithoutAlignBaseline(params, defaultParams, z) {
        const _context = this.nativeContext;
        defaultParams || (defaultParams = this.textAttributes);
        const {
          scaleIn3d = defaultParams.scaleIn3d
        } = params;
        params.font ? _context.font = params.font : _context.font = getContextFont$1(params, defaultParams, scaleIn3d && this.camera && this.camera.getProjectionScale(z));
        const {
          fontFamily = defaultParams.fontFamily,
          fontSize = defaultParams.fontSize
        } = params;
        this.fontFamily = fontFamily, this.fontSize = fontSize, _context.textAlign = "left", _context.textBaseline = "alphabetic";
      }
      setTextStyle(params, defaultParams, z) {
        var _a, _b;
        const _context = this.nativeContext;
        defaultParams || (defaultParams = this.textAttributes), params.font ? _context.font = params.font : _context.font = getContextFont$1(params, defaultParams, this.camera && this.camera.getProjectionScale(z));
        const {
          fontFamily = defaultParams.fontFamily,
          fontSize = defaultParams.fontSize
        } = params;
        this.fontFamily = fontFamily, this.fontSize = fontSize, _context.textAlign = null !== (_a = params.textAlign) && void 0 !== _a ? _a : defaultParams.textAlign, _context.textBaseline = null !== (_b = params.textBaseline) && void 0 !== _b ? _b : defaultParams.textBaseline;
      }
      draw() {}
      clearMatrix() {
        let setTransform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !0;
        let dpr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.dpr;
        this.setTransformFromMatrix(this._clearMatrix, setTransform, dpr);
      }
      setClearMatrix(a, b, c, d, e, f) {
        this._clearMatrix.setValue(a, b, c, d, e, f);
      }
      onlyTranslate() {
        let dpr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.dpr;
        return this.matrix.a === dpr && 0 === this.matrix.b && 0 === this.matrix.c && this.matrix.d === dpr;
      }
      release() {
        this.stack.forEach(m => matrixAllocate.free(m)), this.stack.length = 0;
      }
    };
    BrowserContext2d.env = "browser", BrowserContext2d = __decorate$v([injectable(), __metadata$o("design:paramtypes", [Object, Number])], BrowserContext2d);

    var __decorate$u = undefined && undefined.__decorate || function (decorators, target, key, desc) {
        var d,
          c = arguments.length,
          r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      },
      __metadata$n = undefined && undefined.__metadata || function (k, v) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
      };
    let BrowserCanvas = class extends BaseCanvas {
      constructor(params) {
        super(params);
      }
      init(params) {
        const {
          container: container
        } = params;
        if ("string" == typeof container) {
          const _c = application.global.getElementById(container);
          _c && (this._container = _c);
        } else this._container = container;
        this._context = new BrowserContext2d(this, this._dpr), this.initStyle();
      }
      initStyle() {
        if (!this.controled) return;
        const {
          nativeCanvas: nativeCanvas
        } = this;
        nativeCanvas.width = this._pixelWidth, nativeCanvas.height = this._pixelHeight;
        !nativeCanvas.style || this.setCanvasStyle(nativeCanvas, this._x, this._y, this._displayWidth, this._displayHeight), this._container && this._container.appendChild(nativeCanvas), this.visiable || this.hide();
      }
      hide() {
        this._nativeCanvas && (this._nativeCanvas.style.display = "none");
      }
      show() {
        this._nativeCanvas && (this._nativeCanvas.style.display = "block");
      }
      applyPosition() {
        const canvas = this._nativeCanvas;
        canvas.style.position = "absolute", canvas.style.top = `${this._y}px`, canvas.style.left = `${this._x}px`;
      }
      resetStyle(params) {
        if (!this.controled) return;
        const {
            width = this._displayWidth,
            height = this._displayHeight,
            dpr = this._dpr,
            x = this._x,
            y = this._y
          } = params,
          {
            nativeCanvas: nativeCanvas
          } = this;
        nativeCanvas.width = width * dpr, nativeCanvas.height = height * dpr;
        !nativeCanvas.style || this.setCanvasStyle(nativeCanvas, x, y, width, height), params.id && (nativeCanvas.id = params.id), this.visiable || this.hide();
      }
      setCanvasStyle(canvas, x, y, w, h) {
        this.controled && (canvas.style.width = `${w}px`, canvas.style.height = `${h}px`);
      }
      toDataURL(mimeType, quality) {
        return "image/jpeg" === mimeType ? this._nativeCanvas.toDataURL(mimeType, quality) : "image/png" === mimeType ? this._nativeCanvas.toDataURL(mimeType) : this._nativeCanvas.toDataURL(mimeType, quality);
      }
      resize(width, height) {
        if (!this.controled) return;
        this._pixelWidth = width * this._dpr, this._pixelHeight = height * this._dpr, this._displayWidth = width, this._displayHeight = height, this._nativeCanvas.style && (this._nativeCanvas.style.width = `${width}px`, this._nativeCanvas.style.height = `${height}px`), this._nativeCanvas.width = this._pixelWidth, this._nativeCanvas.height = this._pixelHeight;
        this._context.dpr = this._dpr;
      }
    };
    BrowserCanvas.env = "browser", BrowserCanvas = __decorate$u([injectable(), __metadata$n("design:paramtypes", [Object])], BrowserCanvas);

    function createModule(CanvasConstructor, ContextConstructor) {
      return new ContainerModule(bind => {
        bind(CanvasFactory).toDynamicValue(() => params => new CanvasConstructor(params)).whenTargetNamed(CanvasConstructor.env), bind(Context2dFactory).toDynamicValue(() => (params, dpr) => new ContextConstructor(params, dpr)).whenTargetNamed(ContextConstructor.env);
      });
    }

    const browserCanvasModule = createModule(BrowserCanvas, BrowserContext2d);

    var __decorate$t = undefined && undefined.__decorate || function (decorators, target, key, desc) {
        var d,
          c = arguments.length,
          r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      },
      __metadata$m = undefined && undefined.__metadata || function (k, v) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
      },
      __param$i = undefined && undefined.__param || function (paramIndex, decorator) {
        return function (target, key) {
          decorator(target, key, paramIndex);
        };
      };
    let DefaultCanvasPickerService = class extends DefaultPickService {
      constructor(contributions, drawContribution, pickItemInterceptorContributions, pickServiceInterceptorContributions) {
        super(pickItemInterceptorContributions, pickServiceInterceptorContributions), this.contributions = contributions, this.drawContribution = drawContribution, this.pickItemInterceptorContributions = pickItemInterceptorContributions, this.pickServiceInterceptorContributions = pickServiceInterceptorContributions, this.global.hooks.onSetEnv.tap("canvas-picker-service", (_, env, global) => {
          this.configure(global, env);
        }), this.configure(this.global, this.global.env), this.pickerMap = new Map(), this.init();
      }
      init() {
        this.contributions.getContributions().forEach(item => {
          this.pickerMap.set(item.numberType, item);
        }), super._init();
      }
      configure(global, env) {
        this.pickCanvas = canvasAllocate.shareCanvas(), this.pickContext = this.pickCanvas.getContext("2d");
      }
      pickItem(graphic, point, parentMatrix, params) {
        if (!1 === graphic.attribute.pickable) return null;
        if (this.InterceptorContributions.length) for (let i = 0; i < this.InterceptorContributions.length; i++) {
          const drawContribution = this.InterceptorContributions[i];
          if (drawContribution.beforePickItem) {
            const ret = drawContribution.beforePickItem(graphic, this, point, params, {
              parentMatrix: parentMatrix
            });
            if (ret) return ret;
          }
        }
        const picker = this.pickerMap.get(graphic.numberType);
        if (!picker) return null;
        const pd = picker.contains(graphic, point, params),
          g = pd ? graphic : null,
          data = {
            graphic: g,
            params: pd
          };
        if (g) return data;
        if (this.InterceptorContributions.length) for (let i = 0; i < this.InterceptorContributions.length; i++) {
          const drawContribution = this.InterceptorContributions[i];
          if (drawContribution.afterPickItem) {
            const ret = drawContribution.afterPickItem(graphic, this, point, params, {
              parentMatrix: parentMatrix
            });
            if (ret) return ret;
          }
        }
        return data;
      }
    };
    DefaultCanvasPickerService = __decorate$t([injectable(), __param$i(0, inject(ContributionProvider)), __param$i(0, named(CanvasPickerContribution)), __param$i(1, inject(DrawContribution)), __param$i(2, inject(ContributionProvider)), __param$i(2, named(PickItemInterceptor)), __param$i(3, inject(ContributionProvider)), __param$i(3, named(PickServiceInterceptor)), __metadata$m("design:paramtypes", [Object, Object, Object, Object])], DefaultCanvasPickerService);

    var __decorate$s = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let DefaultCanvasGroupPicker = class {
      constructor() {
        this.type = "group", this.numberType = GROUP_NUMBER_TYPE;
      }
      contains(group, point, params) {
        return !1;
      }
    };
    DefaultCanvasGroupPicker = __decorate$s([injectable()], DefaultCanvasGroupPicker);

    const m = new ContainerModule((bind, unbind, isBound, rebind) => {
      m.__vloaded || (m.__vloaded = !0, bind(CanvasGroupPicker).to(DefaultCanvasGroupPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasGroupPicker), bindContributionProvider(bind, CanvasPickerContribution));
    });
    m.__vloaded = !1;
    var canvasModule = m;

    const canvasPickerModule = new ContainerModule((bind, unbind, isBound, rebind) => {
      isBound(DefaultCanvasPickerService) || bind(DefaultCanvasPickerService).toSelf().inSingletonScope(), isBound(PickerService) ? rebind(PickerService).toService(DefaultCanvasPickerService) : bind(PickerService).toService(DefaultCanvasPickerService);
    });
    function loadCanvasPicker(c) {
      c.load(canvasModule), c.load(canvasPickerModule);
    }

    var BrowserWindowHandlerContribution_1,
      __decorate$r = undefined && undefined.__decorate || function (decorators, target, key, desc) {
        var d,
          c = arguments.length,
          r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      },
      __metadata$l = undefined && undefined.__metadata || function (k, v) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
      };
    let BrowserWindowHandlerContribution = BrowserWindowHandlerContribution_1 = class extends BaseWindowHandlerContribution {
      get container() {
        return this.canvas.nativeCanvas.parentElement;
      }
      static GenerateCanvasId() {
        return `${BrowserWindowHandlerContribution_1.idprefix}_${BrowserWindowHandlerContribution_1.prefix_count++}`;
      }
      constructor() {
        super(), this.type = "browser", this._canvasIsIntersecting = !0, this.global = application.global, this.viewBox = new AABBBounds$1(), this.modelMatrix = new Matrix(1, 0, 0, 1, 0, 0);
      }
      getTitle() {
        return this.canvas.id && this.canvas.id.toString();
      }
      getWH() {
        return {
          width: this.canvas.width / (this.canvas.dpr || 1),
          height: this.canvas.height / (this.canvas.dpr || 1)
        };
      }
      getXY() {
        return this.canvas.nativeCanvas.getBoundingClientRect();
      }
      createWindow(params) {
        params.canvas ? this.createWindowByCanvas(params) : this.createWindowByConfig(params), this.postInit();
      }
      postInit() {
        if (this.global.optimizeVisible) try {
          this.observerCanvas();
        } catch (err) {
        }
      }
      isElementVisible(el) {
        const rect = el.getBoundingClientRect(),
          vWidth = window.innerWidth || document.documentElement.clientWidth,
          vHeight = window.innerHeight || document.documentElement.clientHeight;
        return !(rect.right < 0 || rect.bottom < 0 || rect.left > vWidth || rect.top > vHeight);
      }
      observerCanvas() {
        this._canvasIsIntersecting = this.isElementVisible(this.canvas.nativeCanvas);
        const observer = new IntersectionObserver((entries, observer) => {
          entries.forEach(entry => {
            this._canvasIsIntersecting !== entry.isIntersecting ? (this._canvasIsIntersecting = entry.isIntersecting, this._onVisibleChangeCb && this._onVisibleChangeCb(entry.isIntersecting)) : this._canvasIsIntersecting = entry.isIntersecting;
          });
        });
        observer && observer.observe(this.canvas.nativeCanvas);
      }
      createWindowByConfig(params) {
        const nativeCanvas = this.global.createCanvas({
          width: params.width,
          height: params.height
        });
        let container;
        if (container = "string" == typeof params.container ? this.global.getElementById(params.container) : params.container ? params.container : this.global.getRootElement(), !container) throw new Error("发生错误，containerId可能传入有误");
        params.offscreen ? container = null : container.appendChild(nativeCanvas);
        const options = {
          width: params.width,
          height: params.height,
          dpr: params.dpr,
          nativeCanvas: nativeCanvas,
          container: container,
          id: BrowserWindowHandlerContribution_1.GenerateCanvasId(),
          canvasControled: !0
        };
        this.canvas = new BrowserCanvas(options);
      }
      createWindowByCanvas(params) {
        var _a;
        let canvas;
        if ("string" == typeof params.canvas) {
          if (canvas = this.global.getElementById(params.canvas), !canvas) throw new Error("canvasId 参数不正确，请确认canvas存在并插入dom");
        } else canvas = params.canvas;
        if (!canvas) throw new Error("发生错误，传入的canvas不正确");
        let width = params.width,
          height = params.height;
        if (null == width || null == height || !params.canvasControled) {
          const data = canvas.getBoundingClientRect();
          width = data.width, height = data.height;
        }
        let dpr = params.dpr;
        if (null == dpr) {
          dpr = null !== (_a = canvas.getContext("2d").pixelRatio) && void 0 !== _a ? _a : canvas.width / width;
        }
        this.canvas = new BrowserCanvas({
          width: width,
          height: height,
          dpr: dpr,
          nativeCanvas: canvas,
          canvasControled: params.canvasControled
        });
      }
      releaseWindow() {
        this.canvas.release();
      }
      resizeWindow(width, height) {
        this.canvas.resize(width, height);
      }
      setDpr(dpr) {
        this.canvas.dpr = dpr;
      }
      getContext() {
        return this.canvas.getContext();
      }
      getNativeHandler() {
        return this.canvas;
      }
      getDpr() {
        return this.canvas.dpr;
      }
      addEventListener(type, listener, options) {
        return this.canvas.nativeCanvas.addEventListener(type, listener, options);
      }
      removeEventListener(type, listener, options) {
        return this.canvas.nativeCanvas.removeEventListener(type, listener, options);
      }
      dispatchEvent(event) {
        return this.canvas.nativeCanvas.dispatchEvent(event);
      }
      getStyle() {
        var _a;
        return null !== (_a = this.canvas.nativeCanvas.style) && void 0 !== _a ? _a : {};
      }
      setStyle(style) {
        this.canvas.nativeCanvas.style = style;
      }
      getBoundingClientRect() {
        const c = this.canvas.nativeCanvas,
          wh = this.getWH();
        return c.parentElement ? this.canvas.nativeCanvas.getBoundingClientRect() : {
          x: 0,
          y: 0,
          width: wh.width,
          height: wh.height,
          left: 0,
          top: 0,
          right: 0,
          bottom: 0
        };
      }
      clearViewBox(color) {
        const vb = this.viewBox,
          context = this.getContext(),
          dpr = this.getDpr();
        context.nativeContext.save(), context.nativeContext.setTransform(dpr, 0, 0, dpr, 0, 0), context.clearRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1), color && (context.fillStyle = color, context.fillRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1)), context.nativeContext.restore();
      }
      isVisible(bbox) {
        return this._canvasIsIntersecting;
      }
      onVisibleChange(cb) {
        this._onVisibleChangeCb = cb;
      }
      getTopLeft(baseWindow) {
        return this.global.getElementTopLeft(this.canvas.nativeCanvas, baseWindow);
      }
    };
    BrowserWindowHandlerContribution.env = "browser", BrowserWindowHandlerContribution.idprefix = "visactor_window", BrowserWindowHandlerContribution.prefix_count = 0, BrowserWindowHandlerContribution = BrowserWindowHandlerContribution_1 = __decorate$r([injectable(), __metadata$l("design:paramtypes", [])], BrowserWindowHandlerContribution);
    const browserWindowModule = new ContainerModule(bind => {
      bind(BrowserWindowHandlerContribution).toSelf(), bind(WindowHandlerContribution).toDynamicValue(ctx => ctx.container.get(BrowserWindowHandlerContribution)).whenTargetNamed(BrowserWindowHandlerContribution.env);
    });

    var __decorate$q = undefined && undefined.__decorate || function (decorators, target, key, desc) {
        var d,
          c = arguments.length,
          r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      },
      __metadata$k = undefined && undefined.__metadata || function (k, v) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
      },
      __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator.throw(value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            var value;
            result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P(function (resolve) {
              resolve(value);
            })).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
    class DynamicB {
      get x1() {
        return this.dom.getBoundingClientRect().left;
      }
      get x2() {
        return this.dom.getBoundingClientRect().right;
      }
      get y1() {
        return this.dom.getBoundingClientRect().top;
      }
      get y2() {
        return this.dom.getBoundingClientRect().bottom;
      }
      get width() {
        return this.dom.getBoundingClientRect().width;
      }
      get height() {
        return this.dom.getBoundingClientRect().height;
      }
      constructor(dom) {
        this.dom = dom;
      }
    }
    function createImageElement(src) {
      let isSvg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
      const img = document.createElement("img");
      if (application.global.isImageAnonymous && (img.crossOrigin = "anonymous"), isSvg) {
        const data = new Blob([src], {
          type: "image/svg+xml"
        });
        src = window.URL.createObjectURL(data);
      }
      if (img.src = src, img.complete) return Promise.resolve(img);
      return new Promise((resolve, reject) => {
        img.onload = () => {
          resolve(img);
        }, img.onerror = () => {
          reject(new Error("加载失败"));
        };
      });
    }
    let BrowserEnvContribution = class extends BaseEnvContribution {
      constructor() {
        super(), this.type = "browser", this.supportEvent = !0;
        try {
          this.supportsTouchEvents = "ontouchstart" in globalThis, this.supportsPointerEvents = !!globalThis.PointerEvent, this.supportsMouseEvents = !!globalThis.MouseEvent;
        } catch (err) {
          this.supportsTouchEvents = !1, this.supportsPointerEvents = !1, this.supportsPointerEvents = !1;
        }
        this.applyStyles = !0;
      }
      mapToCanvasPoint(nativeEvent, domElement) {
        var _a, _b;
        let clientX = 0,
          clientY = 0,
          offsetX = 0,
          offsetY = 0;
        if (nativeEvent.changedTouches) {
          const data = null !== (_a = nativeEvent.changedTouches[0]) && void 0 !== _a ? _a : {};
          clientX = data.clientX || 0, clientY = data.clientY || 0, offsetX = clientX, offsetY = clientY;
        } else clientX = nativeEvent.clientX || 0, clientY = nativeEvent.clientY || 0, offsetX = nativeEvent.offsetX || 0, offsetY = nativeEvent.offsetY || 0;
        if (domElement) {
          const x = clientX,
            y = clientY,
            rect = domElement.getBoundingClientRect(),
            nativeCanvas = null === (_b = domElement.getNativeHandler) || void 0 === _b ? void 0 : _b.call(domElement).nativeCanvas;
          let scaleX, scaleY;
          return nativeCanvas && (scaleX = rect.width / nativeCanvas.offsetWidth, scaleY = rect.height / nativeCanvas.offsetHeight), {
            x: (x - rect.left) / (isValidNumber$3(scaleX) ? scaleX : 1),
            y: (y - rect.top) / (isValidNumber$3(scaleY) ? scaleY : 1)
          };
        }
        return {
          x: offsetX,
          y: offsetY
        };
      }
      getNativeAABBBounds(_dom) {
        let dom = _dom;
        if ("string" == typeof _dom && (dom = new DOMParser().parseFromString(_dom, "text/html").firstChild, dom.lastChild && (dom = dom.lastChild.firstChild)), dom.getBoundingClientRect) {
          const b = dom.getBoundingClientRect();
          return new DynamicB(b);
        }
        return new AABBBounds$1();
      }
      removeDom(dom) {
        return dom.parentElement.removeChild(dom), !0;
      }
      updateDom(dom, params) {
        const {
          width: width,
          height: height,
          style: style
        } = params;
        return style && (isString$6(style) ? dom.setAttribute("style", style) : Object.keys(style).forEach(k => {
          dom.style[k] = style[k];
        })), null != width && (dom.style.width = `${width}px`), null != height && (dom.style.height = `${height}px`), !0;
      }
      createDom(params) {
        const {
            tagName = "div",
            parent: parent
          } = params,
          element = document.createElement(tagName);
        if (this.updateDom(element, params), parent) {
          const pd = isString$6(parent) ? this.getElementById(parent) : parent;
          pd && pd.appendChild && pd.appendChild(element);
        }
        return element;
      }
      loadImage(url) {
        return createImageElement(url, !1).then(img => ({
          data: img,
          loadState: "success"
        })).catch(() => ({
          data: null,
          loadState: "fail"
        }));
      }
      loadSvg(url) {
        return createImageElement(url, !0).then(img => ({
          data: img,
          loadState: "success"
        })).catch(() => ({
          data: null,
          loadState: "fail"
        }));
      }
      createCanvas(params) {
        var _a, _b;
        const canvas = document.createElement("canvas");
        params.id && (canvas.id = null !== (_a = params.id) && void 0 !== _a ? _a : Generator.GenAutoIncrementId().toString());
        const dpr = null !== (_b = params.dpr) && void 0 !== _b ? _b : window.devicePixelRatio;
        return params.width && params.height && (canvas.style.width = `${params.width}px`, canvas.style.height = `${params.height}px`, canvas.width = params.width * dpr, canvas.height = params.height * dpr), canvas;
      }
      createOffscreenCanvas(params) {
        var _a;
        const dpr = null !== (_a = params.dpr) && void 0 !== _a ? _a : window.devicePixelRatio;
        return new OffscreenCanvas(params.width * dpr, params.height * dpr);
      }
      releaseCanvas(canvas) {
        let c;
        c = "string" == typeof canvas ? document.getElementById(canvas) : canvas, c && c.parentElement && c.parentElement.removeChild(c);
      }
      getDevicePixelRatio() {
        return window.devicePixelRatio;
      }
      getRequestAnimationFrame() {
        return window.requestAnimationFrame;
      }
      getCancelAnimationFrame() {
        return window.cancelAnimationFrame;
      }
      addEventListener(type, listener, options) {
        return document.addEventListener(type, listener, options);
      }
      removeEventListener(type, listener, options) {
        return document.removeEventListener(type, listener, options);
      }
      dispatchEvent(event) {
        return document.dispatchEvent(event);
      }
      getElementById(str) {
        return document.getElementById(str);
      }
      getRootElement() {
        return document.body;
      }
      getDocument() {
        return document;
      }
      release() {}
      getElementTop(element, baseWindow) {
        let actualTop = element.offsetTop,
          current = element.offsetParent;
        for (; null !== current;) actualTop += current.offsetTop, current = current.offsetParent;
        return actualTop;
      }
      getElementLeft(element, baseWindow) {
        let actualLeft = element.offsetLeft,
          current = element.offsetParent;
        for (; null !== current;) actualLeft += current.offsetLeft, current = current.offsetParent;
        return actualLeft;
      }
      getElementTopLeft(element, baseWindow) {
        let actualTop = element.offsetTop,
          actualLeft = element.offsetLeft,
          current = element.offsetParent;
        for (; null !== current;) actualTop += current.offsetTop, actualLeft += current.offsetLeft, current = current.offsetParent;
        return {
          top: actualTop,
          left: actualLeft
        };
      }
      loadFont(font, source, descriptors) {
        return __awaiter(this, void 0, void 0, function* () {
          return new FontFace(font, isString$6(source) ? `url(${source})` : source, descriptors).load().then(function (loadedFont) {
            return document.fonts.add(loadedFont), {
              loadState: "success"
            };
          }).catch(function (error) {
            return {
              loadState: "fail"
            };
          });
        });
      }
      isMacOS() {
        if (void 0 === this._isMacOS) try {
          this._isMacOS = navigator.platform.toUpperCase().indexOf("MAC") >= 0;
        } catch (err) {
          this._isMacOS = !1;
        }
        return this._isMacOS;
      }
      copyToClipBoard(text) {
        return navigator.clipboard.writeText(text).then(() => {}).catch(err => {});
      }
    };
    BrowserEnvContribution = __decorate$q([injectable(), __metadata$k("design:paramtypes", [])], BrowserEnvContribution);

    const browserEnvModule = new ContainerModule(bind => {
      browserEnvModule.isBrowserBound || (browserEnvModule.isBrowserBound = !0, bind(BrowserEnvContribution).toSelf().inSingletonScope(), bind(EnvContribution).toService(BrowserEnvContribution));
    });
    browserEnvModule.isBrowserBound = !1;
    function loadBrowserEnv(container) {
      let loadPicker = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
      loadBrowserEnv.__loaded || (loadBrowserEnv.__loaded = !0, container.load(browserEnvModule), container.load(browserCanvasModule), container.load(browserWindowModule), loadPicker && loadCanvasPicker(container));
    }
    loadBrowserEnv.__loaded = !1;

    class PickerBase {
      contains(graphic, point, params) {
        if (!graphic.AABBBounds.containsPoint(point)) return !1;
        if ("imprecise" === graphic.attribute.pickMode) return !0;
        if (!this.canvasRenderer) return !0;
        const {
          pickContext: pickContext
        } = null != params ? params : {};
        if (!pickContext) return !1;
        const attribute = graphic.getGraphicTheme();
        pickContext.highPerformanceSave();
        let {
          x = attribute.x,
          y = attribute.y
        } = graphic.attribute;
        if (graphic.transMatrix.onlyTranslate()) {
          const point = graphic.getOffsetXY(attribute);
          x += point.x, y += point.y, pickContext.setTransformForCurrent();
        } else x = 0, y = 0, pickContext.transformFromMatrix(graphic.transMatrix, !0);
        let picked = !1,
          _final = !1;
        return this.canvasRenderer.drawShape(graphic, pickContext, x, y, {}, null, (context, arcAttribute, themeAttribute, final) => !(!picked && !_final) || (picked = context.isPointInPath(point.x, point.y), _final = final || _final, picked), (context, arcAttribute, themeAttribute, final) => {
          if (picked || _final) return !0;
          const lineWidth = arcAttribute.lineWidth || themeAttribute.lineWidth,
            pickStrokeBuffer = arcAttribute.pickStrokeBuffer || themeAttribute.pickStrokeBuffer,
            keepStrokeScale = arcAttribute.keepStrokeScale || themeAttribute.keepStrokeScale;
          return pickContext.lineWidth = keepStrokeScale ? lineWidth + pickStrokeBuffer : getScaledStroke(pickContext, lineWidth + pickStrokeBuffer, pickContext.dpr), picked = context.isPointInStroke(point.x, point.y), _final = final || _final, picked;
        }), pickContext.highPerformanceRestore(), picked;
      }
    }

    var __decorate$p = undefined && undefined.__decorate || function (decorators, target, key, desc) {
        var d,
          c = arguments.length,
          r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      },
      __metadata$j = undefined && undefined.__metadata || function (k, v) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
      },
      __param$h = undefined && undefined.__param || function (paramIndex, decorator) {
        return function (target, key) {
          decorator(target, key, paramIndex);
        };
      };
    let DefaultMathArcPicker = class extends PickerBase {
      constructor(canvasRenderer) {
        super(), this.canvasRenderer = canvasRenderer, this.type = "arc", this.numberType = ARC_NUMBER_TYPE;
      }
    };
    DefaultMathArcPicker = __decorate$p([injectable(), __param$h(0, inject(ArcRender)), __metadata$j("design:paramtypes", [Object])], DefaultMathArcPicker);

    let loadArcPick$1 = !1;
    const arcMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
      loadArcPick$1 || (loadArcPick$1 = !0, bind(MathArcPicker).to(DefaultMathArcPicker).inSingletonScope(), bind(MathPickerContribution).toService(MathArcPicker));
    });

    var __decorate$o = undefined && undefined.__decorate || function (decorators, target, key, desc) {
        var d,
          c = arguments.length,
          r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      },
      __metadata$i = undefined && undefined.__metadata || function (k, v) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
      },
      __param$g = undefined && undefined.__param || function (paramIndex, decorator) {
        return function (target, key) {
          decorator(target, key, paramIndex);
        };
      };
    let DefaultMathCirclePicker = class extends PickerBase {
      constructor(canvasRenderer) {
        super(), this.canvasRenderer = canvasRenderer, this.type = "circle", this.numberType = CIRCLE_NUMBER_TYPE;
      }
    };
    DefaultMathCirclePicker = __decorate$o([injectable(), __param$g(0, inject(CircleRender)), __metadata$i("design:paramtypes", [Object])], DefaultMathCirclePicker);

    let loadCirclePick$1 = !1;
    const circleMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
      loadCirclePick$1 || (loadCirclePick$1 = !0, bind(MathCirclePicker).to(DefaultMathCirclePicker).inSingletonScope(), bind(MathPickerContribution).toService(MathCirclePicker));
    });

    var __decorate$n = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let DefaultMathImagePicker = class {
      constructor() {
        this.type = "image", this.numberType = IMAGE_NUMBER_TYPE;
      }
      contains(image, point, params) {
        const {
          pickContext: pickContext
        } = null != params ? params : {};
        return !!pickContext && !!image.AABBBounds.containsPoint(point);
      }
    };
    DefaultMathImagePicker = __decorate$n([injectable()], DefaultMathImagePicker);

    let loadImagePick$1 = !1;
    const imageMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
      loadImagePick$1 || (loadImagePick$1 = !0, bind(MathImagePicker).to(DefaultMathImagePicker).inSingletonScope(), bind(DefaultMathImagePicker).toService(MathImagePicker));
    });

    var __decorate$m = undefined && undefined.__decorate || function (decorators, target, key, desc) {
        var d,
          c = arguments.length,
          r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      },
      __metadata$h = undefined && undefined.__metadata || function (k, v) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
      },
      __param$f = undefined && undefined.__param || function (paramIndex, decorator) {
        return function (target, key) {
          decorator(target, key, paramIndex);
        };
      };
    let DefaultMathLinePicker = class extends PickerBase {
      constructor(canvasRenderer) {
        super(), this.canvasRenderer = canvasRenderer, this.type = "line", this.numberType = LINE_NUMBER_TYPE;
      }
    };
    DefaultMathLinePicker = __decorate$m([injectable(), __param$f(0, inject(LineRender)), __metadata$h("design:paramtypes", [Object])], DefaultMathLinePicker);

    let loadLinePick$1 = !1;
    const lineMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
      loadLinePick$1 || (loadLinePick$1 = !0, bind(MathLinePicker).to(DefaultMathLinePicker).inSingletonScope(), bind(MathPickerContribution).toService(MathLinePicker));
    });

    var __decorate$l = undefined && undefined.__decorate || function (decorators, target, key, desc) {
        var d,
          c = arguments.length,
          r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      },
      __metadata$g = undefined && undefined.__metadata || function (k, v) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
      },
      __param$e = undefined && undefined.__param || function (paramIndex, decorator) {
        return function (target, key) {
          decorator(target, key, paramIndex);
        };
      };
    let DefaultMathPolygonPicker = class extends PickerBase {
      constructor(canvasRenderer) {
        super(), this.canvasRenderer = canvasRenderer, this.type = "polygon", this.numberType = POLYGON_NUMBER_TYPE;
      }
    };
    DefaultMathPolygonPicker = __decorate$l([injectable(), __param$e(0, inject(PolygonRender)), __metadata$g("design:paramtypes", [Object])], DefaultMathPolygonPicker);

    let loadPolygonPick$1 = !1;
    const polygonMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
      loadPolygonPick$1 || (loadPolygonPick$1 = !0, bind(MathPolygonPicker).to(DefaultMathPolygonPicker).inSingletonScope(), bind(MathPickerContribution).toService(MathPolygonPicker));
    });

    var __decorate$k = undefined && undefined.__decorate || function (decorators, target, key, desc) {
        var d,
          c = arguments.length,
          r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      },
      __metadata$f = undefined && undefined.__metadata || function (k, v) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
      },
      __param$d = undefined && undefined.__param || function (paramIndex, decorator) {
        return function (target, key) {
          decorator(target, key, paramIndex);
        };
      };
    let DefaultMathPathPicker = class extends PickerBase {
      constructor(canvasRenderer) {
        super(), this.canvasRenderer = canvasRenderer, this.type = "path", this.numberType = PATH_NUMBER_TYPE;
      }
    };
    DefaultMathPathPicker = __decorate$k([injectable(), __param$d(0, inject(PathRender)), __metadata$f("design:paramtypes", [Object])], DefaultMathPathPicker);

    let loadPathPick$1 = !1;
    const pathMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
      loadPathPick$1 || (loadPathPick$1 = !0, bind(MathPathPicker).to(DefaultMathPathPicker).inSingletonScope(), bind(MathPickerContribution).toService(MathPathPicker));
    });

    const _bounds = new AABBBounds$1();
    class RectPickerBase {
      constructor() {
        this.type = "rect", this.numberType = RECT_NUMBER_TYPE;
      }
      contains(rect, point, params) {
        if (!rect.AABBBounds.containsPoint(point)) return !1;
        if ("imprecise" === rect.attribute.pickMode) return !0;
        const {
          pickContext: pickContext
        } = null != params ? params : {};
        if (!pickContext) return !1;
        const rectAttribute = rect.getGraphicTheme(),
          {
            cornerRadius = rectAttribute.cornerRadius
          } = rect.attribute;
        let {
          x = rectAttribute.x,
          y = rectAttribute.y
        } = rect.attribute;
        pickContext.highPerformanceSave();
        let onlyTranslate = !0;
        if (rect.transMatrix.onlyTranslate()) {
          const point = rect.getOffsetXY(rectAttribute);
          x += point.x, y += point.y, pickContext.setTransformForCurrent();
        } else x = 0, y = 0, onlyTranslate = !1, pickContext.transformFromMatrix(rect.transMatrix, !0);
        let picked = !0;
        if (!onlyTranslate || rect.shadowRoot || isNumber$6(cornerRadius, !0) && 0 !== cornerRadius || isArray$9(cornerRadius) && cornerRadius.some(num => 0 !== num)) picked = !1, this.canvasRenderer.drawShape(rect, pickContext, x, y, {}, null, (context, rectAttribute, themeAttribute) => !!picked || (picked = context.isPointInPath(point.x, point.y), picked), (context, rectAttribute, themeAttribute) => {
          if (picked) return !0;
          const lineWidth = rectAttribute.lineWidth || themeAttribute.lineWidth,
            pickStrokeBuffer = rectAttribute.pickStrokeBuffer || themeAttribute.pickStrokeBuffer,
            keepStrokeScale = rectAttribute.keepStrokeScale || themeAttribute.keepStrokeScale;
          return pickContext.lineWidth = keepStrokeScale ? lineWidth + pickStrokeBuffer : getScaledStroke(pickContext, lineWidth + pickStrokeBuffer, pickContext.dpr), picked = context.isPointInStroke(point.x, point.y), picked;
        });else {
          const {
            fill = rectAttribute.fill,
            stroke = rectAttribute.stroke,
            lineWidth = rectAttribute.lineWidth
          } = rect.attribute;
          if (fill) picked = !0;else if (stroke) {
            const bounds = rect.AABBBounds;
            _bounds.setValue(bounds.x1, bounds.y1, bounds.x2, bounds.y2), _bounds.expand(-lineWidth / 2), picked = !_bounds.containsPoint(point);
          }
        }
        return pickContext.highPerformanceRestore(), picked;
      }
    }

    var __decorate$j = undefined && undefined.__decorate || function (decorators, target, key, desc) {
        var d,
          c = arguments.length,
          r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      },
      __metadata$e = undefined && undefined.__metadata || function (k, v) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
      },
      __param$c = undefined && undefined.__param || function (paramIndex, decorator) {
        return function (target, key) {
          decorator(target, key, paramIndex);
        };
      };
    let DefaultMathRectPicker = class extends RectPickerBase {
      constructor(canvasRenderer) {
        super(), this.canvasRenderer = canvasRenderer;
      }
    };
    DefaultMathRectPicker = __decorate$j([injectable(), __param$c(0, inject(RectRender)), __metadata$e("design:paramtypes", [Object])], DefaultMathRectPicker);

    let loadRectPick$1 = !1;
    const rectMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
      loadRectPick$1 || (loadRectPick$1 = !0, bind(MathRectPicker).to(DefaultMathRectPicker).inSingletonScope(), bind(MathPickerContribution).toService(MathRectPicker));
    });

    let loadRichTextPick = !1;
    const richTextMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
      loadRichTextPick || (loadRichTextPick = !0, bind(MathImagePicker).to(DefaultMathImagePicker).inSingletonScope(), bind(DefaultMathImagePicker).toService(MathImagePicker));
    });

    var __decorate$i = undefined && undefined.__decorate || function (decorators, target, key, desc) {
        var d,
          c = arguments.length,
          r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      },
      __metadata$d = undefined && undefined.__metadata || function (k, v) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
      },
      __param$b = undefined && undefined.__param || function (paramIndex, decorator) {
        return function (target, key) {
          decorator(target, key, paramIndex);
        };
      };
    let DefaultMathSymbolPicker = class extends PickerBase {
      constructor(canvasRenderer) {
        super(), this.canvasRenderer = canvasRenderer, this.type = "symbol", this.numberType = SYMBOL_NUMBER_TYPE;
      }
    };
    DefaultMathSymbolPicker = __decorate$i([injectable(), __param$b(0, inject(SymbolRender)), __metadata$d("design:paramtypes", [Object])], DefaultMathSymbolPicker);

    let loadSymbolPick$1 = !1;
    const symbolMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
      loadSymbolPick$1 || (loadSymbolPick$1 = !0, bind(MathSymbolPicker).to(DefaultMathSymbolPicker).inSingletonScope(), bind(MathPickerContribution).toService(MathSymbolPicker));
    });

    var __decorate$h = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let DefaultMathTextPicker = class {
      constructor() {
        this.type = "text", this.numberType = TEXT_NUMBER_TYPE;
      }
      contains(text, point, params) {
        return !!text.AABBBounds.containsPoint(point);
      }
    };
    DefaultMathTextPicker = __decorate$h([injectable()], DefaultMathTextPicker);

    let loadTextPick$1 = !1;
    const textMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
      loadTextPick$1 || (loadTextPick$1 = !0, bind(MathTextPicker).to(DefaultMathTextPicker).inSingletonScope(), bind(MathPickerContribution).toService(MathTextPicker));
    });

    var __decorate$g = undefined && undefined.__decorate || function (decorators, target, key, desc) {
        var d,
          c = arguments.length,
          r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      },
      __metadata$c = undefined && undefined.__metadata || function (k, v) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
      };
    let NodeContext2d = class extends BrowserContext2d {
      constructor(canvas, dpr) {
        super(canvas, dpr);
        const context = canvas.nativeCanvas.getContext("2d");
        if (!context) throw new Error("发生错误，获取2d上下文失败");
        this.nativeContext = context, this.canvas = canvas, this.matrix = new Matrix(1, 0, 0, 1, 0, 0), this.stack = [], this.dpr = null != dpr ? dpr : 1;
      }
      release() {}
    };
    NodeContext2d.env = "node", NodeContext2d = __decorate$g([injectable(), __metadata$c("design:paramtypes", [Object, Number])], NodeContext2d);

    var __decorate$f = undefined && undefined.__decorate || function (decorators, target, key, desc) {
        var d,
          c = arguments.length,
          r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      },
      __metadata$b = undefined && undefined.__metadata || function (k, v) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
      };
    let NodeCanvas = class extends BaseCanvas {
      constructor(params) {
        super(params);
      }
      init() {
        this._context = new NodeContext2d(this, this._dpr), this.nativeCanvas.width = this._pixelWidth, this.nativeCanvas.height = this._pixelHeight;
      }
      release() {
        this._nativeCanvas.release && isFunction$7(this._nativeCanvas.release) && this._nativeCanvas.release();
      }
    };
    NodeCanvas.env = "node", NodeCanvas = __decorate$f([injectable(), __metadata$b("design:paramtypes", [Object])], NodeCanvas);

    const nodeCanvasModule = createModule(NodeCanvas, NodeContext2d);

    var __decorate$e = undefined && undefined.__decorate || function (decorators, target, key, desc) {
        var d,
          c = arguments.length,
          r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      },
      __metadata$a = undefined && undefined.__metadata || function (k, v) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
      },
      __param$a = undefined && undefined.__param || function (paramIndex, decorator) {
        return function (target, key) {
          decorator(target, key, paramIndex);
        };
      };
    let NodeWindowHandlerContribution = class extends BaseWindowHandlerContribution {
      get container() {
        return null;
      }
      constructor(global) {
        super(), this.global = global, this.type = "node";
      }
      getTitle() {
        return "";
      }
      getWH() {
        return {
          width: this.canvas.displayWidth,
          height: this.canvas.displayHeight
        };
      }
      getXY() {
        return {
          x: 0,
          y: 0
        };
      }
      createWindow(params) {
        params.canvas ? this.createWindowByCanvas(params) : this.createWindowByConfig(params);
      }
      createWindowByConfig(params) {
        const nativeCanvas = this.global.createCanvas({
            width: params.width,
            height: params.height
          }),
          options = {
            width: params.width,
            height: params.height,
            dpr: params.dpr,
            nativeCanvas: nativeCanvas,
            id: Generator.GenAutoIncrementId().toString(),
            canvasControled: !0
          };
        this.canvas = new NodeCanvas(options);
      }
      createWindowByCanvas(params) {
        var _a;
        const canvas = params.canvas,
          dpr = null !== (_a = params.dpr) && void 0 !== _a ? _a : 1;
        let width = params.width,
          height = params.height;
        null != width && null != height && params.canvasControled || (width = canvas.width / dpr, height = canvas.height / dpr), this.canvas = new NodeCanvas({
          width: width,
          height: height,
          dpr: dpr,
          nativeCanvas: canvas,
          canvasControled: params.canvasControled
        });
      }
      releaseWindow() {
        this.canvas.release();
      }
      resizeWindow(width, height) {
        this.canvas.resize(width, height);
      }
      setDpr(dpr) {
        this.canvas.dpr = dpr;
      }
      getContext() {
        return this.canvas.getContext();
      }
      getNativeHandler() {
        return this.canvas;
      }
      getDpr() {
        return this.canvas.dpr;
      }
      getImageBuffer() {
        let type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "image/png";
        return this.canvas.nativeCanvas.toBuffer(type);
      }
      addEventListener(type, listener, options) {}
      dispatchEvent(event) {
        return !0;
      }
      removeEventListener(type, listener, options) {}
      getStyle() {}
      setStyle(style) {}
      getBoundingClientRect() {
        return null;
      }
      clearViewBox(color) {}
    };
    NodeWindowHandlerContribution.env = "node", NodeWindowHandlerContribution = __decorate$e([injectable(), __param$a(0, inject(VGlobal)), __metadata$a("design:paramtypes", [Object])], NodeWindowHandlerContribution);
    const nodeWindowModule = new ContainerModule(bind => {
      bind(NodeWindowHandlerContribution).toSelf(), bind(WindowHandlerContribution).toDynamicValue(ctx => ctx.container.get(NodeWindowHandlerContribution)).whenTargetNamed(NodeWindowHandlerContribution.env);
    });

    var __decorate$d = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    let NodeEnvContribution = class extends BaseEnvContribution {
      constructor() {
        super(...arguments), this.type = "node", this._lastTime = 0, this.supportEvent = !1;
      }
      configure(service, pkg) {
        service.env === this.type && (service.setActiveEnvContribution(this), this.pkg = pkg);
      }
      getDynamicCanvasCount() {
        return 0;
      }
      getStaticCanvasCount() {
        return 999;
      }
      loadJson(url) {
        const jsonPromise = fetch(url).then(data => data.json());
        return jsonPromise.then(json => ({
          data: json,
          state: "success"
        })).catch(() => ({
          data: null,
          state: "fail"
        })), jsonPromise;
      }
      loadArrayBuffer(url) {
        return fetch(url).then(data => data.arrayBuffer()).then(arrayBuffer => ({
          data: arrayBuffer,
          loadState: "success"
        })).catch(() => ({
          data: null,
          loadState: "fail"
        }));
      }
      loadImage(url) {
        const {
          loadImage: loadImage
        } = this.pkg;
        return loadImage ? loadImage(url).then(image => ({
          loadState: image ? "success" : "fail",
          data: image
        })).catch(() => ({
          loadState: "fail",
          data: null
        })) : Promise.reject(new Error("node-canvas loadImage could not be found!"));
      }
      loadSvg(svgStr) {
        const Resvg = this.pkg.Resvg;
        if (!Resvg) return Promise.reject(new Error("@resvg/resvg-js svgParser could not be found!"));
        const pngData = new Resvg(svgStr).render().asPng();
        return this.loadImage(pngData);
      }
      createCanvas(params) {
        return this.pkg.createCanvas(params.width, params.height);
      }
      releaseCanvas(canvas) {}
      getDevicePixelRatio() {
        return 1;
      }
      getRequestAnimationFrame() {
        return function (callback) {
          return rafBasedSto.call(callback);
        };
      }
      getCancelAnimationFrame() {
        return h => {
          rafBasedSto.clear(h);
        };
      }
      addEventListener(type, listener, options) {}
      removeEventListener(type, listener, options) {}
      getElementById(str) {
        return null;
      }
      getRootElement() {
        return null;
      }
      dispatchEvent(event) {}
      release() {}
      createOffscreenCanvas(params) {}
    };
    NodeEnvContribution = __decorate$d([injectable()], NodeEnvContribution);

    const nodeEnvModule = new ContainerModule(bind => {
      nodeEnvModule.isNodeBound || (nodeEnvModule.isNodeBound = !0, bind(NodeEnvContribution).toSelf().inSingletonScope(), bind(EnvContribution).toService(NodeEnvContribution));
    });
    nodeEnvModule.isNodeBound = !1;
    function loadNodeEnv(container) {
      loadNodeEnv.__loaded || (loadNodeEnv.__loaded = !0, container.load(nodeEnvModule), container.load(nodeCanvasModule), container.load(nodeWindowModule));
    }
    loadNodeEnv.__loaded = !1;

    var __decorate$c = undefined && undefined.__decorate || function (decorators, target, key, desc) {
        var d,
          c = arguments.length,
          r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      },
      __metadata$9 = undefined && undefined.__metadata || function (k, v) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
      },
      __param$9 = undefined && undefined.__param || function (paramIndex, decorator) {
        return function (target, key) {
          decorator(target, key, paramIndex);
        };
      };
    let DefaultCanvasArcPicker = class extends PickerBase {
      constructor(canvasRenderer) {
        super(), this.canvasRenderer = canvasRenderer, this.type = "arc", this.numberType = ARC_NUMBER_TYPE;
      }
    };
    DefaultCanvasArcPicker = __decorate$c([injectable(), __param$9(0, inject(ArcRender)), __metadata$9("design:paramtypes", [Object])], DefaultCanvasArcPicker);

    let loadArcPick = !1;
    const arcCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
      loadArcPick || (loadArcPick = !0, bind(CanvasArcPicker).to(DefaultCanvasArcPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasArcPicker));
    });

    var __decorate$b = undefined && undefined.__decorate || function (decorators, target, key, desc) {
        var d,
          c = arguments.length,
          r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      },
      __metadata$8 = undefined && undefined.__metadata || function (k, v) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
      },
      __param$8 = undefined && undefined.__param || function (paramIndex, decorator) {
        return function (target, key) {
          decorator(target, key, paramIndex);
        };
      };
    let DefaultCanvasRectPicker = class extends RectPickerBase {
      constructor(canvasRenderer) {
        super(), this.canvasRenderer = canvasRenderer;
      }
    };
    DefaultCanvasRectPicker = __decorate$b([injectable(), __param$8(0, inject(RectRender)), __metadata$8("design:paramtypes", [Object])], DefaultCanvasRectPicker);

    let loadRectPick = !1;
    const rectCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
      loadRectPick || (loadRectPick = !0, bind(CanvasRectPicker).to(DefaultCanvasRectPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasRectPicker));
    });

    class BaseLinePicker extends BaseRender {
      contains(graphic, point, params) {
        if (!graphic.AABBBounds.containsPoint(point)) return !1;
        if ("imprecise" === graphic.attribute.pickMode) return !0;
        const {
          pickContext: pickContext
        } = null != params ? params : {};
        if (!pickContext) return !1;
        pickContext.highPerformanceSave();
        const lineAttribute = graphic.getGraphicTheme(),
          data = this.transform(graphic, lineAttribute, pickContext),
          {
            x: x,
            y: y,
            z: z,
            lastModelMatrix: lastModelMatrix
          } = data;
        let pickPoint = point;
        if (pickContext.camera) {
          pickPoint = point.clone();
          const globalMatrix = graphic.parent.globalTransMatrix;
          pickPoint.x = globalMatrix.a * point.x + globalMatrix.c * point.y + globalMatrix.e, pickPoint.y = globalMatrix.b * point.x + globalMatrix.d * point.y + globalMatrix.f;
        }
        this.canvasRenderer.z = z;
        let picked = !1;
        return this.canvasRenderer.drawShape(graphic, pickContext, x, y, {}, null, context => !!picked || (picked = context.isPointInPath(pickPoint.x, pickPoint.y), picked), (context, lineAttribute, themeAttribute) => {
          if (picked) return !0;
          const lineWidth = lineAttribute.lineWidth || themeAttribute.lineWidth,
            pickStrokeBuffer = lineAttribute.pickStrokeBuffer || themeAttribute.pickStrokeBuffer,
            keepStrokeScale = lineAttribute.keepStrokeScale || themeAttribute.keepStrokeScale;
          return pickContext.lineWidth = keepStrokeScale ? lineWidth + pickStrokeBuffer : getScaledStroke(pickContext, lineWidth + pickStrokeBuffer, pickContext.dpr), picked = context.isPointInStroke(pickPoint.x, pickPoint.y), picked;
        }), this.canvasRenderer.z = 0, pickContext.modelMatrix !== lastModelMatrix && mat4Allocate.free(pickContext.modelMatrix), pickContext.modelMatrix = lastModelMatrix, pickContext.highPerformanceRestore(), picked;
      }
    }

    var __decorate$a = undefined && undefined.__decorate || function (decorators, target, key, desc) {
        var d,
          c = arguments.length,
          r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      },
      __metadata$7 = undefined && undefined.__metadata || function (k, v) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
      },
      __param$7 = undefined && undefined.__param || function (paramIndex, decorator) {
        return function (target, key) {
          decorator(target, key, paramIndex);
        };
      };
    let DefaultCanvasLinePicker = class extends BaseLinePicker {
      constructor(canvasRenderer) {
        super(), this.canvasRenderer = canvasRenderer, this.type = "line", this.numberType = LINE_NUMBER_TYPE;
      }
    };
    DefaultCanvasLinePicker = __decorate$a([injectable(), __param$7(0, inject(LineRender)), __metadata$7("design:paramtypes", [Object])], DefaultCanvasLinePicker);

    let loadLinePick = !1;
    const lineCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
      loadLinePick || (loadLinePick = !0, bind(CanvasLinePicker).to(DefaultCanvasLinePicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasLinePicker));
    });

    class Base3dPicker extends BaseRender {
      contains(graphic, point, params) {
        const {
          pickContext: pickContext
        } = null != params ? params : {};
        if (!pickContext) return !1;
        const attribute = graphic.getGraphicTheme();
        pickContext.highPerformanceSave();
        const data = this.transform(graphic, attribute, pickContext),
          {
            x: x,
            y: y,
            z: z,
            lastModelMatrix: lastModelMatrix
          } = data;
        let pickPoint = point;
        if (pickContext.camera) {
          pickPoint = point.clone();
          const globalMatrix = graphic.parent.globalTransMatrix;
          pickPoint.x = globalMatrix.a * point.x + globalMatrix.c * point.y + globalMatrix.e, pickPoint.y = globalMatrix.b * point.x + globalMatrix.d * point.y + globalMatrix.f;
        }
        this.canvasRenderer.z = z;
        let picked = !1;
        return this.canvasRenderer.drawShape(graphic, pickContext, x, y, params, null, (context, arc3dAttribute, themeAttribute) => !!picked || (picked = context.isPointInPath(pickPoint.x, pickPoint.y), picked)), this.canvasRenderer.z = 0, pickContext.modelMatrix !== lastModelMatrix && mat4Allocate.free(pickContext.modelMatrix), pickContext.modelMatrix = lastModelMatrix, pickContext.highPerformanceRestore(), picked;
      }
    }

    var __decorate$9 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
        var d,
          c = arguments.length,
          r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      },
      __metadata$6 = undefined && undefined.__metadata || function (k, v) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
      },
      __param$6 = undefined && undefined.__param || function (paramIndex, decorator) {
        return function (target, key) {
          decorator(target, key, paramIndex);
        };
      };
    let DefaultCanvasSymbolPicker = class extends Base3dPicker {
      constructor(canvasRenderer) {
        super(), this.canvasRenderer = canvasRenderer, this.type = "symbol", this.numberType = SYMBOL_NUMBER_TYPE;
      }
      contains(symbol, point, params) {
        const {
          pickContext: pickContext
        } = null != params ? params : {};
        if (!pickContext) return !1;
        const parsedPath = symbol.getParsedPath();
        if (!pickContext.camera) {
          if (!symbol.AABBBounds.containsPoint(point)) return !1;
          if (parsedPath.isSvg || "imprecise" === symbol.attribute.pickMode) return !0;
        }
        pickContext.highPerformanceSave();
        const symbolAttribute = symbol.getGraphicTheme(),
          data = this.transform(symbol, symbolAttribute, pickContext),
          {
            x: x,
            y: y,
            z: z,
            lastModelMatrix: lastModelMatrix
          } = data;
        let pickPoint = point;
        if (pickContext.camera) {
          pickPoint = point.clone();
          const globalMatrix = symbol.parent.globalTransMatrix;
          pickPoint.x = globalMatrix.a * point.x + globalMatrix.c * point.y + globalMatrix.e, pickPoint.y = globalMatrix.b * point.x + globalMatrix.d * point.y + globalMatrix.f;
        }
        this.canvasRenderer.z = z;
        let picked = !1;
        return this.canvasRenderer.drawShape(symbol, pickContext, x, y, {}, null, (context, symbolAttribute, themeAttribute) => !!picked || (picked = context.isPointInPath(pickPoint.x, pickPoint.y), picked), (context, symbolAttribute, themeAttribute) => {
          if (picked) return !0;
          const lineWidth = symbolAttribute.lineWidth || themeAttribute.lineWidth,
            pickStrokeBuffer = symbolAttribute.pickStrokeBuffer || themeAttribute.pickStrokeBuffer,
            keepStrokeScale = symbolAttribute.keepStrokeScale || themeAttribute.keepStrokeScale;
          return pickContext.lineWidth = keepStrokeScale ? lineWidth + pickStrokeBuffer : getScaledStroke(pickContext, lineWidth + pickStrokeBuffer, pickContext.dpr), picked = context.isPointInStroke(pickPoint.x, pickPoint.y), picked;
        }), this.canvasRenderer.z = 0, pickContext.modelMatrix !== lastModelMatrix && mat4Allocate.free(pickContext.modelMatrix), pickContext.modelMatrix = lastModelMatrix, pickContext.highPerformanceRestore(), picked;
      }
    };
    DefaultCanvasSymbolPicker = __decorate$9([injectable(), __param$6(0, inject(SymbolRender)), __metadata$6("design:paramtypes", [Object])], DefaultCanvasSymbolPicker);

    let loadSymbolPick = !1;
    const symbolCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
      loadSymbolPick || (loadSymbolPick = !0, bind(CanvasSymbolPicker).to(DefaultCanvasSymbolPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasSymbolPicker));
    });

    var __decorate$8 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
        var d,
          c = arguments.length,
          r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      },
      __metadata$5 = undefined && undefined.__metadata || function (k, v) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
      },
      __param$5 = undefined && undefined.__param || function (paramIndex, decorator) {
        return function (target, key) {
          decorator(target, key, paramIndex);
        };
      };
    let DefaultCanvasCirclePicker = class extends PickerBase {
      constructor(canvasRenderer) {
        super(), this.canvasRenderer = canvasRenderer, this.type = "circle", this.numberType = CIRCLE_NUMBER_TYPE;
      }
    };
    DefaultCanvasCirclePicker = __decorate$8([injectable(), __param$5(0, inject(CircleRender)), __metadata$5("design:paramtypes", [Object])], DefaultCanvasCirclePicker);

    let loadCirclePick = !1;
    const circleCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
      loadCirclePick || (loadCirclePick = !0, bind(CanvasCirclePicker).to(DefaultCanvasCirclePicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasCirclePicker));
    });

    var __decorate$7 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
        var d,
          c = arguments.length,
          r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      },
      __metadata$4 = undefined && undefined.__metadata || function (k, v) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
      },
      __param$4 = undefined && undefined.__param || function (paramIndex, decorator) {
        return function (target, key) {
          decorator(target, key, paramIndex);
        };
      };
    let DefaultCanvasTextPicker = class extends Base3dPicker {
      constructor(canvasRenderer) {
        super(), this.canvasRenderer = canvasRenderer, this.type = "text", this.numberType = TEXT_NUMBER_TYPE;
      }
      contains(text, point, params) {
        const {
          pickContext: pickContext
        } = null != params ? params : {};
        if (!pickContext) return !1;
        const bounds = text.AABBBounds;
        if (!pickContext.camera) return !!bounds.containsPoint(point);
        pickContext.highPerformanceSave();
        const textAttribute = text.getGraphicTheme(),
          {
            keepDirIn3d = textAttribute.keepDirIn3d
          } = text.attribute,
          computed3dMatrix = !keepDirIn3d,
          data = this.transform(text, textAttribute, pickContext, computed3dMatrix),
          {
            x: x,
            y: y,
            z: z,
            lastModelMatrix: lastModelMatrix
          } = data;
        this.canvasRenderer.z = z;
        let pickPoint = point;
        if (pickContext.camera) {
          pickPoint = point.clone();
          const globalMatrix = text.parent.globalTransMatrix;
          pickPoint.x = globalMatrix.a * point.x + globalMatrix.c * point.y + globalMatrix.e, pickPoint.y = globalMatrix.b * point.x + globalMatrix.d * point.y + globalMatrix.f;
        }
        let picked = !1;
        return this.canvasRenderer.drawShape(text, pickContext, x, y, {}, null, (context, symbolAttribute, themeAttribute) => {
          if (picked) return !0;
          const {
              fontSize = textAttribute.fontSize,
              textBaseline = textAttribute.textBaseline,
              textAlign = textAttribute.textAlign
            } = text.attribute,
            bounds = text.AABBBounds,
            height = bounds.height(),
            width = bounds.width(),
            offsetY = textLayoutOffsetY(textBaseline, height, fontSize),
            offsetX = textDrawOffsetX(textAlign, width);
          return context.rect(offsetX + x, offsetY + y, width, height, z), picked = context.isPointInPath(pickPoint.x, pickPoint.y), picked;
        }, (context, symbolAttribute, themeAttribute) => picked), this.canvasRenderer.z = 0, pickContext.modelMatrix !== lastModelMatrix && mat4Allocate.free(pickContext.modelMatrix), pickContext.modelMatrix = lastModelMatrix, pickContext.highPerformanceRestore(), picked;
      }
    };
    DefaultCanvasTextPicker = __decorate$7([injectable(), __param$4(0, inject(TextRender)), __metadata$4("design:paramtypes", [Object])], DefaultCanvasTextPicker);

    let loadTextPick = !1;
    const textCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
      loadTextPick || (loadTextPick = !0, bind(CanvasTextPicker).to(DefaultCanvasTextPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasTextPicker));
    });

    var __decorate$6 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
        var d,
          c = arguments.length,
          r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      },
      __metadata$3 = undefined && undefined.__metadata || function (k, v) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
      },
      __param$3 = undefined && undefined.__param || function (paramIndex, decorator) {
        return function (target, key) {
          decorator(target, key, paramIndex);
        };
      };
    let DefaultCanvasPathPicker = class extends BaseLinePicker {
      constructor(canvasRenderer) {
        super(), this.canvasRenderer = canvasRenderer, this.type = "path", this.numberType = PATH_NUMBER_TYPE;
      }
    };
    DefaultCanvasPathPicker = __decorate$6([injectable(), __param$3(0, inject(PathRender)), __metadata$3("design:paramtypes", [Object])], DefaultCanvasPathPicker);

    let loadPathPick = !1;
    const pathCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
      loadPathPick || (loadPathPick = !0, bind(CanvasPathPicker).to(DefaultCanvasPathPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasPathPicker));
    });

    var __decorate$5 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
        var d,
          c = arguments.length,
          r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      },
      __metadata$2 = undefined && undefined.__metadata || function (k, v) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
      },
      __param$2 = undefined && undefined.__param || function (paramIndex, decorator) {
        return function (target, key) {
          decorator(target, key, paramIndex);
        };
      };
    let DefaultCanvasPolygonPicker = class extends PickerBase {
      constructor(canvasRenderer) {
        super(), this.canvasRenderer = canvasRenderer, this.type = "polygon", this.numberType = POLYGON_NUMBER_TYPE;
      }
    };
    DefaultCanvasPolygonPicker = __decorate$5([injectable(), __param$2(0, inject(PolygonRender)), __metadata$2("design:paramtypes", [Object])], DefaultCanvasPolygonPicker);

    let loadPolygonPick = !1;
    const polygonCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
      loadPolygonPick || (loadPolygonPick = !0, bind(CanvasPolygonPicker).to(DefaultCanvasPolygonPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasPolygonPicker));
    });

    var __decorate$4 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
        var d,
          c = arguments.length,
          r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      },
      __metadata$1 = undefined && undefined.__metadata || function (k, v) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
      },
      __param$1 = undefined && undefined.__param || function (paramIndex, decorator) {
        return function (target, key) {
          decorator(target, key, paramIndex);
        };
      };
    let DefaultCanvasRichTextPicker = class {
      constructor(canvasRenderer) {
        this.canvasRenderer = canvasRenderer, this.type = "richtext", this.numberType = RICHTEXT_NUMBER_TYPE;
      }
      contains(richtext, point, params) {
        return !!richtext.AABBBounds.containsPoint(point);
      }
    };
    DefaultCanvasRichTextPicker = __decorate$4([injectable(), __param$1(0, inject(RichTextRender)), __metadata$1("design:paramtypes", [Object])], DefaultCanvasRichTextPicker);

    let loadRichtextPick = !1;
    const richtextCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
      loadRichtextPick || (loadRichtextPick = !0, bind(CanvasRichTextPicker).to(DefaultCanvasRichTextPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasRichTextPicker));
    });

    var __decorate$3 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
        var d,
          c = arguments.length,
          r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      },
      __metadata = undefined && undefined.__metadata || function (k, v) {
        if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
      },
      __param = undefined && undefined.__param || function (paramIndex, decorator) {
        return function (target, key) {
          decorator(target, key, paramIndex);
        };
      };
    let DefaultCanvasImagePicker = class extends PickerBase {
      constructor(canvasRenderer) {
        super(), this.canvasRenderer = canvasRenderer, this.type = "image", this.numberType = IMAGE_NUMBER_TYPE;
      }
    };
    DefaultCanvasImagePicker = __decorate$3([injectable(), __param(0, inject(ImageRender)), __metadata("design:paramtypes", [Object])], DefaultCanvasImagePicker);

    let loadImagePick = !1;
    const imageCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
      loadImagePick || (loadImagePick = !0, bind(CanvasImagePicker).to(DefaultCanvasImagePicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasImagePicker));
    });

    var lib$1 = {};

    var gif = {};

    var lib = {};

    Object.defineProperty(lib, "__esModule", {
      value: true
    });
    lib.loop = lib.conditional = lib.parse = void 0;
    var parse$3 = function parse(stream, schema) {
      var result = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var parent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : result;
      if (Array.isArray(schema)) {
        schema.forEach(function (partSchema) {
          return parse(stream, partSchema, result, parent);
        });
      } else if (typeof schema === 'function') {
        schema(stream, result, parent, parse);
      } else {
        var key = Object.keys(schema)[0];
        if (Array.isArray(schema[key])) {
          parent[key] = {};
          parse(stream, schema[key], result, parent[key]);
        } else {
          parent[key] = schema[key](stream, result, parent, parse);
        }
      }
      return result;
    };
    lib.parse = parse$3;
    var conditional = function conditional(schema, conditionFunc) {
      return function (stream, result, parent, parse) {
        if (conditionFunc(stream, result, parent)) {
          parse(stream, schema, result, parent);
        }
      };
    };
    lib.conditional = conditional;
    var loop = function loop(schema, continueFunc) {
      return function (stream, result, parent, parse) {
        var arr = [];
        var lastStreamPos = stream.pos;
        while (continueFunc(stream, result, parent)) {
          var newParent = {};
          parse(stream, schema, result, newParent); // cases when whole file is parsed but no termination is there and stream position is not getting updated as well
          // it falls into infinite recursion, null check to avoid the same

          if (stream.pos === lastStreamPos) {
            break;
          }
          lastStreamPos = stream.pos;
          arr.push(newParent);
        }
        return arr;
      };
    };
    lib.loop = loop;

    var uint8 = {};

    Object.defineProperty(uint8, "__esModule", {
      value: true
    });
    uint8.readBits = uint8.readArray = uint8.readUnsigned = uint8.readString = uint8.peekBytes = uint8.readBytes = uint8.peekByte = uint8.readByte = uint8.buildStream = void 0;

    // Default stream and parsers for Uint8TypedArray data type
    var buildStream = function buildStream(uint8Data) {
      return {
        data: uint8Data,
        pos: 0
      };
    };
    uint8.buildStream = buildStream;
    var readByte = function readByte() {
      return function (stream) {
        return stream.data[stream.pos++];
      };
    };
    uint8.readByte = readByte;
    var peekByte = function peekByte() {
      var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      return function (stream) {
        return stream.data[stream.pos + offset];
      };
    };
    uint8.peekByte = peekByte;
    var readBytes = function readBytes(length) {
      return function (stream) {
        return stream.data.subarray(stream.pos, stream.pos += length);
      };
    };
    uint8.readBytes = readBytes;
    var peekBytes = function peekBytes(length) {
      return function (stream) {
        return stream.data.subarray(stream.pos, stream.pos + length);
      };
    };
    uint8.peekBytes = peekBytes;
    var readString = function readString(length) {
      return function (stream) {
        return Array.from(readBytes(length)(stream)).map(function (value) {
          return String.fromCharCode(value);
        }).join('');
      };
    };
    uint8.readString = readString;
    var readUnsigned = function readUnsigned(littleEndian) {
      return function (stream) {
        var bytes = readBytes(2)(stream);
        return littleEndian ? (bytes[1] << 8) + bytes[0] : (bytes[0] << 8) + bytes[1];
      };
    };
    uint8.readUnsigned = readUnsigned;
    var readArray = function readArray(byteSize, totalOrFunc) {
      return function (stream, result, parent) {
        var total = typeof totalOrFunc === 'function' ? totalOrFunc(stream, result, parent) : totalOrFunc;
        var parser = readBytes(byteSize);
        var arr = new Array(total);
        for (var i = 0; i < total; i++) {
          arr[i] = parser(stream);
        }
        return arr;
      };
    };
    uint8.readArray = readArray;
    var subBitsTotal = function subBitsTotal(bits, startIndex, length) {
      var result = 0;
      for (var i = 0; i < length; i++) {
        result += bits[startIndex + i] && Math.pow(2, length - i - 1);
      }
      return result;
    };
    var readBits = function readBits(schema) {
      return function (stream) {
        var _byte = readByte()(stream); // convert the byte to bit array

        var bits = new Array(8);
        for (var i = 0; i < 8; i++) {
          bits[7 - i] = !!(_byte & 1 << i);
        } // convert the bit array to values based on the schema

        return Object.keys(schema).reduce(function (res, key) {
          var def = schema[key];
          if (def.length) {
            res[key] = subBitsTotal(bits, def.index, def.length);
          } else {
            res[key] = bits[def.index];
          }
          return res;
        }, {});
      };
    };
    uint8.readBits = readBits;

    (function (exports) {

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports["default"] = void 0;
      var _ = lib;
      var _uint = uint8;

      // a set of 0x00 terminated subblocks
      var subBlocksSchema = {
        blocks: function blocks(stream) {
          var terminator = 0x00;
          var chunks = [];
          var streamSize = stream.data.length;
          var total = 0;
          for (var size = (0, _uint.readByte)()(stream); size !== terminator; size = (0, _uint.readByte)()(stream)) {
            // size becomes undefined for some case when file is corrupted and  terminator is not proper 
            // null check to avoid recursion
            if (!size) break; // catch corrupted files with no terminator

            if (stream.pos + size >= streamSize) {
              var availableSize = streamSize - stream.pos;
              chunks.push((0, _uint.readBytes)(availableSize)(stream));
              total += availableSize;
              break;
            }
            chunks.push((0, _uint.readBytes)(size)(stream));
            total += size;
          }
          var result = new Uint8Array(total);
          var offset = 0;
          for (var i = 0; i < chunks.length; i++) {
            result.set(chunks[i], offset);
            offset += chunks[i].length;
          }
          return result;
        }
      }; // global control extension

      var gceSchema = (0, _.conditional)({
        gce: [{
          codes: (0, _uint.readBytes)(2)
        }, {
          byteSize: (0, _uint.readByte)()
        }, {
          extras: (0, _uint.readBits)({
            future: {
              index: 0,
              length: 3
            },
            disposal: {
              index: 3,
              length: 3
            },
            userInput: {
              index: 6
            },
            transparentColorGiven: {
              index: 7
            }
          })
        }, {
          delay: (0, _uint.readUnsigned)(true)
        }, {
          transparentColorIndex: (0, _uint.readByte)()
        }, {
          terminator: (0, _uint.readByte)()
        }]
      }, function (stream) {
        var codes = (0, _uint.peekBytes)(2)(stream);
        return codes[0] === 0x21 && codes[1] === 0xf9;
      }); // image pipeline block

      var imageSchema = (0, _.conditional)({
        image: [{
          code: (0, _uint.readByte)()
        }, {
          descriptor: [{
            left: (0, _uint.readUnsigned)(true)
          }, {
            top: (0, _uint.readUnsigned)(true)
          }, {
            width: (0, _uint.readUnsigned)(true)
          }, {
            height: (0, _uint.readUnsigned)(true)
          }, {
            lct: (0, _uint.readBits)({
              exists: {
                index: 0
              },
              interlaced: {
                index: 1
              },
              sort: {
                index: 2
              },
              future: {
                index: 3,
                length: 2
              },
              size: {
                index: 5,
                length: 3
              }
            })
          }]
        }, (0, _.conditional)({
          lct: (0, _uint.readArray)(3, function (stream, result, parent) {
            return Math.pow(2, parent.descriptor.lct.size + 1);
          })
        }, function (stream, result, parent) {
          return parent.descriptor.lct.exists;
        }), {
          data: [{
            minCodeSize: (0, _uint.readByte)()
          }, subBlocksSchema]
        }]
      }, function (stream) {
        return (0, _uint.peekByte)()(stream) === 0x2c;
      }); // plain text block

      var textSchema = (0, _.conditional)({
        text: [{
          codes: (0, _uint.readBytes)(2)
        }, {
          blockSize: (0, _uint.readByte)()
        }, {
          preData: function preData(stream, result, parent) {
            return (0, _uint.readBytes)(parent.text.blockSize)(stream);
          }
        }, subBlocksSchema]
      }, function (stream) {
        var codes = (0, _uint.peekBytes)(2)(stream);
        return codes[0] === 0x21 && codes[1] === 0x01;
      }); // application block

      var applicationSchema = (0, _.conditional)({
        application: [{
          codes: (0, _uint.readBytes)(2)
        }, {
          blockSize: (0, _uint.readByte)()
        }, {
          id: function id(stream, result, parent) {
            return (0, _uint.readString)(parent.blockSize)(stream);
          }
        }, subBlocksSchema]
      }, function (stream) {
        var codes = (0, _uint.peekBytes)(2)(stream);
        return codes[0] === 0x21 && codes[1] === 0xff;
      }); // comment block

      var commentSchema = (0, _.conditional)({
        comment: [{
          codes: (0, _uint.readBytes)(2)
        }, subBlocksSchema]
      }, function (stream) {
        var codes = (0, _uint.peekBytes)(2)(stream);
        return codes[0] === 0x21 && codes[1] === 0xfe;
      });
      var schema = [{
        header: [{
          signature: (0, _uint.readString)(3)
        }, {
          version: (0, _uint.readString)(3)
        }]
      }, {
        lsd: [{
          width: (0, _uint.readUnsigned)(true)
        }, {
          height: (0, _uint.readUnsigned)(true)
        }, {
          gct: (0, _uint.readBits)({
            exists: {
              index: 0
            },
            resolution: {
              index: 1,
              length: 3
            },
            sort: {
              index: 4
            },
            size: {
              index: 5,
              length: 3
            }
          })
        }, {
          backgroundColorIndex: (0, _uint.readByte)()
        }, {
          pixelAspectRatio: (0, _uint.readByte)()
        }]
      }, (0, _.conditional)({
        gct: (0, _uint.readArray)(3, function (stream, result) {
          return Math.pow(2, result.lsd.gct.size + 1);
        })
      }, function (stream, result) {
        return result.lsd.gct.exists;
      }),
      // content frames
      {
        frames: (0, _.loop)([gceSchema, applicationSchema, commentSchema, imageSchema, textSchema], function (stream) {
          var nextCode = (0, _uint.peekByte)()(stream); // rather than check for a terminator, we should check for the existence
          // of an ext or image block to avoid infinite loops
          //var terminator = 0x3B;
          //return nextCode !== terminator;

          return nextCode === 0x21 || nextCode === 0x2c;
        })
      }];
      var _default = schema;
      exports["default"] = _default;
    })(gif);

    var deinterlace$1 = {};

    Object.defineProperty(deinterlace$1, "__esModule", {
      value: true
    });
    deinterlace$1.deinterlace = void 0;

    /**
     * Deinterlace function from https://github.com/shachaf/jsgif
     */
    var deinterlace = function deinterlace(pixels, width) {
      var newPixels = new Array(pixels.length);
      var rows = pixels.length / width;
      var cpRow = function cpRow(toRow, fromRow) {
        var fromPixels = pixels.slice(fromRow * width, (fromRow + 1) * width);
        newPixels.splice.apply(newPixels, [toRow * width, width].concat(fromPixels));
      }; // See appendix E.

      var offsets = [0, 4, 2, 1];
      var steps = [8, 8, 4, 2];
      var fromRow = 0;
      for (var pass = 0; pass < 4; pass++) {
        for (var toRow = offsets[pass]; toRow < rows; toRow += steps[pass]) {
          cpRow(toRow, fromRow);
          fromRow++;
        }
      }
      return newPixels;
    };
    deinterlace$1.deinterlace = deinterlace;

    var lzw$1 = {};

    Object.defineProperty(lzw$1, "__esModule", {
      value: true
    });
    lzw$1.lzw = void 0;

    /**
     * javascript port of java LZW decompression
     * Original java author url: https://gist.github.com/devunwired/4479231
     */
    var lzw = function lzw(minCodeSize, data, pixelCount) {
      var MAX_STACK_SIZE = 4096;
      var nullCode = -1;
      var npix = pixelCount;
      var available, clear, code_mask, code_size, end_of_information, in_code, old_code, bits, code, i, datum, data_size, first, top, bi, pi;
      var dstPixels = new Array(pixelCount);
      var prefix = new Array(MAX_STACK_SIZE);
      var suffix = new Array(MAX_STACK_SIZE);
      var pixelStack = new Array(MAX_STACK_SIZE + 1); // Initialize GIF data stream decoder.

      data_size = minCodeSize;
      clear = 1 << data_size;
      end_of_information = clear + 1;
      available = clear + 2;
      old_code = nullCode;
      code_size = data_size + 1;
      code_mask = (1 << code_size) - 1;
      for (code = 0; code < clear; code++) {
        prefix[code] = 0;
        suffix[code] = code;
      } // Decode GIF pixel stream.

      var datum, bits, first, top, pi, bi;
      datum = bits = first = top = pi = bi = 0;
      for (i = 0; i < npix;) {
        if (top === 0) {
          if (bits < code_size) {
            // get the next byte
            datum += data[bi] << bits;
            bits += 8;
            bi++;
            continue;
          } // Get the next code.

          code = datum & code_mask;
          datum >>= code_size;
          bits -= code_size; // Interpret the code

          if (code > available || code == end_of_information) {
            break;
          }
          if (code == clear) {
            // Reset decoder.
            code_size = data_size + 1;
            code_mask = (1 << code_size) - 1;
            available = clear + 2;
            old_code = nullCode;
            continue;
          }
          if (old_code == nullCode) {
            pixelStack[top++] = suffix[code];
            old_code = code;
            first = code;
            continue;
          }
          in_code = code;
          if (code == available) {
            pixelStack[top++] = first;
            code = old_code;
          }
          while (code > clear) {
            pixelStack[top++] = suffix[code];
            code = prefix[code];
          }
          first = suffix[code] & 0xff;
          pixelStack[top++] = first; // add a new string to the table, but only if space is available
          // if not, just continue with current table until a clear code is found
          // (deferred clear code implementation as per GIF spec)

          if (available < MAX_STACK_SIZE) {
            prefix[available] = old_code;
            suffix[available] = first;
            available++;
            if ((available & code_mask) === 0 && available < MAX_STACK_SIZE) {
              code_size++;
              code_mask += available;
            }
          }
          old_code = in_code;
        } // Pop a pixel off the pixel stack.

        top--;
        dstPixels[pi++] = pixelStack[top];
        i++;
      }
      for (i = pi; i < npix; i++) {
        dstPixels[i] = 0; // clear missing pixels
      }

      return dstPixels;
    };
    lzw$1.lzw = lzw;

    Object.defineProperty(lib$1, "__esModule", {
      value: true
    });
    var decompressFrames_1 = lib$1.decompressFrames = lib$1.decompressFrame = parseGIF_1 = lib$1.parseGIF = void 0;
    var _gif = _interopRequireDefault(gif);
    var _jsBinarySchemaParser = lib;
    var _uint = uint8;
    var _deinterlace = deinterlace$1;
    var _lzw = lzw$1;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }
    var parseGIF = function parseGIF(arrayBuffer) {
      var byteData = new Uint8Array(arrayBuffer);
      return (0, _jsBinarySchemaParser.parse)((0, _uint.buildStream)(byteData), _gif["default"]);
    };
    var parseGIF_1 = lib$1.parseGIF = parseGIF;
    var generatePatch = function generatePatch(image) {
      var totalPixels = image.pixels.length;
      var patchData = new Uint8ClampedArray(totalPixels * 4);
      for (var i = 0; i < totalPixels; i++) {
        var pos = i * 4;
        var colorIndex = image.pixels[i];
        var color = image.colorTable[colorIndex] || [0, 0, 0];
        patchData[pos] = color[0];
        patchData[pos + 1] = color[1];
        patchData[pos + 2] = color[2];
        patchData[pos + 3] = colorIndex !== image.transparentIndex ? 255 : 0;
      }
      return patchData;
    };
    var decompressFrame = function decompressFrame(frame, gct, buildImagePatch) {
      if (!frame.image) {
        return;
      }
      var image = frame.image; // get the number of pixels

      var totalPixels = image.descriptor.width * image.descriptor.height; // do lzw decompression

      var pixels = (0, _lzw.lzw)(image.data.minCodeSize, image.data.blocks, totalPixels); // deal with interlacing if necessary

      if (image.descriptor.lct.interlaced) {
        pixels = (0, _deinterlace.deinterlace)(pixels, image.descriptor.width);
      }
      var resultImage = {
        pixels: pixels,
        dims: {
          top: frame.image.descriptor.top,
          left: frame.image.descriptor.left,
          width: frame.image.descriptor.width,
          height: frame.image.descriptor.height
        }
      }; // color table

      if (image.descriptor.lct && image.descriptor.lct.exists) {
        resultImage.colorTable = image.lct;
      } else {
        resultImage.colorTable = gct;
      } // add per frame relevant gce information

      if (frame.gce) {
        resultImage.delay = (frame.gce.delay || 10) * 10; // convert to ms

        resultImage.disposalType = frame.gce.extras.disposal; // transparency

        if (frame.gce.extras.transparentColorGiven) {
          resultImage.transparentIndex = frame.gce.transparentColorIndex;
        }
      } // create canvas usable imagedata if desired

      if (buildImagePatch) {
        resultImage.patch = generatePatch(resultImage);
      }
      return resultImage;
    };
    lib$1.decompressFrame = decompressFrame;
    var decompressFrames = function decompressFrames(parsedGif, buildImagePatches) {
      return parsedGif.frames.filter(function (f) {
        return f.image;
      }).map(function (f) {
        return decompressFrame(f, parsedGif.gct, buildImagePatches);
      });
    };
    decompressFrames_1 = lib$1.decompressFrames = decompressFrames;

    const browser$1 = isBrowserEnv();

    function _registerArc() {
      _registerArc.__loaded || (_registerArc.__loaded = !0, registerArcGraphic(), container.load(arcModule), container.load(browser$1 ? arcCanvasPickModule : arcMathPickModule));
    }
    _registerArc.__loaded = !1;
    const registerArc = _registerArc;

    function _registerCircle() {
      _registerCircle.__loaded || (_registerCircle.__loaded = !0, registerCircleGraphic(), container.load(circleModule), container.load(browser$1 ? circleCanvasPickModule : circleMathPickModule));
    }
    _registerCircle.__loaded = !1;
    const registerCircle = _registerCircle;

    function _registerGroup() {
      _registerGroup.__loaded || (_registerGroup.__loaded = !0, registerGroupGraphic());
    }
    _registerGroup.__loaded = !1;
    const registerGroup = _registerGroup;

    function _registerImage() {
      _registerImage.__loaded || (_registerImage.__loaded = !0, registerImageGraphic(), container.load(imageModule), container.load(browser$1 ? imageCanvasPickModule : imageMathPickModule));
    }
    _registerImage.__loaded = !1;
    const registerImage = _registerImage;

    function _registerLine() {
      _registerLine.__loaded || (_registerLine.__loaded = !0, registerLineGraphic(), container.load(lineModule), container.load(browser$1 ? lineCanvasPickModule : lineMathPickModule));
    }
    _registerLine.__loaded = !1;
    const registerLine = _registerLine;

    function _registerPath() {
      _registerPath.__loaded || (_registerPath.__loaded = !0, registerPathGraphic(), container.load(pathModule), container.load(browser$1 ? pathCanvasPickModule : pathMathPickModule));
    }
    _registerPath.__loaded = !1;
    const registerPath = _registerPath;

    function _registerPolygon() {
      _registerPolygon.__loaded || (_registerPolygon.__loaded = !0, registerPolygonGraphic(), container.load(polygonModule), container.load(browser$1 ? polygonCanvasPickModule : polygonMathPickModule));
    }
    _registerPolygon.__loaded = !1;
    const registerPolygon = _registerPolygon;

    function _registerRect() {
      _registerRect.__loaded || (_registerRect.__loaded = !0, registerRectGraphic(), container.load(rectModule), container.load(browser$1 ? rectCanvasPickModule : rectMathPickModule));
    }
    _registerRect.__loaded = !1;
    const registerRect = _registerRect;

    function _registerRichtext() {
      _registerRichtext.__loaded || (_registerRichtext.__loaded = !0, registerRichtextGraphic(), container.load(richtextModule), container.load(browser$1 ? richtextCanvasPickModule : richTextMathPickModule));
    }
    _registerRichtext.__loaded = !1;
    const registerRichtext = _registerRichtext;

    function _registerShadowRoot() {
      _registerShadowRoot.__loaded || (_registerShadowRoot.__loaded = !0, registerShadowRootGraphic());
    }
    _registerShadowRoot.__loaded = !1;
    const registerShadowRoot = _registerShadowRoot;

    function _registerSymbol() {
      _registerSymbol.__loaded || (_registerSymbol.__loaded = !0, registerSymbolGraphic(), container.load(symbolModule), container.load(browser$1 ? symbolCanvasPickModule : symbolMathPickModule));
    }
    _registerSymbol.__loaded = !1;
    const registerSymbol = _registerSymbol;

    function _registerText() {
      _registerText.__loaded || (_registerText.__loaded = !0, registerTextGraphic(), container.load(textModule), container.load(browser$1 ? textCanvasPickModule : textMathPickModule));
    }
    _registerText.__loaded = !1;
    const registerText = _registerText;

    function _registerWrapText() {
      _registerWrapText.__loaded || (_registerWrapText.__loaded = !0, registerWrapTextGraphic());
    }
    _registerWrapText.__loaded = !1;
    const registerWrapText = _registerWrapText;

    function loadScrollbarComponent() {
      registerGroup(), registerRect();
    }

    const DEFAULT_TEXT_FONT_FAMILY$1 = "PingFang SC,Helvetica Neue,Microsoft Yahei,system-ui,-apple-system,segoe ui,Roboto,Helvetica,Arial,sans-serif,apple color emoji,segoe ui emoji,segoe ui symbol";
    const DEFAULT_TEXT_FONT_SIZE$1 = 14;
    var StateValue;
    !function (StateValue) {
      StateValue.selected = "selected", StateValue.selectedReverse = "selected_reverse", StateValue.hover = "hover", StateValue.hoverReverse = "hover_reverse";
    }(StateValue || (StateValue = {}));
    const DEFAULT_STATES$2 = {
      [StateValue.selectedReverse]: {},
      [StateValue.selected]: {},
      [StateValue.hover]: {},
      [StateValue.hoverReverse]: {}
    };
    const DEFAULT_HTML_TEXT_SPEC = {
      container: "",
      width: 30,
      height: 30,
      style: {}
    };
    const SCROLLBAR_START_EVENT = "scrollDown";
    const SCROLLBAR_EVENT = "scrollDrag";
    const SCROLLBAR_END_EVENT = "scrollUp";

    function getEndTriggersOfDrag() {
      return "browser" === vglobal.env ? ["pointerup", "pointerleave", "pointercancel"] : ["pointerup", "pointerleave", "pointerupoutside"];
    }

    const delayMap = {
      debounce: debounce$1,
      throttle: throttle$1
    };
    loadScrollbarComponent();
    class ScrollBar extends AbstractComponent {
      constructor(attributes, options) {
        super((null == options ? void 0 : options.skipDefault) ? attributes : merge$2({}, ScrollBar.defaultAttributes, attributes)), this.name = "scrollbar", this._handleTouchMove = e => {
          isValid$5(this._prePos) && e.preventDefault();
        }, this._onRailPointerDown = e => {
          const {
              viewX: viewX,
              viewY: viewY
            } = e,
            {
              direction: direction,
              width: width,
              height: height,
              range: range
            } = this.attribute,
            sliderSize = this._sliderSize,
            [min, max] = this._getScrollRange();
          let currentScrollValue;
          if ("vertical" === direction) {
            const relativeY = viewY - this._viewPosition.y,
              currentYPos = clamp$3(relativeY - sliderSize / 2, min, max);
            currentScrollValue = relativeY / height, this._slider.setAttribute("y", currentYPos, !0);
          } else {
            const relativeX = viewX - this._viewPosition.x,
              currentXPos = clamp$3(relativeX - sliderSize / 2, min, max);
            currentScrollValue = relativeX / width, this._slider.setAttribute("x", currentXPos, !0);
          }
          this.setScrollRange([currentScrollValue - (range[1] - range[0]) / 2, currentScrollValue + (range[1] - range[0]) / 2], !1), this.stage && !this.stage.autoRender && this.stage.renderNextFrame();
        }, this._onSliderPointerDown = e => {
          this._clearDragEvents();
          const {
            stopSliderDownPropagation = !0
          } = this.attribute;
          stopSliderDownPropagation && e.stopPropagation();
          const {
              direction: direction
            } = this.attribute,
            {
              x: x,
              y: y
            } = this.stage.eventPointTransform(e);
          this._prePos = "horizontal" === direction ? x : y, this._dispatchEvent(SCROLLBAR_START_EVENT, {
            pos: this._prePos,
            event: e
          });
          const triggers = getEndTriggersOfDrag(),
            obj = "browser" === vglobal.env ? vglobal : this.stage;
          obj.addEventListener("pointermove", this._onSliderPointerMoveWithDelay, {
            capture: !0
          }), triggers.forEach(trigger => {
            obj.addEventListener(trigger, this._onSliderPointerUp);
          });
        }, this._computeScrollValue = e => {
          const {
              direction: direction
            } = this.attribute,
            {
              x: x,
              y: y
            } = this.stage.eventPointTransform(e);
          let currentScrollValue,
            currentPos,
            delta = 0;
          const {
            width: width,
            height: height
          } = this.getSliderRenderBounds();
          return "vertical" === direction ? (currentPos = y, delta = currentPos - this._prePos, currentScrollValue = delta / height) : (currentPos = x, delta = currentPos - this._prePos, currentScrollValue = delta / width), [currentPos, currentScrollValue];
        }, this._onSliderPointerMove = e => {
          const {
            stopSliderMovePropagation = !0
          } = this.attribute;
          stopSliderMovePropagation && e.stopPropagation();
          const preScrollRange = this.getScrollRange(),
            [currentPos, currentScrollValue] = this._computeScrollValue(e);
          this.setScrollRange([preScrollRange[0] + currentScrollValue, preScrollRange[1] + currentScrollValue], !0), this._prePos = currentPos;
        }, this._onSliderPointerMoveWithDelay = 0 === this.attribute.delayTime ? this._onSliderPointerMove : delayMap[this.attribute.delayType](this._onSliderPointerMove, this.attribute.delayTime), this._onSliderPointerUp = e => {
          const {
              range: preRange,
              limitRange = [0, 1]
            } = this.attribute,
            preScrollRange = this.getScrollRange(),
            [currentPos, currentScrollValue] = this._computeScrollValue(e),
            range = [preScrollRange[0] + currentScrollValue, preScrollRange[1] + currentScrollValue];
          this._prePos = null, this._dispatchEvent(SCROLLBAR_END_EVENT, {
            pre: preRange,
            value: clampRange$1(range, limitRange[0], limitRange[1])
          }), this._clearDragEvents();
        };
      }
      setScrollRange(range) {
        let render = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
        const {
            direction = "horizontal",
            limitRange = [0, 1],
            range: preRange,
            realTime = !0
          } = this.attribute,
          currScrollRange = clampRange$1(range, limitRange[0], limitRange[1]);
        if (render) {
          const sliderPos = this._getSliderPos(currScrollRange);
          if (this._slider) {
            const sliderSize = sliderPos[1] - sliderPos[0];
            this._sliderSize = sliderSize, "horizontal" === direction ? this._slider.setAttributes({
              x: sliderPos[0],
              width: sliderSize
            }, !0) : this._slider.setAttributes({
              y: sliderPos[0],
              height: sliderSize
            }, !0), this.stage && !this.stage.autoRender && this.stage.renderNextFrame();
          }
        }
        this.attribute.range = currScrollRange, realTime && this._dispatchEvent(SCROLLBAR_EVENT, {
          pre: preRange,
          value: currScrollRange
        });
      }
      getScrollRange() {
        return this.attribute.range;
      }
      bindEvents() {
        if (this.attribute.disableTriggerEvent) return;
        const {
          delayType = "throttle",
          delayTime = 0
        } = this.attribute;
        this._rail && this._rail.addEventListener("pointerdown", delayMap[delayType](this._onRailPointerDown, delayTime)), this._slider && this._slider.addEventListener("pointerdown", this._onSliderPointerDown), ("browser" === vglobal.env ? vglobal : this.stage).addEventListener("touchmove", this._handleTouchMove, {
          passive: !1
        });
      }
      render() {
        this._reset();
        const {
            direction = "horizontal",
            width: width,
            height: height,
            range: range,
            limitRange = [0, 1],
            railStyle: railStyle,
            sliderStyle: sliderStyle,
            padding = 2
          } = this.attribute,
          group = this.createOrUpdateChild("scrollbar-container", {}, "group"),
          rail = group.createOrUpdateChild("scrollbar-rail", Object.assign({
            x: 0,
            y: 0,
            width: width,
            height: height
          }, railStyle), "rect");
        this._rail = rail;
        const sliderRenderBounds = this.getSliderRenderBounds(),
          sliderPos = this._getSliderPos(clampRange$1(range, limitRange[0], limitRange[1])),
          sliderSize = sliderPos[1] - sliderPos[0];
        let sliderAttribute;
        this._sliderSize = sliderSize, sliderAttribute = "horizontal" === direction ? {
          x: sliderPos[0],
          y: sliderRenderBounds.y1,
          width: sliderSize,
          height: sliderRenderBounds.height
        } : {
          x: sliderRenderBounds.x1,
          y: sliderPos[0],
          width: sliderRenderBounds.width,
          height: sliderSize
        };
        const slider = group.createOrUpdateChild("slider", Object.assign(Object.assign(Object.assign(Object.assign({}, sliderAttribute), {
          cornerRadius: this._getDefaultSliderCornerRadius()
        }), sliderStyle), {
          boundsPadding: normalizePadding(padding),
          pickMode: "imprecise"
        }), "rect");
        this._slider = slider, this._container = group;
        const containerAABBBounds = this._container.AABBBounds;
        this._viewPosition = {
          x: containerAABBBounds.x1,
          y: containerAABBBounds.y1
        };
      }
      getSliderRenderBounds() {
        if (this._sliderRenderBounds) return this._sliderRenderBounds;
        const {
            width: width,
            height: height,
            padding = 2
          } = this.attribute,
          [top, right, bottom, left] = normalizePadding(padding),
          renderBounds = {
            x1: left,
            y1: top,
            x2: width - right,
            y2: height - bottom,
            width: Math.max(0, width - (left + right)),
            height: Math.max(0, height - (top + bottom))
          };
        return this._sliderRenderBounds = renderBounds, renderBounds;
      }
      _getDefaultSliderCornerRadius() {
        const {
          direction: direction,
          round: round
        } = this.attribute;
        if (round) {
          const {
            width: width,
            height: height
          } = this.getSliderRenderBounds();
          return "horizontal" === direction ? height : width;
        }
        return 0;
      }
      _getSliderPos(range) {
        const {
            direction: direction
          } = this.attribute,
          {
            width: width,
            height: height,
            x1: x1,
            y1: y1
          } = this.getSliderRenderBounds();
        return "horizontal" === direction ? [width * range[0] + x1, width * range[1] + x1] : [height * range[0] + y1, height * range[1] + y1];
      }
      _getScrollRange() {
        if (this._sliderLimitRange) return this._sliderLimitRange;
        const {
            limitRange = [0, 1],
            direction: direction
          } = this.attribute,
          [min, max] = clampRange$1(limitRange, 0, 1),
          {
            width: width,
            height: height,
            x1: x1,
            y1: y1
          } = this.getSliderRenderBounds(),
          sliderSize = this._sliderSize;
        return "horizontal" === direction ? clampRange$1([x1 + min * width, x1 + max * width], x1, width - sliderSize) : clampRange$1([y1 + min * height, y1 + max * height], y1, height - sliderSize);
      }
      _clearDragEvents() {
        const triggers = getEndTriggersOfDrag(),
          obj = "browser" === vglobal.env ? vglobal : this.stage;
        obj.removeEventListener("pointermove", this._onSliderPointerMoveWithDelay, {
          capture: !0
        }), triggers.forEach(trigger => {
          obj.removeEventListener(trigger, this._onSliderPointerUp);
        });
      }
      _reset() {
        this._sliderRenderBounds = null, this._sliderLimitRange = null;
      }
      release(all) {
        super.release(all), ("browser" === vglobal.env ? vglobal : this.stage).addEventListener("touchmove", this._handleTouchMove, {
          passive: !1
        }), this._clearDragEvents();
      }
    }
    ScrollBar.defaultAttributes = {
      direction: "horizontal",
      round: !0,
      sliderSize: 20,
      sliderStyle: {
        fill: "rgba(0, 0, 0, .5)"
      },
      railStyle: {
        fill: "rgba(0, 0, 0, .0)"
      },
      padding: 2,
      scrollRange: [0, 1],
      delayType: "throttle",
      delayTime: 0,
      realTime: !0
    };

    function traverseGroup(group, cb) {
      group.forEachChildren(node => {
        const stopped = cb(node);
        node.isContainer && !stopped && traverseGroup(node, cb);
      });
    }

    function scale(vector, scale) {
      return [vector[0] * scale, vector[1] * scale];
    }
    function length(vector) {
      const [x, y] = vector;
      return Math.sqrt(x * x + y * y);
    }
    function normalize$2(vector) {
      let len = length(vector);
      return len > 0 && (len = 1 / len), [vector[0] * len, vector[1] * len];
    }
    function angle(vector1, vector2) {
      const [x1, y1] = vector1,
        [x2, y2] = vector2,
        mag = Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2)),
        cosine = mag && (x1 * x2 + y1 * y2) / mag;
      return Math.acos(Math.min(Math.max(cosine, -1), 1));
    }
    function angleTo(v1, v2, direct) {
      const ang = angle(v1, v2),
        angleLargeThanPI = crossProduct(v1, v2) >= 0;
      return direct ? angleLargeThanPI ? 2 * Math.PI - ang : ang : angleLargeThanPI ? ang : 2 * Math.PI - ang;
    }

    const initTextMeasure$1 = (textSpec, option, useNaiveCanvas, defaultFontParams) => new TextMeasure$1(Object.assign({
      defaultFontParams: Object.assign({
        fontFamily: DEFAULT_TEXT_FONT_FAMILY$1,
        fontSize: DEFAULT_TEXT_FONT_SIZE$1
      }, defaultFontParams),
      getTextBounds: useNaiveCanvas ? void 0 : getTextBounds,
      specialCharSet: "-/: .,@%'\"~" + TextMeasure$1.ALPHABET_CHAR_SET + TextMeasure$1.ALPHABET_CHAR_SET.toUpperCase()
    }, null != option ? option : {}), textSpec);
    function measureTextSize(text, textSpec) {
      let defaultTextTheme = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      if (!text) return {
        width: 0,
        height: 0
      };
      const bounds = getTextBounds({
        text: text,
        fontFamily: textSpec.fontFamily || defaultTextTheme.fontFamily || DEFAULT_TEXT_FONT_FAMILY$1,
        fontSize: textSpec.fontSize || defaultTextTheme.fontSize || 12,
        fontWeight: textSpec.fontWeight || defaultTextTheme.fontWeight,
        textAlign: textSpec.textAlign || "center",
        textBaseline: textSpec.textBaseline,
        ellipsis: !!textSpec.ellipsis,
        maxLineWidth: textSpec.maxLineWidth || 1 / 0,
        lineHeight: textSpec.fontSize || defaultTextTheme.fontSize || 12
      });
      return {
        width: bounds.width(),
        height: bounds.height()
      };
    }
    function isRichText(attributes) {
      let typeKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "type";
      return "rich" === getTextType(attributes, typeKey);
    }
    function getTextType(attributes) {
      let typeKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "type";
      var _a, _b;
      return isObject$9(attributes.text) && "type" in attributes.text ? null !== (_a = attributes.text.type) && void 0 !== _a ? _a : "text" : typeKey in attributes && null !== (_b = attributes[typeKey]) && void 0 !== _b ? _b : "text";
    }
    function richTextAttributeTransform(attributes) {
      var _a, _b;
      return isValid$5(attributes.maxLineWidth) && (attributes.maxWidth = attributes.maxLineWidth, delete attributes.maxLineWidth), attributes.width = null !== (_a = attributes.width) && void 0 !== _a ? _a : 0, attributes.height = null !== (_b = attributes.height) && void 0 !== _b ? _b : 0, attributes.textConfig = attributes.text.text || attributes.text, attributes;
    }
    function htmlAttributeTransform(attributes) {
      const {
          text: text,
          _originText: _originText
        } = attributes,
        {
          text: html
        } = text;
      return attributes.html = html, attributes.text = _originText, attributes.renderable = !1, attributes;
    }
    function reactAttributeTransform(attributes) {
      const {
          text: text,
          _originText: _originText
        } = attributes,
        {
          text: react
        } = text;
      return attributes.react = react, attributes.text = _originText, attributes.renderable = !1, attributes;
    }
    function createTextGraphicByType(textAttributes) {
      let typeKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "type";
      const textType = getTextType(textAttributes, typeKey);
      return "rich" === textType ? graphicCreator.richtext(richTextAttributeTransform(textAttributes)) : ("html" === textType ? textAttributes = htmlAttributeTransform(textAttributes) : "react" === textType && (textAttributes = reactAttributeTransform(textAttributes)), graphicCreator.text(textAttributes));
    }

    function loadTagComponent() {
      registerGroup(), registerRect(), registerSymbol(), registerRichtext(), registerText();
    }

    var __rest$3 = undefined && undefined.__rest || function (s, e) {
      var t = {};
      for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0 && (t[p] = s[p]);
      if (null != s && "function" == typeof Object.getOwnPropertySymbols) {
        var i = 0;
        for (p = Object.getOwnPropertySymbols(s); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t[p[i]] = s[p[i]]);
      }
      return t;
    };
    loadTagComponent();
    let Tag$1 = class Tag extends AbstractComponent {
      getBgRect() {
        return this._bgRect;
      }
      getTextShape() {
        return this._textShape;
      }
      constructor(attributes, options) {
        super((null == options ? void 0 : options.skipDefault) ? attributes : merge$2({}, Tag.defaultAttributes, attributes)), this.name = "tag", this._tagStates = [], this._rectStates = [], this._symbolStates = [], this._textStates = [];
      }
      render() {
        var _a, _b, _c;
        this.cacheStates();
        const {
            text = "",
            textStyle = {},
            shape = {},
            panel = {},
            space = 4,
            minWidth: minWidth,
            maxWidth: maxWidth,
            padding = 4,
            visible: visible,
            state: state,
            type: type,
            textAlwaysCenter: textAlwaysCenter,
            containerTextAlign: containerTextAlign
          } = this.attribute,
          parsedPadding = normalizePadding(padding),
          group = this.createOrUpdateChild("tag-content", {
            x: 0,
            y: 0,
            zIndex: 1
          }, "group");
        let symbol,
          tagX = -parsedPadding[3],
          tagY = -parsedPadding[0],
          tagWidth = parsedPadding[1] + parsedPadding[3],
          tagHeight = parsedPadding[0] + parsedPadding[2],
          textX = 0,
          symbolPlaceWidth = 0;
        const {
            visible: shapeVisible
          } = shape,
          shapeStyle = __rest$3(shape, ["visible"]);
        if (isBoolean$6(shapeVisible)) {
          const size = (null == shapeStyle ? void 0 : shapeStyle.size) || 10,
            maxSize = isNumber$6(size) ? size : Math.max(size[0], size[1]);
          symbol = group.createOrUpdateChild("tag-shape", Object.assign(Object.assign({
            symbolType: "circle",
            size: size,
            strokeBoundsBuffer: 0
          }, shapeStyle), {
            visible: shapeVisible,
            x: maxSize / 2,
            y: maxSize / 2
          }), "symbol"), isEmpty$1(null == state ? void 0 : state.shape) || (symbol.states = state.shape), shapeVisible && (symbolPlaceWidth = maxSize + space);
        }
        let textShape, textWidth, textHeight;
        tagWidth += symbolPlaceWidth, textX += symbolPlaceWidth;
        if (isRichText({
          text: text
        }) || "rich" === type) {
          const richTextAttrs = Object.assign(Object.assign(Object.assign({}, richTextAttributeTransform(Object.assign({
            type: type,
            text: text
          }, textStyle))), textStyle), {
            visible: isValid$5(text) && !1 !== visible,
            x: textX,
            y: 0
          });
          isNil$5(richTextAttrs.lineHeight) && (richTextAttrs.lineHeight = textStyle.fontSize), textShape = group.createOrUpdateChild("tag-text", richTextAttrs, "richtext"), textWidth = textShape.AABBBounds.width(), textHeight = textShape.AABBBounds.height();
        } else {
          const textAttrs = Object.assign(Object.assign({
            text: isObject$9(text) && "type" in text && "text" === text.type ? text.text : text,
            visible: isValid$5(text) && !1 !== visible,
            lineHeight: null == textStyle ? void 0 : textStyle.fontSize
          }, textStyle), {
            x: textX,
            y: 0
          });
          isNil$5(textAttrs.lineHeight) && (textAttrs.lineHeight = textStyle.fontSize), textShape = group.createOrUpdateChild("tag-text", textAttrs, "text");
          const textBounds = measureTextSize(textAttrs.text, textStyle, null === (_b = null === (_a = this.stage) || void 0 === _a ? void 0 : _a.getTheme()) || void 0 === _b ? void 0 : _b.text);
          textWidth = textBounds.width, textHeight = textBounds.height;
        }
        tagWidth += textWidth;
        const size = null !== (_c = shape.size) && void 0 !== _c ? _c : 10,
          maxSize = isNumber$6(size) ? size : Math.max(size[0], size[1]);
        tagHeight += Math.max(textHeight, shape.visible ? maxSize : 0);
        const {
          textAlign: textAlign,
          textBaseline: textBaseline
        } = textStyle;
        (isValid$5(minWidth) || isValid$5(maxWidth)) && (isValid$5(minWidth) && tagWidth < minWidth && (tagWidth = minWidth), isValid$5(maxWidth) && tagWidth > maxWidth && (tagWidth = maxWidth, textShape.setAttribute("maxLineWidth", maxWidth - parsedPadding[1] - parsedPadding[2]))), tagX = 0, tagY = 0;
        let flag = 0;
        "left" === textAlign || "start" === textAlign ? flag = 1 : "right" === textAlign || "end" === textAlign ? flag = -1 : "center" === textAlign && (flag = 0), flag ? flag < 0 ? (tagX -= tagWidth, symbol && symbol.setAttribute("x", (symbol.attribute.x || 0) - textWidth), group.setAttribute("x", -parsedPadding[1] - symbolPlaceWidth)) : flag > 0 && group.setAttribute("x", parsedPadding[3]) : (tagX -= tagWidth / 2, symbol && symbol.setAttribute("x", (symbol.attribute.x || 0) - textWidth / 2), group.setAttribute("x", -symbolPlaceWidth / 2));
        const shouldRight = "right" === containerTextAlign || "end" === containerTextAlign,
          shouldLeft = "left" === containerTextAlign || "start" === containerTextAlign,
          updateTextAttrs = (textX, textAlign) => {
            "richtext" === textShape.type ? textShape.setAttributes({
              x: textX,
              textAlign: textAlign,
              textConfig: array$1(textShape.attribute.textConfig).map(t => Object.assign(Object.assign({}, t), {
                textAlign: textAlign
              }))
            }) : textShape.setAttributes({
              x: textX,
              textAlign: textAlign
            });
          };
        if ((containerTextAlign ? "center" === containerTextAlign : textAlwaysCenter) && flag) {
          const containerWidth = tagWidth - parsedPadding[1] - parsedPadding[3],
            tsWidth = textWidth + symbolPlaceWidth,
            textX = 1 === flag ? (containerWidth - tsWidth) / 2 + symbolPlaceWidth + textWidth / 2 : parsedPadding[0] + symbolPlaceWidth - (tagWidth / 2 + tsWidth / 2 - symbolPlaceWidth) + textWidth / 2;
          if (updateTextAttrs(textX, "center"), symbol) {
            const symbolX = textX - textWidth / 2 - symbolPlaceWidth + maxSize / 2;
            symbol.setAttributes({
              x: symbolX
            });
          }
        }
        if (shouldLeft && 1 !== flag) {
          const containerWidth = tagWidth - parsedPadding[1] - parsedPadding[3],
            offset = 0 === flag ? -containerWidth / 2 + symbolPlaceWidth / 2 : -tagWidth + parsedPadding[3] + parsedPadding[1] + symbolPlaceWidth;
          if (updateTextAttrs(offset + symbolPlaceWidth, "left"), symbol) {
            const symbolX = offset + maxSize / 2;
            symbol.setAttributes({
              x: symbolX
            });
          }
        }
        if (shouldRight && -1 !== flag) {
          const containerWidth = tagWidth - parsedPadding[1] - parsedPadding[3],
            textX = 0 === flag ? containerWidth / 2 + symbolPlaceWidth / 2 : containerWidth;
          if (updateTextAttrs(textX, "right"), symbol) {
            const symbolX = textX - textWidth - symbolPlaceWidth + maxSize / 2;
            symbol.setAttributes({
              x: symbolX
            });
          }
        }
        "middle" === textBaseline ? (tagY -= tagHeight / 2, symbol && symbol.setAttribute("y", 0)) : "bottom" === textBaseline ? (tagY -= tagHeight, symbol && symbol.setAttribute("y", -textHeight / 2), group.setAttribute("y", -parsedPadding[2])) : "top" === textBaseline && (group.setAttribute("y", parsedPadding[0]), symbol && symbol.setAttribute("y", textHeight / 2)), isEmpty$1(null == state ? void 0 : state.text) || (textShape.states = state.text);
        const {
            visible: bgVisible
          } = panel,
          backgroundStyle = __rest$3(panel, ["visible"]);
        if (visible && isBoolean$6(bgVisible)) {
          const bgRect = this.createOrUpdateChild("tag-panel", Object.assign(Object.assign({}, backgroundStyle), {
            visible: bgVisible && !!text,
            width: tagWidth,
            height: tagHeight,
            x: tagX,
            y: tagY
          }), "rect");
          if (isEmpty$1(null == state ? void 0 : state.panel) || (bgRect.states = state.panel), backgroundStyle.customShape) {
            const customShape = backgroundStyle.customShape;
            bgRect.pathProxy = attrs => customShape(this, attrs, new CustomPath2D());
          }
          this._bgRect = bgRect;
        }
        this._textShape = textShape, this._symbol = symbol, this.resetStates();
      }
      initAttributes(params, options) {
        params = (null == options ? void 0 : options.skipDefault) ? params : merge$2({}, Tag.defaultAttributes, params), super.initAttributes(params), this.render();
      }
      addState(stateName, keepCurrentStates, hasAnimation) {
        super.addState(stateName, keepCurrentStates, hasAnimation), this._textShape && this._textShape.addState(stateName, keepCurrentStates, hasAnimation), this._bgRect && this._bgRect.addState(stateName, keepCurrentStates, hasAnimation), this._symbol && this._symbol.addState(stateName, keepCurrentStates, hasAnimation);
      }
      removeState(stateName, hasAnimation) {
        super.removeState(stateName, hasAnimation), this._textShape && this._textShape.removeState(stateName, hasAnimation), this._bgRect && this._bgRect.removeState(stateName, hasAnimation), this._symbol && this._symbol.removeState(stateName, hasAnimation);
      }
      cacheStates() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
        this._tagStates = null !== (_b = null === (_a = this.currentStates) || void 0 === _a ? void 0 : _a.slice()) && void 0 !== _b ? _b : [], this._rectStates = null !== (_e = null === (_d = null === (_c = this._bgRect) || void 0 === _c ? void 0 : _c.currentStates) || void 0 === _d ? void 0 : _d.slice()) && void 0 !== _e ? _e : [], this._symbolStates = null !== (_h = null === (_g = null === (_f = this._symbol) || void 0 === _f ? void 0 : _f.currentStates) || void 0 === _g ? void 0 : _g.slice()) && void 0 !== _h ? _h : [], this._textStates = null !== (_l = null === (_k = null === (_j = this._textShape) || void 0 === _j ? void 0 : _j.currentStates) || void 0 === _k ? void 0 : _k.slice()) && void 0 !== _l ? _l : [], this.clearStates(), null === (_m = this._bgRect) || void 0 === _m || _m.clearStates(), null === (_o = this._symbol) || void 0 === _o || _o.clearStates(), null === (_p = this._textShape) || void 0 === _p || _p.clearStates();
      }
      resetStates() {
        var _a, _b, _c;
        this._tagStates.length && this.useStates(this._tagStates), this._rectStates.length && (null === (_a = this._bgRect) || void 0 === _a || _a.useStates(this._rectStates)), this._symbolStates.length && (null === (_b = this._symbol) || void 0 === _b || _b.useStates(this._symbolStates)), this._textStates.length && (null === (_c = this._textShape) || void 0 === _c || _c.useStates(this._textStates));
      }
    };
    Tag$1.defaultAttributes = {
      visible: !0,
      textStyle: {
        fontSize: 12,
        fill: "#000",
        textAlign: "left",
        textBaseline: "top"
      },
      space: 4,
      padding: 4,
      shape: {
        fill: "#000"
      }
    };

    const DEFAULT_THEME = {
      visible: !0,
      position: "auto",
      titleStyle: {
        fontSize: 16,
        fill: "#08979c"
      },
      contentStyle: {
        fontSize: 12,
        fill: "green"
      },
      panel: {
        visible: !0,
        fill: "#e6fffb",
        size: 12,
        space: 0,
        stroke: "#87e8de",
        lineWidth: 1,
        cornerRadius: 4
      }
    };
    const theme$2 = {
      poptip: merge$2({}, DEFAULT_THEME)
    };

    function loadPoptipComponent() {
      registerGroup(), registerText(), registerSymbol(), registerRect();
    }
    function setPoptipTheme(defaultPoptipTheme) {
      merge$2(theme$2.poptip, DEFAULT_THEME, defaultPoptipTheme);
    }

    var __rest$2 = undefined && undefined.__rest || function (s, e) {
      var t = {};
      for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0 && (t[p] = s[p]);
      if (null != s && "function" == typeof Object.getOwnPropertySymbols) {
        var i = 0;
        for (p = Object.getOwnPropertySymbols(s); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t[p[i]] = s[p[i]]);
      }
      return t;
    };
    const _tBounds = new AABBBounds$1();
    loadPoptipComponent();
    const tlStr = "M -0.5 -0.5, L -0.5 0.5, L 0.5 -0.5, Z",
      blStr = "M -0.5 -0.5, L -0.5 0.5, L 0.5 0.5, Z",
      trStr = "M -0.5 -0.5, L 0.5 -0.5, L 0.5 0.5, Z",
      brStr = "M 0.5 -0.5, L 0.5 0.5, L -0.5 0.5, Z",
      conciseSymbolMap = {
        tl: tlStr,
        tr: trStr,
        bl: blStr,
        br: brStr,
        lt: tlStr,
        lb: blStr,
        rt: trStr,
        rb: brStr
      };
    class PopTip extends AbstractComponent {
      constructor(attributes, options) {
        super((null == options ? void 0 : options.skipDefault) ? attributes : merge$2({}, PopTip.defaultAttributes, attributes)), this.name = "poptip", this.positionList = ["top", "tl", "tr", "bottom", "bl", "br", "left", "lt", "lb", "right", "rt", "rb"];
      }
      render() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const {
          titleStyle = {},
          position: position,
          contentStyle = {},
          panel: panel,
          logoSymbol: logoSymbol,
          poptipAnchor = "position",
          logoText: logoText,
          logoTextStyle = {},
          triangleMode = "default",
          space = 4,
          minWidth = 0,
          maxWidth = 1 / 0,
          padding = 4,
          maxWidthPercent: maxWidthPercent,
          visible: visible,
          state: state,
          dx = 0,
          dy = 0,
          positionBounds: positionBounds
        } = this.attribute;
        let {
          title = "",
          content = ""
        } = this.attribute;
        title = this.attribute.titleFormatMethod ? this.attribute.titleFormatMethod(title) : title, content = this.attribute.contentFormatMethod ? this.attribute.contentFormatMethod(content) : content;
        const parsedPadding = normalizePadding(padding),
          group = this.createOrUpdateChild("poptip-content", {
            x: 0,
            y: 0,
            zIndex: 1
          }, "group");
        this.group = group;
        const maxLineWidth = maxWidth - parsedPadding[1] - parsedPadding[3],
          titleVisible = isValid$5(title) && !1 !== visible,
          titleAttrs = Object.assign(Object.assign({
            text: isArray$9(title) ? title : [title],
            visible: titleVisible,
            wrap: !0
          }, titleStyle), {
            x: parsedPadding[3],
            y: parsedPadding[0],
            maxLineWidth: maxLineWidth,
            textAlign: "left",
            textBaseline: "top"
          }),
          titleShape = group.createOrUpdateChild("poptip-title", titleAttrs, "text");
        isEmpty$1(null == state ? void 0 : state.title) || (titleShape.states = state.title);
        const titleBounds = titleShape.AABBBounds,
          titleHeight = titleBounds.height(),
          titleWidth = titleBounds.width();
        let height = titleHeight + space;
        titleVisible || (height = 0);
        const contentVisible = isValid$5(content) && !1 !== visible,
          contentAttrs = Object.assign(Object.assign({
            text: isArray$9(content) ? content : [content],
            visible: contentVisible,
            wrap: !0
          }, contentStyle), {
            x: parsedPadding[3],
            y: parsedPadding[0] + height,
            maxLineWidth: maxLineWidth,
            textAlign: "left",
            textBaseline: "top"
          }),
          contentShape = group.createOrUpdateChild("poptip-content", contentAttrs, "text");
        isEmpty$1(null == state ? void 0 : state.content) || (contentShape.states = state.content);
        const contentBounds = contentShape.AABBBounds,
          contentHeight = contentBounds.height(),
          contentWidth = contentBounds.width();
        contentVisible && (height += contentHeight), this.titleShape = titleShape, this.contentShape = contentShape;
        let popTipWidth = max(titleWidth + parsedPadding[1] + parsedPadding[3], contentWidth + parsedPadding[1] + parsedPadding[3]);
        popTipWidth > maxWidth ? popTipWidth = maxWidth : popTipWidth < minWidth && (popTipWidth = minWidth);
        let poptipHeight = parsedPadding[0] + parsedPadding[2] + height;
        const {
            visible: bgVisible,
            square: square
          } = panel,
          backgroundStyle = __rest$2(panel, ["visible", "square"]);
        if (square) {
          const maxWH = max(popTipWidth, poptipHeight);
          popTipWidth = maxWH;
          const deltaH = maxWH - poptipHeight;
          poptipHeight = maxWH, titleShape.setAttributes({
            dy: deltaH / 2
          }), contentShape.setAttributes({
            dy: deltaH / 2
          });
        }
        const symbolSize = null !== (_a = backgroundStyle.size) && void 0 !== _a ? _a : 12,
          spaceSize = isArray$9(symbolSize) ? [symbolSize[0] + (null !== (_b = backgroundStyle.space) && void 0 !== _b ? _b : 0), symbolSize[1] + (null !== (_c = backgroundStyle.space) && void 0 !== _c ? _c : 0)] : symbolSize + (null !== (_d = backgroundStyle.space) && void 0 !== _d ? _d : 0),
          lineWidth = null !== (_e = backgroundStyle.lineWidth) && void 0 !== _e ? _e : 1,
          range = this.stage ? [null !== (_f = this.stage.viewWidth) && void 0 !== _f ? _f : this.stage.width, null !== (_g = this.stage.viewHeight) && void 0 !== _g ? _g : this.stage.height] : void 0;
        if (range) {
          const b = this.AABBBounds,
            leftWidth = null !== (_h = this.attribute.x) && void 0 !== _h ? _h : b.x1,
            rightWidth = range[0] - b.x1;
          let maxSpace = Math.max(leftWidth, rightWidth);
          const buf = (isArray$9(symbolSize) ? symbolSize[0] : 12) + 3;
          if (maxSpace = Math.min(maxSpace - buf, maxSpace * maxWidthPercent), maxSpace < popTipWidth) {
            popTipWidth = maxSpace;
            const buf = parsedPadding[1] + parsedPadding[3];
            titleShape.setAttribute("maxLineWidth", maxSpace - buf), contentShape.setAttribute("maxLineWidth", maxSpace - buf), poptipHeight = parsedPadding[0] + parsedPadding[2], titleVisible && (poptipHeight += titleShape.AABBBounds.height() + space), poptipHeight += contentShape.AABBBounds.height();
          }
        }
        const layout = "auto" === position || isArray$9(position),
          positionList = isArray$9(position) ? position : this.positionList;
        let maxBBoxI,
          maxBBoxSize = -1 / 0;
        for (let i = 0; i < positionList.length + 1; i++) {
          const p = layout ? positionList[i === positionList.length ? maxBBoxI : i] : position;
          let symbolType = "arrow2Left",
            offsetX = (isArray$9(symbolSize) ? symbolSize[0] : symbolSize) / 4,
            offsetY = 0;
          "top" === p || "bottom" === p || "left" === p || "right" === p ? symbolType = "arrow2Left" : "concise" === triangleMode && (symbolType = conciseSymbolMap[p], offsetX = ["tl", "bl", "rt", "rb"].includes(p) ? (isArray$9(symbolSize) ? symbolSize[0] : symbolSize) / 2 : -(isArray$9(symbolSize) ? symbolSize[0] : symbolSize) / 2, offsetY = ["tl", "tr", "lb", "rb"].includes(p) ? -(isArray$9(symbolSize) ? symbolSize[1] : symbolSize) / 2 : (isArray$9(symbolSize) ? symbolSize[1] : symbolSize) / 2);
          const {
            angle: angle,
            offset: offset
          } = this.getAngleAndOffset(p, popTipWidth, poptipHeight, isArray$9(spaceSize) ? spaceSize : [spaceSize, spaceSize - lineWidth], symbolType);
          let bgSymbol,
            anchorPoint = {
              x: 0,
              y: 0
            };
          if ("bounds" === poptipAnchor && positionBounds && (anchorPoint = this.calculateAnchorPoint(p, positionBounds)), isBoolean$6(bgVisible)) {
            let bgRect;
            bgSymbol = group.createOrUpdateChild("poptip-symbol-panel", Object.assign(Object.assign({}, backgroundStyle), {
              visible: bgVisible && (contentVisible || titleVisible),
              x: offsetX,
              y: offsetY,
              strokeBoundsBuffer: -1,
              boundsPadding: -2,
              anchor: [0, 0],
              symbolType: symbolType,
              angle: angle,
              dx: offset[0],
              dy: offset[1] - (null !== (_j = backgroundStyle.space) && void 0 !== _j ? _j : 0),
              size: symbolSize,
              zIndex: 9
            }), "symbol"), isEmpty$1(null == state ? void 0 : state.panel) || (bgSymbol.states = state.panel), bgRect = panel.panelSymbolType ? group.createOrUpdateChild("poptip-rect-panel", Object.assign(Object.assign({}, backgroundStyle), {
              visible: bgVisible && (contentVisible || titleVisible),
              x: 0,
              y: 0,
              symbolType: "rect",
              size: [popTipWidth, poptipHeight],
              zIndex: -8
            }), "symbol") : group.createOrUpdateChild("poptip-rect-panel", Object.assign(Object.assign({}, backgroundStyle), {
              visible: bgVisible && (contentVisible || titleVisible),
              x: 0,
              y: 0,
              width: popTipWidth,
              height: poptipHeight,
              zIndex: -8
            }), "rect"), isEmpty$1(null == state ? void 0 : state.panel) || (bgRect.states = state.panel);
          }
          if (group.setAttributes({
            x: -offset[0] + dx + anchorPoint.x,
            y: -offset[1] + dy + anchorPoint.y,
            anchor: [offsetX, offsetY]
          }), logoSymbol) {
            const {
                size = 12
              } = logoSymbol,
              sizeArray = isArray$9(size) ? size : [size, size];
            "auto" === sizeArray[1] && (sizeArray[1] = poptipHeight), "auto" === sizeArray[0] && (sizeArray[0] = poptipHeight);
            const sizeW = sizeArray[0];
            group.createOrUpdateChild("poptip-logo", Object.assign(Object.assign({}, logoSymbol), {
              x: 0,
              y: poptipHeight / 2,
              visible: bgVisible && (contentVisible || titleVisible),
              zIndex: 10,
              size: sizeArray
            }), "symbol"), group.setAttributes({
              x: -offset[0] + dx + sizeW / 2,
              y: -offset[1] + dy
            }), logoText && group.createOrUpdateChild("poptip-logo-text", Object.assign(Object.assign({}, logoTextStyle), {
              x: 0,
              y: poptipHeight / 2,
              visible: bgVisible && (contentVisible || titleVisible),
              text: logoText,
              textAlign: "center",
              textBaseline: "middle",
              zIndex: 10
            }), "text");
          }
          if (!range) break;
          {
            _tBounds.setValue(0, 0, popTipWidth, poptipHeight).transformWithMatrix(group.globalTransMatrix);
            const b = _tBounds,
              stageBounds = new Bounds$1().setValue(0, 0, range[0], range[1]);
            if (layout) {
              if (rectInsideAnotherRect(b, stageBounds, !1)) break;
              {
                const bbox = getRectIntersect(b, stageBounds, !1),
                  size = (bbox.x2 - bbox.x1) * (bbox.y2 - bbox.y1);
                size > maxBBoxSize && (maxBBoxSize = size, maxBBoxI = i);
              }
            }
            if (["top", "bottom", "left", "right"].includes(p)) {
              const isVerticalPosition = "top" === p || "bottom" === p,
                isHorizontalPosition = "left" === p || "right" === p;
              let mainDirectionOverlap = !1;
              if (isVerticalPosition ? mainDirectionOverlap = "top" === p && b.y1 < 0 || "bottom" === p && b.y2 > stageBounds.y2 : isHorizontalPosition && (mainDirectionOverlap = "left" === p && b.x1 < 0 || "right" === p && b.x2 > stageBounds.x2), !mainDirectionOverlap) {
                let secondaryOffset = 0;
                const szNumber = (isArray$9(symbolSize) ? symbolSize[1] : symbolSize) / 2;
                isVerticalPosition ? (b.x1 < 0 ? secondaryOffset = -b.x1 : b.x2 > stageBounds.x2 && (secondaryOffset = stageBounds.x2 - b.x2), group.setAttribute("x", group.attribute.x + secondaryOffset), bgSymbol.setAttribute("dx", min(max(bgSymbol.attribute.dx - secondaryOffset, szNumber), b.width() - szNumber))) : isHorizontalPosition && (b.y1 < 0 ? secondaryOffset = -b.y1 : b.y2 > stageBounds.y2 && (secondaryOffset = stageBounds.y2 - b.y2), group.setAttribute("y", group.attribute.y + secondaryOffset), bgSymbol.setAttribute("dy", min(max(bgSymbol.attribute.dy - secondaryOffset, szNumber), b.height() - szNumber)));
                break;
              }
            }
            if (!layout) break;
          }
        }
      }
      calculateAnchorPoint(position, positionBounds) {
        if (!positionBounds) return {
          x: 0,
          y: 0
        };
        const {
            x: x,
            y: y
          } = this.attribute,
          {
            x1: x1,
            y1: y1,
            x2: x2,
            y2: y2
          } = positionBounds,
          width = x2 - x1,
          height = y2 - y1;
        switch (position) {
          case "top":
          case "tl":
          case "tr":
            return {
              x: x1 + width / 2 - x,
              y: y1 - y
            };
          case "bottom":
          case "bl":
          case "br":
            return {
              x: x1 + width / 2 - x,
              y: y2 - y
            };
          case "left":
          case "lt":
          case "lb":
            return {
              x: x1 - x,
              y: y1 + height / 2 - y
            };
          case "right":
          case "rt":
          case "rb":
            return {
              x: x2 - x,
              y: y1 + height / 2 - y
            };
          default:
            return {
              x: 0,
              y: 0
            };
        }
      }
      getAngleAndOffset(position, width, height, size, symbolType) {
        const sizeH = "arrow2Left" === symbolType ? size[1] / 2 : size[1];
        switch (position) {
          case "tl":
            return {
              angle: "arrow2Left" === symbolType ? pi / 2 * 3 : 0,
              offset: "arrow2Left" === symbolType ? [width / 4, height + sizeH] : [0, height + sizeH]
            };
          case "top":
            return {
              angle: pi / 2 * 3,
              offset: [width / 2, height + sizeH]
            };
          case "tr":
            return {
              angle: "arrow2Left" === symbolType ? pi / 2 * 3 : 0,
              offset: "arrow2Left" === symbolType ? [width / 4 * 3, height + sizeH] : [width, height + sizeH]
            };
          case "rt":
            return {
              angle: 0,
              offset: "arrow2Left" === symbolType ? [-sizeH, height / 5] : [-sizeH, 0]
            };
          case "right":
            return {
              angle: 0,
              offset: [-sizeH, height / 2]
            };
          case "rb":
            return {
              angle: 0,
              offset: "arrow2Left" === symbolType ? [-sizeH, height / 5 * 4] : [-sizeH, height]
            };
          case "bl":
            return {
              angle: "arrow2Left" === symbolType ? pi / 2 : 0,
              offset: "arrow2Left" === symbolType ? [width / 4, -sizeH] : [0, -sizeH]
            };
          case "bottom":
            return {
              angle: pi / 2,
              offset: [width / 2, -sizeH]
            };
          case "br":
            return {
              angle: "arrow2Left" === symbolType ? pi / 2 : 0,
              offset: "arrow2Left" === symbolType ? [width / 4 * 3, -sizeH] : [width, -sizeH]
            };
          case "lt":
            return {
              angle: "arrow2Left" === symbolType ? pi : 0,
              offset: "arrow2Left" === symbolType ? [width + sizeH, height / 5] : [width + sizeH, 0]
            };
          case "left":
            return {
              angle: pi,
              offset: [width + sizeH, height / 2]
            };
          case "lb":
            return {
              angle: "arrow2Left" === symbolType ? pi : 0,
              offset: "arrow2Left" === symbolType ? [width + sizeH, height / 5 * 4] : [width + sizeH, height]
            };
        }
      }
      appearAnimate(animateConfig) {
        const {
          duration = 1e3,
          easing = "quadOut"
        } = animateConfig;
        if (this.setAttributes({
          scaleX: 0,
          scaleY: 0
        }), this.animate().to({
          scaleX: 1,
          scaleY: 1
        }, duration / 3 * 2, easing), this.titleShape && this.titleShape.animate().play(new InputText({
          text: ""
        }, {
          text: this.titleShape.attribute.text
        }, duration, easing)), this.contentShape && this.contentShape.animate().play(new InputText({
          text: ""
        }, {
          text: this.contentShape.attribute.text
        }, duration, easing)), animateConfig.wave) {
          const dur = duration / 6;
          this.group.animate().to({
            angle: animateConfig.wave
          }, dur, easing).to({
            angle: -animateConfig.wave
          }, 2 * dur, easing).to({
            angle: animateConfig.wave
          }, 2 * dur, easing).to({
            angle: 0
          }, dur, easing);
        }
      }
      disappearAnimate(animateConfig) {
        const {
          duration = 1e3,
          easing = "quadOut"
        } = animateConfig;
        this.animate().to({
          scaleX: 0,
          scaleY: 0
        }, duration, easing);
      }
    }
    PopTip.defaultAttributes = {
      position: "rt",
      visible: !0,
      title: null,
      content: null,
      titleStyle: {
        fontSize: 12,
        fill: "#000",
        textAlign: "left",
        textBaseline: "top"
      },
      contentStyle: {
        fontSize: 12,
        fill: "#000",
        textAlign: "left",
        textBaseline: "top"
      },
      panel: {},
      maxWidthPercent: .8,
      space: 8,
      padding: 10
    };

    var __decorate$2 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    function wrapPoptip(target, source) {
      return merge$2(target, theme$2.poptip, source), target;
    }
    let PopTipRenderContribution = class {
      render(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options) {
        var _a, _b;
        if (1 === graphic._showPoptip) {
          const {
            visible: visible,
            visibleCb: visibleCb
          } = graphic.attribute.poptip || {};
          if (!1 === visible || visibleCb && !1 === visibleCb(graphic)) return;
          const attribute = {};
          merge$2(attribute, PopTip.defaultAttributes, graphic.attribute.poptip ? graphic.attribute.poptip : {}), this.poptipComponent ? this.poptipComponent.initAttributes(attribute) : this.poptipComponent = new PopTip(attribute);
          let poptip = graphic.attribute.poptip || {};
          if ("text" === graphic.type && null == poptip.title && null == poptip.content) {
            const out = {};
            wrapPoptip(out, poptip), poptip = out, poptip.content = null !== (_a = poptip.content) && void 0 !== _a ? _a : graphic.attribute.text;
          }
          const matrix = graphic.globalTransMatrix;
          this.poptipComponent.setAttributes(Object.assign(Object.assign({
            visibleAll: !0,
            pickable: !1,
            childrenPickable: !1,
            poptipAnchor: "bounds"
          }, poptip), {
            x: matrix.e,
            y: matrix.f,
            positionBounds: graphic.globalAABBBounds
          })), drawContext.stage.tryInitInteractiveLayer();
          const interactiveLayer = drawContext.stage.getLayer("_builtin_interactive");
          interactiveLayer && interactiveLayer.add(this.poptipComponent);
        } else 2 === graphic._showPoptip && (graphic._showPoptip = 0, this.poptipComponent && (this.poptipComponent.setAttributes({
          visibleAll: !1
        }), null === (_b = this.poptipComponent.parent) || void 0 === _b || _b.removeChild(this.poptipComponent), this.poptipComponent = null));
      }
    };
    PopTipRenderContribution = __decorate$2([injectable()], PopTipRenderContribution);

    var __decorate$1 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    class PopTipPluginBase {
      constructor() {
        this.activeEvent = "onRegister", this._uid = Generator.GenAutoIncrementId(), this.poptip = e => {
          const graphic = e.target;
          this.needHide(graphic) ? this.unpoptip(e) : graphic !== this.activeGraphic && (this.needShow(graphic) && (graphic.setAttributes({}), graphic._showPoptip = 1), this.activeGraphic && (this.activeGraphic.setAttributes({}), this.activeGraphic._showPoptip = 2), this.setActiveGraphic(graphic, !0));
        }, this.unpoptip = e => {
          this.activeGraphic && (this.activeGraphic.setAttributes({}), this.activeGraphic._showPoptip = 2, this.setActiveGraphic(null, !0));
        };
      }
      activate(context) {
        this.pluginService = context;
        const {
          stage: stage
        } = this.pluginService;
        stage.addEventListener("pointerover", this.poptip);
      }
      needHide(graphic) {
        return graphic.isContainer || !graphic.attribute;
      }
      needShow(graphic) {
        return !!graphic.attribute.poptip;
      }
      setActiveGraphic(graphic, rerender) {
        this.activeGraphic = graphic, this.pluginService.stage.renderNextFrame();
      }
      deactivate(context) {
        const {
          stage: stage
        } = this.pluginService;
        stage.removeEventListener("pointerover", this.poptip);
      }
    }
    let PopTipPlugin = class extends PopTipPluginBase {
      constructor() {
        super(...arguments), this.name = "poptip", this.key = this.name + this._uid;
      }
    };
    PopTipPlugin = __decorate$1([injectable()], PopTipPlugin);
    let PopTipForClipedTextPlugin = class extends PopTipPluginBase {
      constructor() {
        super(...arguments), this.name = "poptipForText", this.key = this.name + this._uid, this.pointerlave = e => {
          const {
            stage: stage
          } = this.pluginService;
          e.target === stage && this.unpoptip(e);
        };
      }
      activate(context) {
        super.activate(context);
        const {
          stage: stage
        } = this.pluginService;
        stage.addEventListener("pointerleave", this.pointerlave);
      }
      needHide(graphic) {
        return "text" !== graphic.type || !graphic.cliped || graphic.isContainer || !graphic.attribute || graphic.attribute.disableAutoClipedPoptip;
      }
      needShow(graphic) {
        return !0;
      }
      deactivate(context) {
        const {
          stage: stage
        } = this.pluginService;
        super.deactivate(context), stage.removeEventListener("pointerleave", this.pointerlave);
      }
    };
    PopTipForClipedTextPlugin = __decorate$1([injectable()], PopTipForClipedTextPlugin);

    const popTipModule = new ContainerModule((bind, unbind, isBound, rebind) => {
      isBound(PopTipRenderContribution) || (bind(PopTipRenderContribution).toSelf().inSingletonScope(), bind(InteractiveSubRenderContribution).toService(PopTipRenderContribution)), isBound(PopTipPlugin) || (bind(PopTipPlugin).toSelf(), bind(AutoEnablePlugins).toService(PopTipPlugin)), isBound(PopTipForClipedTextPlugin) || (bind(PopTipForClipedTextPlugin).toSelf(), bind(AutoEnablePlugins).toService(PopTipForClipedTextPlugin));
    });
    function loadPoptip() {
      container.load(popTipModule);
    }

    function loadSegmentComponent() {
      registerGroup(), registerLine(), registerPolygon(), registerSymbol();
    }

    loadSegmentComponent();
    class Segment extends AbstractComponent {
      getStartAngle() {
        return normalizeAngle(this._startAngle);
      }
      getEndAngle() {
        return normalizeAngle(this._endAngle);
      }
      getMainSegmentPoints() {
        return this._mainSegmentPoints;
      }
      constructor(attributes, options) {
        super((null == options ? void 0 : options.skipDefault) ? attributes : merge$2({}, Segment.defaultAttributes, attributes)), this.name = "segment", this.key = "segment", this.lines = [];
      }
      render() {
        this.removeAllChild(!0), this._reset();
        const {
          startSymbol: startSymbol,
          endSymbol: endSymbol,
          lineStyle: lineStyle,
          state: state,
          visible = !0,
          multiSegment: multiSegment,
          mainSegmentIndex: mainSegmentIndex
        } = this.attribute;
        if (!visible) return;
        this._computeLineAngle();
        const points = this._getMainSegmentPoints(),
          startSymbolShape = this._renderSymbol(startSymbol, points, "start"),
          endSymbolShape = this._renderSymbol(endSymbol, points, "end");
        if (this.startSymbol = startSymbolShape, this.endSymbol = endSymbolShape, multiSegment) {
          const points = [...this.attribute.points];
          if (isValidNumber$3(mainSegmentIndex)) points[mainSegmentIndex] = this._clipPoints(points[mainSegmentIndex]);else {
            const clipPoints = this._clipPoints(flattenArray(points));
            points[0][0] = clipPoints[0], points[points.length - 1][points[points.length - 1].length - 1] = clipPoints[clipPoints.length - 1];
          }
          points.forEach((point, index) => {
            var _a, _b;
            const line = graphicCreator.line(Object.assign(Object.assign({
              points: point
            }, isArray$9(lineStyle) ? null !== (_a = lineStyle[index]) && void 0 !== _a ? _a : lineStyle[lineStyle.length - 1] : lineStyle), {
              fill: !1
            }));
            line.name = `${this.name}-line`, line.id = this._getNodeId("line" + index), isEmpty$1(null == state ? void 0 : state.line) || (line.states = isArray$9(state.line) ? null !== (_b = state.line[index]) && void 0 !== _b ? _b : state.line[state.line.length - 1] : state.line), this.add(line), this.lines.push(line);
          });
        } else {
          let lineCreator = graphicCreator.line;
          array$1(lineStyle)[0].cornerRadius && (lineCreator = graphicCreator.polygon);
          const line = lineCreator(Object.assign(Object.assign({
            points: this._clipPoints(this.attribute.points)
          }, array$1(lineStyle)[0]), {
            fill: !1,
            closePath: !1
          }));
          line.name = `${this.name}-line`, line.id = this._getNodeId("line"), isEmpty$1(null == state ? void 0 : state.line) || (line.states = [].concat(state.line)[0]), this.add(line), this.lines.push(line);
        }
      }
      _computeStartRotate(angle) {
        return angle + Math.PI / 2;
      }
      _computeEndRotate(angle) {
        return angle + Math.PI / 2;
      }
      _renderSymbol(attribute, points, dim) {
        if (!points.length) return;
        const {
          autoRotate = !0
        } = attribute;
        let symbol;
        if (attribute && attribute.visible) {
          const startAngle = this.getStartAngle(),
            endAngle = this.getEndAngle(),
            {
              state: state
            } = this.attribute,
            start = points[0],
            end = points[points.length - 1],
            {
              refX = 0,
              refY = 0,
              refAngle = 0,
              style: style,
              symbolType: symbolType,
              size = 12
            } = attribute;
          let position, rotate;
          "start" === dim ? (position = {
            x: start.x + (isValidNumber$3(startAngle) ? refX * Math.cos(startAngle) + refY * Math.cos(startAngle - Math.PI / 2) : 0),
            y: start.y + (isValidNumber$3(startAngle) ? refX * Math.sin(startAngle) + refY * Math.sin(startAngle - Math.PI / 2) : 0)
          }, rotate = this._computeStartRotate(this._startAngle)) : (position = {
            x: end.x + (isValidNumber$3(endAngle) ? refX * Math.cos(endAngle) + refY * Math.cos(endAngle - Math.PI / 2) : 0),
            y: end.y + (isValidNumber$3(endAngle) ? refX * Math.sin(endAngle) + refY * Math.sin(endAngle - Math.PI / 2) : 0)
          }, rotate = this._computeEndRotate(this._endAngle)), symbol = graphicCreator.symbol(Object.assign(Object.assign(Object.assign({}, position), {
            symbolType: symbolType,
            size: size,
            angle: autoRotate ? rotate + refAngle : 0,
            strokeBoundsBuffer: 0
          }), style)), symbol.name = `${this.name}-${dim}-symbol`, symbol.id = this._getNodeId(`${dim}-symbol`), isEmpty$1(null == state ? void 0 : state.symbol) || (symbol.states = state.symbol), "start" === dim ? isEmpty$1(null == state ? void 0 : state.startSymbol) || (symbol.states = state.startSymbol) : isEmpty$1(null == state ? void 0 : state.endSymbol) || (symbol.states = state.endSymbol), this.add(symbol);
        }
        return symbol;
      }
      _getMainSegmentPoints() {
        if (this._mainSegmentPoints) return this._mainSegmentPoints;
        const {
          points: originPoints,
          multiSegment: multiSegment,
          mainSegmentIndex: mainSegmentIndex
        } = this.attribute;
        let points;
        return points = multiSegment ? isValidNumber$3(mainSegmentIndex) ? originPoints[mainSegmentIndex] : flattenArray(originPoints) : originPoints, this._mainSegmentPoints = points, points;
      }
      _clipPoints(points) {
        const {
          startSymbol = {},
          endSymbol = {}
        } = this.attribute;
        let pointsAfterClip = points;
        if (startSymbol.visible) {
          const startSize = startSymbol.clip ? startSymbol.size || 10 : 0;
          pointsAfterClip = [{
            x: points[0].x - startSize / 2 * (Math.cos(this._startAngle) || 0),
            y: points[0].y - startSize / 2 * (Math.sin(this._startAngle) || 0)
          }, ...pointsAfterClip.slice(1)];
        }
        if (endSymbol.visible) {
          const endSize = endSymbol.clip ? endSymbol.size || 10 : 0,
            pointsEnd = {
              x: points[points.length - 1].x - endSize / 2 * (Math.cos(this._endAngle) || 0),
              y: points[points.length - 1].y - endSize / 2 * (Math.sin(this._endAngle) || 0)
            };
          pointsAfterClip = [...pointsAfterClip.slice(0, pointsAfterClip.length - 1), pointsEnd];
        }
        return pointsAfterClip;
      }
      _computeLineAngle() {
        const points = this._getMainSegmentPoints();
        if (points.length <= 1) return;
        const start = points[0],
          startInside = points[1],
          endInside = points[points.length - 2],
          end = points[points.length - 1],
          startVector = [start.x - startInside.x, start.y - startInside.y],
          startAngle = Math.atan2(startVector[1], startVector[0]),
          endVector = [end.x - endInside.x, end.y - endInside.y],
          endAngle = Math.atan2(endVector[1], endVector[0]);
        this._startAngle = startAngle, this._endAngle = endAngle;
      }
      _reset() {
        this.startSymbol = null, this.endSymbol = null, this._startAngle = null, this._endAngle = null, this._mainSegmentPoints = null;
      }
    }
    Segment.defaultAttributes = {
      visible: !0,
      lineStyle: {
        lineWidth: 1,
        stroke: "#000"
      },
      startSymbol: {
        visible: !1,
        autoRotate: !0,
        symbolType: "triangle",
        size: 12,
        refX: 0,
        refY: 0,
        refAngle: 0,
        style: {
          fill: "#000",
          zIndex: 1
        }
      },
      endSymbol: {
        visible: !1,
        autoRotate: !0,
        symbolType: "triangle",
        size: 12,
        refX: 0,
        refY: 0,
        refAngle: 0,
        style: {
          fill: "#000",
          zIndex: 1
        }
      }
    };

    var AXIS_ELEMENT_NAME;
    !function (AXIS_ELEMENT_NAME) {
      AXIS_ELEMENT_NAME.innerView = "inner-view", AXIS_ELEMENT_NAME.axisContainer = "axis-container", AXIS_ELEMENT_NAME.labelContainer = "axis-label-container", AXIS_ELEMENT_NAME.tickContainer = "axis-tick-container", AXIS_ELEMENT_NAME.tick = "axis-tick", AXIS_ELEMENT_NAME.subTick = "axis-sub-tick", AXIS_ELEMENT_NAME.label = "axis-label", AXIS_ELEMENT_NAME.title = "axis-title", AXIS_ELEMENT_NAME.gridContainer = "axis-grid-container", AXIS_ELEMENT_NAME.grid = "axis-grid", AXIS_ELEMENT_NAME.gridRegion = "axis-grid-region", AXIS_ELEMENT_NAME.line = "axis-line", AXIS_ELEMENT_NAME.background = "axis-background", AXIS_ELEMENT_NAME.axisLabelBackground = "axis-label-background", AXIS_ELEMENT_NAME.axisBreak = "axis-break", AXIS_ELEMENT_NAME.axisBreakSymbol = "axis-break-symbol";
    }(AXIS_ELEMENT_NAME || (AXIS_ELEMENT_NAME = {}));
    var AxisStateValue;
    !function (AxisStateValue) {
      AxisStateValue.selected = "selected", AxisStateValue.selectedReverse = "selected_reverse", AxisStateValue.hover = "hover", AxisStateValue.hoverReverse = "hover_reverse";
    }(AxisStateValue || (AxisStateValue = {}));
    const DEFAULT_STATES$1 = {
      [AxisStateValue.selectedReverse]: {},
      [AxisStateValue.selected]: {},
      [AxisStateValue.hover]: {},
      [AxisStateValue.hoverReverse]: {}
    };
    const TopZIndex = 999;

    const DEFAULT_AXIS_THEME = {
      title: {
        space: 4,
        padding: 0,
        textStyle: {
          fontSize: 12,
          fill: "#333333",
          fontWeight: "normal",
          fillOpacity: 1
        }
      },
      label: {
        visible: !0,
        inside: !1,
        space: 4,
        padding: 0,
        style: {
          fontSize: 12,
          fill: "#333",
          fontWeight: "normal",
          fillOpacity: 1
        }
      },
      tick: {
        visible: !0,
        inside: !1,
        alignWithLabel: !0,
        length: 4,
        style: {
          lineWidth: 1,
          stroke: "#000",
          strokeOpacity: 1
        }
      },
      subTick: {
        visible: !1,
        inside: !1,
        count: 4,
        length: 2,
        style: {
          lineWidth: 1,
          stroke: "#999",
          strokeOpacity: 1
        }
      },
      line: {
        visible: !0,
        style: {
          lineWidth: 1,
          stroke: "#000",
          strokeOpacity: 1
        }
      }
    };
    const DEFAULT_AXIS_BREAK_SYMBOL_STYLE = {
      size: 8,
      stroke: "#000",
      lineWidth: 1,
      zIndex: 1
    };

    function genNormalBounds(item) {
      const bounds = item.AABBBounds;
      return {
        x1: bounds.x1,
        x2: bounds.x2,
        y1: bounds.y1,
        y2: bounds.y2,
        centerX: item.attribute.x,
        centerY: item.attribute.y,
        angle: item.attribute.angle
      };
    }
    function genRotateBounds(items) {
      items.forEach(item => {
        if (item.rotatedBounds || !item.attribute.angle) return;
        const bounds = genNormalBounds(item),
          rotatedCenter = rotatePoint({
            x: item.attribute.x,
            y: item.attribute.y
          }, bounds.angle, {
            x: bounds.centerX,
            y: bounds.centerY
          }),
          deltaX = rotatedCenter.x - bounds.centerX,
          deltaY = rotatedCenter.y - bounds.centerY;
        bounds.x1 += deltaX, bounds.x2 += deltaX, bounds.y1 += deltaY, bounds.y2 += deltaY, bounds.centerX += deltaX, bounds.centerY += deltaY, item.rotatedBounds = bounds;
      });
    }
    function itemIntersect(item1, item2) {
      var _a, _b;
      return (null === (_a = item1.OBBBounds) || void 0 === _a ? void 0 : _a.empty()) || (null === (_b = item2.OBBBounds) || void 0 === _b ? void 0 : _b.empty()) ? isRectIntersect(item1.AABBBounds, item2.AABBBounds, !1) && (!item1.rotatedBounds || !item2.rotatedBounds || isRotateAABBIntersect(item1.rotatedBounds, item2.rotatedBounds, !0)) : item1.OBBBounds.intersects(item2.OBBBounds);
    }
    const DELTA_ANGLE = Math.sin(Math.PI / 10);
    function isAngleVertical(angle) {
      let delta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DELTA_ANGLE;
      const hasAngle = !isNil$5(angle) && 0 !== angle,
        cos = hasAngle ? Math.cos(angle) : 1;
      return hasAngle && Math.abs(cos) <= delta;
    }
    function isAngleHorizontal(angle) {
      let delta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DELTA_ANGLE;
      const hasAngle = !isNil$5(angle) && 0 !== angle,
        sin = hasAngle ? Math.sin(angle) : 0;
      return !hasAngle || Math.abs(sin) <= delta;
    }

    function getCircleLabelPosition(tickPosition, tickVector) {
      return {
        x: tickPosition.x + tickVector[0],
        y: tickPosition.y + tickVector[1]
      };
    }
    function getAxisBreakSymbolAttrs() {
      let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var _a, _b;
      const {
          style = {},
          angle = .5 * Math.PI
        } = props,
        symbolStyle = merge$2({}, DEFAULT_AXIS_BREAK_SYMBOL_STYLE, style),
        symbolSize = null !== (_a = symbolStyle.size) && void 0 !== _a ? _a : DEFAULT_AXIS_BREAK_SYMBOL_STYLE.size;
      return Object.assign(Object.assign({}, symbolStyle), {
        symbolType: null !== (_b = symbolStyle.symbolType) && void 0 !== _b ? _b : `M ${-symbolSize / 2} ${symbolSize * Math.sin(angle)} L ${symbolSize / 2} ${-symbolSize * Math.sin(angle)}`,
        symbolSize: symbolSize
      });
    }
    function getElMap(g) {
      const elMap = {};
      return traverseGroup(g, el => {
        "group" !== el.type && el.id && (elMap[el.id] = el);
      }), elMap;
    }
    function getVerticalCoord(point, vector) {
      return {
        x: point.x + vector[0],
        y: point.y + vector[1]
      };
    }
    function getCircleVerticalVector(offset, point, center) {
      let inside = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
      let axisInside = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !1;
      const vector = [point.x - center.x, point.y - center.y];
      return scale(vector, (inside ? -1 : 1) * (axisInside ? -1 : 1) * offset / length(vector));
    }
    function getPolarAngleLabelPosition(angle, center, radius, labelOffset, inside) {
      const point = polarToCartesian({
          x: 0,
          y: 0
        }, radius, angle),
        labelPoint = getVerticalCoord(point, getCircleVerticalVector(labelOffset, point, center, inside));
      return getCircleLabelPosition(labelPoint, getCircleVerticalVector(labelOffset || 1, labelPoint, center, inside));
    }
    function textIntersect(textA, textB, sep) {
      var _a;
      const angle = null === (_a = textA.attribute) || void 0 === _a ? void 0 : _a.angle;
      if (isAngleHorizontal(angle, Number.EPSILON)) return sep > aabbSeparation(textA.AABBBounds, textB.AABBBounds);
      const a = textA.OBBBounds,
        b = textB.OBBBounds;
      return !a || !b || a.empty() || b.empty() ? sep > aabbSeparation(textA.AABBBounds, textB.AABBBounds) : a.intersects(b) || sep > obbSeparation(a, b);
    }
    function hasOverlap(items, pad) {
      for (let b, i = 1, n = items.length, a = items[0]; i < n; a = b, ++i) if (b = items[i], textIntersect(a, b, pad)) return !0;
      return !1;
    }

    const dispatchHoverState = (e, container, lastHover) => {
      const target = e.target;
      return target !== lastHover && target.name && !isEmpty$1(target.states) ? (target.addState(StateValue.hover, !0), traverseGroup(container, node => {
        node !== target && node.name && !isEmpty$1(node.states) && node.addState(StateValue.hoverReverse, !0);
      }), target) : lastHover;
    };
    const dispatchUnHoverState = (e, container, lastHover) => lastHover ? (traverseGroup(container, node => {
      node.name && !isEmpty$1(node.states) && (node.removeState(StateValue.hoverReverse), node.removeState(StateValue.hover));
    }), null) : lastHover;
    const dispatchClickState = (e, container, lastSelect) => {
      const target = e.target;
      return lastSelect === target && target.hasState(StateValue.selected) ? (traverseGroup(container, node => {
        node.name && !isEmpty$1(node.states) && (node.removeState(StateValue.selectedReverse), node.removeState(StateValue.selected));
      }), null) : target.name && !isEmpty$1(target.states) ? (target.addState(StateValue.selected, !0), traverseGroup(container, node => {
        node !== target && node.name && !isEmpty$1(node.states) && node.addState(StateValue.selectedReverse, !0);
      }), target) : lastSelect;
    };

    class AxisBase extends AbstractComponent {
      constructor() {
        super(...arguments), this.name = "axis", this.data = [], this.tickLineItems = [], this.subTickLineItems = [], this.axisLabelLayerSize = {}, this.axisLabelsContainer = null, this._onHover = e => {
          this._lastHover = dispatchHoverState(e, this.axisContainer, this._lastHover);
        }, this._onUnHover = e => {
          this._lastHover = dispatchUnHoverState(e, this.axisContainer, this._lastHover);
        }, this._onClick = e => {
          this._lastSelect = dispatchClickState(e, this.axisContainer, this._lastSelect);
        };
      }
      getInnerView() {
        return this._innerView;
      }
      getPrevInnerView() {
        return this._prevInnerView;
      }
      getBoundsWithoutRender(attributes) {
        const currentAttribute = cloneDeep$2(this.attribute);
        merge$2(this.attribute, attributes);
        const offscreenGroup = graphicCreator.group({
          x: this.attribute.x,
          y: this.attribute.y
        });
        return this.add(offscreenGroup), this._renderInner(offscreenGroup), this.removeChild(offscreenGroup), this.attribute = currentAttribute, offscreenGroup.AABBBounds;
      }
      render() {
        this._prevInnerView = this._innerView && getElMap(this._innerView), this.removeAllChild(!0), this._innerView = graphicCreator.group({
          x: 0,
          y: 0,
          pickable: !1
        }), this.add(this._innerView), this._renderInner(this._innerView), this._bindEvent();
      }
      _bindEvent() {
        if (this.attribute.disableTriggerEvent) return;
        const {
          hover: hover,
          select: select
        } = this.attribute;
        hover && (this._innerView.addEventListener("pointermove", this._onHover), this._innerView.addEventListener("pointerout", this._onUnHover)), select && this._innerView.addEventListener("pointerdown", this._onClick);
      }
      _renderInner(container) {
        const {
            title: title,
            label: label,
            tick: tick,
            line: line,
            items: items
          } = this.attribute,
          axisContainer = graphicCreator.group({
            x: 0,
            y: 0,
            zIndex: 1,
            pickable: !1
          });
        if (axisContainer.name = AXIS_ELEMENT_NAME.axisContainer, axisContainer.id = this._getNodeId("container"), axisContainer.setMode(this.mode), this.axisContainer = axisContainer, container.add(axisContainer), line && line.visible && this.renderLine(axisContainer), items && items.length && (this.data = this._transformItems(items[0]), tick && tick.visible && this.renderTicks(axisContainer), label && label.visible)) {
          const labelGroup = graphicCreator.group({
            x: 0,
            y: 0,
            pickable: !1
          });
          labelGroup.name = AXIS_ELEMENT_NAME.labelContainer, labelGroup.id = this._getNodeId("label-container"), this.axisLabelsContainer = labelGroup, axisContainer.add(labelGroup), items.forEach((axisItems, layer) => {
            const layerLabelGroup = this.renderLabels(labelGroup, axisItems, layer),
              labels = layerLabelGroup.getChildren();
            this.beforeLabelsOverlap(labels, axisItems, layerLabelGroup, layer, items.length), this.handleLabelsOverlap(labels, axisItems, layerLabelGroup, layer, items.length), this.afterLabelsOverlap(labels, axisItems, layerLabelGroup, layer, items.length);
            let maxTextWidth = 0,
              maxTextHeight = 0,
              textAlign = "center",
              textBaseline = "middle",
              labelPos = 0;
            labels.forEach((label, index) => {
              var _a;
              const labelStyle = label.attribute,
                angle = null !== (_a = labelStyle.angle) && void 0 !== _a ? _a : 0,
                textBounds = label.AABBBounds;
              let textWidth = textBounds.width(),
                textHeight = textBounds.height();
              angle && (textWidth = Math.abs(textWidth * Math.cos(angle)), textHeight = Math.abs(textHeight * Math.sin(angle))), maxTextWidth = Math.max(maxTextWidth, textWidth), maxTextHeight = Math.max(maxTextHeight, textHeight), textAlign = labelStyle.textAlign, textBaseline = labelStyle.textBaseline, 0 === index && (labelPos = labelStyle.x);
            }), this.axisLabelLayerSize[layer] = {
              width: maxTextWidth,
              height: maxTextHeight,
              labelPos: labelPos,
              textAlign: textAlign,
              textBaseline: textBaseline
            };
          });
        }
        title && title.visible && this.renderTitle(axisContainer);
      }
      renderTicks(container) {
        const tickLineItems = this.getTickLineItems(),
          tickLineGroup = graphicCreator.group({
            x: 0,
            y: 0,
            pickable: !1
          });
        tickLineGroup.name = AXIS_ELEMENT_NAME.tickContainer, tickLineGroup.id = this._getNodeId("tick-container"), container.add(tickLineGroup), tickLineItems.forEach((item, index) => {
          var _a;
          const line = graphicCreator.line(Object.assign({}, this._getTickLineAttribute("tick", item, index, tickLineItems)));
          if (line.name = AXIS_ELEMENT_NAME.tick, line.id = this._getNodeId(item.id), isEmpty$1(null === (_a = this.attribute.tick) || void 0 === _a ? void 0 : _a.state)) line.states = DEFAULT_STATES$2;else {
            const data = this.data[index],
              tickLineState = merge$2({}, DEFAULT_STATES$2, this.attribute.tick.state);
            Object.keys(tickLineState).forEach(key => {
              isFunction$7(tickLineState[key]) && (tickLineState[key] = tickLineState[key](data.rawValue, index, data, this.data));
            }), line.states = tickLineState;
          }
          tickLineGroup.add(line);
        }), this.tickLineItems = tickLineItems;
        const {
          subTick: subTick
        } = this.attribute;
        if (subTick && subTick.visible) {
          const subTickLineItems = this.getSubTickLineItems();
          subTickLineItems.length && subTickLineItems.forEach((item, index) => {
            const line = graphicCreator.line(Object.assign({}, this._getTickLineAttribute("subTick", item, index, tickLineItems)));
            if (line.name = AXIS_ELEMENT_NAME.subTick, line.id = this._getNodeId(`${index}`), isEmpty$1(subTick.state)) line.states = DEFAULT_STATES$2;else {
              const subTickLineState = merge$2({}, DEFAULT_STATES$2, subTick.state);
              Object.keys(subTickLineState).forEach(key => {
                isFunction$7(subTickLineState[key]) && (subTickLineState[key] = subTickLineState[key](item.value, index, item, tickLineItems));
              }), line.states = subTickLineState;
            }
            tickLineGroup.add(line);
          }), this.subTickLineItems = subTickLineItems;
        }
      }
      renderLabels(container, items, layer) {
        const {
          dataFilter: dataFilter
        } = this.attribute.label;
        dataFilter && isFunction$7(dataFilter) && (items = dataFilter(items, layer));
        const data = this._transformItems(items),
          labelGroup = graphicCreator.group({
            x: 0,
            y: 0,
            pickable: !1
          });
        return labelGroup.name = `${AXIS_ELEMENT_NAME.labelContainer}-layer-${layer}`, labelGroup.id = this._getNodeId(`label-container-layer-${layer}`), container.add(labelGroup), data.forEach((item, index) => {
          var _a;
          const labelStyle = this._getLabelAttribute(item, index, data, layer),
            text = createTextGraphicByType(labelStyle);
          if (text.name = AXIS_ELEMENT_NAME.label, text.id = this._getNodeId(`layer${layer}-label-${item.id}`), isEmpty$1(null === (_a = this.attribute.label) || void 0 === _a ? void 0 : _a.state)) text.states = DEFAULT_STATES$2;else {
            const labelState = merge$2({}, DEFAULT_STATES$2, this.attribute.label.state);
            Object.keys(labelState).forEach(key => {
              isFunction$7(labelState[key]) && (labelState[key] = labelState[key](item, index, data, layer));
            }), text.states = labelState;
          }
          text.data = Object.assign(Object.assign({}, item), {
            index: index,
            layer: layer
          }), labelGroup.add(text);
        }), labelGroup;
      }
      renderTitle(container) {
        const titleAttributes = this.getTitleAttribute(),
          axisTitle = new Tag$1(Object.assign({}, titleAttributes));
        axisTitle.name = AXIS_ELEMENT_NAME.title, axisTitle.id = this._getNodeId("title"), container.add(axisTitle);
      }
      getVerticalCoord(point, offset, inside) {
        return getVerticalCoord(point, this.getVerticalVector(offset, inside, point));
      }
      getTickLineItems() {
        const {
            tick: tick
          } = this.attribute,
          data = this.data,
          tickLineItems = [],
          {
            alignWithLabel: alignWithLabel,
            inside = !1,
            length: length,
            dataFilter: dataFilter
          } = tick;
        let tickSegment = 1;
        return data.length >= 2 && (tickSegment = data[1].value - data[0].value), (dataFilter && isFunction$7(dataFilter) ? dataFilter(data) : data).forEach(item => {
          let point = item.point,
            tickValue = item.value;
          if (!alignWithLabel) {
            const value = item.value - tickSegment / 2;
            if (this.isInValidValue(value)) return;
            point = this.getTickCoord(value), tickValue = value;
          }
          const endPoint = this.getVerticalCoord(point, length, inside);
          if ("3d" === this.mode) {
            const vec = this.getVerticalVector(length, inside, point);
            let alpha = 0,
              beta = 0;
            abs(vec[0]) > abs(vec[1]) ? alpha = pi / 2 * (endPoint.x > point.x ? 1 : -1) : beta = pi / 2 * (endPoint.y > point.y ? -1 : 1), tickLineItems.push({
              start: point,
              end: endPoint,
              value: tickValue,
              id: `tick-${item.id}`,
              anchor: [point.x, point.y],
              alpha: alpha,
              beta: beta
            });
          } else tickLineItems.push({
            start: point,
            end: endPoint,
            value: tickValue,
            id: `tick-${item.id}`
          });
        }), tickLineItems;
      }
      getSubTickLineItems() {
        const {
            subTick: subTick
          } = this.attribute,
          subTickLineItems = [],
          {
            count: subCount = 4,
            inside = !1,
            length = 2
          } = subTick,
          tickLineItems = this.tickLineItems,
          tickLineCount = tickLineItems.length;
        if (tickLineCount >= 2) for (let i = 0; i < tickLineCount - 1; i++) {
          const pre = tickLineItems[i],
            next = tickLineItems[i + 1];
          for (let j = 0; j < subCount; j++) {
            const percent = (j + 1) / (subCount + 1),
              value = (1 - percent) * pre.value + percent * next.value,
              point = this.getTickCoord(value),
              endPoint = this.getVerticalCoord(point, length, inside);
            subTickLineItems.push({
              start: point,
              end: endPoint,
              value: value,
              id: `sub-tick-${value}`
            });
          }
        }
        return subTickLineItems;
      }
      _getTickLineAttribute(type, tickItem, index, tickItems) {
        let style = get$9(this.attribute, `${type}.style`);
        const data = this.data[index];
        style = isFunction$7(style) ? merge$2({}, get$9(DEFAULT_AXIS_THEME, `${type}.style`), "tick" === type ? style(data.rawValue, index, data, this.data) : style(tickItem.value, index, tickItem, tickItems)) : style;
        const {
          start: start,
          end: end,
          anchor: anchor,
          alpha: alpha,
          beta: beta
        } = tickItem;
        return Object.assign({
          points: [start, end],
          anchor: anchor,
          alpha: alpha,
          beta: beta
        }, style);
      }
      _getLabelAttribute(tickDatum, index, tickData, layer) {
        var _a, _b;
        const {
          space = 4,
          inside = !1,
          formatMethod: formatMethod,
          type = "text",
          text: text
        } = this.attribute.label;
        let offset = space,
          tickLength = 0;
        (null === (_a = this.attribute.tick) || void 0 === _a ? void 0 : _a.visible) && this.attribute.tick.inside === inside && (tickLength = this.attribute.tick.length || 4), (null === (_b = this.attribute.subTick) || void 0 === _b ? void 0 : _b.visible) && this.attribute.subTick.inside === inside && (tickLength = Math.max(tickLength, this.attribute.subTick.length || 2)), offset += tickLength;
        const axisVector = this.getRelativeVector(tickDatum.point);
        layer > 0 && (0 === axisVector[1] ? offset += (this.axisLabelLayerSize[layer - 1].height + get$9(this.attribute, "label.space", 4)) * layer : offset += (this.axisLabelLayerSize[layer - 1].width + get$9(this.attribute, "label.space", 4)) * layer);
        const point = this.getVerticalCoord(tickDatum.point, offset, inside),
          vector = this.getVerticalVector(offset || 1, inside, point),
          textContent = formatMethod ? formatMethod(`${tickDatum.label}`, tickDatum, index, tickData, layer) : tickDatum.label;
        let {
          style: textStyle
        } = this.attribute.label;
        textStyle = isFunction$7(textStyle) ? merge$2({}, DEFAULT_AXIS_THEME.label.style, textStyle(tickDatum, index, tickData, layer)) : textStyle;
        const labelAlign = this.getLabelAlign(vector, inside, textStyle.angle);
        return textStyle = merge$2(labelAlign, textStyle), isFunction$7(textStyle.text) && (textStyle.text = textStyle.text({
          label: tickDatum.label,
          value: tickDatum.rawValue,
          index: tickDatum.index,
          layer: layer
        })), Object.assign(Object.assign(Object.assign({}, this.getLabelPosition(point, vector, textContent, textStyle)), {
          text: null != text ? text : textContent,
          _originText: tickDatum.label,
          lineHeight: null == textStyle ? void 0 : textStyle.fontSize,
          type: type
        }), textStyle);
      }
      getLabelPosition(point, vector, text, style) {
        return point;
      }
      _transformItems(items) {
        const data = [];
        return items.forEach(item => {
          var _a;
          data.push(Object.assign(Object.assign({}, item), {
            point: this.getTickCoord(item.value),
            id: null !== (_a = item.id) && void 0 !== _a ? _a : item.label
          }));
        }), data;
      }
      release() {
        super.release(), this._prevInnerView = null, this._innerView = null;
      }
    }

    const methods$1 = {
      parity: function (items) {
        return items.filter((item, i) => i % 2 ? item.setAttribute("opacity", 0) : 1);
      },
      greedy: function (items, sep) {
        let a;
        return items.filter((b, i) => i && textIntersect(a, b, sep) ? b.setAttribute("opacity", 0) : (a = b, 1));
      }
    };
    function hasBounds(item) {
      let bounds;
      return bounds = item.OBBBounds.empty() ? item.AABBBounds : item.OBBBounds, bounds.width() > 1 && bounds.height() > 1;
    }
    function reset(items) {
      return items.forEach(item => item.setAttribute("opacity", 1)), items;
    }
    function forceItemVisible$1(sourceItem, items, check, comparator) {
      let inverse = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !1;
      if (check && !sourceItem.attribute.opacity) {
        const remainLength = items.length;
        if (remainLength > 1) {
          sourceItem.setAttribute("opacity", 1);
          for (let i = 0; i < remainLength; i++) {
            const item = inverse ? items[remainLength - 1 - i] : items[i];
            if (!comparator(item)) break;
            item.setAttribute("opacity", 0);
          }
        }
      }
    }
    function autoHide(labels, config) {
      if (isEmpty$1(labels)) return;
      const source = labels.filter(hasBounds);
      if (isEmpty$1(source)) return;
      let items;
      items = reset(source);
      const {
          method = "parity",
          separation: sep = 0
        } = config,
        reduce = isFunction$7(method) ? method : methods$1[method] || methods$1.parity;
      if (items.length >= 3 && hasOverlap(items, sep)) {
        do {
          items = reduce(items, sep);
        } while (items.length >= 3 && hasOverlap(items, sep));
        const shouldCheck = function (length, visibility) {
            let checkLength = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !0;
            return checkLength && length < 3 || visibility;
          },
          checkFirst = shouldCheck(items.length, config.firstVisible, !1);
        let checkLast = shouldCheck(items.length, config.lastVisible);
        const firstSourceItem = source[0],
          lastSourceItem = last$1(source);
        textIntersect(firstSourceItem, lastSourceItem, sep) && checkFirst && checkLast && (lastSourceItem.setAttribute("opacity", 0), checkLast = !1), forceItemVisible$1(firstSourceItem, items, checkFirst, item => textIntersect(item, firstSourceItem, sep)), forceItemVisible$1(lastSourceItem, items, checkLast, item => textIntersect(item, lastSourceItem, sep) || !(!checkFirst || item === firstSourceItem) && textIntersect(item, firstSourceItem, sep), !0);
      }
      source.forEach(item => {
        item.setAttribute("visible", !!item.attribute.opacity);
      });
    }

    function autoRotate(items, rotateConfig) {
      if (isEmpty$1(items)) return;
      const {
        orient: orient,
        labelRotateAngle = [0, 45, 90]
      } = rotateConfig;
      if (0 === labelRotateAngle.length || items.some(item => !!item.attribute.angle)) return;
      let i = 0,
        n = 0;
      for (labelRotateAngle && labelRotateAngle.length > 0 && (n = labelRotateAngle.length); i < n;) {
        const angle = labelRotateAngle[i++];
        if (items.forEach(item => {
          item.attribute.angle = degreeToRadian$1(angle);
        }), tryRotate(orient, items), !hasIntersect(items)) break;
      }
    }
    function hasIntersect(items) {
      for (let i = 1; i < items.length; i++) if (itemIntersect(items[i - 1], items[i])) return !0;
      return !1;
    }
    function tryRotate(orient, items) {
      "bottom" !== orient && "top" !== orient || rotateXAxis(orient, items), "left" !== orient && "right" !== orient || rotateYAxis(orient, items), genRotateBounds(items);
    }
    function clampAngle() {
      let angle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      if (angle < 0) for (; angle < 0;) angle += 2 * Math.PI;
      if (angle > 0) for (; angle >= 2 * Math.PI;) angle -= 2 * Math.PI;
      return angle;
    }
    function rotateYAxis(orient, items) {
      items.forEach((item, i) => {
        item.attribute.angle && item.setAttributes(Object.assign(Object.assign({}, getYAxisLabelAlign(orient, item.attribute.angle)), {
          angle: clampAngle(item.attribute.angle)
        }));
      });
    }
    function rotateXAxis(orient, items) {
      items.forEach(item => {
        item.attribute.angle && item.setAttributes(Object.assign(Object.assign({}, getXAxisLabelAlign(orient, item.attribute.angle)), {
          angle: clampAngle(item.attribute.angle)
        }));
      });
    }
    function getXAxisLabelAlign(orient) {
      let angle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      let align = ["center", "left", "left", "left", "center", "right", "right", "right", "left"],
        baseline = ["top", "top", "middle", "bottom", "bottom", "bottom", "middle", "top", "top"];
      "top" === orient && (align = ["center", "right", "right", "right", "center", "left", "left", "left", "right"], baseline = ["bottom", "bottom", "middle", "top", "top", "top", "middle", "bottom", "bottom"]);
      const step = (angle = clampAngle(angle)) / (.5 * Math.PI);
      let index;
      return index = step === Math.floor(step) ? 2 * Math.floor(step) : 2 * Math.floor(step) + 1, {
        textAlign: align[index],
        textBaseline: baseline[index]
      };
    }
    function getYAxisLabelAlign(orient) {
      let angle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      let align = ["right", "right", "center", "left", "left", "left", "center", "right", "right"],
        baseline = ["middle", "middle", "top", "top", "middle", "middle", "bottom", "bottom", "middle"];
      "right" === orient && (align = ["left", "left", "center", "right", "right", "right", "center", "left", "left"], baseline = ["middle", "middle", "bottom", "bottom", "middle", "middle", "top", "middle", "middle"]);
      const step = (angle = clampAngle(angle)) / (.5 * Math.PI);
      let index;
      return index = step === Math.floor(step) ? 2 * Math.floor(step) : 2 * Math.floor(step) + 1, {
        textAlign: align[index],
        textBaseline: baseline[index]
      };
    }

    function normalizeOverflowLimitLength(overflowLimitLength) {
      return isValidNumber$3(overflowLimitLength) ? {
        left: overflowLimitLength,
        right: overflowLimitLength
      } : isObject$9(overflowLimitLength) ? {
        left: overflowLimitLength.left || 0,
        right: overflowLimitLength.right || 0
      } : {
        left: 0,
        right: 0
      };
    }
    function autoLimit(labels, config) {
      const {
        limitLength: limitLength,
        verticalLimitLength: verticalLimitLength,
        ellipsis = "...",
        orient: orient,
        axisLength: axisLength
      } = config;
      if (isEmpty$1(labels) || !isValidNumber$3(limitLength)) return;
      const overflowLimitLength = normalizeOverflowLimitLength(config.overflowLimitLength),
        firstLabel = labels[0],
        angle = firstLabel.attribute.angle,
        hasAngle = !isNil$5(angle),
        cos = hasAngle ? Math.cos(angle) : 1,
        sin = hasAngle ? Math.sin(angle) : 0,
        isHorizontal = isAngleHorizontal(angle),
        isVertical = isAngleVertical(angle),
        isX = "top" === orient || "bottom" === orient,
        direction = firstLabel.attribute.direction,
        checkBox = !isHorizontal && !isVertical && isX && (labels.length < 2 || labels.some(label => Math.abs(label.AABBBounds.width() - firstLabel.AABBBounds.width()) >= 2)) && firstLabel.AABBBounds.width() > Math.abs(limitLength / sin);
      labels.forEach(label => {
        var _a;
        if (isX) {
          if (isVertical && Math.floor(label.AABBBounds.height()) <= limitLength) return;
          if (isHorizontal && Math.floor(label.AABBBounds.width()) <= verticalLimitLength) return;
        }
        if (!isX) {
          if ("vertical" === direction && Math.floor(label.AABBBounds.height()) <= verticalLimitLength) return;
          if ("vertical" !== direction) {
            if (isHorizontal && Math.floor(label.AABBBounds.width()) <= limitLength) return;
            if (isVertical && Math.floor(label.AABBBounds.height()) <= verticalLimitLength) return;
          }
        }
        let limitLabelLength = null;
        if (isHorizontal || isVertical) limitLabelLength = isX ? isHorizontal ? verticalLimitLength : limitLength : "vertical" === direction || isVertical ? verticalLimitLength : limitLength;else if (isX) {
          const {
              x1: x1,
              x2: x2
            } = label.AABBBounds,
            tan = sin / cos,
            verticalSizeLimit = Math.abs(limitLength / sin);
          if (checkBox && tan > 0 && x1 <= axisLength + overflowLimitLength.right && limitLength / tan + x1 > axisLength + overflowLimitLength.right) {
            const lengthLimit = (axisLength - x1 + overflowLimitLength.right) / Math.abs(cos);
            limitLabelLength = Math.min(lengthLimit, verticalSizeLimit);
          } else if (checkBox && tan < 0 && x2 >= -overflowLimitLength.left && limitLength / tan + x2 < -overflowLimitLength.left) {
            const lengthLimit = (x2 + overflowLimitLength.left) / Math.abs(cos);
            limitLabelLength = Math.min(lengthLimit, verticalSizeLimit);
          } else limitLabelLength = verticalSizeLimit;
        } else limitLabelLength = Math.abs(limitLength / cos);
        isValidNumber$3(label.attribute.maxLineWidth) && (limitLabelLength = isValidNumber$3(limitLabelLength) ? Math.min(label.attribute.maxLineWidth, limitLabelLength) : label.attribute.maxLineWidth), label.setAttributes({
          maxLineWidth: limitLabelLength,
          ellipsis: null !== (_a = label.attribute.ellipsis) && void 0 !== _a ? _a : ellipsis
        });
      });
    }

    function autoWrap(labels, config) {
      const {
        limitLength: limitLength,
        axisLength: axisLength,
        ellipsis = "...",
        orient: orient
      } = config;
      if (isEmpty$1(labels) || !isValidNumber$3(limitLength)) return;
      const angle = labels[0].attribute.angle,
        isHorizontal = isAngleHorizontal(angle),
        isVertical = isAngleVertical(angle),
        isX = "top" === orient || "bottom" === orient;
      let verticalLimitLength = axisLength / labels.length;
      labels.forEach((label, index) => {
        var _a, _b, _c, _d, _e;
        if (isX) {
          if (isVertical && Math.floor(label.AABBBounds.height()) <= limitLength) return;
          if (isHorizontal) {
            const minGap = getLabelMinGap(label.attribute.x, null === (_a = labels[index + 1]) || void 0 === _a ? void 0 : _a.attribute.x, null === (_b = labels[index - 1]) || void 0 === _b ? void 0 : _b.attribute.x);
            isValidNumber$3(minGap) && (verticalLimitLength = min(verticalLimitLength, minGap));
          }
        } else {
          if (isVertical) {
            const minGap = getLabelMinGap(label.attribute.y, null === (_c = labels[index + 1]) || void 0 === _c ? void 0 : _c.attribute.y, null === (_d = labels[index - 1]) || void 0 === _d ? void 0 : _d.attribute.y);
            isValidNumber$3(minGap) && (verticalLimitLength = min(verticalLimitLength, minGap));
          }
          if (isHorizontal && Math.floor(label.AABBBounds.width()) <= limitLength) return;
        }
        let limitLabelLength = null,
          heightLimit = null;
        isX ? isVertical ? (limitLabelLength = limitLength, heightLimit = verticalLimitLength) : (limitLabelLength = verticalLimitLength, heightLimit = limitLength) : isVertical ? (limitLabelLength = verticalLimitLength, heightLimit = limitLength) : (limitLabelLength = limitLength, heightLimit = verticalLimitLength), label.setAttributes({
          maxLineWidth: limitLabelLength,
          ellipsis: null !== (_e = label.attribute.ellipsis) && void 0 !== _e ? _e : ellipsis,
          whiteSpace: "normal",
          heightLimit: heightLimit
        });
      });
    }
    function getLabelMinGap(current, next, prev) {
      let minGap;
      return isValidNumber$3(next) && (minGap = Math.abs(next - current)), isValidNumber$3(prev) && (minGap = isValidNumber$3(minGap) ? Math.min(Math.abs(current - prev), minGap) : Math.abs(current - prev)), minGap;
    }

    function alignAxisLabels(labels, start, containerSize, orient, align) {
      "left" === orient || "right" === orient ? "left" === align ? labels.forEach(label => {
        var _a;
        label.setAttributes({
          dx: (null !== (_a = label.attribute.dx) && void 0 !== _a ? _a : 0) + start - label.AABBBounds.x1
        });
      }) : "right" === align ? labels.forEach(label => {
        var _a;
        label.setAttributes({
          dx: (null !== (_a = label.attribute.dx) && void 0 !== _a ? _a : 0) + start + containerSize - label.AABBBounds.x2
        });
      }) : "center" === align && labels.forEach(label => {
        var _a;
        label.setAttributes({
          dx: (null !== (_a = label.attribute.dx) && void 0 !== _a ? _a : 0) + start + containerSize / 2 - (label.AABBBounds.x1 + label.AABBBounds.x2) / 2
        });
      }) : "bottom" !== orient && "top" !== orient || ("top" === align ? labels.forEach(label => {
        var _a;
        label.setAttributes({
          dy: (null !== (_a = label.attribute.dy) && void 0 !== _a ? _a : 0) + start - label.AABBBounds.y1
        });
      }) : "bottom" === align ? labels.forEach(label => {
        var _a;
        label.setAttributes({
          dy: (null !== (_a = label.attribute.dy) && void 0 !== _a ? _a : 0) + start + containerSize - label.AABBBounds.y2
        });
      }) : "middle" === align && labels.forEach(label => {
        var _a;
        label.setAttributes({
          dy: (null !== (_a = label.attribute.dy) && void 0 !== _a ? _a : 0) + start + containerSize / 2 - (label.AABBBounds.y1 + label.AABBBounds.y2) / 2
        });
      }));
    }

    class LineAxisMixin {
      isInValidValue(value) {
        return value < 0 || value > 1;
      }
      getTickCoord(tickValue) {
        const {
            start: start
          } = this.attribute,
          axisVector = this.getRelativeVector();
        return {
          x: start.x + axisVector[0] * tickValue,
          y: start.y + axisVector[1] * tickValue
        };
      }
      getRelativeVector(point) {
        const {
          start: start,
          end: end
        } = this.attribute;
        return [end.x - start.x, end.y - start.y];
      }
      getVerticalVector(offset) {
        let inside = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
        const {
            verticalFactor = 1
          } = this.attribute,
          axisVector = this.getRelativeVector(),
          normalizedAxisVector = normalize$2(axisVector),
          verticalVector = [normalizedAxisVector[1], -1 * normalizedAxisVector[0]];
        return scale(verticalVector, offset * (inside ? 1 : -1) * verticalFactor);
      }
    }

    function loadBasicAxis() {
      registerGroup(), registerLine(), registerRichtext(), registerText();
    }
    function loadLineAxisComponent() {
      loadBasicAxis(), registerRect();
    }

    var __rest$1 = undefined && undefined.__rest || function (s, e) {
      var t = {};
      for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0 && (t[p] = s[p]);
      if (null != s && "function" == typeof Object.getOwnPropertySymbols) {
        var i = 0;
        for (p = Object.getOwnPropertySymbols(s); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t[p[i]] = s[p[i]]);
      }
      return t;
    };
    loadLineAxisComponent();
    class LineAxis extends AxisBase {
      constructor(attributes, options) {
        super((null == options ? void 0 : options.skipDefault) ? attributes : merge$2({}, LineAxis.defaultAttributes, attributes), options);
      }
      _renderInner(container) {
        var _a;
        if (this._breaks = null, this.attribute.breaks && this.attribute.breaks.length) {
          const transformedBreaks = [];
          for (let index = 0; index < this.attribute.breaks.length; index++) {
            const aBreak = this.attribute.breaks[index],
              {
                range: range,
                breakSymbol: breakSymbol,
                rawRange: rawRange
              } = aBreak;
            transformedBreaks.push({
              startPoint: this.getTickCoord(range[0]),
              endPoint: this.getTickCoord(range[1]),
              range: range,
              breakSymbol: breakSymbol,
              rawRange: rawRange
            });
          }
          this._breaks = transformedBreaks;
        }
        super._renderInner(container), this._breaks && this._breaks.length && this._breaks.forEach((b, index) => {
          const {
            startPoint: startPoint,
            endPoint: endPoint,
            breakSymbol: breakSymbol,
            rawRange: rawRange
          } = b;
          if (!1 !== (null == breakSymbol ? void 0 : breakSymbol.visible)) {
            const axisBreakGroup = graphicCreator.group({
              zIndex: TopZIndex
            });
            axisBreakGroup.name = AXIS_ELEMENT_NAME.axisBreak, axisBreakGroup.id = this._getNodeId(`${AXIS_ELEMENT_NAME.axisBreak}-${index}`), axisBreakGroup.data = rawRange;
            const symbolStyle = getAxisBreakSymbolAttrs(breakSymbol),
              shape1 = graphicCreator.symbol(Object.assign({
                x: startPoint.x,
                y: startPoint.y
              }, symbolStyle));
            shape1.name = AXIS_ELEMENT_NAME.axisBreakSymbol;
            const shape2 = graphicCreator.symbol(Object.assign({
              x: endPoint.x,
              y: endPoint.y
            }, symbolStyle));
            shape2.name = AXIS_ELEMENT_NAME.axisBreakSymbol, axisBreakGroup.add(shape1), axisBreakGroup.add(shape2), container.add(axisBreakGroup);
          }
        });
        const {
          panel: panel
        } = this.attribute;
        if (panel && panel.visible) {
          const axisContainer = this.axisContainer,
            axisContainerBounds = axisContainer.AABBBounds,
            bgRect = graphicCreator.rect(Object.assign({
              x: axisContainerBounds.x1,
              y: axisContainerBounds.y1,
              width: axisContainerBounds.width(),
              height: axisContainerBounds.height()
            }, panel.style));
          bgRect.name = AXIS_ELEMENT_NAME.background, bgRect.id = this._getNodeId("background"), bgRect.states = merge$2({}, DEFAULT_STATES$1, null !== (_a = panel.state) && void 0 !== _a ? _a : {}), axisContainer.insertBefore(bgRect, axisContainer.firstChild);
        }
      }
      renderLine(container) {
        const {
            start: start,
            end: end,
            line: line
          } = this.attribute,
          _a = line,
          {
            startSymbol: startSymbol,
            endSymbol: endSymbol,
            style: style,
            state: state
          } = _a,
          restLineAttrs = __rest$1(_a, ["startSymbol", "endSymbol", "style", "state"]),
          lineAttrs = Object.assign({
            startSymbol: startSymbol,
            endSymbol: endSymbol,
            lineStyle: style
          }, restLineAttrs);
        if (this._breaks && this._breaks.length) {
          const linePoints = [];
          let lastStartPoint = start;
          this._breaks.forEach(b => {
            const {
              startPoint: startPoint,
              endPoint: endPoint
            } = b;
            linePoints.push([lastStartPoint, startPoint]), lastStartPoint = endPoint;
          }), linePoints.push([lastStartPoint, end]), lineAttrs.points = linePoints, lineAttrs.multiSegment = !0;
        } else lineAttrs.points = [start, end];
        isEmpty$1(state) || (lineAttrs.state = {
          line: merge$2({}, DEFAULT_STATES$1, state),
          symbol: merge$2({}, DEFAULT_STATES$1, state)
        });
        const axisLineGroup = new Segment(lineAttrs);
        axisLineGroup.name = AXIS_ELEMENT_NAME.line, axisLineGroup.id = this._getNodeId("line"), container.add(axisLineGroup);
      }
      getTextAlign(vector) {
        let align = "center";
        return isNumberClose$1(vector[0], 0) ? isNumberClose$1(vector[1], 0) ? Object.is(vector[1], -0) ? align = "start" : Object.is(vector[0], -0) && (align = "end") : align = "center" : vector[0] > 0 ? align = "start" : vector[0] < 0 && (align = "end"), align;
      }
      getTitleAttribute() {
        var _a, _b, _c;
        const _d = this.attribute.title,
          {
            position = "middle",
            space = 4,
            textStyle = {},
            autoRotate = !0,
            shape: shape,
            background: background,
            state = {},
            maxWidth: maxWidth
          } = _d,
          restAttrs = __rest$1(_d, ["position", "space", "textStyle", "autoRotate", "shape", "background", "state", "maxWidth"]);
        let percent = .5;
        "start" === position ? percent = 0 : "end" === position && (percent = 1);
        const {
            verticalFactor = 1
          } = this.attribute,
          factor = -1 * verticalFactor,
          point = this.getTickCoord(percent),
          axisVector = this.getRelativeVector();
        let labelLength = 0;
        if ((null === (_a = this.attribute.label) || void 0 === _a ? void 0 : _a.visible) && !1 === this.attribute.label.inside) {
          const space = +get$9(this.attribute, "label.space", 4);
          labelLength += space;
          const layerCount = Object.keys(this.axisLabelLayerSize).length;
          if (0 === axisVector[1]) {
            const labelBoundsHeight = this.axisLabelsContainer ? this.axisLabelsContainer.AABBBounds.height() : 0;
            isFinite(labelBoundsHeight) ? labelLength += labelBoundsHeight + (layerCount - 1) * space : labelLength = 0;
          } else if (0 === axisVector[0]) {
            if (this.axisLabelsContainer && this.axisLabelsContainer.AABBBounds && !this.axisLabelsContainer.AABBBounds.empty()) {
              const baseX = this.axisLabelLayerSize[0].labelPos,
                bounds = this.axisLabelsContainer.AABBBounds;
              labelLength += (1 === factor ? bounds.x2 > baseX ? Math.min(bounds.x2 - baseX, bounds.width()) : 0 : bounds.x1 < baseX ? Math.min(baseX - bounds.x1, bounds.width()) : 0) + (layerCount - 1) * space;
            } else labelLength = 0;
          } else Object.keys(this.axisLabelLayerSize).forEach((layer, index) => {
            labelLength += this.axisLabelLayerSize[layer].width + (index > 0 ? space : 0);
          });
        }
        let tickLength = 0;
        (null === (_b = this.attribute.tick) || void 0 === _b ? void 0 : _b.visible) && !1 === this.attribute.tick.inside && (tickLength = this.attribute.tick.length || 4), (null === (_c = this.attribute.subTick) || void 0 === _c ? void 0 : _c.visible) && !1 === this.attribute.subTick.inside && (tickLength = Math.max(tickLength, this.attribute.subTick.length || 2));
        const offset = tickLength + labelLength + space,
          titlePoint = this.getVerticalCoord(point, offset, !1),
          vector = this.getVerticalVector(offset, !1, {
            x: 0,
            y: 0
          });
        let textAlign,
          textBaseline,
          {
            angle: angle
          } = restAttrs;
        if (textAlign = "start" === position ? "start" : "end" === position ? "end" : "center", isNil$5(angle) && autoRotate) {
          angle = angleTo(axisVector, [1, 0], !0);
          const {
            verticalFactor = 1
          } = this.attribute;
          textBaseline = 1 === -1 * verticalFactor ? "bottom" : "top";
        } else textAlign = this.getTextAlign(vector), textBaseline = this.getTextBaseline(vector, !1);
        let maxTagWidth = maxWidth;
        if (isNil$5(maxTagWidth)) {
          const {
              verticalLimitSize: verticalLimitSize,
              verticalMinSize: verticalMinSize,
              orient: orient
            } = this.attribute,
            limitSize = Math.min(verticalLimitSize || 1 / 0, verticalMinSize || 1 / 0);
          if (isValidNumber$3(limitSize)) {
            if ("bottom" === orient || "top" === orient) {
              if (angle !== Math.PI / 2) {
                const cosValue = Math.abs(Math.cos(null != angle ? angle : 0));
                maxTagWidth = cosValue < 1e-6 ? 1 / 0 : this.attribute.end.x / cosValue;
              } else maxTagWidth = limitSize - offset;
            } else if (angle && 0 !== angle) {
              const sinValue = Math.abs(Math.sin(angle));
              maxTagWidth = sinValue < 1e-6 ? 1 / 0 : this.attribute.end.y / sinValue;
            } else maxTagWidth = limitSize - offset;
          }
        }
        const attrs = Object.assign(Object.assign(Object.assign({}, titlePoint), restAttrs), {
          maxWidth: maxTagWidth,
          textStyle: Object.assign({
            textAlign: textAlign,
            textBaseline: textBaseline
          }, textStyle),
          state: {
            text: merge$2({}, DEFAULT_STATES$1, state.text),
            shape: merge$2({}, DEFAULT_STATES$1, state.shape),
            panel: merge$2({}, DEFAULT_STATES$1, state.background)
          }
        });
        return attrs.angle = angle, shape && shape.visible && (attrs.shape = Object.assign({
          visible: !0
        }, shape.style), shape.space && (attrs.space = shape.space)), background && background.visible && (attrs.panel = Object.assign({
          visible: !0
        }, background.style)), attrs;
      }
      getTextBaseline(vector, inside) {
        let base = "middle";
        const {
            verticalFactor = 1
          } = this.attribute,
          factor = (inside ? 1 : -1) * verticalFactor;
        return isNumberClose$1(vector[1], 0) ? base = !isNumberClose$1(vector[0], 0) || Object.is(vector[0], -0) || Object.is(vector[1], -0) ? "middle" : 1 === factor ? "bottom" : "top" : vector[1] > 0 ? base = "top" : vector[1] < 0 && (base = "bottom"), base;
      }
      getLabelAlign(vector, inside, angle) {
        const orient = this.attribute.orient;
        if (["top", "bottom", "right", "left"].includes(orient) || 0 === vector[0] && 0 === vector[1]) {
          if ("top" === orient || "bottom" === orient) return getXAxisLabelAlign(inside ? "bottom" === orient ? "top" : "bottom" : orient, angle);
          if ("left" === orient || "right" === orient) return getYAxisLabelAlign(inside ? "left" === orient ? "right" : "left" : orient, angle);
        }
        return {
          textAlign: this.getTextAlign(vector),
          textBaseline: this.getTextBaseline(vector, inside)
        };
      }
      beforeLabelsOverlap(labelShapes, labelData, labelContainer, layer, layerCount) {
        var _a, _b, _c, _d;
        const {
          flush = !1
        } = this.attribute.label || {};
        if (flush && labelShapes.length) {
          const {
              orient: orient,
              start: axisStart,
              end: axisEnd
            } = this.attribute,
            isX = "bottom" === orient || "top" === orient,
            first = labelShapes[0],
            last = last$1(labelShapes),
            isInverse = isX ? first.attribute.x > last.attribute.x : first.attribute.y < last.attribute.y;
          if (isX) {
            const leftMostLabel = isInverse ? last : first,
              rightMostLabel = isInverse ? first : last,
              left = axisStart.x,
              right = axisEnd.x,
              leftBound = leftMostLabel.AABBBounds.x1,
              rightBound = rightMostLabel.AABBBounds.x2;
            if (leftBound < left) {
              leftMostLabel.attribute.angle ? leftMostLabel.setAttributes({
                dx: (null !== (_a = leftMostLabel.attribute.dx) && void 0 !== _a ? _a : 0) + left - leftBound
              }) : leftMostLabel.setAttributes({
                x: left,
                textAlign: "left"
              });
            }
            if (rightBound > right) {
              rightMostLabel.attribute.angle ? rightMostLabel.setAttributes({
                dx: (null !== (_b = rightMostLabel.attribute.dx) && void 0 !== _b ? _b : 0) + right - rightBound
              }) : rightMostLabel.setAttributes({
                x: right,
                textAlign: "right"
              });
            }
          } else {
            const bottomMostLabel = isInverse ? last : first,
              topMostLabel = isInverse ? first : last,
              bottomBound = bottomMostLabel.AABBBounds.y2,
              topBound = topMostLabel.AABBBounds.y1,
              top = axisStart.y,
              bottom = axisEnd.y;
            if (topBound < top) {
              topMostLabel.attribute.angle ? topMostLabel.setAttributes({
                dy: (null !== (_c = topMostLabel.attribute.dy) && void 0 !== _c ? _c : 0) + top - topBound
              }) : topMostLabel.setAttributes({
                y: top,
                textBaseline: "top"
              });
            }
            if (bottomBound > bottom) {
              bottomMostLabel.attribute.angle ? bottomMostLabel.setAttributes({
                dy: (null !== (_d = bottomMostLabel.attribute.dy) && void 0 !== _d ? _d : 0) + bottom - bottomBound
              }) : bottomMostLabel.setAttributes({
                y: bottom,
                textBaseline: "bottom"
              });
            }
          }
        }
      }
      handleLabelsOverlap(labelShapes, labelData, labelContainer, layer, layerCount) {
        if (isEmpty$1(labelShapes)) return;
        const {
            verticalLimitSize: verticalLimitSize,
            label: label,
            orient: orient
          } = this.attribute,
          limitLength = this._getAxisLabelLimitLength(verticalLimitSize, layerCount),
          {
            layoutFunc: layoutFunc,
            autoRotate: autoRotate$1,
            autoRotateAngle: autoRotateAngle,
            autoLimit: autoLimit$1,
            limitEllipsis: limitEllipsis,
            autoHide: autoHide$1,
            autoHideMethod: autoHideMethod,
            autoHideSeparation: autoHideSeparation,
            lastVisible: lastVisible,
            firstVisible: firstVisible,
            autoWrap: autoWrap$1,
            overflowLimitLength: overflowLimitLength
          } = label;
        if (isFunction$7(layoutFunc)) layoutFunc(labelShapes, labelData, layer, this);else {
          if (autoRotate$1) autoRotate(labelShapes, {
            labelRotateAngle: autoRotateAngle,
            orient: orient
          });else if (autoWrap$1) {
            const axisLength = "left" === orient || "right" === orient ? Math.abs(this.attribute.start.y - this.attribute.end.y) : Math.abs(this.attribute.start.x - this.attribute.end.x);
            autoWrap(labelShapes, {
              orient: orient,
              limitLength: limitLength,
              axisLength: axisLength,
              ellipsis: limitEllipsis
            });
          }
          if (!autoWrap$1 && autoLimit$1 && isValidNumber$3(limitLength) && limitLength > 0) {
            const isVertical = "left" === orient || "right" === orient,
              axisLength = isVertical ? Math.abs(this.attribute.start.y - this.attribute.end.y) : Math.abs(this.attribute.start.x - this.attribute.end.x),
              verticalLimitLength = isVertical ? axisLength / labelShapes.length : autoHide$1 || autoRotate$1 ? 1 / 0 : axisLength / labelShapes.length;
            autoLimit(labelShapes, {
              limitLength: limitLength,
              verticalLimitLength: verticalLimitLength,
              ellipsis: limitEllipsis,
              orient: orient,
              axisLength: axisLength,
              overflowLimitLength: overflowLimitLength
            });
          }
          autoHide$1 && autoHide(labelShapes, {
            orient: orient,
            method: autoHideMethod,
            separation: autoHideSeparation,
            lastVisible: lastVisible,
            firstVisible: firstVisible
          });
        }
      }
      afterLabelsOverlap(labelShapes, labelData, labelContainer, layer, layerCount) {
        const {
            verticalLimitSize: verticalLimitSize,
            orient: orient
          } = this.attribute,
          isHorizontal = "bottom" === orient || "top" === orient,
          axisLabelContainerBounds = labelContainer.AABBBounds;
        let axisLabelContainerSize = isHorizontal ? axisLabelContainerBounds.height() : axisLabelContainerBounds.width();
        const {
          verticalMinSize: verticalMinSize
        } = this.attribute;
        if (isValidNumber$3(verticalMinSize) && (!isValidNumber$3(verticalLimitSize) || verticalMinSize <= verticalLimitSize)) {
          const minSize = this._getAxisLabelLimitLength(verticalMinSize, layerCount);
          let x, y;
          axisLabelContainerSize = Math.max(axisLabelContainerSize, minSize), "left" === orient ? (x = axisLabelContainerBounds.x2 - axisLabelContainerSize, y = axisLabelContainerBounds.y1) : "right" === orient ? (x = axisLabelContainerBounds.x1, y = axisLabelContainerBounds.y1) : "top" === orient ? (x = axisLabelContainerBounds.x1, y = axisLabelContainerBounds.y2 - axisLabelContainerSize) : "bottom" === orient && (x = axisLabelContainerBounds.x1, y = axisLabelContainerBounds.y1);
          const bgRect = graphicCreator.rect({
            x: x,
            y: y,
            width: isHorizontal ? axisLabelContainerBounds.width() : axisLabelContainerSize,
            height: isHorizontal ? axisLabelContainerSize : axisLabelContainerBounds.height(),
            pickable: !1
          });
          bgRect.name = AXIS_ELEMENT_NAME.axisLabelBackground, bgRect.id = this._getNodeId("axis-label-background"), labelContainer.insertBefore(bgRect, labelContainer.firstChild);
        }
        if (isValid$5(this.attribute.label.containerAlign)) {
          let start;
          "left" === orient ? start = axisLabelContainerBounds.x2 - axisLabelContainerSize : "right" === orient ? start = axisLabelContainerBounds.x1 : "top" === orient ? start = axisLabelContainerBounds.y2 - axisLabelContainerSize : "bottom" === orient && (start = axisLabelContainerBounds.y1), alignAxisLabels(labelShapes, start, axisLabelContainerSize, orient, this.attribute.label.containerAlign);
        }
      }
      _getAxisLabelLimitLength(limitSize, layerCount) {
        var _a, _b, _c, _d, _e;
        const {
            label: label,
            title: title,
            line: line,
            tick: tick
          } = this.attribute,
          labelSpace = null !== (_a = label.space) && void 0 !== _a ? _a : 4;
        let limitLength = limitSize,
          titleHeight = 0,
          titleSpacing = 0;
        const axisLineWidth = line && line.visible ? null !== (_b = line.style.lineWidth) && void 0 !== _b ? _b : 1 : 0,
          tickLength = tick && tick.visible ? null !== (_c = tick.length) && void 0 !== _c ? _c : 4 : 0;
        if (title && title.visible && "string" == typeof title.text) {
          titleHeight = measureTextSize(title.text, title.textStyle, null === (_e = null === (_d = this.stage) || void 0 === _d ? void 0 : _d.getTheme()) || void 0 === _e ? void 0 : _e.text).height;
          const padding = normalizePadding(title.padding);
          titleSpacing = title.space + padding[0] + padding[2];
        }
        return limitLength && (limitLength = (limitLength - labelSpace - titleSpacing - titleHeight - axisLineWidth - tickLength) / layerCount), limitLength;
      }
      release() {
        super.release(), this._breaks = null;
      }
    }
    LineAxis.defaultAttributes = DEFAULT_AXIS_THEME, mixin$1(LineAxis, LineAxisMixin);

    const convertDomainToTickData = domain => domain.map((t, index) => ({
      index: index,
      value: t
    }));
    const labelOverlap = function (prevLabel, nextLabel) {
      let gap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      const prevBounds = new AABBBounds$1(prevLabel).expand(gap / 2),
        nextBounds = new AABBBounds$1(nextLabel).expand(gap / 2);
      return prevBounds.intersects(nextBounds);
    };
    const MIN_TICK_GAP = 12;
    const calculateFlushPos = (basePosition, size, rangePosition, otherEnd) => rangePosition < basePosition ? Math.max(basePosition - size / 2, rangePosition) : rangePosition > basePosition ? Math.min(basePosition - size / 2, rangePosition - size) : rangePosition < otherEnd ? rangePosition : rangePosition - size;
    const getCartesianLabelBounds = (scale, domain, op) => {
      var _a;
      const {
        labelStyle: labelStyle,
        axisOrientType: axisOrientType,
        labelFlush: labelFlush,
        labelFormatter: labelFormatter,
        startAngle = 0
      } = op;
      let labelAngle = null !== (_a = labelStyle.angle) && void 0 !== _a ? _a : 0;
      "vertical" === labelStyle.direction && (labelAngle += degreeToRadian$1(90));
      const isHorizontal = ["bottom", "top"].includes(axisOrientType),
        isVertical = ["left", "right"].includes(axisOrientType);
      let scaleX = 1,
        scaleY = 0;
      isHorizontal || (isVertical ? (scaleX = 0, scaleY = 1) : startAngle && (scaleX = Math.cos(startAngle), scaleY = -Math.sin(startAngle)));
      const textMeasure = initTextMeasure$1(labelStyle),
        range = scale.range(),
        labelBoundsList = domain.map((v, i) => {
          var _a, _b;
          const str = labelFormatter ? labelFormatter(v) : `${v}`,
            {
              width: width,
              height: height
            } = textMeasure.quickMeasure(str),
            textWidth = Math.max(width, 12),
            textHeight = Math.max(height, 12),
            pos = scale.scale(v),
            baseTextX = scaleX * pos,
            baseTextY = scaleY * pos;
          let align,
            baseline,
            textX = baseTextX,
            textY = baseTextY;
          labelFlush && isHorizontal && 0 === i ? textX = calculateFlushPos(baseTextX, textWidth, range[0], range[range.length - 1]) : labelFlush && isHorizontal && i === domain.length - 1 ? textX = calculateFlushPos(baseTextX, textWidth, range[range.length - 1], range[0]) : align = null !== (_a = labelStyle.textAlign) && void 0 !== _a ? _a : "center", "right" === align ? textX -= textWidth : "center" === align && (textX -= textWidth / 2), labelFlush && isVertical && 0 === i ? textY = calculateFlushPos(baseTextY, textHeight, range[0], range[range.length - 1]) : labelFlush && isVertical && i === domain.length - 1 ? textY = calculateFlushPos(baseTextY, textHeight, range[range.length - 1], range[0]) : baseline = null !== (_b = labelStyle.textBaseline) && void 0 !== _b ? _b : "middle", "bottom" === baseline ? textY -= textHeight : "middle" === baseline && (textY -= textHeight / 2);
          const bounds = new AABBBounds$1().set(textX, textY, textX + textWidth, textY + textHeight);
          return labelAngle && bounds.rotate(labelAngle, baseTextX, baseTextY), bounds;
        });
      return labelBoundsList;
    };
    const isAxisHorizontal = axisOrientType => ["bottom", "top", "z"].includes(axisOrientType);

    var ScaleEnum$1;
    !function (ScaleEnum) {
      ScaleEnum.Identity = "identity", ScaleEnum.Linear = "linear", ScaleEnum.Log = "log", ScaleEnum.Pow = "pow", ScaleEnum.Sqrt = "sqrt", ScaleEnum.Symlog = "symlog", ScaleEnum.Time = "time", ScaleEnum.Quantile = "quantile", ScaleEnum.Quantize = "quantize", ScaleEnum.Threshold = "threshold", ScaleEnum.Ordinal = "ordinal", ScaleEnum.Point = "point", ScaleEnum.Band = "band";
    }(ScaleEnum$1 || (ScaleEnum$1 = {}));
    Object.values(ScaleEnum$1).forEach(v => {
    });
    function isContinuous(type) {
      switch (type) {
        case ScaleEnum$1.Linear:
        case ScaleEnum$1.Log:
        case ScaleEnum$1.Pow:
        case ScaleEnum$1.Sqrt:
        case ScaleEnum$1.Symlog:
        case ScaleEnum$1.Time:
          return !0;
        default:
          return !1;
      }
    }
    function isDiscrete(type) {
      switch (type) {
        case ScaleEnum$1.Ordinal:
        case ScaleEnum$1.Point:
        case ScaleEnum$1.Band:
          return !0;
        default:
          return !1;
      }
    }

    function identity$1(x) {
      return x;
    }
    function normalize$1(a, b) {
      if (a = Number(a), b = Number(b), b -= a) return x => (x - a) / b;
      const result = Number.isNaN(b) ? NaN : .5;
      return () => result;
    }
    function bimap$1(domain, range, interpolate) {
      const d0 = domain[0],
        d1 = domain[1],
        r0 = range[0],
        r1 = range[1];
      let d0Fuc, r0Fuc;
      return d1 < d0 ? (d0Fuc = normalize$1(d1, d0), r0Fuc = interpolate(r1, r0)) : (d0Fuc = normalize$1(d0, d1), r0Fuc = interpolate(r0, r1)), x => r0Fuc(d0Fuc(x));
    }
    function calculateWholeRangeFromRangeFactor$1(range, rangeFactor) {
      const k = (range[1] - range[0]) / (rangeFactor[1] - rangeFactor[0]),
        b = range[0] - k * rangeFactor[0];
      return [b, k + b];
    }
    function polymap$1(domain, range, interpolate) {
      const j = Math.min(domain.length, range.length) - 1,
        d = new Array(j),
        r = new Array(j);
      let i = -1;
      for (domain[j] < domain[0] && (domain = domain.slice().reverse(), range = range.slice().reverse()); ++i < j;) d[i] = normalize$1(domain[i], domain[i + 1]), r[i] = interpolate(range[i], range[i + 1]);
      return function (x) {
        const i = bisect$1(domain, x, 1, j) - 1;
        return r[i](d[i](x));
      };
    }

    let BaseScale$1 = class BaseScale {
      constructor() {
        this._rangeFactorStart = null, this._rangeFactorEnd = null;
      }
      _calculateWholeRange(range) {
        return this._wholeRange ? this._wholeRange : isValid$5(this._rangeFactorStart) && isValid$5(this._rangeFactorEnd) && 2 === range.length ? (this._wholeRange = calculateWholeRangeFromRangeFactor$1(range, [this._rangeFactorStart, this._rangeFactorEnd]), this._wholeRange) : range;
      }
      rangeFactor(_, slience, clear) {
        return _ ? (2 === _.length && _.every(r => r >= 0 && r <= 1) && (this._wholeRange = null, 0 === _[0] && 1 === _[1] ? (this._rangeFactorStart = null, this._rangeFactorEnd = null) : (this._rangeFactorStart = _[0], this._rangeFactorEnd = _[1])), this) : clear ? (this._wholeRange = null, this._rangeFactorStart = null, this._rangeFactorEnd = null, this) : isValid$5(this._rangeFactorStart) && isValid$5(this._rangeFactorEnd) ? [this._rangeFactorStart, this._rangeFactorEnd] : null;
      }
      rangeFactorStart(_, slience) {
        var _a;
        return isNil$5(_) ? this._rangeFactorStart : (_ >= 0 && _ <= 1 && (this._wholeRange = null, 0 !== _ || !isNil$5(this._rangeFactorEnd) && 1 !== this._rangeFactorEnd ? (this._rangeFactorStart = _, this._rangeFactorEnd = null !== (_a = this._rangeFactorEnd) && void 0 !== _a ? _a : 1) : (this._rangeFactorStart = null, this._rangeFactorEnd = null)), this);
      }
      rangeFactorEnd(_, slience) {
        var _a;
        return isNil$5(_) ? this._rangeFactorEnd : (_ >= 0 && _ <= 1 && (this._wholeRange = null, 0 !== _ || !isNil$5(this._rangeFactorStart) && 0 !== this._rangeFactorStart ? (this._rangeFactorEnd = _, this._rangeFactorStart = null !== (_a = this._rangeFactorStart) && void 0 !== _a ? _a : 0) : (this._rangeFactorStart = null, this._rangeFactorEnd = null)), this);
      }
      generateFishEyeTransform() {
        var _a;
        if (!this._fishEyeOptions) return void (this._fishEyeTransform = null);
        const {
            distortion = 2,
            radiusRatio = .1,
            radius: radius
          } = this._fishEyeOptions,
          range = this.range(),
          first = range[0],
          last = range[range.length - 1],
          min = Math.min(first, last),
          max = Math.max(first, last),
          focus = clamp$3(null !== (_a = this._fishEyeOptions.focus) && void 0 !== _a ? _a : 0, min, max),
          rangeRadius = isNil$5(radius) ? (max - min) * radiusRatio : radius;
        let k0 = Math.exp(distortion);
        k0 = k0 / (k0 - 1) * rangeRadius;
        const k1 = distortion / rangeRadius;
        this._fishEyeTransform = output => {
          const delta = Math.abs(output - focus);
          if (delta >= rangeRadius) return output;
          if (delta <= 1e-6) return focus;
          const k = k0 * (1 - Math.exp(-delta * k1)) / delta * .75 + .25;
          return focus + (output - focus) * k;
        };
      }
      unknown(_) {
        return arguments.length ? (this._unknown = _, this) : this._unknown;
      }
      get(key, defaultValue) {
        var _a;
        return null !== (_a = null == this ? void 0 : this[key]) && void 0 !== _a ? _a : defaultValue;
      }
    };

    const {
      interpolateRgb: interpolateRgb$2
    } = ColorUtil$1;
    function interpolate$1(a, b) {
      const t = typeof b;
      let c;
      if (isNil$5(b) || "boolean" === t) return () => b;
      if ("number" === t) return interpolateNumber$1(a, b);
      if ("string" === t) {
        if (c = Color$1.parseColorString(b)) {
          const rgb = interpolateRgb$2(Color$1.parseColorString(a), c);
          return t => rgb(t).formatRgb();
        }
        return interpolateNumber$1(Number(a), Number(b));
      }
      return b instanceof RGB$1 ? interpolateRgb$2(a, b) : b instanceof Color$1 ? interpolateRgb$2(a.color, b.color) : b instanceof Date ? interpolateDate$1(a, b) : interpolateNumber$1(Number(a), Number(b));
    }

    let ContinuousScale$1 = class ContinuousScale extends BaseScale$1 {
      constructor() {
        let transformer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : identity$1;
        let untransformer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity$1;
        super(), this._unknown = void 0, this.transformer = transformer, this.untransformer = untransformer, this._forceAlign = !0, this._domain = [0, 1], this._range = [0, 1], this._clamp = identity$1, this._piecewise = bimap$1, this._interpolate = interpolate$1;
      }
      calculateVisibleDomain(range) {
        var _a;
        if (isValid$5(this._rangeFactorStart) && isValid$5(this._rangeFactorEnd) && 2 === range.length) {
          return [this.invert(range[0]), this.invert(range[1])];
        }
        return null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain;
      }
      fishEye(options, slience, clear) {
        return options || clear ? (this._fishEyeOptions = options, this._fishEyeTransform = null, this.rescale(slience)) : this._fishEyeOptions;
      }
      scale(x) {
        var _a;
        if (x = Number(x), Number.isNaN(x) || this._domainValidator && !this._domainValidator(x)) return this._unknown;
        this._output || (this._output = this._piecewise((null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain).map(this.transformer), this._calculateWholeRange(this._range), this._interpolate));
        const output = this._output(this.transformer(this._clamp(x)));
        return this._fishEyeTransform ? this._fishEyeTransform(output) : output;
      }
      invert(y) {
        var _a;
        return this._input || (this._input = this._piecewise(this._calculateWholeRange(this._range), (null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain).map(this.transformer), interpolateNumber$1)), this._clamp(this.untransformer(this._input(y)));
      }
      domain(_, slience) {
        var _a;
        if (!_) return (null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain).slice();
        this._domainValidator = null, this._niceType = null, this._niceDomain = null;
        const nextDomain = Array.from(_, toNumber$1);
        return this._domain = nextDomain, this.rescale(slience);
      }
      range(_, slience) {
        if (!_) return this._range.slice();
        const nextRange = Array.from(_);
        return this._range = nextRange, this.rescale(slience);
      }
      rangeRound(_, slience) {
        const nextRange = Array.from(_);
        return this._range = nextRange, this._interpolate = interpolateNumberRound$1, this.rescale(slience);
      }
      rescale(slience) {
        var _a;
        if (slience) return this;
        const domain = null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain,
          domainLength = domain.length,
          rangeLength = this._range.length;
        let n = Math.min(domainLength, rangeLength);
        if (domainLength && domainLength < rangeLength && this._forceAlign) {
          const deltaStep = rangeLength - domainLength + 1,
            last = domain[domainLength - 1],
            delta = domainLength >= 2 ? (last - domain[domainLength - 2]) / deltaStep : 0;
          for (let i = 1; i <= deltaStep; i++) domain[domainLength - 2 + i] = last - delta * (deltaStep - i);
          n = rangeLength;
        }
        return this._autoClamp && (this._clamp = clamper$1(domain[0], domain[n - 1])), this._piecewise = n > 2 ? polymap$1 : bimap$1, this._output = this._input = null, this._wholeRange = null, this.generateFishEyeTransform(), this;
      }
      clamp(_, f, slience) {
        return arguments.length ? (f ? (this._autoClamp = !1, this._clamp = f) : (this._autoClamp = !!_, this._clamp = _ ? void 0 : identity$1), this.rescale(slience)) : this._clamp !== identity$1;
      }
      interpolate(_, slience) {
        return arguments.length ? (this._interpolate = _, this.rescale(slience)) : this._interpolate;
      }
      ticks() {
        return [];
      }
      tickData() {
        let count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;
        const ticks = this.ticks(count);
        return (null != ticks ? ticks : []).map((tick, index) => ({
          index: index,
          tick: tick,
          value: (this.scale(tick) - this._range[0]) / (this._range[1] - this._range[0])
        }));
      }
      rangeFactor(_, slience) {
        return _ ? (super.rangeFactor(_), this._output = this._input = null, this) : super.rangeFactor();
      }
      rangeFactorStart(_, slience) {
        return isNil$5(_) ? super.rangeFactorStart() : (super.rangeFactorStart(_), this._output = this._input = null, this);
      }
      rangeFactorEnd(_, slience) {
        return isNil$5(_) ? super.rangeFactorEnd() : (super.rangeFactorEnd(_), this._output = this._input = null, this);
      }
      forceAlignDomainRange(forceAlign) {
        return arguments.length ? (this._forceAlign = forceAlign, this) : this._forceAlign;
      }
    };

    const e10$2 = Math.sqrt(50),
      e5$2 = Math.sqrt(10),
      e2$2 = Math.sqrt(2),
      niceNumbers$1 = [1, 2, 5, 10];
    const calculateTicksOfSingleValue$1 = (value, tickCount, noDecimals) => {
      let step = 1,
        start = value;
      const middleIndex = Math.floor((tickCount - 1) / 2),
        absVal = Math.abs(value);
      return value >= 0 && value <= Number.MIN_VALUE ? start = 0 : value < 0 && value >= -Number.MIN_VALUE ? start = -(tickCount - 1) : !noDecimals && absVal < 1 ? step = getNickStep$1(absVal).step : (noDecimals || absVal > 1) && (start = Math.floor(value) - middleIndex * step), step > 0 ? (value > 0 ? start = Math.max(start, 0) : value < 0 && (start = Math.min(start, -(tickCount - 1) * step)), range$1(0, tickCount).map(index => start + index * step)) : value > 0 ? calculateTicksByStep$1(0, -(tickCount - 1) / step, step) : calculateTicksByStep$1((tickCount - 1) / step, 0, step);
    };
    const d3Ticks$1 = memoize$3((start, stop, count, options) => {
      let reverse,
        n,
        ticks,
        step,
        i = -1;
      if (count = +count, (start = +start) === (stop = +stop)) return [start];
      if (Math.abs(start - stop) <= Number.MIN_VALUE && count > 0) return [start];
      if ((reverse = stop < start) && (n = start, start = stop, stop = n), step = tickIncrement$1(start, stop, count).step, !isFinite(step)) return [];
      if (step > 0) {
        let r0 = Math.round(start / step),
          r1 = Math.round(stop / step);
        for (r0 * step < start && ++r0, r1 * step > stop && --r1, ticks = new Array(n = r1 - r0 + 1); ++i < n;) ticks[i] = (r0 + i) * step;
      } else if (step < 0 && (null == options ? void 0 : options.noDecimals)) {
        step = 1;
        const r0 = Math.ceil(start),
          r1 = Math.floor(stop);
        if (!(r0 <= r1)) return [];
        for (ticks = new Array(n = r1 - r0 + 1); ++i < n;) ticks[i] = r0 + i;
      } else {
        step = -step;
        let r0 = Math.round(start * step),
          r1 = Math.round(stop * step);
        for (r0 / step < start && ++r0, r1 / step > stop && --r1, ticks = new Array(n = r1 - r0 + 1); ++i < n;) ticks[i] = (r0 + i) / step;
      }
      return reverse && ticks.reverse(), ticks;
    });
    const calculateTicksByStep$1 = (start, stop, step) => {
      let n,
        ticks,
        i = -1;
      if (step > 0) {
        let r0 = Math.floor(start / step),
          r1 = Math.ceil(stop / step);
        for ((r0 + 1) * step < start && ++r0, (r1 - 1) * step > stop && --r1, ticks = new Array(n = r1 - r0 + 1); ++i < n;) ticks[i] = (r0 + i) * step;
      } else {
        step = -step;
        let r0 = Math.floor(start * step),
          r1 = Math.ceil(stop * step);
        for ((r0 + 1) / step < start && ++r0, (r1 - 1) / step > stop && --r1, ticks = new Array(n = r1 - r0 + 1); ++i < n;) ticks[i] = (r0 + i) / step;
      }
      return ticks;
    };
    const appendTicksToCount$1 = (ticks, count, step) => {
      let n;
      const firstTick = ticks[0],
        lastTick = ticks[ticks.length - 1],
        appendCount = count - ticks.length;
      if (lastTick <= 0) {
        const headTicks = [];
        for (n = appendCount; n >= 1; n--) headTicks.push(firstTick - n * step);
        return headTicks.concat(ticks);
      }
      if (firstTick >= 0) {
        for (n = 1; n <= appendCount; n++) ticks.push(lastTick + n * step);
        return ticks;
      }
      let headTicks = [];
      const tailTicks = [];
      for (n = 1; n <= appendCount; n++) n % 2 == 0 ? headTicks = [firstTick - Math.floor(n / 2) * step].concat(headTicks) : tailTicks.push(lastTick + Math.ceil(n / 2) * step);
      return headTicks.concat(ticks).concat(tailTicks);
    };
    const ticks$3 = memoize$3((start, stop, count, options) => {
      let reverse, ticks, n;
      if (count = +count, (start = +start) === (stop = +stop)) return calculateTicksOfSingleValue$1(start, count, null == options ? void 0 : options.noDecimals);
      if (Math.abs(start - stop) <= Number.MIN_VALUE && count > 0) return calculateTicksOfSingleValue$1(start, count, null == options ? void 0 : options.noDecimals);
      (reverse = stop < start) && (n = start, start = stop, stop = n);
      const stepRes = tickIncrement$1(start, stop, count);
      let step = stepRes.step;
      if (!isFinite(step)) return [];
      if (step > 0) {
        let cur = 1;
        const {
            power: power,
            gap: gap
          } = stepRes,
          delatStep = 10 === gap ? 2 * 10 ** power : 1 * 10 ** power;
        for (; cur <= 5 && (ticks = calculateTicksByStep$1(start, stop, step), ticks.length > count + 1) && count > 2;) step += delatStep, cur += 1;
        count > 2 && ticks.length < count - 1 && (ticks = appendTicksToCount$1(ticks, count, step));
      } else (null == options ? void 0 : options.noDecimals) && step < 0 && (step = 1), ticks = calculateTicksByStep$1(start, stop, step);
      return reverse && ticks.reverse(), ticks;
    });
    const getNickStep$1 = step => {
      const power = Math.floor(Math.log(step) / Math.LN10),
        error = step / 10 ** power;
      let gap = niceNumbers$1[0];
      return error >= e10$2 ? gap = niceNumbers$1[3] : error >= e5$2 ? gap = niceNumbers$1[2] : error >= e2$2 && (gap = niceNumbers$1[1]), power >= 0 ? {
        step: gap * 10 ** power,
        gap: gap,
        power: power
      } : {
        step: -(10 ** -power) / gap,
        gap: gap,
        power: power
      };
    };
    function tickIncrement$1(start, stop, count) {
      const step = (stop - start) / Math.max(0, count);
      return getNickStep$1(step);
    }
    function forceTicks$1(start, stop, count) {
      let step;
      if (count = +count, (start = +start) === (stop = +stop) && count > 0) return [start];
      if (count <= 0 || 0 === (step = forceTickIncrement$1(start, stop, count)) || !isFinite(step)) return [];
      const ticks = new Array(count);
      for (let i = 0; i < count; i++) ticks[i] = start + i * step;
      return ticks;
    }
    function forceTickIncrement$1(start, stop, count) {
      return (stop - start) / Math.max(1, count - 1);
    }
    function stepTicks$2(start, stop, step) {
      let n,
        reverse,
        i = -1;
      if (step = +step, (reverse = (stop = +stop) < (start = +start)) && (n = start, start = stop, stop = n), !isFinite(step) || stop - start <= step) return [start];
      const count = Math.floor((stop - start) / step + 1),
        ticks = new Array(count);
      for (; ++i < count;) ticks[i] = start + i * step;
      return reverse && ticks.reverse(), ticks;
    }
    function niceLinear$1(d) {
      let count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;
      let prestep,
        step,
        i0 = 0,
        i1 = d.length - 1,
        start = d[i0],
        stop = d[i1],
        maxIter = 10;
      for (stop < start && (step = start, start = stop, stop = step, step = i0, i0 = i1, i1 = step); maxIter-- > 0;) {
        if (step = tickIncrement$1(start, stop, count).step, step === prestep) return d[i0] = start, d[i1] = stop, d;
        if (step > 0) start = Math.floor(start / step) * step, stop = Math.ceil(stop / step) * step;else {
          if (!(step < 0)) break;
          start = Math.ceil(start * step) / step, stop = Math.floor(stop * step) / step;
        }
        prestep = step;
      }
    }
    function parseNiceOptions$1(originalDomain, option) {
      const hasForceMin = isNumber$6(option.forceMin),
        hasForceMax = isNumber$6(option.forceMax);
      let niceType = null;
      const niceMinMax = [];
      let niceDomain = null;
      const domainValidator = hasForceMin && hasForceMax ? x => x >= option.forceMin && x <= option.forceMax : hasForceMin ? x => x >= option.forceMin : hasForceMax ? x => x <= option.forceMax : null;
      return hasForceMin ? niceMinMax[0] = option.forceMin : isNumber$6(option.min) && option.min <= Math.min(originalDomain[0], originalDomain[originalDomain.length - 1]) && (niceMinMax[0] = option.min), hasForceMax ? niceMinMax[1] = option.forceMax : isNumber$6(option.max) && option.max >= Math.max(originalDomain[0], originalDomain[originalDomain.length - 1]) && (niceMinMax[1] = option.max), isNumber$6(niceMinMax[0]) && isNumber$6(niceMinMax[1]) ? (niceDomain = originalDomain.slice(), niceDomain[0] = niceMinMax[0], niceDomain[niceDomain.length - 1] = niceMinMax[1]) : niceType = isNumber$6(niceMinMax[0]) || isNumber$6(niceMinMax[1]) ? isNumber$6(niceMinMax[0]) ? "max" : "min" : "all", {
        niceType: niceType,
        niceDomain: niceDomain,
        niceMinMax: niceMinMax,
        domainValidator: domainValidator
      };
    }

    let LinearScale$1 = class LinearScale extends ContinuousScale$1 {
      constructor() {
        super(...arguments), this.type = ScaleEnum$1.Linear;
      }
      clone() {
        var _a;
        const scale = new LinearScale();
        return scale.domain(this._domain, !0).range(this._range, !0).unknown(this._unknown).clamp(this.clamp(), null, !0).interpolate(this._interpolate), this._niceType && (scale._niceType = this._niceType, scale._domainValidator = this._domainValidator, scale._niceDomain = null === (_a = this._niceDomain) || void 0 === _a ? void 0 : _a.slice()), scale;
      }
      tickFormat() {
        return () => {};
      }
      d3Ticks() {
        let count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;
        let options = arguments.length > 1 ? arguments[1] : undefined;
        const d = this.calculateVisibleDomain(this._range);
        return d3Ticks$1(d[0], d[d.length - 1], count, options);
      }
      ticks() {
        let count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;
        let options = arguments.length > 1 ? arguments[1] : undefined;
        var _a;
        if (isFunction$7(null == options ? void 0 : options.customTicks)) return options.customTicks(this, count);
        if (isValid$5(this._rangeFactorStart) && isValid$5(this._rangeFactorEnd) && (this._rangeFactorStart > 0 || this._rangeFactorEnd < 1) && 2 === this._range.length || !this._niceType) return this.d3Ticks(count, options);
        const curNiceDomain = null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain,
          originalDomain = this._domain,
          start = curNiceDomain[0],
          stop = curNiceDomain[curNiceDomain.length - 1];
        let ticksResult = ticks$3(originalDomain[0], originalDomain[originalDomain.length - 1], count, options);
        if (!ticksResult.length) return ticksResult;
        if (this._domainValidator) ticksResult = ticksResult.filter(this._domainValidator);else if ((ticksResult[0] !== start || ticksResult[ticksResult.length - 1] !== stop) && this._niceType) {
          const newNiceDomain = curNiceDomain.slice();
          if ("all" === this._niceType ? (newNiceDomain[0] = ticksResult[0], newNiceDomain[newNiceDomain.length - 1] = ticksResult[ticksResult.length - 1], this._niceDomain = newNiceDomain, this.rescale()) : "min" === this._niceType && ticksResult[0] !== start ? (newNiceDomain[0] = ticksResult[0], this._niceDomain = newNiceDomain, this.rescale()) : "max" === this._niceType && ticksResult[ticksResult.length - 1] !== stop && (newNiceDomain[newNiceDomain.length - 1] = ticksResult[ticksResult.length - 1], this._niceDomain = newNiceDomain, this.rescale()), "all" !== this._niceType) {
            const min = Math.min(newNiceDomain[0], newNiceDomain[newNiceDomain.length - 1]),
              max = Math.max(newNiceDomain[0], newNiceDomain[newNiceDomain.length - 1]);
            ticksResult = ticksResult.filter(entry => entry >= min && entry <= max);
          }
        }
        return ticksResult;
      }
      forceTicks() {
        let count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;
        const d = this.calculateVisibleDomain(this._range);
        return forceTicks$1(d[0], d[d.length - 1], count);
      }
      stepTicks(step) {
        const d = this.calculateVisibleDomain(this._range);
        return stepTicks$2(d[0], d[d.length - 1], step);
      }
      nice() {
        let count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;
        let option = arguments.length > 1 ? arguments[1] : undefined;
        var _a, _b;
        const originalDomain = this._domain;
        let niceMinMax = [];
        if (option) {
          const res = parseNiceOptions$1(originalDomain, option);
          if (niceMinMax = res.niceMinMax, this._domainValidator = res.domainValidator, this._niceType = res.niceType, res.niceDomain) return this._niceDomain = res.niceDomain, this.rescale(), this;
        } else this._niceType = "all";
        if (this._niceType) {
          const niceDomain = niceLinear$1(originalDomain.slice(), count);
          "min" === this._niceType ? niceDomain[niceDomain.length - 1] = null !== (_a = niceMinMax[1]) && void 0 !== _a ? _a : niceDomain[niceDomain.length - 1] : "max" === this._niceType && (niceDomain[0] = null !== (_b = niceMinMax[0]) && void 0 !== _b ? _b : niceDomain[0]), this._niceDomain = niceDomain, this.rescale();
        }
        return this;
      }
      niceMin() {
        let count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;
        this._niceType = "min";
        const maxD = this._domain[this._domain.length - 1],
          niceDomain = niceLinear$1(this.domain(), count);
        return niceDomain && (niceDomain[niceDomain.length - 1] = maxD, this._niceDomain = niceDomain, this.rescale()), this;
      }
      niceMax() {
        let count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;
        this._niceType = "max";
        const minD = this._domain[0],
          niceDomain = niceLinear$1(this._domain.slice(), count);
        return niceDomain && (niceDomain[0] = minD, this._niceDomain = niceDomain, this.rescale()), this;
      }
    };

    function getScaleTicks(op, scale, count, getTicks) {
      let scaleTicks;
      const {
        breakData: breakData
      } = op;
      if (breakData && breakData()) {
        const {
            breakDomains: breakDomains
          } = breakData(),
          domain = scale.domain();
        scaleTicks = [];
        for (let i = 0; i < domain.length - 1; i++) {
          getTicks(count, [domain[i], domain[i + 1]]).forEach(tick => {
            breakDomains.some(breakDomain => tick >= breakDomain[0] && tick <= breakDomain[1]) || scaleTicks.push(tick);
          });
        }
        scale.domain(domain);
      } else scaleTicks = getTicks(count);
      return scaleTicks;
    }
    function forceItemVisible(sourceItem, items, check, comparator) {
      let inverse = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !1;
      if (check && !items.includes(sourceItem)) {
        let remainLength = items.length;
        if (remainLength > 1) {
          inverse ? items.push(sourceItem) : items.unshift(sourceItem);
          for (let i = 0; i < remainLength; i++) {
            const index = inverse ? remainLength - 1 - i : i;
            if (!comparator(items[index])) break;
            items.splice(index, 1), i--, remainLength--;
          }
        }
      }
    }
    const continuousTicks = (scale, op) => {
      var _a, _b;
      if (!isContinuous(scale.type)) return convertDomainToTickData(scale.domain());
      const range = scale.range(),
        rangeSize = Math.abs(range[range.length - 1] - range[0]);
      if (rangeSize < 2) return convertDomainToTickData([scale.domain()[0]]);
      const {
        tickCount: tickCount,
        forceTickCount: forceTickCount,
        tickStep: tickStep,
        noDecimals = !1,
        labelStyle: labelStyle,
        breakData: breakData
      } = op;
      let scaleTicks;
      if (isValid$5(tickStep)) ticks = scale.stepTicks(tickStep), breakDomains = breakData && breakData() ? breakData().breakDomains : null, scaleTicks = breakDomains && breakDomains.length ? ticks.filter(tick => breakDomains.every(breakDomain => tick < breakDomain[0] || tick > breakDomain[1])) : ticks;else if (isValid$5(forceTickCount)) scaleTicks = getScaleTicks(op, scale, forceTickCount, (count, subDomain) => subDomain && subDomain.length ? scale.domain(subDomain, !0).forceTicks(count) : scale.forceTicks(count));else if ("d3" === op.tickMode) {
        const count = null !== (_a = isFunction$7(tickCount) ? tickCount({
          axisLength: rangeSize,
          labelStyle: labelStyle
        }) : tickCount) && void 0 !== _a ? _a : 5;
        scaleTicks = getScaleTicks(op, scale, count, (count, subDomain) => subDomain && subDomain.length ? scale.domain(subDomain, !0).d3Ticks(count, {
          noDecimals: noDecimals
        }) : scale.d3Ticks(count, {
          noDecimals: noDecimals
        }));
      } else {
        const count = null !== (_b = isFunction$7(tickCount) ? tickCount({
            axisLength: rangeSize,
            labelStyle: labelStyle
          }) : tickCount) && void 0 !== _b ? _b : 5,
          customTicks = isFunction$7(op.tickMode) ? op.tickMode : void 0;
        scaleTicks = getScaleTicks(op, scale, count, (count, subDomain) => subDomain && subDomain.length ? scale.domain(subDomain, !0).ticks(count, {
          noDecimals: noDecimals,
          customTicks: customTicks
        }) : scale.ticks(count, {
          noDecimals: noDecimals,
          customTicks: customTicks
        }));
      }
      var ticks, breakDomains;
      const domain = scale.domain();
      if (op.labelFirstVisible && domain[0] !== scaleTicks[0] && !scaleTicks.includes(domain[0]) && scaleTicks.unshift(domain[0]), op.labelLastVisible && domain[domain.length - 1] !== scaleTicks[scaleTicks.length - 1] && !scaleTicks.includes(domain[domain.length - 1]) && scaleTicks.push(domain[domain.length - 1]), op.sampling && scaleTicks.length > 1 && ("cartesian" === op.coordinateType || "polar" === op.coordinateType && "radius" === op.axisOrientType)) {
        const {
            labelGap = 4,
            labelFlush: labelFlush
          } = op,
          MIN_FONT_SIZE = 6;
        let items;
        if (scaleTicks.length * MIN_FONT_SIZE > rangeSize) {
          const samplingScaleTicks = [],
            step = Math.floor(scaleTicks.length * MIN_FONT_SIZE / rangeSize);
          scaleTicks.forEach((tick, index) => {
            index % step != 0 && index !== scaleTicks.length - 1 || samplingScaleTicks.push(tick);
          }), items = getCartesianLabelBounds(scale, samplingScaleTicks, op).map((bounds, i) => ({
            AABBBounds: bounds,
            value: samplingScaleTicks[i]
          }));
        } else items = getCartesianLabelBounds(scale, scaleTicks, op).map((bounds, i) => ({
          AABBBounds: bounds,
          value: scaleTicks[i]
        }));
        const firstSourceItem = items[0],
          lastSourceItem = last$1(items),
          samplingMethod = breakData && breakData() ? methods.greedy : methods.parity;
        for (; items.length >= 3 && hasOverlap(items, labelGap);) items = samplingMethod(items, labelGap);
        const checkFirst = op.labelFirstVisible;
        let checkLast = op.labelLastVisible;
        textIntersect(firstSourceItem, lastSourceItem, labelGap) && items.includes(lastSourceItem) && items.length > 1 && checkFirst && checkLast && (items.splice(items.indexOf(lastSourceItem), 1), checkLast = !1), forceItemVisible(firstSourceItem, items, checkFirst, item => textIntersect(item, firstSourceItem, labelGap)), forceItemVisible(lastSourceItem, items, checkLast, item => textIntersect(item, lastSourceItem, labelGap) || !(!checkFirst || item === firstSourceItem) && textIntersect(item, firstSourceItem, labelGap), !0);
        const ticks = items.map(item => item.value);
        ticks.length < 3 && labelFlush && (ticks.length > 1 && ticks.pop(), last$1(ticks) !== last$1(scaleTicks) && ticks.push(last$1(scaleTicks))), scaleTicks = ticks;
      }
      return convertDomainToTickData(scaleTicks);
    };
    const methods = {
      parity: function (items) {
        return items.filter((item, i) => i % 2 == 0);
      },
      greedy: function (items, sep) {
        let a;
        return items.filter((b, i) => (!i || !textIntersect(a, b, sep)) && (a = b, !0));
      }
    };

    const getOneDimensionalLabelBounds = (scale, domain, op, isHorizontal) => getCartesianLabelBounds(scale, domain, op).map(bounds => isHorizontal ? [bounds.x1, bounds.x2, bounds.width()] : [bounds.y1, bounds.y2, bounds.height()]),
      boundsOverlap = function (prevBounds, nextBounds) {
        let gap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        return Math.max(prevBounds[0], nextBounds[0]) - gap / 2 <= Math.min(prevBounds[1], nextBounds[1]) + gap / 2;
      };
    const boundsDistance = (prevBounds, nextBounds) => prevBounds[1] < nextBounds[0] ? nextBounds[0] - prevBounds[1] : nextBounds[1] < prevBounds[0] ? prevBounds[0] - nextBounds[1] : 0;
    const linearDiscreteTicks = (scale, op) => {
      var _a;
      const domain = scale.domain();
      if (!domain.length) return [];
      const {
          tickCount: tickCount,
          forceTickCount: forceTickCount,
          tickStep: tickStep,
          labelGap = 4,
          axisOrientType: axisOrientType,
          labelStyle: labelStyle
        } = op,
        isHorizontal = isAxisHorizontal(axisOrientType),
        range = scale.range(),
        rangeSize = scale.calculateWholeRangeSize();
      if (rangeSize < 2) return op.labelLastVisible ? convertDomainToTickData([domain[domain.length - 1]]) : convertDomainToTickData([domain[0]]);
      let scaleTicks;
      if (isValid$5(tickStep)) scaleTicks = scale.stepTicks(tickStep);else if (isValid$5(forceTickCount)) scaleTicks = scale.forceTicks(forceTickCount);else if (isValid$5(tickCount)) {
        const count = isFunction$7(tickCount) ? tickCount({
          axisLength: rangeSize,
          labelStyle: labelStyle
        }) : tickCount;
        scaleTicks = scale.ticks(count);
      } else if (op.sampling) {
        const fontSize = (null !== (_a = op.labelStyle.fontSize) && void 0 !== _a ? _a : 12) + 2,
          rangeStart = minInArray$1(range),
          rangeEnd = maxInArray$1(range);
        if (domain.length <= rangeSize / fontSize) {
          const incrementUnit = (rangeEnd - rangeStart) / domain.length,
            labelBoundsList = getOneDimensionalLabelBounds(scale, domain, op, isHorizontal),
            minBoundsLength = Math.min(...labelBoundsList.map(bounds => bounds[2])),
            stepResult = getStep$1(domain, labelBoundsList, labelGap, op.labelLastVisible, Math.floor(minBoundsLength / incrementUnit), !1);
          scaleTicks = scale.stepTicks(stepResult.step), op.labelLastVisible && (stepResult.delCount && (scaleTicks = scaleTicks.slice(0, scaleTicks.length - stepResult.delCount)), scaleTicks.push(domain[domain.length - 1]));
        } else {
          const tempDomain = [domain[0], domain[Math.floor(domain.length / 2)], domain[domain.length - 1]],
            tempList = getOneDimensionalLabelBounds(scale, tempDomain, op, isHorizontal);
          let maxBounds = null;
          tempList.forEach(current => {
            maxBounds ? maxBounds[2] < current[2] && (maxBounds = current) : maxBounds = current;
          });
          const step = rangeEnd - rangeStart - labelGap > 0 ? Math.ceil(domain.length * (labelGap + maxBounds[2]) / (rangeEnd - rangeStart - labelGap)) : domain.length - 1;
          scaleTicks = scale.stepTicks(step), !op.labelLastVisible || scaleTicks.length && scaleTicks[scaleTicks.length - 1] === domain[domain.length - 1] || (scaleTicks.length && Math.abs(scale.scale(scaleTicks[scaleTicks.length - 1]) - scale.scale(domain[domain.length - 1])) < maxBounds[2] && (scaleTicks = scaleTicks.slice(0, -1)), scaleTicks.push(domain[domain.length - 1]));
        }
      } else scaleTicks = scale.domain();
      return convertDomainToTickData(scaleTicks);
    };
    const getStep$1 = (domain, labelBoundsList, labelGap, labelLastVisible, defaultStep, areAllBoundsSame) => {
      let resultDelCount = 0,
        resultStep = 0,
        resultTickCount = -1,
        minDiff = Number.MAX_VALUE;
      const validateStep = step => {
          let success = !0,
            ptr = 0;
          do {
            ptr + step < domain.length && boundsOverlap(labelBoundsList[ptr], labelBoundsList[ptr + step], labelGap) && (success = !1), ptr += step;
          } while (success && ptr < domain.length);
          return success;
        },
        minValidStep = binaryFuzzySearchInNumberRange(defaultStep, domain.length, step => validateStep(step) ? 1 : -1);
      let step = minValidStep;
      do {
        if (step > minValidStep && !areAllBoundsSame && !validateStep(step)) step++;else {
          if (!labelLastVisible) {
            resultStep = step;
            break;
          }
          {
            const lastIndex = domain.length - 1;
            let ptr,
              delCount = 0;
            ptr = domain.length % step > 0 ? domain.length - domain.length % step + step : domain.length;
            do {
              if (ptr -= step, ptr !== lastIndex && !boundsOverlap(labelBoundsList[ptr], labelBoundsList[lastIndex], labelGap)) break;
              delCount++;
            } while (ptr > 0);
            if (ptr === lastIndex) {
              resultStep = step, resultDelCount = delCount;
              break;
            }
            {
              const tickCount = Math.floor(domain.length / step) - delCount + 1;
              if (tickCount < resultTickCount) break;
              {
                resultTickCount = tickCount;
                const distance1 = boundsDistance(labelBoundsList[ptr], labelBoundsList[lastIndex]),
                  distance2 = ptr - step >= 0 ? boundsDistance(labelBoundsList[ptr - step], labelBoundsList[ptr]) : distance1,
                  diff = Math.abs(distance1 - distance2);
                if (diff < minDiff && (minDiff = diff, resultStep = step, resultDelCount = delCount), distance1 <= distance2) break;
              }
            }
          }
          step++;
        }
      } while (step <= domain.length);
      return {
        step: resultStep,
        delCount: resultDelCount
      };
    };

    const getPolarAngleLabelBounds = (scale, domain, op) => {
      var _a;
      const {
          labelStyle: labelStyle,
          getRadius: getRadius,
          labelOffset: labelOffset,
          labelFormatter: labelFormatter,
          inside: inside
        } = op,
        radius = null == getRadius ? void 0 : getRadius(),
        labelAngle = null !== (_a = labelStyle.angle) && void 0 !== _a ? _a : 0,
        textMeasure = initTextMeasure$1(labelStyle);
      return domain.map(v => {
        const str = labelFormatter ? labelFormatter(v) : `${v}`,
          {
            width: width,
            height: height
          } = textMeasure.quickMeasure(str),
          textWidth = Math.max(width, MIN_TICK_GAP),
          textHeight = Math.max(height, MIN_TICK_GAP),
          angle = scale.scale(v),
          center = {
            x: 0,
            y: 0
          };
        let textX = 0,
          textY = 0;
        const orient = {
            align: labelStyle.textAlign,
            baseline: labelStyle.textBaseline
          },
          {
            x: x,
            y: y
          } = getPolarAngleLabelPosition(angle, center, radius, labelOffset, inside);
        orient.align || (isNumberClose$1(x, center.x) ? orient.baseline || (orient.baseline = y > center.y ? "top" : "bottom") : x > center.x ? orient.align = "left" : x < center.x && (orient.align = "right")), textX = x + ("right" === orient.align ? -textWidth : "left" === orient.align ? 0 : -textWidth / 2), textY = y + ("bottom" === orient.baseline ? -textHeight : "top" === orient.baseline ? 0 : -textHeight / 2);
        return new AABBBounds$1().set(textX, textY, textX + textWidth, textY + textHeight).rotate(labelAngle, textX + textWidth / 2, textY + textHeight / 2);
      });
    };
    const polarAngleAxisDiscreteTicks = (scale, op) => {
      const {
          tickCount: tickCount,
          forceTickCount: forceTickCount,
          tickStep: tickStep,
          getRadius: getRadius,
          labelOffset: labelOffset,
          labelGap = 0,
          labelStyle: labelStyle
        } = op,
        radius = null == getRadius ? void 0 : getRadius();
      if (!radius) return convertDomainToTickData(scale.domain());
      let scaleTicks;
      if (isValid$5(tickStep)) scaleTicks = scale.stepTicks(tickStep);else if (isValid$5(forceTickCount)) scaleTicks = scale.forceTicks(forceTickCount);else if (isValid$5(tickCount)) {
        const range = scale.range(),
          rangeSize = Math.abs(range[range.length - 1] - range[0]),
          count = isFunction$7(tickCount) ? tickCount({
            axisLength: rangeSize,
            labelStyle: labelStyle
          }) : tickCount;
        scaleTicks = scale.ticks(count);
      } else if (op.sampling) {
        const domain = scale.domain(),
          range = scale.range(),
          labelBoundsList = getPolarAngleLabelBounds(scale, domain, op),
          rangeStart = minInArray$1(range),
          rangeEnd = maxInArray$1(range),
          incrementUnit = Math.abs(rangeEnd - rangeStart) * (radius + labelOffset) / domain.length,
          {
            step: step,
            delCount: delCount
          } = getStep(domain, labelBoundsList, labelGap, Math.floor(labelBoundsList.reduce((min, curBounds) => Math.min(min, curBounds.width(), curBounds.height()), Number.MAX_VALUE) / incrementUnit));
        scaleTicks = scale.stepTicks(step), scaleTicks = scaleTicks.slice(0, scaleTicks.length - delCount);
      } else scaleTicks = scale.domain();
      return convertDomainToTickData(scaleTicks);
    };
    const getStep = (domain, labelBoundsList, labelGap, defaultStep) => {
      let step = defaultStep;
      do {
        let success = !0;
        step++;
        let ptr = 0;
        do {
          ptr + step < domain.length && labelOverlap(labelBoundsList[ptr], labelBoundsList[ptr + step], labelGap) && (success = !1), ptr += step;
        } while (success && ptr < domain.length);
        if (success) break;
      } while (step <= domain.length);
      let delCount = 0;
      if (domain.length > 2) {
        let ptr = domain.length - domain.length % step;
        for (ptr >= domain.length && (ptr -= step); ptr > 0 && labelOverlap(labelBoundsList[0], labelBoundsList[ptr]);) delCount++, ptr -= step;
      }
      return {
        step: step,
        delCount: delCount
      };
    };

    const ticks$2 = (scale, op) => {
      if (isContinuous(scale.type)) return continuousTicks(scale, op);
      if (isDiscrete(scale.type)) {
        if ("cartesian" === op.coordinateType) return linearDiscreteTicks(scale, op);
        if ("polar" === op.coordinateType && "angle" === op.axisOrientType) return polarAngleAxisDiscreteTicks(scale, op);
      }
      return convertDomainToTickData(scale.domain());
    };

    function loadPagerComponent() {
      registerGroup(), registerSymbol(), registerText();
    }

    const DEFAULT_HANDLER_STYLE = {
      space: 8,
      style: {
        fill: "rgb(47, 69, 84)",
        cursor: "pointer",
        size: 15
      },
      state: {
        disable: {
          fill: "rgb(170, 170, 170)",
          cursor: "not-allowed"
        },
        hover: {}
      }
    };
    loadPagerComponent();
    class Pager extends AbstractComponent {
      getCurrent() {
        return this._current;
      }
      constructor(attributes, options) {
        super((null == options ? void 0 : options.skipDefault) ? attributes : merge$2({}, Pager.defaultAttributes, attributes)), this.name = "pager", this._current = 1, this._onHover = e => {
          const target = e.target;
          target.hasState("disable") || target.addState("hover");
        }, this._onUnHover = e => {
          e.target.removeState("hover");
        }, this._onClick = e => {
          const target = e.target;
          if ("preHandler" === target.name) {
            if (1 === this._current) return;
            this._current -= 1, 1 === this._current ? target.addState("disable") : target.removeState("disable"), this._dispatchEvent("toPrev", {
              current: this._current,
              total: this._total,
              direction: "pre",
              event: e
            });
          }
          if ("nextHandler" === target.name) {
            if (this._current === this._total) return;
            this._current += 1, this._current === this._total ? target.addState("disable") : target.removeState("disable"), this._dispatchEvent("toNext", {
              current: this._current,
              total: this._total,
              direction: "next",
              event: e
            });
          }
          this._current > 1 && this.preHandler.removeState("disable"), this._current < this._total && this.nextHandler.removeState("disable"), this.text.setAttribute("text", this._getPageText(this._current));
        };
      }
      render() {
        var _a, _b, _c;
        this._reset();
        const {
          layout = "horizontal",
          handler = DEFAULT_HANDLER_STYLE,
          total: total,
          defaultCurrent = 1,
          textStyle: textStyle,
          padding = 0
        } = this.attribute;
        this._current = defaultCurrent;
        const parsedPadding = normalizePadding(padding),
          isHorizontal = "horizontal" === layout,
          container = graphicCreator.group({
            x: 0,
            y: 0
          }),
          handlerStyle = handler.style || {},
          handlerSize = handlerStyle.size || 15,
          handlerSpace = null !== (_a = handler.space) && void 0 !== _a ? _a : 8,
          handlerState = handler.state || {};
        let {
          preShape: preShape,
          nextShape: nextShape
        } = handler;
        preShape || (preShape = isHorizontal ? "triangleLeft" : "triangleUp"), nextShape || (nextShape = isHorizontal ? "triangleRight" : "triangleDown");
        const preHandler = graphicCreator.symbol(Object.assign(Object.assign({
          strokeBoundsBuffer: 0,
          pickMode: "imprecise"
        }, handlerStyle), {
          x: 0,
          y: 0,
          symbolType: preShape,
          size: handlerSize
        }));
        preHandler.states = handlerState, preHandler.name = "preHandler", this.preHandler = preHandler, container.add(preHandler);
        const {
            width: maxTextWidth,
            height: maxTextHeight
          } = measureTextSize(this._getPageText(total), Object.assign({
            textAlign: "center",
            textBaseline: "middle"
          }, textStyle), null === (_c = null === (_b = this.stage) || void 0 === _b ? void 0 : _b.getTheme()) || void 0 === _c ? void 0 : _c.text),
          handlerSizeX = isNumber$6(handlerSize) ? handlerSize : handlerSize[0],
          handlerSizeY = isNumber$6(handlerSize) ? handlerSize : handlerSize[1],
          text = graphicCreator.text(Object.assign({
            x: isHorizontal ? handlerSizeX / 2 + handlerSpace + maxTextWidth / 2 : 0,
            y: isHorizontal ? 0 : handlerSizeY / 2 + handlerSpace + maxTextHeight / 2,
            text: this._getPageText(defaultCurrent),
            textAlign: "center",
            textBaseline: "middle",
            lineHeight: null == textStyle ? void 0 : textStyle.fontSize
          }, textStyle));
        this.text = text, container.add(text);
        const nextHandler = graphicCreator.symbol(Object.assign(Object.assign({
          strokeBoundsBuffer: 0,
          pickMode: "imprecise"
        }, handlerStyle), {
          x: isHorizontal ? handlerSizeX + 2 * handlerSpace + maxTextWidth : 0,
          y: isHorizontal ? 0 : handlerSizeY + 2 * handlerSpace + maxTextHeight,
          symbolType: nextShape,
          size: handlerSize
        }));
        nextHandler.name = "nextHandler", nextHandler.states = handlerState, this.nextHandler = nextHandler, container.add(nextHandler), 1 === this._total ? (preHandler.addState("disable"), nextHandler.addState("disable")) : 1 === this._current ? preHandler.addState("disable") : this._current === total && nextHandler.addState("disable");
        const containerBounds = container.AABBBounds,
          width = containerBounds.width(),
          height = containerBounds.height();
        container.translateTo(0 - containerBounds.x1 + parsedPadding[3], 0 - containerBounds.y1 + parsedPadding[0]), this.add(container), this.attribute.width = width + parsedPadding[1] + parsedPadding[3], this.attribute.height = height + parsedPadding[0] + parsedPadding[2], this._bindEvents();
      }
      _bindEvents() {
        this.attribute.disableTriggerEvent || (this.preHandler && (this.preHandler.addEventListener("pointerenter", this._onHover), this.preHandler.addEventListener("pointerleave", this._onUnHover), this.preHandler.addEventListener("pointerdown", this._onClick)), this.nextHandler && (this.nextHandler.addEventListener("pointerenter", this._onHover), this.nextHandler.addEventListener("pointerleave", this._onUnHover), this.nextHandler.addEventListener("pointerdown", this._onClick)));
      }
      _reset() {
        this.removeAllChild(!0), this._current = 1, this._total = this.attribute.total, this.preHandler = this.nextHandler = this.text = null;
      }
      _getPageText(current) {
        const {
          pageFormatter: pageFormatter
        } = this.attribute;
        return pageFormatter ? isFunction$7(pageFormatter) ? pageFormatter(current, this._total) : `${pageFormatter}`.replace("{current}", `${current}`).replace("{total}", `${this._total}`) : `${current}/${this._total}`;
      }
      setTotal(total) {
        total !== this.attribute.total && (this._total = total, 1 !== this._current && this._current <= total ? this.setAttributes({
          total: total,
          defaultCurrent: this._current
        }) : this.setAttribute("total", total));
      }
    }
    Pager.defaultAttributes = {
      handler: DEFAULT_HANDLER_STYLE,
      textStyle: {
        fill: "rgb(51, 51, 51)",
        fontSize: 12
      }
    };

    const DEFAULT_SHAPE_SIZE = 10;
    const DEFAULT_SHAPE_SPACE = 8;
    const DEFAULT_LABEL_SPACE = 8;
    const DEFAULT_VALUE_SPACE = 8;
    const DEFAULT_ITEM_SPACE_COL = 16;
    const DEFAULT_ITEM_SPACE_ROW = 8;
    const DEFAULT_TITLE_SPACE = 12;
    const DEFAULT_PAGER_SPACE = 12;
    var LegendStateValue;
    !function (LegendStateValue) {
      LegendStateValue.selected = "selected", LegendStateValue.unSelected = "unSelected", LegendStateValue.selectedHover = "selectedHover", LegendStateValue.unSelectedHover = "unSelectedHover", LegendStateValue.focus = "focus";
    }(LegendStateValue || (LegendStateValue = {}));
    var LegendEvent;
    !function (LegendEvent) {
      LegendEvent.legendItemHover = "legendItemHover", LegendEvent.legendItemUnHover = "legendItemUnHover", LegendEvent.legendItemClick = "legendItemClick", LegendEvent.legendItemAttributeUpdate = "legendItemAttributeUpdate";
    }(LegendEvent || (LegendEvent = {}));
    var LEGEND_ELEMENT_NAME;
    !function (LEGEND_ELEMENT_NAME) {
      LEGEND_ELEMENT_NAME.innerView = "innerView", LEGEND_ELEMENT_NAME.title = "legendTitle", LEGEND_ELEMENT_NAME.item = "legendItem", LEGEND_ELEMENT_NAME.itemShape = "legendItemShape", LEGEND_ELEMENT_NAME.itemLabel = "legendItemLabel", LEGEND_ELEMENT_NAME.itemValue = "legendItemValue", LEGEND_ELEMENT_NAME.focus = "legendItemFocus";
    }(LEGEND_ELEMENT_NAME || (LEGEND_ELEMENT_NAME = {}));

    class LegendBase extends AbstractComponent {
      constructor() {
        super(...arguments), this.name = "legend", this._title = null;
      }
      render() {
        this.removeAllChild(!0);
        const {
          interactive = !0,
          title: title,
          padding = 0
        } = this.attribute;
        this._parsedPadding = normalizePadding(padding);
        const innerView = graphicCreator.group({
          x: this._parsedPadding[3],
          y: this._parsedPadding[0],
          pickable: interactive,
          childrenPickable: interactive
        });
        innerView.name = LEGEND_ELEMENT_NAME.innerView, this.add(innerView), this._innerView = innerView, (null == title ? void 0 : title.visible) && this._renderTitle(title), this._renderContent(), this._adjustLayout(), interactive && this._bindEvents();
        const viewBounds = this._innerView.AABBBounds;
        this.attribute.width = viewBounds.width() + this._parsedPadding[1] + this._parsedPadding[3], this.attribute.height = viewBounds.height() + this._parsedPadding[0] + this._parsedPadding[2];
      }
      _renderTitle(title) {
        const {
            text = "",
            textStyle: textStyle,
            padding = 0,
            background: background,
            minWidth: minWidth,
            maxWidth: maxWidth,
            shape: shape
          } = title,
          tagAttrs = {
            x: 0,
            y: 0,
            text: text,
            textStyle: textStyle,
            padding: normalizePadding(padding),
            minWidth: minWidth,
            maxWidth: maxWidth
          };
        shape && shape.visible && (tagAttrs.shape = Object.assign({
          visible: !0
        }, shape.style), isValid$5(shape.space) && (tagAttrs.space = shape.space)), background && background.visible && (tagAttrs.panel = Object.assign({
          visible: !0
        }, background.style));
        const titleTag = new Tag$1(tagAttrs);
        titleTag.name = LEGEND_ELEMENT_NAME.title, this._title = titleTag, this._innerView.add(titleTag);
      }
      _adjustLayout() {
        var _a;
        if (this._title) {
          const innerViewWidth = this._innerView.AABBBounds.width(),
            titleWidth = this._title.AABBBounds.width(),
            align = null === (_a = this.attribute.title) || void 0 === _a ? void 0 : _a.align;
          "center" === align ? this._title.setAttribute("x", (innerViewWidth - titleWidth) / 2) : "end" === align && this._title.setAttribute("x", innerViewWidth - titleWidth);
        }
      }
    }

    function loadSliderComponent() {
      registerGroup(), registerText(), registerRect(), registerSymbol();
    }

    function loadBaseLegend() {
      registerGroup(), loadTagComponent();
    }
    function loadDiscreteLegendComponent() {
      loadBaseLegend(), loadPagerComponent(), loadScrollbarComponent();
    }
    function loadColorContinuousLegendComponent() {
      loadBaseLegend(), loadSliderComponent();
    }
    function loadSizeContinuousLegendComponent() {
      loadBaseLegend(), loadSliderComponent(), registerPath();
    }

    var __rest = undefined && undefined.__rest || function (s, e) {
      var t = {};
      for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0 && (t[p] = s[p]);
      if (null != s && "function" == typeof Object.getOwnPropertySymbols) {
        var i = 0;
        for (p = Object.getOwnPropertySymbols(s); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t[p[i]] = s[p[i]]);
      }
      return t;
    };
    const DEFAULT_STATES = {
      [LegendStateValue.focus]: {},
      [LegendStateValue.selected]: {},
      [LegendStateValue.selectedHover]: {},
      [LegendStateValue.unSelected]: {},
      [LegendStateValue.unSelectedHover]: {}
    };
    loadDiscreteLegendComponent();
    class DiscreteLegend extends LegendBase {
      constructor(attributes, options) {
        super((null == options ? void 0 : options.skipDefault) ? attributes : merge$2({}, DiscreteLegend.defaultAttributes, attributes)), this.name = "discreteLegend", this._itemsContainer = null, this._itemHeightByUser = void 0, this._itemHeight = 0, this._itemMaxWidth = 0, this._contentMaxHeight = 0, this._onHover = e => {
          const target = e.target;
          if (target && target.name && target.name.startsWith(LEGEND_ELEMENT_NAME.item)) {
            const legendItem = target.delegate;
            if (this._lastActiveItem) {
              if (this._lastActiveItem.id === legendItem.id) return;
              this._unHover(this._lastActiveItem, e);
            }
            this._hover(legendItem, e);
          } else this._lastActiveItem && (this._unHover(this._lastActiveItem, e), this._lastActiveItem = null);
        }, this._onUnHover = e => {
          this._lastActiveItem && (this._unHover(this._lastActiveItem, e), this._lastActiveItem = null);
        }, this._onClick = e => {
          var _a, _b, _c, _d;
          const target = e.target;
          if (target && target.name && target.name.startsWith(LEGEND_ELEMENT_NAME.item)) {
            const legendItem = target.delegate,
              {
                selectMode = "multiple"
              } = this.attribute;
            if (target.name === LEGEND_ELEMENT_NAME.focus || "focus" === selectMode) {
              const isFocusSelected = legendItem.hasState(LegendStateValue.focus);
              legendItem.toggleState(LegendStateValue.focus), isFocusSelected ? null === (_a = this._itemsContainer) || void 0 === _a || _a.getChildren().forEach(item => {
                this._removeLegendItemState(item, [LegendStateValue.unSelected, LegendStateValue.unSelectedHover, LegendStateValue.focus], e), this._setLegendItemState(item, LegendStateValue.selected, e);
              }) : (this._setLegendItemState(legendItem, LegendStateValue.selected, e), this._removeLegendItemState(legendItem, [LegendStateValue.unSelected, LegendStateValue.unSelectedHover], e), null === (_b = this._itemsContainer) || void 0 === _b || _b.getChildren().forEach(item => {
                legendItem !== item && (this._removeLegendItemState(item, [LegendStateValue.selected, LegendStateValue.selectedHover, LegendStateValue.focus], e), this._setLegendItemState(item, LegendStateValue.unSelected, e));
              }));
            } else {
              null === (_c = this._itemsContainer) || void 0 === _c || _c.getChildren().forEach(item => {
                item.removeState(LegendStateValue.focus);
              });
              const {
                  allowAllCanceled = !0
                } = this.attribute,
                isSelected = legendItem.hasState(LegendStateValue.selected),
                currentSelectedItems = this._getSelectedLegends();
              if ("multiple" === selectMode) {
                if (!1 === allowAllCanceled && isSelected && 1 === currentSelectedItems.length) return void this._dispatchLegendEvent(LegendEvent.legendItemClick, legendItem, e);
                isSelected ? (this._removeLegendItemState(legendItem, [LegendStateValue.selected, LegendStateValue.selectedHover], e), this._setLegendItemState(legendItem, LegendStateValue.unSelected, e)) : (this._setLegendItemState(legendItem, LegendStateValue.selected, e), this._removeLegendItemState(legendItem, [LegendStateValue.unSelected, LegendStateValue.unSelectedHover], e));
              } else this._setLegendItemState(legendItem, LegendStateValue.selected, e), this._removeLegendItemState(legendItem, [LegendStateValue.unSelected, LegendStateValue.unSelectedHover], e), null === (_d = this._itemsContainer) || void 0 === _d || _d.getChildren().forEach(item => {
                legendItem !== item && (this._removeLegendItemState(item, [LegendStateValue.selected, LegendStateValue.selectedHover], e), this._setLegendItemState(item, LegendStateValue.unSelected, e));
              });
            }
            this._dispatchLegendEvent(LegendEvent.legendItemClick, legendItem, e);
          }
        };
      }
      render() {
        super.render(), this._lastActiveItem = null;
      }
      setSelected(selectedData) {
        var _a;
        (null === (_a = this._itemsContainer) || void 0 === _a ? void 0 : _a.getChildren()).forEach(item => {
          const itemData = item.data;
          selectedData.includes(itemData.label) ? (this._setLegendItemState(item, LegendStateValue.selected), this._removeLegendItemState(item, [LegendStateValue.unSelected, LegendStateValue.unSelectedHover])) : (this._removeLegendItemState(item, [LegendStateValue.selected, LegendStateValue.selectedHover]), this._setLegendItemState(item, LegendStateValue.unSelected));
        });
      }
      _renderItems() {
        const {
            item: itemAttrs = {},
            maxCol = 1,
            maxRow = 2,
            maxWidth: maxWidth,
            defaultSelected: defaultSelected,
            lazyload: lazyload,
            autoPage: autoPage
          } = this.attribute,
          {
            spaceCol = DEFAULT_ITEM_SPACE_COL,
            spaceRow = DEFAULT_ITEM_SPACE_ROW,
            verticalAlign = "middle"
          } = itemAttrs,
          itemsContainer = this._itemsContainer,
          {
            items: legendItems,
            isHorizontal: isHorizontal,
            startIndex: startIndex,
            isScrollbar: isScrollbar
          } = this._itemContext,
          maxPages = isScrollbar ? 1 : isHorizontal ? maxRow : maxCol,
          maxHeight = this._contentMaxHeight;
        let item,
          {
            doWrap: doWrap,
            maxWidthInCol: maxWidthInCol,
            startX: startX,
            startY: startY,
            pages: pages
          } = this._itemContext,
          lastItemWidth = 0,
          lastLineHeight = 0;
        const lastLineItemGroup = [];
        for (let index = startIndex, len = legendItems.length; index < len && !(lazyload && pages > this._itemContext.currentPage * maxPages); index++) {
          lazyload && (this._itemContext.startIndex = index + 1), item = legendItems[index], item.id || (item.id = item.label), item.index = index;
          let isSelected = !0;
          isArray$9(defaultSelected) && (isSelected = defaultSelected.includes(item.label));
          const itemGroup = this._renderEachItem(item, isSelected, index, legendItems),
            itemWidth = itemGroup.attribute.width,
            itemHeight = itemGroup.attribute.height;
          this._itemHeight = Math.max(this._itemHeight, itemHeight), maxWidthInCol = Math.max(itemWidth, maxWidthInCol), this._itemMaxWidth = Math.max(itemWidth, this._itemMaxWidth), isHorizontal ? (isValid$5(maxWidth) && (isScrollbar && autoPage ? (pages = Math.ceil((startX + itemWidth) / maxWidth), doWrap = pages > 1) : startX + itemWidth > maxWidth && (doWrap = !0, startX > 0 && ("middle" !== verticalAlign && "bottom" !== verticalAlign || lastLineItemGroup.forEach(i => {
            i.setAttributes({
              y: i.attribute.y + (lastLineHeight - i.attribute.height) / ("middle" === verticalAlign ? 2 : 1)
            });
          }), pages += 1, startX = 0, startY += lastLineHeight + spaceRow, lastLineHeight = 0, lastLineItemGroup.length = 0))), 0 === startX && 0 === startY || itemGroup.setAttributes({
            x: startX,
            y: startY
          }), startX += spaceCol + itemWidth, lastLineHeight = Math.max(lastLineHeight, itemHeight), lastLineItemGroup.push(itemGroup)) : (isValid$5(maxHeight) && (isScrollbar && autoPage ? (pages = Math.ceil((startY + itemHeight) / maxHeight), doWrap = pages > 1) : maxHeight <= itemHeight ? (pages += 1, doWrap = !0, startY = 0, index > 0 && (startX += lastItemWidth + spaceCol)) : maxHeight < startY + itemHeight && (pages += 1, doWrap = !0, startY = 0, startX += maxWidthInCol + spaceCol, maxWidthInCol = 0)), 0 === startX && 0 === startY || itemGroup.setAttributes({
            x: startX,
            y: startY
          }), startY += spaceRow + itemHeight), itemsContainer.add(itemGroup), lastItemWidth = itemWidth;
        }
        return !isHorizontal || "middle" !== verticalAlign && "bottom" !== verticalAlign || lastLineItemGroup.forEach(i => {
          i.setAttributes({
            y: i.attribute.y + (lastLineHeight - i.attribute.height) / ("middle" === verticalAlign ? 2 : 1)
          });
        }), this._itemContext.doWrap = doWrap, this._itemContext.startX = startX, this._itemContext.startY = startY, this._itemContext.maxWidthInCol = maxWidthInCol, this._itemContext.pages = pages, this._itemContext.maxPages = maxPages, isScrollbar && (this._itemContext.totalPage = pages), lazyload || (this._itemContext.startIndex = legendItems.length), this._itemContext;
      }
      _renderContent() {
        const {
          item = {},
          items: items,
          reversed: reversed,
          maxWidth: maxWidth,
          maxHeight: maxHeight
        } = this.attribute;
        if (!1 === item.visible || isEmpty$1(items)) return;
        let legendItems = items;
        reversed && (legendItems = null == items ? void 0 : items.reverse()), this._contentMaxHeight = Math.max(0, maxHeight - this._parsedPadding[0] - this._parsedPadding[2]);
        const itemsContainer = graphicCreator.group({
          x: 0,
          y: 0
        });
        this._itemsContainer = itemsContainer;
        const {
            layout: layout,
            autoPage: autoPage
          } = this.attribute,
          isHorizontal = "horizontal" === layout,
          {
            maxWidth: maxItemWidth,
            width: itemWidth,
            height: itemHeight
          } = item,
          widthsOptions = [];
        isValid$5(maxItemWidth) && widthsOptions.push(maxItemWidth), isValid$5(itemWidth) && widthsOptions.push(itemWidth), widthsOptions.length && (isValid$5(maxWidth) && widthsOptions.push(maxWidth), this._itemWidthByUser = minInArray$1(widthsOptions)), isValid$5(itemHeight) && (this._itemHeightByUser = itemHeight);
        const pager = this.attribute.pager;
        this._itemContext = {
          currentPage: pager && pager.defaultCurrent || 1,
          doWrap: !1,
          maxWidthInCol: 0,
          maxPages: 1,
          pages: 1,
          startX: 0,
          startY: 0,
          startIndex: 0,
          items: legendItems,
          isHorizontal: isHorizontal,
          totalPage: 1 / 0,
          isScrollbar: pager && "scrollbar" === pager.type,
          clipContainer: void 0
        }, this._itemContext = this._renderItems();
        let pagerRendered = !1;
        this._itemContext.doWrap && autoPage && this._itemContext.pages > this._itemContext.maxPages && (pagerRendered = this._renderPagerComponent()), pagerRendered || (itemsContainer.setAttribute("y", this._title ? this._title.AABBBounds.height() + get$9(this.attribute, "title.space", 8) : 0), this._innerView.add(itemsContainer));
      }
      _bindEvents() {
        if (this.attribute.disableTriggerEvent) return;
        if (!this._itemsContainer) return;
        const {
          hover = !0,
          select = !0
        } = this.attribute;
        if (hover) {
          let trigger = "pointermove",
            triggerOff = "pointerleave";
          isObject$9(hover) && (hover.trigger && (trigger = hover.trigger), hover.triggerOff && (triggerOff = hover.triggerOff)), this._itemsContainer.addEventListener(trigger, this._onHover), this._itemsContainer.addEventListener(triggerOff, this._onUnHover);
        }
        if (select) {
          let trigger = "pointerdown";
          isObject$9(select) && select.trigger && (trigger = select.trigger), this._itemsContainer.addEventListener(trigger, this._onClick);
        }
      }
      _autoEllipsis(autoEllipsisStrategy, layoutWidth, labelShape, valueShape) {
        var _a, _b;
        const {
            label: labelAttr,
            value: valueAttr
          } = this.attribute.item,
          valueBounds = valueShape.AABBBounds,
          labelBounds = labelShape.AABBBounds,
          valueWidth = valueBounds.width(),
          labelWidth = labelBounds.width();
        let useWidthRatio = !1;
        "labelFirst" === autoEllipsisStrategy ? labelWidth > layoutWidth ? useWidthRatio = !0 : valueShape.setAttribute("maxLineWidth", layoutWidth - labelWidth) : "valueFirst" === autoEllipsisStrategy ? valueWidth > layoutWidth ? useWidthRatio = !0 : labelShape.setAttribute("maxLineWidth", layoutWidth - valueWidth) : valueWidth + labelWidth > layoutWidth && (useWidthRatio = !0), useWidthRatio && (valueShape.setAttribute("maxLineWidth", Math.max(layoutWidth * (null !== (_a = labelAttr.widthRatio) && void 0 !== _a ? _a : .5), layoutWidth - labelWidth)), labelShape.setAttribute("maxLineWidth", Math.max(layoutWidth * (null !== (_b = valueAttr.widthRatio) && void 0 !== _b ? _b : .5), layoutWidth - valueWidth)));
      }
      _renderEachItem(item, isSelected, index, items) {
        var _a, _b;
        const {
            id: id,
            label: label,
            value: value,
            shape: shape
          } = item,
          {
            padding = 0,
            focus: focus,
            focusIconStyle: focusIconStyle,
            align: align,
            autoEllipsisStrategy: autoEllipsisStrategy
          } = this.attribute.item,
          {
            shape: shapeAttr,
            label: labelAttr,
            value: valueAttr,
            background: background
          } = this.attribute.item,
          shapeStyle = this._handleStyle(shapeAttr, item, isSelected, index, items),
          labelStyle = this._handleStyle(labelAttr, item, isSelected, index, items),
          valueStyle = this._handleStyle(valueAttr, item, isSelected, index, items),
          backgroundStyle = this._handleStyle(background, item, isSelected, index, items),
          parsedPadding = normalizePadding(padding);
        let itemGroup;
        !1 === background.visible ? (itemGroup = graphicCreator.group({
          x: 0,
          y: 0,
          cursor: null === (_a = backgroundStyle.style) || void 0 === _a ? void 0 : _a.cursor
        }), this._appendDataToShape(itemGroup, LEGEND_ELEMENT_NAME.item, item, itemGroup)) : (itemGroup = graphicCreator.group(Object.assign({
          x: 0,
          y: 0
        }, backgroundStyle.style)), this._appendDataToShape(itemGroup, LEGEND_ELEMENT_NAME.item, item, itemGroup, backgroundStyle.state)), itemGroup.id = `${null != id ? id : label}-${index}`, itemGroup.addState(isSelected ? LegendStateValue.selected : LegendStateValue.unSelected);
        const innerGroup = graphicCreator.group({
          x: 0,
          y: 0,
          pickable: !1
        });
        itemGroup.add(innerGroup);
        let focusShape,
          focusStartX = 0,
          shapeSize = 0,
          shapeSpace = 0;
        if (shapeAttr && !1 !== shapeAttr.visible) {
          const s = get$9(shapeStyle, "style.size", DEFAULT_SHAPE_SIZE);
          shapeSize = isArray$9(s) ? s[0] || 0 : s, shapeSpace = get$9(shapeAttr, "space", DEFAULT_SHAPE_SPACE);
          const itemShape = graphicCreator.symbol(Object.assign(Object.assign({
            x: 0,
            y: 0,
            symbolType: "circle",
            strokeBoundsBuffer: 0
          }, shape), shapeStyle.style));
          Object.keys(shapeStyle.state || {}).forEach(key => {
            const color = shapeStyle.state[key].fill || shapeStyle.state[key].stroke;
            shape.fill && isNil$5(shapeStyle.state[key].fill) && color && (shapeStyle.state[key].fill = color), shape.stroke && isNil$5(shapeStyle.state[key].stroke) && color && (shapeStyle.state[key].stroke = color);
          }), this._appendDataToShape(itemShape, LEGEND_ELEMENT_NAME.itemShape, item, itemGroup, shapeStyle.state), itemShape.addState(isSelected ? LegendStateValue.selected : LegendStateValue.unSelected), innerGroup.add(itemShape);
        }
        let focusSpace = 0;
        if (focus) {
          const focusSize = get$9(focusIconStyle, "size", DEFAULT_SHAPE_SIZE);
          focusShape = graphicCreator.symbol(Object.assign(Object.assign({
            x: 0,
            y: -focusSize / 2 - 1,
            strokeBoundsBuffer: 0,
            boundsPadding: parsedPadding
          }, focusIconStyle), {
            visible: !0,
            pickMode: "imprecise"
          })), this._appendDataToShape(focusShape, LEGEND_ELEMENT_NAME.focus, item, itemGroup), focusSpace = focusSize;
        }
        const text = labelAttr.formatMethod ? labelAttr.formatMethod(label, item, index) : label,
          labelAttributes = Object.assign(Object.assign({
            x: shapeSize / 2 + shapeSpace,
            y: 0,
            textAlign: "start",
            textBaseline: "middle",
            lineHeight: null === (_b = labelStyle.style) || void 0 === _b ? void 0 : _b.fontSize
          }, labelStyle.style), {
            text: text,
            _originText: labelAttr.formatMethod ? label : void 0
          }),
          labelShape = createTextGraphicByType(labelAttributes);
        this._appendDataToShape(labelShape, LEGEND_ELEMENT_NAME.itemLabel, item, itemGroup, labelStyle.state), labelShape.addState(isSelected ? LegendStateValue.selected : LegendStateValue.unSelected), innerGroup.add(labelShape);
        const labelSpace = get$9(labelAttr, "space", DEFAULT_LABEL_SPACE);
        if (isValid$5(value)) {
          const valueSpace = get$9(valueAttr, "space", focus ? DEFAULT_VALUE_SPACE : 0),
            valueText = valueAttr.formatMethod ? valueAttr.formatMethod(value, item, index) : value,
            valueAttributes = Object.assign(Object.assign({
              x: 0,
              y: 0,
              textAlign: "start",
              textBaseline: "middle",
              lineHeight: valueStyle.style.fontSize
            }, valueStyle.style), {
              text: valueText,
              _originText: valueAttr.formatMethod ? value : void 0
            }),
            valueShape = createTextGraphicByType(valueAttributes);
          if (this._appendDataToShape(valueShape, LEGEND_ELEMENT_NAME.itemValue, item, itemGroup, valueStyle.state), valueShape.addState(isSelected ? LegendStateValue.selected : LegendStateValue.unSelected), this._itemWidthByUser) {
            const layoutWidth = this._itemWidthByUser - parsedPadding[1] - parsedPadding[3] - shapeSize - shapeSpace - labelSpace - focusSpace - valueSpace;
            this._autoEllipsis(autoEllipsisStrategy, layoutWidth, labelShape, valueShape), valueAttr.alignRight ? valueShape.setAttributes({
              textAlign: "right",
              x: this._itemWidthByUser - shapeSize / 2 - parsedPadding[1] - parsedPadding[3] - focusSpace - valueSpace
            }) : valueShape.setAttribute("x", labelSpace + (labelShape.AABBBounds.empty() ? 0 : labelShape.AABBBounds.x2));
          } else valueShape.setAttribute("x", labelSpace + (labelShape.AABBBounds.empty() ? 0 : labelShape.AABBBounds.x2));
          focusStartX = valueSpace + (valueShape.AABBBounds.empty() ? 0 : valueShape.AABBBounds.x2), innerGroup.add(valueShape);
        } else this._itemWidthByUser ? (labelShape.setAttribute("maxLineWidth", this._itemWidthByUser - parsedPadding[1] - parsedPadding[3] - shapeSize - shapeSpace - focusSpace), focusStartX = labelSpace + (labelShape.AABBBounds.empty() ? 0 : labelShape.AABBBounds.x2)) : focusStartX = labelSpace + (labelShape.AABBBounds.empty() ? 0 : labelShape.AABBBounds.x2);
        focusShape && (focusShape.setAttribute("x", focusStartX), innerGroup.add(focusShape));
        const innerGroupBounds = innerGroup.AABBBounds,
          innerGroupWidth = innerGroupBounds.width();
        if ("right" === align) {
          const x2 = innerGroupBounds.x2,
            x1 = innerGroupBounds.x1;
          innerGroup.forEachChildren((child, index) => {
            "symbol" !== child.type && "right" !== child.attribute.textAlign || child === focusShape ? child.setAttribute("x", x1 + x2 - child.attribute.x - child.AABBBounds.width()) : "symbol" !== child.type ? child.setAttributes({
              x: x1 + x2 - child.attribute.x,
              textAlign: "left"
            }) : child.setAttribute("x", x1 + x2 - child.attribute.x);
          });
        }
        const innerGroupHeight = innerGroupBounds.height(),
          itemGroupWidth = isValid$5(this.attribute.item.width) ? this.attribute.item.width : innerGroupWidth + parsedPadding[1] + parsedPadding[3],
          itemGroupHeight = this._itemHeightByUser || innerGroupHeight + parsedPadding[0] + parsedPadding[2];
        return itemGroup.attribute.width = itemGroupWidth, itemGroup.attribute.height = itemGroupHeight, focusShape && focusShape.setAttribute("visible", !1), innerGroup.translateTo(-innerGroupBounds.x1 + parsedPadding[3], -innerGroupBounds.y1 + parsedPadding[0]), itemGroup;
      }
      _createPager(compStyle) {
        var _a, _b;
        const {
            disableTriggerEvent: disableTriggerEvent,
            maxRow: maxRow
          } = this.attribute,
          estimateTotal = num => num <= 99 ? 99 : num <= 999 ? 999 : 9999;
        return this._itemContext.isHorizontal ? new Pager(Object.assign(Object.assign({
          layout: 1 === maxRow ? "horizontal" : "vertical",
          total: estimateTotal(this._itemContext.pages)
        }, merge$2({
          handler: {
            preShape: "triangleUp",
            nextShape: "triangleDown"
          }
        }, compStyle)), {
          defaultCurrent: null === (_a = this.attribute.pager) || void 0 === _a ? void 0 : _a.defaultCurrent,
          disableTriggerEvent: disableTriggerEvent
        })) : new Pager(Object.assign({
          layout: "horizontal",
          total: estimateTotal(this._itemContext.pages),
          disableTriggerEvent: disableTriggerEvent,
          defaultCurrent: null === (_b = this.attribute.pager) || void 0 === _b ? void 0 : _b.defaultCurrent
        }, compStyle));
      }
      _createScrollbar(compStyle, compSize) {
        const {
          disableTriggerEvent: disableTriggerEvent
        } = this.attribute;
        return this._itemContext.isHorizontal ? new ScrollBar(Object.assign(Object.assign({
          direction: "horizontal",
          disableTriggerEvent: disableTriggerEvent,
          range: [0, .5],
          height: !1 === compStyle.visible ? 0 : 12
        }, compStyle), {
          width: compSize
        })) : new ScrollBar(Object.assign(Object.assign({
          direction: "vertical",
          width: !1 === compStyle.visible ? 0 : 12,
          range: [0, .5]
        }, compStyle), {
          height: compSize,
          disableTriggerEvent: disableTriggerEvent
        }));
      }
      _updatePositionOfPager(renderStartY, compWidth, compHeight) {
        const {
            pager: pager
          } = this.attribute,
          {
            totalPage: totalPage,
            isHorizontal: isHorizontal
          } = this._itemContext,
          position = pager && pager.position || "middle";
        if (this._pagerComponent.setTotal(totalPage), isHorizontal) {
          let y;
          y = "start" === position ? renderStartY : "end" === position ? renderStartY + compHeight - this._pagerComponent.AABBBounds.height() / 2 : renderStartY + compHeight / 2 - this._pagerComponent.AABBBounds.height() / 2, this._pagerComponent.setAttributes({
            x: compWidth - this._pagerComponent.AABBBounds.width(),
            y: y
          });
        } else {
          let x;
          x = "start" === position ? 0 : "end" === position ? compWidth - this._pagerComponent.AABBBounds.width() : (compWidth - this._pagerComponent.AABBBounds.width()) / 2, this._pagerComponent.setAttributes({
            x: x,
            y: compHeight - this._pagerComponent.AABBBounds.height()
          });
        }
      }
      _computeScrollbarDelta() {
        const {
            isHorizontal: isHorizontal,
            clipContainer: clipContainer
          } = this._itemContext,
          itemContainerBounds = this._itemsContainer.AABBBounds,
          clipContainerBounds = clipContainer.AABBBounds;
        let delta, innerViewSize;
        return isHorizontal ? (innerViewSize = clipContainerBounds.width(), delta = innerViewSize / itemContainerBounds.width()) : (innerViewSize = clipContainerBounds.height(), delta = innerViewSize / itemContainerBounds.height()), delta;
      }
      _updatePositionOfScrollbar(contentWidth, contentHeight, renderStartY) {
        const {
            isHorizontal: isHorizontal,
            currentPage: currentPage,
            totalPage: totalPage
          } = this._itemContext,
          start = (currentPage - 1) / totalPage;
        this._pagerComponent.setScrollRange([start, start + this._computeScrollbarDelta()]), isHorizontal ? this._pagerComponent.setAttributes({
          x: 0,
          y: renderStartY + contentHeight
        }) : this._pagerComponent.setAttributes({
          x: contentWidth,
          y: renderStartY
        });
      }
      _bindEventsOfPager(pageSize, channel) {
        const pager = this.attribute.pager || {},
          {
            animation = !0,
            animationDuration = 450,
            animationEasing = "quadIn"
          } = pager,
          pageParser = this._itemContext.isScrollbar ? e => {
            const {
              value: value
            } = e.detail;
            let newPage;
            return newPage = 0 === value[0] ? 1 : 1 === value[1] ? this._itemContext.totalPage : value[0] * this._itemContext.totalPage + 1, newPage;
          } : e => e.detail.current,
          onScroll = e => {
            const scrollComponent = this._pagerComponent,
              preScrollRange = scrollComponent.getScrollRange(),
              {
                direction: direction
              } = scrollComponent.attribute,
              {
                width: width,
                height: height
              } = scrollComponent.getSliderRenderBounds(),
              currentScrollValue = "vertical" === direction ? e.deltaY / height : e.deltaX / width;
            scrollComponent.setScrollRange([preScrollRange[0] + currentScrollValue, preScrollRange[1] + currentScrollValue], !0), this.updateScrollMask();
          },
          onPaging = e => {
            const newPage = pageParser(e);
            if (newPage !== this._itemContext.currentPage) {
              if (this._itemContext.currentPage = newPage, this._itemContext && this._itemContext.startIndex < this._itemContext.items.length) {
                this._renderItems();
                const newTotalPage = Math.ceil(this._itemContext.pages / this._itemContext.maxPages);
                if (this._itemContext.totalPage = newTotalPage, this._itemContext.isScrollbar && this._pagerComponent) {
                  const newDelta = this._computeScrollbarDelta(),
                    [start] = this._pagerComponent.getScrollRange();
                  this._pagerComponent.setScrollRange([start, start + newDelta]);
                }
              }
              if (this._itemContext.isScrollbar) {
                const [start] = this._pagerComponent.getScrollRange();
                let containerSize;
                containerSize = this._itemContext.isHorizontal ? this._itemsContainer.AABBBounds.width() : this._itemsContainer.AABBBounds.height();
                const startOffset = containerSize * start;
                this.updateScrollMask(), animation ? this._itemsContainer.animate().to({
                  [channel]: -startOffset
                }, animationDuration, animationEasing) : this._itemsContainer.setAttribute(channel, -startOffset);
              } else animation ? this._itemsContainer.animate().to({
                [channel]: -(newPage - 1) * pageSize
              }, animationDuration, animationEasing) : this._itemsContainer.setAttribute(channel, -(newPage - 1) * pageSize);
            }
          };
        if (this._itemContext.isScrollbar) {
          if (this._pagerComponent.addEventListener("scrollDrag", onPaging), this._pagerComponent.addEventListener("scrollUp", onPaging), this.attribute.pager.roamScroll) {
            const THROTTLE_TIME = 50;
            this.addEventListener("wheel", e => e.nativeEvent.preventDefault()), this.addEventListener("wheel", throttle$1(onScroll, THROTTLE_TIME));
          }
        } else this._pagerComponent.addEventListener("toPrev", onPaging), this._pagerComponent.addEventListener("toNext", onPaging);
      }
      _renderPager() {
        const renderStartY = this._title ? this._title.AABBBounds.height() + get$9(this.attribute, "title.space", 8) : 0,
          {
            maxWidth: maxWidth,
            maxCol = 1,
            maxRow = 2,
            item = {},
            pager = {}
          } = this.attribute,
          {
            spaceCol = DEFAULT_ITEM_SPACE_COL,
            spaceRow = DEFAULT_ITEM_SPACE_ROW
          } = item,
          itemsContainer = this._itemsContainer,
          {
            space: pagerSpace = DEFAULT_PAGER_SPACE,
            defaultCurrent = 1
          } = pager,
          compStyle = __rest(pager, ["space", "defaultCurrent"]),
          {
            isHorizontal: isHorizontal
          } = this._itemContext,
          maxHeight = this._contentMaxHeight;
        let comp,
          compWidth = 0,
          compHeight = 0,
          contentWidth = 0,
          contentHeight = 0,
          startX = 0,
          startY = 0,
          pages = 1;
        if (isHorizontal) {
          if (compHeight = (maxRow - 1) * spaceRow + this._itemHeight * maxRow, compWidth = maxWidth, comp = this._createPager(compStyle), this._pagerComponent = comp, this._innerView.add(comp), contentWidth = maxWidth - comp.AABBBounds.width() - pagerSpace, contentWidth <= 0) return this._innerView.removeChild(comp), !1;
          itemsContainer.getChildren().forEach((item, index) => {
            const {
              width: width,
              height: height
            } = item.attribute;
            contentWidth < startX + width && (startX = 0, startY += height + spaceRow, pages += 1), index > 0 && item.setAttributes({
              x: startX,
              y: startY
            }), startX += spaceCol + width;
          }), this._itemContext.startX = startX, this._itemContext.startY = startY, this._itemContext.pages = pages;
          const total = Math.ceil(pages / maxRow);
          this._itemContext.totalPage = total, this._updatePositionOfPager(renderStartY, compWidth, compHeight);
        } else {
          if (compWidth = this._itemMaxWidth * maxCol + (maxCol - 1) * spaceCol, compHeight = maxHeight, contentWidth = compWidth, comp = this._createPager(compStyle), this._pagerComponent = comp, this._innerView.add(comp), contentHeight = maxHeight - comp.AABBBounds.height() - pagerSpace - renderStartY, contentHeight <= 0) return this._innerView.removeChild(comp), !1;
          itemsContainer.getChildren().forEach((item, index) => {
            const {
              height: height
            } = item.attribute;
            contentHeight < startY + height && (startY = 0, startX += this._itemMaxWidth + spaceCol, pages += 1), index > 0 && item.setAttributes({
              x: startX,
              y: startY
            }), startY += spaceRow + height;
          });
          const total = Math.ceil(pages / maxCol);
          this._itemContext.totalPage = total, this._updatePositionOfPager(renderStartY, compWidth, compHeight);
        }
        defaultCurrent > 1 && (isHorizontal ? itemsContainer.setAttribute("y", -(defaultCurrent - 1) * (compHeight + spaceRow)) : itemsContainer.setAttribute("x", -(defaultCurrent - 1) * (compWidth + spaceCol)));
        const clipGroup = graphicCreator.group({
          x: 0,
          y: renderStartY,
          width: isHorizontal ? contentWidth : compWidth,
          height: isHorizontal ? compHeight : contentHeight,
          clip: !0,
          pickable: !1
        });
        return clipGroup.add(itemsContainer), this._innerView.add(clipGroup), this._itemContext.clipContainer = clipGroup, this._bindEventsOfPager(isHorizontal ? compHeight + spaceRow : compWidth + spaceCol, isHorizontal ? "y" : "x"), !0;
      }
      _renderScrollbar() {
        var _a;
        const renderStartY = this._title ? this._title.AABBBounds.height() + get$9(this.attribute, "title.space", 8) : 0,
          {
            maxWidth: maxWidth,
            item = {},
            pager = {}
          } = this.attribute,
          {
            spaceCol = DEFAULT_ITEM_SPACE_COL,
            spaceRow = DEFAULT_ITEM_SPACE_ROW
          } = item,
          itemsContainer = this._itemsContainer,
          {
            space: pagerSpace = DEFAULT_PAGER_SPACE,
            defaultCurrent = 1
          } = pager,
          compStyle = __rest(pager, ["space", "defaultCurrent"]),
          {
            isHorizontal: isHorizontal
          } = this._itemContext,
          maxHeight = this._contentMaxHeight;
        let comp,
          contentWidth = 0,
          contentHeight = 0,
          startY = 0,
          pages = 1;
        if (isHorizontal) contentWidth = maxWidth, contentHeight = this._itemHeight, comp = this._createScrollbar(compStyle, contentWidth), this._pagerComponent = comp, this._innerView.add(comp);else {
          if (contentHeight = maxHeight - renderStartY, contentWidth = this._itemMaxWidth, comp = this._createScrollbar(compStyle, contentHeight), this._pagerComponent = comp, this._innerView.add(comp), contentHeight <= 0) return this._innerView.removeChild(comp), !1;
          const items = itemsContainer.getChildren(),
            itemsHeightArr = items.map(item => item.attribute.height);
          if (1 === itemsHeightArr.length || itemsHeightArr.every(entry => entry === itemsHeightArr[0])) {
            const itemHeight = itemsHeightArr[0],
              maxContentHeight = contentHeight,
              pageItemsCount = Math.floor(maxContentHeight / (spaceRow + itemHeight));
            contentHeight = pageItemsCount * (spaceRow + itemHeight), pages = Math.ceil(items.length / pageItemsCount);
          } else items.forEach((item, index) => {
            const {
                height: height
              } = item.attribute,
              prePages = pages,
              preStartY = startY;
            pages = Math.floor((startY + height) / contentHeight) + 1, startY += spaceRow + height, prePages !== pages && index === itemsContainer.getChildren().length - 1 && startY - contentHeight >= 1 / 3 * height && (contentHeight = preStartY + height, pages -= 1);
          });
          this._itemContext.totalPage = pages, this._itemContext.pages = pages;
        }
        if (defaultCurrent > 1) if (isHorizontal) {
          const maxOffset = this._itemsContainer.AABBBounds.width() - contentWidth;
          itemsContainer.setAttribute("x", -Math.min((defaultCurrent - 1) * (contentWidth + spaceCol), maxOffset));
        } else {
          const maxOffset = this._itemsContainer.AABBBounds.height() - contentHeight;
          itemsContainer.setAttribute("y", -Math.min((defaultCurrent - 1) * (contentHeight + spaceRow), maxOffset));
        }
        const clipGroup = graphicCreator.group({
          x: 0,
          y: renderStartY,
          width: contentWidth,
          height: contentHeight,
          clip: !0,
          pickable: !1
        });
        return clipGroup.add(itemsContainer), this._innerView.add(clipGroup), this._itemContext.clipContainer = clipGroup, this._updatePositionOfScrollbar(contentWidth, contentHeight, renderStartY), (null === (_a = pager.scrollMask) || void 0 === _a ? void 0 : _a.visible) && this.renderScrollMask(clipGroup), this._bindEventsOfPager(isHorizontal ? contentWidth : contentHeight, isHorizontal ? "x" : "y"), !0;
      }
      renderScrollMask(clipGroup) {
        const {
            scrollMask = {}
          } = this.attribute.pager,
          {
            visible = !0,
            gradientLength = 16,
            gradientStops: gradientStops
          } = scrollMask;
        if (!visible || !gradientStops) return;
        const width = clipGroup.AABBBounds.width(),
          height = clipGroup.AABBBounds.height(),
          totalLength = this._itemContext.isHorizontal ? width : height,
          startStops = gradientStops.map(stop => ({
            offset: gradientLength * stop.offset / totalLength,
            color: stop.color
          })),
          endStops = gradientStops.map(stop => ({
            offset: (totalLength - gradientLength * stop.offset) / totalLength,
            color: stop.color
          })),
          mask = graphicCreator.rect({
            x: 0,
            y: 0,
            width: width,
            height: height
          });
        this._scrollMask = mask, this._scrollMaskContext = {
          startStops: startStops,
          endStops: endStops
        }, this.updateScrollMask(), clipGroup.add(mask);
      }
      updateScrollMask() {
        if (!this._scrollMask || !this._pagerComponent) return;
        if (!this._itemContext.isScrollbar) return;
        const [start, end] = this._pagerComponent.getScrollRange(),
          stops = [];
        isNumberClose$1(clamp$3(end, 0, 1), 1) || stops.push(...this._scrollMaskContext.endStops), isNumberClose$1(clamp$3(start, 0, 1), 0) || stops.push(...this._scrollMaskContext.startStops), stops.length && (this._itemContext.isHorizontal ? this._scrollMask.setAttributes({
          fill: {
            gradient: "linear",
            x0: 0,
            y0: 0,
            x1: 1,
            y1: 0,
            stops: stops
          }
        }) : this._scrollMask.setAttributes({
          fill: {
            gradient: "linear",
            x0: 0,
            y0: 0,
            x1: 0,
            y1: 1,
            stops: stops
          }
        }));
      }
      _renderPagerComponent() {
        return this._itemContext.isScrollbar ? this._renderScrollbar() : this._renderPager(), !0;
      }
      _hover(legendItem, e) {
        this._lastActiveItem = legendItem;
        legendItem.hasState(LegendStateValue.selected) ? this._setLegendItemState(legendItem, LegendStateValue.selectedHover, e) : this._setLegendItemState(legendItem, LegendStateValue.unSelectedHover, e);
        const focusButton = legendItem.getChildren()[0].find(node => node.name === LEGEND_ELEMENT_NAME.focus, !1);
        focusButton && focusButton.setAttribute("visible", !0), this._dispatchLegendEvent(LegendEvent.legendItemHover, legendItem, e);
      }
      _unHover(legendItem, e) {
        let attributeUpdate = !1;
        (legendItem.hasState(LegendStateValue.unSelectedHover) || legendItem.hasState(LegendStateValue.selectedHover)) && (attributeUpdate = !0), legendItem.removeState(LegendStateValue.unSelectedHover), legendItem.removeState(LegendStateValue.selectedHover), legendItem.getChildren()[0].getChildren().forEach(child => {
          attributeUpdate || !child.hasState(LegendStateValue.unSelectedHover) && !child.hasState(LegendStateValue.selectedHover) || (attributeUpdate = !0), child.removeState(LegendStateValue.unSelectedHover), child.removeState(LegendStateValue.selectedHover);
        });
        const focusButton = legendItem.getChildren()[0].find(node => node.name === LEGEND_ELEMENT_NAME.focus, !1);
        focusButton && focusButton.setAttribute("visible", !1), attributeUpdate && this._dispatchLegendEvent(LegendEvent.legendItemAttributeUpdate, legendItem, e), this._dispatchLegendEvent(LegendEvent.legendItemUnHover, legendItem, e);
      }
      _setLegendItemState(legendItem, stateName, e) {
        let attributeUpdate = !1;
        legendItem.hasState(stateName) || (attributeUpdate = !0), legendItem.addState(stateName, true), legendItem.getChildren()[0].getChildren().forEach(child => {
          child.name !== LEGEND_ELEMENT_NAME.focus && (attributeUpdate || child.hasState(stateName) || (attributeUpdate = !0), child.addState(stateName, true));
        }), attributeUpdate && this._dispatchLegendEvent(LegendEvent.legendItemAttributeUpdate, legendItem, e);
      }
      _removeLegendItemState(legendItem, stateNames, e) {
        let attributeUpdate = !1;
        stateNames.forEach(name => {
          !attributeUpdate && legendItem.hasState(name) && (attributeUpdate = !0), legendItem.removeState(name);
        }), legendItem.getChildren()[0].getChildren().forEach(child => {
          child.name !== LEGEND_ELEMENT_NAME.focus && stateNames.forEach(name => {
            !attributeUpdate && child.hasState(name) && (attributeUpdate = !0), child.removeState(name);
          });
        }), attributeUpdate && this._dispatchLegendEvent(LegendEvent.legendItemAttributeUpdate, legendItem, e);
      }
      _getSelectedLegends() {
        var _a;
        const selectedData = [];
        return null === (_a = this._itemsContainer) || void 0 === _a || _a.getChildren().forEach(item => {
          item.hasState(LegendStateValue.selected) && selectedData.push(item.data);
        }), selectedData;
      }
      _appendDataToShape(shape, name, data, delegateShape) {
        let states = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
        shape.name = name, shape.data = data, shape.delegate = delegateShape, shape.states = merge$2({}, DEFAULT_STATES, states);
      }
      _dispatchLegendEvent(eventName, legendItem, event) {
        const currentSelectedItems = this._getSelectedLegends();
        currentSelectedItems.sort((pre, next) => pre.index - next.index);
        const currentSelected = currentSelectedItems.map(obj => obj.label);
        this._dispatchEvent(eventName, {
          item: legendItem,
          data: legendItem.data,
          selected: legendItem.hasState(LegendStateValue.selected),
          currentSelectedItems: currentSelectedItems,
          currentSelected: currentSelected,
          event: event
        });
      }
      _handleStyle(config, item, isSelected, index, items) {
        const newConfig = {};
        return config.style && (isFunction$7(config.style) ? newConfig.style = config.style(item, isSelected, index, items) : newConfig.style = config.style), config.state && (newConfig.state = {}, Object.keys(config.state).forEach(key => {
          config.state[key] && (isFunction$7(config.state[key]) ? newConfig.state[key] = config.state[key](item, isSelected, index, items) : newConfig.state[key] = config.state[key]);
        })), newConfig;
      }
      release() {
        super.release(), this.removeAllEventListeners();
      }
    }
    DiscreteLegend.defaultAttributes = {
      layout: "horizontal",
      title: {
        align: "start",
        space: DEFAULT_TITLE_SPACE,
        textStyle: {
          fontSize: 12,
          fontWeight: "bold",
          fill: "#2C3542"
        }
      },
      item: {
        spaceCol: DEFAULT_ITEM_SPACE_COL,
        spaceRow: DEFAULT_ITEM_SPACE_ROW,
        shape: {
          space: DEFAULT_SHAPE_SPACE,
          style: {
            size: DEFAULT_SHAPE_SIZE,
            cursor: "pointer"
          },
          state: {
            selectedHover: {
              opacity: .85
            },
            unSelected: {
              opacity: .5
            }
          }
        },
        label: {
          space: DEFAULT_LABEL_SPACE,
          style: {
            fontSize: 12,
            fill: "#2C3542",
            cursor: "pointer"
          },
          state: {
            selectedHover: {
              opacity: .85
            },
            unSelected: {
              fill: "#D8D8D8"
            }
          }
        },
        value: {
          alignRight: !1,
          style: {
            fontSize: 12,
            fill: "#ccc",
            cursor: "pointer"
          },
          state: {
            selectedHover: {
              opacity: .85
            },
            unSelected: {
              fill: "#D8D8D8"
            }
          }
        },
        background: {
          style: {
            cursor: "pointer"
          }
        },
        focus: !1,
        focusIconStyle: {
          size: DEFAULT_SHAPE_SIZE,
          symbolType: "M8 1C11.866 1 15 4.13401 15 8C15 11.866 11.866 15 8 15C4.13401 15 1 11.866 1 8C1 4.13401 4.13401 1 8 1ZM8.75044 2.55077L8.75 3.75H7.25L7.25006 2.5507C4.81247 2.88304 2.88304 4.81247 2.5507 7.25006L3.75 7.25V8.75L2.55077 8.75044C2.8833 11.1878 4.81264 13.117 7.25006 13.4493L7.25 12.25H8.75L8.75044 13.4492C11.1876 13.1167 13.1167 11.1876 13.4492 8.75044L12.25 8.75V7.25L13.4493 7.25006C13.117 4.81264 11.1878 2.8833 8.75044 2.55077ZM8 5.5C9.38071 5.5 10.5 6.61929 10.5 8C10.5 9.38071 9.38071 10.5 8 10.5C6.61929 10.5 5.5 9.38071 5.5 8C5.5 6.61929 6.61929 5.5 8 5.5ZM8 7C7.44772 7 7 7.44772 7 8C7 8.55228 7.44772 9 8 9C8.55228 9 9 8.55228 9 8C9 7.44772 8.55228 7 8 7Z",
          fill: "#333",
          cursor: "pointer"
        }
      },
      autoPage: !0,
      pager: {
        space: DEFAULT_PAGER_SPACE,
        handler: {
          style: {
            size: 10
          },
          space: 4
        }
      },
      hover: !0,
      select: !0,
      selectMode: "multiple",
      allowAllCanceled: !0
    };

    var SLIDER_ELEMENT_NAME;
    !function (SLIDER_ELEMENT_NAME) {
      SLIDER_ELEMENT_NAME.innerView = "innerView", SLIDER_ELEMENT_NAME.railContainer = "sliderRailContainer", SLIDER_ELEMENT_NAME.rail = "sliderRail", SLIDER_ELEMENT_NAME.startText = "sliderStartText", SLIDER_ELEMENT_NAME.endText = "sliderEndText", SLIDER_ELEMENT_NAME.startHandler = "sliderStartHandler", SLIDER_ELEMENT_NAME.startHandlerText = "startHandlerText", SLIDER_ELEMENT_NAME.endHandler = "sliderEndHandler", SLIDER_ELEMENT_NAME.endHandlerText = "sliderEndHandlerText", SLIDER_ELEMENT_NAME.track = "sliderTrack", SLIDER_ELEMENT_NAME.trackContainer = "sliderTrackContainer";
    }(SLIDER_ELEMENT_NAME || (SLIDER_ELEMENT_NAME = {}));

    function convertValueToRange(value) {
      return isArray$9(value) ? value : [value, value];
    }
    function getDefaultCursor(isHorizontal) {
      return isHorizontal ? "ew-resize" : "ns-resize";
    }
    loadSliderComponent();
    class Slider extends AbstractComponent {
      get track() {
        return this._track;
      }
      get currentValue() {
        return this._currentValue;
      }
      get startHandler() {
        return this._startHandler;
      }
      get endHandler() {
        return this._endHandler;
      }
      get tooltipShape() {
        return this._tooltipShape;
      }
      constructor(attributes, options) {
        super((null == options ? void 0 : options.skipDefault) ? attributes : merge$2({}, Slider.defaultAttributes, attributes)), this.name = "slider", this._isHorizontal = !0, this._startHandler = null, this._endHandler = null, this._startHandlerText = null, this._endHandlerText = null, this._currentHandler = null, this._currentValue = {}, this._onTooltipShow = e => {
          this._isChanging || this._tooltipState && this._tooltipState.isActive || (this._tooltipState ? this._tooltipState.isActive = !0 : this._tooltipState = {
            isActive: !0
          }, this._onTooltipUpdate(e), this._dispatchTooltipEvent("sliderTooltipShow"));
        }, this._onTooltipUpdate = e => {
          if (this._isChanging || !this._tooltipState || !this._tooltipState.isActive) return;
          const railLen = this._isHorizontal ? this._rail.globalAABBBounds.width() : this._rail.globalAABBBounds.height(),
            pos = clamp$3(this._isHorizontal ? (e.viewX - this._rail.globalAABBBounds.x1) / railLen : (e.viewY - this._rail.globalAABBBounds.y1) / railLen, 0, 1);
          pos !== this._tooltipState.pos && (this._tooltipState.pos = pos, this._tooltipState.value = this.calculateValueByPos(pos * railLen), this._updateTooltip(), this._dispatchTooltipEvent("sliderTooltipUpdate"));
        }, this._onTooltipHide = () => {
          const {
            tooltip: tooltip
          } = this.attribute;
          tooltip && tooltip.alwaysShow || (this._tooltipState = null, this._tooltipShape && this._tooltipShape.setAttribute("visible", !1), this._tooltipText && this._tooltipText.setAttribute("visible", !1), this._dispatchTooltipEvent("sliderTooltipHide"));
        }, this._onHandlerPointerdown = e => {
          this._clearAllDragEvents(), this._isChanging = !0;
          const {
            x: x,
            y: y
          } = this.stage.eventPointTransform(e);
          this._currentHandler = e.target, this._prePos = this._isHorizontal ? x : y;
          const triggers = getEndTriggersOfDrag(),
            obj = "browser" === vglobal.env ? vglobal : this.stage;
          obj.addEventListener("pointermove", this._onHandlerPointerMove, {
            capture: !0
          }), triggers.forEach(trigger => {
            obj.addEventListener(trigger, this._onHandlerPointerUp);
          });
        }, this._onHandlerPointerMove = e => {
          var _a, _b;
          this._isChanging = !0;
          const {
            railWidth: railWidth,
            railHeight: railHeight,
            min: min,
            max: max
          } = this.attribute;
          if (max === min) return;
          const {
            x: x,
            y: y
          } = this.stage.eventPointTransform(e);
          let currentPos,
            originPos,
            railLen,
            delta = 0;
          this._isHorizontal ? (currentPos = x, delta = currentPos - this._prePos, originPos = null === (_b = this._currentHandler) || void 0 === _b ? void 0 : _b.attribute.x, railLen = railWidth) : (currentPos = y, delta = currentPos - this._prePos, originPos = null === (_a = this._currentHandler) || void 0 === _a ? void 0 : _a.attribute.y, railLen = railHeight);
          const newPos = clamp$3(originPos + delta, 0, railLen),
            currentValue = this.calculateValueByPos(newPos);
          "text" === this._currentHandler.type ? this._updateHandlerText(this._currentHandler, newPos, currentValue) : this._updateHandler(this._currentHandler, newPos, currentValue), this._updateTrack(), this._prePos = currentPos, this._dispatchChangeEvent();
        }, this._onHandlerPointerUp = e => {
          this._isChanging = !1, this._currentHandler = null, this._clearAllDragEvents();
        }, this._handleTouchMove = e => {
          this._isChanging && e.preventDefault();
        }, this._onTrackPointerdown = e => {
          this._clearAllDragEvents(), this._isChanging = !0;
          const {
            x: x,
            y: y
          } = this.stage.eventPointTransform(e);
          this._prePos = this._isHorizontal ? x : y;
          const triggers = getEndTriggersOfDrag(),
            obj = "browser" === vglobal.env ? vglobal : this.stage;
          obj.addEventListener("pointermove", this._onTrackPointerMove, {
            capture: !0
          }), triggers.forEach(trigger => {
            obj.addEventListener(trigger, this._onTrackPointerUp);
          });
        }, this._onTrackPointerMove = e => {
          this._isChanging = !0;
          const {
            railWidth: railWidth,
            railHeight: railHeight,
            min: min,
            max: max,
            inverse: inverse
          } = this.attribute;
          if (max === min) return;
          const {
            startHandler: startHandler,
            endHandler: endHandler
          } = this._getHandlers();
          let currentPos, trackLen, railLen;
          const {
            x: x,
            y: y
          } = this.stage.eventPointTransform(e);
          this._isHorizontal ? (currentPos = x, trackLen = this._track.attribute.width, railLen = railWidth) : (currentPos = y, trackLen = this._track.attribute.height, railLen = railHeight);
          const delta = currentPos - this._prePos;
          if (startHandler) {
            const originPos = this._isHorizontal ? startHandler.attribute.x : startHandler.attribute.y,
              newPos = inverse ? clamp$3(originPos + delta, trackLen, railLen) : clamp$3(originPos + delta, 0, railLen - trackLen),
              currentValue = this.calculateValueByPos(newPos);
            this._updateHandler(startHandler, newPos, currentValue);
          }
          if (endHandler) {
            const originPos = this._isHorizontal ? endHandler.attribute.x : endHandler.attribute.y,
              newPos = inverse ? clamp$3(originPos + delta, 0, railLen - trackLen) : clamp$3(originPos + delta, trackLen, railLen),
              currentValue = this.calculateValueByPos(newPos),
              startHandlerAttribute = null == startHandler ? void 0 : startHandler.attribute;
            this._updateHandler(endHandler, newPos, currentValue), this._track.setAttributes(this._isHorizontal ? {
              x: Math.min(startHandlerAttribute.x, endHandler.attribute.x),
              width: Math.abs(startHandlerAttribute.x - endHandler.attribute.x)
            } : {
              y: Math.min(startHandlerAttribute.y, endHandler.attribute.y),
              height: Math.abs(startHandlerAttribute.y - endHandler.attribute.y)
            });
          }
          this._prePos = currentPos, this._dispatchChangeEvent();
        }, this._onTrackPointerUp = e => {
          this._isChanging = !1, this._clearAllDragEvents();
        }, this._onRailPointerDown = e => {
          this._clearAllDragEvents(), this._isChanging = !0;
          const {
            railWidth: railWidth,
            railHeight: railHeight,
            min: min,
            max: max
          } = this.attribute;
          if (max === min) return;
          const startHandler = this._startHandler,
            endHandler = this._endHandler;
          let currentPos, startHandlerPos, endHandlerPos;
          this._isHorizontal ? (currentPos = e.viewX - this._rail.globalAABBBounds.x1, startHandlerPos = null == startHandler ? void 0 : startHandler.attribute.x, endHandlerPos = null == endHandler ? void 0 : endHandler.attribute.x, railWidth) : (currentPos = e.viewY - this._rail.globalAABBBounds.y1, startHandlerPos = null == startHandler ? void 0 : startHandler.attribute.y, endHandlerPos = null == endHandler ? void 0 : endHandler.attribute.y, railHeight);
          const currentValue = this.calculateValueByPos(currentPos);
          if (isValid$5(endHandlerPos)) {
            const updateHandler = Math.abs(currentPos - startHandlerPos) > Math.abs(currentPos - endHandlerPos) ? endHandler : startHandler;
            this._updateHandler(updateHandler, currentPos, currentValue);
          } else this._updateHandler(startHandler, currentPos, currentValue);
          this._updateTrack(), this._dispatchChangeEvent();
        };
      }
      calculatePosByValue(value, pos) {
        const {
          layout: layout,
          railWidth: railWidth,
          railHeight: railHeight,
          min: min,
          max: max,
          inverse: inverse
        } = this.attribute;
        let ratio = 0;
        ratio = min === max ? "start" === pos ? 0 : "end" === pos ? 1 : 0 : (value - min) / (max - min);
        return (inverse ? 1 - ratio : ratio) * ("vertical" === layout ? railHeight : railWidth);
      }
      calculateValueByPos(pos) {
        const {
            layout: layout,
            railWidth: railWidth,
            railHeight: railHeight,
            min: min,
            max: max,
            inverse: inverse
          } = this.attribute,
          railLen = "vertical" === layout ? railHeight : railWidth;
        return min + (max - min) * (inverse ? 1 - pos / railLen : pos / railLen);
      }
      setValue(value) {
        const {
          min: min,
          max: max
        } = this.attribute;
        if (max === min) return;
        const [startValue, endValue] = array$1(value),
          {
            startHandler: startHandler,
            endHandler: endHandler
          } = this._getHandlers();
        startHandler && this._updateHandler(startHandler, this.calculatePosByValue(startValue), startValue), endHandler && this._updateHandler(endHandler, this.calculatePosByValue(endValue), endValue), this._updateTrack();
      }
      render() {
        var _a, _b;
        this.removeAllChild(!0);
        const {
          layout = "horizontal",
          railWidth: railWidth,
          railHeight: railHeight,
          startText: startText,
          endText: endText,
          min: min,
          max: max,
          showHandler = !0,
          showTooltip: showTooltip
        } = this.attribute;
        let {
          value: value
        } = this.attribute;
        isNil$5(value) && (value = [min, max]), this._currentValue = {
          startValue: convertValueToRange(value)[0],
          endValue: convertValueToRange(value)[1]
        };
        const isHorizontal = "horizontal" === layout;
        this._isHorizontal = isHorizontal;
        const innerView = graphicCreator.group({
          x: 0,
          y: 0
        });
        innerView.name = SLIDER_ELEMENT_NAME.innerView, this.add(innerView), this._innerView = innerView;
        let startTextShape,
          startLen = 0;
        if (startText && startText.visible) {
          startTextShape = graphicCreator.text(Object.assign({
            x: isHorizontal ? 0 : railWidth / 2,
            y: isHorizontal ? railHeight / 2 : 0,
            textAlign: isHorizontal ? "start" : "center",
            textBaseline: isHorizontal ? "middle" : "top",
            text: startText.text,
            lineHeight: null === (_a = startText.style) || void 0 === _a ? void 0 : _a.fontSize
          }, startText.style)), startTextShape.name = SLIDER_ELEMENT_NAME.startText, innerView.add(startTextShape);
          const space = isValid$5(startText.space) ? startText.space : 0;
          startLen += (isHorizontal ? startTextShape.AABBBounds.width() : startTextShape.AABBBounds.height()) + space;
        }
        const mainContainer = graphicCreator.group({
          x: isHorizontal ? startLen : 0,
          y: isHorizontal ? 0 : startLen
        });
        innerView.add(mainContainer);
        const railContainer = graphicCreator.group({
          x: 0,
          y: 0
        });
        let endTextShape;
        if (railContainer.name = SLIDER_ELEMENT_NAME.railContainer, this._railContainer = railContainer, mainContainer.add(railContainer), this._mainContainer = mainContainer, this._renderRail(railContainer), startLen += isHorizontal ? railWidth : railHeight, endText && endText.visible) {
          const space = isValid$5(endText.space) ? endText.space : 0;
          endTextShape = graphicCreator.text(Object.assign({
            x: isHorizontal ? startLen + space : railWidth / 2,
            y: isHorizontal ? railHeight / 2 : startLen + space,
            textAlign: isHorizontal ? "start" : "center",
            textBaseline: isHorizontal ? "middle" : "top",
            text: endText.text,
            lineHeight: null === (_b = endText.style) || void 0 === _b ? void 0 : _b.fontSize
          }, endText.style)), endTextShape.name = SLIDER_ELEMENT_NAME.endText, innerView.add(endTextShape);
        }
        this._renderTrack(railContainer), showHandler && (this._renderHandlers(mainContainer), this._bindEvents()), showTooltip && (this._renderTooltip(), this._bindTooltipEvents());
      }
      _renderRail(container) {
        const {
          railWidth: railWidth,
          railHeight: railHeight,
          railStyle: railStyle,
          slidable: slidable
        } = this.attribute;
        let cursor = "default";
        !1 !== slidable && (cursor = "pointer");
        const railShape = graphicCreator.rect(Object.assign({
          x: 0,
          y: 0,
          width: railWidth,
          height: railHeight,
          cursor: cursor
        }, railStyle));
        return railShape.name = SLIDER_ELEMENT_NAME.rail, container.add(railShape), this._rail = railShape, railShape;
      }
      _renderHandlers(container) {
        const {
          range: range,
          min: min,
          max: max,
          handlerSize = 14,
          handlerStyle: handlerStyle,
          handlerText: handlerText,
          railHeight: railHeight,
          railWidth: railWidth,
          slidable: slidable
        } = this.attribute;
        let {
          value: value
        } = this.attribute;
        isNil$5(value) && (value = [min, max]);
        const handlerTextVisible = handlerText && handlerText.visible,
          isHorizontal = this._isHorizontal,
          [startValue, endValue] = convertValueToRange(value),
          startPos = this.calculatePosByValue(startValue, range ? "start" : "end"),
          startHandler = this._renderHandler(Object.assign({
            x: isHorizontal ? startPos : railWidth / 2,
            y: isHorizontal ? railHeight / 2 : startPos,
            size: handlerSize,
            strokeBoundsBuffer: 0,
            cursor: !1 === slidable ? "default" : getDefaultCursor(isHorizontal)
          }, handlerStyle));
        if (startHandler.name = SLIDER_ELEMENT_NAME.startHandler, this._startHandler = startHandler, container.add(startHandler), this._currentValue.startPos = startPos, handlerTextVisible) {
          const startHandlerText = this._renderHandlerText(startValue, range ? "start" : "end");
          startHandlerText.name = SLIDER_ELEMENT_NAME.startHandlerText, container.add(startHandlerText), this._startHandlerText = startHandlerText;
        }
        if (range) {
          const endPos = this.calculatePosByValue(endValue, "end"),
            endHandler = this._renderHandler(Object.assign({
              x: isHorizontal ? endPos : railWidth / 2,
              y: isHorizontal ? railHeight / 2 : endPos,
              size: handlerSize,
              strokeBoundsBuffer: 0,
              cursor: !1 === slidable ? "default" : getDefaultCursor(isHorizontal)
            }, handlerStyle));
          if (endHandler.name = SLIDER_ELEMENT_NAME.endHandler, this._endHandler = endHandler, container.add(endHandler), this._currentValue.endPos = endPos, handlerTextVisible) {
            const endHandlerText = this._renderHandlerText(endValue, "end");
            endHandlerText.name = SLIDER_ELEMENT_NAME.endHandlerText, container.add(endHandlerText), this._endHandlerText = endHandlerText;
          }
        }
      }
      _renderTrack(container) {
        const {
          range: range,
          min: min,
          max: max,
          railHeight: railHeight,
          railWidth: railWidth,
          trackStyle: trackStyle,
          railStyle: railStyle,
          slidable: slidable,
          value: value
        } = this.attribute;
        let startValue, endValue;
        if (isNil$5(value)) range ? (startValue = min, endValue = max) : startValue = endValue = min;else if (range) {
          const clampValue = clampRange$1(value, min, max);
          startValue = clampValue[0], endValue = clampValue[1];
        } else startValue = min, endValue = clamp$3(value, min, max);
        const isHorizontal = this._isHorizontal;
        range || (startValue = min);
        const trackContainer = graphicCreator.group({
          x: 0,
          y: 0,
          width: railWidth,
          height: railHeight,
          cornerRadius: null == railStyle ? void 0 : railStyle.cornerRadius,
          clip: !0,
          pickable: !1
        });
        trackContainer.name = SLIDER_ELEMENT_NAME.trackContainer;
        const draggableTrack = isObject$9(range) && !0 === range.draggableTrack;
        let cursor;
        cursor = !1 === slidable ? "default" : !1 === range || !1 === draggableTrack ? "pointer" : getDefaultCursor(isHorizontal);
        const startPos = this.calculatePosByValue(startValue, "start"),
          endPos = this.calculatePosByValue(endValue, range ? "end" : "start"),
          track = graphicCreator.rect(Object.assign({
            x: isHorizontal ? Math.min(startPos, endPos) : 0,
            y: isHorizontal ? 0 : Math.min(startPos, endPos),
            width: isHorizontal ? Math.abs(endPos - startPos) : railWidth,
            height: isHorizontal ? railHeight : Math.abs(endPos - startPos),
            cursor: cursor
          }, trackStyle));
        track.name = SLIDER_ELEMENT_NAME.track, this._track = track, trackContainer.add(track), container.add(trackContainer);
      }
      _renderHandler(style) {
        return graphicCreator.symbol(style);
      }
      _renderHandlerText(value, position) {
        var _a, _b, _c;
        const {
            align: align,
            handlerSize = 14,
            handlerText = {},
            railHeight: railHeight,
            railWidth: railWidth,
            slidable: slidable
          } = this.attribute,
          isHorizontal = this._isHorizontal,
          pos = this.calculatePosByValue(value, position),
          textSpace = null !== (_a = handlerText.space) && void 0 !== _a ? _a : 4,
          textStyle = {
            text: handlerText.formatter ? handlerText.formatter(value) : value.toFixed(null !== (_b = handlerText.precision) && void 0 !== _b ? _b : 0),
            lineHeight: null === (_c = handlerText.style) || void 0 === _c ? void 0 : _c.lineHeight,
            cursor: !1 === slidable ? "default" : getDefaultCursor(isHorizontal)
          };
        isHorizontal ? "top" === align ? (textStyle.textBaseline = "bottom", textStyle.textAlign = "center", textStyle.x = pos, textStyle.y = (railHeight - handlerSize) / 2 - textSpace) : (textStyle.textBaseline = "top", textStyle.textAlign = "center", textStyle.x = pos, textStyle.y = (railHeight + handlerSize) / 2 + textSpace) : "left" === align ? (textStyle.textBaseline = "middle", textStyle.textAlign = "end", textStyle.x = (railWidth - handlerSize) / 2 - textSpace, textStyle.y = pos) : (textStyle.textBaseline = "middle", textStyle.textAlign = "start", textStyle.x = (railWidth + handlerSize) / 2 + textSpace, textStyle.y = pos);
        return graphicCreator.text(Object.assign(Object.assign({}, textStyle), handlerText.style));
      }
      _renderTooltip() {
        var _a;
        const {
          tooltip: tooltip,
          railHeight: railHeight,
          railWidth: railWidth,
          align: align
        } = this.attribute;
        tooltip && tooltip.alwaysShow ? this._tooltipState = {
          value: this._currentValue.startValue,
          pos: this._currentValue.startPos
        } : this._tooltipState = null;
        const cx = this._isHorizontal ? 0 : railWidth / 2,
          cy = this._isHorizontal ? railHeight / 2 : 0;
        if (tooltip && tooltip.shape) {
          const shape = graphicCreator.symbol(Object.assign({
            pickable: !1,
            visible: !!this._tooltipState,
            x: cx,
            y: cy,
            symbolType: "circle"
          }, tooltip.shapeStyle));
          this._tooltipShape = shape, this._mainContainer.add(shape);
        }
        const textConfig = tooltip && tooltip.text || {},
          space = null !== (_a = textConfig.space) && void 0 !== _a ? _a : 6,
          textStyle = {
            pickable: !1,
            visible: !!this._tooltipState,
            text: ""
          };
        this._isHorizontal ? (textStyle.x = cx, textStyle.y = "top" === align ? cy - railHeight / 2 - space : cy + railHeight / 2 + space, textStyle.textAlign = "center", textStyle.textBaseline = "top" === align ? "bottom" : "top") : (textStyle.y = cy, textStyle.x = "left" === align ? cx - railWidth / 2 - space : cy + railWidth / 2 + space, textStyle.textAlign = "left" === align ? "end" : "start", textStyle.textBaseline = "middle");
        const text = graphicCreator.text(Object.assign(Object.assign({}, textStyle), textConfig.style));
        this._mainContainer.add(text), this._tooltipText = text, this._tooltipState && this._updateTooltip();
      }
      _updateTooltip() {
        var _a, _b;
        if (!this._tooltipShape && !this._tooltipText || !this._tooltipState) return;
        const {
            railWidth: railWidth,
            railHeight: railHeight
          } = this.attribute,
          railLen = this._isHorizontal ? railWidth : railHeight,
          coord = this._tooltipState.pos * railLen,
          coordKey = this._isHorizontal ? "x" : "y";
        this._tooltipShape && this._tooltipShape.setAttributes({
          visible: !0,
          [coordKey]: coord
        });
        const {
          align: align
        } = this.attribute;
        if (this._tooltipText) {
          const textConfig = this.attribute.tooltip && this.attribute.tooltip.text || {};
          this._tooltipText.setAttributes({
            visible: !0,
            [coordKey]: coord,
            text: textConfig.formatter ? textConfig.formatter(this._tooltipState.value) : this._isHorizontal || "left" !== align ? `≈ ${this._tooltipState.value.toFixed(null !== (_b = textConfig.precision) && void 0 !== _b ? _b : 0)}` : `${this._tooltipState.value.toFixed(null !== (_a = textConfig.precision) && void 0 !== _a ? _a : 0)} ≈`
          });
        }
      }
      _bindEvents() {
        if (this.attribute.disableTriggerEvent) return;
        const {
          slidable: slidable,
          range: range
        } = this.attribute;
        slidable && (this._startHandler && this._startHandler.addEventListener("pointerdown", this._onHandlerPointerdown), this._startHandlerText && this._startHandlerText.addEventListener("pointerdown", this._onHandlerPointerdown), this._endHandler && this._endHandler.addEventListener("pointerdown", this._onHandlerPointerdown), this._endHandlerText && this._endHandlerText.addEventListener("pointerdown", this._onHandlerPointerdown), isObject$9(range) && range.draggableTrack && this._track.addEventListener("pointerdown", this._onTrackPointerdown), this._railContainer.addEventListener("pointerdown", this._onRailPointerDown), ("browser" === vglobal.env ? vglobal : this.stage).addEventListener("touchmove", this._handleTouchMove, {
          passive: !1
        }));
      }
      _bindTooltipEvents() {
        this.attribute.disableTriggerEvent || (this._mainContainer.addEventListener("pointerenter", this._onTooltipShow), this._mainContainer.addEventListener("pointermove", this._onTooltipUpdate), this._mainContainer.addEventListener("pointerleave", this._onTooltipHide));
      }
      _clearAllDragEvents() {
        const triggers = getEndTriggersOfDrag(),
          obj = "browser" === vglobal.env ? vglobal : this.stage;
        obj.removeEventListener("pointermove", this._onHandlerPointerMove, {
          capture: !0
        }), triggers.forEach(trigger => {
          obj.removeEventListener(trigger, this._onHandlerPointerUp);
        }), obj.removeEventListener("pointermove", this._onTrackPointerMove, {
          capture: !0
        }), triggers.forEach(trigger => {
          obj.removeEventListener(trigger, this._onTrackPointerUp);
        });
      }
      _updateTrack() {
        const {
            inverse: inverse,
            railWidth: railWidth,
            railHeight: railHeight
          } = this.attribute,
          startHandler = this._startHandler,
          endHandler = this._endHandler;
        if (this._isHorizontal) {
          const startHandlerPos = null == startHandler ? void 0 : startHandler.attribute.x;
          if (endHandler) {
            const endHandlerPos = null == endHandler ? void 0 : endHandler.attribute.x;
            this._track.setAttributes({
              x: Math.min(startHandlerPos, endHandlerPos),
              width: Math.abs(startHandlerPos - endHandlerPos)
            });
          } else inverse ? this._track.setAttributes({
            x: startHandlerPos,
            width: railWidth - startHandlerPos
          }) : this._track.setAttributes({
            width: startHandlerPos
          });
        } else {
          const startHandlerPos = null == startHandler ? void 0 : startHandler.attribute.y;
          if (endHandler) {
            const endHandlerPos = null == endHandler ? void 0 : endHandler.attribute.y;
            this._track.setAttributes({
              y: Math.min(startHandlerPos, endHandlerPos),
              height: Math.abs(startHandlerPos - endHandlerPos)
            });
          } else inverse ? this._track.setAttributes({
            y: startHandlerPos,
            height: railHeight - startHandlerPos
          }) : this._track.setAttributes({
            height: startHandlerPos
          });
        }
      }
      _updateHandler(handler, position, value) {
        var _a;
        const isHorizontal = this._isHorizontal;
        handler.setAttribute(isHorizontal ? "x" : "y", position);
        const updateHandlerText = handler.name === SLIDER_ELEMENT_NAME.startHandler ? this._startHandlerText : this._endHandlerText;
        if (updateHandlerText) {
          const {
            handlerText = {}
          } = this.attribute;
          updateHandlerText.setAttributes({
            text: handlerText.formatter ? handlerText.formatter(value) : value.toFixed(null !== (_a = handlerText.precision) && void 0 !== _a ? _a : 0),
            [isHorizontal ? "x" : "y"]: position
          });
        }
        handler.name === SLIDER_ELEMENT_NAME.startHandler ? (this._currentValue.startValue = value, this._currentValue.startPos = position) : (this._currentValue.endValue = value, this._currentValue.endPos = position);
      }
      _updateHandlerText(handlerText, position, value) {
        var _a;
        const isHorizontal = this._isHorizontal,
          {
            handlerText: handlerTextAttr = {}
          } = this.attribute;
        handlerText.setAttributes({
          [isHorizontal ? "x" : "y"]: position,
          text: handlerTextAttr.formatter ? handlerTextAttr.formatter(value) : value.toFixed(null !== (_a = handlerTextAttr.precision) && void 0 !== _a ? _a : 0)
        });
        const updateHandler = handlerText.name === SLIDER_ELEMENT_NAME.startHandlerText ? this._startHandler : this._endHandler;
        updateHandler && updateHandler.setAttributes({
          [isHorizontal ? "x" : "y"]: position
        }), handlerText.name === SLIDER_ELEMENT_NAME.startHandlerText ? (this._currentValue.startValue = value, this._currentValue.startPos = position) : (this._currentValue.endValue = value, this._currentValue.endPos = position);
      }
      _dispatchChangeEvent() {
        const isRange = !!this.attribute.range,
          currentValue = this._currentValue;
        this._dispatchEvent("change", {
          value: isRange ? [Math.min(currentValue.endValue, currentValue.startValue), Math.max(currentValue.endValue, currentValue.startValue)] : currentValue.startValue,
          position: isRange ? [Math.min(currentValue.endPos, currentValue.startPos), Math.max(currentValue.endPos, currentValue.startPos)] : currentValue.startPos
        });
      }
      _dispatchTooltipEvent(type) {
        this._dispatchEvent("sliderTooltip", {
          type: type,
          position: this._tooltipState && this._tooltipState.pos,
          value: this._tooltipState && this._tooltipState.value
        });
      }
      _getHandlers() {
        const {
          inverse: inverse
        } = this.attribute;
        let startHandler = this._startHandler,
          endHandler = this._endHandler;
        return endHandler ? (this._isHorizontal ? (!inverse && endHandler.attribute.x < (null == startHandler ? void 0 : startHandler.attribute.x) || inverse && endHandler.attribute.x > (null == startHandler ? void 0 : startHandler.attribute.x)) && ([startHandler, endHandler] = [endHandler, startHandler]) : (!inverse && endHandler.attribute.y < (null == startHandler ? void 0 : startHandler.attribute.y) || inverse && endHandler.attribute.y > (null == startHandler ? void 0 : startHandler.attribute.y)) && ([startHandler, endHandler] = [endHandler, startHandler]), {
          startHandler: startHandler,
          endHandler: endHandler
        }) : {
          startHandler: startHandler,
          endHandler: endHandler
        };
      }
      release(all) {
        super.release(all), ("browser" === vglobal.env ? vglobal : this.stage).addEventListener("touchmove", this._handleTouchMove, {
          passive: !1
        }), this._clearAllDragEvents();
      }
    }
    Slider.defaultAttributes = {
      slidable: !0,
      layout: "horizontal",
      align: "bottom",
      height: 8,
      showHandler: !0,
      handlerSize: 14,
      handlerStyle: {
        symbolType: "circle",
        fill: "#fff",
        stroke: "#91caff",
        lineWidth: 2
      },
      tooltip: {
        shapeStyle: {
          symbolType: "circle",
          fill: "#fff",
          stroke: "#91caff",
          lineWidth: 2
        },
        text: {
          style: {
            fill: "#2C3542",
            fontSize: 12
          }
        }
      },
      railStyle: {
        fill: "rgba(0,0,0,.04)"
      },
      trackStyle: {
        fill: "#91caff"
      },
      showValue: !0,
      valueStyle: {
        fill: "#2C3542",
        fontSize: 12
      },
      startText: {
        style: {
          fill: "#2C3542",
          fontSize: 12
        }
      },
      endText: {
        style: {
          fill: "#2C3542",
          fontSize: 12
        }
      },
      handlerText: {
        visible: !0,
        space: 4,
        precision: 0,
        style: {
          fill: "#2C3542",
          fontSize: 12
        }
      }
    };

    loadColorContinuousLegendComponent();
    class ColorContinuousLegend extends LegendBase {
      constructor(attributes, options) {
        super((null == options ? void 0 : options.skipDefault) ? attributes : merge$2({}, ColorContinuousLegend.defaultAttributes, attributes)), this.name = "colorLegend", this._onSliderToolipChange = e => {
          const tooltipShape = this._slider.tooltipShape;
          if (tooltipShape && e.detail && !isNil$5(e.detail.value)) {
            const color = this._colorScale.scale(e.detail.value);
            tooltipShape.setAttribute("fill", color);
          }
          this.dispatchEvent(e);
        }, this._onSliderChange = e => {
          this._updateColor(), this.dispatchEvent(e);
        };
      }
      setSelected(value) {
        this._slider && (this._slider.setValue(value), this._updateColor());
      }
      _renderContent() {
        const {
            colors: colors,
            slidable: slidable,
            layout: layout,
            align: align,
            min: min,
            max: max,
            value: value,
            railWidth: railWidth,
            railHeight: railHeight,
            showHandler = !0,
            handlerSize: handlerSize,
            handlerStyle: handlerStyle,
            railStyle: railStyle,
            trackStyle: trackStyle,
            startText: startText,
            endText: endText,
            handlerText: handlerText,
            showTooltip: showTooltip,
            tooltip: tooltip,
            inverse: inverse,
            disableTriggerEvent: disableTriggerEvent
          } = this.attribute,
          domain = [],
          step = (max - min) / (colors.length - 1);
        for (let i = 0; i < colors.length; i++) domain.push(min + step * i);
        this._colorScale = new LinearScale$1().domain(domain, !0).range(colors), this._color = this._getTrackColor();
        const slider = new Slider({
          x: 0,
          y: 0,
          range: {
            draggableTrack: !0
          },
          slidable: slidable,
          layout: layout,
          align: align,
          min: min,
          max: max,
          value: value,
          railWidth: railWidth,
          railHeight: railHeight,
          showHandler: showHandler,
          handlerSize: handlerSize,
          handlerStyle: handlerStyle,
          railStyle: railStyle,
          trackStyle: Object.assign({
            fill: this._color
          }, trackStyle),
          startText: startText,
          endText: endText,
          handlerText: handlerText,
          showTooltip: showTooltip,
          tooltip: tooltip,
          disableTriggerEvent: disableTriggerEvent,
          inverse: inverse
        });
        this._innerView.add(slider), this._slider = slider, slider.translateTo(0 - slider.AABBBounds.x1, (this._title ? this._title.AABBBounds.height() + get$9(this.attribute, "title.space", DEFAULT_TITLE_SPACE) : 0) - slider.AABBBounds.y1), this._updateColor();
      }
      _bindEvents() {
        this.attribute.disableTriggerEvent || this._slider && (this._slider.addEventListener("change", this._onSliderChange), this._slider.addEventListener("sliderTooltip", this._onSliderToolipChange));
      }
      _getTrackColor() {
        const {
          colors: colors,
          layout: layout,
          inverse: inverse
        } = this.attribute;
        if (isEmpty$1(colors)) return;
        const count = colors.length;
        if (1 === count) return colors[0];
        const stops = [];
        for (let i = 0; i < count; i++) {
          const percent = i / (count - 1);
          stops.push({
            offset: percent,
            color: colors[i]
          });
        }
        const isHorizontal = "horizontal" === layout,
          res = {
            gradient: "linear",
            stops: stops,
            x0: 0,
            y0: 0,
            x1: isHorizontal ? 1 : 0,
            y1: isHorizontal ? 0 : 1
          };
        return inverse && (isHorizontal ? (res.x0 = 1, res.x1 = 0) : (res.y0 = 1, res.y1 = 0)), res;
      }
      _updateColor() {
        var _a;
        const {
            layout = "horizontal",
            colors: colors,
            railWidth: railWidth,
            railHeight: railHeight
          } = this.attribute,
          {
            startHandler: startHandler,
            endHandler: endHandler,
            track: track,
            attribute: attribute
          } = this._slider,
          {
            startValue: startValue,
            endValue: endValue,
            startPos: startPos,
            endPos: endPos
          } = this._slider.currentValue,
          handlerColor = null === (_a = attribute.handlerStyle) || void 0 === _a ? void 0 : _a.fill;
        if (startHandler && !handlerColor) {
          const startHandlerColor = this._colorScale.scale(startValue);
          startHandler.setAttribute("fill", startHandlerColor);
        }
        if (endHandler && !handlerColor) {
          const endHandlerColor = this._colorScale.scale(endValue);
          endHandler.setAttribute("fill", endHandlerColor);
        }
        const railLen = "horizontal" === layout ? railWidth : railHeight;
        if (Math.abs(startPos - endPos) !== railLen && colors && colors.length > 1) {
          const stops = this._color.stops,
            start = Math.min(startPos, endPos),
            end = Math.max(startPos, endPos),
            startRatio = start / railLen,
            endRatio = end / railLen,
            range = endRatio - startRatio,
            betweenStops = stops.filter(stop => stop.offset > startRatio && stop.offset < endRatio),
            minValue = Math.min(startValue, endValue),
            maxValue = Math.max(startValue, endValue),
            startColor = this._colorScale.scale(minValue),
            endColor = this._colorScale.scale(maxValue),
            newStops = [{
              offset: 0,
              color: startColor
            }];
          betweenStops.forEach(stop => {
            newStops.push({
              offset: (stop.offset - startRatio) / range,
              color: stop.color
            });
          }), newStops.push({
            offset: 1,
            color: endColor
          }), track.setAttribute("fill", Object.assign(Object.assign({}, this._color), {
            stops: newStops
          }));
        }
      }
    }
    ColorContinuousLegend.defaultAttributes = {
      layout: "horizontal",
      title: {
        align: "start",
        space: DEFAULT_TITLE_SPACE,
        textStyle: {
          fontSize: 12,
          fontWeight: "bold",
          fill: "rgba(46, 47, 50, 1)"
        }
      },
      handlerSize: 10,
      handlerStyle: {
        fill: null,
        lineWidth: 4,
        stroke: "#fff",
        outerBorder: {
          distance: 2,
          lineWidth: 1,
          stroke: "#ccc"
        }
      },
      tooltip: {
        shapeStyle: {
          lineWidth: 4,
          stroke: "#fff"
        }
      }
    };

    function getSizeHandlerPath() {
      let align = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "bottom";
      let centerX = 0;
      return "top" === align ? `\n    M${centerX},-6L${centerX - 3.5},-2.5\n    v5\n    h7\n    v-5\n    Z\n` : "left" === align ? (centerX = 1, `\n    M${centerX - 6},0L${centerX - 6 + 2.5},-3.5\n    h5\n    v7\n    h-5\n    Z\n`) : "right" === align ? (centerX = -1, `\n    M${centerX + 6},0L${centerX + 6 - 2.5},-3.5\n    h-5\n    v7\n    h5\n    Z\n  `) : `\n    M${centerX},6L${centerX - 3.5},2.5\n    v-5\n    h7\n    v5\n    Z\n`;
    }

    loadSizeContinuousLegendComponent();
    class SizeContinuousLegend extends LegendBase {
      constructor(attributes, options) {
        super((null == options ? void 0 : options.skipDefault) ? attributes : merge$2({}, SizeContinuousLegend.defaultAttributes, attributes)), this.name = "sizeLegend", this._onSliderChange = e => {
          this.dispatchEvent(e);
        }, this._onSliderToolipChange = e => {
          this.dispatchEvent(e);
        };
      }
      setSelected(value) {
        this._slider && this._slider.setValue(value);
      }
      _renderContent() {
        const {
            slidable: slidable,
            layout: layout,
            align: align,
            min: min,
            max: max,
            value: value,
            railWidth: railWidth,
            railHeight: railHeight,
            showHandler = !0,
            handlerSize: handlerSize,
            handlerStyle: handlerStyle,
            railStyle: railStyle,
            trackStyle: trackStyle,
            startText: startText,
            endText: endText,
            handlerText: handlerText,
            showTooltip: showTooltip,
            tooltip: tooltip,
            sizeBackground: sizeBackground,
            disableTriggerEvent: disableTriggerEvent,
            inverse: inverse
          } = this.attribute,
          mainContainer = graphicCreator.group({
            x: 0,
            y: 0
          });
        this._innerView.add(mainContainer);
        const slider = new Slider({
          x: 0,
          y: 0,
          zIndex: 1,
          range: {
            draggableTrack: !0
          },
          slidable: slidable,
          layout: layout,
          align: align,
          min: min,
          max: max,
          value: value,
          railWidth: railWidth,
          railHeight: railHeight,
          showHandler: showHandler,
          handlerSize: handlerSize,
          handlerStyle: Object.assign({
            symbolType: getSizeHandlerPath(align)
          }, handlerStyle),
          railStyle: railStyle,
          trackStyle: trackStyle,
          startText: startText,
          endText: endText,
          handlerText: handlerText,
          showTooltip: showTooltip,
          tooltip: tooltip,
          disableTriggerEvent: disableTriggerEvent,
          inverse: inverse
        });
        mainContainer.add(slider);
        let path,
          start = 0;
        "horizontal" === layout ? "top" === align ? (path = `M0,0L${railWidth},0L${inverse ? 0 : railWidth},12Z`, start = railHeight) : (path = `M0,12L${railWidth},12L${inverse ? 0 : railWidth},0Z`, slider.setAttribute("y", 12)) : "left" === align ? path = `M${railWidth},0L${railWidth + 12},${inverse ? 0 : railHeight}L${railWidth},${railHeight}Z` : (path = `M0,${inverse ? 0 : railHeight}L12,${railHeight}L12,0Z`, slider.setAttribute("x", 12));
        const background = graphicCreator.path(Object.assign(Object.assign({
          x: 0,
          y: start,
          path: path
        }, sizeBackground), {
          zIndex: 0
        }));
        mainContainer.add(background);
        const titleSpace = this._title ? this._title.AABBBounds.height() + get$9(this.attribute, "title.space", DEFAULT_TITLE_SPACE) : 0;
        mainContainer.translate(0 - mainContainer.AABBBounds.x1, titleSpace - mainContainer.AABBBounds.y1), this._slider = slider;
      }
      _bindEvents() {
        this.attribute.disableTriggerEvent || this._slider && (this._slider.addEventListener("change", this._onSliderChange), this._slider.addEventListener("sliderTooltip", this._onSliderToolipChange));
      }
    }
    SizeContinuousLegend.defaultAttributes = {
      layout: "horizontal",
      title: {
        align: "start",
        space: DEFAULT_TITLE_SPACE,
        textStyle: {
          fontSize: 12,
          fontWeight: "bold",
          fill: "rgba(46, 47, 50, 1)"
        }
      },
      handlerSize: 10,
      handlerStyle: {
        lineWidth: 1,
        stroke: "#ccc",
        fill: "#fff"
      },
      sizeBackground: {
        fill: "rgba(20,20,20,0.1)"
      }
    };

    function loadTitleComponent() {
      registerGroup(), registerText(), registerRichtext();
    }

    loadTitleComponent();
    let Title$1 = class Title extends AbstractComponent {
      constructor(attributes, options) {
        super((null == options ? void 0 : options.skipDefault) ? attributes : merge$2({}, Title.defaultAttributes, attributes)), this.name = "title";
      }
      render() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v;
        const {
            textType: textType,
            text: text,
            subtextType: subtextType,
            textStyle = {},
            subtext: subtext,
            subtextStyle = {},
            width: width,
            height: height,
            minWidth: minWidth,
            maxWidth: maxWidth,
            minHeight: minHeight,
            maxHeight: maxHeight,
            align: align,
            verticalAlign: verticalAlign,
            padding = 0
          } = this.attribute,
          parsedPadding = normalizePadding(padding),
          group = this.createOrUpdateChild("title-container", {
            x: parsedPadding[3],
            y: parsedPadding[0],
            zIndex: 1
          }, "group"),
          fixedMainTitleHeight = null !== (_a = textStyle.height) && void 0 !== _a ? _a : height;
        if (!1 !== this.attribute.visible && !1 !== textStyle.visible) {
          const {
            width: mainTitleWidth,
            maxHeight: mainTitleMaxHeight,
            maxWidth: mainTitleMaxWidth,
            x = 0,
            y = 0,
            ellipsis = !0,
            wordBreak = "break-word",
            maxWidth: maxWidth,
            lineClamp: lineClamp
          } = textStyle;
          if ("rich" === textType || isValid$5(textStyle.character)) {
            const attr = Object.assign({
              x: x,
              y: y,
              width: null !== (_b = null != mainTitleWidth ? mainTitleWidth : width) && void 0 !== _b ? _b : 0,
              height: null != fixedMainTitleHeight ? fixedMainTitleHeight : 0,
              ellipsis: null == ellipsis || ellipsis,
              wordBreak: null != wordBreak ? wordBreak : "break-word",
              maxHeight: null != mainTitleMaxHeight ? mainTitleMaxHeight : maxHeight,
              maxWidth: null != mainTitleMaxWidth ? mainTitleMaxWidth : maxWidth,
              textConfig: null !== (_c = textStyle.character) && void 0 !== _c ? _c : text
            }, textStyle);
            this._mainTitle = group.createOrUpdateChild("mainTitle", attr, "richtext");
          } else if ("html" === textType) {
            const attr = Object.assign({
              html: Object.assign(Object.assign({
                dom: text
              }, DEFAULT_HTML_TEXT_SPEC), textStyle),
              x: x,
              y: y,
              width: null !== (_d = null != mainTitleWidth ? mainTitleWidth : width) && void 0 !== _d ? _d : 0,
              height: null != fixedMainTitleHeight ? fixedMainTitleHeight : 0,
              ellipsis: ellipsis,
              wordBreak: wordBreak,
              maxHeight: null != mainTitleMaxHeight ? mainTitleMaxHeight : maxHeight,
              maxWidth: null != mainTitleMaxWidth ? mainTitleMaxWidth : maxWidth,
              textConfig: []
            }, textStyle);
            this._mainTitle = group.createOrUpdateChild("mainTitle", attr, "richtext");
          } else isValid$5(text) && (this._mainTitle = group.createOrUpdateChild("mainTitle", Object.assign(Object.assign({
            text: isArray$9(text) ? text : [text],
            whiteSpace: "normal"
          }, textStyle), {
            maxLineWidth: null !== (_f = null !== (_e = textStyle.maxLineWidth) && void 0 !== _e ? _e : mainTitleWidth) && void 0 !== _f ? _f : width,
            heightLimit: null !== (_g = textStyle.height) && void 0 !== _g ? _g : maxHeight,
            lineClamp: lineClamp,
            ellipsis: ellipsis,
            x: x,
            y: y
          }), "text"));
        }
        const mainTextBoundsHeight = this._mainTitle ? this._mainTitle.AABBBounds.height() : 0,
          mainTextBoundsWidth = this._mainTitle ? this._mainTitle.AABBBounds.width() : 0;
        if (!1 !== this.attribute.visible && !1 !== subtextStyle.visible) {
          const {
              width: subTitleWidth,
              height: subTitleHeight,
              maxWidth: subTitleMaxWidth,
              maxHeight: subTitleMaxHeight,
              x = 0,
              y = 0,
              ellipsis = !0,
              wordBreak = "break-word",
              lineClamp: lineClamp
            } = subtextStyle,
            maxSubTextHeight = Math.max(Number.MIN_VALUE, maxHeight - mainTextBoundsHeight);
          if ("rich" === subtextType || isValid$5(subtextStyle.character)) {
            const attr = Object.assign({
              x: x,
              y: y,
              width: null !== (_h = null != subTitleWidth ? subTitleWidth : width) && void 0 !== _h ? _h : 0,
              height: null !== (_j = null != subTitleHeight ? subTitleHeight : height) && void 0 !== _j ? _j : 0,
              ellipsis: ellipsis,
              wordBreak: wordBreak,
              maxHeight: null != subTitleMaxHeight ? subTitleMaxHeight : maxSubTextHeight,
              maxWidth: null != subTitleMaxWidth ? subTitleMaxWidth : maxWidth,
              textConfig: null !== (_k = subtextStyle.character) && void 0 !== _k ? _k : subtext
            }, subtextStyle);
            this._subTitle = group.createOrUpdateChild("subTitle", attr, "richtext");
          } else if ("html" === subtextType) {
            const attr = Object.assign({
              html: Object.assign(Object.assign({
                dom: subtext
              }, DEFAULT_HTML_TEXT_SPEC), subtextStyle),
              x: x,
              y: y,
              width: null !== (_l = null != subTitleWidth ? subTitleWidth : width) && void 0 !== _l ? _l : 0,
              height: null !== (_m = null != subTitleHeight ? subTitleHeight : height) && void 0 !== _m ? _m : 0,
              ellipsis: ellipsis,
              wordBreak: wordBreak,
              maxHeight: null != subTitleMaxHeight ? subTitleMaxHeight : maxSubTextHeight,
              maxWidth: null != subTitleMaxWidth ? subTitleMaxWidth : maxWidth,
              textConfig: []
            }, subtextStyle);
            this._subTitle = group.createOrUpdateChild("subTitle", attr, "richtext");
          } else isValid$5(subtext) && (this._subTitle = group.createOrUpdateChild("subTitle", Object.assign(Object.assign({
            text: isArray$9(subtext) ? subtext : [subtext],
            whiteSpace: "normal"
          }, subtextStyle), {
            maxLineWidth: null !== (_o = subtextStyle.maxLineWidth) && void 0 !== _o ? _o : width,
            heightLimit: null !== (_p = subtextStyle.heightLimit) && void 0 !== _p ? _p : maxSubTextHeight,
            lineClamp: lineClamp,
            ellipsis: ellipsis,
            x: 0,
            y: mainTextBoundsHeight
          }), "text"));
        }
        const subTextBoundsHeight = this._subTitle ? this._subTitle.AABBBounds.height() : 0,
          subTextBoundsWidth = this._subTitle ? this._subTitle.AABBBounds.width() : 0;
        let totalWidth = Math.max(mainTextBoundsWidth, subTextBoundsWidth),
          totalHeight = mainTextBoundsHeight + (null !== (_q = subtextStyle.height) && void 0 !== _q ? _q : subTextBoundsHeight);
        if (isValid$5(width) && (totalWidth = width), isValid$5(height) && (totalHeight = height), isValid$5(minWidth) && totalWidth < minWidth && (totalWidth = minWidth), isValid$5(maxWidth) && totalWidth > maxWidth && (totalWidth = maxWidth), isValid$5(minHeight) && totalHeight < minHeight && (totalHeight = minHeight), isValid$5(maxHeight) && totalHeight > maxHeight && (totalHeight = maxHeight), group.attribute.width = totalWidth, group.attribute.height = totalHeight, group.attribute.boundsPadding = parsedPadding, this._mainTitle) {
          if (isValid$5(align) || isValid$5(textStyle.align)) {
            const mainTitleAlign = textStyle.align ? textStyle.align : align,
              mainTitleWidth = null !== (_r = textStyle.width) && void 0 !== _r ? _r : totalWidth;
            "center" === mainTitleAlign ? (this._mainTitle.setAttribute("x", mainTitleWidth / 2), this._mainTitle.setAttribute("textAlign", "center")) : "right" === mainTitleAlign ? (this._mainTitle.setAttribute("x", mainTitleWidth), this._mainTitle.setAttribute("textAlign", "right")) : (this._mainTitle.setAttribute("x", 0), this._mainTitle.setAttribute("textAlign", "left"));
          }
          const mainTitleVerticalAlign = textStyle.verticalAlign ? textStyle.verticalAlign : verticalAlign,
            mainTitleHeight = null != fixedMainTitleHeight ? fixedMainTitleHeight : this._mainTitle.AABBBounds.empty() ? 0 : this._mainTitle.AABBBounds.height();
          "middle" === mainTitleVerticalAlign ? (this._mainTitle.setAttribute("y", mainTitleHeight / 2), this._mainTitle.setAttribute("textBaseline", "middle")) : "bottom" === mainTitleVerticalAlign ? (this._mainTitle.setAttribute("y", mainTitleHeight), this._mainTitle.setAttribute("textBaseline", "bottom")) : (this._mainTitle.setAttribute("y", 0), this._mainTitle.setAttribute("textBaseline", "top"));
        }
        if (this._subTitle) {
          if (isValid$5(align) || isValid$5(subtextStyle.align)) {
            const subTitleAlign = subtextStyle.align ? subtextStyle.align : align,
              subTitleWidth = null !== (_t = null !== (_s = subtextStyle.width) && void 0 !== _s ? _s : textStyle.width) && void 0 !== _t ? _t : totalWidth;
            "center" === subTitleAlign ? (this._subTitle.setAttribute("x", subTitleWidth / 2), this._subTitle.setAttribute("textAlign", "center")) : "right" === subTitleAlign ? (this._subTitle.setAttribute("x", subTitleWidth), this._subTitle.setAttribute("textAlign", "right")) : (this._subTitle.setAttribute("x", 0), this._subTitle.setAttribute("textAlign", "left"));
          }
          const subTitleVerticalAlign = subtextStyle.verticalAlign ? subtextStyle.verticalAlign : verticalAlign,
            subTitleYStart = this._mainTitle ? isValid$5(fixedMainTitleHeight) ? this._mainTitle.AABBBounds.y1 + Math.max(this._mainTitle.AABBBounds.empty() ? 0 : this._mainTitle.AABBBounds.height(), fixedMainTitleHeight) : this._mainTitle.AABBBounds.y2 : 0,
            subTitleHeight = null !== (_v = null !== (_u = subtextStyle.height) && void 0 !== _u ? _u : height) && void 0 !== _v ? _v : this._subTitle.AABBBounds.empty() ? 0 : this._subTitle.AABBBounds.height();
          "middle" === subTitleVerticalAlign ? (this._subTitle.setAttribute("y", subTitleYStart + subTitleHeight / 2), this._subTitle.setAttribute("textBaseline", "middle")) : "bottom" === subTitleVerticalAlign ? (this._subTitle.setAttribute("y", subTitleYStart + subTitleHeight), this._subTitle.setAttribute("textBaseline", "bottom")) : (this._subTitle.setAttribute("y", subTitleYStart), this._subTitle.setAttribute("textBaseline", "top"));
        }
      }
    };
    Title$1.defaultAttributes = {
      textStyle: {
        ellipsis: "...",
        fill: "#333",
        fontSize: 20,
        fontWeight: "bold",
        textAlign: "left",
        textBaseline: "top"
      },
      subtextStyle: {
        ellipsis: "...",
        fill: "#6F6F6F",
        fontSize: 16,
        fontWeight: "normal",
        textAlign: "left",
        textBaseline: "top"
      }
    };

    function loadCheckBoxComponent() {
      registerGroup(), registerRect(), registerText(), registerImage();
    }

    const checkSvg = '<svg width="200" height="200" viewBox="0 0 1024 1024" fill="#fff" xmlns="http://www.w3.org/2000/svg"><path d="M877.44815445 206.10060629a64.72691371 64.72691371 0 0 0-95.14856334 4.01306852L380.73381888 685.46812814 235.22771741 533.48933518a64.72691371 64.72691371 0 0 0-92.43003222-1.03563036l-45.82665557 45.82665443a64.72691371 64.72691371 0 0 0-0.90617629 90.61767965l239.61903446 250.10479331a64.72691371 64.72691371 0 0 0 71.19960405 15.14609778 64.33855261 64.33855261 0 0 0 35.08198741-21.23042702l36.24707186-42.71976334 40.5190474-40.77795556-3.36579926-3.49525333 411.40426297-486.74638962a64.72691371 64.72691371 0 0 0-3.88361443-87.64024149l-45.3088404-45.43829334z"></path></svg>',
      indeterminateSvg = '<svg width="200" height="200" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" fill="none"><path stroke="#fff" stroke-linecap="round" stroke-linejoin="round" stroke-width="5" d="M5 12h14"/></svg>';
    loadCheckBoxComponent();
    class CheckBox extends AbstractComponent {
      constructor(attributes, options) {
        super((null == options ? void 0 : options.skipDefault) ? attributes : merge$2({}, CheckBox.defaultAttributes, attributes)), this._handlePointerUp = () => {
          this.attribute.disabled || (this.attribute.checked ? (this.setAttribute("checked", !1), this.setAttribute("indeterminate", !1)) : (this.setAttribute("checked", !0), this.setAttribute("indeterminate", !1)), this._dispatchEvent("checkbox_state_change", {
            eventType: "checkbox_state_change",
            checked: this.attribute.checked
          }), this.stage.renderNextFrame());
        }, this.renderGroup(), this.onBeforeAttributeUpdate = (val, attributes, key) => {
          "interactive" in val && this.setAttribute("pickable", val.interactive), "disabled" in val && this.setAttribute("cursor", val.disable ? this.attribute.disableCursor : this.attribute.cursor);
        }, this.addEventListener("pointerup", this._handlePointerUp);
      }
      render() {
        this.removeAllChild(!0), this.renderBox(), this.renderIcon(), this.renderText(), this.layout();
      }
      renderBox() {
        this._box = new Rect$2(merge$2({}, this.attribute.box));
        const isCheckedOrIndeterminate = this.attribute.checked || this.attribute.indeterminate;
        isCheckedOrIndeterminate && this.attribute.disabled ? this._box.setAttributes({
          fill: this.attribute.box.disableCheckedFill,
          stroke: this.attribute.box.disableCheckedStroke
        }) : isCheckedOrIndeterminate ? this._box.setAttributes({
          fill: this.attribute.box.checkedFill,
          stroke: this.attribute.box.checkedStroke
        }) : this.attribute.disabled && this._box.setAttributes({
          fill: this.attribute.box.disableFill
        }), this.appendChild(this._box);
      }
      renderIcon() {
        this._checkIcon = new Image$2(merge$2({
          image: this.attribute.icon.checkIconImage
        }, this.attribute.icon)), this.appendChild(this._checkIcon), this._indeterminateIcon = new Image$2(merge$2({
          image: this.attribute.icon.indeterminateIconImage
        }, this.attribute.icon)), this.appendChild(this._indeterminateIcon), this.attribute.checked ? (this._checkIcon.setAttribute("visible", !0), this._indeterminateIcon.setAttribute("visible", !1)) : this.attribute.indeterminate ? (this._checkIcon.setAttribute("visible", !1), this._indeterminateIcon.setAttribute("visible", !0)) : (this._checkIcon.setAttribute("visible", !1), this._indeterminateIcon.setAttribute("visible", !1));
      }
      renderText() {
        this._text = new Text$1(merge$2({
          wrap: !0
        }, this.attribute.text)), this.attribute.disabled && this._text.setAttribute("fill", this.attribute.text.disableFill), this.appendChild(this._text);
      }
      renderGroup() {
        this.attribute.interactive || this.setAttribute("pickable", !1), this.attribute.disabled && this.setAttribute("cursor", this.attribute.disableCursor);
      }
      layout() {
        const boxHeight = this.attribute.box.height,
          iconHeight = this.attribute.icon.height,
          textHeight = this._text.AABBBounds.height(),
          maxHeight = Math.max(boxHeight, iconHeight, textHeight),
          boxY = maxHeight / 2 - boxHeight / 2,
          iconY = maxHeight / 2 - iconHeight / 2,
          textY = maxHeight / 2 - textHeight / 2,
          boxWidth = this.attribute.box.width,
          iconWidth = this.attribute.icon.width,
          maxWidth = Math.max(boxWidth, iconWidth),
          boxX = maxWidth / 2 - boxWidth / 2,
          iconX = maxWidth / 2 - iconWidth / 2,
          textX = maxWidth + this.attribute.spaceBetweenTextAndIcon;
        this._box.setAttributes({
          x: boxX,
          y: boxY
        }), this._checkIcon.setAttributes({
          x: iconX,
          y: iconY
        }), this._indeterminateIcon.setAttributes({
          x: iconX,
          y: iconY
        }), this._text.setAttributes({
          x: textX,
          y: textY
        });
      }
      initAttributes(params, options) {
        params = (null == options ? void 0 : options.skipDefault) ? params : merge$2({}, CheckBox.defaultAttributes, params), super.initAttributes(params), this.renderGroup(), this.render();
      }
    }
    CheckBox.defaultAttributes = {
      interactive: !0,
      disabled: !1,
      checked: !1,
      indeterminate: !1,
      cursor: "pointer",
      disableCursor: "not-allowed",
      spaceBetweenTextAndIcon: 8,
      text: {
        text: "text",
        fontSize: 14,
        fill: "#000",
        disableFill: "rgb(201,205,212)",
        textBaseline: "top",
        pickable: !1
      },
      icon: {
        checkIconImage: checkSvg,
        indeterminateIconImage: indeterminateSvg,
        width: 10,
        height: 10,
        pickable: !1
      },
      box: {
        width: 14,
        height: 14,
        cornerRadius: 2,
        fill: "#fff",
        stroke: "rgb(229,230,235)",
        disableFill: "rgb(242,243,245)",
        checkedFill: "rgb(22, 93, 255)",
        checkedStroke: "rgb(22, 93, 255)",
        disableCheckedFill: "rgb(148, 191, 255)",
        disableCheckedStroke: "rgb(148, 191, 255)",
        pickable: !1
      }
    };

    function loadRadioComponent() {
      registerGroup(), registerRect(), registerWrapText(), registerImage();
    }

    loadRadioComponent();
    class Radio extends AbstractComponent {
      constructor(attributes, options) {
        super((null == options ? void 0 : options.skipDefault) ? attributes : merge$2({}, Radio.defaultAttributes, attributes)), this._handlePointerUp = () => {
          this.attribute.disabled || this.attribute.checked || (this.setAttribute("checked", !0), this._dispatchEvent("radio_checked", {
            eventType: "radio_checked",
            target: this
          }), this.stage.renderNextFrame());
        }, this.renderGroup(), this.onBeforeAttributeUpdate = (val, attributes, key) => {
          "interactive" in val && this.setAttribute("pickable", val.interactive), "disabled" in val && this.setAttribute("cursor", val.disable ? this.attribute.disableCursor : this.attribute.cursor);
        }, this.addEventListener("pointerup", this._handlePointerUp);
      }
      render() {
        this.removeAllChild(!0), this.renderCircle(), this.renderText(), this.layout();
      }
      renderCircle() {
        this._circle = new Arc$1(merge$2({}, this.attribute.circle));
        const isChecked = this.attribute.checked;
        isChecked && this.attribute.disabled ? this._circle.setAttributes({
          fill: this.attribute.circle.disableCheckedFill,
          stroke: this.attribute.circle.disableCheckedStroke
        }) : isChecked ? this._circle.setAttributes({
          fill: this.attribute.circle.checkedFill,
          stroke: this.attribute.circle.checkedStroke
        }) : this.attribute.disabled && this._circle.setAttributes({
          fill: this.attribute.circle.disableFill
        }), this.appendChild(this._circle);
      }
      renderText() {
        this._text = new Text$1(merge$2({}, this.attribute.text)), this.attribute.disabled && this._text.setAttribute("fill", this.attribute.text.disableFill), this.appendChild(this._text);
      }
      renderGroup() {
        this.attribute.interactive || this.setAttribute("pickable", !1), this.attribute.disabled && this.setAttribute("cursor", this.attribute.disableCursor);
      }
      layout() {
        const circleHeight = 2 * (this.attribute.circle.outerRadius + this.attribute.circle.lineWidth),
          textHeight = this._text.AABBBounds.height(),
          maxHeight = Math.max(circleHeight, textHeight),
          circleY = maxHeight / 2 - circleHeight / 2 + this.attribute.circle.outerRadius + this.attribute.circle.lineWidth,
          textY = maxHeight / 2 - textHeight / 2,
          circleWidth = 2 * (this.attribute.circle.outerRadius + this.attribute.circle.lineWidth),
          circleX = this.attribute.circle.outerRadius + this.attribute.circle.lineWidth,
          textX = circleWidth + this.attribute.spaceBetweenTextAndIcon;
        this._circle.setAttributes({
          x: circleX,
          y: circleY
        }), this._text.setAttributes({
          x: textX,
          y: textY
        });
      }
      initAttributes(params, options) {
        params = (null == options ? void 0 : options.skipDefault) ? params : merge$2({}, Radio.defaultAttributes, params), super.initAttributes(params), this.renderGroup(), this.render();
      }
    }
    Radio.defaultAttributes = {
      interactive: !0,
      disabled: !1,
      checked: !1,
      cursor: "pointer",
      disableCursor: "not-allowed",
      spaceBetweenTextAndIcon: 8,
      text: {
        text: "text",
        fontSize: 14,
        fill: "#000",
        disableFill: "rgb(201,205,212)",
        textBaseline: "top",
        pickable: !1
      },
      circle: {
        outerRadius: 7,
        innerRadius: 3,
        startAngle: 0,
        endAngle: 2 * Math.PI,
        lineWidth: 1,
        fill: "#fff",
        stroke: "rgb(229,230,235)",
        disableFill: "rgb(242,243,245)",
        checkedFill: "rgb(22, 93, 255)",
        checkedStroke: "rgb(22, 93, 255)",
        disableCheckedFill: "rgb(148, 191, 255)",
        disableCheckedStroke: "rgb(148, 191, 255)",
        pickable: !1
      }
    };

    function loadEmptyTipComponent() {
      registerGroup(), registerText(), registerImage();
    }

    const emptyTipSvg$1 = '<svg t="1716726614852" class="icon" viewBox="0 0 1194 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2621" width="200" height="200"><path d="M1038.694079 367.237067c13.265507 23.342857-16.633865-40.004445-63.05621-40.004446H219.018794c-26.558738 0-46.46393 13.334815-63.05621 40.004446S0.006238 607.277601 0.006238 650.608819V940.647979a82.351494 82.351494 0 0 0 82.961402 83.349526H1111.702885a82.337632 82.337632 0 0 0 82.975264-83.349526V650.608819c0-43.331218-155.970208-283.371753-155.970208-283.371752zM730.066575 667.284269a136.328386 136.328386 0 0 1-132.738243 133.33429 133.417459 133.417459 0 0 1-132.738243-133.33429v-6.681269a40.6698 40.6698 0 0 0-36.497473-26.66963H73.015044l119.458874-220.02445s23.231965-40.004445 53.103614-40.004446h713.481918c26.544876 0 29.871649 10.008042 46.436207 40.004446L1128.33675 633.947231H769.904682c-26.184476 0-39.838107 7.623855-39.838107 33.337038zM338.505391 210.559919l-89.601086-86.69016a22.178487 22.178487 0 0 1 0-33.26773 21.984425 21.984425 0 0 1 33.170699 0l89.601087 86.676299a22.317102 22.317102 0 0 1 0 33.26773 24.950798 24.950798 0 0 1-33.1707 0z m252.197118-40.059891a25.532983 25.532983 0 0 1-6.639685-16.633865l-3.326773-126.694606A28.263709 28.263709 0 0 1 603.995739 0.515788c13.251646-3.326773 23.204242 10.021904 26.544877 23.342858V153.866163a28.249847 28.249847 0 0 1-23.259688 26.66963c-6.611961-3.312911-13.279369-3.312911-16.578419-10.035765z m235.646421 33.337038a22.372548 22.372548 0 0 1 0-33.337038l86.288175-90.030795a22.039871 22.039871 0 0 1 33.170699 0 22.289379 22.289379 0 0 1 0 33.364761l-82.961401 90.003072a25.962691 25.962691 0 0 1-36.483611 0z" fill="#8a8a8a" p-id="2622"></path></svg>';
    loadEmptyTipComponent();
    let EmptyTip$1 = class EmptyTip extends AbstractComponent {
      constructor(attributes, options) {
        super((null == options ? void 0 : options.skipDefault) ? attributes : merge$2({}, EmptyTip.defaultAttributes, attributes));
      }
      render() {
        this.removeAllChild(!0), this.renderIcon(), this.renderText(), this.layout();
      }
      renderIcon() {
        this._emptyTipIcon = new Image$2(merge$2({
          image: this.attribute.icon.image
        }, this.attribute.icon)), this.appendChild(this._emptyTipIcon);
      }
      renderText() {
        this._text = new Text$1(merge$2({
          wrap: !0
        }, this.attribute.text)), this.appendChild(this._text);
      }
      layout() {
        const iconHeight = this.attribute.icon.height,
          textHeight = this._text.AABBBounds.height(),
          iconWidth = this.attribute.icon.width,
          {
            width: width,
            height: height,
            spaceBetweenTextAndIcon: spaceBetweenTextAndIcon
          } = this.attribute;
        this._emptyTipIcon.setAttribute("x", width / 2 - iconWidth / 2), this._emptyTipIcon.setAttribute("y", height / 2 - iconHeight / 2 - textHeight / 2 - spaceBetweenTextAndIcon / 2), this._text.setAttribute("x", width / 2), this._text.setAttribute("textAlign", "center"), this._text.setAttribute("y", height / 2 + iconHeight / 2 + spaceBetweenTextAndIcon / 2), this._text.setAttribute("textBaseline", "middle");
      }
    };
    EmptyTip$1.defaultAttributes = {
      spaceBetweenTextAndIcon: 20,
      text: {
        text: "no data",
        fontSize: 14,
        fill: "#000",
        disableFill: "rgb(201,205,212)",
        pickable: !1
      },
      icon: {
        image: emptyTipSvg$1,
        width: 100,
        height: 100,
        pickable: !1
      }
    };

    function loadSwitchComponent() {
      registerGroup(), registerRect(), registerText(), registerCircle();
    }

    loadSwitchComponent();
    class Switch extends AbstractComponent {
      constructor(attributes, options) {
        super((null == options ? void 0 : options.skipDefault) ? attributes : merge$2({}, Switch.defaultAttributes, attributes)), this._handlePointerUp = () => {
          this.attribute.disabled || (this.attribute.checked ? this.setAttribute("checked", !1) : this.setAttribute("checked", !0), this._dispatchEvent("switch_state_change", {
            eventType: "switch_state_change",
            checked: this.attribute.checked
          }), this.stage.renderNextFrame());
        }, this.renderGroup(), this.onBeforeAttributeUpdate = (val, attributes, key) => {
          "interactive" in val && this.setAttribute("pickable", val.interactive), "disabled" in val && this.setAttribute("cursor", val.disable ? this.attribute.disableCursor : this.attribute.cursor);
        }, this.addEventListener("pointerup", this._handlePointerUp);
      }
      render() {
        this.removeAllChild(!0), this.renderBox(), this.renderCircle(), this.renderText(), this.layout();
      }
      renderBox() {
        this._box = new Rect$2(merge$2({}, this.attribute.box)), this.attribute.disabled && this.attribute.checked ? this._box.setAttributes({
          fill: this.attribute.box.disableCheckedFill
        }) : this.attribute.disabled && !this.attribute.checked ? this._box.setAttributes({
          fill: this.attribute.box.disableUncheckedFill
        }) : this.attribute.checked ? this._box.setAttributes({
          fill: this.attribute.box.checkedFill
        }) : this._box.setAttributes({
          fill: this.attribute.box.uncheckedFill
        }), this.appendChild(this._box);
      }
      renderCircle() {
        this._circle = new Circle$1(merge$2({}, this.attribute.circle)), this.appendChild(this._circle);
      }
      renderText() {
        var _a, _b, _c;
        this._text = new Text$1(merge$2({}, null !== (_a = this.attribute.text) && void 0 !== _a ? _a : {})), this.attribute.checked && (null === (_b = this.attribute.text) || void 0 === _b ? void 0 : _b.checkedText) ? this._text.setAttributes({
          text: this.attribute.text.checkedText
        }) : (null === (_c = this.attribute.text) || void 0 === _c ? void 0 : _c.uncheckedText) && this._text.setAttributes({
          text: this.attribute.text.uncheckedText
        }), this.appendChild(this._text);
      }
      renderGroup() {
        this.attribute.interactive || this.setAttribute("pickable", !1), this.attribute.disabled && this.setAttribute("cursor", this.attribute.disableCursor);
      }
      layout() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        const space = this.attribute.spaceBetweenTextAndCircle,
          radius = this.attribute.circle.radius,
          boxHeight = this.attribute.box.height,
          circleHeight = 2 * radius,
          textHeight = this._text.AABBBounds.height(),
          maxHeight = Math.max(boxHeight, circleHeight, textHeight),
          circleY = maxHeight / 2 - circleHeight / 2 + radius,
          textY = maxHeight / 2 - textHeight / 2,
          boxWidth = this.attribute.box.width,
          circleWidth = 2 * radius,
          textWidth = measureTextSize((null !== (_c = null === (_b = null === (_a = this.attribute.text) || void 0 === _a ? void 0 : _a.checkedText) || void 0 === _b ? void 0 : _b.length) && void 0 !== _c ? _c : 0) > (null !== (_f = null === (_e = null === (_d = this.attribute.text) || void 0 === _d ? void 0 : _d.uncheckedText) || void 0 === _e ? void 0 : _e.length) && void 0 !== _f ? _f : 0) ? null !== (_h = null === (_g = this.attribute.text) || void 0 === _g ? void 0 : _g.checkedText) && void 0 !== _h ? _h : "" : null !== (_k = null === (_j = this.attribute.text) || void 0 === _j ? void 0 : _j.uncheckedText) && void 0 !== _k ? _k : "", this._text.attribute).width,
          maxWidth = Math.max(boxWidth, circleWidth + textWidth + 3 * space),
          circleX = boxHeight / 2 - circleWidth / 2 + radius,
          textX = circleX + radius + space;
        this._box.setAttributes({
          width: maxWidth,
          height: maxHeight
        }), this._circle.setAttributes({
          y: circleY,
          x: this.attribute.checked ? maxWidth - circleX : circleX
        }), this._text.setAttributes({
          x: this.attribute.checked ? maxWidth - textX - textWidth : textX,
          y: textY
        });
      }
      initAttributes(params, options) {
        params = (null == options ? void 0 : options.skipDefault) ? params : merge$2({}, Switch.defaultAttributes, params), super.initAttributes(params), this.renderGroup(), this.render();
      }
    }
    Switch.defaultAttributes = {
      interactive: !0,
      disabled: !1,
      checked: !1,
      cursor: "pointer",
      disableCursor: "not-allowed",
      circle: {
        radius: 8,
        fill: "#FFF",
        pickable: !1
      },
      box: {
        width: 40,
        height: 24,
        cornerRadius: 12,
        uncheckedFill: "rgb(201,205,212)",
        checkedFill: "#165DFF",
        disableUncheckedFill: "rgb(242,243,245)",
        disableCheckedFill: "rgb(148,191,255)",
        pickable: !1
      },
      text: {
        textAlign: "left",
        textBaseline: "top",
        pickable: !1
      },
      spaceBetweenTextAndCircle: 6
    };

    let registed = false;
    function registerForVrender() {
        if (registed) {
            return;
        }
        registed = true;
        preLoadAllModule();
        if (isBrowserEnv()) {
            loadBrowserEnv(container);
        }
        else if (isNodeEnv()) {
            loadNodeEnv(container);
        }
        registerArc();
        registerCircle();
        registerGroup();
        registerImage();
        registerLine();
        registerRect();
        registerRichtext();
        registerShadowRoot();
        registerSymbol();
        registerText();
        registerFlexLayoutPlugin();
        loadPoptip();
        registerFlexLayoutPlugin();
    }

    var InteractionState;
    (function (InteractionState) {
        InteractionState["default"] = "default";
        InteractionState["grabing"] = "grabing";
        InteractionState["scrolling"] = "scrolling";
    })(InteractionState || (InteractionState = {}));
    var HighlightScope;
    (function (HighlightScope) {
        HighlightScope["single"] = "single";
        HighlightScope["column"] = "column";
        HighlightScope["row"] = "row";
        HighlightScope["cross"] = "cross";
        HighlightScope["none"] = "none";
    })(HighlightScope || (HighlightScope = {}));

    const cellStyleKeys = ['bgColor', 'color', 'strokeColor', 'borderColor', 'linkColor'];

    var AggregationType;
    (function (AggregationType) {
        AggregationType["RECORD"] = "RECORD";
        AggregationType["NONE"] = "NONE";
        AggregationType["SUM"] = "SUM";
        AggregationType["MIN"] = "MIN";
        AggregationType["MAX"] = "MAX";
        AggregationType["AVG"] = "AVG";
        AggregationType["COUNT"] = "COUNT";
        AggregationType["CUSTOM"] = "CUSTOM";
        AggregationType["RECALCULATE"] = "RECALCULATE";
    })(AggregationType || (AggregationType = {}));
    var SortType;
    (function (SortType) {
        SortType["ASC"] = "ASC";
        SortType["DESC"] = "DESC";
        SortType["NORMAL"] = "NORMAL";
        SortType["desc"] = "desc";
        SortType["asc"] = "asc";
        SortType["normal"] = "normal";
    })(SortType || (SortType = {}));

    var Placement;
    (function (Placement) {
        Placement["top"] = "top";
        Placement["bottom"] = "bottom";
        Placement["left"] = "left";
        Placement["right"] = "right";
    })(Placement || (Placement = {}));
    var HierarchyState;
    (function (HierarchyState) {
        HierarchyState["expand"] = "expand";
        HierarchyState["collapse"] = "collapse";
        HierarchyState["none"] = "none";
        HierarchyState["loading"] = "loading";
    })(HierarchyState || (HierarchyState = {}));

    var IconPosition;
    (function (IconPosition) {
        IconPosition["inlineFront"] = "inlineFront";
        IconPosition["inlineEnd"] = "inlineEnd";
        IconPosition["left"] = "left";
        IconPosition["right"] = "right";
        IconPosition["absoluteRight"] = "absoluteRight";
        IconPosition["contentLeft"] = "contentLeft";
        IconPosition["contentRight"] = "contentRight";
        IconPosition["absolute"] = "absolute";
    })(IconPosition || (IconPosition = {}));
    var IconFuncTypeEnum;
    (function (IconFuncTypeEnum) {
        IconFuncTypeEnum["frozen"] = "frozen";
        IconFuncTypeEnum["sort"] = "sort";
        IconFuncTypeEnum["dropDown"] = "dropDown";
        IconFuncTypeEnum["dropDownState"] = "dropDownState";
        IconFuncTypeEnum["play"] = "play";
        IconFuncTypeEnum["damagePic"] = "damagePic";
        IconFuncTypeEnum["expand"] = "expand";
        IconFuncTypeEnum["collapse"] = "collapse";
        IconFuncTypeEnum["drillDown"] = "drillDown";
        IconFuncTypeEnum["drillUp"] = "drillUp";
        IconFuncTypeEnum["dragReorder"] = "dragReorder";
    })(IconFuncTypeEnum || (IconFuncTypeEnum = {}));
    var InternalIconName;
    (function (InternalIconName) {
        InternalIconName["upwardIconName"] = "sort_upward";
        InternalIconName["downwardIconName"] = "sort_downward";
        InternalIconName["normalIconName"] = "sort_normal";
        InternalIconName["freezeIconName"] = "freeze";
        InternalIconName["frozenIconName"] = "frozen";
        InternalIconName["frozenCurrentIconName"] = "frozenCurrent";
        InternalIconName["dropdownIconName"] = "dropdownIcon";
        InternalIconName["expandIconName"] = "expand";
        InternalIconName["collapseIconName"] = "collapse";
        InternalIconName["dragReorderIconName"] = "dragReorder";
        InternalIconName["loadingIconName"] = "loading";
    })(InternalIconName || (InternalIconName = {}));

    const isType$2 = (value, type) => Object.prototype.toString.call(value) === `[object ${type}]`;
    var isType$3 = isType$2;

    const isBoolean$3 = function (value) {
      let fuzzy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
      return fuzzy ? "boolean" == typeof value : !0 === value || !1 === value || isType$3(value, "Boolean");
    };
    var isBoolean$4 = isBoolean$3;

    const isFunction$4 = value => "function" == typeof value;
    var isFunction$5 = isFunction$4;

    const isNil$2 = value => null == value;
    var isNil$3 = isNil$2;

    const isValid$2 = value => null != value;
    var isValid$3 = isValid$2;

    const isObject$6 = value => {
      const type = typeof value;
      return null !== value && "object" === type || "function" === type;
    };
    var isObject$7 = isObject$6;

    const isObjectLike$4 = value => "object" == typeof value && null !== value;
    var isObjectLike$5 = isObjectLike$4;

    const isPlainObject$2 = function (value) {
      if (!isObjectLike$5(value) || !isType$3(value, "Object")) return !1;
      if (null === Object.getPrototypeOf(value)) return !0;
      let proto = value;
      for (; null !== Object.getPrototypeOf(proto);) proto = Object.getPrototypeOf(proto);
      return Object.getPrototypeOf(value) === proto;
    };
    var isPlainObject$3 = isPlainObject$2;

    const isString$3 = function (value) {
      let fuzzy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
      const type = typeof value;
      return fuzzy ? "string" === type : "string" === type || isType$3(value, "String");
    };
    var isString$4 = isString$3;

    const isArray$6 = value => Array.isArray ? Array.isArray(value) : isType$3(value, "Array");
    var isArray$7 = isArray$6;

    const isArrayLike$2 = function (value) {
      return null !== value && "function" != typeof value && Number.isFinite(value.length);
    };
    var isArrayLike$3 = isArrayLike$2;

    const isDate$2 = value => isType$3(value, "Date");
    var isDate$3 = isDate$2;

    const isNumber$3 = function (value) {
      let fuzzy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
      const type = typeof value;
      return fuzzy ? "number" === type : "number" === type || isType$3(value, "Number");
    };
    var isNumber$4 = isNumber$3;

    const isValidNumber = value => isNumber$4(value) && Number.isFinite(value);
    var isValidNumber$1 = isValidNumber;

    const getType = value => ({}).toString.call(value).replace(/^\[object /, "").replace(/]$/, "");
    var getType$1 = getType;

    const objectProto$5 = Object.prototype,
      isPrototype = function (value) {
        const Ctor = value && value.constructor;
        return value === ("function" == typeof Ctor && Ctor.prototype || objectProto$5);
      };
    var isPrototype$1 = isPrototype;

    const hasOwnProperty$4 = Object.prototype.hasOwnProperty;
    function isEmpty(value) {
      if (isNil$3(value)) return !0;
      if (isArrayLike$3(value)) return !value.length;
      const type = getType$1(value);
      if ("Map" === type || "Set" === type) return !value.size;
      if (isPrototype$1(value)) return !Object.keys(value).length;
      for (const key in value) if (hasOwnProperty$4.call(value, key)) return !1;
      return !0;
    }

    const get$6 = (obj, path, defaultValue) => {
      const paths = isString$4(path) ? path.split(".") : path;
      for (let p = 0; p < paths.length; p++) obj = obj ? obj[paths[p]] : void 0;
      return void 0 === obj ? defaultValue : obj;
    };
    var get$7 = get$6;

    function cloneDeep$1(value, ignoreWhen, excludeKeys) {
      let result;
      if (!isValid$3(value) || "object" != typeof value || ignoreWhen && ignoreWhen(value)) return value;
      const isArr = isArray$7(value),
        length = value.length;
      result = isArr ? new Array(length) : "object" == typeof value ? {} : isBoolean$4(value) || isNumber$4(value) || isString$4(value) ? value : isDate$3(value) ? new Date(+value) : void 0;
      const props = isArr ? void 0 : Object.keys(Object(value));
      let index = -1;
      if (result) for (; ++index < (props || value).length;) {
        const key = props ? props[index] : index,
          subValue = value[key];
        excludeKeys && excludeKeys.includes(key.toString()) ? result[key] = subValue : result[key] = cloneDeep$1(subValue, ignoreWhen, excludeKeys);
      }
      return result;
    }

    function baseMerge$1(target, source) {
      let shallowArray = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
      let skipTargetArray = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
      if (source) {
        if (target === source) return;
        if (isValid$3(source) && "object" == typeof source) {
          const iterable = Object(source),
            props = [];
          for (const key in iterable) props.push(key);
          let {
              length: length
            } = props,
            propIndex = -1;
          for (; length--;) {
            const key = props[++propIndex];
            !isValid$3(iterable[key]) || "object" != typeof iterable[key] || skipTargetArray && isArray$7(target[key]) ? assignMergeValue$1(target, key, iterable[key]) : baseMergeDeep$1(target, source, key, shallowArray, skipTargetArray);
          }
        }
      }
    }
    function baseMergeDeep$1(target, source, key) {
      let shallowArray = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
      let skipTargetArray = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !1;
      const objValue = target[key],
        srcValue = source[key];
      let newValue = source[key],
        isCommon = !0;
      if (isArray$7(srcValue)) {
        if (shallowArray) newValue = [];else if (isArray$7(objValue)) newValue = objValue;else if (isArrayLike$3(objValue)) {
          newValue = new Array(objValue.length);
          let index = -1;
          const length = objValue.length;
          for (; ++index < length;) newValue[index] = objValue[index];
        }
      } else isPlainObject$3(srcValue) ? (newValue = null != objValue ? objValue : {}, "function" != typeof objValue && "object" == typeof objValue || (newValue = {})) : isCommon = !1;
      isCommon && baseMerge$1(newValue, srcValue, shallowArray, skipTargetArray), assignMergeValue$1(target, key, newValue);
    }
    function assignMergeValue$1(target, key, value) {
      (void 0 !== value && !eq$3(target[key], value) || void 0 === value && !(key in target)) && (target[key] = value);
    }
    function eq$3(value, other) {
      return value === other || Number.isNaN(value) && Number.isNaN(other);
    }
    function merge$1(target) {
      let sourceIndex = -1;
      const length = arguments.length <= 1 ? 0 : arguments.length - 1;
      for (; ++sourceIndex < length;) {
        baseMerge$1(target, sourceIndex + 1 < 1 || arguments.length <= sourceIndex + 1 ? undefined : arguments[sourceIndex + 1], !0);
      }
      return target;
    }

    function pickWithout(obj, keys) {
      if (!obj || !isPlainObject$3(obj)) return obj;
      const result = {};
      return Object.keys(obj).forEach(k => {
        const v = obj[k];
        let match = !1;
        keys.forEach(itKey => {
          (isString$4(itKey) && itKey === k || itKey instanceof RegExp && k.match(itKey)) && (match = !0);
        }), match || (result[k] = v);
      }), result;
    }

    function objToString(obj) {
      return Object.prototype.toString.call(obj);
    }
    function objectKeys(obj) {
      return Object.keys(obj);
    }
    function isEqual(a, b, options) {
      if (a === b) return !0;
      if (typeof a != typeof b) return !1;
      if (null == a || null == b) return !1;
      if (Number.isNaN(a) && Number.isNaN(b)) return !0;
      if (objToString(a) !== objToString(b)) return !1;
      if (isFunction$5(a)) return !!(null == options ? void 0 : options.skipFunction);
      if ("object" != typeof a) return !1;
      if (isArray$7(a)) {
        if (a.length !== b.length) return !1;
        for (let i = a.length - 1; i >= 0; i--) if (!isEqual(a[i], b[i], options)) return !1;
        return !0;
      }
      if (!isPlainObject$3(a)) return !1;
      const ka = objectKeys(a),
        kb = objectKeys(b);
      if (ka.length !== kb.length) return !1;
      ka.sort(), kb.sort();
      for (let i = ka.length - 1; i >= 0; i--) if (ka[i] != kb[i]) return !1;
      for (let i = ka.length - 1; i >= 0; i--) {
        const key = ka[i];
        if (!isEqual(a[key], b[key], options)) return !1;
      }
      return !0;
    }

    function last(val) {
      if (isArrayLike$3(val)) {
        return val[val.length - 1];
      }
    }
    const maxInArray = (arr, compareFn) => {
      var _a;
      if (0 === arr.length) return;
      let max = arr[0];
      for (let i = 1; i < arr.length; i++) {
        const value = arr[i];
        (null !== (_a = null == compareFn ? void 0 : compareFn(value, max)) && void 0 !== _a ? _a : value - max) > 0 && (max = value);
      }
      return max;
    };
    const minInArray = (arr, compareFn) => {
      var _a;
      if (0 === arr.length) return;
      let min = arr[0];
      for (let i = 1; i < arr.length; i++) {
        const value = arr[i];
        (null !== (_a = null == compareFn ? void 0 : compareFn(value, min)) && void 0 !== _a ? _a : value - min) < 0 && (min = value);
      }
      return min;
    };
    function arrayEqual(a, b) {
      if (!isArray$7(a) || !isArray$7(b)) return !1;
      if (a.length !== b.length) return !1;
      for (let i = 0; i < a.length; i++) if (a[i] !== b[i]) return !1;
      return !0;
    }

    function degreeToRadian(degree) {
      return degree * (Math.PI / 180);
    }

    const eastAsianCharacterInfo = character => {
      let x = character.charCodeAt(0),
        y = 2 === character.length ? character.charCodeAt(1) : 0,
        codePoint = x;
      return 55296 <= x && x <= 56319 && 56320 <= y && y <= 57343 && (x &= 1023, y &= 1023, codePoint = x << 10 | y, codePoint += 65536), 12288 === codePoint || 65281 <= codePoint && codePoint <= 65376 || 65504 <= codePoint && codePoint <= 65510 ? "F" : 8361 === codePoint || 65377 <= codePoint && codePoint <= 65470 || 65474 <= codePoint && codePoint <= 65479 || 65482 <= codePoint && codePoint <= 65487 || 65490 <= codePoint && codePoint <= 65495 || 65498 <= codePoint && codePoint <= 65500 || 65512 <= codePoint && codePoint <= 65518 ? "H" : 4352 <= codePoint && codePoint <= 4447 || 4515 <= codePoint && codePoint <= 4519 || 4602 <= codePoint && codePoint <= 4607 || 9001 <= codePoint && codePoint <= 9002 || 11904 <= codePoint && codePoint <= 11929 || 11931 <= codePoint && codePoint <= 12019 || 12032 <= codePoint && codePoint <= 12245 || 12272 <= codePoint && codePoint <= 12283 || 12289 <= codePoint && codePoint <= 12350 || 12353 <= codePoint && codePoint <= 12438 || 12441 <= codePoint && codePoint <= 12543 || 12549 <= codePoint && codePoint <= 12589 || 12593 <= codePoint && codePoint <= 12686 || 12688 <= codePoint && codePoint <= 12730 || 12736 <= codePoint && codePoint <= 12771 || 12784 <= codePoint && codePoint <= 12830 || 12832 <= codePoint && codePoint <= 12871 || 12880 <= codePoint && codePoint <= 13054 || 13056 <= codePoint && codePoint <= 19903 || 19968 <= codePoint && codePoint <= 42124 || 42128 <= codePoint && codePoint <= 42182 || 43360 <= codePoint && codePoint <= 43388 || 44032 <= codePoint && codePoint <= 55203 || 55216 <= codePoint && codePoint <= 55238 || 55243 <= codePoint && codePoint <= 55291 || 63744 <= codePoint && codePoint <= 64255 || 65040 <= codePoint && codePoint <= 65049 || 65072 <= codePoint && codePoint <= 65106 || 65108 <= codePoint && codePoint <= 65126 || 65128 <= codePoint && codePoint <= 65131 || 110592 <= codePoint && codePoint <= 110593 || 127488 <= codePoint && codePoint <= 127490 || 127504 <= codePoint && codePoint <= 127546 || 127552 <= codePoint && codePoint <= 127560 || 127568 <= codePoint && codePoint <= 127569 || 131072 <= codePoint && codePoint <= 194367 || 177984 <= codePoint && codePoint <= 196605 || 196608 <= codePoint && codePoint <= 262141 ? "W" : 32 <= codePoint && codePoint <= 126 || 162 <= codePoint && codePoint <= 163 || 165 <= codePoint && codePoint <= 166 || 172 === codePoint || 175 === codePoint || 10214 <= codePoint && codePoint <= 10221 || 10629 <= codePoint && codePoint <= 10630 ? "Na" : 161 === codePoint || 164 === codePoint || 167 <= codePoint && codePoint <= 168 || 170 === codePoint || 173 <= codePoint && codePoint <= 174 || 176 <= codePoint && codePoint <= 180 || 182 <= codePoint && codePoint <= 186 || 188 <= codePoint && codePoint <= 191 || 198 === codePoint || 208 === codePoint || 215 <= codePoint && codePoint <= 216 || 222 <= codePoint && codePoint <= 225 || 230 === codePoint || 232 <= codePoint && codePoint <= 234 || 236 <= codePoint && codePoint <= 237 || 240 === codePoint || 242 <= codePoint && codePoint <= 243 || 247 <= codePoint && codePoint <= 250 || 252 === codePoint || 254 === codePoint || 257 === codePoint || 273 === codePoint || 275 === codePoint || 283 === codePoint || 294 <= codePoint && codePoint <= 295 || 299 === codePoint || 305 <= codePoint && codePoint <= 307 || 312 === codePoint || 319 <= codePoint && codePoint <= 322 || 324 === codePoint || 328 <= codePoint && codePoint <= 331 || 333 === codePoint || 338 <= codePoint && codePoint <= 339 || 358 <= codePoint && codePoint <= 359 || 363 === codePoint || 462 === codePoint || 464 === codePoint || 466 === codePoint || 468 === codePoint || 470 === codePoint || 472 === codePoint || 474 === codePoint || 476 === codePoint || 593 === codePoint || 609 === codePoint || 708 === codePoint || 711 === codePoint || 713 <= codePoint && codePoint <= 715 || 717 === codePoint || 720 === codePoint || 728 <= codePoint && codePoint <= 731 || 733 === codePoint || 735 === codePoint || 768 <= codePoint && codePoint <= 879 || 913 <= codePoint && codePoint <= 929 || 931 <= codePoint && codePoint <= 937 || 945 <= codePoint && codePoint <= 961 || 963 <= codePoint && codePoint <= 969 || 1025 === codePoint || 1040 <= codePoint && codePoint <= 1103 || 1105 === codePoint || 8208 === codePoint || 8211 <= codePoint && codePoint <= 8214 || 8216 <= codePoint && codePoint <= 8217 || 8220 <= codePoint && codePoint <= 8221 || 8224 <= codePoint && codePoint <= 8226 || 8228 <= codePoint && codePoint <= 8231 || 8240 === codePoint || 8242 <= codePoint && codePoint <= 8243 || 8245 === codePoint || 8251 === codePoint || 8254 === codePoint || 8308 === codePoint || 8319 === codePoint || 8321 <= codePoint && codePoint <= 8324 || 8364 === codePoint || 8451 === codePoint || 8453 === codePoint || 8457 === codePoint || 8467 === codePoint || 8470 === codePoint || 8481 <= codePoint && codePoint <= 8482 || 8486 === codePoint || 8491 === codePoint || 8531 <= codePoint && codePoint <= 8532 || 8539 <= codePoint && codePoint <= 8542 || 8544 <= codePoint && codePoint <= 8555 || 8560 <= codePoint && codePoint <= 8569 || 8585 === codePoint || 8592 <= codePoint && codePoint <= 8601 || 8632 <= codePoint && codePoint <= 8633 || 8658 === codePoint || 8660 === codePoint || 8679 === codePoint || 8704 === codePoint || 8706 <= codePoint && codePoint <= 8707 || 8711 <= codePoint && codePoint <= 8712 || 8715 === codePoint || 8719 === codePoint || 8721 === codePoint || 8725 === codePoint || 8730 === codePoint || 8733 <= codePoint && codePoint <= 8736 || 8739 === codePoint || 8741 === codePoint || 8743 <= codePoint && codePoint <= 8748 || 8750 === codePoint || 8756 <= codePoint && codePoint <= 8759 || 8764 <= codePoint && codePoint <= 8765 || 8776 === codePoint || 8780 === codePoint || 8786 === codePoint || 8800 <= codePoint && codePoint <= 8801 || 8804 <= codePoint && codePoint <= 8807 || 8810 <= codePoint && codePoint <= 8811 || 8814 <= codePoint && codePoint <= 8815 || 8834 <= codePoint && codePoint <= 8835 || 8838 <= codePoint && codePoint <= 8839 || 8853 === codePoint || 8857 === codePoint || 8869 === codePoint || 8895 === codePoint || 8978 === codePoint || 9312 <= codePoint && codePoint <= 9449 || 9451 <= codePoint && codePoint <= 9547 || 9552 <= codePoint && codePoint <= 9587 || 9600 <= codePoint && codePoint <= 9615 || 9618 <= codePoint && codePoint <= 9621 || 9632 <= codePoint && codePoint <= 9633 || 9635 <= codePoint && codePoint <= 9641 || 9650 <= codePoint && codePoint <= 9651 || 9654 <= codePoint && codePoint <= 9655 || 9660 <= codePoint && codePoint <= 9661 || 9664 <= codePoint && codePoint <= 9665 || 9670 <= codePoint && codePoint <= 9672 || 9675 === codePoint || 9678 <= codePoint && codePoint <= 9681 || 9698 <= codePoint && codePoint <= 9701 || 9711 === codePoint || 9733 <= codePoint && codePoint <= 9734 || 9737 === codePoint || 9742 <= codePoint && codePoint <= 9743 || 9748 <= codePoint && codePoint <= 9749 || 9756 === codePoint || 9758 === codePoint || 9792 === codePoint || 9794 === codePoint || 9824 <= codePoint && codePoint <= 9825 || 9827 <= codePoint && codePoint <= 9829 || 9831 <= codePoint && codePoint <= 9834 || 9836 <= codePoint && codePoint <= 9837 || 9839 === codePoint || 9886 <= codePoint && codePoint <= 9887 || 9918 <= codePoint && codePoint <= 9919 || 9924 <= codePoint && codePoint <= 9933 || 9935 <= codePoint && codePoint <= 9953 || 9955 === codePoint || 9960 <= codePoint && codePoint <= 9983 || 10045 === codePoint || 10071 === codePoint || 10102 <= codePoint && codePoint <= 10111 || 11093 <= codePoint && codePoint <= 11097 || 12872 <= codePoint && codePoint <= 12879 || 57344 <= codePoint && codePoint <= 63743 || 65024 <= codePoint && codePoint <= 65039 || 65533 === codePoint || 127232 <= codePoint && codePoint <= 127242 || 127248 <= codePoint && codePoint <= 127277 || 127280 <= codePoint && codePoint <= 127337 || 127344 <= codePoint && codePoint <= 127386 || 917760 <= codePoint && codePoint <= 917999 || 983040 <= codePoint && codePoint <= 1048573 || 1048576 <= codePoint && codePoint <= 1114109 ? "A" : "N";
    };

    function getContextFont(text) {
      let defaultAttr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      let fontSizeScale = arguments.length > 2 ? arguments[2] : undefined;
      fontSizeScale || (fontSizeScale = 1);
      const {
        fontStyle = defaultAttr.fontStyle,
        fontVariant = defaultAttr.fontVariant,
        fontWeight = defaultAttr.fontWeight,
        fontSize = defaultAttr.fontSize,
        fontFamily = defaultAttr.fontFamily
      } = text;
      return (fontStyle ? fontStyle + " " : "") + (fontVariant ? fontVariant + " " : "") + (fontWeight ? fontWeight + " " : "") + fontSize * fontSizeScale + "px " + (fontFamily || "sans-serif");
    }

    class TextMeasure {
      constructor(option, textSpec) {
        this._numberCharSize = null, this._fullCharSize = null, this._letterCharSize = null, this._specialCharSizeMap = {}, this._canvas = null, this._context = null, this._contextSaved = !1, this._notSupportCanvas = !1, this._notSupportVRender = !1, this._userSpec = {}, this.specialCharSet = "-/: .,@%'\"~", this._option = option, this._userSpec = null != textSpec ? textSpec : {}, this.textSpec = this._initSpec(), isValid$3(option.specialCharSet) && (this.specialCharSet = option.specialCharSet), this._standardMethod = isValid$3(option.getTextBounds) ? this.fullMeasure.bind(this) : this.measureWithNaiveCanvas.bind(this);
      }
      initContext() {
        if (this._notSupportCanvas) return !1;
        if (isNil$3(this._canvas) && (isValid$3(this._option.getCanvasForMeasure) && (this._canvas = this._option.getCanvasForMeasure()), isNil$3(this._canvas) && "undefined" != typeof window && void 0 !== window.document && globalThis && isValid$3(globalThis.document) && (this._canvas = globalThis.document.createElement("canvas"))), isNil$3(this._context) && isValid$3(this._canvas)) {
          const context = this._canvas.getContext("2d");
          isValid$3(context) && (context.save(), context.font = getContextFont(this.textSpec), this._contextSaved = !0, this._context = context);
        }
        return !isNil$3(this._context) || (this._notSupportCanvas = !0, !1);
      }
      _initSpec() {
        var _a, _b, _c;
        const {
            defaultFontParams = {}
          } = this._option,
          {
            fontStyle = defaultFontParams.fontStyle,
            fontVariant = defaultFontParams.fontVariant,
            fontWeight = null !== (_a = defaultFontParams.fontWeight) && void 0 !== _a ? _a : "normal",
            fontSize = null !== (_b = defaultFontParams.fontSize) && void 0 !== _b ? _b : 12,
            fontFamily = null !== (_c = defaultFontParams.fontFamily) && void 0 !== _c ? _c : "sans-serif",
            align: align,
            textAlign = null != align ? align : "center",
            baseline: baseline,
            textBaseline = null != baseline ? baseline : "middle",
            ellipsis: ellipsis,
            limit: limit
          } = this._userSpec;
        let {
          lineHeight = fontSize
        } = this._userSpec;
        if (isString$4(lineHeight) && "%" === lineHeight[lineHeight.length - 1]) {
          const scale = Number.parseFloat(lineHeight.substring(0, lineHeight.length - 1)) / 100;
          lineHeight = fontSize * scale;
        }
        return {
          fontStyle: fontStyle,
          fontVariant: fontVariant,
          fontFamily: fontFamily,
          fontSize: fontSize,
          fontWeight: fontWeight,
          textAlign: textAlign,
          textBaseline: textBaseline,
          ellipsis: ellipsis,
          limit: limit,
          lineHeight: lineHeight
        };
      }
      measure(text, method) {
        switch (method) {
          case "vrender":
          case "canopus":
            return this.fullMeasure(text);
          case "canvas":
            return this.measureWithNaiveCanvas(text);
          case "simple":
            return this.quickMeasureWithoutCanvas(text);
          default:
            return this.quickMeasure(text);
        }
      }
      fullMeasure(text) {
        if (isNil$3(text)) return {
          width: 0,
          height: 0
        };
        if (isNil$3(this._option.getTextBounds) || !this._notSupportVRender) return this.measureWithNaiveCanvas(text);
        const {
          fontFamily: fontFamily,
          fontSize: fontSize,
          fontWeight: fontWeight,
          textAlign: textAlign,
          textBaseline: textBaseline,
          ellipsis: ellipsis,
          limit: limit,
          lineHeight: lineHeight
        } = this.textSpec;
        let size;
        try {
          const bounds = this._option.getTextBounds({
            text: text,
            fontFamily: fontFamily,
            fontSize: fontSize,
            fontWeight: fontWeight,
            textAlign: textAlign,
            textBaseline: textBaseline,
            ellipsis: !!ellipsis,
            maxLineWidth: limit || 1 / 0,
            lineHeight: lineHeight
          });
          size = {
            width: bounds.width(),
            height: bounds.height()
          };
        } catch (e) {
          this._notSupportVRender = !0, size = this.measureWithNaiveCanvas(text);
        }
        return size;
      }
      measureWithNaiveCanvas(text) {
        return this._measureReduce(text, this._measureWithNaiveCanvas.bind(this));
      }
      _measureWithNaiveCanvas(text) {
        var _a;
        if (!this.initContext()) return this._quickMeasureWithoutCanvas(text);
        const metrics = this._context.measureText(text),
          {
            fontSize: fontSize,
            lineHeight: lineHeight
          } = this.textSpec;
        return {
          width: metrics.width,
          height: null !== (_a = lineHeight) && void 0 !== _a ? _a : fontSize,
          fontBoundingBoxAscent: metrics.fontBoundingBoxAscent,
          fontBoundingBoxDescent: metrics.fontBoundingBoxDescent
        };
      }
      quickMeasure(text) {
        return this._measureReduce(text, this._quickMeasure.bind(this));
      }
      _quickMeasure(text) {
        const totalSize = {
          width: 0,
          height: 0
        };
        for (let i = 0; i < text.length; i++) {
          const char = text[i];
          let size = this._measureSpecialChar(char);
          isNil$3(size) && TextMeasure.NUMBERS_CHAR_SET.includes(char) && (size = this._measureNumberChar()), isNil$3(size) && ["F", "W"].includes(eastAsianCharacterInfo(char)) && (size = this._measureFullSizeChar()), isNil$3(size) && (size = this._measureLetterChar()), totalSize.width += size.width, totalSize.height = Math.max(totalSize.height, size.height), !isNil$3(size.fontBoundingBoxAscent) && (totalSize.fontBoundingBoxAscent = size.fontBoundingBoxAscent), !isNil$3(size.fontBoundingBoxDescent) && (totalSize.fontBoundingBoxDescent = size.fontBoundingBoxDescent);
        }
        return totalSize;
      }
      quickMeasureWithoutCanvas(text) {
        return this._measureReduce(text, this._quickMeasureWithoutCanvas.bind(this));
      }
      _quickMeasureWithoutCanvas(text) {
        var _a;
        const totalSize = {
            width: 0,
            height: 0
          },
          {
            fontSize: fontSize,
            lineHeight: lineHeight
          } = this.textSpec;
        for (let i = 0; i < text.length; i++) {
          const char = text[i],
            size = ["F", "W"].includes(eastAsianCharacterInfo(char)) ? 1 : .53;
          totalSize.width += size * fontSize;
        }
        return totalSize.height = null !== (_a = lineHeight) && void 0 !== _a ? _a : fontSize, totalSize;
      }
      _measureReduce(text, processor) {
        var _a;
        const {
            fontSize: fontSize,
            lineHeight: lineHeight
          } = this.textSpec,
          defaultResult = {
            width: 0,
            height: 0
          };
        if (isNil$3(text)) return defaultResult;
        if (isArray$7(text)) {
          const textArr = text.filter(isValid$3).map(s => s.toString());
          return 0 === textArr.length ? defaultResult : 1 === textArr.length ? processor(textArr[0]) : {
            width: textArr.reduce((maxWidth, cur) => Math.max(maxWidth, processor(cur).width), 0),
            height: textArr.length * ((null !== (_a = lineHeight) && void 0 !== _a ? _a : fontSize) + 1) + 1
          };
        }
        return processor(text.toString());
      }
      _measureNumberChar() {
        if (isNil$3(this._numberCharSize)) {
          const numberBounds = this._standardMethod(TextMeasure.NUMBERS_CHAR_SET);
          this._numberCharSize = {
            width: numberBounds.width / TextMeasure.NUMBERS_CHAR_SET.length,
            height: numberBounds.height,
            fontBoundingBoxAscent: numberBounds.fontBoundingBoxAscent,
            fontBoundingBoxDescent: numberBounds.fontBoundingBoxDescent
          };
        }
        return this._numberCharSize;
      }
      _measureFullSizeChar() {
        return isNil$3(this._fullCharSize) && (this._fullCharSize = this._standardMethod(TextMeasure.FULL_SIZE_CHAR)), this._fullCharSize;
      }
      _measureLetterChar() {
        if (isNil$3(this._letterCharSize)) {
          const alphabetBounds = this._standardMethod(TextMeasure.ALPHABET_CHAR_SET);
          this._letterCharSize = {
            width: alphabetBounds.width / TextMeasure.ALPHABET_CHAR_SET.length,
            height: alphabetBounds.height,
            fontBoundingBoxAscent: alphabetBounds.fontBoundingBoxAscent,
            fontBoundingBoxDescent: alphabetBounds.fontBoundingBoxDescent
          };
        }
        return this._letterCharSize;
      }
      _measureSpecialChar(char) {
        return isValid$3(this._specialCharSizeMap[char]) ? this._specialCharSizeMap[char] : this.specialCharSet.includes(char) ? (this._specialCharSizeMap[char] = this._standardMethod(char), this._specialCharSizeMap[char]) : null;
      }
      release() {
        isValid$3(this._canvas) && (this._canvas = null), isValid$3(this._context) && (this._contextSaved && (this._context.restore(), this._contextSaved = !1), this._context = null);
      }
    }
    TextMeasure.ALPHABET_CHAR_SET = "abcdefghijklmnopqrstuvwxyz", TextMeasure.NUMBERS_CHAR_SET = "0123456789", TextMeasure.FULL_SIZE_CHAR = "字";

    function transformBoundsWithMatrix(out, bounds, matrix) {
      const {
        x1: x1,
        y1: y1,
        x2: x2,
        y2: y2
      } = bounds;
      return matrix.onlyTranslate() ? (out !== bounds && out.setValue(bounds.x1, bounds.y1, bounds.x2, bounds.y2), out.translate(matrix.e, matrix.f), bounds) : (out.clear(), out.add(matrix.a * x1 + matrix.c * y1 + matrix.e, matrix.b * x1 + matrix.d * y1 + matrix.f), out.add(matrix.a * x2 + matrix.c * y1 + matrix.e, matrix.b * x2 + matrix.d * y1 + matrix.f), out.add(matrix.a * x2 + matrix.c * y2 + matrix.e, matrix.b * x2 + matrix.d * y2 + matrix.f), out.add(matrix.a * x1 + matrix.c * y2 + matrix.e, matrix.b * x1 + matrix.d * y2 + matrix.f), bounds);
    }
    class Bounds {
      constructor(bounds) {
        bounds ? this.setValue(bounds.x1, bounds.y1, bounds.x2, bounds.y2) : this.clear();
      }
      clone() {
        return new Bounds(this);
      }
      clear() {
        return this.x1 = +Number.MAX_VALUE, this.y1 = +Number.MAX_VALUE, this.x2 = -Number.MAX_VALUE, this.y2 = -Number.MAX_VALUE, this;
      }
      empty() {
        return this.x1 === +Number.MAX_VALUE && this.y1 === +Number.MAX_VALUE && this.x2 === -Number.MAX_VALUE && this.y2 === -Number.MAX_VALUE;
      }
      equals(b) {
        return this.x1 === b.x1 && this.y1 === b.y1 && this.x2 === b.x2 && this.y2 === b.y2;
      }
      setValue() {
        let x1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        let y1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        let x2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        let y2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
        return this.x1 = x1, this.y1 = y1, this.x2 = x2, this.y2 = y2, this;
      }
      set() {
        let x1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        let y1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        let x2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        let y2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
        return x2 < x1 ? (this.x2 = x1, this.x1 = x2) : (this.x1 = x1, this.x2 = x2), y2 < y1 ? (this.y2 = y1, this.y1 = y2) : (this.y1 = y1, this.y2 = y2), this;
      }
      add() {
        let x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        let y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        return x < this.x1 && (this.x1 = x), y < this.y1 && (this.y1 = y), x > this.x2 && (this.x2 = x), y > this.y2 && (this.y2 = y), this;
      }
      expand() {
        let d = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        return isArray$7(d) ? (this.y1 -= d[0], this.x2 += d[1], this.y2 += d[2], this.x1 -= d[3]) : (this.x1 -= d, this.y1 -= d, this.x2 += d, this.y2 += d), this;
      }
      round() {
        return this.x1 = Math.floor(this.x1), this.y1 = Math.floor(this.y1), this.x2 = Math.ceil(this.x2), this.y2 = Math.ceil(this.y2), this;
      }
      translate() {
        let dx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        let dy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        return this.x1 += dx, this.x2 += dx, this.y1 += dy, this.y2 += dy, this;
      }
      rotate() {
        let angle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        let x = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        let y = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        const p = this.rotatedPoints(angle, x, y);
        return this.clear().add(p[0], p[1]).add(p[2], p[3]).add(p[4], p[5]).add(p[6], p[7]);
      }
      scale() {
        let sx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        let sy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        let x = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        let y = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
        const p = this.scalePoints(sx, sy, x, y);
        return this.clear().add(p[0], p[1]).add(p[2], p[3]);
      }
      union(b) {
        return b.x1 < this.x1 && (this.x1 = b.x1), b.y1 < this.y1 && (this.y1 = b.y1), b.x2 > this.x2 && (this.x2 = b.x2), b.y2 > this.y2 && (this.y2 = b.y2), this;
      }
      intersect(b) {
        return b.x1 > this.x1 && (this.x1 = b.x1), b.y1 > this.y1 && (this.y1 = b.y1), b.x2 < this.x2 && (this.x2 = b.x2), b.y2 < this.y2 && (this.y2 = b.y2), this;
      }
      encloses(b) {
        return b && this.x1 <= b.x1 && this.x2 >= b.x2 && this.y1 <= b.y1 && this.y2 >= b.y2;
      }
      alignsWith(b) {
        return b && (this.x1 === b.x1 || this.x2 === b.x2 || this.y1 === b.y1 || this.y2 === b.y2);
      }
      intersects(b) {
        return b && !(this.x2 < b.x1 || this.x1 > b.x2 || this.y2 < b.y1 || this.y1 > b.y2);
      }
      contains() {
        let x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        let y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        return !(x < this.x1 || x > this.x2 || y < this.y1 || y > this.y2);
      }
      containsPoint(p) {
        return !(p.x < this.x1 || p.x > this.x2 || p.y < this.y1 || p.y > this.y2);
      }
      width() {
        return this.empty() ? 0 : this.x2 - this.x1;
      }
      height() {
        return this.empty() ? 0 : this.y2 - this.y1;
      }
      scaleX() {
        let s = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        return this.x1 *= s, this.x2 *= s, this;
      }
      scaleY() {
        let s = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        return this.y1 *= s, this.y2 *= s, this;
      }
      transformWithMatrix(matrix) {
        return transformBoundsWithMatrix(this, this, matrix), this;
      }
      copy(b) {
        return this.x1 = b.x1, this.y1 = b.y1, this.x2 = b.x2, this.y2 = b.y2, this;
      }
      rotatedPoints(angle, x, y) {
        const {
            x1: x1,
            y1: y1,
            x2: x2,
            y2: y2
          } = this,
          cos = Math.cos(angle),
          sin = Math.sin(angle),
          cx = x - x * cos + y * sin,
          cy = y - x * sin - y * cos;
        return [cos * x1 - sin * y1 + cx, sin * x1 + cos * y1 + cy, cos * x1 - sin * y2 + cx, sin * x1 + cos * y2 + cy, cos * x2 - sin * y1 + cx, sin * x2 + cos * y1 + cy, cos * x2 - sin * y2 + cx, sin * x2 + cos * y2 + cy];
      }
      scalePoints(sx, sy, x, y) {
        const {
          x1: x1,
          y1: y1,
          x2: x2,
          y2: y2
        } = this;
        return [sx * x1 + (1 - sx) * x, sy * y1 + (1 - sy) * y, sx * x2 + (1 - sx) * x, sy * y2 + (1 - sy) * y];
      }
    }
    class AABBBounds extends Bounds {}

    const registeredAggregators = {};
    class Aggregator {
        isAggregator = true;
        isRecord = true;
        records = [];
        type;
        key;
        field;
        formatFun;
        _formatedValue;
        constructor(config) {
            this.key = config.key;
            this.field = config.field;
            this.formatFun = config.formatFun;
            this.isRecord = config.isRecord ?? this.isRecord;
        }
        clearCacheValue() {
            this._formatedValue = undefined;
        }
        formatValue(col, row, table) {
            if (!this._formatedValue) {
                if (this.formatFun) {
                    this._formatedValue = this.formatFun(this.value(), col, row, table);
                }
                else {
                    this._formatedValue = this.value();
                }
            }
            return this._formatedValue;
        }
        reset() {
            this.records = [];
            this.clearCacheValue();
        }
    }
    class RecordAggregator extends Aggregator {
        type = AggregationType.RECORD;
        isRecord = true;
        push(record) {
            if (record && this.isRecord && this.records) {
                if (record.isAggregator) {
                    this.records.push(...record.records);
                }
                else {
                    this.records.push(record);
                }
            }
            this.clearCacheValue();
        }
        deleteRecord(record) {
            if (record) {
                if (this.isRecord && this.records) {
                    this.records = this.records.filter(item => item !== record);
                }
            }
            this.clearCacheValue();
        }
        updateRecord(oldRecord, newRecord) {
            if (oldRecord && newRecord) {
                if (this.isRecord && this.records) {
                    this.records = this.records.map(item => {
                        if (item === oldRecord) {
                            return newRecord;
                        }
                        return item;
                    });
                }
                this.clearCacheValue();
            }
        }
        value() {
            return this.records;
        }
        reset() {
            this.records = [];
        }
        recalculate() {
        }
    }
    class NoneAggregator extends Aggregator {
        type = AggregationType.NONE;
        isRecord = true;
        fieldValue;
        push(record) {
            if (record) {
                if (this.isRecord) {
                    this.records = [record];
                }
                if (this.field) {
                    this.fieldValue = record[this.field];
                }
            }
            this.clearCacheValue();
        }
        deleteRecord(record) {
            if (record) {
                if (this.isRecord && this.records) {
                    this.records = this.records.filter(item => item !== record);
                }
                if (this.field && this.records.length) {
                    this.fieldValue = this.records[this.records.length - 1][this.field];
                }
            }
            this.clearCacheValue();
        }
        updateRecord(oldRecord, newRecord) {
            if (oldRecord && newRecord) {
                if (this.isRecord && this.records) {
                    this.records = this.records.map(item => {
                        if (item === oldRecord) {
                            return newRecord;
                        }
                        return item;
                    });
                }
                if (this.field && this.records.length) {
                    this.fieldValue = this.records[this.records.length - 1][this.field];
                }
                this.clearCacheValue();
            }
        }
        value() {
            return this.fieldValue;
        }
        reset() {
            this.records = [];
            this.fieldValue = undefined;
        }
        recalculate() {
        }
    }
    class CustomAggregator extends Aggregator {
        type = AggregationType.CUSTOM;
        isRecord = true;
        aggregationFun;
        values = [];
        fieldValue;
        constructor(config) {
            super(config);
            this.aggregationFun = config.aggregationFun;
        }
        push(record) {
            if (record) {
                if (this.isRecord && this.records) {
                    if (record.isAggregator) {
                        this.records.push(...record.records);
                    }
                    else {
                        this.records.push(record);
                    }
                }
                if (this.field) {
                    this.values.push(record[this.field]);
                }
            }
            this.clearCacheValue();
        }
        updateRecord(oldRecord, newRecord) {
            if (oldRecord && newRecord) {
                if (this.isRecord && this.records) {
                    this.records = this.records.map(item => {
                        if (item === oldRecord) {
                            return newRecord;
                        }
                        return item;
                    });
                }
                if (this.field && this.records.length) {
                    this.values = this.records.map(item => item[this.field]);
                }
                this.clearCacheValue();
            }
        }
        deleteRecord(record) {
            if (record) {
                if (this.isRecord && this.records) {
                    this.records = this.records.filter(item => item !== record);
                }
                if (this.field && this.records.length) {
                    this.values = this.records.map(item => item[this.field]);
                }
            }
            this.clearCacheValue();
        }
        value() {
            if (!this.fieldValue) {
                this.fieldValue = this.aggregationFun?.(this.values, this.records, this.field);
            }
            return this.fieldValue;
        }
        reset() {
            this.records = [];
            this.fieldValue = undefined;
        }
        recalculate() {
            this.fieldValue = undefined;
            this._formatedValue = undefined;
        }
    }
    class RecalculateAggregator extends Aggregator {
        type = AggregationType.RECALCULATE;
        isRecord = true;
        calculateFun;
        fieldValue;
        dependAggregators;
        dependIndicatorKeys;
        constructor(config) {
            super(config);
            this.calculateFun = config.calculateFun;
            this.dependAggregators = config.dependAggregators;
            this.dependIndicatorKeys = config.dependIndicatorKeys;
        }
        push(record) {
            if (record && this.isRecord && this.records) {
                if (record.isAggregator) {
                    this.records.push(...record.records);
                }
                else {
                    this.records.push(record);
                }
            }
            this.clearCacheValue();
        }
        deleteRecord(record) {
            if (record) {
                if (this.isRecord && this.records) {
                    this.records = this.records.filter(item => item !== record);
                }
            }
            this.clearCacheValue();
        }
        updateRecord(oldRecord, newRecord) {
            if (oldRecord && newRecord) {
                if (this.isRecord && this.records) {
                    this.records = this.records.map(item => {
                        if (item === oldRecord) {
                            return newRecord;
                        }
                        return item;
                    });
                }
                this.clearCacheValue();
            }
        }
        value() {
            if (!this.fieldValue) {
                const aggregatorValue = _getDependAggregatorValues(this.dependAggregators, this.dependIndicatorKeys);
                this.fieldValue = this.calculateFun?.(aggregatorValue, this.records, this.field);
            }
            return this.fieldValue;
        }
        reset() {
            this.records = [];
            this.fieldValue = undefined;
        }
        recalculate() {
        }
    }
    class SumAggregator extends Aggregator {
        type = AggregationType.SUM;
        sum = 0;
        positiveSum = 0;
        nagetiveSum = 0;
        needSplitPositiveAndNegativeForSum = false;
        constructor(config) {
            super(config);
            this.needSplitPositiveAndNegativeForSum = config.needSplitPositiveAndNegative ?? false;
        }
        push(record) {
            if (record) {
                if (this.isRecord && this.records) {
                    if (record.isAggregator) {
                        this.records.push(...record.records);
                    }
                    else {
                        this.records.push(record);
                    }
                }
                if (record.isAggregator) {
                    const value = record.value();
                    this.sum += value ?? 0;
                    if (this.needSplitPositiveAndNegativeForSum) {
                        if (value > 0) {
                            this.positiveSum += value;
                        }
                        else if (value < 0) {
                            this.nagetiveSum += value;
                        }
                    }
                }
                else if (this.field && !isNaN(parseFloat(record[this.field]))) {
                    const value = parseFloat(record[this.field]);
                    this.sum += value;
                    if (this.needSplitPositiveAndNegativeForSum) {
                        if (value > 0) {
                            this.positiveSum += value;
                        }
                        else if (value < 0) {
                            this.nagetiveSum += value;
                        }
                    }
                }
            }
            this.clearCacheValue();
        }
        deleteRecord(record) {
            if (record) {
                if (this.isRecord && this.records) {
                    this.records = this.records.filter(item => item !== record);
                }
                if (record.isAggregator) {
                    const value = record.value();
                    this.sum -= value ?? 0;
                    if (this.needSplitPositiveAndNegativeForSum) {
                        if (value > 0) {
                            this.positiveSum -= value;
                        }
                        else if (value < 0) {
                            this.nagetiveSum -= value;
                        }
                    }
                }
                else if (this.field && !isNaN(parseFloat(record[this.field]))) {
                    const value = parseFloat(record[this.field]);
                    this.sum -= value;
                    if (this.needSplitPositiveAndNegativeForSum) {
                        if (value > 0) {
                            this.positiveSum -= value;
                        }
                        else if (value < 0) {
                            this.nagetiveSum -= value;
                        }
                    }
                }
            }
            this.clearCacheValue();
        }
        updateRecord(oldRecord, newRecord) {
            if (oldRecord && newRecord) {
                if (this.isRecord && this.records) {
                    this.records = this.records.map(item => {
                        if (item === oldRecord) {
                            return newRecord;
                        }
                        return item;
                    });
                }
                if (oldRecord.isAggregator) {
                    const oldValue = oldRecord.value();
                    const newValue = newRecord.value();
                    this.sum += newValue - oldValue;
                    if (this.needSplitPositiveAndNegativeForSum) {
                        if (oldValue > 0) {
                            this.positiveSum -= oldValue;
                        }
                        else if (oldValue < 0) {
                            this.nagetiveSum -= oldValue;
                        }
                        if (newValue > 0) {
                            this.positiveSum += newValue;
                        }
                        else if (newValue < 0) {
                            this.nagetiveSum += newValue;
                        }
                    }
                }
                else if (this.field && !isNaN(parseFloat(oldRecord[this.field]))) {
                    const oldValue = parseFloat(oldRecord[this.field]);
                    const newValue = parseFloat(newRecord[this.field]);
                    this.sum += newValue - oldValue;
                    if (this.needSplitPositiveAndNegativeForSum) {
                        if (oldValue > 0) {
                            this.positiveSum -= oldValue;
                        }
                        else if (oldValue < 0) {
                            this.nagetiveSum -= oldValue;
                        }
                        if (newValue > 0) {
                            this.positiveSum += newValue;
                        }
                        else if (newValue < 0) {
                            this.nagetiveSum += newValue;
                        }
                    }
                }
                this.clearCacheValue();
            }
        }
        value() {
            return this.records?.length >= 1 ? this.sum : undefined;
        }
        positiveValue() {
            return this.positiveSum;
        }
        negativeValue() {
            return this.nagetiveSum;
        }
        reset() {
            super.reset();
            this.records = [];
            this.sum = 0;
        }
        recalculate() {
            this.sum = 0;
            this._formatedValue = undefined;
            if (this.records) {
                for (let i = 0; i < this.records.length; i++) {
                    const record = this.records[i];
                    if (record.isAggregator) {
                        const value = record.value();
                        this.sum += value ?? 0;
                        if (this.needSplitPositiveAndNegativeForSum) {
                            if (value > 0) {
                                this.positiveSum += value;
                            }
                            else if (value < 0) {
                                this.nagetiveSum += value;
                            }
                        }
                    }
                    else if (this.field && !isNaN(parseFloat(record[this.field]))) {
                        const value = parseFloat(record[this.field]);
                        this.sum += value;
                        if (this.needSplitPositiveAndNegativeForSum) {
                            if (value > 0) {
                                this.positiveSum += value;
                            }
                            else if (value < 0) {
                                this.nagetiveSum += value;
                            }
                        }
                    }
                }
            }
        }
    }
    class CountAggregator extends Aggregator {
        type = AggregationType.COUNT;
        count = 0;
        push(record) {
            if (record) {
                if (this.isRecord && this.records) {
                    if (record.isAggregator) {
                        this.records.push(...record.records);
                    }
                    else {
                        this.records.push(record);
                    }
                }
                if (record.isAggregator) {
                    this.count += record.value();
                }
                else {
                    this.count++;
                }
            }
            this.clearCacheValue();
        }
        deleteRecord(record) {
            if (record) {
                if (this.isRecord && this.records) {
                    this.records = this.records.filter(item => item !== record);
                }
                if (record.isAggregator) {
                    this.count -= record.value();
                }
                else {
                    this.count--;
                }
            }
            this.clearCacheValue();
        }
        updateRecord(oldRecord, newRecord) {
            if (oldRecord && newRecord) {
                if (this.isRecord && this.records) {
                    this.records = this.records.map(item => {
                        if (item === oldRecord) {
                            return newRecord;
                        }
                        return item;
                    });
                }
                if (oldRecord.isAggregator) {
                    this.count += newRecord.value() - oldRecord.value();
                }
            }
        }
        value() {
            return this.count;
        }
        reset() {
            this.records = [];
            this.count = 0;
        }
        recalculate() {
            this.count = 0;
            this._formatedValue = undefined;
            if (this.records) {
                for (let i = 0; i < this.records.length; i++) {
                    const record = this.records[i];
                    if (record.isAggregator) {
                        this.count += record.value();
                    }
                    else {
                        this.count++;
                    }
                }
            }
        }
    }
    class AvgAggregator extends Aggregator {
        type = AggregationType.AVG;
        sum = 0;
        count = 0;
        push(record) {
            if (record) {
                if (this.isRecord && this.records) {
                    if (record.isAggregator) {
                        this.records.push(...record.records);
                    }
                    else {
                        this.records.push(record);
                    }
                }
                if (record.isAggregator && record.type === AggregationType.AVG) {
                    this.sum += record.sum;
                    this.count += record.count;
                }
                else if (this.field && !isNaN(parseFloat(record[this.field]))) {
                    this.sum += parseFloat(record[this.field]);
                    this.count++;
                }
            }
            this.clearCacheValue();
        }
        deleteRecord(record) {
            if (record) {
                if (this.isRecord && this.records) {
                    this.records = this.records.filter(item => item !== record);
                }
                if (record.isAggregator && record.type === AggregationType.AVG) {
                    this.sum -= record.sum;
                    this.count -= record.count;
                }
                else if (this.field && !isNaN(parseFloat(record[this.field]))) {
                    this.sum -= parseFloat(record[this.field]);
                    this.count--;
                }
            }
            this.clearCacheValue();
        }
        updateRecord(oldRecord, newRecord) {
            if (oldRecord && newRecord) {
                if (this.isRecord && this.records) {
                    this.records = this.records.map(item => {
                        if (item === oldRecord) {
                            return newRecord;
                        }
                        return item;
                    });
                }
                if (oldRecord.isAggregator && oldRecord.type === AggregationType.AVG) {
                    this.sum += newRecord.sum - oldRecord.sum;
                    this.count += newRecord.count - oldRecord.count;
                }
                else if (this.field && !isNaN(parseFloat(oldRecord[this.field]))) {
                    this.sum += parseFloat(newRecord[this.field]) - parseFloat(oldRecord[this.field]);
                }
                this.clearCacheValue();
            }
        }
        value() {
            return this.records?.length >= 1 ? this.sum / this.count : undefined;
        }
        reset() {
            this.records = [];
            this.sum = 0;
            this.count = 0;
        }
        recalculate() {
            this.sum = 0;
            this.count = 0;
            this._formatedValue = undefined;
            if (this.records) {
                for (let i = 0; i < this.records.length; i++) {
                    const record = this.records[i];
                    if (record.isAggregator && record.type === AggregationType.AVG) {
                        this.sum += record.sum;
                        this.count += record.count;
                    }
                    else if (this.field && !isNaN(parseFloat(record[this.field]))) {
                        this.sum += parseFloat(record[this.field]);
                        this.count++;
                    }
                }
            }
        }
    }
    class MaxAggregator extends Aggregator {
        type = AggregationType.MAX;
        max = Number.MIN_SAFE_INTEGER;
        push(record) {
            if (record) {
                if (this.isRecord && this.records) {
                    if (record.isAggregator) {
                        this.records.push(...record.records);
                    }
                    else {
                        this.records.push(record);
                    }
                }
                if (record.isAggregator) {
                    this.max = record.max > this.max ? record.max : this.max;
                }
                else if (typeof record === 'number') {
                    this.max = record > this.max ? record : this.max;
                }
                else if (this.field && typeof record[this.field] === 'number') {
                    this.max = record[this.field] > this.max ? record[this.field] : this.max;
                }
                else if (this.field && !isNaN(record[this.field])) {
                    this.max = parseFloat(record[this.field]) > this.max ? parseFloat(record[this.field]) : this.max;
                }
            }
            this.clearCacheValue();
        }
        deleteRecord(record) {
            if (record) {
                if (this.isRecord && this.records) {
                    this.records = this.records.filter(item => item !== record);
                }
                this.recalculate();
            }
        }
        updateRecord(oldRecord, newRecord) {
            if (oldRecord && newRecord) {
                if (this.isRecord && this.records) {
                    this.records = this.records.map(item => {
                        if (item === oldRecord) {
                            return newRecord;
                        }
                        return item;
                    });
                }
                this.recalculate();
            }
        }
        value() {
            return this.records?.length >= 1 ? this.max : undefined;
        }
        reset() {
            this.records = [];
            this.max = Number.MIN_SAFE_INTEGER;
        }
        recalculate() {
            this.max = Number.MIN_SAFE_INTEGER;
            this._formatedValue = undefined;
            if (this.records) {
                for (let i = 0; i < this.records.length; i++) {
                    const record = this.records[i];
                    if (record.isAggregator) {
                        this.max = record.max > this.max ? record.max : this.max;
                    }
                    else if (typeof record === 'number') {
                        this.max = record > this.max ? record : this.max;
                    }
                    else if (this.field && typeof record[this.field] === 'number') {
                        this.max = record[this.field] > this.max ? record[this.field] : this.max;
                    }
                    else if (this.field && !isNaN(record[this.field])) {
                        this.max = parseFloat(record[this.field]) > this.max ? parseFloat(record[this.field]) : this.max;
                    }
                }
            }
        }
    }
    class MinAggregator extends Aggregator {
        type = AggregationType.MIN;
        min = Number.MAX_SAFE_INTEGER;
        push(record) {
            if (record) {
                if (this.isRecord && this.records) {
                    if (record.isAggregator) {
                        this.records.push(...record.records);
                    }
                    else {
                        this.records.push(record);
                    }
                }
                if (record.isAggregator) {
                    this.min = record.min < this.min ? record.min : this.min;
                }
                else if (typeof record === 'number') {
                    this.min = record < this.min ? record : this.min;
                }
                else if (this.field && typeof record[this.field] === 'number') {
                    this.min = record[this.field] < this.min ? record[this.field] : this.min;
                }
                else if (this.field && !isNaN(record[this.field])) {
                    this.min = parseFloat(record[this.field]) < this.min ? parseFloat(record[this.field]) : this.min;
                }
            }
            this.clearCacheValue();
        }
        deleteRecord(record) {
            if (record) {
                if (this.isRecord && this.records) {
                    this.records = this.records.filter(item => item !== record);
                }
                this.recalculate();
            }
        }
        updateRecord(oldRecord, newRecord) {
            if (oldRecord && newRecord) {
                if (this.isRecord && this.records) {
                    this.records = this.records.map(item => {
                        if (item === oldRecord) {
                            return newRecord;
                        }
                        return item;
                    });
                }
                this.recalculate();
            }
        }
        value() {
            return this.records?.length >= 1 ? this.min : undefined;
        }
        reset() {
            this.records = [];
            this.min = Number.MAX_SAFE_INTEGER;
        }
        recalculate() {
            this.min = Number.MAX_SAFE_INTEGER;
            this._formatedValue = undefined;
            if (this.records) {
                for (let i = 0; i < this.records.length; i++) {
                    const record = this.records[i];
                    if (record.isAggregator) {
                        this.min = record.min < this.min ? record.min : this.min;
                    }
                    else if (typeof record === 'number') {
                        this.min = record < this.min ? record : this.min;
                    }
                    else if (this.field && typeof record[this.field] === 'number') {
                        this.min = record[this.field] < this.min ? record[this.field] : this.min;
                    }
                    else if (this.field && !isNaN(record[this.field])) {
                        this.min = parseFloat(record[this.field]) < this.min ? parseFloat(record[this.field]) : this.min;
                    }
                }
            }
        }
    }
    function indicatorSort(a, b) {
        if (a && b) {
            return a.toString().localeCompare(b.toString(), 'zh');
        }
        if (a) {
            return 1;
        }
        return -1;
    }
    function typeSort(a, b, sortType) {
        if (sortType === SortType.NORMAL || sortType === SortType.normal) {
            return 0;
        }
        const factor = sortType === SortType.DESC || sortType === SortType.desc ? -1 : 1;
        if (a && b) {
            return a.toString().localeCompare(b.toString(), 'zh') * factor;
        }
        if (a) {
            return 1 * factor;
        }
        return -1 * factor;
    }
    function naturalSort(as, bs, sortType) {
        if (sortType === SortType.NORMAL || sortType === SortType.normal) {
            return 0;
        }
        const rx = /(\d+)|(\D+)/g;
        const rd = /\d/;
        const rz = /^0/;
        let a;
        let a1;
        let b;
        let b1;
        let nas = 0;
        let nbs = 0;
        const factor = sortType === SortType.DESC || sortType === SortType.desc ? -1 : 1;
        if (bs !== null && as === null) {
            return -1 * factor;
        }
        if (as !== null && bs === null) {
            return 1 * factor;
        }
        if (typeof as === 'number' && isNaN(as)) {
            return -1 * factor;
        }
        if (typeof bs === 'number' && isNaN(bs)) {
            return 1 * factor;
        }
        nas = +as;
        nbs = +bs;
        if (nas < nbs) {
            return -1 * factor;
        }
        if (nas > nbs) {
            return 1 * factor;
        }
        if (typeof as === 'number' && typeof bs !== 'number') {
            return -1 * factor;
        }
        if (typeof bs === 'number' && typeof as !== 'number') {
            return 1 * factor;
        }
        if (typeof as === 'number' && typeof bs === 'number') {
            return 0;
        }
        if (isNaN(nbs) && !isNaN(nas)) {
            return -1 * factor;
        }
        if (isNaN(nas) && !isNaN(nbs)) {
            return 1 * factor;
        }
        a = String(as);
        b = String(bs);
        if (a === b) {
            return 0;
        }
        if (!(rd.test(a) && rd.test(b))) {
            return (a > b ? 1 : -1) * factor;
        }
        a = a.match(rx);
        b = b.match(rx);
        while (a.length && b.length) {
            a1 = a.shift();
            b1 = b.shift();
            if (a1 !== b1) {
                if (rd.test(a1) && rd.test(b1)) {
                    return (a1.replace(rz, '.0') - b1.replace(rz, '.0')) * factor;
                }
                return (a1 > b1 ? 1 : -1) * factor;
            }
        }
        return (a.length - b.length) * factor;
    }
    function sortBy(order) {
        let x;
        const mapping = {};
        const lowercase_mapping = {};
        for (let i = 0; i < order.length; i++) {
            x = order[i];
            mapping[x] = i;
            if (typeof x === 'string') {
                lowercase_mapping[x.toLowerCase()] = i;
            }
        }
        return function (a, b, sortType) {
            if (sortType === SortType.NORMAL || sortType === SortType.normal) {
                return 0;
            }
            const factor = sortType === SortType.DESC || sortType === SortType.desc ? -1 : 1;
            let comparison;
            if (mapping[a] !== null && mapping[a] !== undefined && mapping[b] !== null && mapping[b] !== undefined) {
                comparison = mapping[a] - mapping[b];
            }
            else if (mapping[a] !== null && mapping[a] !== undefined) {
                comparison = -1;
            }
            else if (mapping[b] !== null && mapping[b] !== undefined) {
                comparison = 1;
            }
            else if (lowercase_mapping[a] !== null &&
                mapping[a] !== undefined &&
                lowercase_mapping[b] !== null &&
                mapping[b] !== undefined) {
                comparison = lowercase_mapping[a] - lowercase_mapping[b];
            }
            else if (lowercase_mapping[a] === null ||
                mapping[a] === undefined ||
                lowercase_mapping[b] === null ||
                mapping[b] === undefined) {
                comparison = 0;
            }
            else if (lowercase_mapping[a] !== null && mapping[a] !== undefined) {
                comparison = -1;
            }
            else if (lowercase_mapping[b] !== null && mapping[b] !== undefined) {
                comparison = 1;
            }
            if (isValid$3(comparison)) {
                return comparison * factor;
            }
            return naturalSort(a, b, sortType);
        };
    }
    function _getDependAggregatorValues(aggregators, dependIndicatorKeys) {
        const dependAggregatorValues = {};
        for (let m = 0; m < dependIndicatorKeys?.length; m++) {
            const aggrator = aggregators.find(aggrator => aggrator?.key === dependIndicatorKeys[m]);
            if (aggrator) {
                dependAggregatorValues[aggrator.key] = aggrator?.value();
            }
        }
        return dependAggregatorValues;
    }

    var index$2 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        get AggregationType () { return AggregationType; },
        Aggregator: Aggregator,
        AvgAggregator: AvgAggregator,
        CountAggregator: CountAggregator,
        CustomAggregator: CustomAggregator,
        get HierarchyState () { return HierarchyState; },
        get HighlightScope () { return HighlightScope; },
        get IconFuncTypeEnum () { return IconFuncTypeEnum; },
        get IconPosition () { return IconPosition; },
        get InteractionState () { return InteractionState; },
        get InternalIconName () { return InternalIconName; },
        MaxAggregator: MaxAggregator,
        MinAggregator: MinAggregator,
        NoneAggregator: NoneAggregator,
        get Placement () { return Placement; },
        RecalculateAggregator: RecalculateAggregator,
        RecordAggregator: RecordAggregator,
        get SortType () { return SortType; },
        SumAggregator: SumAggregator,
        cellStyleKeys: cellStyleKeys,
        indicatorSort: indicatorSort,
        naturalSort: naturalSort,
        registeredAggregators: registeredAggregators,
        sortBy: sortBy,
        typeSort: typeSort
    });

    let idCount$1 = 1;
    let EventTarget$1 = class EventTarget {
        listenersData = {
            listeners: {},
            listenerData: {}
        };
        on(type, listener) {
            const list = this.listenersData.listeners[type] || (this.listenersData.listeners[type] = []);
            list.push(listener);
            const id = idCount$1++;
            this.listenersData.listenerData[id] = {
                type,
                listener,
                remove: () => {
                    delete this.listenersData.listenerData[id];
                    const index = list.indexOf(listener);
                    list.splice(index, 1);
                    if (!this.listenersData.listeners[type].length) {
                        delete this.listenersData.listeners[type];
                    }
                }
            };
            return id;
        }
        off(idOrType, listener) {
            if (listener) {
                const type = idOrType;
                this.removeEventListener(type, listener);
            }
            else {
                const id = idOrType;
                if (!this.listenersData) {
                    return;
                }
                this.listenersData.listenerData[id]?.remove();
            }
        }
        addEventListener(type, listener, option) {
            this.on(type, listener);
        }
        removeEventListener(type, listener) {
            if (!this.listenersData) {
                return;
            }
            for (const key in this.listenersData.listenerData) {
                const listenerData = this.listenersData.listenerData[key];
                if (listenerData.type === type && listenerData.listener === listener) {
                    this.off(key);
                }
            }
        }
        hasListeners(type) {
            if (!this.listenersData) {
                return false;
            }
            return !!this.listenersData.listeners[type];
        }
        fireListeners(type, event) {
            if (!this.listenersData) {
                return [];
            }
            const list = this.listenersData.listeners[type];
            if (!list) {
                return [];
            }
            return list.map(listener => listener.call(this, event)).filter(r => isValid$3(r));
        }
        release() {
            delete this.listenersData;
        }
    };

    let defaultStyle$b;
    const STYLE_EVENT_TYPE = {
        CHANGE_STYLE: 'change_style'
    };
    let Style$1 = class Style extends EventTarget$1 {
        _color;
        _strokeColor;
        _fontSize;
        _fontFamily;
        _fontWeight;
        _fontVariant;
        _fontStyle;
        _padding;
        _defaultPadding = [10, 16, 10, 16];
        _textStick;
        _textStickBaseOnAlign;
        _textOverflow;
        _textAlign;
        _textBaseline;
        _bgColor;
        _borderColor;
        _lineHeight;
        _underline;
        _underlineColor;
        _underlineDash;
        _underlineOffset;
        _lineThrough;
        _lineThroughColor;
        _lineThroughDash;
        _linkColor;
        _cursor;
        _borderLineWidth;
        _borderLineDash;
        _marked;
        static get EVENT_TYPE() {
            return STYLE_EVENT_TYPE;
        }
        static get DEFAULT() {
            return defaultStyle$b ? defaultStyle$b : (defaultStyle$b = new Style());
        }
        constructor(style = {}, bodyStyle = {}) {
            super();
            this._textAlign = style?.textAlign ?? bodyStyle?.textAlign;
            this._textBaseline = style?.textBaseline ?? bodyStyle?.textBaseline;
            this._color = style?.color ?? bodyStyle?.color;
            this._strokeColor = style?.strokeColor ?? bodyStyle?.strokeColor;
            this._fontSize = style.fontSize ?? bodyStyle?.fontSize;
            this._fontFamily = style.fontFamily ?? bodyStyle?.fontFamily;
            this._fontWeight = style.fontWeight ?? bodyStyle?.fontWeight;
            this._fontVariant = style.fontVariant ?? bodyStyle?.fontVariant;
            this._fontStyle = style.fontStyle ?? bodyStyle?.fontStyle;
            this._padding = style?.padding ?? bodyStyle?.padding ?? this._defaultPadding;
            this._borderColor = style?.borderColor ?? bodyStyle?.borderColor;
            this._textOverflow = style?.textOverflow ?? bodyStyle?.textOverflow;
            this._textStick = style.textStick ?? bodyStyle?.textStick ?? false;
            this._textStickBaseOnAlign = style.textStickBaseOnAlign ?? bodyStyle?.textStickBaseOnAlign ?? false;
            this._bgColor = style?.bgColor ?? bodyStyle?.bgColor;
            this._lineHeight = style?.lineHeight ?? bodyStyle?.lineHeight;
            this._underline = style?.underline ?? bodyStyle?.underline;
            this._underlineColor = style?.underlineColor ?? bodyStyle?.underlineColor;
            this._underlineDash = style?.underlineDash ?? bodyStyle?.underlineDash;
            this._underlineOffset = style?.underlineOffset ?? bodyStyle?.underlineOffset;
            this._lineThrough = style?.lineThrough ?? bodyStyle?.lineThrough;
            this._lineThroughColor = style?.lineThroughColor ?? bodyStyle?.lineThroughColor;
            this._lineThroughDash = style?.lineThroughDash ?? bodyStyle?.lineThroughDash;
            this._linkColor = style?.linkColor ?? bodyStyle?.linkColor;
            this._cursor = style.cursor ?? bodyStyle?.cursor;
            this._borderLineWidth = style.borderLineWidth ?? bodyStyle?.borderLineWidth;
            this._borderLineDash = style.borderLineDash ?? bodyStyle?.borderLineDash;
            this._marked = style.marked ?? bodyStyle?.marked;
        }
        get color() {
            return this._color;
        }
        set color(color) {
            this._color = color;
        }
        get strokeColor() {
            return this._strokeColor;
        }
        set strokeColor(strokeColor) {
            this._strokeColor = strokeColor;
        }
        get fontSize() {
            return this._fontSize;
        }
        set fontSize(fontSize) {
            this._fontSize = fontSize;
        }
        get fontFamily() {
            return this._fontFamily;
        }
        set fontFamily(fontFamily) {
            this._fontFamily = fontFamily;
        }
        get fontWeight() {
            return this._fontWeight;
        }
        set fontWeight(fontWeight) {
            this._fontWeight = fontWeight;
        }
        get fontVariant() {
            return this._fontVariant;
        }
        set fontVariant(fontVariant) {
            this._fontVariant = fontVariant;
        }
        get fontStyle() {
            return this._fontStyle;
        }
        set fontStyle(fontStyle) {
            this._fontStyle = fontStyle;
        }
        get padding() {
            return this._padding;
        }
        set padding(padding) {
            this._padding = padding;
        }
        get textOverflow() {
            return this._textOverflow;
        }
        set textOverflow(textOverflow) {
            this._textOverflow = textOverflow;
        }
        get bgColor() {
            return this._bgColor;
        }
        set bgColor(bgColor) {
            this._bgColor = bgColor;
        }
        get borderColor() {
            return this._borderColor;
        }
        set borderColor(borderColor) {
            this._borderColor = borderColor;
        }
        get textStick() {
            return this._textStick;
        }
        set textStick(textStick) {
            this._textStick = textStick;
        }
        get textStickBaseOnAlign() {
            return this._textStickBaseOnAlign;
        }
        set textStickBaseOnAlign(textStickBaseOnAlign) {
            this._textStickBaseOnAlign = textStickBaseOnAlign;
        }
        get textAlign() {
            return this._textAlign;
        }
        set textAlign(textAlign) {
            this._textAlign = textAlign;
        }
        get textBaseline() {
            return this._textBaseline;
        }
        set textBaseline(textBaseline) {
            this._textBaseline = textBaseline;
        }
        get lineHeight() {
            return this._lineHeight;
        }
        set lineHeight(lineHeight) {
            this._lineHeight = lineHeight;
        }
        get underline() {
            return this._underline;
        }
        set underline(underline) {
            this._underline = underline;
        }
        get underlineColor() {
            return this._underlineColor;
        }
        set underlineColor(underlineColor) {
            this._underlineColor = underlineColor;
        }
        get underlineDash() {
            return this._underlineDash;
        }
        set underlineDash(underlineDash) {
            this._underlineDash = underlineDash;
        }
        get underlineOffset() {
            return this._underlineOffset;
        }
        set underlineOffset(underlineOffset) {
            this._underlineOffset = underlineOffset;
        }
        get lineThrough() {
            return this._lineThrough;
        }
        set lineThrough(lineThrough) {
            this._lineThrough = lineThrough;
        }
        get lineThroughColor() {
            return this._lineThroughColor;
        }
        set lineThroughColor(lineThroughColor) {
            this._lineThroughColor = lineThroughColor;
        }
        get lineThroughDash() {
            return this._lineThroughDash;
        }
        set lineThroughDash(lineThroughDash) {
            this._lineThroughDash = lineThroughDash;
        }
        get linkColor() {
            return this._linkColor;
        }
        set linkColor(linkColor) {
            this._linkColor = linkColor;
        }
        get cursor() {
            return this._cursor;
        }
        set cursor(cursor) {
            this._cursor = cursor;
        }
        get borderLineWidth() {
            return this._borderLineWidth;
        }
        set borderLineWidth(borderLineWidth) {
            this._borderLineWidth = borderLineWidth;
        }
        get borderLineDash() {
            return this._borderLineDash;
        }
        set borderLineDash(borderLineDash) {
            this._borderLineDash = borderLineDash;
        }
        get marked() {
            return this._marked;
        }
        set marked(marked) {
            this._marked = marked;
        }
        clone() {
            return new Style(this, null);
        }
    };

    let defaultStyle$a;
    let ImageStyle$1 = class ImageStyle extends Style$1 {
        static get DEFAULT() {
            return defaultStyle$a ? defaultStyle$a : (defaultStyle$a = new ImageStyle());
        }
        constructor(style = {}, bodyStyle = {}) {
            super(style, bodyStyle);
        }
        clone() {
            return new ImageStyle(this, null);
        }
    };

    let defaultStyle$9;
    class TextStyle extends Style$1 {
        _autoWrapText;
        _lineClamp;
        static get DEFAULT() {
            return defaultStyle$9 ? defaultStyle$9 : (defaultStyle$9 = new TextStyle());
        }
        constructor(style = {}, bodyStyle = {}) {
            super(style, bodyStyle);
            this._autoWrapText = style?.autoWrapText ?? bodyStyle?.autoWrapText;
            this._lineClamp = style?.lineClamp ?? bodyStyle?.lineClamp;
        }
        clone() {
            return new TextStyle(this, null);
        }
        get lineClamp() {
            return this._lineClamp;
        }
        set lineClamp(lineClamp) {
            this._lineClamp = lineClamp;
        }
        get autoWrapText() {
            return this._autoWrapText;
        }
        set autoWrapText(autoWrapText) {
            this._autoWrapText = autoWrapText;
        }
    }

    let defaultStyle$8;
    let CheckboxStyle$1 = class CheckboxStyle extends Style$1 {
        _size;
        _spaceBetweenTextAndIcon;
        _defaultFill;
        _defaultStroke;
        _disableFill;
        _checkedFill;
        _checkedStroke;
        _disableCheckedFill;
        _disableCheckedStroke;
        _checkIconImage;
        _indeterminateIconImage;
        static get DEFAULT() {
            return defaultStyle$8 ? defaultStyle$8 : (defaultStyle$8 = new CheckboxStyle());
        }
        constructor(style = {}, headerStyle = {}, checkboxThemeStyle = {}) {
            super(style, headerStyle);
            this._size = (style?.size ?? headerStyle?.size ?? checkboxThemeStyle?.size) || 14;
            this._spaceBetweenTextAndIcon =
                (style?.spaceBetweenTextAndIcon ??
                    headerStyle?.spaceBetweenTextAndIcon ??
                    checkboxThemeStyle?.spaceBetweenTextAndIcon) ||
                    8;
            this._defaultFill = style?.checkboxStyle?.defaultFill ?? checkboxThemeStyle?.defaultFill;
            this._defaultStroke = style?.checkboxStyle?.defaultStroke ?? checkboxThemeStyle?.defaultStroke;
            this._disableFill = style?.checkboxStyle?.disableFill ?? checkboxThemeStyle?.disableFill;
            this._checkedFill = style?.checkboxStyle?.checkedFill ?? checkboxThemeStyle?.checkedFill;
            this._checkedStroke = style?.checkboxStyle?.checkedStroke ?? checkboxThemeStyle?.checkedStroke;
            this._disableCheckedFill = style?.checkboxStyle?.disableCheckedFill ?? checkboxThemeStyle?.disableCheckedFill;
            this._disableCheckedStroke = style?.checkboxStyle?.disableCheckedStroke ?? checkboxThemeStyle?.disableCheckedStroke;
            this._checkIconImage = style?.checkboxStyle?.checkIconImage ?? checkboxThemeStyle?.checkIconImage;
            this._indeterminateIconImage =
                style?.checkboxStyle?.indeterminateIconImage ?? checkboxThemeStyle?.indeterminateIconImage;
        }
        get size() {
            return this._size;
        }
        set size(size) {
            this._size = size;
        }
        get spaceBetweenTextAndIcon() {
            return this._spaceBetweenTextAndIcon;
        }
        set spaceBetweenTextAndIcon(spaceBetweenTextAndIcon) {
            this._spaceBetweenTextAndIcon = spaceBetweenTextAndIcon;
        }
        get defaultFill() {
            return this._defaultFill;
        }
        set defaultFill(defaultFill) {
            this._defaultFill = defaultFill;
        }
        get defaultStroke() {
            return this._defaultStroke;
        }
        set defaultStroke(defaultStroke) {
            this._defaultStroke = defaultStroke;
        }
        get disableFill() {
            return this._disableFill;
        }
        set disableFill(disableFill) {
            this._disableFill = disableFill;
        }
        get checkedFill() {
            return this._checkedFill;
        }
        set checkedFill(checkedFill) {
            this._checkedFill = checkedFill;
        }
        get checkedStroke() {
            return this._checkedStroke;
        }
        set checkedStroke(checkedStroke) {
            this._checkedStroke = checkedStroke;
        }
        get disableCheckedFill() {
            return this._disableCheckedFill;
        }
        set disableCheckedFill(disableCheckedFill) {
            this._disableCheckedFill = disableCheckedFill;
        }
        get disableCheckedStroke() {
            return this._disableCheckedStroke;
        }
        set disableCheckedStroke(disableCheckedStroke) {
            this._disableCheckedStroke = disableCheckedStroke;
        }
        get checkIconImage() {
            return this._checkIconImage;
        }
        set checkIconImage(checkIconImage) {
            this._checkIconImage = checkIconImage;
        }
        get indeterminateIconImage() {
            return this._indeterminateIconImage;
        }
        set indeterminateIconImage(indeterminateIconImage) {
            this._indeterminateIconImage = indeterminateIconImage;
        }
        getStyle(style) {
            return new CheckboxStyle(style, this);
        }
        clone() {
            return new CheckboxStyle(this);
        }
    };

    let defaultStyle$7;
    class RadioStyle extends Style$1 {
        _size;
        _spaceBetweenTextAndIcon;
        _spaceBetweenRadio;
        _outerRadius;
        _innerRadius;
        _defaultFill;
        _defaultStroke;
        _disableFill;
        _checkedFill;
        _checkedStroke;
        _disableCheckedFill;
        _disableCheckedStroke;
        static get DEFAULT() {
            return defaultStyle$7 ? defaultStyle$7 : (defaultStyle$7 = new RadioStyle());
        }
        constructor(style = {}, headerStyle = {}, radioThemeStyle = {}) {
            super(style, headerStyle);
            this._size = (style?.size ?? headerStyle?.size ?? radioThemeStyle?.size) || 14;
            this._spaceBetweenTextAndIcon =
                (style?.spaceBetweenTextAndIcon ??
                    headerStyle?.spaceBetweenTextAndIcon ??
                    radioThemeStyle?.spaceBetweenTextAndIcon) ||
                    8;
            this._spaceBetweenRadio =
                (style?.spaceBetweenRadio ?? headerStyle?.spaceBetweenRadio ?? radioThemeStyle?.spaceBetweenRadio) || 2;
            this._innerRadius = style?.radioStyle?.innerRadius ?? radioThemeStyle?.innerRadius;
            this._outerRadius = style?.radioStyle?.outerRadius ?? radioThemeStyle?.outerRadius;
            this._defaultFill = style?.radioStyle?.defaultFill ?? radioThemeStyle?.defaultFill;
            this._defaultStroke = style?.radioStyle?.defaultStroke ?? radioThemeStyle?.defaultStroke;
            this._disableFill = style?.radioStyle?.disableFill ?? radioThemeStyle?.disableFill;
            this._checkedFill = style?.radioStyle?.checkedFill ?? radioThemeStyle?.checkedFill;
            this._checkedStroke = style?.radioStyle?.checkedStroke ?? radioThemeStyle?.checkedStroke;
            this._disableCheckedFill = style?.radioStyle?.disableCheckedFill ?? radioThemeStyle?.disableCheckedFill;
            this._disableCheckedStroke = style?.radioStyle?.disableCheckedStroke ?? radioThemeStyle?.disableCheckedStroke;
        }
        get size() {
            return this._size;
        }
        set size(size) {
            this._size = size;
        }
        get spaceBetweenTextAndIcon() {
            return this._spaceBetweenTextAndIcon;
        }
        set spaceBetweenTextAndIcon(spaceBetweenTextAndIcon) {
            this._spaceBetweenTextAndIcon = spaceBetweenTextAndIcon;
        }
        get spaceBetweenRadio() {
            return this._spaceBetweenRadio;
        }
        set spaceBetweenRadio(spaceBetweenRadio) {
            this._spaceBetweenRadio = spaceBetweenRadio;
        }
        get innerRadius() {
            return this._innerRadius;
        }
        set innerRadius(innerRadius) {
            this._innerRadius = innerRadius;
        }
        get outerRadius() {
            return this._outerRadius;
        }
        set outerRadius(outerRadius) {
            this._outerRadius = outerRadius;
        }
        get defaultFill() {
            return this._defaultFill;
        }
        set defaultFill(defaultFill) {
            this._defaultFill = defaultFill;
        }
        get defaultStroke() {
            return this._defaultStroke;
        }
        set defaultStroke(defaultStroke) {
            this._defaultStroke = defaultStroke;
        }
        get disableFill() {
            return this._disableFill;
        }
        set disableFill(disableFill) {
            this._disableFill = disableFill;
        }
        get checkedFill() {
            return this._checkedFill;
        }
        set checkedFill(checkedFill) {
            this._checkedFill = checkedFill;
        }
        get checkedStroke() {
            return this._checkedStroke;
        }
        set checkedStroke(checkedStroke) {
            this._checkedStroke = checkedStroke;
        }
        get disableCheckedFill() {
            return this._disableCheckedFill;
        }
        set disableCheckedFill(disableCheckedFill) {
            this._disableCheckedFill = disableCheckedFill;
        }
        get disableCheckedStroke() {
            return this._disableCheckedStroke;
        }
        set disableCheckedStroke(disableCheckedStroke) {
            this._disableCheckedStroke = disableCheckedStroke;
        }
        getStyle(style) {
            return new RadioStyle(style, this);
        }
        clone() {
            return new RadioStyle(this);
        }
    }

    let defaultStyle$6;
    class SwitchStyle extends Style$1 {
        _spaceBetweenTextAndCircle;
        _circleRadius;
        _boxWidth;
        _boxHeight;
        _checkedFill;
        _uncheckedFill;
        _disableCheckedFill;
        _disableUncheckedFill;
        _circleFill;
        static get DEFAULT() {
            return defaultStyle$6 ? defaultStyle$6 : (defaultStyle$6 = new SwitchStyle());
        }
        constructor(style = {}, headerStyle = {}, switchThemeStyle = {}) {
            super(style, headerStyle);
            this._spaceBetweenTextAndCircle =
                (style?.spaceBetweenTextAndCircle ??
                    headerStyle?.spaceBetweenTextAndCircle ??
                    switchThemeStyle?.spaceBetweenTextAndCircle) ||
                    6;
            this._circleRadius = (style?.switchStyle?.circleRadius ?? switchThemeStyle?.circleRadius) || 8;
            this._boxWidth = (style?.switchStyle?.boxWidth ?? switchThemeStyle?.boxWidth) || 40;
            this._boxHeight = (style?.switchStyle?.boxHeight ?? switchThemeStyle?.boxHeight) || 24;
            this._checkedFill = (style?.switchStyle?.checkedFill ?? switchThemeStyle?.checkedFill) || '#165DFF';
            this._uncheckedFill = (style?.switchStyle?.uncheckedFill ?? switchThemeStyle?.uncheckedFill) || '#c9cdd4';
            this._disableCheckedFill =
                (style?.switchStyle?.disableCheckedFill ?? switchThemeStyle?.disableCheckedFill) || '#94bfff';
            this._disableUncheckedFill =
                (style?.switchStyle?.disableUncheckedFill ?? switchThemeStyle?.disableUncheckedFill) || '#f2f3f5';
            this._circleFill = (style?.switchStyle?.circleFill ?? switchThemeStyle?.circleFill) || '#FFF';
        }
        get spaceBetweenTextAndCircle() {
            return this._spaceBetweenTextAndCircle;
        }
        set spaceBetweenTextAndCircle(spaceBetweenTextAndCircle) {
            this._spaceBetweenTextAndCircle = spaceBetweenTextAndCircle;
        }
        get circleRadius() {
            return this._circleRadius;
        }
        set circleRadius(circleRadius) {
            this._circleRadius = circleRadius;
        }
        get boxWidth() {
            return this._boxWidth;
        }
        set boxWidth(boxWidth) {
            this._boxWidth = boxWidth;
        }
        get boxHeight() {
            return this._boxHeight;
        }
        set boxHeight(boxHeight) {
            this._boxHeight = boxHeight;
        }
        get checkedFill() {
            return this._checkedFill;
        }
        set checkedFill(checkedFill) {
            this._checkedFill = checkedFill;
        }
        get uncheckedFill() {
            return this._uncheckedFill;
        }
        set uncheckedFill(uncheckedFill) {
            this._uncheckedFill = uncheckedFill;
        }
        get disableCheckedFill() {
            return this._disableCheckedFill;
        }
        set disableCheckedFill(disableCheckedFill) {
            this._disableCheckedFill = disableCheckedFill;
        }
        get disableUncheckedFill() {
            return this._disableUncheckedFill;
        }
        set disableUncheckedFill(disableUncheckedFill) {
            this._disableUncheckedFill = disableUncheckedFill;
        }
        get circleFill() {
            return this._circleFill;
        }
        set circleFill(circleFill) {
            this._circleFill = circleFill;
        }
        getStyle(style) {
            return new SwitchStyle(style, this);
        }
        clone() {
            return new SwitchStyle(this);
        }
    }

    let defaultStyle$5;
    class ButtonStyle extends Style$1 {
        _buttonColor;
        _buttonBorderColor;
        _buttonLineWidth;
        _buttonBorderRadius;
        _buttonHoverColor;
        _buttonHoverBorderColor;
        _buttonTextHoverColor;
        _buttonDisableColor;
        _buttonDisableBorderColor;
        _buttonTextDisableColor;
        _buttonTextHoverBorderColor;
        _buttonPadding;
        static get DEFAULT() {
            return defaultStyle$5 ? defaultStyle$5 : (defaultStyle$5 = new ButtonStyle());
        }
        constructor(style = {}, headerStyle = {}, buttonThemeStyle = {}) {
            super(style, headerStyle);
            this._buttonColor = (style?.buttonStyle?.buttonColor ?? buttonThemeStyle?.buttonColor) || '#165DFF';
            this._buttonBorderColor =
                (style?.buttonStyle?.buttonBorderColor ?? buttonThemeStyle?.buttonBorderColor) || '#165DFF';
            this._buttonLineWidth = (style?.buttonStyle?.buttonLineWidth ?? buttonThemeStyle?.buttonLineWidth) || 1;
            this._buttonBorderRadius = (style?.buttonStyle?.buttonBorderRadius ?? buttonThemeStyle?.buttonBorderRadius) || 2;
            this._buttonHoverColor = (style?.buttonStyle?.buttonHoverColor ?? buttonThemeStyle?.buttonHoverColor) || '#4080FF';
            this._buttonHoverBorderColor =
                (style?.buttonStyle?.buttonHoverBorderColor ?? buttonThemeStyle?.buttonHoverBorderColor) || '#4080FF';
            this._buttonTextHoverColor = style?.buttonStyle?.buttonTextHoverColor ?? buttonThemeStyle?.buttonTextHoverColor;
            this._buttonDisableColor =
                (style?.buttonStyle?.buttonDisableColor ?? buttonThemeStyle?.buttonDisableColor) || '#94bfff';
            this._buttonDisableBorderColor =
                (style?.buttonStyle?.buttonDisableBorderColor ?? buttonThemeStyle?.buttonDisableBorderColor) || '#94bfff';
            this._buttonTextDisableColor =
                style?.buttonStyle?.buttonTextDisableColor ?? buttonThemeStyle?.buttonTextDisableColor;
            this._buttonPadding = (style?.buttonStyle?.buttonPadding ?? buttonThemeStyle?.buttonPadding) || 10;
        }
        get buttonColor() {
            return this._buttonColor;
        }
        set buttonColor(buttonColor) {
            this._buttonColor = buttonColor;
        }
        get buttonBorderColor() {
            return this._buttonBorderColor;
        }
        set buttonBorderColor(buttonBorderColor) {
            this._buttonBorderColor = buttonBorderColor;
        }
        get buttonLineWidth() {
            return this._buttonLineWidth;
        }
        set buttonLineWidth(buttonLineWidth) {
            this._buttonLineWidth = buttonLineWidth;
        }
        get buttonBorderRadius() {
            return this._buttonBorderRadius;
        }
        set buttonBorderRadius(buttonBorderRadius) {
            this._buttonBorderRadius = buttonBorderRadius;
        }
        get buttonHoverColor() {
            return this._buttonHoverColor;
        }
        set buttonHoverColor(buttonHoverColor) {
            this._buttonHoverColor = buttonHoverColor;
        }
        get buttonHoverBorderColor() {
            return this._buttonHoverBorderColor;
        }
        set buttonHoverBorderColor(buttonHoverBorderColor) {
            this._buttonHoverBorderColor = buttonHoverBorderColor;
        }
        get buttonTextHoverColor() {
            return this._buttonTextHoverColor;
        }
        set buttonTextHoverColor(buttonTextHoverColor) {
            this._buttonTextHoverColor = buttonTextHoverColor;
        }
        get buttonDisableColor() {
            return this._buttonDisableColor;
        }
        set buttonDisableColor(buttonDisableColor) {
            this._buttonDisableColor = buttonDisableColor;
        }
        get buttonDisableBorderColor() {
            return this._buttonDisableBorderColor;
        }
        set buttonDisableBorderColor(buttonDisableBorderColor) {
            this._buttonDisableBorderColor = buttonDisableBorderColor;
        }
        get buttonTextDisableColor() {
            return this._buttonTextDisableColor;
        }
        set buttonTextDisableColor(buttonTextDisableColor) {
            this._buttonTextDisableColor = buttonTextDisableColor;
        }
        get buttonTextHoverBorderColor() {
            return this._buttonTextHoverBorderColor;
        }
        set buttonTextHoverBorderColor(buttonTextHoverBorderColor) {
            this._buttonTextHoverBorderColor = buttonTextHoverBorderColor;
        }
        get buttonPadding() {
            return this._buttonPadding;
        }
        set buttonPadding(buttonPadding) {
            this._buttonPadding = buttonPadding;
        }
        getStyle(style) {
            return new ButtonStyle(style, this);
        }
        clone() {
            return new ButtonStyle(this);
        }
    }

    function of$2(columnStyle, bodyStyle, styleArg, StyleClassDef = Style$1, globalAutoWrapText, theme) {
        if (columnStyle || bodyStyle) {
            if (columnStyle instanceof Style$1) {
                return columnStyle;
            }
            else if (typeof columnStyle === 'function') {
                return of$2(columnStyle(styleArg), bodyStyle, styleArg, StyleClassDef, globalAutoWrapText, theme);
            }
            if (!columnStyle) {
                columnStyle = {};
            }
            if (globalAutoWrapText && !isValid$3(columnStyle.autoWrapText)) {
                columnStyle.autoWrapText = true;
            }
            if (StyleClassDef === CheckboxStyle$1) {
                return new CheckboxStyle$1(columnStyle ?? {}, (bodyStyle ?? {}), (theme.checkboxStyle ?? {}));
            }
            else if (StyleClassDef === RadioStyle) {
                return new RadioStyle(columnStyle ?? {}, (bodyStyle ?? {}), (theme.radioStyle ?? {}));
            }
            else if (StyleClassDef === SwitchStyle) {
                return new SwitchStyle(columnStyle ?? {}, (bodyStyle ?? {}), (theme.switchStyle ?? {}));
            }
            else if (StyleClassDef === ButtonStyle) {
                return new ButtonStyle(columnStyle ?? {}, (bodyStyle ?? {}), (theme.buttonStyle ?? {}));
            }
            return new StyleClassDef((columnStyle ?? {}), (bodyStyle ?? {}));
        }
        return StyleClassDef.DEFAULT;
    }

    class Env {
        static _mode;
        static get mode() {
            if (!Env._mode) {
                Env._mode = defaultMode();
            }
            return Env._mode;
        }
        static set mode(mode) {
            Env._mode = mode;
        }
        static dpr = 0;
        static CreateCanvas;
        static LoadImage;
        static RequestAnimationFrame;
        static CancelAnimationFrame;
        static RegisterCreateCanvas(func) {
            Env.CreateCanvas = func;
        }
        static RegisterLoadImage(func) {
            Env.LoadImage = func;
        }
        static GetCreateCanvasFunc() {
            if (Env.CreateCanvas) {
                return Env.CreateCanvas;
            }
            if (Env.mode === 'worker') {
                return (width = 200, height = 200) => new OffscreenCanvas(width, height);
            }
            return undefined;
        }
        static RegisterRequestAnimationFrame(func) {
            Env.RequestAnimationFrame = func();
        }
        static GetRequestAnimationFrame() {
            if (Env.RequestAnimationFrame) {
                return Env.RequestAnimationFrame;
            }
            return undefined;
        }
        static RegisterCancelAnimationFrame(func) {
            Env.CancelAnimationFrame = func();
        }
        static GetCancelAnimationFrame() {
            if (Env.CancelAnimationFrame) {
                return Env.CancelAnimationFrame;
            }
            return undefined;
        }
    }
    function defaultMode() {
        let mode = 'browser';
        try {
            if (window.type === 'node') {
                mode = 'node';
            }
            else if (typeof window !== 'undefined' && !window.performance) {
                mode = 'miniApp';
            }
            else if (typeof window === 'undefined') {
                mode = 'node';
            }
        }
        catch (err) {
            mode = 'node';
        }
        return mode;
    }

    function importStyle$2() {
        if (Env.mode === 'node') {
            return;
        }
        const styleElement = document.createElement('style');
        styleElement.id = 'vtable-style-styleSheet';
        styleElement.textContent = `
.vtable .input-container {
	position: absolute;
	top:0px;
}
.vtable .table-scrollable {
	position: absolute;
	overflow: scroll;
}
.vtable .table-scrollable::-webkit-scrollbar-button{
	background-color: transparent;
}
.vtable .table-scrollable::-webkit-scrollbar-track-piece{
	background-color: transparent;
}
.vtable .table-scrollable::-webkit-scrollbar-corner {
	background-color: transparent;
}
.vtable .table-scrollable::-webkit-scrollbar-thumb {
	border-radius      : 4px;
	background-color   : rgba(100, 100, 100, .5);
}

.vtable .table-scroll-end-point {
	opacity: 0;
	position: relative;
}
.vtable {
	/* 设置overflow: auto 应该是为了滚动条的某个问题 但设置了auto之后 dom的下拉菜单只能显示在vtable节点中 超出会截断;现在去掉auto 暂时滚动条的问题没有发现 */
	/* overflow: auto; */
	position: relative;
	width: 100%;
	height: 100%;
	text-align: left;
  -webkit-font-smoothing:auto;

  overflow: hidden; // for react-vtable dom custom element
}

.vtable-gantt {
	/* 设置overflow: auto 应该是为了滚动条的某个问题 但设置了auto之后 dom的下拉菜单只能显示在vtable节点中 超出会截断;现在去掉auto 暂时滚动条的问题没有发现 */
	/* overflow: auto; */
	position: absolute;
	width: 100%;
	height: 100%;
	text-align: left;
  -webkit-font-smoothing:auto;

  overflow: hidden; // for react-vtable dom custom element
}
.vtable .table-component-container {
  pointer-events: none;
  overflow: hidden;
  position: absolute;
  top: 0px;
  left: 0px;
}
.vtable > canvas {
	position: absolute;
	width: 0;
	height: 0;
}
.vtable .table-focus-control {
	position: relative !important;
	width: 1px;
	height: 1px;
	opacity: 0;
	padding: 0;
	margin: 0;
	box-sizing: border-box;
	pointer-events: none;
	max-width: 500px;
	max-height: 500px;
	float: none !important;
}
.vtable input.table-focus-control::-ms-clear {
	visibility: hidden;
}
.vtable input.table-focus-control.composition {
	opacity: 1;
	max-width: none;
	max-height: none;
}
`;
        document.head.appendChild(styleElement);
    }

    function getHorizontalScrollBarSize(scrollStyle) {
        if (scrollStyle?.hoverOn ||
            (scrollStyle?.horizontalVisible && scrollStyle?.horizontalVisible === 'none') ||
            (!scrollStyle?.horizontalVisible && scrollStyle?.visible === 'none')) {
            return 0;
        }
        return scrollStyle?.width ?? 7;
    }
    function getVerticalScrollBarSize(scrollStyle) {
        if (scrollStyle?.hoverOn ||
            (scrollStyle?.verticalVisible && scrollStyle?.verticalVisible === 'none') ||
            (!scrollStyle?.verticalVisible && scrollStyle?.visible === 'none')) {
            return 0;
        }
        return scrollStyle?.width ?? 7;
    }
    function isValidStyle(style) {
        if (!isValid$3(style)) {
            return false;
        }
        if (isArray$7(style)) {
            return style.some(s => isValid$3(s));
        }
        return true;
    }
    function isZeroStyle(style) {
        return style === 0 || (isArray$7(style) && style.every(s => s === 0));
    }

    const judgeType$1 = (value) => {
        switch (Object.prototype.toString.call(value)) {
            case '[object Object]':
                return 'object';
            case '[object Function]':
                return 'function';
            case '[object Array]':
                return 'array';
            case '[object String]':
                return 'string';
            case '[object Number]':
                return 'number';
            case '[object RegExp]':
                return 'regExp';
            case '[object Boolean]':
                return 'boolean';
            case '[object Symbol]':
                return 'symbol';
            case '[object Date]':
                return 'date';
            case '[object Undefined]':
                return 'undefined';
            case '[object Null]':
                return 'null';
            case '[object Error]':
                return 'error';
            case '[object HTMLDocument]':
                return 'document';
            case '[object global]':
                return 'global';
            default:
                return null;
        }
    };
    const isIt$1 = (v, type) => judgeType$1(v) === type;
    const isObject$5 = (v) => isIt$1(v, 'object');
    const isString$2 = (v) => isIt$1(v, 'string');
    const isNumber$2 = (v) => isIt$1(v, 'number');
    const isBoolean$2 = (v) => isIt$1(v, 'boolean');
    function ingoreNoneValueMerge(target, ...sources) {
        if (!sources.length) {
            return target || {};
        }
        const source = sources.shift();
        if (isObject$5(target) && isObject$5(source)) {
            for (const key in source) {
                if (isObject$5(source[key])) {
                    if (!target[key]) {
                        Object.assign(target, { [key]: {} });
                    }
                    if (!isObject$5(target[key])) {
                        Object.assign(target, { [key]: source[key] });
                    }
                    ingoreNoneValueMerge(target[key], source[key]);
                }
                else if (source[key] !== null && source[key] !== undefined) {
                    Object.assign(target, { [key]: source[key] });
                }
            }
        }
        return ingoreNoneValueMerge(target, ...sources);
    }
    function convertInternal(value) {
        if (typeof value === 'function') {
            value = value();
        }
        return isValid$3(value) ? `${value}` : '';
    }
    function transpose(matrix) {
        if (matrix?.length <= 0) {
            return matrix;
        }
        const m = matrix.length;
        const n = matrix[0].length;
        const transposed = new Array(n);
        for (let i = 0; i < m; i++) {
            for (let j = 0; j < n; j++) {
                if (!transposed[j]) {
                    transposed[j] = new Array(m);
                }
                transposed[j][i] = matrix[i][j];
            }
        }
        return transposed;
    }
    function throttle(func, delay) {
        let timer = null;
        return function (...args) {
            if (!timer) {
                func.apply(this, args);
                timer = setTimeout(() => {
                    timer = null;
                }, delay);
            }
        };
    }
    function throttle2(func, delay) {
        let timer = null;
        return function (...args) {
            if (!timer) {
                timer = setTimeout(() => {
                    func.apply(this, args);
                    timer = null;
                }, delay);
            }
        };
    }
    function pad(num, totalChars) {
        const pad = '0';
        num = `${num}`;
        while (num.length < totalChars) {
            num = pad + num;
        }
        return num;
    }
    function changeColor(color, ratio, isDarker) {
        color = color.replace(/^\s*|\s*$/, '');
        color = color.replace(/^#?([a-f0-9])([a-f0-9])([a-f0-9])$/i, '#$1$1$2$2$3$3');
        const difference = Math.round(ratio * 256) * (isDarker ? -1 : 1);
        const rgb = color.match(new RegExp('^rgba?\\(\\s*' +
            '(\\d|[1-9]\\d|1\\d{2}|2[0-4][0-9]|25[0-5])' +
            '\\s*,\\s*' +
            '(\\d|[1-9]\\d|1\\d{2}|2[0-4][0-9]|25[0-5])' +
            '\\s*,\\s*' +
            '(\\d|[1-9]\\d|1\\d{2}|2[0-4][0-9]|25[0-5])' +
            '(?:\\s*,\\s*' +
            '(0|1|0?\\.\\d+))?' +
            '\\s*\\)$', 'i'));
        const alpha = !!rgb && isValid$3(rgb[4]) ? rgb[4] : null;
        const decimal = rgb
            ? [rgb[1], rgb[2], rgb[3]]
            : color
                .replace(/^#?([a-f0-9][a-f0-9])([a-f0-9][a-f0-9])([a-f0-9][a-f0-9])/i, function () {
                return `${parseInt(arguments[1], 16)},${parseInt(arguments[2], 16)},${parseInt(arguments[3], 16)}`;
            })
                .split(/,/);
        return rgb
            ? `rgb${alpha !== null ? 'a' : ''}(${Math[isDarker ? 'max' : 'min'](parseInt(decimal[0], 10) + difference, isDarker ? 0 : 255)}, ${Math[isDarker ? 'max' : 'min'](parseInt(decimal[1], 10) + difference, isDarker ? 0 : 255)}, ${Math[isDarker ? 'max' : 'min'](parseInt(decimal[2], 10) + difference, isDarker ? 0 : 255)}${alpha !== null ? `, ${alpha}` : ''})`
            :
                [
                    '#',
                    pad(Math[isDarker ? 'max' : 'min'](parseInt(decimal[0], 10) + difference, isDarker ? 0 : 255).toString(16), 2),
                    pad(Math[isDarker ? 'max' : 'min'](parseInt(decimal[1], 10) + difference, isDarker ? 0 : 255).toString(16), 2),
                    pad(Math[isDarker ? 'max' : 'min'](parseInt(decimal[2], 10) + difference, isDarker ? 0 : 255).toString(16), 2)
                ].join('');
    }
    function validToString(v) {
        if (isString$2(v) || isNumber$2(v) || isBoolean$2(v)) {
            return v.toString();
        }
        return '';
    }
    function isMobile() {
        return navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
    }
    function defaultOrderFn(v1, v2, order) {
        if (order !== 'desc') {
            return v1 === v2 ? 0 : v1 > v2 ? 1 : -1;
        }
        return v1 === v2 ? 0 : v1 < v2 ? 1 : -1;
    }
    function getValueByPath(obj, paths) {
        let res = obj;
        let prop;
        while ((prop = paths.shift())) {
            res = res[prop];
            if (!res) {
                break;
            }
        }
        return res;
    }
    function isAllDigits(str) {
        const pattern = /^-?\d+(\.\d+)?$/;
        return pattern.test(str);
    }
    function deduplication$1(array) {
        const result = [];
        for (let i = 0; i < array.length; i++) {
            if (result.indexOf(array[i]) === -1) {
                result.push(array[i]);
            }
        }
        return result;
    }
    function isDivSelected(div) {
        const selection = window.getSelection();
        if (selection.rangeCount) {
            const range = selection.getRangeAt(0);
            return range.endOffset > range.startOffset && div.contains(range.commonAncestorContainer);
        }
        return false;
    }
    function traverseObject(obj, childrenProperty, callback) {
        callback(obj);
        if (obj?.[childrenProperty] && Array.isArray(obj?.[childrenProperty])) {
            obj[childrenProperty].forEach((child) => traverseObject(child, childrenProperty, callback));
        }
    }

    const isNode = typeof window === 'undefined' || typeof window.window === 'undefined';
    let arrayFind;
    let arrayFindIndex;
    const array = {
        get find() {
            if (arrayFind) {
                return arrayFind;
            }
            if (Array.prototype.find) {
                arrayFind = (arr, predicate) => Array.prototype.find.call(arr, predicate);
            }
            else {
                arrayFind = (arr, predicate) => {
                    const index = array.findIndex(arr, predicate);
                    return index >= 0 ? arr[index] : undefined;
                };
            }
            return arrayFind;
        },
        get findIndex() {
            if (arrayFindIndex) {
                return arrayFindIndex;
            }
            if (Array.prototype.findIndex) {
                arrayFindIndex = (arr, predicate) => Array.prototype.findIndex.call(arr, predicate);
            }
            else {
                arrayFindIndex = (arr, predicate) => {
                    const { length } = arr;
                    for (let i = 0; i < length; i++) {
                        const value = arr[i];
                        if (predicate(value, i, arr)) {
                            return i;
                        }
                    }
                    return -1;
                };
            }
            return arrayFindIndex;
        }
    };
    function analyzeUserAgent() {
        if (isNode) {
            return {
                IE: false,
                Edge: false,
                Chrome: false,
                Firefox: false,
                Safari: false
            };
        }
        const ua = window.navigator.userAgent.toLowerCase();
        return {
            IE: !!/(msie|trident)/.exec(ua),
            Edge: ua.indexOf('edge') > -1,
            Chrome: ua.indexOf('chrome') > -1 && ua.indexOf('edge') === -1,
            Firefox: ua.indexOf('firefox') > -1,
            Safari: ua.indexOf('safari') > -1 && ua.indexOf('edge') === -1
        };
    }
    const { IE, Chrome, Firefox, Edge, Safari } = analyzeUserAgent();
    function isObject$4(obj) {
        return obj === Object(obj);
    }
    function extend(...args) {
        const result = {};
        args.forEach(source => {
            for (const key in source) {
                Object.defineProperty(result, key, {
                    get() {
                        return source[key];
                    },
                    set(val) {
                        source[key] = val;
                    },
                    configurable: true,
                    enumerable: true
                });
            }
        });
        return result;
    }
    function applyChainSafe(obj, fn, ...names) {
        let value = obj;
        for (let i = 0; i < names.length && value !== null && value !== undefined; i++) {
            value = fn(value, names[i]);
        }
        return value;
    }
    function getChainSafe(obj, ...names) {
        return applyChainSafe(obj, (val, name) => val[name], ...names);
    }
    function getOrApply(value, ...args) {
        if (typeof value === 'function') {
            return value(...args);
        }
        return value;
    }
    function endsWith(str, searchString, position) {
        const subjectString = validToString(str);
        if (typeof position !== 'number' ||
            !isFinite(position) ||
            Math.floor(position) !== position ||
            position > subjectString.length) {
            position = subjectString.length;
        }
        position -= searchString.length;
        const lastIndex = subjectString.lastIndexOf(searchString, position);
        return lastIndex !== -1 && lastIndex === position;
    }
    function isPromise(data) {
        return Boolean(data && typeof data.then === 'function');
    }
    function getPromiseValue(value, callback) {
        if (isPromise(value)) {
            value
                .then(result => {
                callback(result);
            })
                .catch((err) => {
            });
        }
        else {
            callback(value);
        }
    }
    function isTouchEvent$2(e) {
        return !!e.changedTouches;
    }
    function getIgnoreCase(obj, name) {
        if (obj[name]) {
            return obj[name];
        }
        const l = name.toLowerCase();
        if (obj[l]) {
            return obj[l];
        }
        const u = name.toLowerCase();
        if (obj[u]) {
            return obj[u];
        }
        for (const k in obj) {
            if (k.toLowerCase() === l) {
                return obj[k];
            }
        }
        return undefined;
    }
    function toBoxArray$1(obj) {
        if (!Array.isArray(obj)) {
            return [obj, obj, obj, obj];
        }
        if (obj.length === 3) {
            return [obj[0], obj[1], obj[2], obj[1]];
        }
        if (obj.length === 2) {
            return [obj[0], obj[1], obj[0], obj[1]];
        }
        if (obj.length === 1) {
            return [obj[0], obj[0], obj[0], obj[0]];
        }
        return [obj[0], obj[1], obj[2], obj[3]];
    }
    function cellInRange(range, col, row) {
        return ((range.start.col <= col && col <= range.end.col && range.start.row <= row && row <= range.end.row) ||
            (range.end.col <= col && col <= range.start.col && range.end.row <= row && row <= range.start.row) ||
            (range.end.col <= col && col <= range.start.col && range.start.row <= row && row <= range.end.row) ||
            (range.start.col <= col && col <= range.end.col && range.end.row <= row && row <= range.start.row));
    }
    function cellInRanges(ranges, col, row) {
        for (let i = 0; i < ranges.length; i++) {
            const range = ranges[i];
            const startCol = Math.min(range.start.col, range.end.col);
            const endCol = Math.max(range.start.col, range.end.col);
            const startRow = Math.min(range.start.row, range.end.row);
            const endRow = Math.max(range.start.row, range.end.row);
            if ((startCol <= col && col <= endCol && startRow <= row && row <= endRow) ||
                (endCol <= col && col <= startCol && endRow <= row && row <= startRow)) {
                return true;
            }
        }
        return false;
    }
    function adjust(range) {
        const start = {
            col: Math.min(range.start.col, range.end.col),
            row: Math.min(range.start.row, range.end.row)
        };
        const end = {
            col: Math.max(range.start.col, range.end.col),
            row: Math.max(range.start.row, range.end.row)
        };
        return { start, end };
    }
    function rangeIntersected(range, range1) {
        const rangeAdjust = adjust(range);
        const range1Adjust = adjust(range1);
        const col0 = Math.max(rangeAdjust.start.col, range1Adjust.start.col);
        const col1 = Math.min(rangeAdjust.end.col, range1Adjust.end.col);
        if (col0 <= col1) {
            const row0 = Math.max(rangeAdjust.start.row, range1Adjust.start.row);
            const row1 = Math.min(rangeAdjust.end.row, range1Adjust.end.row);
            if (row0 <= row1) {
                return true;
            }
        }
        return false;
    }
    const browser = {
        IE,
        Edge,
        Chrome,
        Firefox,
        Safari,
        heightLimit: Chrome ? 33554431 : Firefox ? 17895588 : 10737433
    };
    const obj = {
        isObject: isObject$4
    };
    const str = {
        endsWith
    };
    const event = {
        isTouchEvent: isTouchEvent$2
    };
    const style = {
        toBoxArray: toBoxArray$1
    };
    const emptyFn = Function.prototype;

    const TABLE_EVENT_TYPE = {
        CLICK_CELL: 'click_cell',
        DBLCLICK_CELL: 'dblclick_cell',
        MOUSEDOWN_CELL: 'mousedown_cell',
        MOUSEUP_CELL: 'mouseup_cell',
        SELECTED_CELL: 'selected_cell',
        SELECTED_CLEAR: 'selected_clear',
        BEFORE_KEYDOWN: 'before_keydown',
        KEYDOWN: 'keydown',
        MOUSEENTER_TABLE: 'mouseenter_table',
        MOUSELEAVE_TABLE: 'mouseleave_table',
        MOUSEDOWN_TABLE: 'mousedown_table',
        MOUSEMOVE_TABLE: 'mousemove_table',
        MOUSEMOVE_CELL: 'mousemove_cell',
        MOUSEENTER_CELL: 'mouseenter_cell',
        MOUSELEAVE_CELL: 'mouseleave_cell',
        CONTEXTMENU_CELL: 'contextmenu_cell',
        RESIZE_COLUMN: 'resize_column',
        RESIZE_COLUMN_END: 'resize_column_end',
        RESIZE_ROW: 'resize_row',
        RESIZE_ROW_END: 'resize_row_end',
        CHANGE_HEADER_POSITION_START: 'change_header_position_start',
        CHANGE_HEADER_POSITION: 'change_header_position',
        CHANGING_HEADER_POSITION: 'changing_header_position',
        CHANGE_HEADER_POSITION_FAIL: 'change_header_position_fail',
        SORT_CLICK: 'sort_click',
        AFTER_SORT: 'after_sort',
        FREEZE_CLICK: 'freeze_click',
        SCROLL: 'scroll',
        CAN_SCROLL: 'can_scroll',
        SCROLL_HORIZONTAL_END: 'scroll_horizontal_end',
        SCROLL_VERTICAL_END: 'scroll_vertical_end',
        DROPDOWN_MENU_CLICK: 'dropdown_menu_click',
        MOUSEOVER_CHART_SYMBOL: 'mouseover_chart_symbol',
        DRAG_SELECT_END: 'drag_select_end',
        COPY_DATA: 'copy_data',
        DROPDOWN_ICON_CLICK: 'dropdown_icon_click',
        DROPDOWN_MENU_CLEAR: 'dropdown_menu_clear',
        TREE_HIERARCHY_STATE_CHANGE: 'tree_hierarchy_state_change',
        SHOW_MENU: 'show_menu',
        HIDE_MENU: 'hide_menu',
        ICON_CLICK: 'icon_click',
        LEGEND_ITEM_CLICK: 'legend_item_click',
        LEGEND_ITEM_HOVER: 'legend_item_hover',
        LEGEND_ITEM_UNHOVER: 'legend_item_unHover',
        LEGEND_CHANGE: 'legend_change',
        MOUSEENTER_AXIS: 'mouseenter_axis',
        MOUSELEAVE_AXIS: 'mouseleave_axis',
        CHECKBOX_STATE_CHANGE: 'checkbox_state_change',
        RADIO_STATE_CHANGE: 'radio_state_change',
        SWITCH_STATE_CHANGE: 'switch_state_change',
        BEFORE_SET_SIZE: 'before_set_size',
        BEFORE_INIT: 'before_init',
        AFTER_RENDER: 'after_render',
        INITIALIZED: 'initialized',
        CHANGE_CELL_VALUE: 'change_cell_value',
        DRAG_FILL_HANDLE_END: 'drag_fill_handle_end',
        MOUSEDOWN_FILL_HANDLE: 'mousedown_fill_handle',
        DBLCLICK_FILL_HANDLE: 'dblclick_fill_handle',
        EMPTY_TIP_CLICK: 'empty_tip_click',
        EMPTY_TIP_DBLCLICK: 'empty_tip_dblclick',
        BUTTON_CLICK: 'button_click',
        BEFORE_CACHE_CHART_IMAGE: 'before_cache_chart_image'
    };

    const judgeType = (value) => {
        switch (Object.prototype.toString.call(value)) {
            case '[object Object]':
                return 'object';
            case '[object Function]':
                return 'function';
            case '[object Array]':
                return 'array';
            case '[object String]':
                return 'string';
            case '[object Number]':
                return 'number';
            case '[object RegExp]':
                return 'regExp';
            case '[object Boolean]':
                return 'boolean';
            case '[object Symbol]':
                return 'symbol';
            case '[object Date]':
                return 'date';
            case '[object Undefined]':
                return 'undefined';
            case '[object Null]':
                return 'null';
            case '[object Error]':
                return 'error';
            case '[object HTMLDocument]':
                return 'document';
            case '[object global]':
                return 'global';
            default:
                return null;
        }
    };
    const isIt = (v, type) => judgeType(v) === type;
    const isObject$3 = (v) => isIt(v, 'object');

    function debounce(func, wait, options) {
        let lastArgs;
        let lastThis;
        let maxWait;
        let result;
        let timerId;
        let lastCallTime;
        let lastInvokeTime = 0;
        let maxing = false;
        let leading = false;
        let trailing = true;
        const useRAF = !wait && wait !== 0 && typeof requestAnimationFrame === 'function';
        if (typeof func !== 'function') {
            throw new TypeError('Expected a function');
        }
        wait = +wait || 0;
        if (isObject$3(options)) {
            leading = !!options.leading;
            maxing = 'maxWait' in options;
            if (maxing) {
                maxWait = Math.max(+options.maxWait || 0, wait);
            }
            trailing = 'trailing' in options ? !!options.trailing : trailing;
        }
        function invokeFunc(time) {
            const args = lastArgs;
            const thisArg = lastThis;
            lastThis = undefined;
            lastArgs = undefined;
            lastInvokeTime = time;
            result = func.apply(thisArg, args);
            return result;
        }
        function startTimer(pendingFunc, wait) {
            if (useRAF) {
                return requestAnimationFrame(pendingFunc);
            }
            return setTimeout(pendingFunc, wait);
        }
        function leadingEdge(time) {
            lastInvokeTime = time;
            timerId = startTimer(timerExpired, wait);
            return leading ? invokeFunc(time) : result;
        }
        function trailingEdge(time) {
            timerId = undefined;
            if (trailing && lastArgs) {
                return invokeFunc(time);
            }
            lastThis = undefined;
            lastArgs = undefined;
            return result;
        }
        function remainingWait(time) {
            const timeSinceLastCall = time - lastCallTime;
            const timeSinceLastInvoke = time - lastInvokeTime;
            const timeWaiting = wait && -timeSinceLastCall;
            return maxing ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        }
        function shouldInvoke(time) {
            const timeSinceLastCall = time - lastCallTime;
            const timeSinceLastInvoke = time - lastInvokeTime;
            return (lastCallTime === undefined ||
                timeSinceLastCall >= wait ||
                timeSinceLastCall < 0 ||
                (maxing && timeSinceLastInvoke >= maxWait));
        }
        function timerExpired() {
            const time = Date.now();
            if (shouldInvoke(time)) {
                return trailingEdge(time);
            }
            timerId = startTimer(timerExpired, remainingWait(time));
        }
        function debounced(...args) {
            const time = Date.now();
            const isInvoking = shouldInvoke(time);
            lastArgs = args;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
                if (timerId === undefined) {
                    return leadingEdge(lastCallTime);
                }
                if (maxing) {
                    timerId = startTimer(timerExpired, wait);
                    return invokeFunc(lastCallTime);
                }
            }
            if (timerId === undefined) {
                timerId = startTimer(timerExpired, wait);
            }
            return result;
        }
        return debounced;
    }

    let idCount = 1;
    class ResizeObserver {
        resizeTime = 100;
        element;
        cb;
        observer;
        lastSize = {
            width: 0,
            height: 0
        };
        callBackDebounce;
        constructor(element, cb, resizeTime) {
            this.element = element;
            this.cb = cb;
            this.lastSize = this.getSize();
            if (resizeTime) {
                this.resizeTime = Math.max(resizeTime, 16);
            }
            this.callBackDebounce = debounce(this.callBack, this.resizeTime);
            window?.addEventListener('resize', this.onResize);
            if ('ResizeObserver' in window) {
                const ResizeObserverWindow = window.ResizeObserver;
                this.observer = new ResizeObserverWindow(this.mutationResize);
                this.observer?.observe(this.element);
            }
            else if ('MutationObserver' in window) {
                this.observer = new MutationObserver(this.mutationResize);
                this.observer.observe(this.element, {
                    attributes: true,
                    attributeFilter: ['style']
                });
            }
        }
        mutationResize = () => {
            this.onResize();
        };
        disConnect() {
            window.removeEventListener('resize', this.onResize);
            if (this.observer) {
                this.observer.disconnect();
                this.observer = undefined;
            }
        }
        callBack = () => {
            const newSize = this.getSize();
            let windowSizeNotChange = false;
            if (newSize.width === this.lastSize.width && newSize.height === this.lastSize.height) {
                windowSizeNotChange = true;
            }
            this.lastSize = newSize;
            this.cb && this.cb({ ...this.lastSize, windowSizeNotChange });
        };
        setSize(size) {
            this.lastSize = size;
        }
        onResize = () => {
            this.callBackDebounce();
        };
        checkSize() {
            const newSize = this.getSize();
            if (newSize.width === this.lastSize.width && newSize.height === this.lastSize.height) {
                return false;
            }
            return true;
        }
        getSize() {
            if (!this.element) {
                return {
                    ...this.lastSize
                };
            }
            return {
                width: Math.floor(this.element.clientWidth),
                height: Math.floor(this.element.clientHeight)
            };
        }
    }
    class EventHandler {
        resizeTime;
        listeners = {};
        reseizeListeners = {};
        on(target, type, listener, ...options) {
            if (Env.mode === 'node') {
                return -1;
            }
            const id = idCount++;
            if (target?.addEventListener) {
                if (type !== 'resize' || target === window) {
                    target?.addEventListener(type, listener, ...options);
                }
                else {
                    const resizeObserver = new ResizeObserver(target, listener, this.resizeTime);
                    this.reseizeListeners[id] = resizeObserver;
                }
            }
            const obj = { target, type, listener, options };
            this.listeners[id] = obj;
            return id;
        }
        once(target, type, listener, ...options) {
            if (Env.mode === 'node') {
                return -1;
            }
            const id = this.on(target, type, (...args) => {
                this.off(id);
                listener(...args);
            }, ...options);
            return id;
        }
        off(id) {
            if (Env.mode === 'node') {
                return;
            }
            if (id === null) {
                return;
            }
            const obj = this.listeners?.[id];
            if (!obj) {
                return;
            }
            delete this.listeners[id];
            if (obj.target.removeEventListener) {
                obj.target.removeEventListener(obj.type, obj.listener, ...obj.options);
            }
        }
        fire(target, type, ...args) {
            if (Env.mode === 'node') {
                return;
            }
            for (const key in this.listeners) {
                const listener = this.listeners[key];
                if (listener.target === target && listener.type === type) {
                    listener.listener.call(listener.target, ...args);
                }
            }
        }
        hasListener(target, type) {
            if (Env.mode === 'node') {
                return false;
            }
            let result = false;
            for (const key in this.listeners) {
                const listener = this.listeners[key];
                if (listener.target === target && listener.type === type) {
                    result = true;
                }
            }
            return result;
        }
        clear() {
            if (Env.mode === 'node') {
                return;
            }
            for (const key in this.listeners) {
                const listener = this.listeners[key];
                if (listener.target.removeEventListener) {
                    listener.target.removeEventListener(listener.type, listener.listener, ...listener.options);
                }
            }
            for (const key in this.reseizeListeners) {
                const resizeObserver = this.reseizeListeners[key];
                resizeObserver?.disConnect();
            }
            this.listeners = {};
        }
        release() {
            if (Env.mode === 'node') {
                return;
            }
            this.clear();
            this.listeners = {};
        }
    }

    const indexFirst$1 = (arr, elm) => {
        let low = 0;
        let high = arr.length - 1;
        while (low <= high) {
            const i = Math.floor((low + high) / 2);
            if (arr[i] === elm) {
                return i;
            }
            else if (arr[i] > elm) {
                high = i - 1;
            }
            else {
                low = i + 1;
            }
        }
        return high < 0 ? 0 : high;
    };
    class NumberMap {
        _keys = [];
        _vals = {};
        _sorted = false;
        count() {
            return this._keys.length;
        }
        values() {
            return this._vals;
        }
        valueArr() {
            return Object.values(this._vals);
        }
        adjustOrder(sourceIndex, targetIndex, moveCount) {
            const { _keys: keys } = this;
            if (!this._sorted) {
                keys.sort((a, b) => {
                    if (a < b) {
                        return -1;
                    }
                    if (a > b) {
                        return 1;
                    }
                    return 0;
                });
                this._sorted = true;
            }
            if (sourceIndex > targetIndex) {
                const sourceVals = [];
                for (let i = indexFirst$1(keys, sourceIndex + moveCount - 1); i >= 0; i--) {
                    const key = keys[i];
                    if (key >= sourceIndex) {
                        sourceVals.push(this.get(key));
                    }
                    else if (targetIndex <= key && key < sourceIndex) {
                        this.put(key + moveCount, this.get(key));
                    }
                    else if (key < targetIndex) {
                        break;
                    }
                }
                for (let i = 0; i < moveCount; i++) {
                    this.put(targetIndex + i, sourceVals[moveCount - 1 - i]);
                }
            }
            const { length } = keys;
            if (sourceIndex < targetIndex) {
                const sourceVals = [];
                for (let i = indexFirst$1(keys, sourceIndex); i < length; i++) {
                    const key = keys[i];
                    if (key >= sourceIndex && key < sourceIndex + moveCount) {
                        sourceVals.push(this.get(key));
                    }
                    else if (sourceIndex + moveCount <= key && key <= targetIndex) {
                        this.put(key - moveCount, this.get(key));
                    }
                    else if (key > targetIndex) {
                        break;
                    }
                }
                for (let i = 0; i < moveCount; i++) {
                    this.put(targetIndex + i, sourceVals[i]);
                }
            }
        }
        exchangeOrder(sourceIndex, sourceCount, targetIndex, targetCount, insertIndex) {
            const { _keys: keys } = this;
            if (!this._sorted) {
                keys.sort((a, b) => {
                    if (a < b) {
                        return -1;
                    }
                    if (a > b) {
                        return 1;
                    }
                    return 0;
                });
                this._sorted = true;
            }
            if (sourceIndex > targetIndex) {
                const targetVals = [];
                const sourceVals = [];
                for (let i = indexFirst$1(keys, targetIndex); i < indexFirst$1(keys, sourceIndex) + sourceCount; i++) {
                    const key = keys[i];
                    if (key >= sourceIndex && key < sourceIndex + sourceCount) {
                        sourceVals.push(this.get(key));
                    }
                    else {
                        targetVals.push(this.get(key));
                    }
                }
                for (let i = 0; i < sourceCount; i++) {
                    this.put(insertIndex + i, sourceVals[i]);
                }
                for (let i = 0; i < targetVals.length; i++) {
                    this.put(insertIndex + sourceCount + i, targetVals[i]);
                }
            }
            else {
                const targetVals = [];
                const sourceVals = [];
                for (let i = indexFirst$1(keys, sourceIndex); i < indexFirst$1(keys, targetIndex) + targetCount; i++) {
                    const key = keys[i];
                    if (key >= sourceIndex && key < sourceIndex + sourceCount) {
                        sourceVals.push(this.get(key));
                    }
                    else {
                        targetVals.push(this.get(key));
                    }
                }
                for (let i = 0; i < sourceCount; i++) {
                    this.put(insertIndex + i, sourceVals[i]);
                }
                for (let i = 0; i < targetVals.length; i++) {
                    this.put(sourceIndex + i, targetVals[i]);
                }
            }
        }
        del(key) {
            delete this._vals[key];
            const index = this._keys.indexOf(key);
            if (index !== -1) {
                this._keys.splice(index, 1);
            }
        }
        put(key, value) {
            if (!(key in this._vals)) {
                this._keys.push(key);
                this._sorted = false;
            }
            this._vals[key] = value;
        }
        get(key) {
            return this._vals[key];
        }
        has(key) {
            return isValid$3(this._vals[key]);
        }
        contain(value) {
            return Object.values(this._vals).indexOf(value) >= 0;
        }
        each(keyFrom, keyTo, fn) {
            const { _keys: keys } = this;
            const { length } = keys;
            if (!this._sorted) {
                keys.sort((a, b) => {
                    if (a < b) {
                        return -1;
                    }
                    if (a > b) {
                        return 1;
                    }
                    return 0;
                });
                this._sorted = true;
            }
            for (let i = indexFirst$1(keys, keyFrom); i < length; i++) {
                const key = keys[i];
                if (keyFrom <= key && key <= keyTo) {
                    const callRes = fn(this.get(key), key);
                    if (callRes === false) {
                        break;
                    }
                }
                else if (keyTo < key) {
                    return;
                }
            }
        }
        clear() {
            this._keys.length = 0;
            this._vals = {};
            this._sorted = false;
        }
        getLastIndex() {
            return this._keys[this._keys.length - 1];
        }
        delLast() {
            const lastIndex = this.getLastIndex();
            this.del(lastIndex);
        }
        delAndReorder(index) {
            if (!this.has(index)) {
                return;
            }
            const lastIndex = this.getLastIndex();
            this.adjustOrder(index + 1, index, lastIndex - index);
            this.delLast();
        }
        addAndReorder(index, newValue) {
            if (isValid$3(newValue)) {
                const lastIndex = this.getLastIndex();
                this.adjustOrder(index, index + 1, lastIndex - index);
                this.put(index, newValue);
            }
        }
    }

    let Rect$1 = class Rect {
        bounds;
        constructor(left, top, width, height) {
            this.bounds = new Bounds();
            this.bounds.set(left, top, left + width, top + height);
        }
        static bounds(left, top, right, bottom) {
            return new Rect(left, top, Math.round(right - left), Math.round(bottom - top));
        }
        get left() {
            return this.bounds.x1;
        }
        set left(left) {
            this.bounds.x1 = left;
        }
        get top() {
            return this.bounds.y1;
        }
        set top(top) {
            this.bounds.y1 = top;
        }
        get right() {
            return this.bounds.x2;
        }
        set right(right) {
            this.bounds.x2 = right;
        }
        get bottom() {
            return this.bounds.y2;
        }
        set bottom(bottom) {
            this.bounds.y2 = bottom;
        }
        get width() {
            return this.bounds.width();
        }
        set width(width) {
            this.bounds.x2 = this.bounds.x1 + width;
        }
        get height() {
            return this.bounds.height();
        }
        set height(height) {
            this.bounds.y2 = this.bounds.y1 + height;
        }
        offsetLeft(offset) {
            this.bounds.translate(offset, 0);
        }
        offsetTop(offset) {
            this.bounds.translate(0, offset);
        }
        copy() {
            return new Rect(this.left, this.top, this.width, this.height);
        }
        contains(another) {
            return this.bounds.encloses(another.bounds);
        }
        inPoint(x, y) {
            return this.bounds.contains(x, y);
        }
    };

    function getBackgroundColor$3(args) {
        const { row, table } = args;
        const index = row - table.frozenRowCount;
        if (!(index & 1)) {
            return '#2d3137';
        }
        return '#282a2e';
    }
    var darkTheme = {
        name: 'DARK',
        underlayBackgroundColor: 'transparent',
        defaultStyle: {
            color: '#D3D5DA',
            bgColor: '#373b45',
            fontSize: 12,
            fontFamily: 'PingFang SC',
            fontWeight: 500,
            lineHeight: 12,
            borderColor: '#444A54',
            padding: [8, 12, 8, 12],
            hover: {
                cellBgColor: '#2F4774'
            }
        },
        headerStyle: {
            color: '#D3D5DA',
            bgColor: '#373b45',
            fontSize: 12,
            fontFamily: 'PingFang SC',
            fontWeight: 500,
            lineHeight: 12,
            borderColor: '#444A54',
            padding: [8, 12, 8, 12],
            hover: {
                cellBgColor: '#2F4774'
            }
        },
        rowHeaderStyle: {},
        cornerHeaderStyle: {},
        bodyStyle: {
            color: '#e5e7ea',
            bgColor: getBackgroundColor$3,
            fontSize: 12,
            fontFamily: 'PingFang SC',
            fontWeight: 500,
            lineHeight: 12,
            borderColor: '#444A54',
            padding: [8, 12, 8, 12],
            hover: {
                cellBgColor: '#29364D'
            }
        },
        frameStyle: {
            borderColor: '#d1d5da',
            borderLineWidth: 1,
            borderLineDash: [],
            cornerRadius: 10,
            shadowBlur: 6,
            shadowOffsetX: 0,
            shadowOffsetY: 0,
            shadowColor: 'rgba(00, 24, 47, 0.06)'
        },
        columnResize: {
            lineWidth: 1,
            lineColor: '#416EFF',
            bgColor: '#D9E2FF',
            width: 3
        },
        frozenColumnLine: {
            shadow: {
                width: 4,
                startColor: 'rgba(00, 24, 47, 0.05)',
                endColor: 'rgba(00, 24, 47, 0)',
                visible: 'always'
            }
        },
        selectionStyle: {
            cellBgColor: 'rgba(255, 255, 255, 0.1)',
            cellBorderColor: '#4284FF',
            cellBorderLineWidth: 2
        },
        tooltipStyle: {
            bgColor: '#FFF',
            color: '#000',
            fontSize: 12,
            fontFamily: 'Arial,sans-serif'
        },
        functionalIconsStyle: {
            sort_color: '#FFFFFF',
            sort_color_opacity: '0.75',
            sort_color_2: '#416EFF',
            sort_color_opacity_2: '1',
            frozen_color: '#FFFFFF',
            frozen_color_opacity: '0.75',
            collapse_color: '#FFF',
            collapse_color_opacity: '0.75',
            expand_color: '#FFF',
            expand_color_opacity: '0.75',
            dragReorder_color: '#FFF',
            dragReorder_color_opacity: '0.75'
        }
    };

    function getBackgroundColor$2(args) {
        const { row, table } = args;
        const index = row - table.frozenRowCount;
        if (!(index & 1)) {
            return '#F4F8FF';
        }
        return '#FFF';
    }
    var brightTheme = {
        name: 'BRIGHT',
        underlayBackgroundColor: '#FFF',
        defaultStyle: {
            color: '#FFF',
            bgColor: '#5389FF',
            borderColor: '#5286FA',
            hover: {
                cellBgColor: '#2E67E3'
            }
        },
        headerStyle: {
            color: '#FFF',
            bgColor: '#5389FF',
            borderColor: '#A1C1FF',
            hover: {
                cellBgColor: '#2E67E3'
            }
        },
        bodyStyle: {
            color: '#000',
            bgColor: getBackgroundColor$2,
            borderColor: '#E0EAFE',
            hover: {
                cellBgColor: '#E9EFFD'
            }
        },
        frameStyle: {
            borderColor: '#E1E4E8',
            borderLineWidth: 1,
            borderLineDash: [],
            cornerRadius: 0,
            shadowBlur: 0,
            shadowOffsetX: 0,
            shadowOffsetY: 0,
            shadowColor: 'black'
        },
        columnResize: {
            lineWidth: 1,
            lineColor: '#416EFF',
            bgColor: '#D9E2FF',
            width: 3
        },
        frozenColumnLine: {
            shadow: {
                width: 3,
                startColor: '#CBDCFE',
                endColor: '#CBDCFE',
                visible: 'always'
            }
        },
        selectionStyle: {
            cellBgColor: 'rgba(0, 0, 255,0.1)'
        },
        tooltipStyle: {
            bgColor: '#FFF',
            color: '#000',
            fontSize: 12,
            fontFamily: 'Arial,sans-serif'
        }
    };

    function getBackgroundColor$1(args) {
        const { row, table } = args;
        const index = row - table.frozenRowCount;
        if (!(index & 1)) {
            return '#FFF';
        }
        return '#fbfbfc';
    }
    var arcoTheme = {
        name: 'ARCO',
        underlayBackgroundColor: '#FFF',
        defaultStyle: {
            color: '#1B1F23',
            bgColor: '#EEF1F5',
            fontSize: 14,
            fontFamily: 'Arial,sans-serif',
            fontWeight: 600,
            lineHeight: 14,
            borderColor: '#e1e4e8',
            padding: [8, 12, 8, 12]
        },
        headerStyle: {
            color: '#1B1F23',
            bgColor: '#EEF1F5',
            fontSize: 14,
            fontFamily: 'Arial,sans-serif',
            fontWeight: 600,
            lineHeight: 14,
            borderColor: '#e1e4e8',
            padding: [8, 12, 8, 12],
            hover: {
                cellBgColor: '#c8daf6'
            }
        },
        rowHeaderStyle: {
            color: '#1B1F23',
            bgColor: '#EEF1F5',
            fontSize: 12,
            fontFamily: 'PingFang SC',
            fontWeight: 500,
            lineHeight: 12,
            borderColor: '#e1e4e8',
            padding: [8, 12, 8, 12],
            hover: {
                cellBgColor: '#c8daf6'
            }
        },
        cornerHeaderStyle: {
            color: '#1B1F23',
            bgColor: '#EEF1F5',
            fontSize: 12,
            fontFamily: 'PingFang SC',
            fontWeight: 500,
            lineHeight: 12,
            borderColor: '#e1e4e8',
            padding: [8, 12, 8, 12],
            hover: {
                cellBgColor: '#c8daf6'
            }
        },
        bodyStyle: {
            padding: [8, 12, 8, 12],
            color: '#141414',
            fontSize: 14,
            fontFamily: 'Arial,sans-serif',
            fontWeight: 400,
            textAlign: 'left',
            bgColor: getBackgroundColor$1,
            borderColor: '#e1e4e8',
            lineHeight: 14,
            hover: {
                cellBgColor: '#F7F8FA',
                inlineRowBgColor: '#F3F8FF',
                inlineColumnBgColor: '#F3F8FF'
            }
        },
        frameStyle: {
            borderColor: '#d1d5da',
            borderLineWidth: 1,
            borderLineDash: [],
            cornerRadius: 4,
            shadowBlur: 6,
            shadowOffsetX: 0,
            shadowOffsetY: 0,
            shadowColor: 'rgba(00, 24, 47, 0.06)'
        },
        columnResize: {
            lineWidth: 1,
            lineColor: '#416EFF',
            bgColor: '#D9E2FF',
            width: 3
        },
        frozenColumnLine: {
            shadow: {
                width: 4,
                startColor: 'rgba(00, 24, 47, 0.05)',
                endColor: 'rgba(00, 24, 47, 0)',
                visible: 'always'
            }
        },
        selectionStyle: {
            cellBgColor: 'rgba(0, 0, 255,0.1)',
            cellBorderLineWidth: 2,
            cellBorderColor: '#3073f2'
        },
        tooltipStyle: {
            bgColor: '#FFF',
            color: '#000',
            fontSize: 12,
            fontFamily: 'Arial,sans-serif'
        }
    };

    function getBackgroundColor(args) {
        const { row, table } = args;
        const index = row - table.frozenRowCount;
        if (!(index & 1)) {
            return '#FAF9FB';
        }
        return '#FDFDFD';
    }
    var defaultTheme = {
        name: 'DEFAULT',
        underlayBackgroundColor: '#FFF',
        defaultStyle: {
            borderColor: '#E1E4E8',
            color: '#000',
            bgColor: '#ECF1F5'
        },
        headerStyle: {
            fontSize: 16,
            fontWeight: 'bold',
            bgColor: '#ECF1F5',
            hover: {
                cellBgColor: '#CCE0FF',
                inlineRowBgColor: '#F3F8FF',
                inlineColumnBgColor: '#F3F8FF'
            }
        },
        rowHeaderStyle: {
            fontSize: 16,
            fontWeight: 'bold',
            bgColor: '#ECF1F5',
            hover: {
                cellBgColor: '#CCE0FF',
                inlineRowBgColor: '#F3F8FF',
                inlineColumnBgColor: '#F3F8FF'
            }
        },
        cornerHeaderStyle: {
            fontSize: 16,
            fontWeight: 'bold'
        },
        bodyStyle: {
            fontSize: 14,
            bgColor: getBackgroundColor,
            hover: {
                cellBgColor: '#CCE0FF',
                inlineRowBgColor: '#F3F8FF',
                inlineColumnBgColor: '#F3F8FF'
            }
        },
        frameStyle: {
            borderColor: '#E1E4E8',
            borderLineWidth: 1,
            borderLineDash: [],
            cornerRadius: 0,
            shadowBlur: 0,
            shadowOffsetX: 0,
            shadowOffsetY: 0,
            shadowColor: 'black'
        },
        columnResize: {
            lineWidth: 1,
            lineColor: '#416EFF',
            bgColor: '#D9E2FF',
            width: 3
        },
        frozenColumnLine: {
            shadow: {
                width: 3,
                startColor: 'rgba(225, 228, 232, 0.6)',
                endColor: 'rgba(225, 228, 232, 0.6)',
                visible: 'always'
            }
        },
        selectionStyle: {
            cellBgColor: 'rgba(0, 0, 255,0.1)',
            cellBorderLineWidth: 2,
            cellBorderColor: '#0000ff'
        },
        tooltipStyle: {
            bgColor: '#FFF',
            color: '#000',
            fontSize: 12,
            fontFamily: 'Arial,sans-serif'
        }
    };

    function getFrozenRowsBorderColor(args) {
        const { row, table: { frozenRowCount } } = args;
        if (frozenRowCount - 1 === row) {
            return ['#f2f2f2', '#f2f2f2', '#ccc7c7', '#f2f2f2'];
        }
        return ['#f2f2f2'];
    }
    function getBorderColor(args) {
        const { col, table } = args;
        const { colCount, frozenColCount } = table;
        const top = '#ccc7c7';
        const bottom = '#ccc7c7';
        if (frozenColCount - 1 === col) {
            return [top, '#f2f2f2', bottom, null];
        }
        if (colCount - 1 === col) {
            return [top, '#f2f2f2', bottom, null];
        }
        return [top, null, bottom, null];
    }
    var materialDesignTheme = {
        name: 'SIMPLIFY',
        underlayBackgroundColor: '#FFF',
        defaultStyle: {
            borderColor: getBorderColor,
            hover: { cellBorderColor: '#0000FF', cellBgColor: '#D0E0E3' },
            bgColor: '#FFF'
        },
        headerStyle: {
            color: 'rgba(0, 0, 0, 0.87)',
            borderColor: getFrozenRowsBorderColor
        },
        bodyStyle: {
            color: 'rgba(0, 0, 0, 0.87)'
        },
        frameStyle: {
            borderColor: '#f2f2f2',
            borderLineWidth: 1
        },
        columnResize: {
            lineWidth: 1,
            lineColor: '#416EFF',
            bgColor: '#D9E2FF'
        },
        selectionStyle: { cellBorderColor: '#FD5', cellBgColor: 'rgba(111, 168, 220, 0.1)' },
        tooltipStyle: {
            bgColor: '#FFF',
            color: '#000',
            fontSize: 12,
            fontFamily: 'Arial,sans-serif'
        }
    };

    const themes$2 = {};

    const DEFAULTFONTSIZE = 16;
    const DEFAULTFONTFAMILY = 'Arial,sans-serif';
    const DEFAULTBGCOLOR = '#FFF';
    const DEFAULTBORDERCOLOR = '#000';
    const DEFAULTBORDERLINEWIDTH = 1;
    const DEFAULTBORDERLINEDASH = [];
    const DEFAULTFONTCOLOR = '#000';
    const regUrl = /^(https?|ftp|file):\/\/[-A-Za-z0-9+&@#/%?=~_|!:,.;]+[-A-Za-z0-9+&@#/%=~_|]/;
    const IndicatorDimensionKeyPlaceholder = '$$indicator$$';
    const DrillDown = `<svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><rect x="0" y="0" width="1024" height="1024" rx="20%" ry="20%" fill="#ffffff" /><path  d="M810.666667 85.333333c70.688 0 128 57.312 128 128v597.333334c0 70.688-57.312 128-128 128H213.333333c-70.688 0-128-57.312-128-128V213.333333c0-70.688 57.312-128 128-128h597.333334z m0 85.333334H213.333333a42.666667 42.666667 0 0 0-42.613333 40.533333L170.666667 213.333333v597.333334a42.666667 42.666667 0 0 0 40.533333 42.613333L213.333333 853.333333h597.333334a42.666667 42.666667 0 0 0 42.613333-40.533333L853.333333 810.666667V213.333333a42.666667 42.666667 0 0 0-40.533333-42.613333L810.666667 170.666667zM549.333333 288a5.333333 5.333333 0 0 1 5.333334 5.333333V469.333333h176a5.333333 5.333333 0 0 1 5.333333 5.333334v74.666666a5.333333 5.333333 0 0 1-5.333333 5.333334H554.666667v176a5.333333 5.333333 0 0 1-5.333334 5.333333h-74.666666a5.333333 5.333333 0 0 1-5.333334-5.333333V554.666667H293.333333a5.333333 5.333333 0 0 1-5.333333-5.333334v-74.666666a5.333333 5.333333 0 0 1 5.333333-5.333334H469.333333V293.333333a5.333333 5.333333 0 0 1 5.333334-5.333333h74.666666z"></path></svg>`;
    const DrillUp = `<svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><rect x="0" y="0" width="1024" height="1024" rx="20%" ry="20%" fill="#ffffff" /><path d="M810.666667 85.333333c70.688 0 128 57.312 128 128v597.333334c0 70.688-57.312 128-128 128H213.333333c-70.688 0-128-57.312-128-128V213.333333c0-70.688 57.312-128 128-128h597.333334z m0 85.333334H213.333333a42.666667 42.666667 0 0 0-42.613333 40.533333L170.666667 213.333333v597.333334a42.666667 42.666667 0 0 0 40.533333 42.613333L213.333333 853.333333h597.333334a42.666667 42.666667 0 0 0 42.613333-40.533333L853.333333 810.666667V213.333333a42.666667 42.666667 0 0 0-40.533333-42.613333L810.666667 170.666667zM693.333333 469.333333a42.666667 42.666667 0 1 1 0 85.333334H330.666667a42.666667 42.666667 0 1 1 0-85.333334h362.666666z"></path></svg>`;
    const DefaultSparklineSpec = {
        type: 'line'
    };

    function getAxisStyle(axisStyle) {
        const style = {
            defaultAxisStyle: getSingleAxisStyle(axisStyle.defaultAxisStyle),
            leftAxisStyle: getSingleAxisStyle(axisStyle.leftAxisStyle),
            rightAxisStyle: getSingleAxisStyle(axisStyle.rightAxisStyle),
            topAxisStyle: getSingleAxisStyle(axisStyle.topAxisStyle),
            bottomAxisStyle: getSingleAxisStyle(axisStyle.bottomAxisStyle)
        };
        return style;
    }
    function getSingleAxisStyle(axisStyle) {
        if (!axisStyle) {
            return {};
        }
        return axisStyle;
    }
    const defalutPoptipStyle = {
        visible: true,
        position: 'auto',
        padding: 8,
        titleStyle: {
            fontSize: 12,
            fontWeight: 'bold',
            fill: '#4E5969'
        },
        contentStyle: {
            fontSize: 12,
            fill: '#4E5969'
        },
        panel: {
            visible: true,
            fill: '#fff',
            stroke: '#ffffff',
            lineWidth: 0,
            cornerRadius: 3,
            shadowBlur: 12,
            shadowOffsetX: 0,
            shadowOffsetY: 4,
            shadowColor: 'rgba(0, 0, 0, 0.1)',
            size: 0,
            space: 12
        }
    };

    function getProp$1(obj, superObj, names, defNames) {
        return (getChainSafe(obj, ...names) ??
            getChainSafe(superObj, ...names) ??
            (defNames && getChainSafe(obj, ...defNames)) ??
            (defNames && getChainSafe(superObj, ...defNames)));
    }
    class TableTheme {
        internalTheme;
        _defaultStyle = null;
        _header = null;
        _cornerHeader = null;
        _cornerRightTopCell = null;
        _cornerLeftBottomCell = null;
        _cornerRightBottomCell = null;
        _rightFrozen = null;
        _bottomFrozen = null;
        _rowHeader = null;
        _body = null;
        _groupTitle = null;
        _scroll = null;
        _tooltip = null;
        _frameStyle = null;
        _columnResize = null;
        _dragHeaderSplitLine = null;
        _frozenColumnLine = null;
        _selectionStyle = null;
        _axisStyle = null;
        _checkboxStyle = null;
        _radioStyle = null;
        _switchStyle = null;
        _buttonStyle = null;
        _textPopTipStyle = null;
        _internalIconsStyle = null;
        isPivot = false;
        name = '';
        constructor(obj, superTheme) {
            this.internalTheme = {
                obj,
                superTheme
            };
            this.name = getProp$1(obj, superTheme, ['name']);
        }
        getExtendTheme() {
            return this.internalTheme.obj;
        }
        clearBodyStyleCache() {
            this._body = null;
        }
        get font() {
            const { obj, superTheme } = this.internalTheme;
            return getProp$1(obj, superTheme, ['font'], ['bodyStyle', 'font']);
        }
        get underlayBackgroundColor() {
            const { obj, superTheme } = this.internalTheme;
            return getProp$1(obj, superTheme, ['underlayBackgroundColor']);
        }
        get cellInnerBorder() {
            const { obj, superTheme } = this.internalTheme;
            return getProp$1(obj, superTheme, ['cellInnerBorder']) ?? true;
        }
        get cellBorderClipDirection() {
            const { obj, superTheme } = this.internalTheme;
            return getProp$1(obj, superTheme, ['cellBorderClipDirection']) ?? 'top-left';
        }
        get _contentOffset() {
            const { obj, superTheme } = this.internalTheme;
            return getProp$1(obj, superTheme, ['_contentOffset']) ?? 0;
        }
        get defaultStyle() {
            const that = this;
            if (!this._defaultStyle) {
                const { obj, superTheme } = this.internalTheme;
                const defaultStyle = ingoreNoneValueMerge({}, superTheme.defaultStyle, obj.defaultStyle);
                this._defaultStyle = {
                    get fontSize() {
                        return defaultStyle.fontSize ?? DEFAULTFONTSIZE;
                    },
                    get fontFamily() {
                        return defaultStyle.fontFamily ?? DEFAULTFONTFAMILY;
                    },
                    get fontWeight() {
                        return defaultStyle.fontWeight;
                    },
                    get fontVariant() {
                        return defaultStyle.fontVariant;
                    },
                    get fontStyle() {
                        return defaultStyle.fontStyle;
                    },
                    get bgColor() {
                        return defaultStyle.bgColor ?? DEFAULTBGCOLOR;
                    },
                    get color() {
                        return defaultStyle.color ?? DEFAULTFONTCOLOR;
                    },
                    get borderColor() {
                        return defaultStyle.borderColor ?? DEFAULTBORDERCOLOR;
                    },
                    get borderLineWidth() {
                        return defaultStyle.borderLineWidth ?? DEFAULTBORDERLINEWIDTH;
                    },
                    get borderLineDash() {
                        return defaultStyle.borderLineDash ?? DEFAULTBORDERLINEDASH;
                    },
                    get hover() {
                        if (defaultStyle.hover) {
                            return {
                                get cellBgColor() {
                                    return defaultStyle.hover?.cellBgColor ?? undefined;
                                },
                                get inlineColumnBgColor() {
                                    return (defaultStyle.hover?.inlineColumnBgColor ??
                                        (defaultStyle.hover?.cellBgColor && typeof defaultStyle.hover?.cellBgColor === 'string'
                                            ? changeColor(defaultStyle.hover?.cellBgColor, 0.1, false)
                                            : undefined) ??
                                        undefined);
                                },
                                get inlineRowBgColor() {
                                    return (defaultStyle.hover?.inlineRowBgColor ??
                                        (defaultStyle.hover?.cellBgColor && typeof defaultStyle.hover?.cellBgColor === 'string'
                                            ? changeColor(defaultStyle.hover?.cellBgColor, 0.1, false)
                                            : undefined) ??
                                        undefined);
                                }
                            };
                        }
                        return undefined;
                    },
                    get select() {
                        if (defaultStyle.select) {
                            return {
                                get inlineColumnBgColor() {
                                    return (defaultStyle.select?.inlineColumnBgColor ??
                                        that.selectionStyle?.inlineColumnBgColor ??
                                        (that.selectionStyle?.cellBgColor && typeof that.selectionStyle.cellBgColor === 'string'
                                            ? changeColor(that.selectionStyle.cellBgColor, 0.1, false)
                                            : undefined) ??
                                        undefined);
                                },
                                get inlineRowBgColor() {
                                    return (defaultStyle.select?.inlineRowBgColor ??
                                        that.selectionStyle.inlineRowBgColor ??
                                        (that.selectionStyle?.cellBgColor && typeof that.selectionStyle.cellBgColor === 'string'
                                            ? changeColor(that.selectionStyle.cellBgColor, 0.1, false)
                                            : undefined) ??
                                        undefined);
                                }
                            };
                        }
                        return undefined;
                    },
                    get padding() {
                        return defaultStyle.padding ?? [10, 16, 10, 16];
                    },
                    get textAlign() {
                        return defaultStyle.textAlign ?? 'left';
                    },
                    get textBaseline() {
                        return defaultStyle.textBaseline ?? 'middle';
                    },
                    get textOverflow() {
                        return defaultStyle.textOverflow ?? 'ellipsis';
                    },
                    get lineHeight() {
                        return defaultStyle.lineHeight;
                    },
                    get autoWrapText() {
                        return defaultStyle.autoWrapText ?? false;
                    },
                    get lineClamp() {
                        return defaultStyle.lineClamp ?? 'auto';
                    },
                    get linkColor() {
                        return defaultStyle.linkColor ?? '#3772ff';
                    },
                    get cursor() {
                        return defaultStyle.cursor ?? 'auto';
                    },
                    get marked() {
                        return defaultStyle.marked ?? false;
                    },
                    get underline() {
                        return defaultStyle.underline ?? false;
                    },
                    get underlineColor() {
                        return defaultStyle.underlineColor;
                    },
                    get underlineDash() {
                        return defaultStyle.underlineDash;
                    },
                    get underlineOffset() {
                        return defaultStyle.underlineOffset;
                    },
                    get lineThrough() {
                        return defaultStyle.lineThrough ?? false;
                    },
                    get lineThroughColor() {
                        return defaultStyle.lineThroughColor;
                    },
                    get lineThroughDash() {
                        return defaultStyle.lineThroughDash;
                    }
                };
            }
            return this._defaultStyle;
        }
        get cornerHeaderStyle() {
            if (!this._cornerHeader) {
                const { obj, superTheme } = this.internalTheme;
                const header = ingoreNoneValueMerge({}, this.defaultStyle, superTheme.cornerHeaderStyle, obj.cornerHeaderStyle);
                this._cornerHeader = this.getStyle(header);
            }
            return this._cornerHeader;
        }
        get cornerRightTopCellStyle() {
            if (!this._cornerRightTopCell) {
                const { obj, superTheme } = this.internalTheme;
                if (!superTheme.cornerRightTopCellStyle && !obj.cornerRightTopCellStyle) {
                    return this._cornerRightTopCell;
                }
                const header = ingoreNoneValueMerge({}, this.defaultStyle, superTheme.cornerRightTopCellStyle, obj.cornerRightTopCellStyle);
                this._cornerRightTopCell = this.getStyle(header);
            }
            return this._cornerRightTopCell;
        }
        get cornerLeftBottomCellStyle() {
            if (!this._cornerLeftBottomCell) {
                const { obj, superTheme } = this.internalTheme;
                if (!superTheme.cornerLeftBottomCellStyle && !obj.cornerLeftBottomCellStyle) {
                    return this._cornerLeftBottomCell;
                }
                const header = ingoreNoneValueMerge({}, this.defaultStyle, superTheme.cornerLeftBottomCellStyle, obj.cornerLeftBottomCellStyle);
                this._cornerLeftBottomCell = this.getStyle(header);
            }
            return this._cornerLeftBottomCell;
        }
        get cornerRightBottomCellStyle() {
            if (!this._cornerRightBottomCell) {
                const { obj, superTheme } = this.internalTheme;
                if (!superTheme.cornerRightBottomCellStyle && !obj.cornerRightBottomCellStyle) {
                    return this._cornerRightBottomCell;
                }
                const header = ingoreNoneValueMerge({}, this.defaultStyle, superTheme.cornerRightBottomCellStyle, obj.cornerRightBottomCellStyle);
                this._cornerRightBottomCell = this.getStyle(header);
            }
            return this._cornerRightBottomCell;
        }
        get rightFrozenStyle() {
            if (!this._rightFrozen) {
                const { obj, superTheme } = this.internalTheme;
                if (!superTheme.rightFrozenStyle && !obj.rightFrozenStyle) {
                    return this._rightFrozen;
                }
                const header = ingoreNoneValueMerge({}, this.defaultStyle, this.rowHeaderStyle, superTheme.rightFrozenStyle, obj.rightFrozenStyle);
                this._rightFrozen = this.getStyle(header);
            }
            return this._rightFrozen;
        }
        get bottomFrozenStyle() {
            if (!this._bottomFrozen) {
                const { obj, superTheme } = this.internalTheme;
                if (!superTheme.bottomFrozenStyle && !obj.bottomFrozenStyle) {
                    return this._bottomFrozen;
                }
                const header = ingoreNoneValueMerge({}, this.defaultStyle, this.headerStyle, superTheme.bottomFrozenStyle, obj.bottomFrozenStyle);
                this._bottomFrozen = this.getStyle(header);
            }
            return this._bottomFrozen;
        }
        get rowHeaderStyle() {
            if (!this._rowHeader) {
                const { obj, superTheme } = this.internalTheme;
                const header = ingoreNoneValueMerge({}, this.defaultStyle, superTheme.rowHeaderStyle, obj.rowHeaderStyle ?? (this.isPivot ? null : obj.headerStyle));
                this._rowHeader = this.getStyle(header);
            }
            return this._rowHeader;
        }
        get headerStyle() {
            if (!this._header) {
                const { obj, superTheme } = this.internalTheme;
                const header = ingoreNoneValueMerge({}, this.defaultStyle, superTheme.headerStyle, obj.headerStyle);
                this._header = this.getStyle(header);
            }
            return this._header;
        }
        get bodyStyle() {
            if (!this._body) {
                const { obj, superTheme } = this.internalTheme;
                const body = ingoreNoneValueMerge({}, this.defaultStyle, superTheme.bodyStyle, obj.bodyStyle);
                this._body = this.getStyle(body);
            }
            return this._body;
        }
        get groupTitleStyle() {
            if (!this._groupTitle) {
                const { obj, superTheme } = this.internalTheme;
                if (!superTheme.groupTitleStyle && !obj.groupTitleStyle) {
                    return this._groupTitle;
                }
                const groupTitle = ingoreNoneValueMerge({}, this.defaultStyle, superTheme.groupTitleStyle, obj.groupTitleStyle);
                this._groupTitle = this.getStyle(groupTitle);
            }
            return this._groupTitle;
        }
        get frameStyle() {
            if (!this._frameStyle) {
                const { obj, superTheme } = this.internalTheme;
                const frameStyle = ingoreNoneValueMerge({}, superTheme.frameStyle, obj.frameStyle);
                this._frameStyle = {
                    get borderColor() {
                        return frameStyle.borderColor;
                    },
                    get borderLineWidth() {
                        return frameStyle.borderLineWidth;
                    },
                    get borderLineDash() {
                        return frameStyle.borderLineDash;
                    },
                    get innerBorder() {
                        return frameStyle.innerBorder;
                    },
                    get shadowBlur() {
                        return frameStyle.shadowBlur;
                    },
                    get shadowColor() {
                        return frameStyle.shadowColor;
                    },
                    get shadowOffsetX() {
                        return frameStyle.shadowOffsetX;
                    },
                    get shadowOffsetY() {
                        return frameStyle.shadowOffsetY;
                    },
                    get cornerRadius() {
                        return frameStyle.cornerRadius;
                    }
                };
            }
            return this._frameStyle;
        }
        get scrollStyle() {
            if (!this._scroll) {
                const { obj, superTheme } = this.internalTheme;
                const scroll = ingoreNoneValueMerge({}, superTheme.scrollStyle, obj.scrollStyle);
                this._scroll = {
                    get scrollSliderColor() {
                        return scroll.scrollSliderColor ?? '#C0C0C0';
                    },
                    get scrollSliderCornerRadius() {
                        return scroll.scrollSliderCornerRadius;
                    },
                    get scrollRailColor() {
                        return scroll.scrollRailColor;
                    },
                    get visible() {
                        return scroll.visible ?? 'scrolling';
                    },
                    get verticalVisible() {
                        return scroll.verticalVisible;
                    },
                    get horizontalVisible() {
                        return scroll.horizontalVisible;
                    },
                    get width() {
                        return scroll.width ?? 7;
                    },
                    get hoverOn() {
                        return scroll.hoverOn ?? true;
                    },
                    get barToSide() {
                        return scroll.barToSide ?? false;
                    },
                    get horizontalPadding() {
                        return scroll.horizontalPadding ?? 0;
                    },
                    get verticalPadding() {
                        return scroll.verticalPadding ?? 0;
                    }
                };
            }
            return this._scroll;
        }
        get tooltipStyle() {
            if (!this._tooltip) {
                const { obj, superTheme } = this.internalTheme;
                const tooltip = ingoreNoneValueMerge({}, superTheme.tooltipStyle, obj.tooltipStyle);
                this._tooltip = {
                    get fontFamily() {
                        return tooltip.fontFamily ?? DEFAULTFONTFAMILY;
                    },
                    get fontSize() {
                        return tooltip.fontSize ?? DEFAULTFONTSIZE;
                    },
                    get bgColor() {
                        return tooltip.bgColor ?? '#000';
                    },
                    get padding() {
                        return tooltip.padding ?? [6, 8];
                    },
                    get color() {
                        return tooltip.color ?? '#FFF';
                    },
                    get maxWidth() {
                        return tooltip.maxWidth;
                    },
                    get maxHeight() {
                        return tooltip.maxHeight;
                    }
                };
            }
            return this._tooltip;
        }
        get columnResize() {
            if (!this._columnResize) {
                const { obj, superTheme } = this.internalTheme;
                const columnResize = ingoreNoneValueMerge({}, superTheme.columnResize, obj.columnResize);
                this._columnResize = {
                    get lineColor() {
                        return columnResize.lineColor ?? '#416EFF';
                    },
                    get bgColor() {
                        return columnResize.bgColor ?? '#D9E2FF';
                    },
                    get lineWidth() {
                        return columnResize.lineWidth ?? 1;
                    },
                    get width() {
                        return columnResize.width ?? columnResize.lineWidth + 2;
                    },
                    get resizeHotSpotSize() {
                        return columnResize.resizeHotSpotSize ?? 16;
                    },
                    get labelColor() {
                        return columnResize.labelColor ?? '#FFF';
                    },
                    get labelFontSize() {
                        return columnResize.labelFontSize ?? 10;
                    },
                    get labelFontFamily() {
                        return columnResize.labelFontFamily ?? 'sans-serif';
                    },
                    get labelBackgroundFill() {
                        return columnResize.labelBackgroundFill ?? '#3073F2';
                    },
                    get labelBackgroundCornerRadius() {
                        return columnResize.labelBackgroundCornerRadius ?? 5;
                    },
                    get labelVisible() {
                        return columnResize.labelVisible ?? true;
                    },
                    get visibleOnHover() {
                        return columnResize.visibleOnHover ?? false;
                    }
                };
            }
            return this._columnResize;
        }
        get dragHeaderSplitLine() {
            if (!this._dragHeaderSplitLine) {
                const { obj, superTheme } = this.internalTheme;
                const dragHeaderSplitLine = ingoreNoneValueMerge({}, superTheme.dragHeaderSplitLine, obj.dragHeaderSplitLine);
                this._dragHeaderSplitLine = {
                    get lineColor() {
                        return dragHeaderSplitLine.lineColor ?? 'blue';
                    },
                    get lineWidth() {
                        return dragHeaderSplitLine.lineWidth ?? 2;
                    },
                    get shadowBlockColor() {
                        return dragHeaderSplitLine.shadowBlockColor ?? 'rgba(204,204,204,0.3)';
                    }
                };
            }
            return this._dragHeaderSplitLine;
        }
        get frozenColumnLine() {
            if (!this._frozenColumnLine) {
                const { obj, superTheme } = this.internalTheme;
                const frozenColumnLine = ingoreNoneValueMerge({}, superTheme.frozenColumnLine, obj.frozenColumnLine);
                this._frozenColumnLine = {
                    get shadow() {
                        if (frozenColumnLine.shadow) {
                            return {
                                get width() {
                                    return frozenColumnLine.shadow?.width ?? 24;
                                },
                                get startColor() {
                                    return frozenColumnLine.shadow?.startColor ?? 'rgba(00, 24, 47, 0.06)';
                                },
                                get endColor() {
                                    return frozenColumnLine.shadow?.endColor ?? 'rgba(00, 24, 47, 0)';
                                },
                                get visible() {
                                    return frozenColumnLine.shadow?.visible ?? 'always';
                                }
                            };
                        }
                        return undefined;
                    },
                    get border() {
                        if (frozenColumnLine.border) {
                            return {
                                get lineColor() {
                                    return frozenColumnLine.border?.lineColor ?? 'rgba(00, 24, 47, 0.06)';
                                },
                                get bgColor() {
                                    return (frozenColumnLine.border?.bgColor ?? frozenColumnLine.border?.lineColor ?? 'rgba(00, 24, 47, 0.06)');
                                },
                                get lineWidth() {
                                    return frozenColumnLine.border?.lineWidth ?? 4;
                                },
                                get width() {
                                    return frozenColumnLine.border?.width ?? frozenColumnLine.border?.lineWidth ?? 4;
                                }
                            };
                        }
                        return undefined;
                    }
                };
            }
            return this._frozenColumnLine;
        }
        get selectionStyle() {
            if (!this._selectionStyle) {
                const { obj, superTheme } = this.internalTheme;
                const selectionStyle = ingoreNoneValueMerge({}, superTheme.selectionStyle, obj.selectionStyle);
                this._selectionStyle = {
                    get cellBgColor() {
                        return selectionStyle?.cellBgColor ?? 'rgba(0, 0, 255,0.1)';
                    },
                    get cellBorderColor() {
                        return selectionStyle?.cellBorderColor ?? '#3073f2';
                    },
                    get cellBorderLineWidth() {
                        return selectionStyle?.cellBorderLineWidth ?? 2;
                    },
                    get inlineColumnBgColor() {
                        return selectionStyle?.inlineColumnBgColor;
                    },
                    get inlineRowBgColor() {
                        return selectionStyle?.inlineRowBgColor;
                    },
                    get selectionFillMode() {
                        return selectionStyle?.selectionFillMode ?? 'overlay';
                    },
                    get dynamicUpdateSelectionSize() {
                        return selectionStyle?.dynamicUpdateSelectionSize ?? false;
                    }
                };
            }
            return this._selectionStyle;
        }
        get axisStyle() {
            if (!this._axisStyle) {
                const { obj, superTheme } = this.internalTheme;
                const axisStyle = ingoreNoneValueMerge({}, superTheme.axisStyle, obj.axisStyle);
                this._axisStyle = getAxisStyle(axisStyle);
            }
            return this._axisStyle;
        }
        get checkboxStyle() {
            if (!this._checkboxStyle) {
                const { obj, superTheme } = this.internalTheme;
                const checkboxStyle = ingoreNoneValueMerge({}, superTheme.checkboxStyle, obj.checkboxStyle);
                this._checkboxStyle = checkboxStyle;
            }
            return this._checkboxStyle;
        }
        get radioStyle() {
            if (!this._radioStyle) {
                const { obj, superTheme } = this.internalTheme;
                const radioStyle = ingoreNoneValueMerge({}, superTheme.radioStyle, obj.radioStyle);
                this._radioStyle = radioStyle;
            }
            return this._radioStyle;
        }
        get switchStyle() {
            if (!this._switchStyle) {
                const { obj, superTheme } = this.internalTheme;
                const switchStyle = ingoreNoneValueMerge({}, superTheme.switchStyle, obj.switchStyle);
                this._switchStyle = switchStyle;
            }
            return this._switchStyle;
        }
        get buttonStyle() {
            if (!this._buttonStyle) {
                const { obj, superTheme } = this.internalTheme;
                const buttonStyle = ingoreNoneValueMerge({}, superTheme.buttonStyle, obj.buttonStyle);
                this._buttonStyle = buttonStyle;
            }
            return this._buttonStyle;
        }
        get textPopTipStyle() {
            if (!this._textPopTipStyle) {
                const { obj, superTheme } = this.internalTheme;
                const textPopTipStyle = ingoreNoneValueMerge({}, defalutPoptipStyle, superTheme.textPopTipStyle, obj.textPopTipStyle);
                this._textPopTipStyle = textPopTipStyle;
            }
            return this._textPopTipStyle;
        }
        get functionalIconsStyle() {
            if (!this._internalIconsStyle) {
                const { obj, superTheme } = this.internalTheme;
                const functionalIconsStyle = ingoreNoneValueMerge({}, superTheme.functionalIconsStyle, obj.functionalIconsStyle);
                this._internalIconsStyle = functionalIconsStyle;
            }
            return this._internalIconsStyle;
        }
        hasProperty(names) {
            const { obj, superTheme } = this.internalTheme;
            return hasThemeProperty(obj, names) || hasThemeProperty(superTheme, names);
        }
        extends(obj) {
            return new TableTheme(ingoreNoneValueMerge({}, obj), ingoreNoneValueMerge(this.internalTheme.superTheme, this.internalTheme.obj));
        }
        getStyle(style) {
            const that = this;
            return {
                get fontSize() {
                    return style.fontSize;
                },
                get fontFamily() {
                    return style.fontFamily;
                },
                get fontWeight() {
                    return style.fontWeight;
                },
                get fontVariant() {
                    return style.fontVariant;
                },
                get fontStyle() {
                    return style.fontStyle;
                },
                get bgColor() {
                    return style.bgColor;
                },
                get color() {
                    return style.color;
                },
                get strokeColor() {
                    return style.strokeColor;
                },
                get borderColor() {
                    return style.borderColor;
                },
                get borderLineWidth() {
                    return style.borderLineWidth;
                },
                get borderLineDash() {
                    return style.borderLineDash;
                },
                get hover() {
                    if (style.hover) {
                        return {
                            get cellBgColor() {
                                return style.hover?.cellBgColor ?? undefined;
                            },
                            get inlineColumnBgColor() {
                                return (style.hover?.inlineColumnBgColor ??
                                    (style.hover?.cellBgColor && typeof style.hover?.cellBgColor === 'string'
                                        ? changeColor(style.hover?.cellBgColor, 0.1, false)
                                        : undefined) ??
                                    undefined);
                            },
                            get inlineRowBgColor() {
                                return (style.hover?.inlineRowBgColor ??
                                    (style.hover?.cellBgColor && typeof style.hover?.cellBgColor === 'string'
                                        ? changeColor(style.hover?.cellBgColor, 0.1, false)
                                        : undefined) ??
                                    undefined);
                            }
                        };
                    }
                    return undefined;
                },
                get select() {
                    return {
                        get inlineColumnBgColor() {
                            return (style.select?.inlineColumnBgColor ??
                                that.selectionStyle?.inlineColumnBgColor ??
                                (that.selectionStyle?.cellBgColor && typeof that.selectionStyle.cellBgColor === 'string'
                                    ? changeColor(that.selectionStyle.cellBgColor, 0.1, false)
                                    : undefined) ??
                                undefined);
                        },
                        get inlineRowBgColor() {
                            return (style.select?.inlineRowBgColor ??
                                that.selectionStyle.inlineRowBgColor ??
                                (that.selectionStyle?.cellBgColor && typeof that.selectionStyle.cellBgColor === 'string'
                                    ? changeColor(that.selectionStyle.cellBgColor, 0.1, false)
                                    : undefined) ??
                                undefined);
                        },
                        get cellBgColor() {
                            if (that.selectionStyle.selectionFillMode === 'replace') {
                                return style.select?.cellBgColor ?? that.selectionStyle.cellBgColor ?? undefined;
                            }
                            return undefined;
                        }
                    };
                },
                get frameStyle() {
                    if (style.frameStyle) {
                        return {
                            get borderColor() {
                                return style.frameStyle?.borderColor ?? undefined;
                            },
                            get borderLineWidth() {
                                return style.frameStyle?.borderLineWidth ?? undefined;
                            },
                            get borderLineDash() {
                                return style.frameStyle?.borderLineDash ?? undefined;
                            }
                        };
                    }
                    return undefined;
                },
                get padding() {
                    return style.padding;
                },
                get textAlign() {
                    return style.textAlign;
                },
                get textBaseline() {
                    return style.textBaseline;
                },
                get textOverflow() {
                    return style.textOverflow;
                },
                get lineHeight() {
                    return style.lineHeight;
                },
                get autoWrapText() {
                    return style.autoWrapText;
                },
                get lineClamp() {
                    return style.lineClamp;
                },
                get linkColor() {
                    return style.linkColor;
                },
                get cursor() {
                    return style.cursor;
                },
                get textStick() {
                    return style.textStick;
                },
                get marked() {
                    return style.marked;
                },
                get underline() {
                    return style.underline ?? false;
                },
                get underlineColor() {
                    return style.underlineColor;
                },
                get underlineDash() {
                    return style.underlineDash;
                },
                get underlineOffset() {
                    return style.underlineOffset;
                },
                get lineThrough() {
                    return style.lineThrough ?? false;
                },
                get lineThroughColor() {
                    return style.lineThroughColor;
                },
                get lineThroughDash() {
                    return style.lineThroughDash;
                }
            };
        }
    }
    function hasThemeProperty(obj, names) {
        if (obj instanceof TableTheme) {
            return obj.hasProperty(names);
        }
        let o = obj;
        if (!o) {
            return false;
        }
        for (let index = 0; index < names.length; index++) {
            const name = names[index];
            o = o[name];
            if (!o) {
                return false;
            }
        }
        return !!o;
    }

    const DARK = new TableTheme(darkTheme, darkTheme);
    const BRIGHT = new TableTheme(brightTheme, brightTheme);
    const ARCO = new TableTheme(arcoTheme, arcoTheme);
    const DEFAULT = new TableTheme(defaultTheme, defaultTheme);
    const SIMPLIFY = new TableTheme(materialDesignTheme, materialDesignTheme);
    const builtin$1 = {
        DEFAULT,
        SIMPLIFY,
        ARCO,
        DARK,
        BRIGHT
    };
    const theme$1 = { TableTheme };
    function of$1(value) {
        if (!value) {
            return null;
        }
        if (typeof value === 'string') {
            const t = getIgnoreCase(get$5(), value);
            if (t) {
                if (t instanceof TableTheme) {
                    return t;
                }
                return new TableTheme(t, t);
            }
            return null;
        }
        if (value instanceof TableTheme) {
            return value;
        }
        return new TableTheme(value, value);
    }
    function get$5() {
        return extend(builtin$1, themes$2);
    }
    var themes = {
        DARK,
        BRIGHT,
        ARCO,
        DEFAULT,
        SIMPLIFY,
        theme: theme$1,
        of: of$1,
        get: get$5
    };

    var themes$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        ARCO: ARCO,
        BRIGHT: BRIGHT,
        DARK: DARK,
        DEFAULT: DEFAULT,
        SIMPLIFY: SIMPLIFY,
        TableTheme: TableTheme,
        default: themes,
        get: get$5,
        of: of$1,
        theme: theme$1
    });

    function getCellMergeInfo(table, col, row) {
        if (table.internalProps.customMergeCell) {
            const customMerge = table.getCustomMerge(col, row);
            if (customMerge) {
                return customMerge.range;
            }
        }
        if (!table.internalProps.enableTreeNodeMerge &&
            !table.isHeader(col, row) &&
            !table.getBodyColumnDefine(col, row)?.mergeCell) {
            return false;
        }
        const range = table.getCellRange(col, row);
        const isMerge = range.start.col !== range.end.col || range.start.row !== range.end.row;
        if (!isMerge) {
            return false;
        }
        return range;
    }

    class Factory {
        static _components = {};
        static _functions = {};
        static _cellTypes = {};
        static registerComponent(key, component) {
            Factory._components[key] = component;
        }
        static getComponent(key) {
            return Factory._components[key];
        }
        static registerFunction(key, func) {
            Factory._functions[key] = func;
        }
        static getFunction(key) {
            return Factory._functions[key];
        }
        static registerCellType(key, cellType) {
            Factory._cellTypes[key] = cellType;
        }
        static getCellType(key) {
            return Factory._cellTypes[key];
        }
    }

    function createArray(get, length) {
        const array = new Array(length);
        for (let i = 0; i < length; i++) {
            array[i] = get(i);
        }
        return array;
    }
    function sort(get, set, length, compare, order, getField) {
        const old = createArray(get, length);
        old.sort((r1, r2) => compare(getField(r1), getField(r2), order));
        for (let i = 0; i < length; i++) {
            set(i, old[i]);
        }
    }

    function isFieldAssessor(field) {
        if (obj.isObject(field)) {
            const a = field;
            if (isValid$3(a.get) && isValid$3(a.set)) {
                return true;
            }
        }
        return false;
    }
    const EVENT_TYPE$1 = {
        SOURCE_LENGTH_UPDATE: 'source_length_update',
        CHANGE_ORDER: 'change_order'
    };
    function getValue$2(value, promiseCallBack) {
        const maybePromiseOrValue = getOrApply(value);
        if (isPromise(maybePromiseOrValue)) {
            const promiseValue = maybePromiseOrValue.then((r) => {
                promiseCallBack(r);
                return r;
            });
            promiseCallBack(promiseValue);
            return promiseValue;
        }
        return maybePromiseOrValue;
    }
    function getField(record, field, col, row, table, promiseCallBack) {
        if (record === null || record === undefined) {
            return undefined;
        }
        if (isPromise(record)) {
            return record.then((r) => getField(r, field, col, row, table, promiseCallBack));
        }
        const fieldGet = isFieldAssessor(field) ? field.get : field;
        if ((fieldGet === undefined || fieldGet === '') && Array.isArray(record)) {
            const colIndex = col - table.leftRowSeriesNumberCount;
            return record[colIndex];
        }
        if (isObject$7(record) && fieldGet in record) {
            const fieldResult = record[fieldGet];
            return getValue$2(fieldResult, promiseCallBack);
        }
        if (typeof fieldGet === 'function') {
            const fieldResult = fieldGet(record, col, row, table);
            return getValue$2(fieldResult, promiseCallBack);
        }
        if (Array.isArray(fieldGet)) {
            const fieldResult = getValueByPath(record, [...fieldGet]);
            return getValue$2(fieldResult, promiseCallBack);
        }
        const fieldArray = `${fieldGet}`.split('.');
        if (fieldArray.length <= 1) {
            const fieldResult = record[fieldGet];
            return getValue$2(fieldResult, promiseCallBack);
        }
        const fieldResult = applyChainSafe(record, (val, name) => getField(val, name, col, row, table, emptyFn), ...fieldArray);
        return getValue$2(fieldResult, promiseCallBack);
    }
    function _getIndex(sortedIndexMap, index) {
        if (!sortedIndexMap) {
            return index;
        }
        const mapIndex = sortedIndexMap[index];
        return isValid$3(mapIndex) ? mapIndex : index;
    }
    class DataSource extends EventTarget$1 {
        dataConfig;
        dataSourceObj;
        _get;
        _sourceLength;
        _source;
        sortedIndexMap;
        lastSortStates;
        currentIndexedData = [];
        userPagination;
        pagination;
        _currentPagerIndexedData;
        hierarchyExpandLevel = 0;
        static get EVENT_TYPE() {
            return EVENT_TYPE$1;
        }
        hasHierarchyStateExpand = false;
        beforeChangedRecordsMap = new Map();
        registedAggregators = {};
        rowHierarchyType = 'grid';
        fieldAggregators = [];
        columns;
        lastFilterRules;
        constructor(dataSourceObj, dataConfig, pagination, columns, rowHierarchyType, hierarchyExpandLevel) {
            super();
            this.registerAggregators();
            this.dataSourceObj = dataSourceObj;
            this.dataConfig = dataConfig;
            this._get = dataSourceObj?.get;
            this.columns = columns;
            this._source = dataSourceObj?.records ? this.processRecords(dataSourceObj?.records) : dataSourceObj;
            this._sourceLength = this._source?.length || 0;
            this.sortedIndexMap = new Map();
            this._currentPagerIndexedData = [];
            this.userPagination = pagination;
            this.pagination = pagination || {
                totalCount: this._sourceLength,
                perPageCount: this._sourceLength,
                currentPage: 0
            };
            if (hierarchyExpandLevel >= 1) {
                this.hierarchyExpandLevel = hierarchyExpandLevel;
            }
            this.currentIndexedData = Array.from({ length: this._sourceLength }, (_, i) => i);
            if (rowHierarchyType === 'tree') {
                this.initTreeHierarchyState();
            }
            this.rowHierarchyType = rowHierarchyType;
            this.updatePagerData();
        }
        initTreeHierarchyState() {
            this.currentIndexedData = Array.from({ length: this._sourceLength }, (_, i) => i);
            let nodeLength = this._sourceLength;
            for (let i = 0; i < nodeLength; i++) {
                const indexKey = this.currentIndexedData[i];
                const nodeData = this.getOriginalRecord(indexKey);
                const children = nodeData.filteredChildren ?? nodeData.children;
                if (children?.length > 0) {
                    if (this.hierarchyExpandLevel > 1) {
                        !nodeData.hierarchyState && (nodeData.hierarchyState = HierarchyState.expand);
                    }
                    else {
                        !nodeData.hierarchyState && (nodeData.hierarchyState = HierarchyState.collapse);
                    }
                    this.hasHierarchyStateExpand = true;
                    if (nodeData.hierarchyState === HierarchyState.collapse) {
                        continue;
                    }
                    const childrenLength = this.initChildrenNodeHierarchy(indexKey, this.hierarchyExpandLevel, 2, nodeData);
                    i += childrenLength;
                    nodeLength += childrenLength;
                }
                else if (nodeData.children === true) {
                    !nodeData.hierarchyState && (nodeData.hierarchyState = HierarchyState.collapse);
                }
            }
        }
        supplementConfig(pagination, columns, rowHierarchyType, hierarchyExpandLevel) {
            this.columns = columns;
            this._sourceLength = this._source?.length || 0;
            this.sortedIndexMap = new Map();
            this._currentPagerIndexedData = [];
            this.userPagination = pagination;
            this.pagination = pagination || {
                totalCount: this._sourceLength,
                perPageCount: this._sourceLength,
                currentPage: 0
            };
            if (hierarchyExpandLevel >= 1) {
                this.hierarchyExpandLevel = hierarchyExpandLevel;
            }
            this.currentIndexedData = Array.from({ length: this._sourceLength }, (_, i) => i);
            if (rowHierarchyType === 'tree') {
                this.initTreeHierarchyState();
            }
            this.rowHierarchyType = rowHierarchyType;
            this.updatePagerData();
        }
        registerAggregator(type, aggregator) {
            this.registedAggregators[type] = aggregator;
        }
        registerAggregators() {
            this.registerAggregator(AggregationType.RECORD, RecordAggregator);
            this.registerAggregator(AggregationType.SUM, SumAggregator);
            this.registerAggregator(AggregationType.COUNT, CountAggregator);
            this.registerAggregator(AggregationType.MAX, MaxAggregator);
            this.registerAggregator(AggregationType.MIN, MinAggregator);
            this.registerAggregator(AggregationType.AVG, AvgAggregator);
            this.registerAggregator(AggregationType.NONE, NoneAggregator);
            this.registerAggregator(AggregationType.CUSTOM, CustomAggregator);
        }
        updateColumns(columns) {
            this.columns = columns;
        }
        _generateFieldAggragations() {
            const columnObjs = this.columns;
            this.fieldAggregators = [];
            const processColumn = column => {
                delete column.vtable_aggregator;
                const field = column.field;
                const aggregation = column.aggregation;
                if (!aggregation) {
                    return;
                }
                if (Array.isArray(aggregation)) {
                    for (const item of aggregation) {
                        const aggregator = new this.registedAggregators[item.aggregationType]({
                            field: field,
                            formatFun: item.formatFun,
                            isRecord: true,
                            aggregationFun: item.aggregationFun
                        });
                        this.fieldAggregators.push(aggregator);
                        if (!column.vtable_aggregator) {
                            column.vtable_aggregator = [];
                        }
                        column.vtable_aggregator.push(aggregator);
                    }
                }
                else {
                    const aggregator = new this.registedAggregators[aggregation.aggregationType]({
                        field: field,
                        formatFun: aggregation.formatFun,
                        isRecord: true,
                        aggregationFun: aggregation.aggregationFun
                    });
                    this.fieldAggregators.push(aggregator);
                    column.vtable_aggregator = aggregator;
                }
            };
            const traverseColumns = columns => {
                if (!columns || columns.length === 0) {
                    return;
                }
                for (const column of columns) {
                    processColumn(column);
                    if (column.columns) {
                        traverseColumns(column.columns);
                    }
                }
            };
            traverseColumns(columnObjs);
        }
        processRecords(records) {
            this._generateFieldAggragations();
            const filteredRecords = [];
            const isHasAggregation = this.fieldAggregators.length >= 1;
            const isHasFilterRule = this.dataConfig?.filterRules?.length >= 1 || this.lastFilterRules?.length >= 1;
            if (isHasFilterRule || isHasAggregation) {
                for (let i = 0, len = records.length; i < len; i++) {
                    const record = records[i];
                    if (this.dataConfig?.filterRules?.length >= 1) {
                        if (this.filterRecord(record)) {
                            filteredRecords.push(record);
                            if (this.rowHierarchyType === 'tree' && record.children) {
                                record.filteredChildren = this.filteredChildren(record.children);
                            }
                            isHasAggregation && this.processRecord(record);
                        }
                    }
                    else if (this.lastFilterRules?.length >= 1) {
                        this.clearFilteredChildren(record);
                        isHasAggregation && this.processRecord(record);
                    }
                    else if (isHasAggregation) {
                        this.processRecord(record);
                    }
                }
                if (this.dataConfig?.filterRules?.length >= 1) {
                    return filteredRecords;
                }
            }
            return records;
        }
        filteredChildren(records) {
            const filteredRecords = [];
            for (let i = 0, len = records.length; i < len; i++) {
                const record = records[i];
                if (this.filterRecord(record)) {
                    filteredRecords.push(record);
                    if (record.children) {
                        record.filteredChildren = this.filteredChildren(record.children);
                    }
                }
            }
            return filteredRecords;
        }
        processRecord(record) {
            for (let i = 0; i < this.fieldAggregators.length; i++) {
                const aggregator = this.fieldAggregators[i];
                aggregator.push(record);
            }
        }
        initChildrenNodeHierarchy(indexKey, hierarchyExpandLevel, currentLevel, nodeData) {
            let childTotalLength = 0;
            const nodeLength = nodeData.filteredChildren ? nodeData.filteredChildren.length : nodeData.children?.length ?? 0;
            for (let j = 0; j < nodeLength; j++) {
                if (currentLevel <= hierarchyExpandLevel || nodeData.hierarchyState === HierarchyState.expand) {
                    childTotalLength += 1;
                }
                const childNodeData = nodeData.filteredChildren ? nodeData.filteredChildren[j] : nodeData.children[j];
                const childIndexKey = Array.isArray(indexKey) ? indexKey.concat(j) : [indexKey, j];
                if (currentLevel <= hierarchyExpandLevel || nodeData.hierarchyState === HierarchyState.expand) {
                    this.currentIndexedData.splice(this.currentIndexedData.indexOf(indexKey) + childTotalLength, 0, childIndexKey);
                }
                if (childNodeData.filteredChildren ? childNodeData.filteredChildren.length > 0 : childNodeData.children?.length > 0) {
                    if (currentLevel < hierarchyExpandLevel || childNodeData.hierarchyState === HierarchyState.expand) {
                        !childNodeData.hierarchyState && (childNodeData.hierarchyState = HierarchyState.expand);
                        this.hasHierarchyStateExpand = true;
                    }
                    else {
                        !childNodeData.hierarchyState && (childNodeData.hierarchyState = HierarchyState.collapse);
                    }
                }
                if (childNodeData.hierarchyState === HierarchyState.expand) {
                    childTotalLength += this.initChildrenNodeHierarchy(childIndexKey, hierarchyExpandLevel, currentLevel + 1, childNodeData);
                }
                if (childNodeData.children === true) {
                    !childNodeData.hierarchyState && (childNodeData.hierarchyState = HierarchyState.collapse);
                }
            }
            return childTotalLength;
        }
        updatePagination(pagination) {
            this.pagination = pagination || {
                totalCount: this._sourceLength,
                perPageCount: this._sourceLength,
                currentPage: 0
            };
            this.updatePagerData();
        }
        updatePagerData() {
            const { currentIndexedData } = this;
            const { perPageCount, currentPage } = this.pagination;
            const startIndex = perPageCount * (currentPage || 0);
            const endIndex = startIndex + perPageCount;
            this._currentPagerIndexedData.length = 0;
            if (currentIndexedData && currentIndexedData.length > 0) {
                let firstLevelIndex = -1;
                for (let i = 0; i < currentIndexedData.length; i++) {
                    if ((Array.isArray(currentIndexedData[i]) && currentIndexedData[i].length === 1) ||
                        !Array.isArray(currentIndexedData[i])) {
                        firstLevelIndex++;
                    }
                    if (firstLevelIndex >= startIndex && firstLevelIndex < endIndex) {
                        this._currentPagerIndexedData.push(currentIndexedData[i]);
                    }
                    else if (firstLevelIndex >= endIndex) {
                        break;
                    }
                }
            }
            else if (this._sourceLength > 0) {
                throw new Error(`currentIndexedData should has values!`);
            }
        }
        getRecordIndexPaths(bodyShowIndex) {
            return this._currentPagerIndexedData[bodyShowIndex];
        }
        get records() {
            return Array.isArray(this._source) ? this._source : [];
        }
        get source() {
            return this._source;
        }
        get(index) {
            return this.getOriginalRecord(_getIndex(this.currentPagerIndexedData, index));
        }
        getRaw(index) {
            return this.getRawRecord(_getIndex(this.currentPagerIndexedData, index));
        }
        getIndexKey(index) {
            return _getIndex(this.currentPagerIndexedData, index);
        }
        getTableIndex(colOrRow) {
            if (Array.isArray(colOrRow)) {
                if (this.rowHierarchyType === 'tree') {
                    return this.currentPagerIndexedData.findIndex(value => arrayEqual(value, colOrRow));
                }
                return this.currentPagerIndexedData.findIndex(value => value === colOrRow[0]);
            }
            return this.currentPagerIndexedData.findIndex(value => value === colOrRow);
        }
        getField(index, field, col, row, table) {
            return this.getOriginalField(_getIndex(this.currentPagerIndexedData, index), field, col, row, table);
        }
        getRawField(index, field, col, row, table) {
            return this.getRawFieldData(_getIndex(this.currentPagerIndexedData, index), field, col, row, table);
        }
        hasField(index, field) {
            return this.hasOriginalField(_getIndex(this.currentPagerIndexedData, index), field);
        }
        getHierarchyState(index) {
            const record = this.getOriginalRecord(this.currentPagerIndexedData[index]);
            if (record?.hierarchyState) {
                const hierarchyState = record.hierarchyState;
                if (record.children?.length > 0 || record.children === true) {
                    return hierarchyState;
                }
            }
            return null;
        }
        toggleHierarchyState(index, bodyStartIndex, bodyEndIndex) {
            const oldIndexedData = this.currentIndexedData.slice(0);
            const indexed = this.getIndexKey(index);
            const state = this.getHierarchyState(index);
            const data = this.getOriginalRecord(indexed);
            this.clearSortedIndexMap();
            if (state === HierarchyState.collapse) {
                data.hierarchyState = HierarchyState.expand;
                this.pushChildrenNode(indexed, HierarchyState.expand, data);
                this.hasHierarchyStateExpand = true;
            }
            else if (state === HierarchyState.expand) {
                let childrenLength = 0;
                const computeChildrenNodeLength = (indexKey, hierarchyState, nodeData) => {
                    if (!hierarchyState || hierarchyState === HierarchyState.collapse || hierarchyState === HierarchyState.none) {
                        return;
                    }
                    const children = nodeData.filteredChildren ? nodeData.filteredChildren : nodeData.children;
                    if (children) {
                        for (let i = 0; i < children.length; i++) {
                            childrenLength += 1;
                            const childIndex = Array.isArray(indexKey) ? indexKey.concat([i]) : [indexKey, i];
                            computeChildrenNodeLength(childIndex, children[i].hierarchyState, children[i]);
                        }
                    }
                };
                computeChildrenNodeLength(indexed, state, data);
                this.currentIndexedData.splice(this.currentIndexedData.indexOf(indexed) + 1, childrenLength);
                data.hierarchyState = HierarchyState.collapse;
            }
            this.updatePagerData();
            const add = [];
            const remove = [];
            if (state === HierarchyState.collapse) {
                const addLength = this.currentIndexedData.length - oldIndexedData.length;
                for (let i = 0; i < addLength; i++) {
                    add.push(index + i + 1);
                }
            }
            else if (state === HierarchyState.expand) {
                const removeLength = oldIndexedData.length - this.currentIndexedData.length;
                for (let i = 0; i < removeLength; i++) {
                    remove.push(index + i + 1);
                }
            }
            return { add, remove };
        }
        pushChildrenNode(indexKey, hierarchyState, nodeData) {
            if (!hierarchyState || hierarchyState === HierarchyState.collapse || hierarchyState === HierarchyState.none) {
                return 0;
            }
            let childrenLength = 0;
            const children = nodeData.filteredChildren ? nodeData.filteredChildren : nodeData.children;
            if (children) {
                const subNodeSortedIndexArray = Array.from({ length: children.length }, (_, i) => i);
                this.lastSortStates?.forEach(state => {
                    if (state.order !== 'normal') {
                        sort(index => isValid$3(subNodeSortedIndexArray[index])
                            ? subNodeSortedIndexArray[index]
                            : (subNodeSortedIndexArray[index] = index), (index, rel) => {
                            subNodeSortedIndexArray[index] = rel;
                        }, children.length, state.orderFn, state.order, index => this.getOriginalField(Array.isArray(indexKey) ? indexKey.concat([index]) : [indexKey, index], state.field));
                    }
                });
                for (let i = 0; i < subNodeSortedIndexArray.length; i++) {
                    childrenLength += 1;
                    const childIndex = Array.isArray(indexKey)
                        ? indexKey.concat([subNodeSortedIndexArray[i]])
                        : [indexKey, subNodeSortedIndexArray[i]];
                    this.currentIndexedData.splice(this.currentIndexedData.indexOf(indexKey) + childrenLength, 0, childIndex);
                    const childData = this.getOriginalRecord(childIndex);
                    if (!childData.hierarchyState && (childData.filteredChildren ?? childData.children)) {
                        childData.hierarchyState = HierarchyState.collapse;
                    }
                    childrenLength += this.pushChildrenNode(childIndex, childData.hierarchyState, children[subNodeSortedIndexArray[i]]);
                }
            }
            return childrenLength;
        }
        changeFieldValue(value, index, field, col, row, table) {
            if (field === null) {
                return undefined;
            }
            if (index >= 0) {
                const dataIndex = this.getIndexKey(index);
                this.cacheBeforeChangedRecord(dataIndex, table);
                if (field === undefined || field === '') {
                    field = col - table.leftRowSeriesNumberCount;
                }
                if (typeof field === 'string' || typeof field === 'number') {
                    const beforeChangedValue = this.beforeChangedRecordsMap.get(dataIndex.toString())?.[field];
                    const record = this.getOriginalRecord(dataIndex);
                    let formatValue = value;
                    if (typeof beforeChangedValue === 'number' && isAllDigits(value)) {
                        formatValue = parseFloat(value);
                    }
                    if (isPromise(record)) {
                        record
                            .then(record => {
                            record[field] = formatValue;
                        })
                            .catch((err) => {
                        });
                    }
                    else {
                        if (record) {
                            record[field] = formatValue;
                        }
                        else {
                            this.records[dataIndex] = {};
                            this.records[dataIndex][field] = formatValue;
                        }
                    }
                }
            }
        }
        cacheBeforeChangedRecord(dataIndex, table) {
            if (!this.beforeChangedRecordsMap.has(dataIndex.toString())) {
                const originRecord = this.getOriginalRecord(dataIndex);
                this.beforeChangedRecordsMap.set(dataIndex.toString(), cloneDeep$1(originRecord, undefined, ['vtable_gantt_linkedFrom', 'vtable_gantt_linkedTo']) ?? {});
            }
        }
        setRecord(record, index) {
            let isAdd = true;
            if (this.dataConfig?.filterRules?.length >= 1) {
                if (this.filterRecord(record)) {
                    if (this.rowHierarchyType === 'tree' && record.children) {
                        record.filteredChildren = this.filteredChildren(record.children);
                    }
                }
                else {
                    isAdd = false;
                }
            }
            if (isAdd && Array.isArray(this.records)) {
                const indexed = this.getIndexKey(index);
                if (!Array.isArray(indexed)) {
                    this.records.splice(indexed, 1, record);
                }
            }
        }
        addRecord(record, index) {
            if (Array.isArray(this.records)) {
                this.records.splice(index, 0, record);
                this.adjustBeforeChangedRecordsMap(index, 1);
                this.currentIndexedData.push(this.currentIndexedData.length);
                this._sourceLength += 1;
                for (let i = 0; i < this.fieldAggregators.length; i++) {
                    this.fieldAggregators[i].push(record);
                }
                if (this.rowHierarchyType === 'tree') {
                    this.initTreeHierarchyState();
                }
                if (this.userPagination) {
                    this.pagination.totalCount = this._sourceLength;
                    const { perPageCount, currentPage } = this.pagination;
                    const startIndex = perPageCount * (currentPage || 0);
                    const endIndex = startIndex + perPageCount;
                    if (index < endIndex) {
                        this.updatePagerData();
                    }
                }
                else {
                    this.pagination.perPageCount = this._sourceLength;
                    this.pagination.totalCount = this._sourceLength;
                    this.updatePagerData();
                }
                if (this.dataSourceObj?.added) {
                    this.dataSourceObj.added(index, 1);
                }
            }
        }
        addRecords(recordArr, index) {
            if (Array.isArray(this.records)) {
                if (Array.isArray(recordArr)) {
                    this.records.splice(index, 0, ...recordArr);
                    this.adjustBeforeChangedRecordsMap(index, recordArr.length);
                    for (let i = 0; i < recordArr.length; i++) {
                        this.currentIndexedData.push(this.currentIndexedData.length);
                    }
                    this._sourceLength += recordArr.length;
                    for (let i = 0; i < this.fieldAggregators.length; i++) {
                        for (let j = 0; j < recordArr.length; j++) {
                            this.fieldAggregators[i].push(recordArr[j]);
                        }
                    }
                }
                if (this.userPagination) {
                    this.pagination.totalCount = this._sourceLength;
                    const { perPageCount, currentPage } = this.pagination;
                    const startIndex = perPageCount * (currentPage || 0);
                    const endIndex = startIndex + perPageCount;
                    if (index < endIndex) {
                        this.updatePagerData();
                    }
                }
                else {
                    this.pagination.perPageCount = this._sourceLength;
                    this.pagination.totalCount = this._sourceLength;
                    this.updatePagerData();
                }
                if (this.dataSourceObj?.added) {
                    this.dataSourceObj.added(index, recordArr.length);
                }
            }
        }
        addRecordForSorted(record) {
            if (Array.isArray(this.records)) {
                this.beforeChangedRecordsMap.clear();
                this.records.push(record);
                this.currentIndexedData.push(this.currentIndexedData.length);
                this._sourceLength += 1;
                this.sortedIndexMap.clear();
                if (!this.userPagination) {
                    this.pagination.perPageCount = this._sourceLength;
                    this.pagination.totalCount = this._sourceLength;
                }
            }
        }
        addRecordsForSorted(recordArr) {
            if (Array.isArray(this.records)) {
                this.beforeChangedRecordsMap.clear();
                if (Array.isArray(recordArr)) {
                    this.records.push(...recordArr);
                    for (let i = 0; i < recordArr.length; i++) {
                        this.currentIndexedData.push(this.currentIndexedData.length);
                    }
                    this._sourceLength += recordArr.length;
                    this.sortedIndexMap.clear();
                }
                if (!this.userPagination) {
                    this.pagination.perPageCount = this._sourceLength;
                    this.pagination.totalCount = this._sourceLength;
                }
            }
        }
        adjustBeforeChangedRecordsMap(insertIndex, insertCount, type = 'add') {
            const length = this.beforeChangedRecordsMap.size;
            for (let key = length - 1; key >= insertIndex; key--) {
                const record = this.beforeChangedRecordsMap.get(key.toString());
                this.beforeChangedRecordsMap.delete(key.toString());
                this.beforeChangedRecordsMap.set((key + (type === 'add' ? insertCount : -insertCount)).toString(), record);
            }
        }
        deleteRecords(recordIndexs) {
            if (Array.isArray(this.records)) {
                const realDeletedRecordIndexs = [];
                const recordIndexsMaxToMin = recordIndexs.sort((a, b) => b - a);
                for (let index = 0; index < recordIndexsMaxToMin.length; index++) {
                    const recordIndex = recordIndexsMaxToMin[index];
                    if (recordIndex >= this._sourceLength || recordIndex < 0) {
                        continue;
                    }
                    this.adjustBeforeChangedRecordsMap(recordIndex, 1, 'delete');
                    realDeletedRecordIndexs.push(recordIndex);
                    const deletedRecord = this.records[recordIndex];
                    for (let i = 0; i < this.fieldAggregators.length; i++) {
                        this.fieldAggregators[i].deleteRecord(deletedRecord);
                    }
                    this.records.splice(recordIndex, 1);
                    this.currentIndexedData.pop();
                    this._sourceLength -= 1;
                }
                if (this.userPagination) {
                    this.updatePagerData();
                }
                else {
                    this.pagination.perPageCount = this._sourceLength;
                    this.pagination.totalCount = this._sourceLength;
                    this.updatePagerData();
                }
                if (this.dataSourceObj?.deleted) {
                    this.dataSourceObj.deleted(realDeletedRecordIndexs);
                }
                return realDeletedRecordIndexs;
            }
            return [];
        }
        deleteRecordsForSorted(recordIndexs) {
            if (Array.isArray(this.records)) {
                const recordIndexsMaxToMin = recordIndexs.sort((a, b) => b - a);
                for (let index = 0; index < recordIndexsMaxToMin.length; index++) {
                    const recordIndex = recordIndexsMaxToMin[index];
                    if (recordIndex >= this._sourceLength || recordIndex < 0) {
                        continue;
                    }
                    const rawIndex = this.currentIndexedData[recordIndex];
                    this.records.splice(rawIndex, 1);
                    this._sourceLength -= 1;
                }
                this.sortedIndexMap.clear();
                if (!this.userPagination) {
                    this.pagination.perPageCount = this._sourceLength;
                    this.pagination.totalCount = this._sourceLength;
                }
                this.beforeChangedRecordsMap.clear();
            }
        }
        updateRecords(records, recordIndexs) {
            const realDeletedRecordIndexs = [];
            for (let index = 0; index < recordIndexs.length; index++) {
                const recordIndex = recordIndexs[index];
                if (Array.isArray(recordIndex)) {
                    this.beforeChangedRecordsMap.delete(recordIndex.toString());
                    realDeletedRecordIndexs.push(recordIndex);
                    recordIndex.slice(0, -1).reduce((acc, key) => {
                        if (acc[key] === undefined) {
                            acc[key] = {};
                        }
                        return acc[key].children;
                    }, this.records)[recordIndex[recordIndex.length - 1]] = records[index];
                }
                else {
                    if (recordIndex >= this._sourceLength || recordIndex < 0) {
                        continue;
                    }
                    this.beforeChangedRecordsMap.delete(recordIndex.toString());
                    realDeletedRecordIndexs.push(recordIndex);
                    for (let i = 0; i < this.fieldAggregators.length; i++) {
                        this.fieldAggregators[i].updateRecord(this.records[recordIndex], records[index]);
                    }
                    this.records[recordIndex] = records[index];
                }
            }
            if (this.userPagination) {
                this.updatePagerData();
            }
            return realDeletedRecordIndexs;
        }
        updateRecordsForSorted(records, recordIndexs) {
            for (let index = 0; index < recordIndexs.length; index++) {
                const recordIndex = recordIndexs[index];
                if (recordIndex >= this._sourceLength || recordIndex < 0) {
                    continue;
                }
                const rawIndex = this.currentIndexedData[recordIndex];
                if (typeof rawIndex !== 'number') {
                    return;
                }
                this.beforeChangedRecordsMap.delete(rawIndex.toString());
                this.records[rawIndex] = records[index];
            }
            this.sortedIndexMap.clear();
        }
        sort(states) {
            states = (Array.isArray(states) ? states : [states]).filter(state => {
                const column = this.columns.find(obj => obj.field === state.field);
                return column?.sort !== false && state.order !== 'normal';
            });
            this.lastSortStates = states;
            let filedMapArray = states.map(state => this.sortedIndexMap.get(state?.field) || { asc: [], desc: [], normal: [] });
            let orderedData = null;
            if (filedMapArray.length > 0) {
                orderedData = states.reduce((data, state, index) => {
                    const currentData = filedMapArray[index]?.[state.order];
                    return currentData && currentData.length > 0 ? currentData : data;
                }, null);
                if (orderedData && orderedData.length > 0) {
                    this.currentIndexedData = orderedData;
                    this.updatePagerData();
                    this.fireListeners(EVENT_TYPE$1.CHANGE_ORDER, null);
                    return;
                }
            }
            const sortedIndexArray = Array.from({ length: this._sourceLength }, (_, i) => i);
            sortedIndexArray.sort((indexA, indexB) => {
                return states.reduce((result, state) => {
                    if (result !== 0) {
                        return result;
                    }
                    const orderFn = state.orderFn ||
                        (state.order !== 'desc'
                            ? (v1, v2) => (v1 === v2 ? 0 : v1 > v2 ? 1 : -1)
                            : (v1, v2) => (v1 === v2 ? 0 : v1 < v2 ? 1 : -1));
                    return orderFn(this.getOriginalField(indexA, state.field), this.getOriginalField(indexB, state.field), state.order);
                }, 0);
            });
            this.currentIndexedData = sortedIndexArray;
            if (this.hierarchyExpandLevel) {
                let nodeLength = sortedIndexArray.length;
                for (let i = 0; i < nodeLength; i++) {
                    const record = this.getOriginalRecord(sortedIndexArray[i]);
                    const subNodeLength = this.pushChildrenNode(sortedIndexArray[i], record.hierarchyState, this.getOriginalRecord(sortedIndexArray[i]));
                    nodeLength += subNodeLength;
                    i += subNodeLength;
                }
            }
            if (!filedMapArray.length) {
                filedMapArray = states.map(() => ({ asc: [], desc: [], normal: [] }));
                for (let index = 0; index < states.length; index++) {
                    this.sortedIndexMap.set(states[index].field, filedMapArray[index]);
                }
            }
            states.forEach((state, index) => {
                const mapItem = filedMapArray[index];
                mapItem[state.order] = sortedIndexArray.slice();
            });
            this.updatePagerData();
            this.fireListeners(EVENT_TYPE$1.CHANGE_ORDER, null);
        }
        setSortedIndexMap(field, filedMap) {
            this.sortedIndexMap.set(field, filedMap);
        }
        clearFilteredChildren(record) {
            record.filteredChildren = undefined;
            for (let i = 0; i < (record.children?.length ?? 0); i++) {
                this.clearFilteredChildren(record.children[i]);
            }
        }
        filterRecord(record) {
            let isReserved = true;
            for (let i = 0; i < this.dataConfig.filterRules?.length; i++) {
                const filterRule = this.dataConfig?.filterRules[i];
                if (filterRule.filterKey) {
                    const filterValue = record[filterRule.filterKey];
                    if (filterRule.filteredValues.indexOf(filterValue) === -1) {
                        isReserved = false;
                        break;
                    }
                }
                else if (!filterRule.filterFunc?.(record)) {
                    isReserved = false;
                    break;
                }
            }
            return isReserved;
        }
        updateFilterRulesForSorted(filterRules) {
            this.lastFilterRules = this.dataConfig.filterRules;
            this.dataConfig.filterRules = filterRules;
            this._source = this.processRecords(this.dataSourceObj?.records ?? this.dataSourceObj);
            this._sourceLength = this._source?.length || 0;
            this.sortedIndexMap.clear();
            this.currentIndexedData = Array.from({ length: this._sourceLength }, (_, i) => i);
            if (!this.userPagination) {
                this.pagination.perPageCount = this._sourceLength;
                this.pagination.totalCount = this._sourceLength;
            }
        }
        updateFilterRules(filterRules) {
            this.lastFilterRules = this.dataConfig.filterRules;
            this.dataConfig.filterRules = filterRules;
            this._source = this.processRecords(this.dataSourceObj?.records ?? this.dataSourceObj);
            this._sourceLength = this._source?.length || 0;
            this.currentIndexedData = Array.from({ length: this._sourceLength }, (_, i) => i);
            if (this.userPagination) {
                this.updatePagerData();
            }
            else {
                this.pagination.perPageCount = this._sourceLength;
                this.pagination.totalCount = this._sourceLength;
                if (this.rowHierarchyType === 'tree') {
                    this.initTreeHierarchyState();
                }
                this.updatePagerData();
            }
        }
        clearSortedIndexMap() {
            if (this.lastSortStates && this.lastSortStates.length > 0) {
                this.sortedIndexMap.forEach((sortMap, key) => {
                    const isFieldInRules = this.lastSortStates.some(state => state.field === key);
                    if (!isFieldInRules) {
                        this.sortedIndexMap.delete(key);
                    }
                    else {
                        this.lastSortStates.forEach(state => {
                            if (state.order === 'asc') {
                                sortMap.desc = [];
                                sortMap.normal = [];
                            }
                            else if (state.order === 'desc') {
                                sortMap.asc = [];
                                sortMap.normal = [];
                            }
                            else {
                                sortMap.asc = [];
                                sortMap.desc = [];
                            }
                        });
                    }
                });
            }
        }
        get sourceLength() {
            return this._sourceLength;
        }
        set sourceLength(sourceLen) {
            if (this._sourceLength === sourceLen) {
                return;
            }
            this._sourceLength = sourceLen;
            this.fireListeners(EVENT_TYPE$1.SOURCE_LENGTH_UPDATE, this._sourceLength);
        }
        get length() {
            return this.currentPagerIndexedData.length;
        }
        get dataSource() {
            return this;
        }
        get currentPagerIndexedData() {
            if (this._currentPagerIndexedData.length > 0) {
                return this._currentPagerIndexedData;
            }
            return [];
        }
        release() {
            super.release?.();
            this.lastFilterRules = null;
            this.clearSortedMap();
            this.clearCurrentIndexedData();
            this.currentPagerIndexedData.length = 0;
        }
        clearSortedMap() {
            this.currentIndexedData && (this.currentIndexedData.length = 0);
            this.currentIndexedData = null;
            this.sortedIndexMap.forEach(item => {
                item.asc && (item.asc.length = 0);
                item.desc && (item.desc.length = 0);
            });
            this.sortedIndexMap.clear();
        }
        clearCurrentIndexedData() {
            this.currentIndexedData = null;
            this.currentPagerIndexedData.length = 0;
        }
        getOriginalRecord(dataIndex) {
            let data;
            if (!this.dataSourceObj.records) {
                data = this._get(dataIndex);
            }
            else {
                if (Array.isArray(dataIndex)) {
                    data = getValueFromDeepArray(this.records, dataIndex);
                }
                else {
                    data = this.records[dataIndex];
                }
            }
            return getValue$2(data, (val) => {
                this.recordPromiseCallBack(dataIndex, val);
            });
        }
        getRawRecord(dataIndex) {
            if (this.beforeChangedRecordsMap?.has(dataIndex.toString())) {
                return this.beforeChangedRecordsMap?.get(dataIndex.toString());
            }
            let data;
            if (!this.dataSourceObj.records) {
                data = this._get(dataIndex);
            }
            else {
                if (Array.isArray(dataIndex)) {
                    data = getValueFromDeepArray(this.records, dataIndex);
                }
                else {
                    data = this.records[dataIndex];
                }
            }
            return getValue$2(data, (val) => {
                this.recordPromiseCallBack(dataIndex, val);
            });
        }
        getOriginalField(index, field, col, row, table) {
            if (field === null) {
                return undefined;
            }
            const record = this.getOriginalRecord(index);
            return getField(record, field, col, row, table, (val) => {
                this.fieldPromiseCallBack(index, field, val);
            });
        }
        getRawFieldData(index, field, col, row, table) {
            if (field === null) {
                return undefined;
            }
            const record = this.getRawRecord(index);
            return getField(record, field, col, row, table, (val) => {
                this.fieldPromiseCallBack(index, field, val);
            });
        }
        hasOriginalField(index, field) {
            if (field === null) {
                return false;
            }
            if (typeof field === 'function') {
                return true;
            }
            const record = this.getOriginalRecord(index);
            return Boolean(record && field in record);
        }
        fieldPromiseCallBack(_index, _field, _value) {
        }
        recordPromiseCallBack(_index, _record) {
        }
        static EMPTY = new DataSource({
            get() {
            },
            length: 0
        });
        canChangeOrder(sourceIndex, targetIndex) {
            if ((this.dataSourceObj?.canChangeOrder)) {
                return this.dataSourceObj.canChangeOrder(sourceIndex, targetIndex);
            }
            if (this.hasHierarchyStateExpand) {
                let sourceIndexs = this.currentPagerIndexedData[sourceIndex];
                let targetIndexs = this.currentPagerIndexedData[targetIndex];
                if (Array.isArray(sourceIndexs)) {
                    sourceIndexs = [...sourceIndexs];
                }
                else {
                    sourceIndexs = [sourceIndexs];
                }
                if (Array.isArray(targetIndexs)) {
                    targetIndexs = [...targetIndexs];
                }
                else {
                    targetIndexs = [targetIndexs];
                }
                if (targetIndex > sourceIndex) {
                    if (targetIndexs.length > sourceIndexs.length) {
                        let targetNextIndexs = this.currentPagerIndexedData[targetIndex + 1];
                        if (Array.isArray(targetNextIndexs)) {
                            targetNextIndexs = [...targetNextIndexs];
                        }
                        else {
                            targetNextIndexs = [targetNextIndexs];
                        }
                        if (targetNextIndexs.length < targetIndexs.length) {
                            targetIndexs.splice(targetIndexs.length - 1, 1);
                        }
                    }
                }
                if (sourceIndexs.length === targetIndexs.length) {
                    for (let i = 0; i <= sourceIndexs.length - 2; i++) {
                        if (sourceIndexs[i] !== targetIndexs[i]) {
                            return false;
                        }
                    }
                    return true;
                }
                return false;
            }
            return true;
        }
        changeOrder(sourceIndex, targetIndex) {
            if ((this.dataSourceObj?.changeOrder)) {
                this.dataSourceObj.changeOrder(sourceIndex, targetIndex);
                return;
            }
            if (this.lastSortStates?.some(state => state.order === 'asc' || state.order === 'desc')) {
                return;
            }
            else if (this.canChangeOrder(sourceIndex, targetIndex)) {
                if (this.hasHierarchyStateExpand) {
                    let sourceIndexs = this.currentPagerIndexedData[sourceIndex];
                    let targetIndexs = this.currentPagerIndexedData[targetIndex];
                    if (Array.isArray(sourceIndexs)) {
                        sourceIndexs = [...sourceIndexs];
                    }
                    else {
                        sourceIndexs = [sourceIndexs];
                    }
                    if (Array.isArray(targetIndexs)) {
                        targetIndexs = [...targetIndexs];
                    }
                    else {
                        targetIndexs = [targetIndexs];
                    }
                    let sourceI;
                    let targetI;
                    if (sourceIndexs.length > 1 || targetIndexs.length > 1) {
                        if (targetIndex > sourceIndex) {
                            if (targetIndexs.length > sourceIndexs.length) {
                                let targetNextIndexs = this.currentPagerIndexedData[targetIndex + 1];
                                if (Array.isArray(targetNextIndexs)) {
                                    targetNextIndexs = [...targetNextIndexs];
                                }
                                else {
                                    targetNextIndexs = [targetNextIndexs];
                                }
                                if (targetNextIndexs.length < targetIndexs.length) {
                                    targetIndexs.splice(targetIndexs.length - 1, 1);
                                }
                            }
                        }
                        sourceI = sourceIndexs.splice(sourceIndexs.length - 1, 1)[0];
                        targetI = targetIndexs.splice(targetIndexs.length - 1, 1)[0];
                        if (sourceIndexs.length >= 1) {
                            const parent = this.getOriginalRecord(sourceIndexs);
                            const sourceIds = parent.filteredChildren
                                ? parent.filteredChildren.splice(sourceI, 1)
                                : parent.children.splice(sourceI, 1);
                            sourceIds.unshift(targetI, 0);
                            Array.prototype.splice.apply(parent.filteredChildren ?? parent.children, sourceIds);
                        }
                        else {
                            const sourceIds = this.records.splice(sourceI, 1);
                            sourceIds.unshift(targetI, 0);
                            Array.prototype.splice.apply(this.records, sourceIds);
                        }
                    }
                    else {
                        sourceI = this.currentPagerIndexedData[sourceIndex];
                        targetI = this.currentPagerIndexedData[targetIndex];
                        const records = this.records.splice(sourceI, 1);
                        records.unshift(targetI, 0);
                        Array.prototype.splice.apply(this.records, records);
                    }
                    this.restoreTreeHierarchyState();
                    this.updatePagerData();
                }
                else {
                    const records = this.records.splice(sourceIndex, 1);
                    records.unshift(targetIndex, 0);
                    Array.prototype.splice.apply(this.records, records);
                }
            }
        }
        restoreTreeHierarchyState() {
            if (this.hierarchyExpandLevel) {
                for (let i = 0; i < this._sourceLength; i++) {
                    const nodeData = this.getOriginalRecord(i);
                    const children = nodeData.filteredChildren ?? nodeData.children;
                    children && !nodeData.hierarchyState && (nodeData.hierarchyState = HierarchyState.collapse);
                }
                this.currentIndexedData = Array.from({ length: this._sourceLength }, (_, i) => i);
                let nodeLength = this._sourceLength;
                for (let i = 0; i < nodeLength; i++) {
                    const indexKey = this.currentIndexedData[i];
                    const nodeData = this.getOriginalRecord(indexKey);
                    const children = nodeData.filteredChildren ?? nodeData.children;
                    if (children?.length > 0 && nodeData.hierarchyState === HierarchyState.expand) {
                        this.hasHierarchyStateExpand = true;
                        const childrenLength = this.restoreChildrenNodeHierarchy(indexKey, nodeData);
                        i += childrenLength;
                        nodeLength += childrenLength;
                    }
                    else if (nodeData.children === true) {
                        !nodeData.hierarchyState && (nodeData.hierarchyState = HierarchyState.collapse);
                    }
                }
            }
        }
        restoreChildrenNodeHierarchy(indexKey, nodeData) {
            let childTotalLength = 0;
            const children = nodeData.filteredChildren ?? nodeData.children;
            const nodeLength = children?.length ?? 0;
            for (let j = 0; j < nodeLength; j++) {
                if (nodeData.hierarchyState === HierarchyState.expand) {
                    childTotalLength += 1;
                }
                const childNodeData = children[j];
                const childIndexKey = Array.isArray(indexKey) ? indexKey.concat(j) : [indexKey, j];
                if (nodeData.hierarchyState === HierarchyState.expand) {
                    this.currentIndexedData.splice(this.currentIndexedData.indexOf(indexKey) + childTotalLength, 0, childIndexKey);
                }
                childTotalLength += this.restoreChildrenNodeHierarchy(childIndexKey, childNodeData);
            }
            return childTotalLength;
        }
    }
    function getValueFromDeepArray(array, index) {
        let result = array;
        for (let i = 0; i < index.length; i++) {
            const currentIdx = index[i];
            if (result[currentIdx]) {
                result = result[currentIdx];
            }
            else {
                return undefined;
            }
            const children = result.filteredChildren ?? result?.children;
            if (children && i + 1 < index.length) {
                result = children;
            }
        }
        return result;
    }
    function sortRecordIndexs(recordIndexs, sort) {
        const result = recordIndexs.sort((a, b) => {
            if (isNumber$4(a)) {
                a = [a];
            }
            if (isNumber$4(b)) {
                b = [b];
            }
            const length = Math.max(a.length, b.length);
            for (let i = 0; i < length; i++) {
                const aa = a[i] ?? -1;
                const bb = b[i] ?? -1;
                if (aa !== bb) {
                    return sort === 1 ? aa - bb : bb - aa;
                }
            }
            return 0;
        });
        return result;
    }

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */
    var isArray$5 = Array.isArray;
    var isArray_1 = isArray$5;

    /** Detect free variable `global` from Node.js. */
    var freeGlobal$1 = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
    var _freeGlobal = freeGlobal$1;

    var freeGlobal = _freeGlobal;

    /** Detect free variable `self`. */
    var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

    /** Used as a reference to the global object. */
    var root$3 = freeGlobal || freeSelf || Function('return this')();
    var _root = root$3;

    var root$2 = _root;

    /** Built-in value references. */
    var Symbol$4 = root$2.Symbol;
    var _Symbol = Symbol$4;

    var Symbol$3 = _Symbol;

    /** Used for built-in method references. */
    var objectProto$4 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$3 = objectProto$4.hasOwnProperty;

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString$1 = objectProto$4.toString;

    /** Built-in value references. */
    var symToStringTag$1 = Symbol$3 ? Symbol$3.toStringTag : undefined;

    /**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */
    function getRawTag$1(value) {
      var isOwn = hasOwnProperty$3.call(value, symToStringTag$1),
        tag = value[symToStringTag$1];
      try {
        value[symToStringTag$1] = undefined;
        var unmasked = true;
      } catch (e) {}
      var result = nativeObjectToString$1.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag$1] = tag;
        } else {
          delete value[symToStringTag$1];
        }
      }
      return result;
    }
    var _getRawTag = getRawTag$1;

    /** Used for built-in method references. */
    var objectProto$3 = Object.prototype;

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString = objectProto$3.toString;

    /**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */
    function objectToString$1(value) {
      return nativeObjectToString.call(value);
    }
    var _objectToString = objectToString$1;

    var Symbol$2 = _Symbol,
      getRawTag = _getRawTag,
      objectToString = _objectToString;

    /** `Object#toString` result references. */
    var nullTag = '[object Null]',
      undefinedTag = '[object Undefined]';

    /** Built-in value references. */
    var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : undefined;

    /**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    function baseGetTag$2(value) {
      if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    var _baseGetTag = baseGetTag$2;

    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike$3(value) {
      return value != null && typeof value == 'object';
    }
    var isObjectLike_1 = isObjectLike$3;

    var baseGetTag$1 = _baseGetTag,
      isObjectLike$2 = isObjectLike_1;

    /** `Object#toString` result references. */
    var symbolTag = '[object Symbol]';

    /**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */
    function isSymbol$3(value) {
      return typeof value == 'symbol' || isObjectLike$2(value) && baseGetTag$1(value) == symbolTag;
    }
    var isSymbol_1 = isSymbol$3;

    var isArray$4 = isArray_1,
      isSymbol$2 = isSymbol_1;

    /** Used to match property names within property paths. */
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/;

    /**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */
    function isKey$1(value, object) {
      if (isArray$4(value)) {
        return false;
      }
      var type = typeof value;
      if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol$2(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    var _isKey = isKey$1;

    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject$2(value) {
      var type = typeof value;
      return value != null && (type == 'object' || type == 'function');
    }
    var isObject_1 = isObject$2;

    var baseGetTag = _baseGetTag,
      isObject$1 = isObject_1;

    /** `Object#toString` result references. */
    var asyncTag = '[object AsyncFunction]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      proxyTag = '[object Proxy]';

    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction$3(value) {
      if (!isObject$1(value)) {
        return false;
      }
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 9 which returns 'object' for typed arrays and other constructors.
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    var isFunction_1 = isFunction$3;

    var root$1 = _root;

    /** Used to detect overreaching core-js shims. */
    var coreJsData$1 = root$1['__core-js_shared__'];
    var _coreJsData = coreJsData$1;

    var coreJsData = _coreJsData;

    /** Used to detect methods masquerading as native. */
    var maskSrcKey = function () {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
      return uid ? 'Symbol(src)_1.' + uid : '';
    }();

    /**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */
    function isMasked$1(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    var _isMasked = isMasked$1;

    /** Used for built-in method references. */
    var funcProto$1 = Function.prototype;

    /** Used to resolve the decompiled source of functions. */
    var funcToString$1 = funcProto$1.toString;

    /**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to convert.
     * @returns {string} Returns the source code.
     */
    function toSource$1(func) {
      if (func != null) {
        try {
          return funcToString$1.call(func);
        } catch (e) {}
        try {
          return func + '';
        } catch (e) {}
      }
      return '';
    }
    var _toSource = toSource$1;

    var isFunction$2 = isFunction_1,
      isMasked = _isMasked,
      isObject = isObject_1,
      toSource = _toSource;

    /**
     * Used to match `RegExp`
     * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
     */
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

    /** Used to detect host constructors (Safari). */
    var reIsHostCtor = /^\[object .+?Constructor\]$/;

    /** Used for built-in method references. */
    var funcProto = Function.prototype,
      objectProto$2 = Object.prototype;

    /** Used to resolve the decompiled source of functions. */
    var funcToString = funcProto.toString;

    /** Used to check objects for own properties. */
    var hasOwnProperty$2 = objectProto$2.hasOwnProperty;

    /** Used to detect if a method is native. */
    var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty$2).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');

    /**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */
    function baseIsNative$1(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction$2(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    var _baseIsNative = baseIsNative$1;

    /**
     * Gets the value at `key` of `object`.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */
    function getValue$1(object, key) {
      return object == null ? undefined : object[key];
    }
    var _getValue = getValue$1;

    var baseIsNative = _baseIsNative,
      getValue = _getValue;

    /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */
    function getNative$2(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : undefined;
    }
    var _getNative = getNative$2;

    var getNative$1 = _getNative;

    /* Built-in method references that are verified to be native. */
    var nativeCreate$4 = getNative$1(Object, 'create');
    var _nativeCreate = nativeCreate$4;

    var nativeCreate$3 = _nativeCreate;

    /**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */
    function hashClear$1() {
      this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {};
      this.size = 0;
    }
    var _hashClear = hashClear$1;

    /**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function hashDelete$1(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    var _hashDelete = hashDelete$1;

    var nativeCreate$2 = _nativeCreate;

    /** Used to stand-in for `undefined` hash values. */
    var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

    /** Used for built-in method references. */
    var objectProto$1 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$1 = objectProto$1.hasOwnProperty;

    /**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function hashGet$1(key) {
      var data = this.__data__;
      if (nativeCreate$2) {
        var result = data[key];
        return result === HASH_UNDEFINED$1 ? undefined : result;
      }
      return hasOwnProperty$1.call(data, key) ? data[key] : undefined;
    }
    var _hashGet = hashGet$1;

    var nativeCreate$1 = _nativeCreate;

    /** Used for built-in method references. */
    var objectProto = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function hashHas$1(key) {
      var data = this.__data__;
      return nativeCreate$1 ? data[key] !== undefined : hasOwnProperty.call(data, key);
    }
    var _hashHas = hashHas$1;

    var nativeCreate = _nativeCreate;

    /** Used to stand-in for `undefined` hash values. */
    var HASH_UNDEFINED = '__lodash_hash_undefined__';

    /**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */
    function hashSet$1(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
      return this;
    }
    var _hashSet = hashSet$1;

    var hashClear = _hashClear,
      hashDelete = _hashDelete,
      hashGet = _hashGet,
      hashHas = _hashHas,
      hashSet = _hashSet;

    /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Hash$1(entries) {
      var index = -1,
        length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    // Add methods to `Hash`.
    Hash$1.prototype.clear = hashClear;
    Hash$1.prototype['delete'] = hashDelete;
    Hash$1.prototype.get = hashGet;
    Hash$1.prototype.has = hashHas;
    Hash$1.prototype.set = hashSet;
    var _Hash = Hash$1;

    /**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */
    function listCacheClear$1() {
      this.__data__ = [];
      this.size = 0;
    }
    var _listCacheClear = listCacheClear$1;

    /**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */
    function eq$2(value, other) {
      return value === other || value !== value && other !== other;
    }
    var eq_1 = eq$2;

    var eq$1 = eq_1;

    /**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function assocIndexOf$4(array, key) {
      var length = array.length;
      while (length--) {
        if (eq$1(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    var _assocIndexOf = assocIndexOf$4;

    var assocIndexOf$3 = _assocIndexOf;

    /** Used for built-in method references. */
    var arrayProto = Array.prototype;

    /** Built-in value references. */
    var splice = arrayProto.splice;

    /**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function listCacheDelete$1(key) {
      var data = this.__data__,
        index = assocIndexOf$3(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    var _listCacheDelete = listCacheDelete$1;

    var assocIndexOf$2 = _assocIndexOf;

    /**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function listCacheGet$1(key) {
      var data = this.__data__,
        index = assocIndexOf$2(data, key);
      return index < 0 ? undefined : data[index][1];
    }
    var _listCacheGet = listCacheGet$1;

    var assocIndexOf$1 = _assocIndexOf;

    /**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function listCacheHas$1(key) {
      return assocIndexOf$1(this.__data__, key) > -1;
    }
    var _listCacheHas = listCacheHas$1;

    var assocIndexOf = _assocIndexOf;

    /**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */
    function listCacheSet$1(key, value) {
      var data = this.__data__,
        index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    var _listCacheSet = listCacheSet$1;

    var listCacheClear = _listCacheClear,
      listCacheDelete = _listCacheDelete,
      listCacheGet = _listCacheGet,
      listCacheHas = _listCacheHas,
      listCacheSet = _listCacheSet;

    /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function ListCache$1(entries) {
      var index = -1,
        length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    // Add methods to `ListCache`.
    ListCache$1.prototype.clear = listCacheClear;
    ListCache$1.prototype['delete'] = listCacheDelete;
    ListCache$1.prototype.get = listCacheGet;
    ListCache$1.prototype.has = listCacheHas;
    ListCache$1.prototype.set = listCacheSet;
    var _ListCache = ListCache$1;

    var getNative = _getNative,
      root = _root;

    /* Built-in method references that are verified to be native. */
    var Map$2 = getNative(root, 'Map');
    var _Map = Map$2;

    var Hash = _Hash,
      ListCache = _ListCache,
      Map$1 = _Map;

    /**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */
    function mapCacheClear$1() {
      this.size = 0;
      this.__data__ = {
        'hash': new Hash(),
        'map': new (Map$1 || ListCache)(),
        'string': new Hash()
      };
    }
    var _mapCacheClear = mapCacheClear$1;

    /**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */
    function isKeyable$1(value) {
      var type = typeof value;
      return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
    }
    var _isKeyable = isKeyable$1;

    var isKeyable = _isKeyable;

    /**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */
    function getMapData$4(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
    }
    var _getMapData = getMapData$4;

    var getMapData$3 = _getMapData;

    /**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function mapCacheDelete$1(key) {
      var result = getMapData$3(this, key)['delete'](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    var _mapCacheDelete = mapCacheDelete$1;

    var getMapData$2 = _getMapData;

    /**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function mapCacheGet$1(key) {
      return getMapData$2(this, key).get(key);
    }
    var _mapCacheGet = mapCacheGet$1;

    var getMapData$1 = _getMapData;

    /**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function mapCacheHas$1(key) {
      return getMapData$1(this, key).has(key);
    }
    var _mapCacheHas = mapCacheHas$1;

    var getMapData = _getMapData;

    /**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */
    function mapCacheSet$1(key, value) {
      var data = getMapData(this, key),
        size = data.size;
      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    var _mapCacheSet = mapCacheSet$1;

    var mapCacheClear = _mapCacheClear,
      mapCacheDelete = _mapCacheDelete,
      mapCacheGet = _mapCacheGet,
      mapCacheHas = _mapCacheHas,
      mapCacheSet = _mapCacheSet;

    /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function MapCache$1(entries) {
      var index = -1,
        length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    // Add methods to `MapCache`.
    MapCache$1.prototype.clear = mapCacheClear;
    MapCache$1.prototype['delete'] = mapCacheDelete;
    MapCache$1.prototype.get = mapCacheGet;
    MapCache$1.prototype.has = mapCacheHas;
    MapCache$1.prototype.set = mapCacheSet;
    var _MapCache = MapCache$1;

    var MapCache = _MapCache;

    /** Error message constants. */
    var FUNC_ERROR_TEXT = 'Expected a function';

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided, it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is used as the map cache key. The `func`
     * is invoked with the `this` binding of the memoized function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the
     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoized function.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     * var other = { 'c': 3, 'd': 4 };
     *
     * var values = _.memoize(_.values);
     * values(object);
     * // => [1, 2]
     *
     * values(other);
     * // => [3, 4]
     *
     * object.a = 2;
     * values(object);
     * // => [1, 2]
     *
     * // Modify the result cache.
     * values.cache.set(object, ['a', 'b']);
     * values(object);
     * // => ['a', 'b']
     *
     * // Replace `_.memoize.Cache`.
     * _.memoize.Cache = WeakMap;
     */
    function memoize$2(func, resolver) {
      if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function () {
        var args = arguments,
          key = resolver ? resolver.apply(this, args) : args[0],
          cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };
      memoized.cache = new (memoize$2.Cache || MapCache)();
      return memoized;
    }

    // Expose `MapCache`.
    memoize$2.Cache = MapCache;
    var memoize_1 = memoize$2;

    var memoize$1 = memoize_1;

    /** Used as the maximum memoize cache size. */
    var MAX_MEMOIZE_SIZE = 500;

    /**
     * A specialized version of `_.memoize` which clears the memoized function's
     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
     *
     * @private
     * @param {Function} func The function to have its output memoized.
     * @returns {Function} Returns the new memoized function.
     */
    function memoizeCapped$1(func) {
      var result = memoize$1(func, function (key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key;
      });
      var cache = result.cache;
      return result;
    }
    var _memoizeCapped = memoizeCapped$1;

    var memoizeCapped = _memoizeCapped;

    /** Used to match property names within property paths. */
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

    /** Used to match backslashes in property paths. */
    var reEscapeChar = /\\(\\)?/g;

    /**
     * Converts `string` to a property path array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the property path array.
     */
    var stringToPath$1 = memoizeCapped(function (string) {
      var result = [];
      if (string.charCodeAt(0) === 46 /* . */) {
        result.push('');
      }
      string.replace(rePropName, function (match, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match);
      });
      return result;
    });
    var _stringToPath = stringToPath$1;

    /**
     * A specialized version of `_.map` for arrays without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function arrayMap$1(array, iteratee) {
      var index = -1,
        length = array == null ? 0 : array.length,
        result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    var _arrayMap = arrayMap$1;

    var Symbol$1 = _Symbol,
      arrayMap = _arrayMap,
      isArray$3 = isArray_1,
      isSymbol$1 = isSymbol_1;

    /** Used as references for various `Number` constants. */
    var INFINITY$1 = 1 / 0;

    /** Used to convert symbols to primitives and strings. */
    var symbolProto = Symbol$1 ? Symbol$1.prototype : undefined,
      symbolToString = symbolProto ? symbolProto.toString : undefined;

    /**
     * The base implementation of `_.toString` which doesn't convert nullish
     * values to empty strings.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */
    function baseToString$1(value) {
      // Exit early for strings to avoid a performance hit in some environments.
      if (typeof value == 'string') {
        return value;
      }
      if (isArray$3(value)) {
        // Recursively convert values (susceptible to call stack limits).
        return arrayMap(value, baseToString$1) + '';
      }
      if (isSymbol$1(value)) {
        return symbolToString ? symbolToString.call(value) : '';
      }
      var result = value + '';
      return result == '0' && 1 / value == -INFINITY$1 ? '-0' : result;
    }
    var _baseToString = baseToString$1;

    var baseToString = _baseToString;

    /**
     * Converts `value` to a string. An empty string is returned for `null`
     * and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */
    function toString$1(value) {
      return value == null ? '' : baseToString(value);
    }
    var toString_1 = toString$1;

    var isArray$2 = isArray_1,
      isKey = _isKey,
      stringToPath = _stringToPath,
      toString = toString_1;

    /**
     * Casts `value` to a path array if it's not one.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {Object} [object] The object to query keys on.
     * @returns {Array} Returns the cast property path array.
     */
    function castPath$1(value, object) {
      if (isArray$2(value)) {
        return value;
      }
      return isKey(value, object) ? [value] : stringToPath(toString(value));
    }
    var _castPath = castPath$1;

    var isSymbol = isSymbol_1;

    /** Used as references for various `Number` constants. */
    var INFINITY = 1 / 0;

    /**
     * Converts `value` to a string key if it's not a string or symbol.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {string|symbol} Returns the key.
     */
    function toKey$1(value) {
      if (typeof value == 'string' || isSymbol(value)) {
        return value;
      }
      var result = value + '';
      return result == '0' && 1 / value == -INFINITY ? '-0' : result;
    }
    var _toKey = toKey$1;

    var castPath = _castPath,
      toKey = _toKey;

    /**
     * The base implementation of `_.get` without support for default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @returns {*} Returns the resolved value.
     */
    function baseGet$1(object, path) {
      path = castPath(path, object);
      var index = 0,
        length = path.length;
      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return index && index == length ? object : undefined;
    }
    var _baseGet = baseGet$1;

    var baseGet = _baseGet;

    /**
     * Gets the value at `path` of `object`. If the resolved value is
     * `undefined`, the `defaultValue` is returned in its place.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */
    function get$3(object, path, defaultValue) {
      var result = object == null ? undefined : baseGet(object, path);
      return result === undefined ? defaultValue : result;
    }
    var get_1 = get$3;
    var get$4 = /*@__PURE__*/getDefaultExportFromCjs(get_1);

    function _setFieldCache(fCache, index, field, value) {
        const recCache = fCache[index] || (fCache[index] = new Map());
        recCache.set(field, value);
    }
    class CachedDataSource extends DataSource {
        _recordCache;
        _fieldCache;
        groupAggregator;
        _isGrouped;
        static get EVENT_TYPE() {
            return DataSource.EVENT_TYPE;
        }
        static ofArray(array, dataConfig, pagination, columns, rowHierarchyType, hierarchyExpandLevel) {
            return new CachedDataSource({
                get: (index) => {
                    return array[index];
                },
                length: array.length,
                records: array
            }, dataConfig, pagination, columns, rowHierarchyType, hierarchyExpandLevel);
        }
        constructor(opt, dataConfig, pagination, columns, rowHierarchyType, hierarchyExpandLevel) {
            let _isGrouped;
            if (isArray$7(dataConfig?.groupByRules)) {
                rowHierarchyType = 'tree';
                _isGrouped = true;
            }
            super(opt, dataConfig, pagination, columns, rowHierarchyType, hierarchyExpandLevel);
            this._isGrouped = _isGrouped;
            this._recordCache = [];
            this._fieldCache = {};
        }
        getOriginalRecord(index) {
            if (isNumber$4(index) && this._recordCache && this._recordCache[index]) {
                return this._recordCache[index];
            }
            return super.getOriginalRecord(index);
        }
        getRawRecord(index) {
            let originRecordIndex;
            if (this._isGrouped) {
                originRecordIndex = this.getOriginRecordIndexForGroup(index);
                if (isValid$3(originRecordIndex) && this.beforeChangedRecordsMap?.has(originRecordIndex.toString())) {
                    return this.beforeChangedRecordsMap?.get(originRecordIndex.toString());
                }
            }
            else {
                if (this.beforeChangedRecordsMap?.has(index.toString())) {
                    return this.beforeChangedRecordsMap?.get(index.toString());
                }
            }
            if (isNumber$4(index) && this._recordCache && this._recordCache[index]) {
                return this._recordCache[index];
            }
            let data;
            if (!this.dataSourceObj.records) {
                data = this._get(index);
            }
            else {
                if (Array.isArray(index)) {
                    data = getValueFromDeepArray(this.records, index);
                }
                else {
                    data = this.records[index];
                }
            }
            return getValue$2(data, (val) => {
                this.recordPromiseCallBack(index, val);
            });
        }
        getOriginalField(index, field, col, row, table) {
            const rowCache = this._fieldCache && this._fieldCache[index];
            if (rowCache) {
                const cache = rowCache.get(field);
                if (cache) {
                    return cache;
                }
            }
            return super.getOriginalField(index, field, col, row, table);
        }
        clearCache() {
            if (this._recordCache) {
                this._recordCache = [];
            }
            if (this._fieldCache) {
                this._fieldCache = {};
            }
        }
        fieldPromiseCallBack(index, field, value) {
            _setFieldCache(this._fieldCache, index, field, value);
        }
        recordPromiseCallBack(index, record) {
            this._recordCache && (this._recordCache[index] = record);
        }
        get records() {
            return Array.isArray(this._recordCache) && this._recordCache.length > 0 ? this._recordCache : super.records;
        }
        release() {
            super.release?.();
            this._recordCache = null;
            this._fieldCache = null;
        }
        _generateFieldAggragations() {
            super._generateFieldAggragations();
            if (isArray$7(this.dataConfig?.groupByRules)) {
                const groupByKeys = this.dataConfig.groupByRules;
                this.groupAggregator = new this.registedAggregators[AggregationType.CUSTOM]({
                    field: '',
                    aggregationFun: (values, records, field) => {
                        const groupMap = new Map();
                        const groupResult = [];
                        for (let i = 0; i < records.length; i++) {
                            dealWithGroup(records[i], groupResult, groupMap, groupByKeys, 0);
                        }
                        return groupResult;
                    }
                });
                this.fieldAggregators.push(this.groupAggregator);
            }
        }
        processRecords(records) {
            const result = super.processRecords(records);
            const groupResult = this.groupAggregator?.value();
            if (groupResult) {
                return groupResult;
            }
            return result;
        }
        getGroupLength() {
            return this.dataConfig?.groupByRules?.length ?? 0;
        }
        updateGroup() {
            this.clearCache();
            const oldSource = this.source;
            this._source = this.processRecords(this.dataSourceObj?.records ?? this.dataSourceObj);
            if (oldSource) {
                syncGroupCollapseState(oldSource, this.source);
            }
            this.sourceLength = this.source?.length || 0;
            this.sortedIndexMap.clear();
            this.currentIndexedData = Array.from({ length: this.sourceLength }, (_, i) => i);
            if (!this.userPagination) {
                this.pagination.perPageCount = this.sourceLength;
                this.pagination.totalCount = this.sourceLength;
            }
            this.initTreeHierarchyState();
            this.updatePagerData();
        }
        getOriginRecordIndexForGroup(recordIndex) {
            const targetRecord = this.getOriginalRecord(recordIndex);
            if (!isValid$3(targetRecord)) {
                return undefined;
            }
            if (targetRecord.children && targetRecord.children.length > 0) {
                return undefined;
            }
            for (let i = 0; i < this.dataSourceObj.records.length; i++) {
                if (this.dataSourceObj.records[i] === targetRecord) {
                    return i;
                }
            }
            return undefined;
        }
        addRecordsForGroup(recordArr, recordIndex) {
            if (!isArray$7(recordArr) || recordArr.length === 0) {
                return;
            }
            let originRecordIndex = this.getOriginRecordIndexForGroup(recordIndex);
            if (originRecordIndex === undefined || originRecordIndex > this.dataSourceObj.records) {
                originRecordIndex = this.dataSourceObj.records.length;
            }
            this.dataSourceObj.records.splice(originRecordIndex, 0, ...recordArr);
            this.adjustBeforeChangedRecordsMap(originRecordIndex, recordArr.length);
            this.updateGroup();
        }
        deleteRecordsForGroup(recordIndexs) {
            if (!isArray$7(recordIndexs) || recordIndexs.length === 0) {
                return;
            }
            const recordIndexsMaxToMin = sortRecordIndexs(recordIndexs, -1);
            for (let index = 0; index < recordIndexsMaxToMin.length; index++) {
                const recordIndex = recordIndexsMaxToMin[index];
                if (isNumber$4(recordIndex) && (recordIndex >= this.sourceLength || recordIndex < 0)) {
                    continue;
                }
                const originRecordIndex = this.getOriginRecordIndexForGroup(recordIndex);
                this.beforeChangedRecordsMap.delete(originRecordIndex.toString());
                this.dataSourceObj.records.splice(originRecordIndex, 1);
                this.sourceLength -= 1;
                this.adjustBeforeChangedRecordsMap(originRecordIndex, 1, 'delete');
            }
            this.updateGroup();
        }
        updateRecordsForGroup(records, recordIndexs) {
            for (let index = 0; index < recordIndexs.length; index++) {
                const recordIndex = recordIndexs[index];
                if (isNumber$4(recordIndex) && (recordIndex >= this.sourceLength || recordIndex < 0)) {
                    continue;
                }
                const originRecordIndex = this.getOriginRecordIndexForGroup(recordIndex);
                this.beforeChangedRecordsMap.delete(originRecordIndex.toString());
                this.dataSourceObj.records[originRecordIndex] = records[index];
            }
            this.updateGroup();
        }
        addRecordsForTree(recordArr, recordIndex) {
            if (!isArray$7(recordArr) || recordArr.length === 0) {
                return;
            }
            this.adjustBeforeChangedRecordsMap(recordIndex, recordArr.length);
            if (isNumber$4(recordIndex)) {
                this.dataSourceObj.records.splice(recordIndex, 0, ...recordArr);
            }
            else {
                const index = recordIndex.pop();
                const parentRecord = this.getOriginalRecord(recordIndex);
                if (parentRecord.children) {
                    parentRecord.children.splice(index, 0, ...recordArr);
                }
                else {
                    parentRecord.children = recordArr;
                }
            }
            this.initTreeHierarchyState();
            this.updatePagerData();
        }
        deleteRecordsForTree(recordIndexs) {
            if (!isArray$7(recordIndexs) || recordIndexs.length === 0) {
                return;
            }
            const recordIndexsMaxToMin = sortRecordIndexs(recordIndexs, -1);
            for (let index = 0; index < recordIndexsMaxToMin.length; index++) {
                const recordIndex = recordIndexsMaxToMin[index];
                if (isNumber$4(recordIndex) && (recordIndex >= this.sourceLength || recordIndex < 0)) {
                    continue;
                }
                this.beforeChangedRecordsMap.delete(recordIndex.toString());
                if (isNumber$4(recordIndex)) {
                    this.dataSourceObj.records.splice(recordIndex, 1);
                }
                else {
                    const index = recordIndex.pop();
                    const parentRecord = this.getOriginalRecord(recordIndex);
                    parentRecord.children.splice(index, 1);
                }
                this.adjustBeforeChangedRecordsMap(recordIndex, 1, 'delete');
            }
            this.initTreeHierarchyState();
            this.updatePagerData();
        }
        updateRecordsForTree(records, recordIndexs) {
            for (let index = 0; index < recordIndexs.length; index++) {
                const recordIndex = recordIndexs[index];
                const record = records[index];
                if (isNumber$4(recordIndex) && (recordIndex >= this.sourceLength || recordIndex < 0)) {
                    continue;
                }
                this.beforeChangedRecordsMap.delete(recordIndex.toString());
                if (isNumber$4(recordIndex)) {
                    this.dataSourceObj.records.splice(recordIndex, 1, record);
                }
                else {
                    const index = recordIndex.pop();
                    const parentRecord = this.getOriginalRecord(recordIndex);
                    parentRecord.children.splice(index, 1, record);
                }
            }
            this.initTreeHierarchyState();
            this.updatePagerData();
        }
        adjustBeforeChangedRecordsMap(insertIndex, insertCount, type = 'add') {
            if (this.rowHierarchyType === 'tree') {
                let insertIndexArr;
                if (isNumber$4(insertIndex)) {
                    insertIndexArr = [insertIndex];
                }
                else {
                    insertIndexArr = insertIndex;
                }
                const targetResult = [];
                this.beforeChangedRecordsMap.forEach((value, key) => {
                    const keyArray = key.split(',');
                    const length = Math.max(keyArray.length, insertIndexArr.length);
                    for (let i = 0; i < length; i++) {
                        const current = insertIndexArr[i] ?? -1;
                        const keyIndex = Number(keyArray[i]) ?? -1;
                        if (current < keyIndex ||
                            (current === keyIndex && i === keyArray.length - 1 && i === insertIndexArr.length - 1)) {
                            keyArray[i] = (keyIndex + (type === 'add' ? insertCount : -insertCount)).toString();
                            targetResult.push({
                                originKey: key,
                                targetKey: keyArray.toString(),
                                value
                            });
                            return;
                        }
                    }
                });
                targetResult.forEach(({ originKey, targetKey, value }) => {
                    this.beforeChangedRecordsMap.delete(originKey);
                    this.beforeChangedRecordsMap.set(targetKey, value);
                });
            }
            else {
                super.adjustBeforeChangedRecordsMap(insertIndex, insertCount, type);
            }
        }
        cacheBeforeChangedRecord(dataIndex, table) {
            const originRecord = this.getOriginalRecord(dataIndex);
            if (table.options.groupBy) {
                dataIndex = this.getOriginRecordIndexForGroup(dataIndex);
            }
            if (!this.beforeChangedRecordsMap.has(dataIndex.toString())) {
                this.beforeChangedRecordsMap.set(dataIndex.toString(), cloneDeep$1(originRecord, undefined, ['vtable_gantt_linkedFrom', 'vtable_gantt_linkedTo']) ?? {});
            }
        }
        getGroupSeriesNumber(showIndex) {
            const recordIndex = this.dataSource.currentIndexedData[showIndex];
            const parentRecordIndexLength = recordIndex.length - 1;
            let recordIndexLength = recordIndex.length;
            let i = 1;
            for (; recordIndexLength > parentRecordIndexLength; i++) {
                const index = this.dataSource.currentIndexedData[showIndex - i];
                recordIndexLength = isNumber$4(index) ? 1 : index.length;
            }
            return i - 1;
        }
    }
    function dealWithGroup(record, children, map, groupByKeys, level) {
        const groupByKey = groupByKeys[level];
        if (!isValid$3(groupByKey)) {
            children.push(record);
            return;
        }
        const value = get$4(record, groupByKey);
        if (value !== undefined) {
            if (map.has(value)) {
                const index = map.get(value);
                return dealWithGroup(record, children[index].children, children[index].map, groupByKeys, level + 1);
            }
            map.set(value, children.length);
            children.push({
                vtableMerge: true,
                vtableMergeName: value,
                children: [],
                map: new Map()
            });
            return dealWithGroup(record, children[children.length - 1].children, children[children.length - 1].map, groupByKeys, level + 1);
        }
    }
    function syncGroupCollapseState(oldSource, newSource, oldGroupMap, newGroupMap) {
        if (!oldGroupMap) {
            oldGroupMap = new Map();
            for (let i = 0; i < oldSource.length; i++) {
                const record = oldSource[i];
                if (record.vtableMerge) {
                    oldGroupMap.set(record.vtableMergeName, i);
                }
            }
        }
        if (!newGroupMap) {
            newGroupMap = new Map();
            for (let i = 0; i < newSource.length; i++) {
                const record = newSource[i];
                if (record.vtableMerge) {
                    newGroupMap.set(record.vtableMergeName, i);
                }
            }
        }
        for (let i = 0; i < oldSource.length; i++) {
            const oldRecord = oldSource[i];
            const newRecord = newSource[newGroupMap.get(oldRecord.vtableMergeName)];
            if (isValid$3(newRecord)) {
                newRecord.hierarchyState = oldSource[i].hierarchyState;
            }
            if (isArray$7(oldRecord.children) &&
                isArray$7(newRecord.children) &&
                oldRecord.map.size !== 0 &&
                newRecord.map.size !== 0) {
                syncGroupCollapseState(oldRecord.children, newRecord.children, oldRecord.map, newRecord.map);
            }
        }
    }

    var data = /*#__PURE__*/Object.freeze({
        __proto__: null,
        CachedDataSource: CachedDataSource,
        DataSource: DataSource
    });

    var cssfontparser = {exports: {}};

    // Inspriation from node-canvas (https://github.com/LearnBoost/node-canvas/)

    var cache = {};

    // regex hoisted from http://stackoverflow.com/questions/10135697/regex-to-parse-any-css-font
    var fontRegex = new RegExp(['^\\s*(?=(?:(?:[-a-z]+\\s*){0,2}(italic|oblique))?)', '(?=(?:(?:[-a-z]+\\s*){0,2}(small-caps))?)', '(?=(?:(?:[-a-z]+\\s*){0,2}(bold(?:er)?|lighter|[1-9]00 ))?)', '(?:(?:normal|\\1|\\2|\\3)\\s*){0,3}((?:xx?-)?', '(?:small|large)|medium|smaller|larger|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx]))', '(?:\\s*\\/\\s*(normal|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx])?))', '?\\s*([-,\\"\\\'\\sa-z]+?)\\s*$'].join(''), 'i');
    var mapping = ['style', 'variant', 'weight', 'size', 'lineHeight', 'family'];
    var unitMatch = /([\.0-9]+)(.*)/;
    var numeric = function (val, parent, dpi) {
      var matches = val.match(unitMatch);
      if (!matches) {
        return;
      }
      val = parseFloat(matches[1]);
      var units = matches[2].toLowerCase().trim();
      var v = Math.round(val);
      if (v === val) {
        val = v;
      }
      switch (units) {
        case 'em':
          if (parent === null) {
            return;
          }
          return val * parent;
        case 'px':
          return val;
        case 'pt':
          return val / (72 / dpi);
        case 'pc':
          return val / (6 / dpi);
        case 'mm':
          return val * (dpi / 25.4);
        case 'cm':
          return val * (dpi / 2.54);
        case 'in':
          return val * dpi;
        case '%':
          if (parent === null) {
            return;
          }
          return parent * (val / 100);
      }
    };
    var op = {
      size: numeric,
      lineHeight: numeric
    };
    var generics = {
      serif: 1,
      'sans-serif': 1,
      cursive: 1,
      fantasy: 1,
      monospace: 1
    };
    var parse$1 = cssfontparser.exports = function (str, existing, dpi) {
      var cacheKey = str + '-' + (existing || 'null') + '@' + dpi;
      dpi = dpi || 96.0;
      if (typeof cache[cacheKey] !== 'undefined') {
        return cache[cacheKey];
      }
      if (existing) {
        existing = parse$1(existing, null, dpi);
      }
      if (str === 'inherit') {
        return existing;
      }
      var matches = fontRegex.exec(str);
      if (!matches) {
        cache[cacheKey] = null;
        return;
      }
      matches.shift();
      var collected = {};
      for (var i = 0; i < matches.length; i++) {
        var key = mapping[i];
        var val = matches[i];
        if (op[key] && val) {
          var existingVal = existing ? existing[key] || null : null;
          var v = op[key](val, existingVal, dpi);
          if (typeof v === 'undefined' && key === 'lineHeight' && val) {
            val = collected.size * parseFloat(val);
          } else {
            val = v;
          }
        }
        if (!val || val === 'normal') {
          continue;
        } else if (val === 'inherit') {
          if (!existing) {
            return;
          }
          val = existing[key];
        }
        if (val.trim) {
          val = val.trim();
        }
        collected[key] = val;
      }
      if (!Object.keys(collected).length) {
        collected = null;
      }
      cache[cacheKey] = collected;
      var out = [];
      if (collected.style) {
        out.push(collected.style);
      }
      if (collected.variant) {
        out.push(collected.variant);
      }
      if (collected.weight && collected.weight !== '400' && collected.weight !== 'normal') {
        out.push(collected.weight);
      }
      out.push(collected.size + 'px');
      if (collected.lineHeight) {
        out[out.length - 1] += '/' + collected.lineHeight + 'px';
      }
      var family = collected.family.split(',');
      collected.family = family.map(function (a) {
        a = a.trim();
        if (generics[a.toLowerCase()]) {
          a = a.toLowerCase();
        }
        return a;
      });
      out.push(collected.family);
      Object.defineProperty(collected, 'toString', {
        value: function () {
          return out.map(function (val) {
            if (Array.isArray(val)) {
              return val.map(function (a) {
                if (a.indexOf(' ') > -1) {
                  return '"' + a.replace(/["']/g, '') + '"';
                } else {
                  return a;
                }
              }).join(', ');
            } else {
              return val;
            }
          }).join(' ');
        }
      });
      return collected;
    };
    cssfontparser.exports.generics = generics;
    var cssfontparserExports = cssfontparser.exports;
    var parse$2 = /*@__PURE__*/getDefaultExportFromCjs(cssfontparserExports);

    function parseFont(font) {
        return parse$2(font);
    }

    function getQuadProps(paddingOrigin) {
        if (isNumber$4(paddingOrigin) || isString$4(paddingOrigin) || isArray$7(paddingOrigin)) {
            let padding = parsePadding(paddingOrigin);
            if (typeof padding === 'number' || typeof padding === 'string') {
                padding = [padding, padding, padding, padding];
            }
            else if (Array.isArray(padding)) {
                padding = padding.slice(0);
            }
            return padding;
        }
        else if (paddingOrigin &&
            (isFinite(paddingOrigin.bottom) ||
                isFinite(paddingOrigin.left) ||
                isFinite(paddingOrigin.right) ||
                isFinite(paddingOrigin.top))) {
            return [paddingOrigin.top ?? 0, paddingOrigin.right ?? 0, paddingOrigin.bottom ?? 0, paddingOrigin.left ?? 0];
        }
        return [0, 0, 0, 0];
    }

    const TYPE_PAREN = 0;
    const TYPE_UNIT = 1;
    const TYPE_OPERATOR = 2;
    const TYPE_NUMBER = 3;
    const NODE_TYPE_UNIT = 10;
    const NODE_TYPE_BINARY_EXPRESSION = 11;
    const NODE_TYPE_NUMBER = 12;
    const TABULATION = 0x09;
    const CARRIAGE_RETURN = 0x0d;
    const LINE_FEED = 0x0a;
    const FORM_FEED = 0x0c;
    const SPACE = 0x20;
    const PERCENT = 0x25;
    const FULL_STOP = 0x2e;
    const DIGIT_0 = 0x30;
    const DIGIT_9 = 0x39;
    const LATIN_CAPITAL_A = 0x41;
    const LATIN_CAPITAL_Z = 0x5a;
    const LATIN_SMALL_A = 0x61;
    const LATIN_SMALL_Z = 0x7a;
    function isUpperLetter(cp) {
        return cp >= LATIN_CAPITAL_A && cp <= LATIN_CAPITAL_Z;
    }
    function isLowerLetter(cp) {
        return cp >= LATIN_SMALL_A && cp <= LATIN_SMALL_Z;
    }
    function isLetter(cp) {
        return isLowerLetter(cp) || isUpperLetter(cp);
    }
    function isWhitespace(cp) {
        return cp === TABULATION || cp === LINE_FEED || cp === FORM_FEED || cp === CARRIAGE_RETURN || cp === SPACE;
    }
    function isDigit(cp) {
        return cp >= DIGIT_0 && cp <= DIGIT_9;
    }
    function isDot(cp) {
        return cp === FULL_STOP;
    }
    function isUnit(cp) {
        return isLetter(cp) || cp === PERCENT;
    }
    function createError(calc) {
        return new Error(`calc parse error: ${calc}`);
    }
    function tokenize(calc) {
        const exp = calc.replace(/calc\(/g, '(').trim();
        const tokens = [];
        const len = exp.length;
        for (let index = 0; index < len; index++) {
            const c = exp[index];
            const cp = c.charCodeAt(0);
            if (c === '(' || c === ')') {
                tokens.push({ value: c, type: TYPE_PAREN });
            }
            else if (c === '*' || c === '/') {
                tokens.push({ value: c, type: TYPE_OPERATOR });
            }
            else if (c === '+' || c === '-') {
                index = parseSign(c, index + 1) - 1;
            }
            else if (isDigit(cp) || isDot(cp)) {
                index = parseNum(c, index + 1) - 1;
            }
            else if (isWhitespace(cp)) ;
            else {
                throw createError(calc);
            }
        }
        function parseSign(sign, start) {
            if (start < len) {
                const c = exp[start];
                const cp = c.charCodeAt(0);
                if (isDigit(cp) || isDot(cp)) {
                    return parseNum(sign + c, start + 1);
                }
            }
            tokens.push({ value: sign, type: TYPE_OPERATOR });
            return start;
        }
        function parseNum(num, start) {
            let index = start;
            for (; index < len; index++) {
                const c = exp[index];
                const cp = c.charCodeAt(0);
                if (isDigit(cp)) {
                    num += c;
                }
                else if (c === '.') {
                    if (num.indexOf('.') >= 0) {
                        throw createError(calc);
                    }
                    num += c;
                }
                else if (isUnit(cp)) {
                    return parseUnit(num, c, index + 1);
                }
                else {
                    break;
                }
            }
            if (num === '.') {
                throw createError(calc);
            }
            tokens.push({ value: parseFloat(num), type: TYPE_NUMBER });
            return index;
        }
        function parseUnit(num, unit, start) {
            let index = start;
            for (; index < len; index++) {
                const c = exp[index];
                const cp = c.charCodeAt(0);
                if (isUnit(cp)) {
                    unit += c;
                }
                else {
                    break;
                }
            }
            tokens.push({ value: parseFloat(num), unit, type: TYPE_UNIT });
            return index;
        }
        return tokens;
    }
    const PRECEDENCE = {
        '*': 3,
        '/': 3,
        '+': 2,
        '-': 2
    };
    function lex(tokens, calc) {
        function buildBinaryExpNode(stack) {
            const right = stack.pop();
            const op = stack.pop();
            const left = stack.pop();
            if (!left || !left.nodeType || !op || op.type !== TYPE_OPERATOR || !right || !right.nodeType) {
                throw createError(calc);
            }
            return {
                nodeType: NODE_TYPE_BINARY_EXPRESSION,
                left,
                op,
                right
            };
        }
        const stack = [];
        while (tokens.length) {
            const token = tokens.shift();
            if (token.type === TYPE_PAREN && token.value === '(') {
                let deep = 0;
                const closeIndex = array.findIndex(tokens, t => {
                    if (t.type === TYPE_PAREN && t.value === '(') {
                        deep++;
                    }
                    else if (t.type === TYPE_PAREN && t.value === ')') {
                        if (!deep) {
                            return true;
                        }
                        deep--;
                    }
                    return false;
                });
                if (closeIndex === -1) {
                    throw createError(calc);
                }
                stack.push(lex(tokens.splice(0, closeIndex), calc));
                tokens.shift();
            }
            else if (token.type === TYPE_OPERATOR) {
                if (stack.length >= 3) {
                    const beforeOp = stack[stack.length - 2].value;
                    if (PRECEDENCE[token.value] <= PRECEDENCE[beforeOp]) {
                        stack.push(buildBinaryExpNode(stack));
                    }
                }
                stack.push(token);
            }
            else if (token.type === TYPE_UNIT) {
                const { value: num, unit } = token;
                stack.push({
                    nodeType: NODE_TYPE_UNIT,
                    value: num,
                    unit
                });
            }
            else if (token.type === TYPE_NUMBER) {
                stack.push({
                    nodeType: NODE_TYPE_NUMBER,
                    value: token.value
                });
            }
        }
        while (stack.length > 1) {
            stack.push(buildBinaryExpNode(stack));
        }
        return stack[0];
    }
    function parse(calcStr) {
        const tokens = tokenize(calcStr);
        return lex(tokens, calcStr);
    }
    function calcNode(node, context) {
        if (node.nodeType === NODE_TYPE_BINARY_EXPRESSION) {
            const left = calcNode(node.left, context);
            const right = calcNode(node.right, context);
            switch (node.op.value) {
                case '+':
                    return left + right;
                case '-':
                    return left - right;
                case '*':
                    return left * right;
                case '/':
                    return left / right;
                default:
                    throw new Error(`calc error. unknown operator: ${node.op.value}`);
            }
        }
        else if (node.nodeType === NODE_TYPE_UNIT) {
            switch (node.unit) {
                case '%':
                    return (node.value * context.full) / 100;
                case 'px':
                    return node.value;
                default:
                    throw new Error(`calc error. unknown unit: ${node.unit}`);
            }
        }
        else if (node.nodeType === NODE_TYPE_NUMBER) {
            return node.value;
        }
        throw new Error('calc error.');
    }
    function toPxInternal(value, context) {
        const ast = parse(value);
        return calcNode(ast, context);
    }
    function toPx(value, context) {
        if (typeof value === 'string') {
            return toPxInternal(value.trim(), context);
        }
        return value - 0;
    }
    function couldBeValidNumber(v) {
        if (isNil$3(v)) {
            return false;
        }
        if (isNumber$4(v)) {
            return true;
        }
        return +v === +v;
    }
    function isPercent(v) {
        if (!isString$4(v)) {
            return false;
        }
        if (!v.endsWith('%')) {
            return false;
        }
        return couldBeValidNumber(v.substring(0, v.length - 1));
    }

    function createRootElement(padding, className = 'vtable') {
        const element = document.createElement('div');
        element.setAttribute('tabindex', '0');
        element.classList.add(className);
        element.style.outline = 'none';
        element.style.margin = `${padding.top}px ${padding.right}px ${padding.bottom}px ${padding.left}px`;
        const width = (element.offsetWidth || element.parentElement?.offsetWidth || 1) - 1;
        const height = (element.offsetHeight || element.parentElement?.offsetHeight || 1) - 1;
        element.style.width = (width && `${width - padding.left - padding.right}px`) || '0px';
        element.style.height = (height && `${height - padding.top - padding.bottom}px`) || '0px';
        return element;
    }
    function updateRootElementPadding(element, padding) {
        element.style.margin = `${padding.top}px ${padding.right}px ${padding.bottom}px ${padding.left}px`;
        const width = (element.offsetWidth || element.parentElement?.offsetWidth || 1) - 1;
        const height = (element.offsetHeight || element.parentElement?.offsetHeight || 1) - 1;
        element.style.width = (width && `${width - padding.left - padding.right}px`) || '0px';
        element.style.height = (height && `${height - padding.top - padding.bottom}px`) || '0px';
    }
    function _dealWithUpdateDataSource(table, fn) {
        const { dataSourceEventIds } = table.internalProps;
        if (dataSourceEventIds) {
            dataSourceEventIds.forEach((id) => table.internalProps.handler.off(id));
        }
        fn(table);
        table.internalProps.dataSourceEventIds = [
            table.internalProps.handler.on(table.internalProps.dataSource, DataSource.EVENT_TYPE.CHANGE_ORDER, () => {
                if (table.dataSource.hierarchyExpandLevel) {
                    table.refreshRowColCount();
                }
                table.render();
            })
        ];
    }
    function _setRecords(table, records = []) {
        _dealWithUpdateDataSource(table, () => {
            table.internalProps.records = records;
            const newDataSource = (table.internalProps.dataSource = CachedDataSource.ofArray(records, table.internalProps.dataConfig, table.pagination, table.internalProps.columns, table.internalProps.layoutMap.rowHierarchyType, getHierarchyExpandLevel(table)));
            table.addReleaseObj(newDataSource);
        });
    }
    function getHierarchyExpandLevel(table) {
        if (table.options.hierarchyExpandLevel) {
            return table.options.hierarchyExpandLevel;
        }
        else if (table.options.groupBy) {
            return Infinity;
        }
        return table._hasHierarchyTreeHeader?.() ? 1 : undefined;
    }
    function _setDataSource(table, dataSource) {
        _dealWithUpdateDataSource(table, () => {
            if (table.internalProps.dataSource) {
                table.internalProps.releaseList.forEach(releaseObj => {
                    if (releaseObj instanceof DataSource) {
                        releaseObj.release();
                        table.internalProps.releaseList.splice(table.internalProps.releaseList.indexOf(releaseObj), 1);
                    }
                });
            }
            if (dataSource) {
                if (dataSource instanceof DataSource) {
                    table.internalProps.dataSource = dataSource;
                    table.internalProps.dataSource.supplementConfig(table.pagination, table.options.columns, table.internalProps.layoutMap.rowHierarchyType, getHierarchyExpandLevel(table));
                }
                else {
                    table.internalProps.dataSource = new CachedDataSource(dataSource);
                }
            }
            else {
                table.internalProps.dataSource = DataSource.EMPTY;
            }
            table.addReleaseObj(table.internalProps.dataSource);
            table.internalProps.records = null;
        });
    }
    function _getTargetFrozenRowAt(table, absoluteY) {
        if (!table.internalProps.frozenRowCount) {
            return null;
        }
        let { scrollTop } = table;
        const rowCount = table.internalProps.frozenRowCount;
        for (let row = 0; row < rowCount; row++) {
            const height = table.getRowHeight(row);
            const bottom = scrollTop + height;
            if (bottom > absoluteY) {
                return {
                    top: scrollTop,
                    row,
                    bottom,
                    height
                };
            }
            scrollTop = bottom;
        }
        return null;
    }
    function _getTargetFrozenColAt(table, absoluteX) {
        if (!table.internalProps.frozenColCount) {
            return null;
        }
        let { scrollLeft } = table;
        const colCount = table.internalProps.frozenColCount;
        for (let col = 0; col < colCount; col++) {
            const width = table.getColWidth(col);
            const right = scrollLeft + width;
            if (right > absoluteX) {
                return {
                    left: scrollLeft,
                    col,
                    right,
                    width
                };
            }
            scrollLeft = right;
        }
        return null;
    }
    function _toPxWidth(table, width) {
        return Math.round(toPx(width, table.internalProps.calcWidthContext));
    }
    function _applyColWidthLimits(limits, orgWidth) {
        if (!limits) {
            return orgWidth;
        }
        if (limits.min) {
            if (limits.min > orgWidth) {
                return limits.min;
            }
        }
        if (limits.max) {
            if (limits.max < orgWidth) {
                return limits.max;
            }
        }
        return orgWidth;
    }
    function _getScrollableVisibleRect(table) {
        let frozenColsWidth = 0;
        let rightFrozenColsWidth = 0;
        if (table.frozenColCount > 0) {
            frozenColsWidth = table.getFrozenColsWidth();
        }
        if (table.rightFrozenColCount > 0) {
            rightFrozenColsWidth = table.getRightFrozenColsWidth();
        }
        let frozenRowsHeight = 0;
        let bottomFrozenRowsHeight = 0;
        if (table.frozenRowCount > 0) {
            frozenRowsHeight = table.getFrozenRowsHeight();
        }
        if (table.bottomFrozenRowCount > 0) {
            bottomFrozenRowsHeight = table.getBottomFrozenRowsHeight();
        }
        return new Rect$1(table.scrollLeft + frozenColsWidth, table.scrollTop + frozenRowsHeight, table.tableNoFrameWidth - frozenColsWidth - rightFrozenColsWidth, table.tableNoFrameHeight - frozenRowsHeight - bottomFrozenRowsHeight);
    }
    function getStyleTheme(headerStyle, table, col, row, getProp, needGetTheme = true) {
        const padding = getQuadProps(getProp('padding', headerStyle, col, row, table));
        const bgColor = getProp('bgColor', headerStyle, col, row, table);
        const font = getProp('font', headerStyle, col, row, table);
        let fontFamily;
        let fontSize;
        let fontWeight;
        let fontStyle;
        let fontVariant;
        if (font) {
            const { family, size, weight, style, variant } = parseFont(font);
            fontFamily = family.join(' ');
            fontSize = size;
            fontWeight = weight;
            fontStyle = style;
            fontStyle = variant;
        }
        else {
            fontFamily = getProp('fontFamily', headerStyle, col, row, table);
            fontSize = getProp('fontSize', headerStyle, col, row, table);
            fontWeight = getProp('fontWeight', headerStyle, col, row, table);
            fontStyle = getProp('fontStyle', headerStyle, col, row, table);
            fontVariant = getProp('fontVariant', headerStyle, col, row, table);
        }
        const textAlign = getProp('textAlign', headerStyle, col, row, table);
        const textBaseline = getProp('textBaseline', headerStyle, col, row, table);
        const color = getProp('color', headerStyle, col, row, table);
        const strokeColor = getProp('strokeColor', headerStyle, col, row, table);
        const lineHeight = getProp('lineHeight', headerStyle, col, row, table);
        const underline = getProp('underline', headerStyle, col, row, table);
        const underlineDash = getProp('underlineDash', headerStyle, col, row, table);
        const underlineOffset = getProp('underlineOffset', headerStyle, col, row, table);
        const lineThrough = getProp('lineThrough', headerStyle, col, row, table);
        const textDecorationWidth = Math.max(1, Math.floor(fontSize / 10));
        const textOverflow = getProp('textOverflow', headerStyle, col, row, table);
        const borderColor = getProp('borderColor', headerStyle, col, row, table);
        const borderLineWidth = getProp('borderLineWidth', headerStyle, col, row, table);
        const borderLineDash = getProp('borderLineDash', headerStyle, col, row, table);
        const marked = getProp('marked', headerStyle, col, row, table);
        const cursor = getProp('cursor', headerStyle, col, row, table);
        const hasFunctionPros = !padding ||
            !bgColor ||
            !font ||
            !textAlign ||
            !textBaseline ||
            !color ||
            !textOverflow ||
            !borderColor ||
            !borderLineWidth ||
            !borderLineDash ||
            typeof underline !== 'boolean' ||
            typeof lineThrough !== 'boolean' ||
            typeof marked !== 'boolean';
        if (!needGetTheme) {
            return { hasFunctionPros };
        }
        const theme = {
            text: {
                fontFamily,
                fontSize,
                fontWeight,
                fontStyle,
                fontVariant,
                fill: color,
                stroke: strokeColor ?? false,
                textAlign,
                textBaseline,
                lineHeight: lineHeight ?? fontSize,
                underline: underline ? textDecorationWidth : undefined,
                underlineDash,
                underlineOffset,
                lineThrough: lineThrough ? textDecorationWidth : undefined,
                ellipsis: textOverflow === 'clip'
                    ? ''
                    : textOverflow === 'ellipsis'
                        ? '...'
                        : isValid$3(textOverflow)
                            ? textOverflow
                            : undefined
            },
            group: {
                fill: bgColor,
                lineDash: borderLineDash,
                lineWidth: borderLineWidth,
                stroke: borderColor,
                cursor: cursor === 'auto' || cursor === 'default' ? undefined : cursor
            },
            _vtable: {
                padding,
                marked
            }
        };
        if (Array.isArray(borderLineWidth)) {
            theme.group.strokeArrayWidth = getQuadProps(borderLineWidth);
        }
        if (Array.isArray(borderColor)) {
            const strokeColors = getQuadProps(borderColor);
            theme.group.stroke = strokeColors.every(color => !color) ? false : strokeColors;
            theme.group.strokeArrayColor = getQuadProps(borderColor);
        }
        return {
            theme,
            hasFunctionPros
        };
    }
    function getCellCornerRadius(col, row, table) {
        const tableCornerRadius = table.theme.frameStyle.cornerRadius;
        if (table.theme.cellInnerBorder) {
            if (Array.isArray(tableCornerRadius)) {
                const radius = [0, 0, 0, 0];
                if (col === 0 && row === 0) {
                    radius[0] = tableCornerRadius[0];
                }
                if (col === table.colCount - 1 && row === 0) {
                    radius[1] = tableCornerRadius[1];
                }
                if (col === 0 && row === table.rowCount - 1) {
                    radius[3] = tableCornerRadius[3];
                }
                if (col === table.colCount - 1 && row === table.rowCount - 1) {
                    radius[2] = tableCornerRadius[2];
                }
                return radius;
            }
            else if (tableCornerRadius) {
                const radius = [0, 0, 0, 0];
                if (col === 0 && row === 0) {
                    radius[0] = tableCornerRadius;
                }
                if (col === table.colCount - 1 && row === 0) {
                    radius[1] = tableCornerRadius;
                }
                if (col === 0 && row === table.rowCount - 1) {
                    radius[3] = tableCornerRadius;
                }
                if (col === table.colCount - 1 && row === table.rowCount - 1) {
                    radius[2] = tableCornerRadius;
                }
                return radius;
            }
        }
        return 0;
    }
    function parseMarkLineGetExtendRange(markLine) {
        if (markLine) {
            if (Array.isArray(markLine)) {
                let extendRange;
                for (let i = 0; i < markLine.length; i++) {
                    if (markLine[i].autoRange) {
                        if (markLine[i].y === 'sum' ||
                            markLine[i].x === 'sum' ||
                            markLine[i].y1 === 'sum' ||
                            markLine[i].x1 === 'sum') {
                            return 'sum';
                        }
                        if (markLine[i].y === 'max' ||
                            markLine[i].x === 'max' ||
                            markLine[i].y1 === 'max' ||
                            markLine[i].x1 === 'max') {
                            extendRange = 'max';
                        }
                        if (typeof markLine[i].y === 'number' && typeof (extendRange ?? 0) === 'number') {
                            extendRange = Math.max(extendRange ?? 0, markLine[i].y);
                        }
                        if (typeof markLine[i].x === 'number' && typeof (extendRange ?? 0) === 'number') {
                            extendRange = Math.max(extendRange ?? 0, markLine[i].x);
                        }
                        if (typeof markLine[i].y1 === 'number' && typeof (extendRange ?? 0) === 'number') {
                            extendRange = Math.max(extendRange ?? 0, markLine[i].y1);
                        }
                        if (typeof markLine[i].x1 === 'number' && typeof (extendRange ?? 0) === 'number') {
                            extendRange = Math.max(extendRange ?? 0, markLine[i].x1);
                        }
                    }
                }
                return extendRange;
            }
            else if (markLine.autoRange) {
                if (markLine.y === 'sum' || markLine.x === 'sum' || markLine.y1 === 'sum' || markLine.x1 === 'sum') {
                    return 'sum';
                }
                if (markLine.y === 'max' || markLine.x === 'max' || markLine.y1 === 'max' || markLine.x1 === 'max') {
                    return 'max';
                }
                if (typeof markLine.y === 'number') {
                    return markLine.y;
                }
                if (typeof markLine.x === 'number') {
                    return markLine.x;
                }
                if (typeof markLine.y1 === 'number') {
                    return markLine.y1;
                }
                if (typeof markLine.x1 === 'number') {
                    return markLine.x1;
                }
            }
        }
        return undefined;
    }
    function generateAggregationForColumn(table) {
        for (let col = 0; col < table.internalProps.columns.length; col++) {
            const colDef = table.internalProps.columns[col];
            if (colDef.aggregation) ;
            else if (table.options.aggregation) {
                let aggregation;
                if (typeof table.options.aggregation === 'function') {
                    aggregation = table.options.aggregation({
                        col: col,
                        field: colDef.field
                    });
                }
                else {
                    aggregation = table.options.aggregation;
                }
                if (aggregation) {
                    if (Array.isArray(aggregation)) {
                        const aggregations = [];
                        aggregation.forEach(item => {
                            aggregations.push(Object.assign({ showOnTop: false }, item));
                        });
                        colDef.aggregation = aggregations;
                    }
                    else {
                        colDef.aggregation = Object.assign({ showOnTop: false }, aggregation);
                    }
                }
            }
        }
    }
    function checkHasAggregationOnColumnDefine(colDefs) {
        for (let i = 0; i < colDefs.length; i++) {
            const colDef = colDefs[i];
            if (colDef.aggregation) {
                return true;
            }
        }
        return false;
    }
    function checkHasColumnAutoWidth(table) {
        if (table.options.widthMode === 'autoWidth') {
            return true;
        }
        if (table.options.defaultHeaderColWidth === 'auto' ||
            (Array.isArray(table.options.defaultHeaderColWidth) && table.options.defaultHeaderColWidth.includes('auto'))) {
            return true;
        }
        const columnObjects = table.internalProps.layoutMap.columnObjects;
        for (let i = 0; i < columnObjects.length; i++) {
            const column = columnObjects[i];
            if (column.width === 'auto') {
                return true;
            }
        }
        return false;
    }

    let Icon$1 = class Icon extends Image$2 {
        role;
        tooltip;
        frameImageData;
        tempCanvas;
        tempCtx;
        gifCanvas;
        gifCtx;
        loadedFrames;
        frameIndex;
        playing;
        lastTime;
        constructor(params) {
            super(params);
            if (this.attribute.visibleTime === 'mouseenter_cell' || this.attribute.visibleTime === 'click_cell') {
                this.attribute.opacity = 0;
            }
            if (this.attribute.hoverImage) {
                this.attribute.originImage = this.attribute.image;
            }
            if (this.attribute.isGif && this.attribute.gif) {
                this.loadGif();
            }
        }
        loadGif() {
            this.playing = false;
            ResourceLoader.GetFile(this.attribute.gif + '?role=gif' + `&radom=${Math.random()}`, 'arrayBuffer')
                .then((res) => {
                const gif = parseGIF_1(res);
                const frames = decompressFrames_1(gif, true);
                this.renderGIF(frames);
                this.resources.set(this.attribute.image, {
                    state: 'success',
                    data: this.gifCanvas
                });
            })
                .catch((e) => {
            });
        }
        get backgroundWidth() {
            return this.attribute.backgroundWidth ?? this.attribute.width ?? 0;
        }
        get backgroundHeight() {
            return this.attribute.backgroundHeight ?? this.attribute.height ?? 0;
        }
        renderGIF(frames) {
            this.loadedFrames = frames;
            this.frameIndex = 0;
            if (!this.tempCanvas) {
                this.tempCanvas = document.createElement('canvas');
                this.tempCtx = this.tempCanvas.getContext('2d');
            }
            if (!this.gifCanvas) {
                this.gifCanvas = document.createElement('canvas');
                this.gifCtx = this.gifCanvas.getContext('2d');
            }
            this.gifCanvas.width = frames[0].dims.width;
            this.gifCanvas.height = frames[0].dims.height;
            this.playing = true;
            this.lastTime = new Date().getTime();
            this.animate().to({}, 1000, 'linear').loop(Infinity);
        }
        renderFrame(context, x, y) {
            const frame = this.loadedFrames[this.frameIndex || 0];
            if (frame.disposalType === 2) {
                this.gifCtx.clearRect(0, 0, this.gifCanvas.width, this.gifCanvas.height);
            }
            this.drawPatch(frame);
            this.manipulate(context, x, y);
            const diff = new Date().getTime() - this.lastTime;
            if (frame.delay < diff) {
                this.frameIndex++;
                this.lastTime = new Date().getTime();
            }
            if (this.frameIndex >= this.loadedFrames.length) {
                this.frameIndex = 0;
            }
        }
        drawPatch(frame) {
            const dims = frame.dims;
            if (!this.frameImageData ||
                dims.width !== this.frameImageData.width ||
                dims.height !== this.frameImageData.height) {
                this.tempCanvas.width = dims.width;
                this.tempCanvas.height = dims.height;
                this.frameImageData = this.tempCtx.createImageData(dims.width, dims.height);
            }
            this.frameImageData.data.set(frame.patch);
            this.tempCtx.putImageData(this.frameImageData, 0, 0);
            this.gifCtx.drawImage(this.tempCanvas, dims.left, dims.top);
        }
        manipulate(context, x, y) {
            context.drawImage(this.gifCanvas, 0, 0, this.gifCanvas.width, this.gifCanvas.height, x, y, this.attribute.width, this.attribute.height);
        }
        setAttribute(key, value, forceUpdateTag, context) {
            super.setAttribute(key, value, forceUpdateTag, context);
            if (key === 'gif') {
                this.loadGif();
            }
        }
        setAttributes(params, forceUpdateTag, context) {
            super.setAttributes(params, forceUpdateTag, context);
            if (params.gif) {
                this.loadGif();
            }
        }
    };
    class TextIcon extends Text$1 {
        role;
        tooltip;
        constructor(params) {
            params.fill = params.fill ?? '#00F';
            params.fontSize = params.fontSize ?? 12;
            params.underline = params.underline ?? 1;
            params.textBaseline = params.textBaseline ?? 'top';
            params.cursor = params.cursor ?? 'pointer';
            super(params);
        }
    }

    function emptyCustomLayout(args) {
        const group = new Group$2({});
        return {
            rootContainer: group,
            renderDefault: true
        };
    }
    class ReactCustomLayout {
        removeAllContainer;
        table;
        customLayoutFuncCache;
        reactRemoveGraphicCache;
        reactRemoveAllGraphicCache;
        headerCustomLayoutFuncCache;
        headerReactRemoveGraphicCache;
        headerReactRemoveAllGraphicCache;
        constructor(table) {
            this.table = table;
            this.customLayoutFuncCache = new Map();
            this.reactRemoveGraphicCache = new Map();
            this.reactRemoveAllGraphicCache = new Map();
            this.headerCustomLayoutFuncCache = new Map();
            this.headerReactRemoveGraphicCache = new Map();
            this.headerReactRemoveAllGraphicCache = new Map();
        }
        hasReactCreateGraphic(componentId, isHeaderCustomLayout) {
            if (isHeaderCustomLayout) {
                return this.headerCustomLayoutFuncCache.has(componentId);
            }
            return this.customLayoutFuncCache.has(componentId);
        }
        setReactCreateGraphic(componentId, createGraphic, isHeaderCustomLayout) {
            if (isHeaderCustomLayout) {
                this.headerCustomLayoutFuncCache.set(componentId, createGraphic);
            }
            else {
                this.customLayoutFuncCache.set(componentId, createGraphic);
            }
        }
        setReactRemoveGraphic(componentId, removeGraphic, isHeaderCustomLayout) {
            if (isHeaderCustomLayout) {
                this.headerReactRemoveGraphicCache.set(componentId, removeGraphic);
            }
            else {
                this.reactRemoveGraphicCache.set(componentId, removeGraphic);
            }
        }
        setReactRemoveAllGraphic(componentId, removeGraphic, isHeaderCustomLayout) {
            if (isHeaderCustomLayout) {
                this.headerReactRemoveAllGraphicCache.set(componentId, removeGraphic);
            }
            else {
                this.reactRemoveAllGraphicCache.set(componentId, removeGraphic);
            }
        }
        updateCustomCell(componentId, isHeaderCustomLayout) {
            const table = this.table;
            if (table.widthMode === 'autoWidth') {
                table.scenegraph.recalculateColWidths();
            }
            if (table.isAutoRowHeight() ||
                (table.internalProps.defaultRowHeight === 'auto' && !isHeaderCustomLayout) ||
                (table.internalProps.defaultHeaderRowHeight === 'auto' && isHeaderCustomLayout)) {
                table.scenegraph.recalculateRowHeights();
            }
            if (table.isPivotTable()) {
                const ranges = getUpdateCustomCellRangeInPivotTable(componentId, table, isHeaderCustomLayout);
                for (let i = 0; i < ranges.length; i++) {
                    const range = ranges[i];
                    for (let col = range.start.col; col <= range.end.col; col++) {
                        for (let row = range.start.row; row <= range.end.row; row++) {
                            table.scenegraph.updateCellContent(col, row);
                        }
                    }
                }
            }
            else {
                const range = getUpdateCustomCellRangeInListTable(componentId, table, isHeaderCustomLayout);
                for (let col = range.start.col; col <= range.end.col; col++) {
                    for (let row = range.start.row; row <= range.end.row; row++) {
                        table.scenegraph.updateCellContent(col, row);
                    }
                }
            }
            table.scenegraph.renderSceneGraph();
        }
        getCustomLayoutFunc(col, row) {
            const isHeader = this.table.isHeader(col, row);
            if (isHeader) {
                const { componentId } = this.table.getHeaderDefine(col, row);
                return this.headerCustomLayoutFuncCache.get(componentId) ?? emptyCustomLayout;
            }
            const { componentId } = this.table.getBodyColumnDefine(col, row);
            return this.customLayoutFuncCache.get(componentId) || emptyCustomLayout;
        }
        removeCustomCell(col, row) {
            const isHeader = this.table.isHeader(col, row);
            let removeFun;
            if (isHeader) {
                const define = this.table.getHeaderDefine(col, row);
                const { componentId } = define;
                removeFun = this.headerReactRemoveGraphicCache.get(componentId);
            }
            else {
                const define = this.table.getBodyColumnDefine(col, row);
                const { componentId } = define;
                removeFun = this.reactRemoveGraphicCache.get(componentId);
            }
            if (removeFun) {
                removeFun(col, row);
            }
        }
        clearCache() {
            this.reactRemoveAllGraphicCache.forEach(removeFun => {
                removeFun();
            });
            this.headerReactRemoveAllGraphicCache.forEach(removeFun => {
                removeFun();
            });
        }
        updateAllCustomCell() {
            this.customLayoutFuncCache.forEach((createFun, componentId) => {
                this.updateCustomCell(componentId);
            });
            this.headerCustomLayoutFuncCache.forEach((createFun, componentId) => {
                this.updateCustomCell(componentId, true);
            });
        }
    }
    function getUpdateCustomCellRangeInListTable(componentId, table, isHeaderCustomLayout) {
        const rowSeriesNumber = table.internalProps.rowSeriesNumber ? 1 : 0;
        if (isHeaderCustomLayout) {
            const layoutMap = table.internalProps.layoutMap;
            const { headerObjects } = table.internalProps.layoutMap;
            let headerId;
            for (let i = 0; i < headerObjects.length; i++) {
                const headerObject = headerObjects[i];
                if (headerObject.define.componentId === componentId) {
                    headerId = headerObject.id;
                    break;
                }
            }
            const startCell = layoutMap.getHeaderCellAdressById(headerId);
            const range = layoutMap.getCellRange(startCell.col, startCell.row);
            return range;
        }
        const { columnObjects } = table.internalProps.layoutMap;
        for (let i = 0; i < columnObjects.length; i++) {
            const columnObject = columnObjects[i];
            if (columnObject.define.componentId === componentId) {
                return {
                    start: {
                        col: rowSeriesNumber + i,
                        row: table.columnHeaderLevelCount
                    },
                    end: {
                        col: rowSeriesNumber + i,
                        row: table.rowCount - 1
                    }
                };
            }
        }
        return {
            start: {
                col: 0,
                row: 0
            },
            end: {
                col: table.colCount - 1,
                row: table.rowCount - 1
            }
        };
    }
    function getUpdateCustomCellRangeInPivotTable(componentId, table, isHeaderCustomLayout) {
        const rowSeriesNumber = table.internalProps.rowSeriesNumber ? 1 : 0;
        const ranges = [];
        const layoutMap = table.internalProps.layoutMap;
        if (isHeaderCustomLayout) {
            const { headerObjects } = layoutMap;
            const headerIds = [];
            for (let i = 0; i < headerObjects.length; i++) {
                const headerObject = headerObjects[i];
                if (!headerObject) {
                    continue;
                }
                if (headerObject.define.componentId === componentId) {
                    headerIds.push(headerObject.id);
                }
            }
            for (let i = 0; i < headerIds.length; i++) {
                const headerId = headerIds[i];
                const startCell = layoutMap.getHeaderCellAdressById(headerId);
                const range = layoutMap.getCellRange(startCell.col, startCell.row);
                ranges.push(range);
            }
        }
        else {
            let columnIndex;
            const { columnObjects, indicatorsAsCol } = layoutMap;
            for (let i = 0; i < columnObjects.length; i++) {
                const columnObject = columnObjects[i];
                if (columnObject.define.componentId === componentId) {
                    columnIndex = i;
                    break;
                }
            }
            if (indicatorsAsCol) {
                for (let column = layoutMap.rowHeaderLevelCount + columnIndex; column < layoutMap.colCount; column += columnObjects.length) {
                    const range = {
                        start: {
                            col: column + rowSeriesNumber,
                            row: layoutMap.columnHeaderLevelCount
                        },
                        end: {
                            col: column + rowSeriesNumber,
                            row: layoutMap.rowCount - 1
                        }
                    };
                    ranges.push(range);
                }
            }
            else {
                for (let row = layoutMap.columnHeaderLevelCount + columnIndex; row < layoutMap.rowCount; row += columnObjects.length) {
                    const range = {
                        start: {
                            col: layoutMap.rowHeaderLevelCount + rowSeriesNumber,
                            row: row
                        },
                        end: {
                            col: layoutMap.colCount - 1,
                            row: row
                        }
                    };
                    ranges.push(range);
                }
            }
        }
        return ranges;
    }

    function getCellEventArgsSet(e) {
        const tableEvent = {
            abstractPos: {
                x: e.viewport.x,
                y: e.viewport.y
            }
        };
        const targetCell = getTargetCell(e.target);
        if (targetCell) {
            tableEvent.eventArgs = {
                col: targetCell.col,
                row: targetCell.row,
                event: e,
                targetCell,
                mergeInfo: getMergeCellInfo(targetCell),
                target: e.target
            };
        }
        return tableEvent;
    }
    function getTargetCell(target) {
        while (target && target.parent) {
            if (target.role === 'cell') {
                return target;
            }
            target = target.parent;
        }
        return null;
    }
    function getMergeCellInfo(cellGroup) {
        if (isValid$3(cellGroup.mergeStartCol) &&
            isValid$3(cellGroup.mergeStartRow) &&
            isValid$3(cellGroup.mergeEndCol) &&
            isValid$3(cellGroup.mergeEndRow)) {
            return {
                colStart: cellGroup.mergeStartCol,
                colEnd: cellGroup.mergeEndCol,
                rowStart: cellGroup.mergeStartRow,
                rowEnd: cellGroup.mergeEndRow
            };
        }
        return undefined;
    }
    const regIndexReg = /radio-\d+-\d+-(\d+)/;

    const CUSTOM_MERGE_PRE_NAME = '_custom_';
    const CUSTOM_CONTAINER_NAME = 'custom-container';
    const CUSTOM_MERGE_CONTAINER_NAME = CUSTOM_MERGE_PRE_NAME + '_0';
    function dealWithCustom(customLayout, customRender, col, row, width, height, autoWidth, autoHeight, padding, range, table) {
        let renderDefault = true;
        let enableCellPadding = false;
        let expectedWidth;
        let expectedHeight;
        let customElements;
        let elementsGroup;
        if (customLayout === 'react-custom-layout') {
            customLayout = table.reactCustomLayout?.getCustomLayoutFunc(col, row) || emptyCustomLayout;
        }
        if (typeof customLayout === 'function') {
            const arg = {
                col: range?.start.col ?? col,
                row: range?.start.row ?? row,
                dataValue: table.getCellOriginValue(col, row),
                value: table.getCellValue(col, row) || '',
                rect: {
                    left: 0,
                    top: 0,
                    right: width,
                    bottom: height,
                    width,
                    height
                },
                table,
                originCol: col,
                originRow: row
            };
            const customRenderObj = customLayout(arg);
            if (!customRenderObj) {
                return {
                    renderDefault: true
                };
            }
            if (customRenderObj.rootContainer) {
                customRenderObj.rootContainer = decodeReactDom(customRenderObj.rootContainer, table.animationManager.timeline);
            }
            if (customRenderObj.rootContainer instanceof Group$2) {
                elementsGroup = customRenderObj.rootContainer;
                elementsGroup.name = CUSTOM_CONTAINER_NAME;
                elementsGroup.col = col;
                elementsGroup.row = row;
            }
            renderDefault = customRenderObj.renderDefault;
            enableCellPadding = customRenderObj.enableCellPadding;
        }
        else if (typeof customRender === 'function') {
            const arg = {
                col,
                row,
                dataValue: table.getCellOriginValue(col, row),
                value: table.getCellValue(col, row) || '',
                rect: {
                    left: 0,
                    top: 0,
                    right: width,
                    bottom: height,
                    width,
                    height
                },
                table
            };
            const customRenderObj = customRender(arg);
            if (customRenderObj) {
                customElements = customRenderObj.elements;
                renderDefault = customRenderObj.renderDefault;
                expectedWidth = customRenderObj.expectedWidth;
                expectedHeight = customRenderObj.expectedHeight;
            }
        }
        else if (customRender) {
            expectedWidth = customRender.expectedWidth;
            expectedHeight = customRender.expectedHeight;
            customElements = customRender.elements;
            renderDefault = customRender.renderDefault;
        }
        if (customElements) {
            const value = table.getCellValue(col, row);
            elementsGroup = adjustElementToGroup(customElements, autoWidth ? expectedWidth : width, autoHeight ? expectedHeight : height, value);
        }
        if (enableCellPadding) {
            elementsGroup.setAttributes({
                x: padding[3],
                y: padding[0],
                width: width - padding[1] - padding[3],
                height: height - padding[0] - padding[2]
            });
        }
        dealPercentCalc(elementsGroup, width, height);
        if (range && (range.start.col !== range.end.col || range.start.row !== range.end.row)) {
            bindAttributeUpdate(elementsGroup, col, row, 0);
        }
        return {
            elementsGroup,
            renderDefault
        };
    }
    function adjustElementToGroup(elements, width, height, value) {
        const customGroup = new Group$2({
            x: 0,
            y: 0,
            width,
            height,
            fill: false,
            stroke: false,
            pickable: false
        });
        customGroup.name = CUSTOM_CONTAINER_NAME;
        const elementsAdjusted = adjustElementsPos(elements, width, height, value);
        elementsAdjusted.forEach(element => {
            if (element.clickable) {
                element.pickable = element.clickable;
            }
            switch (element.type) {
                case 'arc':
                    const arc = createArc({
                        x: element.x,
                        y: element.y,
                        dx: (element.dx ?? 0),
                        dy: (element.dy ?? 0),
                        fill: element.fill,
                        stroke: element.stroke,
                        outerRadius: element.radius,
                        startAngle: element.startAngle,
                        endAngle: element.endAngle,
                        pickable: !!element.pickable,
                        cursor: element.cursor
                    });
                    arc.name = element.name;
                    customGroup.appendChild(arc);
                    break;
                case 'text':
                    if (element.background) {
                        const expandX = element.background?.expandX ?? 0;
                        const expandY = element.background?.expandY ?? 0;
                        const textBackRect = createRect({
                            x: element.x - expandX,
                            y: element.y - expandY,
                            dx: (element.dx ?? 0),
                            dy: (element.dy ?? 0),
                            width: element.width + expandX * 2,
                            height: element.height + expandY * 2,
                            cornerRadius: element.background?.cornerRadius ?? 0,
                            fill: element.background?.fill ?? '#888'
                        });
                        customGroup.appendChild(textBackRect);
                    }
                    const text = new Text$1(Object.assign({
                        pickable: !!element.pickable,
                        fill: element.color ?? element.fill
                    }, element));
                    text.name = element.name;
                    customGroup.appendChild(text);
                    break;
                case 'rect':
                    const rect = createRect({
                        x: element.x,
                        y: element.y,
                        dx: (element.dx ?? 0),
                        dy: (element.dy ?? 0),
                        width: element.width,
                        height: element.height,
                        cornerRadius: element.radius,
                        fill: element.fill,
                        stroke: element.stroke,
                        pickable: !!element.pickable,
                        cursor: element.cursor
                    });
                    rect.name = element.name;
                    customGroup.appendChild(rect);
                    break;
                case 'circle':
                    const circle = createCircle({
                        x: element.x,
                        y: element.y,
                        dx: (element.dx ?? 0),
                        dy: (element.dy ?? 0),
                        radius: element.radius,
                        fill: element.fill,
                        stroke: element.stroke,
                        pickable: !!element.pickable,
                        cursor: element.cursor
                    });
                    circle.name = element.name;
                    customGroup.appendChild(circle);
                    break;
                case 'icon':
                    const icon = new Icon$1({
                        x: element.x,
                        y: element.y,
                        dx: (element.dx ?? 0),
                        dy: (element.dy ?? 0),
                        width: element.width,
                        height: element.height,
                        image: element.svg,
                        backgroundWidth: element.hover ? (element.hover.width ?? element.width) : undefined,
                        backgroundHeight: element.hover ? (element.hover.width ?? element.width) : undefined,
                        backgroundColor: element.hover ? element.hover.bgColor ?? 'rgba(22,44,66,0.2)' : undefined,
                        pickable: !!element.pickable,
                        cursor: element.cursor
                    });
                    icon.name = element.name;
                    icon.role = 'icon-custom';
                    customGroup.appendChild(icon);
                    break;
                case 'image':
                    const image = new Icon$1({
                        x: element.x,
                        y: element.y,
                        dx: (element.dx ?? 0),
                        dy: (element.dy ?? 0),
                        width: element.width,
                        height: element.height,
                        image: element.src,
                        backgroundWidth: element.hover ? (element.hover.width ?? element.width) : undefined,
                        backgroundHeight: element.hover ? (element.hover.width ?? element.width) : undefined,
                        backgroundColor: element.hover ? element.hover.bgColor ?? 'rgba(22,44,66,0.2)' : undefined,
                        pickable: !!element.pickable,
                        cursor: element.cursor,
                        shape: element.shape
                    });
                    image.name = element.name;
                    image.role = 'image-custom';
                    customGroup.appendChild(image);
                    break;
                case 'line':
                    const line = createLine({
                        points: element.points,
                        lineWidth: element.lineWidth ?? 1,
                        stroke: element.stroke,
                        pickable: !!element.pickable,
                        cursor: element.cursor
                    });
                    line.name = element.name;
                    customGroup.appendChild(line);
                    break;
            }
        });
        return customGroup;
    }
    function adjustElementsPos(originalElements, width, height, value) {
        const result = [];
        const left = 0;
        const top = 0;
        const borderLineWidths = [0, 0, 0, 0];
        for (let i = 0; i < originalElements.length; i++) {
            const originalElement = originalElements[i];
            const element = Object.assign({}, originalElement);
            for (const name in element) {
                if (element.hasOwnProperty(name) && isFunction$5(element[name])) {
                    element[name] = element[name](value);
                }
            }
            const rect = element;
            if (isValid$3(rect.x)) {
                rect.x = isString$4(rect.x)
                    ? transformString(rect.x, width - borderLineWidths[1])
                    : Number(rect.x);
            }
            if (isValid$3(rect.y)) {
                rect.y = isString$4(rect.y)
                    ? transformString(rect.y, height - borderLineWidths[2])
                    : Number(rect.y);
            }
            if ('width' in element) {
                element.width = isString$4(element.width)
                    ? transformString(element.width, width - borderLineWidths[1])
                    : Number(element.width);
            }
            if ('height' in element) {
                element.height = isString$4(element.height)
                    ? transformString(element.height, height - borderLineWidths[2])
                    : Number(element.height);
            }
            if ('radius' in element) {
                element.radius = isString$4(element.radius)
                    ? transformString(element.radius, Math.min(width - borderLineWidths[1], height - borderLineWidths[2]))
                    : Number(element.radius);
            }
            if ('hover' in element) {
                element.hover.x = isString$4(element.hover.x)
                    ? transformString(element.hover.x, width - borderLineWidths[1])
                    : Number(element.hover.x);
                element.hover.y = isString$4(element.hover.y)
                    ? transformString(element.hover.y, height - borderLineWidths[2])
                    : Number(element.hover.y);
                element.hover.width = isString$4(element.hover.width)
                    ? transformString(element.hover.width, width - borderLineWidths[1])
                    : Number(element.hover.width);
                element.hover.height = isString$4(element.hover.height)
                    ? transformString(element.hover.height, height - borderLineWidths[2])
                    : Number(element.hover.height);
                element.hover.x += left;
                element.hover.y += top;
            }
            rect.x = rect.x + left;
            rect.y = rect.y + top;
            result.push(element);
        }
        return result;
    }
    function transformString(str, size) {
        if (str.endsWith('px')) {
            return parseInt(str, 10);
        }
        else if (str.endsWith('%') && size) {
            return (parseInt(str, 10) / 100) * size;
        }
        return parseInt(str, 10);
    }
    function dealPercentCalc(group, parentWidth, parentHeight) {
        if (!group) {
            return;
        }
        group.forEachChildren((child) => {
            if (!child) {
                return;
            }
            if (isObject$7(child.attribute.width) && child.attribute.width.percent) {
                child.setAttribute('width', Math.max(0, (child.attribute.width.percent / 100) * parentWidth +
                    (child.attribute.width.delta ?? 0)));
            }
            if (child.attribute.width < 0) {
                child.setAttribute('width', 0);
            }
            if (isObject$7(child.attribute.height) && child.attribute.height.percent) {
                child.setAttribute('height', Math.max(0, (child.attribute.height.percent / 100) * parentHeight +
                    (child.attribute.height.delta ?? 0)));
            }
            if (child.attribute.height < 0) {
                child.setAttribute('height', 0);
            }
            if (child.type === 'group') {
                dealPercentCalc(child, child.attribute.width, child.attribute.height);
            }
        });
    }
    function decodeReactDom(dom, timeline) {
        if (!dom ||
            (!isValid$3(dom.$$typeof) &&
                !isValid$3(dom.vtype))) {
            return dom;
        }
        const type = dom.type;
        const { attribute, children, stateProxy, animation } = dom.props;
        const g = type({ attribute });
        parseToGraphic(g, dom.props);
        if (stateProxy) {
            g.stateProxy = stateProxy;
        }
        g.id = attribute.id;
        g.name = attribute.name;
        if (isArray$7(children)) {
            children.forEach((item) => {
                const c = decodeReactDom(item, timeline);
                c && c.type && g.add(c);
            });
        }
        else if (children) {
            g.add(decodeReactDom(children, timeline));
        }
        if (isArray$7(animation) && timeline) {
            const animate = g.animate();
            animate.setTimeline(timeline);
            animation.forEach((item) => {
                animate[item[0]](...item.slice(1));
            });
        }
        return g;
    }
    function parseToGraphic(g, props) {
        let isGraphic = false;
        switch (g.type) {
            case 'richtext':
                break;
            case 'rich/image':
                break;
            default:
                isGraphic = true;
        }
        if (isGraphic) {
            Object.keys(props).forEach(k => {
                const en = REACT_TO_CANOPUS_EVENTS[k];
                if (en) {
                    g.on(en, props[k]);
                }
            });
        }
    }
    function bindAttributeUpdate(group, col, row, index, preId) {
        if (!group) {
            return;
        }
        group.name = `${CUSTOM_MERGE_PRE_NAME}${preId ?? ''}_${index}`;
        group.onBeforeAttributeUpdate = onBeforeAttributeUpdate$1;
        if (group.type === 'group' && group.childrenCount) {
            group.forEachChildren((child, childIndex) => {
                bindAttributeUpdate(child, col, row, childIndex, (preId ?? '') + '_' + index);
            });
        }
    }
    function onBeforeAttributeUpdate$1(val, attribute) {
        const graphic = this;
        if (graphic.skipMergeUpdate) {
            return;
        }
        const cellGroup = getTargetCell(graphic);
        if (!cellGroup || !cellGroup.stage) {
            return;
        }
        const table = cellGroup.stage.table;
        graphic.skipAttributeUpdate = true;
        const { mergeStartCol, mergeEndCol, mergeStartRow, mergeEndRow } = cellGroup;
        if (isValid$3(mergeStartCol) &&
            isValid$3(mergeEndCol) &&
            isValid$3(mergeStartRow) &&
            isValid$3(mergeEndRow) &&
            (mergeStartCol !== mergeEndCol || mergeStartRow !== mergeEndRow)) {
            for (let col = mergeStartCol; col <= mergeEndCol; col++) {
                for (let row = mergeStartRow; row <= mergeEndRow; row++) {
                    if (col === cellGroup.col && row === cellGroup.row) {
                        continue;
                    }
                    const cell = table.scenegraph.highPerformanceGetCell(col, row);
                    if (cell.role === 'cell') {
                        const target = cell.getChildByName(graphic.name, true);
                        if (!target || target.skipAttributeUpdate) {
                            continue;
                        }
                        for (const key in val) {
                            if (val[key] !== target.attribute[key] && key !== 'dx' && key !== 'dy') {
                                target.setAttribute(key, val[key]);
                            }
                        }
                    }
                }
            }
            graphic.skipAttributeUpdate = undefined;
        }
    }

    let sort_color;
    let sort_color_opacity;
    let sort_color_2;
    let sort_color_opacity_2;
    let sort_size;
    let sort_size_2;
    let frozen_color;
    let frozen_color_opacity;
    let freeze_color_opacity;
    let frozen_color_2;
    let frozen_color_opacity_2;
    let frozen_size;
    let frozen_size_2;
    let collapse_color;
    let collapse_color_opacity;
    let collapse_size;
    let collapse_size_2;
    let expand_color;
    let expand_color_opacity;
    let expand_size;
    let expand_size_2;
    let dragReorder_color;
    let dragReorder_color_opacity;
    let dragReorder_size;
    function setIconColor(themeIconsColor) {
        sort_color = themeIconsColor?.sort_color ?? '#282F38';
        sort_color_opacity = themeIconsColor?.sort_color_opacity ?? '0.35';
        sort_color_2 = themeIconsColor?.sort_color_2 ?? '#416EFF';
        sort_color_opacity_2 = themeIconsColor?.sort_color_opacity_2 ?? '1';
        sort_size = themeIconsColor?.sort_size ?? 16;
        sort_size_2 = themeIconsColor?.sort_size_2 ?? 22;
        frozen_color = themeIconsColor?.frozen_color ?? '#282F38';
        frozen_color_opacity = themeIconsColor?.frozen_color_opacity ?? '0.35';
        freeze_color_opacity = themeIconsColor?.frozen_color_opacity ?? '0.2';
        frozen_color_2 = themeIconsColor?.frozen_color_2 ?? '#416EFF';
        frozen_color_opacity_2 = themeIconsColor?.frozen_color_opacity_2 ?? '1';
        frozen_size = themeIconsColor?.frozen_size ?? 22;
        frozen_size_2 = themeIconsColor?.frozen_size_2 ?? 22;
        collapse_color = themeIconsColor?.collapse_color ?? '#141414';
        collapse_color_opacity = themeIconsColor?.collapse_color_opacity ?? '0.65';
        collapse_size = themeIconsColor?.collapse_size ?? 16;
        collapse_size_2 = themeIconsColor?.frozen_size_2 ?? 22;
        expand_color = themeIconsColor?.expand_color ?? '#141414';
        expand_color_opacity = themeIconsColor?.expand_color_opacity ?? '0.65';
        expand_size = themeIconsColor?.expand_size ?? 16;
        expand_size_2 = themeIconsColor?.expand_size_2 ?? 22;
        dragReorder_color = themeIconsColor?.dragReorder_color ?? '#666666';
        dragReorder_color_opacity = themeIconsColor?.dragReorder_color_opacity ?? '1';
        dragReorder_size = themeIconsColor?.dragReorder_size ?? 20;
    }
    const builtins = {
        get sort_downward() {
            return {
                type: 'svg',
                svg: '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">' +
                    ` <path d="M4.6665 9H11.3332L7.99984 13.1667L4.6665 9Z" fill="${sort_color_2}"  fill-opacity="${sort_color_opacity_2}"/>` +
                    `<path d="M11.3335 7L4.66683 7L8.00016 2.83333L11.3335 7Z" fill="${sort_color}" fill-opacity="${sort_color_opacity}"/>` +
                    '</svg> ',
                width: sort_size,
                height: sort_size,
                funcType: IconFuncTypeEnum.sort,
                name: 'sort_downward',
                positionType: IconPosition.contentRight,
                marginLeft: 3,
                hover: {
                    width: sort_size_2,
                    height: sort_size_2,
                    bgColor: 'rgba(101, 117, 168, 0.1)'
                },
                cursor: 'pointer'
            };
        },
        get sort_upward() {
            return {
                type: 'svg',
                svg: '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">' +
                    `<path d="M4.6665 9H11.3332L7.99984 13.1667L4.6665 9Z" fill="${sort_color}"  fill-opacity="${sort_color_opacity}"/>` +
                    `<path d="M11.3335 7L4.66683 7L8.00016 2.83333L11.3335 7Z" fill="${sort_color_2}"  fill-opacity="${sort_color_opacity_2}"/>` +
                    ' </svg>',
                width: sort_size,
                height: sort_size,
                funcType: IconFuncTypeEnum.sort,
                positionType: IconPosition.contentRight,
                name: 'sort_upward',
                marginLeft: 3,
                hover: {
                    width: sort_size_2,
                    height: sort_size_2,
                    bgColor: 'rgba(101, 117, 168, 0.1)'
                },
                cursor: 'pointer'
            };
        },
        get sort_normal() {
            return {
                type: 'svg',
                svg: '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">' +
                    `<path d="M4.6665 9H11.3332L7.99984 13.1667L4.6665 9Z" fill="${sort_color}" fill-opacity="${sort_color_opacity}"/>` +
                    `<path d="M11.3335 7L4.66683 7L8.00016 2.83333L11.3335 7Z" fill="${sort_color}" fill-opacity="${sort_color_opacity}"/>` +
                    '</svg> ',
                width: sort_size,
                height: sort_size,
                funcType: IconFuncTypeEnum.sort,
                positionType: IconPosition.contentRight,
                name: 'sort_normal',
                marginLeft: 3,
                hover: {
                    width: sort_size_2,
                    height: sort_size_2,
                    bgColor: 'rgba(101, 117, 168, 0.1)'
                },
                cursor: 'pointer'
            };
        },
        get freeze() {
            return {
                type: 'svg',
                svg: '<svg width="22" height="22" viewBox="0 0 22 22" fill="none" xmlns="http://www.w3.org/2000/svg">' +
                    '<g clip-path="url(#clip0)">' +
                    `<path d="M17.1313 8.42047C17.1932 8.48238 17.2423 8.55587 17.2759 8.63676C17.3094 8.71764 17.3266 8.80434 17.3266 8.89189C17.3266 8.97944 17.3094 9.06613 17.2759 9.14702C17.2423 9.2279 17.1932 9.3014 17.1313 9.3633L13.3843 13.1103C13.7007 14.3048 13.5305 15.4443 12.8388 16.2395C12.8104 16.2781 12.7778 16.3136 12.7417 16.3451L12.712 16.3755C12.6501 16.4374 12.5766 16.4865 12.4957 16.52C12.4148 16.5535 12.3281 16.5707 12.2406 16.5707C12.153 16.5707 12.0663 16.5535 11.9854 16.52C11.9046 16.4865 11.8311 16.4374 11.7692 16.3755L9.17633 13.7826L6.05316 16.9058L5.11983 17.0925C5.09291 17.0979 5.06508 17.0965 5.03881 17.0886C5.01254 17.0806 4.98863 17.0663 4.96923 17.0469C4.94982 17.0275 4.9355 17.0036 4.92755 16.9773C4.9196 16.951 4.91827 16.9232 4.92366 16.8963L5.11033 15.963L8.23333 12.8396L5.64066 10.2471C5.57875 10.1852 5.52964 10.1117 5.49614 10.0309C5.46263 9.94997 5.44539 9.86327 5.44539 9.77572C5.44539 9.68817 5.46263 9.60148 5.49614 9.52059C5.52964 9.43971 5.57875 9.36621 5.64066 9.3043C5.65066 9.2943 5.66066 9.2843 5.67099 9.27464C5.70266 9.2383 5.73833 9.20547 5.77766 9.17664C6.57283 8.48564 7.71199 8.31564 8.90599 8.63197L12.6528 4.88497C12.7147 4.82306 12.7882 4.77395 12.8691 4.74045C12.95 4.70694 13.0367 4.6897 13.1242 4.6897C13.2118 4.6897 13.2985 4.70694 13.3794 4.74045C13.4603 4.77395 13.5338 4.82306 13.5957 4.88497L17.1312 8.42047H17.1313ZM15.7172 8.8918L13.1243 6.29914L9.56483 9.8588C9.47574 9.94788 9.36323 10.0099 9.24034 10.0376C9.11746 10.0654 8.98922 10.0578 8.87049 10.0156C8.22783 9.78764 7.63899 9.7553 7.17749 9.89814L12.1182 14.8388C12.261 14.3771 12.2287 13.7885 12.0007 13.146C11.9585 13.0272 11.9509 12.899 11.9787 12.7761C12.0064 12.6532 12.0684 12.5407 12.1575 12.4516L15.7172 8.89164V8.8918Z" fill="${frozen_color}" fill-opacity="${freeze_color_opacity}"/>` +
                    '</g>' +
                    '<defs>' +
                    '<clipPath id="clip0">' +
                    '<rect width="22" height="22" fill="white"/>' +
                    '</clipPath>' +
                    '</defs>' +
                    '</svg>',
                width: frozen_size,
                height: frozen_size,
                name: 'freeze',
                funcType: IconFuncTypeEnum.frozen,
                positionType: IconPosition.right,
                marginRight: 0,
                hover: {
                    width: frozen_size_2,
                    height: frozen_size_2,
                    bgColor: 'rgba(101, 117, 168, 0.1)'
                },
                cursor: 'pointer'
            };
        },
        get frozen() {
            return {
                type: 'svg',
                svg: '<svg width="22" height="22" viewBox="0 0 22 22" fill="none" xmlns="http://www.w3.org/2000/svg">' +
                    `<path d="M8.49975 3.66663C8.32294 3.66663 8.15337 3.73686 8.02835 3.86189C7.90332 3.98691 7.83309 4.15648 7.83309 4.33329V9.63246C6.76475 10.2533 6.07942 11.1795 6.00625 12.2308C5.99892 12.2786 5.99692 12.3268 6.00009 12.3741L5.99975 12.4166C5.99975 12.5934 6.06999 12.763 6.19501 12.888C6.32004 13.0131 6.48961 13.0833 6.66642 13.0833H10.3333L10.3331 17.5L10.8611 18.292C10.8763 18.3148 10.8969 18.3335 10.9211 18.3464C10.9453 18.3594 10.9723 18.3662 10.9998 18.3662C11.0272 18.3662 11.0542 18.3594 11.0784 18.3464C11.1026 18.3335 11.1232 18.3148 11.1384 18.292L11.6664 17.5L11.6666 13.0833H15.3331C15.5099 13.0833 15.6795 13.0131 15.8045 12.888C15.9295 12.763 15.9998 12.5934 15.9998 12.4166C15.9998 12.4025 15.9998 12.3883 15.9994 12.3741C16.0028 12.3263 16.0008 12.2776 15.9933 12.2295C15.9196 11.1786 15.2343 10.2528 14.1664 9.63229V4.33329C14.1664 4.15648 14.0962 3.98691 13.9712 3.86189C13.8461 3.73686 13.6766 3.66663 13.4998 3.66663H8.49975Z" fill="${frozen_color}" fill-opacity="${frozen_color_opacity}"/>` +
                    '</svg>',
                width: frozen_size,
                height: frozen_size,
                name: 'frozen',
                funcType: IconFuncTypeEnum.frozen,
                positionType: IconPosition.right,
                marginRight: 0,
                hover: {
                    width: frozen_size_2,
                    height: frozen_size_2,
                    bgColor: 'rgba(101, 117, 168, 0.1)'
                },
                cursor: 'pointer'
            };
        },
        get frozenCurrent() {
            return {
                type: 'svg',
                svg: '<svg width="22" height="22" viewBox="0 0 22 22" fill="none" xmlns="http://www.w3.org/2000/svg">' +
                    `<path d="M8.49975 3.66663C8.32294 3.66663 8.15337 3.73686 8.02835 3.86189C7.90332 3.98691 7.83309 4.15648 7.83309 4.33329V9.63246C6.76475 10.2533 6.07942 11.1795 6.00625 12.2308C5.99892 12.2786 5.99692 12.3268 6.00009 12.3741L5.99975 12.4166C5.99975 12.5934 6.06999 12.763 6.19501 12.888C6.32004 13.0131 6.48961 13.0833 6.66642 13.0833H10.3333L10.3331 17.5L10.8611 18.292C10.8763 18.3148 10.8969 18.3335 10.9211 18.3464C10.9453 18.3594 10.9723 18.3662 10.9998 18.3662C11.0272 18.3662 11.0542 18.3594 11.0784 18.3464C11.1026 18.3335 11.1232 18.3148 11.1384 18.292L11.6664 17.5L11.6666 13.0833H15.3331C15.5099 13.0833 15.6795 13.0131 15.8045 12.888C15.9295 12.763 15.9998 12.5934 15.9998 12.4166C15.9998 12.4025 15.9998 12.3883 15.9994 12.3741C16.0028 12.3263 16.0008 12.2776 15.9933 12.2295C15.9196 11.1786 15.2343 10.2528 14.1664 9.63229V4.33329C14.1664 4.15648 14.0962 3.98691 13.9712 3.86189C13.8461 3.73686 13.6766 3.66663 13.4998 3.66663H8.49975Z"  fill="${frozen_color_2}" fill-opacity="${frozen_color_opacity_2}"/>` +
                    '</svg>',
                width: frozen_size,
                height: frozen_size,
                funcType: IconFuncTypeEnum.frozen,
                positionType: IconPosition.right,
                name: 'frozenCurrent',
                marginRight: 0,
                hover: {
                    width: frozen_size_2,
                    height: frozen_size_2,
                    bgColor: 'rgba(101, 117, 168, 0.1)'
                },
                cursor: 'pointer'
            };
        },
        get dropdownIcon() {
            return {
                type: 'svg',
                svg: '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><g><rect x="2" y="1" width="20" height="20" rx="10" fill="white"/><rect x="2.5" y="1.5" width="19" height="19" rx="9.5" stroke="#959DA5"/></g><path d="M14.9492 9.39531C15.0086 9.31911 15.0165 9.21887 14.9698 9.1356C14.923 9.05234 14.8294 9 14.7273 9L9.27273 9C9.17057 9 9.07697 9.05234 9.03023 9.1356C8.98348 9.21887 8.99142 9.31911 9.0508 9.39531L11.7781 12.8953C11.8293 12.961 11.9119 13 12 13C12.0881 13 12.1707 12.961 12.2219 12.8953L14.9492 9.39531Z" fill="#4F5965"/></svg>',
                width: 24,
                height: 24,
                funcType: IconFuncTypeEnum.dropDown,
                positionType: IconPosition.absoluteRight,
                name: 'dropdownIcon',
                marginRight: 0,
                hover: {
                    width: 24,
                    height: 24,
                    bgColor: 'rgba(101, 117, 168, 0.1)',
                    image: '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><g><rect x="2" y="1" width="20" height="20" rx="10" fill="#1E54C9"/><rect x="2.5" y="1.5" width="19" height="19" rx="9.5" stroke="#141414" stroke-opacity="0.2"/></g><path d="M14.9492 9.39531C15.0086 9.31911 15.0165 9.21887 14.9698 9.1356C14.923 9.05234 14.8294 9 14.7273 9L9.27273 9C9.17057 9 9.07697 9.05234 9.03023 9.1356C8.98348 9.21887 8.99142 9.31911 9.0508 9.39531L11.7781 12.8953C11.8293 12.961 11.9119 13 12 13C12.0881 13 12.1707 12.961 12.2219 12.8953L14.9492 9.39531Z" fill="white"/></svg>'
                },
                cursor: 'pointer',
                visibleTime: 'mouseenter_cell'
            };
        },
        get play() {
            return {
                type: 'svg',
                svg: '<svg width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><rect width="48" height="48" fill="white" fill-opacity="0.01" /><path d="M24 44C35.0457 44 44 35.0457 44 24C44 12.9543 35.0457 4 24 4C12.9543 4 4 12.9543 4 24C4 35.0457 12.9543 44 24 44Z" fill="none" stroke="#686a6e" stroke-width="4" stroke-linejoin="round" stroke-opacity="0.7" /><path d="M20 24V17.0718L26 20.5359L32 24L26 27.4641L20 30.9282V24Z" fill="none" stroke="#686a6e" stroke-width="4" stroke-linejoin="round" stroke-opacity="0.7" /></svg>',
                width: 24,
                height: 24,
                funcType: IconFuncTypeEnum.play,
                positionType: IconPosition.right,
                name: 'play',
                marginRight: 0,
                hover: {
                    width: 24,
                    height: 24,
                    bgColor: 'rgba(101, 117, 168, 0.1)'
                },
                cursor: 'pointer'
            };
        },
        get damage_pic() {
            return {
                type: 'svg',
                svg: '<svg width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M5 10V38C5 39.1046 5.89543 40 7 40H14H18L15 29L22 27L21 20L29 16L27 13L30 8H7C5.89543 8 5 8.89543 5 10Z" fill="none" stroke="#333" stroke-width="4" stroke-linecap="round" stroke-linejoin="round"/><path d="M43 38V10C43 8.89543 42.1046 8 41 8H38L34 14L37 19L28 23L29 31L22 33L24 40H41C42.1046 40 43 39.1046 43 38Z" fill="none" stroke="#333" stroke-width="4" stroke-linecap="round" stroke-linejoin="round"/><path fill-rule="evenodd" clip-rule="evenodd" d="M14.5 18C15.3284 18 16 17.3284 16 16.5C16 15.6716 15.3284 15 14.5 15C13.6716 15 13 15.6716 13 16.5C13 17.3284 13.6716 18 14.5 18Z" fill="none" stroke="#333" stroke-width="4" stroke-linecap="round" stroke-linejoin="round"/></svg>',
                width: 24,
                height: 24,
                funcType: IconFuncTypeEnum.damagePic,
                positionType: IconPosition.left,
                name: 'damage_pic',
                marginRight: 0,
                hover: {
                    width: 24,
                    height: 24,
                    bgColor: 'rgba(101, 117, 168, 0.1)'
                },
                cursor: 'pointer'
            };
        },
        get loading_pic() {
            return {
                type: 'svg',
                svg: '<svg viewBox="0 0 400 300" fill="none" xmlns="http://www.w3.org/2000/svg"><mask id="a" style="mask-type:alpha" maskUnits="userSpaceOnUse" x="50" y="65" width="301" height="170"><path d="M350.3 65H50v169.8h300.3V65Z" fill="#fff"/></mask><g mask="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M58.3 233.2h32.8v-36.8H58.3v36.8Z" fill="#C7DEFF"/><path d="M91.1 224.5v8.8H58.3M82.4 196.2H58.3" stroke="#071F4D"/><path fill-rule="evenodd" clip-rule="evenodd" d="M305.4 182.5s-2.7 12.6 0 17.4c2.7 4.8 8.3 6.7 12.4 4.4 4.2-2.4 5.3-8.1 2.6-12.9-2.7-4.8-15-8.9-15-8.9ZM336 204.7c4.3 2 9.7-.4 12-5.4 2.3-5-1.5-17.3-1.5-17.3s-11.8 5.1-14.1 10.1c-2.3 5-.7 10.6 3.6 12.6Z" fill="#00E4E5"/><path fill-rule="evenodd" clip-rule="evenodd" d="M326.7 174s-10 11.8-10 18.6c0 6.7 4.5 12.2 10 12.2s10-5.5 10-12.3c0-6.8-10-18.5-10-18.5Z" fill="#00E4E5"/><path d="M332.3 181.5c2.3 3.6 4.4 7.8 4.4 10.9M316.7 192.5c0-3.1 2.1-7.2 4.3-10.8" stroke="#071F4D"/><path fill-rule="evenodd" clip-rule="evenodd" d="M343.1 227.3v-9.7h-34v9.7c0 3.7 3 6.6 6.6 6.6h20.9c3.6 0 6.5-2.9 6.5-6.6Z" fill="#071F4D"/><path fill-rule="evenodd" clip-rule="evenodd" d="M350.4 220.8V198H302v22.8c0 5.9 4.8 10.7 10.7 10.7h26.9c5.9 0 10.7-4.8 10.8-10.7Z" fill="#C7DEFF"/><path fill-rule="evenodd" clip-rule="evenodd" d="M331.7 74.2H117.8L87.4 203h213.8l30.5-128.8Z" fill="#fff"/><path fill-rule="evenodd" clip-rule="evenodd" d="M337 74.2h-6.2l-30.6 129.2h6.2L337 74.2Z" fill="#fff"/><path fill-rule="evenodd" clip-rule="evenodd" d="M303.8 203.5h2.4l30.7-129.3h-1.8l-31.3 129.3Z" fill="#C7DEFF"/><path d="m337 74.2-30.6 129.2h-5.9" stroke="#071F4D"/><path fill-rule="evenodd" clip-rule="evenodd" d="M229.9 202.1h-47.6l2 9.6h47.3l-1.7-9.6Z" fill="#C7DEFF"/><path fill-rule="evenodd" clip-rule="evenodd" d="M94.7 172.6 87.4 203h213.1l7.8-30.4H94.7Z" fill="#006EFF"/><path fill-rule="evenodd" clip-rule="evenodd" d="M94.7 172.6 87.4 203h213.1l7.8-30.4H94.7Z" fill="#006EFF"/><path d="M138.5 74.2h193.2l-23.4 98.6M94.5 172.7l11-46.3M104.8 155.4l-2.3 11.5h6.7M316 112.1l1.1-4.5" stroke="#071F4D"/><path fill-rule="evenodd" clip-rule="evenodd" d="M148.3 138.1h97V119h-97v19.1Z" fill="#00E4E5"/><path d="M303.1 80.6h20.3l-4.6 19.6M228.3 234.3c3.6 0 6.3-3.2 5.7-6.8l-4.1-24.1" stroke="#071F4D"/><path fill-rule="evenodd" clip-rule="evenodd" d="M226.2 229.5h-68.9v1.2c0 2 1.6 3.7 3.7 3.7h60.1c2.8 0 5-2.2 5.1-4.9Z" fill="#C7DEFF"/><path d="M180.699 226.8h-19.9c-2.8 0-4.6 3-3.3 5.5m0 0c.6 1.2 1.9 2 3.3 2h57.8M175.9 203.4l3.6 17.6M241.2 234.3h65.1M104.6 234.3h41.3" stroke="#071F4D"/><path d="M206.2 234.3h14.9c3.1 0 5.5-2.8 5-5.9l-4.3-24.9M160.7 226.8h46M62.2 226.1h-9.5c-1.2 0-2.2-1-2.2-2.2v-18.3c0-1.2 1-2.2 2.2-2.2h9.5" stroke="#071F4D"/><path d="M53.4 171.7H68c2.1 0 3.7 1.7 3.7 3.7v16.1M79.1 192v-21.8c0-2.5 2-4.6 4.6-4.6h2.2c2.5 0 4.5-2 4.5-4.5m0 0c0-2.5-2-4.5-4.5-4.5H56.1c-2.4 0-4.3-1.9-4.3-4.3V148M71.2 165.2h-18M64 181.7v10.1" stroke="#C7DEFF"/><path fill-rule="evenodd" clip-rule="evenodd" d="M85.7 120H124c4.3 0 7.7-3.5 7.7-7.7V65.5H94.2c-4.7 0-8.5 4.9-8.5 11V120Z" fill="#C7DEFF"/><path d="M85.7 110.7V73c0-4.1 3.4-7.5 7.5-7.5h38.5M146.2 73.8v-2.5c0-3.2-2-5.8-5.8-5.8-2.8 0-6 1.1-6 5.8v42.4c0 4.7-3.8 8.5-8.5 8.5h-15.6" stroke="#071F4D"/><path d="M119.7 122.3H87c-6.1 0-11.1-5-11.1-11.1m0 0h39M126.1 122.3c-6.1 0-11.1-5-11.1-11.1" stroke="#071F4D"/><path fill-rule="evenodd" clip-rule="evenodd" d="M85.4 122.1h37.2c-6.5-1.8-8-10.5-8-10.5H76.2c.6 8.8 9.2 10.5 9.2 10.5Z" fill="#071F4D"/><path fill-rule="evenodd" clip-rule="evenodd" d="M95.8 102.9h4.8V83.6h-4.8v19.3ZM106.6 102.9h4.8V77.6h-4.8v25.3ZM117.3 102.9h4.8V89.1h-4.8v13.8Z" fill="#fff"/><path d="M273.2 195.9h16.9M261.2 195.9h5" stroke="#fff"/><path d="M62.4 201.9v2.9M62.4 224.5v2.9" stroke="#071F4D"/><path d="m153.6 138.1 9.7-19.1M168.8 138.1l9.7-19.1M184.1 138.1l9.7-19.1M199.4 138.1l9.7-19.1M214.6 138.1l9.8-19.1M229.9 138.1l9.7-19.1" stroke="#fff"/><path d="M148.3 138.1h121.6V119H148.3v19.1Z" stroke="#071F4D"/></g></svg>',
                width: 400,
                height: 300,
                name: 'loading_pic',
                positionType: IconPosition.left
            };
        },
        get expand() {
            return {
                type: 'svg',
                svg: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none">
      <path d="M4.64988 6.81235C4.38797 6.48497 4.62106 6 5.04031 6L10.9597 6C11.3789 6 11.612 6.48497 11.3501 6.81235L8.39043 10.512C8.19027 10.7622 7.80973 10.7622 7.60957 10.512L4.64988 6.81235Z" fill="${expand_color}" fill-opacity="${expand_color_opacity}"/>
      </svg>`,
                width: expand_size,
                height: expand_size,
                funcType: IconFuncTypeEnum.expand,
                name: 'expand',
                positionType: IconPosition.contentLeft,
                marginLeft: 0,
                marginRight: 4,
                hover: {
                    width: expand_size_2,
                    height: expand_size_2,
                    bgColor: 'rgba(101, 117, 168, 0.1)'
                },
                cursor: 'pointer'
            };
        },
        get collapse() {
            return {
                type: 'svg',
                svg: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none">
      <path d="M5.81235 11.3501C5.48497 11.612 5 11.3789 5 10.9597L5 5.04031C5 4.62106 5.48497 4.38797 5.81235 4.64988L9.51196 7.60957C9.76216 7.80973 9.76216 8.19027 9.51196 8.39044L5.81235 11.3501Z"  fill="${collapse_color}" fill-opacity="${collapse_color_opacity}"/>
      </svg>`,
                width: collapse_size,
                height: collapse_size,
                funcType: IconFuncTypeEnum.collapse,
                name: 'collapse',
                positionType: IconPosition.contentLeft,
                marginLeft: 0,
                marginRight: 4,
                hover: {
                    width: collapse_size_2,
                    height: collapse_size_2,
                    bgColor: 'rgba(101, 117, 168, 0.1)'
                },
                cursor: 'pointer'
            };
        },
        get drillDown() {
            return {
                name: 'drillDown',
                type: 'svg',
                positionType: IconPosition.absolute,
                funcType: IconFuncTypeEnum.drillDown,
                svg: DrillDown,
                width: 13,
                height: 13,
                cursor: 'pointer'
            };
        },
        get drillUp() {
            return {
                name: 'drillUp',
                type: 'svg',
                positionType: IconPosition.absolute,
                funcType: IconFuncTypeEnum.drillUp,
                svg: DrillUp,
                width: 13,
                height: 13,
                cursor: 'pointer'
            };
        },
        get dragReorder() {
            return {
                type: 'svg',
                svg: `<svg t="1710129136961" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5166" width="200" height="200"><path d="M362.666667 192m-64 0a64 64 0 1 0 128 0 64 64 0 1 0-128 0Z" fill="${dragReorder_color}"  fill-opacity="${dragReorder_color_opacity}" p-id="5167"></path><path d="M661.333333 192m-64 0a64 64 0 1 0 128 0 64 64 0 1 0-128 0Z" fill="${dragReorder_color}"  fill-opacity="${dragReorder_color_opacity}" p-id="5168"></path><path d="M362.666667 512m-64 0a64 64 0 1 0 128 0 64 64 0 1 0-128 0Z" fill="${dragReorder_color}"  fill-opacity="${dragReorder_color_opacity}" p-id="5169"></path><path d="M661.333333 512m-64 0a64 64 0 1 0 128 0 64 64 0 1 0-128 0Z" fill="${dragReorder_color}"  fill-opacity="${dragReorder_color_opacity}" p-id="5170"></path><path d="M362.666667 832m-64 0a64 64 0 1 0 128 0 64 64 0 1 0-128 0Z" fill="${dragReorder_color}"  fill-opacity="${dragReorder_color_opacity}" p-id="5171"></path><path d="M661.333333 832m-64 0a64 64 0 1 0 128 0 64 64 0 1 0-128 0Z" fill="${dragReorder_color}"  fill-opacity="${dragReorder_color_opacity}" p-id="5172"></path></svg>`,
                width: dragReorder_size,
                height: dragReorder_size,
                funcType: IconFuncTypeEnum.dragReorder,
                positionType: IconPosition.left,
                name: 'dragReorder',
                marginLeft: -10,
                marginRight: 10,
                cursor: 'grab'
            };
        }
    };
    const icons = {};
    function get$2() {
        return extend(builtins, icons);
    }

    let Group$1 = class Group extends Group$2 {
        role;
        col;
        row;
        mergeStartCol;
        mergeStartRow;
        mergeEndCol;
        mergeEndRow;
        contentWidth;
        contentHeight;
        rowNumber;
        colHeight;
        border;
        needUpdate;
        needUpdateWidth;
        needUpdateHeight;
        clear() {
            this.removeAllChild();
        }
        getChildByName(name, deep) {
            let result = null;
            this.forEachChildren((child) => {
                if (child.name === name) {
                    result = child;
                    return true;
                }
                return false;
            });
            if (deep) {
                this.forEachChildren((child) => {
                    if (child.getChildByName) {
                        const target = child.getChildByName(name, true);
                        if (target) {
                            result = target;
                            return true;
                        }
                    }
                    return false;
                });
            }
            return result;
        }
        get width() {
            let width = this.AABBBounds.width();
            if (width === Infinity || width === -Infinity) {
                width = 0;
            }
            return Math.max(width, this.attribute.width ?? 0);
        }
        get height() {
            let height = this.AABBBounds.height();
            if (height === Infinity || height === -Infinity) {
                height = 0;
            }
            return Math.max(height, this.attribute.height ?? 0);
        }
        setDeltaWidth(deltaX) {
            if (deltaX === 0) {
                return;
            }
            this.setAttribute('width', (this.attribute.width ?? 0) + deltaX);
            if (this.border) {
                this.border.setAttribute('width', this.border.attribute.width + deltaX);
                if (this.border.type === 'group') {
                    this.border.firstChild.setAttribute('width', this.border.firstChild.attribute.width + deltaX);
                }
            }
        }
        setDeltaHeight(deltaY) {
            if (deltaY === 0) {
                return;
            }
            this.setAttribute('height', (this.attribute.height ?? 0) + deltaY);
            if (this.border) {
                this.border.setAttribute('height', this.border.attribute.height + deltaY);
                if (this.border.type === 'group') {
                    this.border.firstChild.setAttribute('width', this.border.firstChild.attribute.height + deltaY);
                }
            }
        }
        setDeltaX(deltaX) {
            if (deltaX === 0) {
                return;
            }
            this.setAttribute('x', this.attribute.x + deltaX);
        }
        setDeltaY(deltaY) {
            if (deltaY === 0) {
                return;
            }
            this.setAttribute('y', this.attribute.y + deltaY);
        }
        forEachChildrenSkipChild(cb, skipChildName = 'border-rect', reverse = false) {
            if (reverse) {
                let child = this._lastChild;
                let i = 0;
                while (child) {
                    if (child.name !== skipChildName) {
                        const breakTag = cb(child, i++);
                        if (breakTag) {
                            return;
                        }
                    }
                    child = child._prev;
                }
            }
            else {
                let child = this._firstChild;
                let i = 0;
                while (child) {
                    if (child.name !== skipChildName) {
                        const breakTag = cb(child, i++);
                        if (breakTag) {
                            return;
                        }
                    }
                    child = child._next;
                }
            }
        }
        getColGroup(col) {
            let c = this._firstChild;
            if (!c) {
                return null;
            }
            for (let i = 0; i < this.childrenCount; i++) {
                if (c.col === col) {
                    return c;
                }
                c = c._next;
            }
            return null;
        }
        getRowGroup(row) {
            let c = this._firstChild;
            if (!c) {
                return null;
            }
            for (let i = 0; i < this.childrenCount; i++) {
                if (c.row === row) {
                    return c;
                }
                c = c._next;
            }
            return null;
        }
        addCellGroup(cellGroup) {
            if (this.childrenCount === 0 || this.lastChild.row === cellGroup.row - 1) {
                this.addChild(cellGroup);
            }
            else {
                let c = this._firstChild;
                for (let i = 0; i < this.childrenCount; i++) {
                    if (c.row === cellGroup.row - 1) {
                        this.insertAfter(cellGroup, c);
                        return;
                    }
                    c = c._next;
                }
                this.addChild(cellGroup);
            }
        }
        getChildAt(index) {
            const child = super.getChildAt(index);
            if (child && child.name === 'border-rect') {
                return child._next;
            }
            return child;
        }
        tryUpdateAABBBounds() {
            if (this.role === 'cell') {
                if (!this.shouldUpdateAABBBounds()) {
                    return this._AABBBounds;
                }
                const selfChange = this.shouldSelfChangeUpdateAABBBounds();
                const bounds = this.doUpdateAABBBounds();
                this.addUpdateLayoutTag();
                after(this, selfChange);
                return bounds;
            }
            return super.tryUpdateAABBBounds();
        }
        doUpdateAABBBounds() {
            if (this.role === 'cell') {
                const attribute = this.attribute;
                const { x, y, width, height } = attribute;
                this._AABBBounds.setValue(x, y, x + width, y + height);
                this.parent && this.parent.addChildUpdateBoundTag();
                this.clearUpdateBoundTag();
                if (this.shadowRoot) {
                    this.shadowRoot.tryUpdateAABBBounds();
                }
                return this._AABBBounds;
            }
            else if (this.role === 'body' ||
                this.role === 'row-header' ||
                this.role === 'col-header' ||
                this.role === 'right-frozen' ||
                this.role === 'bottom-frozen' ||
                this.role === 'corner-header' ||
                this.role === 'corner-right-top-header' ||
                this.role === 'corner-right-bottom-header' ||
                this.role === 'corner-left-bottom-header') {
                this._AABBBounds.setValue(-Infinity, -Infinity, Infinity, Infinity);
                this.parent && this.parent.addChildUpdateBoundTag();
                this.clearUpdateBoundTag();
                if (this.shadowRoot) {
                    this.shadowRoot.tryUpdateAABBBounds();
                }
                return this._AABBBounds;
            }
            return super.doUpdateAABBBounds();
        }
        updateColumnRowNumber(row) {
            if (!this.rowNumber) {
                this.rowNumber = row;
            }
            else {
                this.rowNumber = Math.max(this.rowNumber, row);
            }
        }
        updateColumnHeight(cellHeight) {
            if (!this.colHeight) {
                this.colHeight = cellHeight;
            }
            else {
                this.colHeight += cellHeight;
            }
        }
    };
    function after(group, selfChange) {
        if (!group.stage || !group.stage.dirtyBounds || !group.stage.renderCount) {
            return;
        }
        if (group.isContainer && !selfChange) {
            return;
        }
        group.stage.dirty(group.globalAABBBounds);
    }

    function calcKeepAspectRatioSize(width, height, maxWidth, maxHeight) {
        const rectWidth = width;
        const rectHeight = height;
        const containerWidth = maxWidth;
        const containerHeight = maxHeight;
        const containerRatio = containerWidth / containerHeight;
        const rectRatio = rectWidth / rectHeight;
        let newWidth;
        let newHeight;
        if (rectRatio > containerRatio) {
            newWidth = containerWidth;
            newHeight = newWidth / rectRatio;
        }
        else {
            newHeight = containerHeight;
            newWidth = newHeight * rectRatio;
        }
        return {
            width: newWidth,
            height: newHeight
        };
    }

    function calcStartPosition(left, top, width, height, contentWidth, contentHeight, textAlign = 'left', textBaseline = 'middle', margin = [0, 0, 0, 0], paddingLeft = 0, paddingRight = 0, paddingTop = 0, paddingBottom = 0) {
        const right = left + width;
        const bottom = top + height;
        let x = left + margin[3] + paddingLeft;
        if (textAlign === 'right' || textAlign === 'end') {
            x = right - contentWidth - margin[1] - paddingRight;
        }
        else if (textAlign === 'center') {
            x = left + (width - contentWidth + paddingLeft - paddingRight) / 2;
        }
        let y = top + margin[0] + paddingTop;
        if (textBaseline === 'bottom' || textBaseline === 'alphabetic' || textBaseline === 'ideographic') {
            y = bottom - contentHeight - margin[2] - paddingBottom;
        }
        else if (textBaseline === 'middle') {
            y = top + (height - contentHeight + paddingTop - paddingBottom) / 2;
        }
        return { x, y };
    }

    function getProp(name, cellStyle, col, row, _table) {
        const prop = cellStyle && isValid$3(cellStyle[name]) ? cellStyle[name] : undefined;
        if (typeof prop === 'function') {
            const arg = {
                col,
                row,
                table: _table,
                value: _table.getCellValue(col, row),
                dataValue: _table.getCellOriginValue(col, row),
                cellHeaderPaths: _table.getCellHeaderPaths(col, row)
            };
            return prop(arg);
        }
        return prop;
    }
    function getFunctionalProp(name, cellStyle, col, row, _table) {
        const prop = cellStyle && isValid$3(cellStyle[name]) ? cellStyle[name] : undefined;
        if (typeof prop === 'function') {
            const arg = {
                col,
                row,
                table: _table,
                value: _table.getCellValue(col, row),
                dataValue: _table.getCellOriginValue(col, row),
                cellHeaderPaths: _table.getCellHeaderPaths(col, row)
            };
            return prop(arg);
        }
        return undefined;
    }

    function getCellBorderStrokeWidth(col, row, cellTheme, table) {
        let strokeArrayWidth = cellTheme?.group?.strokeArrayWidth ?? undefined;
        if (table.theme.cellInnerBorder ||
            !isValidStyle(table.theme.frameStyle.borderLineWidth) ||
            isZeroStyle(table.theme.frameStyle.borderLineWidth)) {
            return strokeArrayWidth;
        }
        if (col === 0) {
            strokeArrayWidth = strokeArrayWidth ?? [
                cellTheme?.group?.lineWidth,
                cellTheme?.group?.lineWidth,
                cellTheme?.group?.lineWidth,
                cellTheme?.group?.lineWidth
            ];
            strokeArrayWidth[3] = 0;
        }
        if (col === table.colCount - 1) {
            strokeArrayWidth = strokeArrayWidth ?? [
                cellTheme?.group?.lineWidth,
                cellTheme?.group?.lineWidth,
                cellTheme?.group?.lineWidth,
                cellTheme?.group?.lineWidth
            ];
            strokeArrayWidth[1] = 0;
        }
        if (row === 0) {
            strokeArrayWidth = strokeArrayWidth ?? [
                cellTheme?.group?.lineWidth,
                cellTheme?.group?.lineWidth,
                cellTheme?.group?.lineWidth,
                cellTheme?.group?.lineWidth
            ];
            strokeArrayWidth[0] = 0;
        }
        if (row === table.rowCount - 1) {
            strokeArrayWidth = strokeArrayWidth ?? [
                cellTheme?.group?.lineWidth,
                cellTheme?.group?.lineWidth,
                cellTheme?.group?.lineWidth,
                cellTheme?.group?.lineWidth
            ];
            strokeArrayWidth[2] = 0;
        }
        return strokeArrayWidth;
    }

    class CellContent extends Group$1 {
        _leftGroup;
        _rightGroup;
        _centerGroup;
        _autoWidth = false;
        _autoHeight = false;
        _cellWidth;
        _originCellWidth;
        _cellHeight;
        _align;
        _baseline;
        constructor(params) {
            super(params);
            this._leftGroup = new Group$1({
                pickable: false,
                fill: false,
                stroke: false
            });
            this._leftGroup.role = 'content-left';
            this._rightGroup = new Group$1({
                pickable: false,
                fill: false,
                stroke: false
            });
            this._rightGroup.role = 'content-right';
            this._centerGroup = new Group$1({
                pickable: false,
                fill: false,
                stroke: false
            });
            this._centerGroup.role = 'content-center';
            this.appendChild(this._leftGroup);
            this.appendChild(this._rightGroup);
            this.appendChild(this._centerGroup);
        }
        setCellContentOption(option) {
            this._autoWidth = option.autoWidth;
            this._autoHeight = option.autoHeight;
            this._cellWidth = option.cellWidth;
            this._originCellWidth = option.cellWidth;
            this._cellHeight = option.cellHeight;
            this._align = option.align;
            this._baseline = option.baseline;
        }
        addLeftOccupyingIcon(icon) {
            icon.setAttribute('x', this._leftGroup.width + (icon.attribute.marginLeft ?? 0));
            this._leftGroup.appendChild(icon);
            this._leftGroup.setDeltaWidth((icon.attribute.marginLeft ?? 0) + (icon.attribute.marginRight ?? 0) + icon.attribute.width);
        }
        addRightOccupyingIcon(icon) {
            icon.setAttribute('x', this._rightGroup.width + (icon.attribute.marginLeft ?? 0));
            this._rightGroup.appendChild(icon);
            this._rightGroup.setDeltaWidth((icon.attribute.marginLeft ?? 0) + (icon.attribute.marginRight ?? 0) + icon.attribute.width);
        }
        addContent(content) {
            const lastChild = this._centerGroup.lastChild;
            if (lastChild) {
                content.setAttributes({
                    x: lastChild.attribute.x + lastChild.AABBBounds.width()
                });
            }
            this._centerGroup.appendChild(content);
            if (content instanceof Text$1) {
                this._centerGroup.setAttribute('pickable', false);
                content.setAttribute('textAlign', 'left');
            }
        }
        layout() {
            let leftOccupyingWidth = this._leftGroup.width;
            if (leftOccupyingWidth === Infinity) {
                leftOccupyingWidth = 0;
            }
            let rightOccupyingWidth = this._rightGroup.width;
            if (rightOccupyingWidth === -Infinity) {
                rightOccupyingWidth = 0;
            }
            if (this._autoWidth) {
                const centerWidth = this._centerGroup.width;
                this._cellWidth = leftOccupyingWidth + rightOccupyingWidth + centerWidth;
                this.setAttribute('width', this._cellWidth);
            }
            else {
                const contentWidth = this._cellWidth - leftOccupyingWidth - rightOccupyingWidth;
                this.updateCenterLayout(contentWidth);
                const centerWidth = this._centerGroup.width;
                this._cellWidth = leftOccupyingWidth + rightOccupyingWidth + centerWidth;
                this.setAttribute('width', this._cellWidth);
            }
            this.updateHorizontalPos();
            const leftOccupyingHeight = this._leftGroup.height;
            const rightOccupyingHeight = this._rightGroup.height;
            const centerHeight = this._centerGroup.height;
            this._cellHeight = Math.max(leftOccupyingHeight, rightOccupyingHeight, centerHeight);
            this.setAttribute('height', this._cellHeight);
            this.updateVerticalPos();
        }
        updateCenterLayout(contentWidth) {
            let textWidth = contentWidth;
            this._centerGroup.forEachChildren(child => {
                if (child instanceof Icon$1 || child instanceof TextIcon) {
                    textWidth -= child.AABBBounds.width();
                }
            });
            const text = this._centerGroup.getChildByName('text');
            if (text instanceof RichText) {
                text.setAttribute('width', textWidth);
            }
            else if (text instanceof Text$1) {
                text.setAttribute('maxLineWidth', textWidth);
            }
            let x = 0;
            this._centerGroup.forEachChildren((child) => {
                child.setAttribute('x', x);
                x += child.AABBBounds.width();
            });
        }
        updateHorizontalPos() {
            this._leftGroup.setAttribute('x', 0);
            this._rightGroup.setAttribute('x', this._cellWidth - this._rightGroup.width);
            this._centerGroup.setAttribute('x', this._leftGroup.width);
            if (this._align === 'left' || this._align === 'start') {
                this.setAttribute('dx', 0);
            }
            else if (this._align === 'center') {
                this.setAttribute('dx', -this.attribute.width / 2);
            }
            else if (this._align === 'right' || this._align === 'end') {
                this.setAttribute('dx', -this.attribute.width);
            }
        }
        updateVerticalPos() {
            if (this._baseline === 'top') {
                this._leftGroup.setAttribute('y', 0);
                this._rightGroup.setAttribute('y', 0);
                this._centerGroup.setAttribute('y', 0);
            }
            else if (this._baseline === 'middle') {
                this._leftGroup.forEachChildren((icon) => {
                    icon.setAttribute('y', (this._leftGroup.height - icon.AABBBounds.height()) / 2);
                });
                this._rightGroup.forEachChildren((icon) => {
                    icon.setAttribute('y', (this._rightGroup.height - icon.AABBBounds.height()) / 2);
                });
                this._leftGroup.setAttribute('y', this._cellHeight / 2 - this._leftGroup.height / 2);
                this._rightGroup.setAttribute('y', this._cellHeight / 2 - this._rightGroup.height / 2);
                this._centerGroup.setAttribute('y', this._cellHeight / 2 - this._centerGroup.height / 2);
            }
            else if (this._baseline === 'bottom') {
                this._leftGroup.forEachChildren((icon) => {
                    icon.setAttribute('y', this._leftGroup.height - icon.AABBBounds.height());
                });
                this._rightGroup.forEachChildren((icon) => {
                    icon.setAttribute('y', this._rightGroup.height - icon.AABBBounds.height());
                });
                this._leftGroup.setAttribute('y', this._cellHeight - this._leftGroup.height);
                this._rightGroup.setAttribute('y', this._cellHeight - this._rightGroup.height);
                this._centerGroup.setAttribute('y', this._cellHeight - this._centerGroup.height);
            }
        }
        updateWidth(width) {
            this._cellWidth = width;
            this._originCellWidth = width;
            this.layout();
        }
        updateHeight(height) {
            this._cellHeight = height;
            this._cellWidth = this._originCellWidth;
            const textMark = this.getChildByName('text', true);
            if (textMark) {
                textMark.setAttribute('heightLimit', height);
            }
            this.layout();
        }
    }

    function getHierarchyOffset(col, row, table) {
        let cellHierarchyIndent = 0;
        const layoutMap = table.internalProps.layoutMap;
        if (layoutMap.isHeader(col, row)) {
            const hd = layoutMap.getHeader(col, row);
            if (isValid$3(hd?.hierarchyLevel)) {
                cellHierarchyIndent =
                    (hd.hierarchyLevel ?? 0) *
                        (layoutMap.rowHierarchyType === 'tree'
                            ? layoutMap.rowHierarchyIndent ?? 0
                            : 0);
                if (layoutMap.rowHierarchyTextStartAlignment &&
                    !table.internalProps.headerHelper.getHierarchyIcon(col, row)) {
                    cellHierarchyIndent += table.internalProps.headerHelper.getHierarchyIconWidth();
                }
            }
        }
        else {
            if (table.options.groupBy ||
                table.getBodyColumnDefine(col, row)?.tree) {
                const indexArr = table.dataSource.getIndexKey(table.getRecordShowIndexByCell(col, row));
                const groupLength = table.dataSource.getGroupLength() ?? 0;
                let indexArrLngth = isArray$7(indexArr) ? indexArr.length - 1 : 0;
                if (groupLength > 0 && indexArrLngth === groupLength) {
                    indexArrLngth = 0;
                }
                cellHierarchyIndent =
                    Array.isArray(indexArr) && table.getHierarchyState(col, row) !== HierarchyState.none
                        ? indexArrLngth * (layoutMap.hierarchyIndent ?? 0)
                        : 0;
                if (layoutMap.hierarchyTextStartAlignment &&
                    !table.internalProps.bodyHelper.getHierarchyIcon(col, row)) {
                    cellHierarchyIndent += table.internalProps.bodyHelper.getHierarchyIconWidth();
                }
            }
        }
        return cellHierarchyIndent;
    }

    function breakString(textStr, table) {
        let moreThanMaxCharacters = false;
        if (isString$4(textStr) && textStr.length > (table.options.maxCharactersNumber || 200)) {
            textStr = textStr.slice(0, table.options.maxCharactersNumber || 200);
            textStr += '\u2026';
            moreThanMaxCharacters = true;
        }
        let text;
        if (!table.internalProps.enableLineBreak && !table.options.customConfig?.multilinesForXTable) {
            text = [convertInternal(textStr)];
        }
        else {
            text = convertInternal(textStr).replace(/\r?\n/g, '\n').replace(/\r/g, '\n').split('\n') || [];
        }
        while (text.length && text.length > 1 && !text[text.length - 1]) {
            text.pop();
        }
        if (table.options.customConfig?.multilinesForXTable && !table.internalProps.autoWrapText) {
            while (text.length && text.length > 1 && !text[0]) {
                text.shift();
            }
        }
        return {
            text,
            moreThanMaxCharacters
        };
    }

    function createCellContent(cellGroup, icons, textStr, padding, autoColWidth, autoRowHeight, autoWrapText, lineClamp, cellWidth, cellHeight, textAlign, textBaseline, table, cellTheme, range) {
        let contentWidth;
        let leftIconWidth = 0;
        let rightIconWidth = 0;
        let absoluteRightIconWidth = 0;
        if (!Array.isArray(icons) || icons.length === 0) {
            if (isValid$3(textStr)) {
                const { text, moreThanMaxCharacters } = breakString(textStr, table);
                const hierarchyOffset = range
                    ? getHierarchyOffset(range.start.col, range.start.row, table)
                    : getHierarchyOffset(cellGroup.col, cellGroup.row, table);
                let _contentOffset = 0;
                if (isNumber$4(table.theme._contentOffset)) {
                    if (textAlign === 'left') {
                        _contentOffset = table.theme._contentOffset;
                    }
                    else if (textAlign === 'right') {
                        _contentOffset = -table.theme._contentOffset;
                    }
                }
                const attribute = {
                    text: text.length === 1 ? text[0] : text,
                    moreThanMaxCharacters,
                    maxLineWidth: autoColWidth ? Infinity : cellWidth - (padding[1] + padding[3] + hierarchyOffset),
                    textBaseline: 'top',
                    autoWrapText,
                    lineClamp,
                    wordBreak: 'break-word',
                    heightLimit: table.options.customConfig?.limitContentHeight === false
                        ? -1
                        : autoRowHeight && !table.options.customConfig?.multilinesForXTable
                            ? -1
                            : cellHeight - Math.floor(padding[0] + padding[2]),
                    pickable: false,
                    dx: (textAlign === 'left' ? hierarchyOffset : 0) + _contentOffset,
                    whiteSpace: table.options.customConfig?.limitContentHeight === false
                        ? 'normal'
                        : text.length === 1 && !autoWrapText
                            ? 'no-wrap'
                            : 'normal',
                    keepCenterInLine: true
                };
                const wrapText = new Text$1(cellTheme.text ? Object.assign({}, cellTheme.text, attribute) : attribute);
                wrapText.name = 'text';
                wrapText.textBaseline = textBaseline;
                cellGroup.appendChild(wrapText);
                contentWidth = wrapText.AABBBounds.width();
                wrapText.AABBBounds.height();
            }
        }
        else {
            const { inlineFrontIcons, inlineEndIcons, contentLeftIcons, contentRightIcons, leftIconWidth: layoutLeftIconWidth, rightIconWidth: layoutRightIconWidth, absoluteRightIconWidth: layoutAbsoluteRightIconWidth } = dealWithIconLayout(icons, cellGroup, range, table);
            leftIconWidth = layoutLeftIconWidth;
            rightIconWidth = layoutRightIconWidth;
            absoluteRightIconWidth = layoutAbsoluteRightIconWidth;
            let textMark;
            if (inlineFrontIcons.length === 0 && inlineEndIcons.length === 0) {
                let _contentOffset = 0;
                if (isNumber$4(table.theme._contentOffset)) {
                    if (textAlign === 'left') {
                        _contentOffset = table.theme._contentOffset;
                    }
                    else if (textAlign === 'right') {
                        _contentOffset = -table.theme._contentOffset;
                    }
                }
                const hierarchyOffset = range
                    ? getHierarchyOffset(range.start.col, range.start.row, table)
                    : getHierarchyOffset(cellGroup.col, cellGroup.row, table);
                const { text, moreThanMaxCharacters } = breakString(textStr, table);
                const attribute = {
                    text: text.length === 1 ? text[0] : text,
                    moreThanMaxCharacters,
                    maxLineWidth: autoColWidth
                        ? Infinity
                        : cellWidth - (padding[1] + padding[3]) - leftIconWidth - rightIconWidth - hierarchyOffset,
                    textBaseline: 'top',
                    heightLimit: table.options.customConfig?.limitContentHeight === false
                        ? -1
                        : autoRowHeight && !table.options.customConfig?.multilinesForXTable
                            ? -1
                            : cellHeight - Math.floor(padding[0] + padding[2]),
                    pickable: false,
                    autoWrapText,
                    lineClamp,
                    wordBreak: 'break-word',
                    whiteSpace: table.options.customConfig?.limitContentHeight === false
                        ? 'normal'
                        : text.length === 1 && !autoWrapText
                            ? 'no-wrap'
                            : 'normal',
                    dx: (textAlign === 'left' ? (!contentLeftIcons.length ? hierarchyOffset : 0) : 0) + _contentOffset,
                    keepCenterInLine: true
                };
                const wrapText = new Text$1(cellTheme.text ? Object.assign({}, cellTheme.text, attribute) : attribute);
                wrapText.name = 'text';
                textMark = wrapText;
            }
            else {
                const textOption = Object.assign({
                    text: textStr?.toString()
                }, cellGroup.parent?.theme?.userTheme?.text || {});
                if (cellTheme.text) {
                    Object.assign(textOption, cellTheme.text);
                }
                textOption.textBaseline = 'middle';
                const textConfig = [
                    ...inlineFrontIcons.map(icon => dealWithRichTextIcon(icon)),
                    textOption,
                    ...inlineEndIcons.map(icon => dealWithRichTextIcon(icon))
                ];
                textConfig[0].textAlign = textAlign;
                const text = new RichText({
                    width: autoColWidth ? 0 : cellWidth - (padding[1] + padding[3]) - leftIconWidth - rightIconWidth,
                    height: autoRowHeight && autoWrapText ? 0 : Math.ceil(cellHeight - (padding[0] + padding[2])),
                    textConfig,
                    verticalDirection: autoRowHeight && autoWrapText ? 'top' : textBaseline,
                    ellipsis: textOption.ellipsis
                });
                text.name = 'text';
                textMark = text;
                text.bindIconEvent();
                if (range && (range.start.col !== range.end.col || range.start.row !== range.end.row)) {
                    text.onBeforeAttributeUpdate = onBeforeAttributeUpdate;
                }
            }
            if (contentLeftIcons.length !== 0 || contentRightIcons.length !== 0) {
                const cellContent = new CellContent({
                    x: 0,
                    y: 0,
                    fill: false,
                    stroke: false,
                    pickable: false
                });
                cellContent.name = 'content';
                cellContent.setCellContentOption({
                    autoWidth: autoColWidth,
                    autoHeight: autoRowHeight,
                    cellWidth: cellWidth - (padding[1] + padding[3]) - leftIconWidth - rightIconWidth,
                    cellHeight: cellHeight - (padding[0] + padding[2]),
                    align: textAlign,
                    baseline: textBaseline
                });
                const dealWithIconComputeVar = {
                    addedHierarchyOffset: 0
                };
                contentLeftIcons.forEach(icon => {
                    const iconMark = dealWithIcon(icon, undefined, cellGroup.col, cellGroup.row, range, table, dealWithIconComputeVar);
                    iconMark.role = 'icon-content-left';
                    iconMark.name = icon.name;
                    cellContent.addLeftOccupyingIcon(iconMark);
                });
                contentRightIcons.forEach(icon => {
                    const iconMark = dealWithIcon(icon, undefined, cellGroup.col, cellGroup.row, range, table, dealWithIconComputeVar);
                    iconMark.role = 'icon-content-right';
                    iconMark.name = icon.name;
                    cellContent.addRightOccupyingIcon(iconMark);
                });
                cellContent.addContent(textMark);
                cellGroup.appendChild(cellContent);
                cellContent.layout();
                contentWidth = cellContent.AABBBounds.width();
                cellContent.AABBBounds.height();
            }
            else {
                if (cellGroup.firstChild) {
                    cellGroup.insertBefore(textMark, cellGroup.firstChild);
                }
                else {
                    cellGroup.appendChild(textMark);
                }
                contentWidth = textMark.AABBBounds.width();
                textMark.AABBBounds.height();
            }
        }
        const width = autoColWidth
            ? leftIconWidth + contentWidth + rightIconWidth
            : cellWidth - (padding[1] + padding[3]);
        const height = cellHeight - (padding[0] + padding[2]);
        cellGroup.forEachChildren((child) => {
            if (child.role === 'icon-left') {
                child.setAttribute('x', child.attribute.x + padding[3]);
            }
            else if (child.role === 'icon-right') {
                child.setAttribute('x', child.attribute.x + width - rightIconWidth + padding[3]);
            }
            else if (child.role === 'icon-absolute-right') {
                child.setAttribute('x', child.attribute.x + width - absoluteRightIconWidth + padding[3] + padding[1]);
            }
            else if (child.name === 'content' || child.name === 'text') {
                if (textAlign === 'center' && child.type !== 'richtext') {
                    child.setAttribute('x', padding[3] + leftIconWidth + (width - leftIconWidth - rightIconWidth) / 2);
                }
                else if (textAlign === 'right' && child.type !== 'richtext') {
                    child.setAttribute('x', padding[3] + width - rightIconWidth);
                }
                else {
                    child.setAttribute('x', padding[3] + leftIconWidth);
                }
            }
        });
        cellGroup.forEachChildren((child) => {
            if (child.name === CUSTOM_CONTAINER_NAME) {
                return;
            }
            if (textBaseline === 'middle') {
                child.setAttribute('y', padding[0] + (height - child.AABBBounds.height()) / 2);
            }
            else if (textBaseline === 'bottom') {
                child.setAttribute('y', padding[0] + height - child.AABBBounds.height());
            }
            else {
                child.setAttribute('y', padding[0]);
            }
        });
        cellGroup.setAttributes({
            width: width + padding[1] + padding[3],
            height: height + padding[0] + padding[2]
        });
    }
    function dealWithIcon(icon, mark, col, row, range, table, dealWithIconComputeVar) {
        const iconAttribute = {};
        if (icon.type === 'image') {
            if (icon.isGif) {
                iconAttribute.gif = icon.src;
                iconAttribute.image = icon.src;
            }
            else {
                iconAttribute.image = icon.src;
            }
        }
        else if (icon.type === 'svg' || 'svg' in icon) {
            iconAttribute.image = icon.svg;
        }
        iconAttribute.width = icon.width;
        iconAttribute.height = icon.height;
        iconAttribute.visibleTime = icon.visibleTime ?? 'always';
        iconAttribute.funcType = icon.funcType;
        iconAttribute.interactive = icon.interactive;
        iconAttribute.isGif = icon.isGif;
        let hierarchyOffset = 0;
        if ((!dealWithIconComputeVar || dealWithIconComputeVar?.addedHierarchyOffset === 0) &&
            isNumber$4(col) &&
            isNumber$4(row) &&
            table &&
            (icon.funcType === IconFuncTypeEnum.collapse ||
                icon.funcType === IconFuncTypeEnum.expand ||
                icon.positionType === IconPosition.contentLeft ||
                icon.positionType === IconPosition.contentRight)) {
            hierarchyOffset = range
                ? getHierarchyOffset(range.start.col, range.start.row, table)
                : getHierarchyOffset(col, row, table);
            if (dealWithIconComputeVar) {
                dealWithIconComputeVar.addedHierarchyOffset = 1;
            }
        }
        iconAttribute.marginLeft = (icon.marginLeft ?? 0) + hierarchyOffset;
        iconAttribute.marginRight = icon.marginRight ?? 0;
        if (icon.interactive === false) {
            iconAttribute.pickable = false;
        }
        if (icon.hover) {
            iconAttribute.backgroundWidth = icon.hover.width ?? icon.width;
            iconAttribute.backgroundHeight = icon.hover.width ?? icon.width;
            iconAttribute.backgroundColor = icon.hover.bgColor ?? 'rgba(22,44,66,0.2)';
            iconAttribute.hoverImage = icon.hover.image;
        }
        if (icon.cursor) {
            iconAttribute.cursor = icon.cursor;
        }
        if ('shape' in icon && icon.shape === 'circle') {
            iconAttribute.shape = icon.shape;
        }
        if (mark) {
            mark.setAttributes(iconAttribute);
            mark.loadImage(iconAttribute.image);
            mark.tooltip = icon.tooltip;
            mark.name = icon.name;
            return mark;
        }
        let iconMark;
        if (icon.type === 'text') {
            iconAttribute.text = icon.content;
            merge$1(iconAttribute, icon.style);
            iconMark = new TextIcon(iconAttribute);
            iconMark.tooltip = icon.tooltip;
            iconMark.name = icon.name;
        }
        else {
            iconMark = new Icon$1(iconAttribute);
            iconMark.tooltip = icon.tooltip;
            iconMark.name = icon.name;
        }
        return iconMark;
    }
    function dealWithRichTextIcon(icon) {
        const config = {};
        if (icon.type === 'image') {
            config.image = icon.src;
        }
        else if (icon.type === 'svg' || 'svg' in icon) {
            config.image = icon.svg;
        }
        config.visibleTime = icon.visibleTime ?? 'always';
        config.funcType = icon.funcType;
        config.id = icon.name;
        config.width = icon.width;
        config.height = icon.height;
        if (icon.marginRight || icon.marginLeft) {
            config.margin = [0, icon.marginRight ?? 0, 0, icon.marginLeft ?? 0];
        }
        if (icon.hover) {
            config.backgroundWidth = icon.hover.width ?? icon.width;
            config.backgroundHeight = icon.hover.height ?? icon.height;
            config.backgroundShowMode = 'hover';
            config.hoverImage = icon.hover.image;
            config.backgroundStroke = false;
            config.backgroundFill = icon.hover.bgColor ?? 'rgba(22,44,66,0.2)';
        }
        if (icon.cursor) {
            config.cursor = icon.cursor;
        }
        config.tooltip = icon.tooltip;
        return config;
    }
    function updateCellContentWidth(cellGroup, distWidth, cellHeight, detaX, autoRowHeight, padding, textAlign, textBaseline, scene) {
        if (isValidNumber$1(cellGroup.contentWidth)) {
            detaX = distWidth - (cellGroup.contentWidth ?? cellGroup.attribute.width);
        }
        let leftIconWidth = 0;
        let leftIconHeight = 0;
        let rightIconWidth = 0;
        let rightIconHeight = 0;
        cellGroup.forEachChildren((iconMark) => {
            if (iconMark.role === 'icon-left') {
                leftIconWidth +=
                    iconMark.AABBBounds.width() + (iconMark.attribute.marginLeft ?? 0) + (iconMark.attribute.marginRight ?? 0);
                leftIconHeight = Math.max(leftIconHeight, iconMark.AABBBounds.height());
            }
            else if (iconMark.role === 'icon-right') {
                rightIconWidth +=
                    iconMark.AABBBounds.width() + (iconMark.attribute.marginLeft ?? 0) + (iconMark.attribute.marginRight ?? 0);
                rightIconHeight = Math.max(rightIconHeight, iconMark.AABBBounds.height());
            }
        });
        let oldTextHeight;
        const textMark = cellGroup.getChildByName('text');
        const cellContent = cellGroup.getChildByName('content');
        let contentHeight;
        if (textMark instanceof Text$1) {
            oldTextHeight = textMark.AABBBounds.height();
            textMark.setAttribute('maxLineWidth', distWidth -
                leftIconWidth -
                rightIconWidth -
                (padding[1] + padding[3]) -
                (textMark.attribute.dx ?? 0) -
                (scene.table.theme._contentOffset ?? 0));
            contentHeight = textMark.AABBBounds.height();
        }
        else if (textMark instanceof RichText) {
            oldTextHeight = textMark.AABBBounds.height();
            textMark.setAttribute('width', distWidth - leftIconWidth - rightIconWidth - (padding[1] + padding[3]));
            contentHeight = textMark.AABBBounds.height();
        }
        else if (cellContent) {
            oldTextHeight = cellContent.AABBBounds.height();
            cellContent.updateWidth(distWidth - leftIconWidth - rightIconWidth - (padding[1] + padding[3]));
            contentHeight = cellContent.AABBBounds.height();
        }
        const oldCellHeight = Math.round(Math.max(leftIconHeight, rightIconHeight, oldTextHeight) + padding[0] + padding[2]);
        cellGroup.forEachChildren((child) => {
            if (child.role === 'icon-left') ;
            else if (child.role === 'icon-right') {
                child.setAttribute('x', child.attribute.x + detaX);
            }
            else if (child.role === 'icon-absolute-right') {
                child.setAttribute('x', child.attribute.x + detaX);
            }
            else if (child.name === 'content' || (child.name === 'text' && child.type !== 'richtext')) {
                const childTextAlign = child.attribute.textAlign ?? textAlign;
                if (childTextAlign === 'center') {
                    child.setAttribute('x', padding[3] + leftIconWidth + (distWidth - (padding[1] + padding[3]) - leftIconWidth - rightIconWidth) / 2);
                }
                else if (childTextAlign === 'right') {
                    child.setAttribute('x', padding[3] + distWidth - (padding[1] + padding[3]) - rightIconWidth);
                }
                else ;
            }
            else if (child.name === 'mark') {
                child.setAttribute('x', cellGroup.attribute.width);
            }
        });
        if (autoRowHeight) {
            let newHeight = Math.max(leftIconHeight, contentHeight, rightIconHeight);
            if (isCellHeightUpdate(scene, cellGroup, Math.round(newHeight + padding[0] + padding[2]), oldCellHeight)) {
                return true;
            }
            newHeight = (cellGroup.contentHeight ?? cellHeight) - (padding[0] + padding[2]);
            cellGroup.forEachChildren((child) => {
                if (child.type === 'rect' || child.type === 'chart' || child.name === CUSTOM_CONTAINER_NAME) {
                    return;
                }
                if (child.name === 'mark') {
                    child.setAttribute('y', 0);
                }
                else if (textBaseline === 'middle') {
                    child.setAttribute('y', padding[0] + (newHeight - child.AABBBounds.height()) / 2);
                }
                else if (textBaseline === 'bottom') {
                    child.setAttribute('y', padding[0] + newHeight - child.AABBBounds.height());
                }
                else {
                    child.setAttribute('y', padding[0]);
                }
            });
        }
        else if (textBaseline === 'middle' || textBaseline === 'bottom') {
            cellGroup.forEachChildren((child) => {
                if (child.type === 'rect' || child.type === 'chart' || child.name === CUSTOM_CONTAINER_NAME) {
                    return;
                }
                if (child.name === 'mark') {
                    child.setAttribute('y', 0);
                }
                else if (textBaseline === 'middle') {
                    child.setAttribute('y', (cellHeight - padding[2] + padding[0] - child.AABBBounds.height()) / 2);
                }
                else if (textBaseline === 'bottom') {
                    child.setAttribute('y', cellHeight - child.AABBBounds.height() - padding[2]);
                }
                else {
                    child.setAttribute('y', padding[0]);
                }
            });
        }
        return false;
    }
    function updateCellContentHeight(cellGroup, distHeight, detaY, autoRowHeight, padding, textAlign, textBaseline, table) {
        const newHeight = distHeight - Math.floor(padding[0] + padding[2]);
        const textMark = cellGroup.getChildByName('text');
        if (textMark instanceof Text$1 && !autoRowHeight) {
            textMark.setAttributes({
                heightLimit: table.options.customConfig?.limitContentHeight === false ? -1 : newHeight
            });
        }
        else if (textMark instanceof RichText && !autoRowHeight) {
            textMark.setAttributes({
                height: newHeight
            });
        }
        else if (cellGroup.getChildByName('content')) {
            const cellContent = cellGroup.getChildByName('content');
            cellContent.updateHeight(newHeight);
        }
        cellGroup.forEachChildren((child) => {
            child.setAttribute('dy', 0);
            if (child.type === 'rect' || child.type === 'chart' || child.name === CUSTOM_CONTAINER_NAME) ;
            else if (child.name === 'mark') {
                child.setAttribute('y', 0);
            }
            else if (textBaseline === 'middle') {
                child.setAttribute('y', padding[0] + (newHeight - child.AABBBounds.height()) / 2);
            }
            else if (textBaseline === 'bottom') {
                child.setAttribute('y', padding[0] + newHeight - child.AABBBounds.height());
            }
            else {
                child.setAttribute('y', padding[0]);
            }
        });
    }
    function isCellHeightUpdate(scene, cellGroup, newHeight, oldHeight) {
        const table = scene.table;
        const mergeInfo = getCellMergeInfo(table, cellGroup.col, cellGroup.row);
        if (mergeInfo && mergeInfo.end.row - mergeInfo.start.row) {
            oldHeight = oldHeight / (mergeInfo.end.row - mergeInfo.start.row + 1);
            newHeight = newHeight / (mergeInfo.end.row - mergeInfo.start.row + 1);
            for (let rowIndex = mergeInfo.start.row; rowIndex <= mergeInfo.end.row; rowIndex++) {
                const rowHeight = table.getRowHeight(rowIndex);
                if (rowHeight === oldHeight && newHeight !== rowHeight) {
                    return true;
                }
                else if (newHeight > rowHeight) {
                    return true;
                }
            }
        }
        else {
            const rowHeight = table.getRowHeight(cellGroup.row);
            if (rowHeight === oldHeight && newHeight !== rowHeight) {
                return true;
            }
            else if (newHeight > rowHeight) {
                return true;
            }
        }
        return false;
    }
    function dealWithIconLayout(icons, cellGroup, range, table) {
        const leftIcons = [];
        const rightIcons = [];
        const contentLeftIcons = [];
        const contentRightIcons = [];
        const inlineFrontIcons = [];
        const inlineEndIcons = [];
        const absoluteLeftIcons = [];
        const absoluteRightIcons = [];
        let leftIconWidth = 0;
        let leftIconHeight = 0;
        let rightIconWidth = 0;
        let rightIconHeight = 0;
        let absoluteLeftIconWidth = 0;
        let absoluteRightIconWidth = 0;
        icons.forEach(icon => {
            switch (icon.positionType) {
                case IconPosition.left:
                    leftIcons.push(icon);
                    break;
                case IconPosition.right:
                    rightIcons.push(icon);
                    break;
                case IconPosition.contentLeft:
                    contentLeftIcons.push(icon);
                    break;
                case IconPosition.contentRight:
                    contentRightIcons.push(icon);
                    break;
                case IconPosition.absoluteRight:
                    absoluteRightIcons.push(icon);
                    break;
                case IconPosition.inlineFront:
                    inlineFrontIcons.push(icon);
                    break;
                case IconPosition.inlineEnd:
                    inlineEndIcons.push(icon);
                    break;
            }
        });
        leftIcons.forEach(icon => {
            const iconMark = dealWithIcon(icon, undefined, cellGroup.col, cellGroup.row, range, table);
            iconMark.role = 'icon-left';
            iconMark.name = icon.name;
            iconMark.setAttribute('x', leftIconWidth + (iconMark.attribute.marginLeft ?? 0));
            leftIconWidth +=
                iconMark.AABBBounds.width() + (iconMark.attribute.marginLeft ?? 0) + (iconMark.attribute.marginRight ?? 0);
            leftIconHeight = Math.max(leftIconHeight, iconMark.AABBBounds.height());
            cellGroup.appendChild(iconMark);
        });
        rightIcons.forEach(icon => {
            const iconMark = dealWithIcon(icon, undefined, cellGroup.col, cellGroup.row, range, table);
            iconMark.role = 'icon-right';
            iconMark.name = icon.name;
            iconMark.setAttribute('x', rightIconWidth + (iconMark.attribute.marginLeft ?? 0));
            rightIconWidth +=
                iconMark.AABBBounds.width() + (iconMark.attribute.marginLeft ?? 0) + (iconMark.attribute.marginRight ?? 0);
            rightIconHeight = Math.max(rightIconHeight, iconMark.AABBBounds.height());
            cellGroup.appendChild(iconMark);
        });
        absoluteLeftIcons.forEach(icon => {
            const iconMark = dealWithIcon(icon, undefined, cellGroup.col, cellGroup.row, range, table);
            iconMark.role = 'icon-absolute-left';
            iconMark.name = icon.name;
            iconMark.setAttribute('x', absoluteLeftIconWidth + (iconMark.attribute.marginLeft ?? 0));
            absoluteLeftIconWidth +=
                iconMark.AABBBounds.width() + (iconMark.attribute.marginLeft ?? 0) + (iconMark.attribute.marginRight ?? 0);
            cellGroup.appendChild(iconMark);
        });
        absoluteRightIcons.forEach(icon => {
            const iconMark = dealWithIcon(icon, undefined, cellGroup.col, cellGroup.row, range, table);
            iconMark.role = 'icon-absolute-right';
            iconMark.name = icon.name;
            iconMark.setAttribute('x', absoluteRightIconWidth + (iconMark.attribute.marginLeft ?? 0));
            absoluteRightIconWidth +=
                iconMark.AABBBounds.width() + (iconMark.attribute.marginLeft ?? 0) + (iconMark.attribute.marginRight ?? 0);
            cellGroup.appendChild(iconMark);
        });
        return {
            leftIcons,
            rightIcons,
            contentLeftIcons,
            contentRightIcons,
            inlineFrontIcons,
            inlineEndIcons,
            absoluteLeftIcons,
            absoluteRightIcons,
            leftIconWidth,
            leftIconHeight,
            rightIconWidth,
            rightIconHeight,
            absoluteLeftIconWidth,
            absoluteRightIconWidth
        };
    }
    function onBeforeAttributeUpdate(val, attribute) {
        if (val.hasOwnProperty('hoverIconId')) {
            const graphic = this;
            if (graphic.skipMergeUpdate) {
                return;
            }
            const cellGroup = getTargetCell(graphic);
            if (!cellGroup || !cellGroup.stage) {
                return;
            }
            const table = cellGroup.stage.table;
            graphic.skipAttributeUpdate = true;
            const { mergeStartCol, mergeEndCol, mergeStartRow, mergeEndRow } = cellGroup;
            if (isValid$3(mergeStartCol) &&
                isValid$3(mergeEndCol) &&
                isValid$3(mergeStartRow) &&
                isValid$3(mergeEndRow) &&
                (mergeStartCol !== mergeEndCol || mergeStartRow !== mergeEndRow)) {
                for (let col = mergeStartCol; col <= mergeEndCol; col++) {
                    for (let row = mergeStartRow; row <= mergeEndRow; row++) {
                        if (col === cellGroup.col && row === cellGroup.row) {
                            if (val.hoverIconId !== graphic.attribute.hoverIconId) {
                                const icon = graphic._frameCache.icons.get(val.hoverIconId);
                                graphic.updateHoverIconState(icon);
                            }
                            continue;
                        }
                        const cell = table.scenegraph.highPerformanceGetCell(col, row);
                        if (cell.role === 'cell') {
                            const target = cell.getChildByName(graphic.name, true);
                            if (!target || target.skipAttributeUpdate) {
                                continue;
                            }
                            if (val.hoverIconId !== target.attribute.hoverIconId) {
                                target.setAttribute('hoverIconId', val.hoverIconId);
                                cell.addUpdateBoundTag();
                            }
                        }
                    }
                }
                graphic.skipAttributeUpdate = undefined;
            }
        }
    }

    function createImageCellGroup(columnGroup, xOrigin, yOrigin, col, row, width, height, keepAspectRatio, imageAutoSizing, padding, textAlign, textBaseline, mayHaveIcon, table, cellTheme, range, isAsync) {
        const headerStyle = table._getCellStyle(col, row);
        const functionalPadding = getFunctionalProp('padding', headerStyle, col, row, table);
        if (table.options.customConfig?.imageMargin) {
            padding = getQuadProps(table.options.customConfig?.imageMargin);
        }
        else if (isValid$3(functionalPadding)) {
            padding = functionalPadding;
        }
        if (cellTheme?.text?.textAlign) {
            textAlign = cellTheme?.text?.textAlign;
        }
        if (cellTheme?.text?.textBaseline) {
            textBaseline = cellTheme?.text?.textBaseline;
        }
        const strokeArrayWidth = getCellBorderStrokeWidth(col, row, cellTheme, table);
        let cellGroup;
        if (isAsync) {
            cellGroup = table.scenegraph.highPerformanceGetCell(col, row, true);
            if (cellGroup && cellGroup.role === 'cell') {
                cellGroup.setAttributes({
                    x: xOrigin,
                    y: yOrigin,
                    width,
                    height,
                    lineWidth: cellTheme?.group?.lineWidth ?? undefined,
                    fill: cellTheme?.group?.fill ?? undefined,
                    stroke: cellTheme?.group?.stroke ?? undefined,
                    strokeArrayWidth: strokeArrayWidth ?? undefined,
                    strokeArrayColor: cellTheme?.group?.strokeArrayColor ?? undefined,
                    cursor: cellTheme?.group?.cursor ?? undefined,
                    lineDash: cellTheme?.group?.lineDash ?? undefined,
                    lineCap: 'butt',
                    clip: true,
                    cornerRadius: cellTheme.group.cornerRadius
                });
            }
        }
        if (!cellGroup || cellGroup.role !== 'cell') {
            cellGroup = new Group$1({
                x: xOrigin,
                y: yOrigin,
                width,
                height,
                lineWidth: cellTheme?.group?.lineWidth ?? undefined,
                fill: cellTheme?.group?.fill ?? undefined,
                stroke: cellTheme?.group?.stroke ?? undefined,
                strokeArrayWidth: strokeArrayWidth ?? undefined,
                strokeArrayColor: cellTheme?.group?.strokeArrayColor ?? undefined,
                cursor: cellTheme?.group?.cursor ?? undefined,
                lineDash: cellTheme?.group?.lineDash ?? undefined,
                lineCap: 'butt',
                clip: true,
                cornerRadius: cellTheme.group.cornerRadius
            });
            cellGroup.role = 'cell';
            cellGroup.col = col;
            cellGroup.row = row;
            columnGroup?.addCellGroup(cellGroup);
        }
        let cellIcons;
        if (mayHaveIcon) {
            let iconCol = col;
            let iconRow = row;
            if (range) {
                iconCol = range.start.col;
                iconRow = range.start.row;
            }
            cellIcons = table.getCellIcons(iconCol, iconRow);
        }
        let iconWidth = 0;
        let cellLeftIconWidth = 0;
        let cellRightIconWidth = 0;
        if (Array.isArray(cellIcons) && cellIcons.length !== 0) {
            const { leftIconWidth, rightIconWidth, absoluteLeftIconWidth, absoluteRightIconWidth } = dealWithIconLayout(cellIcons, cellGroup, range, table);
            iconWidth = leftIconWidth + rightIconWidth;
            cellLeftIconWidth = leftIconWidth;
            cellRightIconWidth = rightIconWidth;
            cellGroup.forEachChildren((child) => {
                if (child.role === 'icon-left') {
                    child.setAttribute('x', child.attribute.x + padding[3]);
                }
                else if (child.role === 'icon-right') {
                    child.setAttribute('x', child.attribute.x + width - rightIconWidth - padding[1]);
                }
                else if (child.role === 'icon-absolute-right') {
                    child.setAttribute('x', child.attribute.x + width - absoluteRightIconWidth - padding[1]);
                }
            });
            cellGroup.forEachChildren((child) => {
                if (textBaseline === 'middle') {
                    child.setAttribute('y', (height - child.AABBBounds.height()) / 2);
                }
                else if (textBaseline === 'bottom') {
                    child.setAttribute('y', height - child.AABBBounds.height() - padding[2]);
                }
                else {
                    child.setAttribute('y', padding[0]);
                }
            });
            cellGroup._cellLeftIconWidth = cellLeftIconWidth;
            cellGroup._cellRightIconWidth = cellRightIconWidth;
        }
        const value = table.getCellValue(col, row);
        const image = createImage({
            x: padding[3],
            y: padding[0],
            width: width - padding[1] - padding[3] - iconWidth,
            height: height - padding[0] - padding[2],
            image: value,
            cursor: 'pointer'
        });
        image.name = 'image';
        image.keepAspectRatio = keepAspectRatio;
        image.textAlign = textAlign;
        image.textBaseline = textBaseline;
        if (keepAspectRatio || imageAutoSizing) {
            if (image.resources &&
                image.resources.has(image.attribute.image) &&
                image.resources.get(image.attribute.image).state === 'success') {
                image.setAttribute('opacity', 0);
                setTimeout(() => {
                    image.setAttribute('opacity', 1);
                    updateAutoSizingAndKeepAspectRatio(imageAutoSizing, keepAspectRatio, padding, textAlign, textBaseline, image, cellGroup, table);
                    table.scenegraph.updateNextFrame();
                }, 0);
            }
            else {
                image.successCallback = () => {
                    updateAutoSizingAndKeepAspectRatio(imageAutoSizing, keepAspectRatio, padding, textAlign, textBaseline, image, cellGroup, table);
                    table.scenegraph.updateNextFrame();
                };
            }
        }
        else {
            if (image.resources &&
                image.resources.has(image.attribute.image) &&
                image.resources.get(image.attribute.image).state === 'success') {
                updateImageCellContentWhileResize(cellGroup, col, row, 0, 0, table);
            }
            else {
                image.successCallback = () => {
                    updateImageCellContentWhileResize(cellGroup, col, row, 0, 0, table);
                };
            }
        }
        image.failCallback = () => {
            const regedIcons = get$2();
            image.image = regedIcons.damage_pic.svg;
        };
        cellGroup.appendChild(image);
        return cellGroup;
    }
    function _adjustWidthHeight(col, row, width, height, scene, padding, cellGroup) {
        let needInvalidate = false;
        let targetWidth = null;
        let targetHeight = null;
        const { width: cellWidth, height: cellHeight, isMerge } = getCellRange$1(cellGroup, scene.table);
        if (cellWidth < width + padding[1] + padding[3]) {
            targetWidth = width + padding[1] + padding[3];
            needInvalidate = true;
        }
        if (cellHeight < height + padding[2] + padding[0]) {
            targetHeight = height + padding[2] + padding[0];
            needInvalidate = true;
        }
        if (needInvalidate) {
            if (typeof targetWidth === 'number') {
                if (isMerge) {
                    for (let col = cellGroup.mergeStartCol; col <= cellGroup.mergeEndCol; col++) {
                        scene.setColWidth(col, targetWidth / (cellGroup.mergeEndCol - cellGroup.mergeStartCol + 1));
                    }
                }
                else {
                    scene.setColWidth(col, targetWidth);
                }
            }
            if (typeof targetHeight === 'number') {
                if (isMerge) {
                    for (let row = cellGroup.mergeStartRow; row <= cellGroup.mergeEndRow; row++) {
                        scene.setRowHeight(row, targetHeight / (cellGroup.mergeEndRow - cellGroup.mergeStartRow + 1));
                    }
                }
                else {
                    scene.setRowHeight(row, targetHeight);
                }
            }
            scene.component.updateScrollBar();
            return true;
        }
        return false;
    }
    function updateImageCellContentWhileResize(cellGroup, col, row, deltaX, deltaY, table) {
        const image = cellGroup.getChildByName('image');
        if (!image) {
            return;
        }
        const originImage = (typeof image.attribute.image !== 'string' && image.attribute.image) ||
            image.resources?.get(image.attribute.image).data;
        if (!originImage) {
            return;
        }
        const headerStyle = table._getCellStyle(col, row);
        const textAlign = getProp('textAlign', headerStyle, col, row, table) ?? 'left';
        const textBaseline = getProp('textBaseline', headerStyle, col, row, table) ?? 'middle';
        let padding;
        if (table.options.customConfig?.imageMargin) {
            padding = getQuadProps(table.options.customConfig?.imageMargin);
        }
        else {
            padding = getQuadProps(getProp('padding', headerStyle, col, row, table)) ?? [0, 0, 0, 0];
        }
        const { width: cellWidth, height: cellHeight, isMerge } = getCellRange$1(cellGroup, table);
        const colStart = cellGroup.mergeStartCol ?? cellGroup.col;
        const rowStart = cellGroup.mergeStartRow ?? cellGroup.row;
        const colEnd = cellGroup.mergeEndCol ?? cellGroup.col;
        const rowEnd = cellGroup.mergeEndCol ?? cellGroup.row;
        const leftIconWidth = cellGroup._cellLeftIconWidth ?? 0;
        const rightIconWidth = cellGroup._cellRightIconWidth ?? 0;
        if (image.keepAspectRatio) {
            const { width: imageWidth, height: imageHeight } = calcKeepAspectRatioSize(originImage.width || originImage.videoWidth, originImage.height || originImage.videoHeight, cellWidth - (padding[1] + padding[3]), cellHeight - (padding[0] + padding[2]));
            const pos = calcStartPosition(0, 0, cellWidth, cellHeight, imageWidth, imageHeight, textAlign, textBaseline, padding);
            for (let col = colStart; col <= colEnd; col++) {
                for (let row = rowStart; row <= rowEnd; row++) {
                    const cellGroup = table.scenegraph.getCell(col, row);
                    const image = cellGroup.getChildByName('image');
                    image?.setAttributes({
                        x: pos.x,
                        y: pos.y,
                        width: imageWidth,
                        height: imageHeight
                    });
                }
            }
        }
        else {
            for (let col = colStart; col <= colEnd; col++) {
                for (let row = rowStart; row <= rowEnd; row++) {
                    const cellGroup = table.scenegraph.getCell(col, row);
                    const image = cellGroup.getChildByName('image');
                    image?.setAttributes({
                        x: leftIconWidth + padding[3],
                        y: padding[0],
                        width: cellWidth - padding[1] - padding[3] - rightIconWidth - leftIconWidth,
                        height: cellHeight - padding[0] - padding[2]
                    });
                }
            }
        }
        const playIcon = cellGroup.getChildByName('play-icon');
        if (playIcon) {
            const left = 0;
            const top = 0;
            const { width, height } = getCellRange$1(cellGroup, table);
            const iconSize = Math.floor(Math.min(width - padding[1] - padding[3], height - padding[2] - padding[0]) / 2);
            const anchorX = left + (width > image.attribute.width ? image.attribute.x - left + image.attribute.width / 2 : width / 2);
            const anchorY = top + (height > image.attribute.height ? image.attribute.y - top + image.attribute.height / 2 : height / 2);
            for (let col = colStart; col <= colEnd; col++) {
                for (let row = rowStart; row <= rowEnd; row++) {
                    const cellGroup = table.scenegraph.getCell(col, row);
                    const playIcon = cellGroup.getChildByName('play-icon');
                    playIcon.setAttributes({
                        x: anchorX - iconSize / 2,
                        y: anchorY - iconSize / 2,
                        width: iconSize,
                        height: iconSize
                    });
                }
            }
        }
        cellGroup.forEachChildren((child) => {
            if (child.role === 'icon-left') ;
            else if (child.role === 'icon-right') {
                child.setAttribute('x', child.attribute.x + deltaX);
            }
            else if (child.role === 'icon-absolute-right') {
                child.setAttribute('x', child.attribute.x + deltaX);
            }
        });
        cellGroup.forEachChildren((child) => {
            if (child.type !== 'rect' && (!child.role || !child.role.startsWith('icon'))) ;
            else if (textBaseline === 'middle') {
                child.setAttribute('y', padding[0] + (cellHeight - padding[0] - padding[2] - child.AABBBounds.height()) / 2);
            }
            else if (textBaseline === 'bottom') {
                child.setAttribute('y', padding[0] + cellHeight - padding[0] - padding[2] - child.AABBBounds.height());
            }
            else {
                child.setAttribute('y', padding[0]);
            }
        });
        if (isMerge) {
            updateImageDxDy(cellGroup.mergeStartCol, cellGroup.mergeEndCol, cellGroup.mergeStartRow, cellGroup.mergeEndRow, table);
        }
    }
    function getCellRange$1(cellGroup, table) {
        if (cellGroup.role === 'cell' &&
            isValid$3(cellGroup.mergeStartCol) &&
            isValid$3(cellGroup.mergeEndCol) &&
            isValid$3(cellGroup.mergeStartRow) &&
            isValid$3(cellGroup.mergeEndRow)) {
            return {
                width: table.getColsWidth(cellGroup.mergeStartCol, cellGroup.mergeEndCol),
                height: table.getRowsHeight(cellGroup.mergeStartRow, cellGroup.mergeEndRow),
                isMerge: true
            };
        }
        return {
            width: cellGroup.attribute.width,
            height: cellGroup.attribute.height,
            isMerge: false
        };
    }
    function updateImageDxDy(startCol, endCol, startRow, endRow, table) {
        for (let col = startCol; col <= endCol; col++) {
            for (let row = startRow; row <= endRow; row++) {
                const cellGroup = table.scenegraph.getCell(col, row);
                if (cellGroup) {
                    const image = cellGroup.getChildByName('image');
                    if (image) {
                        image.setAttributes({
                            dx: -table.getColsWidth(cellGroup.mergeStartCol, col - 1),
                            dy: -table.getRowsHeight(cellGroup.mergeStartRow, row - 1)
                        });
                    }
                    const playIcon = cellGroup.getChildByName('play-icon');
                    if (playIcon) {
                        playIcon.setAttributes({
                            dx: -table.getColsWidth(cellGroup.mergeStartCol, col - 1),
                            dy: -table.getRowsHeight(cellGroup.mergeStartRow, row - 1)
                        });
                    }
                }
            }
        }
    }
    function updateAutoSizingAndKeepAspectRatio(imageAutoSizing, keepAspectRatio, padding, textAlign, textBaseline, image, cellGroup, table) {
        const originImage = image.resources.get(image.attribute.image).data;
        const { col, row } = cellGroup;
        if (imageAutoSizing && !isDamagePic(image)) {
            _adjustWidthHeight(col, row, originImage.width, originImage.height, table.scenegraph, padding, cellGroup);
        }
        if (keepAspectRatio || isDamagePic(image)) {
            const { width: cellWidth, height: cellHeight, isMerge } = getCellRange$1(cellGroup, table);
            const { width: imageWidth, height: imageHeight } = calcKeepAspectRatioSize(originImage.width, originImage.height, cellWidth - padding[1] - padding[3], cellHeight - padding[0] - padding[2]);
            const pos = calcStartPosition(0, 0, cellWidth, cellHeight, imageWidth, imageHeight, textAlign, textBaseline, padding);
            image.setAttributes({
                x: pos.x,
                y: pos.y,
                width: imageWidth,
                height: imageHeight
            });
            if (isMerge) {
                updateImageDxDy(cellGroup.mergeStartCol, cellGroup.mergeEndCol, cellGroup.mergeStartRow, cellGroup.mergeEndRow, table);
            }
        }
    }
    function isDamagePic(image) {
        const regedIcons = get$2();
        return image.attribute.image === regedIcons.damage_pic.svg;
    }

    function dealPromiseData(dataPromise, tabel, callback) {
        dataPromise
            .then(() => {
            callback();
            tabel.scenegraph.updateNextFrame();
        })
            .catch((err) => {
        });
    }

    function onBeforeAttributeUpdateForInvertHighlight(val, attribute) {
        const graphic = this;
        if (graphic.shadowRoot && graphic.shadowRoot.childrenCount && (isValid$3(val.width) || isValid$3(val.height))) {
            const shadowRect = graphic.shadowRoot.findChildrenByName('shadow-rect')[0];
            if (shadowRect) {
                shadowRect.setAttributes({
                    width: val.width ?? shadowRect.attribute.width,
                    height: val.height ?? shadowRect.attribute.height
                });
            }
        }
    }

    function createCell(type, value, define, table, col, row, colWidth, cellWidth, cellHeight, columnGroup, y, padding, textAlign, textBaseline, mayHaveIcon, cellTheme, range, customResult) {
        let isAsync = false;
        let cellGroup;
        if (isPromise(value)) {
            if (table.scenegraph.highPerformanceGetCell(col, row).role !== 'cell') {
                return cellGroup;
            }
            value = table.getCellValue(col, row);
            isAsync = true;
        }
        if (type === 'text' || type === 'link' || customResult) {
            if (type === 'link') {
                const cellValue = value;
                const cellOriginValue = table.getCellOriginValue(col, row);
                const headerStyle = table._getCellStyle(col, row);
                if (type === 'link' &&
                    (('templateLink' in define && define.templateLink) ||
                        !('linkDetect' in define &&
                            getOrApply(define.linkDetect, {
                                col,
                                row,
                                table,
                                value: cellValue,
                                dataValue: cellOriginValue,
                                cellHeaderPaths: undefined
                            })) ||
                        regUrl.test(cellValue))) {
                    if (cellTheme) {
                        cellTheme.text.fill = getProp('linkColor', headerStyle, col, row, table);
                        cellTheme.group.cursor = 'pointer';
                    }
                    else {
                        cellTheme = {
                            text: {
                                fill: getProp('linkColor', headerStyle, col, row, table)
                            },
                            group: {
                                cursor: 'pointer'
                            }
                        };
                    }
                }
            }
            const { customElementsGroup, renderDefault } = _generateCustomElementsGroup(table, define, col, row, cellWidth, cellHeight, padding, range, customResult);
            const createTextCellGroup = Factory.getFunction('createTextCellGroup');
            cellGroup = createTextCellGroup(table, value, columnGroup, 0, y, col, row, colWidth, cellWidth, cellHeight, padding, textAlign, textBaseline, mayHaveIcon, customElementsGroup, renderDefault, cellTheme, range, isAsync);
            const axisConfig = table.internalProps.layoutMap.getAxisConfigInPivotChart(col, row);
            if (axisConfig) {
                const CartesianAxis = Factory.getComponent('axis');
                const axis = new CartesianAxis(axisConfig, cellGroup.attribute.width, cellGroup.attribute.height, axisConfig.__vtablePadding ?? padding, table);
                cellGroup.clear();
                cellGroup.appendChild(axis.component);
                axis.overlap();
            }
            else if (table.internalProps.layoutMap.isEmpty(col, row)) {
                cellGroup.setAttributes({
                    fill: false,
                    stroke: false
                });
                cellGroup.clear();
            }
            else if (table.internalProps.layoutMap.isAxisCell(col, row)) {
                cellGroup.clear();
            }
        }
        else if (type === 'image') {
            const createImageCellGroup = Factory.getFunction('createImageCellGroup');
            cellGroup = createImageCellGroup(columnGroup, 0, y, col, row, cellWidth, cellHeight, define.keepAspectRatio, define.imageAutoSizing, padding, textAlign, textBaseline, mayHaveIcon, table, cellTheme, range, isAsync);
        }
        else if (type === 'video') {
            const createVideoCellGroup = Factory.getFunction('createVideoCellGroup');
            cellGroup = createVideoCellGroup(columnGroup, 0, y, col, row, cellWidth, cellHeight, define.keepAspectRatio, define.imageAutoSizing, padding, textAlign, textBaseline, mayHaveIcon, table, cellTheme, range, isAsync);
        }
        else if (type === 'chart') {
            const chartInstance = table.internalProps.layoutMap.getChartInstance(col, row);
            const createChartCellGroup = Factory.getFunction('createChartCellGroup');
            cellGroup = createChartCellGroup(null, columnGroup, 0, y, col, row, cellWidth, cellHeight, padding, value, define.chartModule, table.internalProps.layoutMap.getChartSpec(col, row), chartInstance, table.internalProps.layoutMap.getChartDataId(col, row) ?? 'data', table, cellTheme, table.internalProps.layoutMap.isShareChartSpec(col, row), isAsync, table.internalProps.layoutMap.isNoChartDataRenderNothing(col, row));
        }
        else if (type === 'progressbar') {
            const { customElementsGroup, renderDefault } = _generateCustomElementsGroup(table, define, col, row, cellWidth, cellHeight, padding, range, customResult);
            const style = table._getCellStyle(col, row);
            const dataValue = table.getCellOriginValue(col, row);
            const createTextCellGroup = Factory.getFunction('createTextCellGroup');
            cellGroup = createTextCellGroup(table, value, columnGroup, 0, y, col, row, colWidth, cellWidth, cellHeight, padding, textAlign, textBaseline, false, customElementsGroup, renderDefault, cellTheme, range, isAsync);
            const createProgressBarCell = Factory.getFunction('createProgressBarCell');
            const progressBarGroup = createProgressBarCell(define, style, colWidth, value, dataValue, col, row, padding, table, range);
            if (cellGroup.firstChild) {
                cellGroup.insertBefore(progressBarGroup, cellGroup.firstChild);
            }
            else {
                cellGroup.appendChild(progressBarGroup);
            }
        }
        else if (type === 'sparkline') {
            const createSparkLineCellGroup = Factory.getFunction('createSparkLineCellGroup');
            cellGroup = createSparkLineCellGroup(null, columnGroup, 0, y, col, row, cellWidth, cellHeight, padding, table, cellTheme, isAsync);
        }
        else if (type === 'checkbox') {
            const isAggregation = 'isAggregation' in table.internalProps.layoutMap && table.internalProps.layoutMap.isAggregation(col, row);
            const isSeriesNumber = table.internalProps.layoutMap.isSeriesNumber(col, row);
            if (isAggregation && isSeriesNumber) {
                const createTextCellGroup = Factory.getFunction('createTextCellGroup');
                cellGroup = createTextCellGroup(table, value, columnGroup, 0, y, col, row, colWidth, cellWidth, cellHeight, padding, textAlign, textBaseline, false, undefined, true, cellTheme, range, isAsync);
            }
            else {
                const createCheckboxCellGroup = Factory.getFunction('createCheckboxCellGroup');
                cellGroup = createCheckboxCellGroup(null, columnGroup, 0, y, col, row, colWidth, cellWidth, cellHeight, padding, textAlign, textBaseline, mayHaveIcon, table, cellTheme, define, range, isAsync);
            }
        }
        else if (type === 'radio') {
            const createRadioCellGroup = Factory.getFunction('createRadioCellGroup');
            cellGroup = createRadioCellGroup(null, columnGroup, 0, y, col, row, colWidth, cellWidth, cellHeight, padding, textAlign, textBaseline, table, cellTheme, define, range);
        }
        else if (type === 'switch') {
            const createSwitchCellGroup = Factory.getFunction('createSwitchCellGroup');
            cellGroup = createSwitchCellGroup(null, columnGroup, 0, y, col, row, colWidth, cellWidth, cellHeight, padding, textAlign, textBaseline, mayHaveIcon, table, cellTheme, define, range, isAsync);
        }
        else if (type === 'button') {
            const createButtonCellGroup = Factory.getFunction('createButtonCellGroup');
            cellGroup = createButtonCellGroup(null, columnGroup, 0, y, col, row, colWidth, cellWidth, cellHeight, padding, textAlign, textBaseline, mayHaveIcon, table, cellTheme, define, range, isAsync);
        }
        cellGroup.onBeforeAttributeUpdate = onBeforeAttributeUpdateForInvertHighlight;
        return cellGroup;
    }
    function _generateCustomElementsGroup(table, define, col, row, cellWidth, cellHeight, padding, range, customResult) {
        let customElementsGroup;
        let renderDefault = true;
        if (customResult) {
            customElementsGroup = customResult.elementsGroup;
            renderDefault = customResult.renderDefault;
        }
        else if (range?.isCustom && !table.isCornerHeader(col, row)) ;
        else {
            let customRender;
            let customLayout;
            const cellLocation = table.getCellLocation(col, row);
            if (cellLocation !== 'body') {
                customRender = define?.headerCustomRender;
                customLayout = define?.headerCustomLayout;
            }
            else {
                customRender = define?.customRender || table.customRender;
                customLayout = define?.customLayout;
            }
            if (customLayout || customRender) {
                const customResult = dealWithCustom(customLayout, customRender, col, row, cellWidth, cellHeight, false, table.isAutoRowHeight(row), padding, range, table);
                customElementsGroup = customResult.elementsGroup;
                renderDefault = customResult.renderDefault;
            }
        }
        return {
            customElementsGroup,
            renderDefault
        };
    }
    function updateCell$1(col, row, table, addNew, isShadow, forceFastUpdate) {
        const oldCellGroup = table.scenegraph.highPerformanceGetCell(col, row, true);
        if (oldCellGroup.role !== 'cell' && !addNew) {
            return undefined;
        }
        const cellLocation = table.getCellLocation(col, row);
        let value = table.getCellValue(col, row);
        let isMerge;
        let range;
        let customStyle;
        let customResult;
        let isCustomMerge = false;
        if (table.internalProps.customMergeCell) {
            const customMerge = table.getCustomMerge(col, row);
            if (customMerge) {
                const { range: customMergeRange, text: customMergeText, style: customMergeStyle, customLayout, customRender } = customMerge;
                range = customMergeRange;
                isMerge = range.start.col !== range.end.col || range.start.row !== range.end.row;
                value = customMergeText;
                customStyle = customMergeStyle;
                if (customLayout || customRender) {
                    customResult = dealWithCustom(customLayout, customRender, customMergeRange.start.col, customMergeRange.start.row, table.getColsWidth(customMergeRange.start.col, customMergeRange.end.col), table.getRowsHeight(customMergeRange.start.row, customMergeRange.end.row), false, table.isAutoRowHeight(row), [0, 0, 0, 0], range, table);
                }
                isCustomMerge = true;
            }
        }
        let colForDefine = col;
        let rowForDefine = row;
        if (range) {
            colForDefine = range.start.col;
            rowForDefine = range.start.row;
        }
        const define = (cellLocation !== 'body'
            ? table.getHeaderDefine(colForDefine, rowForDefine)
            : table.getBodyColumnDefine(colForDefine, rowForDefine));
        let mayHaveIcon = cellLocation !== 'body'
            ? true
            : define?.dragOrder || !!define?.icon || !!define?.tree;
        if (!range &&
            (table.internalProps.enableTreeNodeMerge || cellLocation !== 'body' || define?.mergeCell)) {
            range = table.getCellRange(col, row);
            isMerge = range.start.col !== range.end.col || range.start.row !== range.end.row;
        }
        let isVtableMerge = false;
        if (table.internalProps.enableTreeNodeMerge && isMerge) {
            const rawRecord = table.getCellRawRecord(range.start.col, range.start.row);
            const { vtableMergeName, vtableMerge } = rawRecord ?? {};
            isVtableMerge = vtableMerge;
            if (vtableMerge) {
                mayHaveIcon = true;
                if (table.options.groupTitleCustomLayout) {
                    customResult = dealWithCustom(table.options.groupTitleCustomLayout, undefined, range.start.col, range.start.row, table.getColsWidth(range.start.col, range.end.col), table.getRowsHeight(range.start.row, range.end.row), false, table.isAutoRowHeight(row), [0, 0, 0, 0], range, table);
                }
                if (table.options.groupTitleFieldFormat) {
                    value = table.options.groupTitleFieldFormat(rawRecord, col, row, table);
                }
                else if (vtableMergeName) {
                    value = vtableMergeName;
                }
            }
        }
        const cellStyle = customStyle || table._getCellStyle(range ? range.start.col : col, range ? range.start.row : row);
        const autoWrapText = cellStyle.autoWrapText ?? table.internalProps.autoWrapText;
        const cellTheme = getStyleTheme(cellStyle, table, isMerge ? range.start.col : col, isMerge ? range.start.row : row, getProp).theme;
        cellTheme.group.cornerRadius = getCellCornerRadius(col, row, table);
        if (!addNew &&
            !isMerge &&
            !(define?.customLayout || define?.customRender || define?.headerCustomLayout || define?.headerCustomRender) &&
            (forceFastUpdate || canUseFastUpdate(col, row, oldCellGroup, autoWrapText, mayHaveIcon, table))) {
            const cellWidth = table.getColWidth(col);
            const cellHeight = table.getRowHeight(row);
            const strokeArrayWidth = getCellBorderStrokeWidth(col, row, cellTheme, table);
            oldCellGroup.setAttributes({
                width: cellWidth,
                height: cellHeight,
                lineWidth: cellTheme?.group?.lineWidth ?? undefined,
                fill: cellTheme?.group?.fill ?? undefined,
                stroke: cellTheme?.group?.stroke ?? undefined,
                strokeArrayWidth: strokeArrayWidth ?? undefined,
                strokeArrayColor: cellTheme?.group?.strokeArrayColor ?? undefined,
                cursor: cellTheme?.group?.cursor ?? undefined,
                cornerRadius: cellTheme?.group?.cornerRadius ?? 0,
                lineDash: cellTheme?.group?.lineDash ?? undefined,
                y: table.scenegraph.getCellGroupY(row)
            });
            oldCellGroup.forEachChildren((child) => {
                child.setAttributes({
                    dx: 0,
                    dy: 0
                });
            });
            const textMark = oldCellGroup.getChildByName('text');
            if (forceFastUpdate && textMark) {
                const attribute = {
                    textBaseline: 'top'
                };
                textMark.setAttributes(cellTheme.text ? Object.assign({}, cellTheme.text, attribute) : attribute);
            }
            else if (textMark) {
                const text = table.getCellValue(col, row);
                const { text: textArr, moreThanMaxCharacters } = breakString(text, table);
                const hierarchyOffset = getHierarchyOffset(col, row, table);
                const lineClamp = cellStyle.lineClamp;
                const padding = getQuadProps(getProp('padding', cellStyle, col, row, table)) ?? [0, 0, 0, 0];
                const textAlign = cellTheme.text.textAlign;
                let x = 0;
                if (textAlign === 'center') {
                    x = padding[3] + (cellWidth - (padding[1] + padding[3])) / 2;
                }
                else if (textAlign === 'right') {
                    x = padding[3] + cellWidth - (padding[1] + padding[3]);
                }
                else {
                    x = padding[3];
                }
                const attribute = {
                    text: textArr.length === 1 && !autoWrapText ? textArr[0] : textArr,
                    moreThanMaxCharacters,
                    maxLineWidth: cellWidth - (padding[1] + padding[3] + hierarchyOffset),
                    textBaseline: 'top',
                    autoWrapText,
                    lineClamp,
                    wordBreak: 'break-word',
                    heightLimit: cellHeight - Math.floor(padding[0] + padding[2]),
                    pickable: false,
                    dx: textAlign === 'left' ? hierarchyOffset : 0,
                    x
                };
                textMark.setAttributes(cellTheme.text ? Object.assign({}, cellTheme.text, attribute) : attribute);
                if (textMark.attribute.text) {
                    const textBaseline = cellTheme.text.textBaseline;
                    const height = cellHeight - (padding[0] + padding[2]);
                    let y = 0;
                    if (textBaseline === 'middle') {
                        y = padding[0] + (height - textMark.AABBBounds.height()) / 2;
                    }
                    else if (textBaseline === 'bottom') {
                        y = padding[0] + height - textMark.AABBBounds.height();
                    }
                    else {
                        y = padding[0];
                    }
                    textMark.setAttributes({
                        y
                    });
                }
            }
            return oldCellGroup;
        }
        if (!addNew && oldCellGroup.role === 'empty') {
            return undefined;
        }
        const type = isVtableMerge || isCustomMerge
            ? 'text'
            : table.isHeader(col, row)
                ? table._getHeaderLayoutMap(col, row).headerType ?? 'text'
                : table.getBodyColumnType(col, row) ?? 'text';
        const padding = cellTheme._vtable.padding;
        const textAlign = cellTheme.text.textAlign;
        const textBaseline = cellTheme.text.textBaseline;
        let newCellGroup;
        let cellWidth;
        let cellHeight;
        if (range) {
            cellWidth = table.getColsWidth(range.start.col, range.end.col);
            cellHeight = table.getRowsHeight(range.start.row, range.end.row);
        }
        else {
            cellWidth = table.getColWidth(col);
            cellHeight = table.getRowHeight(row);
        }
        if (isPromise(value)) {
            oldCellGroup.removeAllChild();
            dealPromiseData(value, table, callUpdateCellContentForPromiseValue.bind(null, {
                type,
                value,
                define,
                table,
                col,
                row,
                cellWidth,
                cellHeight,
                oldCellGroup,
                padding,
                textAlign,
                textBaseline,
                mayHaveIcon,
                addNew,
                range,
                customResult,
                customStyle
            }));
        }
        else {
            newCellGroup = updateCellContent(type, value, define, table, col, row, cellWidth, cellHeight, oldCellGroup, padding, textAlign, textBaseline, mayHaveIcon, addNew, cellTheme, range, customResult);
        }
        if (isMerge) {
            const { width: contentWidth } = newCellGroup.attribute;
            const { height: contentHeight } = newCellGroup.attribute;
            newCellGroup.contentWidth = contentWidth;
            newCellGroup.contentHeight = contentHeight;
            if (isShadow) {
                dealWithMergeCellSizeForShadow(range, cellWidth, cellHeight, padding, textAlign, textBaseline, table, newCellGroup);
            }
            else {
                dealWithMergeCellSize(range, cellWidth, cellHeight, padding, textAlign, textBaseline, table);
            }
        }
        return newCellGroup;
    }
    function updateCellContent(type, value, define, table, col, row, cellWidth, cellHeight, oldCellGroup, padding, textAlign, textBaseline, mayHaveIcon, addNew, cellTheme, range, customResult) {
        if (isPromise(value)) {
            value = table.getCellValue(col, row);
        }
        if (!addNew && (oldCellGroup.row !== row || oldCellGroup.col !== col)) {
            return null;
        }
        if (!addNew && oldCellGroup.parent) {
            if (table.reactCustomLayout) {
                const reactGroup = oldCellGroup.getChildByName('custom-container');
                if (reactGroup) {
                    const { col, row } = reactGroup;
                    if (isNumber$4(col) && isNumber$4(row)) {
                        table.reactCustomLayout.removeCustomCell(col, row);
                    }
                }
            }
        }
        const newCellGroup = createCell(type, value, define, table, col, row, table.getColWidth(col), cellWidth, cellHeight, addNew ? table.scenegraph.getColGroup(col) : oldCellGroup.parent, addNew ? 0 : table.scenegraph.getCellGroupY(row), padding, textAlign, textBaseline, mayHaveIcon, cellTheme, range, customResult);
        if (!addNew && oldCellGroup.parent) {
            oldCellGroup.parent.insertAfter(newCellGroup, oldCellGroup);
            oldCellGroup.parent.removeChild(oldCellGroup);
            if (table.scenegraph?.proxy.cellCache.get(col)) {
                table.scenegraph?.proxy.cellCache.set(col, newCellGroup);
            }
        }
        return newCellGroup;
    }
    function canUseFastUpdate(col, row, oldCellGroup, autoWrapText, mayHaveIcon, table) {
        const cellType = table.getBodyColumnType(col, row);
        const autoRowHeight = table.isAutoRowHeight(row);
        const value = table.getCellValue(col, row);
        if (!table.isHeader(col, row) &&
            oldCellGroup.role === 'cell' &&
            cellType === 'text' &&
            !autoWrapText &&
            !autoRowHeight &&
            !mayHaveIcon &&
            oldCellGroup.firstChild?.type === 'text' &&
            !isPromise(value)) {
            return true;
        }
        return false;
    }
    function callUpdateCellContentForPromiseValue(updateCellArgs) {
        const { type, value, define, table, col, row, cellWidth, cellHeight, oldCellGroup, padding, textAlign, textBaseline, mayHaveIcon, addNew, range, customResult, customStyle } = updateCellArgs;
        const cellStyle = customStyle || table._getCellStyle(range ? range.start.col : col, range ? range.start.row : row);
        const cellTheme = getStyleTheme(cellStyle, table, range ? range.start.col : col, range ? range.start.row : row, getProp).theme;
        cellTheme.group.cornerRadius = getCellCornerRadius(col, row, table);
        updateCellContent(type, value, define, table, col, row, cellWidth, cellHeight, oldCellGroup, padding, textAlign, textBaseline, mayHaveIcon, addNew, cellTheme, range, customResult);
    }
    function dealWithMergeCellSize(range, cellWidth, cellHeight, padding, textAlign, textBaseline, table) {
        for (let col = range.start.col; col <= range.end.col; col++) {
            for (let row = range.start.row; row <= range.end.row; row++) {
                const cellGroup = table.scenegraph.highPerformanceGetCell(col, row, true);
                if (cellGroup.role !== 'cell') {
                    continue;
                }
                if (range.start.row !== range.end.row && cellGroup.contentHeight !== cellHeight) {
                    updateCellContentHeight(cellGroup, cellHeight, cellHeight, table.isAutoRowHeight(row), padding, textAlign, textBaseline, table);
                }
                if (range.start.col !== range.end.col && cellGroup.contentWidth !== cellWidth) {
                    updateCellContentWidth(cellGroup, cellWidth, cellHeight, 0, table.isAutoRowHeight(row), padding, textAlign, textBaseline, table.scenegraph);
                }
                cellGroup.contentWidth = cellWidth;
                cellGroup.contentHeight = cellHeight;
                const rangeHeight = table.getRowHeight(row);
                const rangeWidth = table.getColWidth(col);
                resizeCellGroup(cellGroup, rangeWidth, rangeHeight, range, table);
            }
        }
    }
    function dealWithMergeCellSizeForShadow(range, cellWidth, cellHeight, padding, textAlign, textBaseline, table, cellGroup) {
        const { col, row } = cellGroup;
        if (range.start.row !== range.end.row && cellGroup.contentHeight !== cellHeight) {
            updateCellContentHeight(cellGroup, cellHeight, cellHeight, table.isAutoRowHeight(row), padding, textAlign, textBaseline, table);
        }
        if (range.start.col !== range.end.col && cellGroup.contentWidth !== cellWidth) {
            updateCellContentWidth(cellGroup, cellWidth, cellHeight, 0, table.isAutoRowHeight(row), padding, textAlign, textBaseline, table.scenegraph);
        }
        cellGroup.contentWidth = cellWidth;
        cellGroup.contentHeight = cellHeight;
        const rangeHeight = table.getRowHeight(row);
        const rangeWidth = table.getColWidth(col);
        resizeCellGroup(cellGroup, rangeWidth, rangeHeight, range, table);
    }
    function resizeCellGroup(cellGroup, rangeWidth, rangeHeight, range, table) {
        const { col, row } = cellGroup;
        const dx = -table.getColsWidth(range.start.col, col - 1);
        let dy = 0;
        if (table.options.customConfig?._disableColumnAndRowSizeRound) {
            for (let i = range.start.row; i <= row - 1; i++) {
                dy -= table.getRowHeight(i);
            }
        }
        else {
            dy = -table.getRowsHeight(range.start.row, row - 1);
        }
        cellGroup.forEachChildren((child) => {
            if (typeof child._dx === 'number') {
                child.skipMergeUpdate = true;
                child.setAttributes({
                    dx: (child._dx ?? 0) + dx
                });
                child.skipMergeUpdate = false;
            }
            else {
                child.skipMergeUpdate = true;
                child._dx = child.attribute.dx ?? 0;
                child.setAttributes({
                    dx: (child.attribute.dx ?? 0) + dx
                });
                child.skipMergeUpdate = false;
            }
            if (typeof child._dy === 'number') {
                child.skipMergeUpdate = true;
                child.setAttributes({
                    dy: (child._dy ?? 0) + dy
                });
                child.skipMergeUpdate = false;
            }
            else {
                child._dy = child.attribute.dy ?? 0;
                child.skipMergeUpdate = true;
                child.setAttributes({
                    dy: (child.attribute.dy ?? 0) + dy
                });
                child.skipMergeUpdate = false;
            }
        });
        const lineWidth = cellGroup.attribute.strokeArrayWidth ?? cellGroup.attribute.lineWidth;
        const isLineWidthArray = isArray$7(lineWidth);
        const newLineWidth = [0, 0, 0, 0];
        if (col === range.start.col) {
            newLineWidth[3] = isLineWidthArray ? lineWidth[3] : lineWidth;
        }
        if (row === range.start.row) {
            newLineWidth[0] = isLineWidthArray ? lineWidth[0] : lineWidth;
        }
        if (col === range.end.col) {
            newLineWidth[1] = isLineWidthArray ? lineWidth[1] : lineWidth;
        }
        if (row === range.end.row) {
            newLineWidth[2] = isLineWidthArray ? lineWidth[2] : lineWidth;
        }
        const widthChange = rangeWidth !== cellGroup.attribute.width;
        const heightChange = rangeHeight !== cellGroup.attribute.height;
        cellGroup.skipMergeUpdate = true;
        cellGroup.setAttributes({
            width: rangeWidth,
            height: rangeHeight,
            strokeArrayWidth: newLineWidth
        });
        cellGroup.skipMergeUpdate = false;
        cellGroup.mergeStartCol = range.start.col;
        cellGroup.mergeStartRow = range.start.row;
        cellGroup.mergeEndCol = range.end.col;
        cellGroup.mergeEndRow = range.end.row;
        return {
            widthChange,
            heightChange
        };
    }
    function getCustomCellMergeCustom(col, row, cellGroup, table) {
        if (table.internalProps.customMergeCell) {
            const customMerge = table.getCustomMerge(col, row);
            if (customMerge) {
                const { range: customMergeRange, text: customMergeText, style: customMergeStyle, customLayout: customMergeLayout, customRender: customMergeRender } = customMerge;
                if (customMergeLayout || customMergeRender) {
                    const customResult = dealWithCustom(customMergeLayout, customMergeRender, customMergeRange.start.col, customMergeRange.start.row, table.getColsWidth(customMergeRange.start.col, customMergeRange.end.col), table.getRowsHeight(customMergeRange.start.row, customMergeRange.end.row), false, table.isAutoRowHeight(row), [0, 0, 0, 0], customMergeRange, table);
                    const customElementsGroup = customResult.elementsGroup;
                    if (cellGroup.childrenCount > 0 && customElementsGroup) {
                        cellGroup.insertBefore(customElementsGroup, cellGroup.firstChild);
                    }
                    else if (customElementsGroup) {
                        cellGroup.appendChild(customElementsGroup);
                    }
                    const rangeHeight = table.getRowHeight(row);
                    const rangeWidth = table.getColWidth(col);
                    const { width: contentWidth } = cellGroup.attribute;
                    const { height: contentHeight } = cellGroup.attribute;
                    cellGroup.contentWidth = contentWidth;
                    cellGroup.contentHeight = contentHeight;
                    resizeCellGroup(cellGroup, rangeWidth, rangeHeight, customMergeRange, table);
                    return customMergeRange;
                }
            }
        }
        return undefined;
    }

    function isMergeCellGroup(cellGroup) {
        if (cellGroup.role === 'cell' &&
            isNumber$4(cellGroup.mergeStartCol) &&
            isNumber$4(cellGroup.mergeStartRow) &&
            isNumber$4(cellGroup.mergeEndCol) &&
            isNumber$4(cellGroup.mergeEndRow)) {
            return true;
        }
        return false;
    }

    const utilCheckBoxMark = new CheckBox({});
    const utilRadioMark = new Radio({});
    const utilButtonMark = new Tag$1({});
    function computeCheckboxCellHeight(cellValue, col, row, endCol, actStyle, autoWrapText, iconWidth, fontSize, fontStyle, fontWeight, fontFamily, lineHeight, lineClamp, padding, table) {
        const text = isObject$7(cellValue) ? cellValue.text : cellValue;
        const lines = validToString(text).split('\n') || [];
        const cellWidth = table.getColsWidth(col, endCol);
        const size = getProp('size', actStyle, col, row, table);
        let maxHeight = 0;
        if (autoWrapText) {
            const spaceBetweenTextAndIcon = getProp('spaceBetweenTextAndIcon', actStyle, col, row, table);
            const maxLineWidth = cellWidth - (padding[1] + padding[3]) - iconWidth - size - spaceBetweenTextAndIcon;
            utilCheckBoxMark.setAttributes({
                text: {
                    maxLineWidth,
                    text: lines,
                    fontSize,
                    fontStyle,
                    fontWeight,
                    fontFamily,
                    lineHeight,
                    wordBreak: 'break-word',
                    lineClamp
                },
                icon: {
                    width: Math.floor(size / 1.4),
                    height: Math.floor(size / 1.4)
                },
                box: {
                    width: size,
                    height: size
                },
                spaceBetweenTextAndIcon
            });
            utilCheckBoxMark.render();
            maxHeight = utilCheckBoxMark.AABBBounds.height();
        }
        else {
            maxHeight = Math.max(size, lines.length * lineHeight);
        }
        return maxHeight;
    }
    function computeRadioCellHeight(cellValue, col, row, endCol, actStyle, autoWrapText, iconWidth, fontSize, fontStyle, fontWeight, fontFamily, lineHeight, lineClamp, padding, table) {
        if (isArray$7(cellValue)) {
            let maxHeight = 0;
            const define = table.getBodyColumnDefine(col, row);
            const spaceBetweenRadio = getProp('spaceBetweenRadio', actStyle, col, row, table);
            const radioDirectionInCell = define?.radioDirectionInCell ?? 'vertical';
            if (radioDirectionInCell === 'vertical') {
                cellValue.forEach((singleValue, index) => {
                    const height = computeSingleRadioCellHeight(singleValue, col, row, endCol, actStyle, autoWrapText, iconWidth, fontSize, fontStyle, fontWeight, fontFamily, lineHeight, lineClamp, padding, table);
                    maxHeight += height;
                    if (index !== cellValue.length - 1) {
                        maxHeight += spaceBetweenRadio;
                    }
                });
            }
            else if (radioDirectionInCell === 'horizontal') {
                cellValue.forEach(singleValue => {
                    const height = computeSingleRadioCellHeight(singleValue, col, row, endCol, actStyle, autoWrapText, iconWidth, fontSize, fontStyle, fontWeight, fontFamily, lineHeight, lineClamp, padding, table);
                    maxHeight = Math.max(height, maxHeight);
                });
            }
            return maxHeight;
        }
        return computeSingleRadioCellHeight(cellValue, col, row, endCol, actStyle, autoWrapText, iconWidth, fontSize, fontStyle, fontWeight, fontFamily, lineHeight, lineClamp, padding, table);
    }
    function computeSingleRadioCellHeight(cellValue, col, row, endCol, actStyle, autoWrapText, iconWidth, fontSize, fontStyle, fontWeight, fontFamily, lineHeight, lineClamp, padding, table) {
        const text = isObject$7(cellValue) ? cellValue.text : cellValue;
        const lines = validToString(text).split('\n') || [];
        const cellWidth = table.getColsWidth(col, endCol);
        const size = getProp('size', actStyle, col, row, table);
        let outerRadius = getProp('outerRadius', actStyle, col, row, table);
        const circleSize = isNumber$4(outerRadius) ? outerRadius * 2 : size;
        let maxHeight = 0;
        if (autoWrapText) {
            const spaceBetweenTextAndIcon = getProp('spaceBetweenTextAndIcon', actStyle, col, row, table);
            const maxLineWidth = cellWidth - (padding[1] + padding[3]) - iconWidth - circleSize - spaceBetweenTextAndIcon;
            if (!isNumber$4(outerRadius)) {
                outerRadius = Math.round(size / 2);
            }
            utilRadioMark.setAttributes({
                text: {
                    maxLineWidth,
                    text: lines,
                    fontSize,
                    fontStyle,
                    fontWeight,
                    fontFamily,
                    lineHeight,
                    wordBreak: 'break-word',
                    lineClamp
                },
                circle: {
                    outerRadius
                },
                spaceBetweenTextAndIcon
            });
            utilRadioMark.render();
            maxHeight = utilRadioMark.AABBBounds.height();
        }
        else {
            maxHeight = Math.max(size, lines.length * lineHeight);
        }
        return maxHeight;
    }
    function computeSwitchCellHeight(cellValue, col, row, endCol, actStyle, autoWrapText, iconWidth, fontSize, fontStyle, fontWeight, fontFamily, lineHeight, lineClamp, padding, table) {
        const boxWidth = getProp('boxWidth', actStyle, col, row, table);
        return boxWidth;
    }
    function computeButtonCellHeight(cellValue, col, row, endCol, actStyle, autoWrapText, iconWidth, fontSize, fontStyle, fontWeight, fontFamily, lineHeight, lineClamp, padding, table) {
        const text = isObject$7(cellValue) ? cellValue.text : cellValue;
        const lines = validToString(text).split('\n') || [];
        const cellWidth = table.getColsWidth(col, endCol);
        const buttonPadding = getProp('buttonPadding', actStyle, col, row, table);
        const buttonLineWidth = getProp('buttonLineWidth', actStyle, col, row, table);
        let maxHeight = 0;
        if (autoWrapText) {
            const maxLineWidth = cellWidth - (padding[1] + padding[3]);
            utilButtonMark.setAttributes({
                text: lines,
                textStyle: {
                    maxLineWidth,
                    fontSize,
                    fontStyle,
                    fontWeight,
                    fontFamily,
                    lineHeight,
                    wordBreak: 'break-word',
                    lineClamp
                },
                padding: buttonPadding,
                panel: {
                    visible: true,
                    fill: 'red',
                    stroke: 'red',
                    lineWidth: buttonLineWidth
                }
            });
            utilRadioMark.render();
            maxHeight = utilRadioMark.AABBBounds.height();
        }
        else {
            maxHeight = lines.length * lineHeight + buttonPadding * 2;
        }
        return maxHeight;
    }

    let customAlphabetCharSet = '';
    let textMeasureMode = 'quick';
    const textMeasureModule = new ContainerModule((bind, unbind, isBound, rebind) => {
        if (isBound(TextMeasureContribution)) {
            rebind(TextMeasureContribution).to(FastTextMeasureContribution).inSingletonScope();
        }
        else {
            bind(TextMeasureContribution).to(FastTextMeasureContribution).inSingletonScope();
        }
    });
    const restoreTextMeasureModule = new ContainerModule((bind, unbind, isBound, rebind) => {
        if (isBound(TextMeasureContribution)) {
            rebind(TextMeasureContribution).to(DefaultTextMeasureContribution).inSingletonScope();
        }
        else {
            bind(TextMeasureContribution).to(DefaultTextMeasureContribution).inSingletonScope();
        }
    });
    const initTextMeasure = (textSpec, option, useNaiveCanvas) => {
        return new TextMeasure({
            defaultFontParams: {
                fontFamily: DefaultTextStyle.fontFamily,
                fontSize: DefaultTextStyle.fontSize
            },
            getTextBounds: useNaiveCanvas ? undefined : getTextBounds,
            specialCharSet: `{}()//&-/: .,@%'"~…=——${TextMeasure.ALPHABET_CHAR_SET}${TextMeasure.ALPHABET_CHAR_SET.toUpperCase()}0123456789${customAlphabetCharSet}`,
            ...(option ?? {})
        }, textSpec);
    };
    const fastTextMeasureCache = new Map();
    function getFastTextMeasure(fontSize, fontWeight, fontFamily, fontStyle = 'normal') {
        const key = `${fontSize}-${fontWeight}-${fontFamily}-${fontStyle}`;
        const cache = fastTextMeasureCache.get(key);
        if (cache) {
            return cache;
        }
        const fastTextMeasure = initTextMeasure({
            fontSize,
            fontFamily,
            fontWeight,
            fontStyle
        });
        fastTextMeasureCache.set(key, fastTextMeasure);
        return fastTextMeasure;
    }
    class FastTextMeasureContribution extends DefaultTextMeasureContribution {
        _fastMeasure(text, options) {
            const { fontSize, fontFamily = 'Arial,sans-serif', fontWeight = 'normal', fontStyle = 'normal' } = options;
            const fastTextMeasure = getFastTextMeasure(fontSize, fontWeight, fontFamily, fontStyle);
            const textMeasure = fastTextMeasure.measure(text, textMeasureMode);
            if (!isValid$3(textMeasure.fontBoundingBoxAscent) && !isValid$3(textMeasure.fontBoundingBoxDescent)) {
                const { ascent, descent } = this.measureTextBoundADscentEstimate(options);
                textMeasure.fontBoundingBoxAscent = ascent;
                textMeasure.fontBoundingBoxDescent = descent;
            }
            return textMeasure;
        }
        measureTextWidth(text, options) {
            return this._fastMeasure(text, options).width;
        }
        measureText(text, options) {
            return this._fastMeasure(text, options);
        }
        _measureTextWithoutAlignBaseline(text, options, compatible) {
            return this._fastMeasure(text, options);
        }
        _measureTextWithAlignBaseline(text, options, compatible) {
            return this._fastMeasure(text, options);
        }
    }
    class TextMeasureTool {
        measureText(text, options) {
            const { fontSize, fontFamily = 'Arial,sans-serif', fontWeight = 'normal', fontStyle = 'normal' } = options;
            const fastTextMeasure = getFastTextMeasure(fontSize, fontWeight, fontFamily, fontStyle);
            const textMeasure = fastTextMeasure.measure(text, textMeasureMode);
            return textMeasure;
        }
        measureTextWidth(text, options) {
            const { fontSize, fontFamily = 'Arial,sans-serif', fontWeight = 'normal', fontStyle = 'normal' } = options;
            const fastTextMeasure = getFastTextMeasure(fontSize, fontWeight, fontFamily, fontStyle);
            const textMeasure = fastTextMeasure.measure(text, textMeasureMode);
            return textMeasure.width;
        }
        clipText(text, options, width) {
            if (text.length === 0) {
                return { str: '', width: 0 };
            }
            let length = this.measureTextWidth(text, options);
            if (length <= width) {
                return { str: text, width: length };
            }
            length = this.measureTextWidth(text[0], options);
            if (length > width) {
                return { str: '', width: 0 };
            }
            return this._clipText(text, options, width, 0, text.length - 1);
        }
        _clipText(text, options, width, leftIdx, rightIdx) {
            const middleIdx = Math.floor((leftIdx + rightIdx) / 2);
            const subText = text.substring(0, middleIdx + 1);
            const strWidth = this.measureTextWidth(subText, options);
            let length;
            if (strWidth > width) {
                if (subText.length <= 1) {
                    return { str: '', width: 0 };
                }
                const str = text.substring(0, middleIdx);
                length = this.measureTextWidth(str, options);
                if (length <= width) {
                    return { str, width: length };
                }
                return this._clipText(text, options, width, leftIdx, middleIdx);
            }
            else if (strWidth < width) {
                if (middleIdx >= text.length - 1) {
                    return { str: text, width: this.measureTextWidth(text, options) };
                }
                const str = text.substring(0, middleIdx + 2);
                length = this.measureTextWidth(str, options);
                if (length >= width) {
                    return { str: subText, width: strWidth };
                }
                return this._clipText(text, options, width, middleIdx, rightIdx);
            }
            return { str: subText, width: strWidth };
        }
        clipTextWithSuffix(text, options, width, suffix) {
            if (suffix === '') {
                return this.clipText(text, options, width);
            }
            if (text.length === 0) {
                return { str: '', width: 0 };
            }
            const length = this.measureTextWidth(text, options);
            if (length <= width) {
                return { str: text, width: length };
            }
            const suffixWidth = this.measureTextWidth(suffix, options);
            if (suffixWidth > width) {
                return { str: '', width: 0 };
            }
            width -= suffixWidth;
            const data = this._clipText(text, options, width, 0, text.length - 1);
            data.str += suffix;
            data.width += suffixWidth;
            return data;
        }
    }
    const textMeasure = new TextMeasureTool();
    function setCustomAlphabetCharSet(str) {
        customAlphabetCharSet = str;
        fastTextMeasureCache.clear();
    }
    function restoreMeasureText() {
        textMeasureMode = 'canvas';
        container.load(restoreTextMeasureModule);
    }
    const utilTextMark = new Text$1({
        ignoreBuf: true
    });
    function measureTextBounds(attribute) {
        utilTextMark.initAttributes({
            ...attribute,
            ignoreBuf: true
        });
        return utilTextMark.AABBBounds;
    }

    const utilRichTextMark = new RichText({
        width: 0,
        height: 0,
        textConfig: []
    });
    function computeRowsHeight(table, rowStart, rowEnd, isClearRowRangeHeightsMap = true, update) {
        typeof window !== 'undefined' ? window.performance.now() : 0;
        const oldRowHeights = [];
        const newHeights = [];
        if (update) {
            for (let row = rowStart; row <= rowEnd; row++) {
                oldRowHeights[row] = table.getRowHeight(row);
            }
        }
        const layoutMap = table.internalProps.layoutMap;
        if (table.isPivotTable()) {
            layoutMap.enableUseGetBodyCache();
            layoutMap.enableUseHeaderPathCache();
        }
        table.defaultHeaderRowHeight;
        table.defaultHeaderColWidth;
        const isDefaultHeaderHasAuto = table.defaultHeaderRowHeight === 'auto' ||
            (isArray$7(table.defaultHeaderRowHeight) && table.defaultHeaderRowHeight.some(item => item === 'auto'));
        const isAllRowsAuto = table.isAutoRowHeight(rowStart) ||
            (table.heightMode === 'adaptive' && table.options.autoHeightInAdaptiveMode !== false);
        const isDefaultRowHeightIsAuto = table.options.defaultRowHeight === 'auto';
        if (isAllRowsAuto || isDefaultHeaderHasAuto || isDefaultRowHeightIsAuto) {
            rowStart = rowStart ?? 0;
            rowEnd = rowEnd ?? table.rowCount - 1;
            if ((rowStart === 0 && rowEnd === table.rowCount - 1) || isClearRowRangeHeightsMap) {
                table._clearRowRangeHeightsMap();
            }
            for (let row = rowStart; row < table.columnHeaderLevelCount; row++) {
                let startCol = 0;
                let endCol = table.colCount - 1;
                if (((table.isPivotTable() && !table.isPivotChart()) ||
                    (table.isPivotChart() && !table.internalProps.layoutMap.indicatorsAsCol)) &&
                    checkPivotFixedStyleAndNoWrap(table, row) &&
                    !getCellMergeInfo(table, table.rowHeaderLevelCount, row)) {
                    startCol = 0;
                    endCol = table.rowHeaderLevelCount;
                }
                if (isAllRowsAuto || table.getDefaultRowHeight(row) === 'auto') {
                    const height = computeRowHeight(row, startCol, endCol, table);
                    newHeights[row] = Math.round(height);
                    if (table.heightAdaptiveMode === 'only-body' || !update) {
                        table._setRowHeight(row, height);
                    }
                }
            }
            for (let row = table.rowCount - table.bottomFrozenRowCount; row <= rowEnd; row++) {
                if (isAllRowsAuto || table.getDefaultRowHeight(row) === 'auto') {
                    const height = computeRowHeight(row, 0, table.colCount - 1, table);
                    if (update) {
                        newHeights[row] = Math.round(height);
                    }
                    else {
                        table._setRowHeight(row, height);
                    }
                }
            }
            if (rowEnd < table.columnHeaderLevelCount || (!isAllRowsAuto && !isDefaultRowHeightIsAuto)) ;
            else {
                if (!(table.internalProps.transpose ||
                    (table.isPivotTable() && !table.internalProps.layoutMap.indicatorsAsCol)) &&
                    !table.options.customComputeRowHeight &&
                    checkFixedStyleAndNoWrap(table, rowStart)) {
                    const height = computeRowHeight(table.columnHeaderLevelCount, 0, table.colCount - 1, table);
                    fillRowsHeight(height, table.columnHeaderLevelCount, table.rowCount - 1 - table.bottomFrozenRowCount, table, update ? newHeights : undefined);
                    for (let row = table.rowCount - table.bottomFrozenRowCount; row <= rowEnd; row++) {
                        const height = computeRowHeight(row, 0, table.colCount - 1, table);
                        if (update) {
                            newHeights[row] = Math.round(height);
                        }
                        else {
                            table._setRowHeight(row, height);
                        }
                    }
                }
                else if (table.internalProps.transpose ||
                    (table.isPivotTable() && !table.internalProps.layoutMap.indicatorsAsCol)) {
                    for (let row = Math.max(rowStart, table.columnHeaderLevelCount); row <= rowEnd; row++) {
                        let height;
                        if (checkFixedStyleAndNoWrapForTranspose(table, row)) {
                            height = computeRowHeight(row, 0, table.rowHeaderLevelCount, table);
                        }
                        else {
                            height = computeRowHeight(row, 0, table.colCount - 1, table);
                        }
                        if (update) {
                            newHeights[row] = Math.round(height);
                        }
                        else {
                            table._setRowHeight(row, height);
                        }
                    }
                }
                else {
                    for (let row = Math.max(rowStart, table.columnHeaderLevelCount); row <= rowEnd; row++) {
                        const height = computeRowHeight(row, 0, table.colCount - 1, table);
                        if (update) {
                            newHeights[row] = Math.round(height);
                        }
                        else {
                            table._setRowHeight(row, height);
                        }
                    }
                }
            }
        }
        else {
            if (table.heightMode === 'adaptive' || table.autoFillHeight) {
                table.clearRowHeightCache();
            }
            if (update) {
                for (let row = rowStart; row <= rowEnd; row++) {
                    newHeights[row] = table.getRowHeight(row);
                }
            }
        }
        if ((rowStart === 0 && rowEnd === table.rowCount - 1) || isClearRowRangeHeightsMap) {
            table._clearRowRangeHeightsMap();
        }
        if (table.heightMode === 'adaptive') {
            table._clearRowRangeHeightsMap();
            let totalDrawHeight = table.tableNoFrameHeight;
            let startRow = 0;
            let endRow = table.rowCount;
            if (table.heightAdaptiveMode === 'only-body') {
                const columnHeaderHeight = table.getRowsHeight(0, table.columnHeaderLevelCount - 1);
                const bottomHeaderHeight = table.isPivotChart() ? table.getBottomFrozenRowsHeight() : 0;
                totalDrawHeight = table.tableNoFrameHeight - columnHeaderHeight - bottomHeaderHeight;
                startRow = table.columnHeaderLevelCount;
                endRow = table.isPivotChart() ? table.rowCount - table.bottomFrozenRowCount : table.rowCount;
            }
            let actualHeight = 0;
            for (let row = startRow; row < endRow; row++) {
                actualHeight += update ? newHeights[row] ?? table.getRowHeight(row) : table.getRowHeight(row);
            }
            const factor = totalDrawHeight / actualHeight;
            for (let row = startRow; row < endRow; row++) {
                let rowHeight;
                if (row === endRow - 1) {
                    rowHeight =
                        totalDrawHeight -
                            (update
                                ? newHeights.reduce((acr, cur, index) => {
                                    if (index >= startRow && index <= endRow - 2) {
                                        return acr + cur;
                                    }
                                    return acr;
                                }, 0)
                                : table.getRowsHeight(startRow, endRow - 2));
                }
                else {
                    rowHeight = Math.round((update ? newHeights[row] ?? table.getRowHeight(row) : table.getRowHeight(row)) * factor);
                }
                if (update) {
                    newHeights[row] = rowHeight;
                }
                else {
                    table._setRowHeight(row, rowHeight, false);
                }
            }
        }
        else if (table.autoFillHeight) {
            table._clearRowRangeHeightsMap();
            const canvasHeight = table.tableNoFrameHeight;
            let actualHeight = 0;
            let actualHeaderHeight = 0;
            for (let row = 0; row < table.rowCount; row++) {
                const rowHeight = update ? newHeights[row] ?? table.getRowHeight(row) : table.getRowHeight(row);
                if (row < table.columnHeaderLevelCount ||
                    (table.isPivotChart() && row >= table.rowCount - table.bottomFrozenRowCount)) {
                    actualHeaderHeight += rowHeight;
                }
                actualHeight += rowHeight;
            }
            table.scenegraph._dealAutoFillHeightOriginRowsHeight = actualHeight;
            if (actualHeight < canvasHeight && actualHeight - actualHeaderHeight > 0) {
                const startRow = table.columnHeaderLevelCount;
                const endRow = table.isPivotChart() ? table.rowCount - table.bottomFrozenRowCount : table.rowCount;
                const factor = (canvasHeight - actualHeaderHeight) / (actualHeight - actualHeaderHeight);
                for (let row = startRow; row < endRow; row++) {
                    let rowHeight;
                    if (row === endRow - 1) {
                        rowHeight =
                            canvasHeight -
                                actualHeaderHeight -
                                (update
                                    ? newHeights.reduce((acr, cur, index) => {
                                        if (index >= startRow && index <= endRow - 2) {
                                            return acr + cur;
                                        }
                                        return acr;
                                    }, 0)
                                    : table.getRowsHeight(startRow, endRow - 2));
                    }
                    else {
                        rowHeight = Math.round((update ? newHeights[row] ?? table.getRowHeight(row) : table.getRowHeight(row)) * factor);
                    }
                    if (update) {
                        newHeights[row] = rowHeight;
                    }
                    else {
                        table._setRowHeight(row, rowHeight, false);
                    }
                }
            }
        }
        if (update) {
            for (let row = rowStart; row <= rowEnd; row++) {
                const newRowHeight = newHeights[row] ?? table.getRowHeight(row);
                if (isValid$3(newRowHeight)) {
                    table._setRowHeight(row, newRowHeight);
                }
            }
            for (let row = 0; row <= table.frozenRowCount - 1; row++) {
                const newRowHeight = table.getRowHeight(row);
                if (newRowHeight !== (oldRowHeights[row] ?? table.getRowHeight(row))) {
                    table.scenegraph.updateRowHeight(row, newRowHeight - (oldRowHeights[row] ?? table.getRowHeight(row)), true);
                }
            }
            for (let row = table.rowCount - table.bottomFrozenRowCount; row <= table.rowCount - 1; row++) {
                const newRowHeight = table.getRowHeight(row);
                if (newRowHeight !== (oldRowHeights[row] ?? table.getRowHeight(row))) {
                    table.scenegraph.updateRowHeight(row, newRowHeight - (oldRowHeights[row] ?? table.getRowHeight(row)), true);
                }
            }
            for (let row = table.scenegraph.proxy.rowStart; row <= table.scenegraph.proxy.rowEnd; row++) {
                const newRowHeight = table.getRowHeight(row);
                if (newRowHeight !== (oldRowHeights[row] ?? table.getRowHeight(row))) {
                    table.scenegraph.updateRowHeight(row, newRowHeight - (oldRowHeights[row] ?? table.getRowHeight(row)), true);
                }
            }
        }
        if (table.isPivotTable()) {
            layoutMap.disableUseGetBodyCache();
            layoutMap.disableUseHeaderPathCache();
        }
    }
    function computeRowHeight(row, startCol, endCol, table) {
        const isAllRowsAuto = table.isAutoRowHeight(row) || (table.heightMode === 'adaptive' && table.options.autoHeightInAdaptiveMode !== false);
        if (!isAllRowsAuto && table.getDefaultRowHeight(row) !== 'auto') {
            return table.getDefaultRowHeight(row);
        }
        let maxHeight;
        if (table.options.customComputeRowHeight) {
            const customRowHeight = table.options.customComputeRowHeight({
                row,
                table
            });
            if (typeof customRowHeight === 'number') {
                return customRowHeight;
            }
            else if (customRowHeight !== 'auto') {
                return table.getDefaultRowHeight(row);
            }
        }
        if (table.isPivotChart() &&
            row >= table.columnHeaderLevelCount &&
            row < table.rowCount - table.bottomFrozenRowCount) {
            if (table.internalProps.layoutMap.indicatorsAsCol) {
                const optimunHeight = table.internalProps.layoutMap.getOptimunHeightForChart(row);
                if (optimunHeight > 0) {
                    return optimunHeight;
                }
            }
            else {
                const defaultHeight = table.getDefaultRowHeight(row);
                if (isNumber$4(defaultHeight)) {
                    return defaultHeight;
                }
            }
        }
        for (let col = startCol; col <= endCol; col++) {
            const customHeight = computeCustomRenderHeight(col, row, table);
            if (customHeight) {
                maxHeight = isValid$3(maxHeight) ? Math.max(customHeight.height, maxHeight) : customHeight.height;
                if (!customHeight.renderDefault) {
                    continue;
                }
            }
            if (table.isPivotChart()) {
                const layout = table.internalProps.layoutMap;
                const axisConfig = layout.getAxisConfigInPivotChart(col, row);
                if (axisConfig) {
                    const computeAxisComponentHeight = Factory.getFunction('computeAxisComponentHeight');
                    const axisWidth = computeAxisComponentHeight(axisConfig, table);
                    if (typeof axisWidth === 'number') {
                        maxHeight = isValid$3(maxHeight) ? Math.max(axisWidth, maxHeight) : axisWidth;
                        continue;
                    }
                }
            }
            if (table.isPivotChart() &&
                ((table.isLeftFrozenColumn(col) && table.isBottomFrozenRow(row)) ||
                    (table.isRightFrozenColumn(col) && table.isBottomFrozenRow(row)))) {
                continue;
            }
            const cellType = table.isHeader(col, row)
                ? table._getHeaderLayoutMap(col, row)?.headerType
                : table.getBodyColumnType(col, row);
            const textHeight = computeTextHeight(col, row, cellType, table);
            maxHeight = isValid$3(maxHeight) ? Math.max(textHeight, maxHeight) : textHeight;
        }
        if (isValid$3(maxHeight)) {
            return maxHeight;
        }
        const defaultHeight = table.getDefaultRowHeight(row);
        return isNumber$4(defaultHeight) ? defaultHeight : table.defaultRowHeight;
    }
    function checkFixedStyleAndNoWrap(table, rowStart) {
        const { layoutMap } = table.internalProps;
        const row = table.columnHeaderLevelCount;
        if ((table.internalProps.autoWrapText || table.internalProps.enableLineBreak || table.isPivotChart()) &&
            (table.isAutoRowHeight(rowStart) || table.options.heightMode === 'adaptive')) {
            return false;
        }
        for (let col = 0; col < table.colCount; col++) {
            const cellDefine = layoutMap.getBody(col, row);
            if (cellDefine.cellType === 'radio') {
                return false;
            }
            if (typeof cellDefine.style === 'function' ||
                typeof cellDefine.icon === 'function' ||
                cellDefine.define?.customRender ||
                cellDefine.define?.customLayout ||
                typeof cellDefine.define?.icon === 'function') {
                return false;
            }
            const cellStyle = table._getCellStyle(col, row);
            if (typeof cellStyle.padding === 'function' ||
                typeof cellStyle.fontSize === 'function' ||
                typeof cellStyle.lineHeight === 'function' ||
                cellStyle.autoWrapText === true) {
                return false;
            }
        }
        return true;
    }
    function checkFixedStyleAndNoWrapForTranspose(table, row) {
        const { layoutMap } = table.internalProps;
        if ((table.internalProps.autoWrapText || table.internalProps.enableLineBreak) &&
            (table.isAutoRowHeight(row) || table.options.heightMode === 'adaptive')) {
            return false;
        }
        const cellDefine = layoutMap.getBody(table.rowHeaderLevelCount, row);
        if (typeof cellDefine.style === 'function' ||
            typeof cellDefine.icon === 'function' ||
            cellDefine.define?.customRender ||
            cellDefine.define?.customLayout ||
            typeof cellDefine.define?.icon === 'function') {
            return false;
        }
        const cellStyle = table._getCellStyle(table.rowHeaderLevelCount, row);
        if (typeof cellStyle.padding === 'function' ||
            typeof cellStyle.fontSize === 'function' ||
            typeof cellStyle.lineHeight === 'function' ||
            cellStyle.autoWrapText === true) {
            return false;
        }
        return true;
    }
    function checkPivotFixedStyleAndNoWrap(table, row) {
        const { layoutMap } = table.internalProps;
        if (table.internalProps.autoWrapText && (table.isAutoRowHeight(row) || table.options.heightMode === 'adaptive')) {
            return false;
        }
        const headerDefine = layoutMap.getHeader(table.rowHeaderLevelCount, row);
        if (typeof headerDefine.style === 'function' ||
            typeof headerDefine.icons === 'function' ||
            headerDefine.define?.headerCustomRender ||
            headerDefine.define?.headerCustomLayout ||
            typeof headerDefine.define?.icon === 'function') {
            return false;
        }
        const headerStyle = table._getCellStyle(table.rowHeaderLevelCount, row);
        if (typeof headerStyle.padding === 'function' ||
            typeof headerStyle.fontSize === 'function' ||
            typeof headerStyle.lineHeight === 'function' ||
            headerStyle.autoWrapText === true) {
            return false;
        }
        return true;
    }
    function fillRowsHeight(height, startRow, endRow, table, newHeights) {
        if (table.internalProps.useOneRowHeightFillAll) {
            return;
        }
        for (let row = startRow; row <= endRow; row++) {
            if (newHeights) {
                newHeights[row] = height;
            }
            else {
                table._setRowHeight(row, height);
            }
        }
        table.internalProps.useOneRowHeightFillAll = true;
    }
    function computeCustomRenderHeight(col, row, table) {
        const customRender = table.getCustomRender(col, row);
        let customLayout = table.getCustomLayout(col, row);
        if (customRender || customLayout) {
            let spanRow = 1;
            let height = 0;
            let renderDefault = false;
            let enableCellPadding = false;
            let cellRange;
            if (table.isHeader(col, row) ||
                table.getBodyColumnDefine(col, row)?.mergeCell ||
                table.hasCustomMerge()) {
                cellRange = table.getCellRange(col, row);
                spanRow = cellRange.end.row - cellRange.start.row + 1;
            }
            const arg = {
                col: cellRange?.start.col ?? col,
                row: cellRange?.start.row ?? row,
                dataValue: table.getCellOriginValue(col, row),
                value: table.getCellValue(col, row) || '',
                rect: getCellRect$1(col, row, table),
                table,
                originCol: col,
                originRow: row,
                forComputation: true
            };
            if (customLayout === 'react-custom-layout') {
                customLayout = table.reactCustomLayout?.getCustomLayoutFunc(col, row) || emptyCustomLayout;
            }
            if (isFunction$5(customLayout)) {
                const customLayoutObj = customLayout(arg);
                if (customLayoutObj.rootContainer) {
                    customLayoutObj.rootContainer = decodeReactDom(customLayoutObj.rootContainer);
                    dealPercentCalc(customLayoutObj.rootContainer, table.getColWidth(col), 0);
                    customLayoutObj.rootContainer.setStage(table.scenegraph.stage);
                    height = customLayoutObj.rootContainer.AABBBounds.height() ?? 0;
                    renderDefault = customLayoutObj.renderDefault;
                    enableCellPadding = customLayoutObj.enableCellPadding;
                }
                else {
                    height = 0;
                    renderDefault = customLayoutObj.renderDefault;
                    enableCellPadding = customLayoutObj.enableCellPadding;
                }
            }
            else if (typeof customRender === 'function') {
                const customRenderObj = customRender(arg);
                height = customRenderObj?.expectedHeight ?? 0;
                renderDefault = customRenderObj?.renderDefault;
            }
            else {
                height = customRender?.expectedHeight ?? 0;
                renderDefault = customRender?.renderDefault;
            }
            if (enableCellPadding) {
                const actStyle = table._getCellStyle(col, row);
                const padding = getQuadProps(getProp('padding', actStyle, col, row, table));
                height += padding[0] + padding[2];
            }
            return {
                height: height / spanRow,
                renderDefault
            };
        }
        return undefined;
    }
    function computeTextHeight(col, row, cellType, table) {
        let maxHeight = 0;
        const cellValue = table.getCellValue(col, row);
        const actStyle = table._getCellStyle(col, row);
        let iconHeight = 0;
        let iconWidth = 0;
        const iconInlineFront = [];
        let iconInlineFrontHeight = 0;
        const iconInlineEnd = [];
        let iconInlineEndHeight = 0;
        let mayHaveIcon = false;
        if (table.getCellLocation(col, row) !== 'body') {
            mayHaveIcon = true;
        }
        else {
            const define = table.getBodyColumnDefine(col, row);
            mayHaveIcon = !!define?.icon || !!define?.tree || define?.dragOrder;
        }
        if (mayHaveIcon) {
            const icons = table.getCellIcons(col, row);
            icons?.forEach(icon => {
                if (icon.positionType !== IconPosition.absoluteRight &&
                    icon.positionType !== IconPosition.inlineFront &&
                    icon.positionType !== IconPosition.inlineEnd) {
                    iconWidth += (icon.width ?? 0) + (icon.marginLeft ?? 0) + (icon.marginRight ?? 0);
                    iconHeight = Math.max(iconHeight, icon.height ?? 0);
                }
                else if (icon.positionType === IconPosition.inlineFront) {
                    iconInlineFront.push(icon);
                    iconInlineFrontHeight = Math.max(iconInlineFrontHeight, (icon.height ?? 0) + (icon.marginLeft ?? 0) + (icon.marginRight ?? 0));
                }
                else if (icon.positionType === IconPosition.inlineEnd) {
                    iconInlineEnd.push(icon);
                    iconInlineEndHeight = Math.max(iconInlineEndHeight, (icon.height ?? 0) + (icon.marginLeft ?? 0) + (icon.marginRight ?? 0));
                }
            });
        }
        let spanRow = 1;
        let endCol = col;
        if (table.isHeader(col, row) ||
            table.getBodyColumnDefine(col, row)?.mergeCell ||
            table.hasCustomMerge()) {
            const cellRange = table.getCellRange(col, row);
            spanRow = cellRange.end.row - cellRange.start.row + 1;
            col = cellRange.start.col;
            endCol = cellRange.end.col;
        }
        const padding = getQuadProps(getProp('padding', actStyle, col, row, table));
        const fontSize = getProp('fontSize', actStyle, col, row, table);
        const fontStyle = getProp('fontStyle', actStyle, col, row, table);
        const fontWeight = getProp('fontWeight', actStyle, col, row, table);
        const lineHeight = getProp('lineHeight', actStyle, col, row, table) ?? fontSize;
        const fontFamily = getProp('fontFamily', actStyle, col, row, table);
        const autoWrapText = getProp('autoWrapText', actStyle, col, row, table);
        const lineClamp = getProp('lineClamp', actStyle, col, row, table);
        const underline = getProp('underline', actStyle, col, row, table);
        const underlineOffset = getProp('underlineOffset', actStyle, col, row, table) ?? 0;
        let text;
        if (cellType !== 'text' &&
            cellType !== 'link' &&
            cellType !== 'progressbar' &&
            cellType !== 'checkbox' &&
            cellType !== 'radio' &&
            cellType !== 'switch' &&
            cellType !== 'button') {
            maxHeight = lineHeight;
        }
        else if (cellType === 'checkbox') {
            maxHeight = computeCheckboxCellHeight(cellValue, col, row, endCol, actStyle, autoWrapText, iconWidth, fontSize, fontStyle, fontWeight, fontFamily, lineHeight, lineClamp, padding, table);
        }
        else if (cellType === 'radio') {
            maxHeight = computeRadioCellHeight(cellValue, col, row, endCol, actStyle, autoWrapText, iconWidth, fontSize, fontStyle, fontWeight, fontFamily, lineHeight, lineClamp, padding, table);
        }
        else if (cellType === 'switch') {
            maxHeight = computeSwitchCellHeight(cellValue, col, row, endCol, actStyle, autoWrapText, iconWidth, fontSize, fontStyle, fontWeight, fontFamily, lineHeight, lineClamp, padding, table);
        }
        else if (cellType === 'button') {
            maxHeight = computeButtonCellHeight(cellValue, col, row, endCol, actStyle, autoWrapText, iconWidth, fontSize, fontStyle, fontWeight, fontFamily, lineHeight, lineClamp, padding, table);
        }
        else {
            text = cellValue;
            const lines = breakString(text, table).text;
            const cellWidth = table.getColsWidth(col, endCol);
            if (iconInlineFront.length || iconInlineEnd.length) {
                if (autoWrapText) {
                    const textOption = Object.assign({
                        text: cellValue?.toString(),
                        fontFamily,
                        fontSize,
                        fontStyle,
                        fontWeight,
                        lineHeight
                    });
                    textOption.textBaseline = 'middle';
                    const textConfig = [
                        ...iconInlineFront.map(icon => dealWithRichTextIcon(icon)),
                        textOption,
                        ...iconInlineEnd.map(icon => dealWithRichTextIcon(icon))
                    ];
                    utilRichTextMark.setAttributes({
                        width: cellWidth - (padding[1] + padding[3]) - iconWidth,
                        height: 0,
                        textConfig
                    });
                    maxHeight = utilRichTextMark.AABBBounds.height();
                }
                else {
                    maxHeight = 0;
                    lines.forEach((line, index) => {
                        if (table.options.customConfig?.multilinesForXTable && index !== 0) {
                            return;
                        }
                        if (index === 0 && iconInlineFront.length) {
                            maxHeight += Math.max(lineHeight, iconInlineFrontHeight);
                        }
                        else if (index === lines.length - 1 && iconInlineEnd.length) {
                            maxHeight += Math.max(lineHeight, iconInlineEndHeight);
                        }
                        else {
                            maxHeight += lineHeight;
                        }
                    });
                }
            }
            else if (autoWrapText) {
                const hierarchyOffset = getHierarchyOffset(col, row, table);
                const maxLineWidth = cellWidth - (padding[1] + padding[3]) - iconWidth - hierarchyOffset;
                const bounds = measureTextBounds({
                    maxLineWidth,
                    text: lines,
                    fontSize,
                    fontStyle,
                    fontWeight,
                    fontFamily,
                    lineHeight,
                    wordBreak: 'break-word',
                    whiteSpace: lines.length === 1 && !autoWrapText ? 'no-wrap' : 'normal',
                    lineClamp
                });
                maxHeight =
                    (bounds.height() || (typeof lineHeight === 'number' ? lineHeight : fontSize)) +
                        (underline ? underlineOffset : 0);
            }
            else {
                if (table.options.customConfig?.multilinesForXTable) {
                    maxHeight = lineHeight;
                }
                else {
                    maxHeight = lines.length * lineHeight;
                }
            }
        }
        return (Math.max(maxHeight, iconHeight) + padding[0] + padding[2]) / spanRow;
    }
    function getCellRect$1(col, row, table) {
        return {
            left: 0,
            top: 0,
            right: table.getColWidth(col),
            bottom: table.getRowHeight(row),
            width: table.getColWidth(col),
            height: 0
        };
    }

    function getCellMergeRange(cellGroup, scene) {
        if (!scene || !scene.proxy) {
            return {
                colStart: 0,
                colEnd: 0,
                rowStart: 0,
                rowEnd: 0
            };
        }
        const { mergeStartCol, mergeEndCol, mergeStartRow, mergeEndRow, col, row } = cellGroup;
        const cellRangeColStart = mergeStartCol;
        const cellRangeColEnd = mergeEndCol;
        const cellRangeRowStart = mergeStartRow;
        const cellRangeRowEnd = mergeEndRow;
        return {
            colStart: cellRangeColStart,
            colEnd: cellRangeColEnd,
            rowStart: cellRangeRowStart,
            rowEnd: cellRangeRowEnd
        };
    }
    function expendCellRange(cellRange, table) {
        const colStart = cellRange.start.col;
        const colEnd = cellRange.end.col;
        const rowStart = cellRange.start.row;
        const rowEnd = cellRange.end.row;
        let newColStart = colStart;
        let newColEnd = colEnd;
        let newRowStart = rowStart;
        let newRowEnd = rowEnd;
        for (let col = colStart; col <= colEnd; col++) {
            for (let row = rowStart; row <= rowEnd; row++) {
                const mergeRange = table.getCellRange(col, row);
                if (mergeRange) {
                    newColStart = Math.min(newColStart, mergeRange.start.col);
                    newColEnd = Math.max(newColEnd, mergeRange.end.col);
                    newRowStart = Math.min(newRowStart, mergeRange.start.row);
                    newRowEnd = Math.max(newRowEnd, mergeRange.end.row);
                }
            }
        }
        cellRange.start.col = newColStart;
        cellRange.end.col = newColEnd;
        cellRange.start.row = newRowStart;
        cellRange.end.row = newRowEnd;
        return cellRange;
    }

    function updateRowHeight(scene, row, detaY, skipTableHeightMap) {
        if (!skipTableHeightMap) {
            scene.table._setRowHeight(row, scene.table.getRowHeight(row) + detaY, true);
        }
        for (let col = 0; col < scene.table.colCount; col++) {
            const cell = scene.getCell(col, row);
            if (cell.role === 'empty') {
                continue;
            }
            const mergeInfo = getCellMergeInfo(scene.table, col, row);
            if (mergeInfo && mergeInfo.start.col !== col) {
                continue;
            }
            const height = cell.attribute.height;
            updateCellHeightForRow(scene, cell, col, row, height + detaY, detaY, scene.table.isHeader(col, row));
            scene.updateCellContentWhileResize(col, row);
        }
        let rowStart = 0;
        let rowEnd = 0;
        if (row < scene.table.frozenRowCount) {
            rowStart = row + 1;
            rowEnd = scene.table.frozenRowCount - 1;
        }
        else if (row >= scene.table.rowCount - scene.table.bottomFrozenRowCount) {
            rowStart = row + 1;
            rowEnd = scene.table.rowCount - 1;
        }
        else {
            rowStart = row + 1;
            rowEnd = Math.min(scene.proxy.rowEnd, scene.table.rowCount - scene.table.bottomFrozenRowCount - 1);
        }
        for (let colIndex = 0; colIndex < scene.table.colCount; colIndex++) {
            for (let rowIndex = rowStart; rowIndex <= rowEnd; rowIndex++) {
                const cellGroup = scene.highPerformanceGetCell(colIndex, rowIndex);
                if (cellGroup.role === 'cell') {
                    cellGroup.setAttribute('y', cellGroup.attribute.y + detaY);
                }
            }
        }
    }
    function updateCellHeightForRow(scene, cell, col, row, height, detaY, isHeader) {
        const cellGroup = cell;
        const distHeight = height;
        if (!cellGroup) {
            return;
        }
        updateCellHeight(scene, cellGroup, col, row, distHeight, detaY);
    }
    function updateCellHeight(scene, cell, col, row, distHeight, detaY, isHeader) {
        if (cell.attribute.height === distHeight && !cell.needUpdateHeight) {
            return;
        }
        cell.needUpdateHeight = false;
        cell.setAttribute('height', distHeight);
        const isVtableMerge = scene.table.getCellRawRecord(col, row)?.vtableMerge;
        const isCustomMerge = !!scene.table.getCustomMerge(col, row);
        const type = isVtableMerge || isCustomMerge
            ? 'text'
            : scene.table.isHeader(col, row)
                ? scene.table._getHeaderLayoutMap(col, row).headerType ?? 'text'
                : scene.table.getBodyColumnType(col, row) ?? 'text';
        if (type === 'progressbar') {
            const columnDefine = scene.table.getBodyColumnDefine(col, row);
            const style = scene.table._getCellStyle(col, row);
            const value = scene.table.getCellValue(col, row);
            const dataValue = scene.table.getCellOriginValue(col, row);
            const padding = getQuadProps(getProp('padding', style, col, row, scene.table));
            let range;
            if (columnDefine?.mergeCell) {
                range = scene.table.getCellRange(col, row);
            }
            const createProgressBarCell = Factory.getFunction('createProgressBarCell');
            const newBarCell = createProgressBarCell(columnDefine, style, cell.attribute.width, value, dataValue, col, row, padding, scene.table, range);
            const oldBarCell = cell.getChildByName('progress-bar');
            cell.insertBefore(newBarCell, oldBarCell);
            cell.removeChild(oldBarCell);
            oldBarCell.removeAllChild();
            oldBarCell.release();
            updateMergeCellContentHeight(cell, distHeight, detaY, scene.table.isAutoRowHeight(row), true, scene.table);
        }
        else if (type === 'sparkline') {
            cell.removeAllChild();
            const headerStyle = scene.table._getCellStyle(col, row);
            const padding = getQuadProps(getProp('padding', headerStyle, col, row, scene.table));
            const createSparkLineCellGroup = Factory.getFunction('createSparkLineCellGroup');
            createSparkLineCellGroup(cell, cell.parent, cell.attribute.x, cell.attribute.y, col, row, cell.attribute.width, cell.attribute.height, padding, scene.table, getStyleTheme(headerStyle, scene.table, col, row, getProp).theme, false);
        }
        else if (type === 'image' || type === 'video') {
            updateImageCellContentWhileResize(cell, col, row, 0, detaY, scene.table);
        }
        else if (cell.firstChild?.name === 'axis') {
            cell.firstChild?.originAxis.resize(cell.attribute.width, cell.attribute.height);
        }
        else {
            let renderDefault = true;
            const customContainer = cell.getChildByName(CUSTOM_CONTAINER_NAME) ||
                cell.getChildByName(CUSTOM_MERGE_CONTAINER_NAME);
            if (customContainer) {
                let customElementsGroup;
                cell.removeChild(customContainer);
                const customMergeRange = getCustomCellMergeCustom(col, row, cell, scene.table);
                if (customMergeRange) {
                    for (let mergeRow = customMergeRange.start.row; mergeRow <= customMergeRange.end.row; mergeRow++) {
                        if (mergeRow === row) {
                            continue;
                        }
                        const mergedCell = scene.getCell(col, mergeRow);
                        const customContainer = mergedCell.getChildByName(CUSTOM_CONTAINER_NAME) ||
                            mergedCell.getChildByName(CUSTOM_MERGE_CONTAINER_NAME);
                        customContainer.removeAllChild();
                        mergedCell.removeChild(customContainer);
                        getCustomCellMergeCustom(col, mergeRow, mergedCell, scene.table);
                    }
                }
                else {
                    let customRender;
                    let customLayout;
                    const cellLocation = scene.table.getCellLocation(col, row);
                    const { vtableMerge } = scene.table.getCellRawRecord(col, row) || {};
                    if (vtableMerge && scene.table.options.groupTitleCustomLayout) {
                        customLayout = scene.table.options.groupTitleCustomLayout;
                    }
                    else if (cellLocation !== 'body') {
                        const define = scene.table.getHeaderDefine(col, row);
                        customRender = define?.headerCustomRender;
                        customLayout = define?.headerCustomLayout;
                    }
                    else {
                        const define = scene.table.getBodyColumnDefine(col, row);
                        customRender = define?.customRender || scene.table.customRender;
                        customLayout = define?.customLayout;
                    }
                    if ((customRender || customLayout) && isMergeCellGroup(cell)) {
                        for (let mergeCol = cell.mergeStartCol; mergeCol <= cell.mergeEndCol; mergeCol++) {
                            for (let mergeRow = cell.mergeStartRow; mergeRow <= cell.mergeEndRow; mergeRow++) {
                                if (mergeRow !== row) {
                                    scene.updateCellContent(mergeCol, mergeRow);
                                }
                            }
                        }
                    }
                    if (customLayout || customRender) {
                        const style = scene.table._getCellStyle(col, row);
                        const padding = getQuadProps(getProp('padding', style, col, row, scene.table));
                        let width = cell.attribute.width;
                        let height = cell.attribute.height;
                        if (isMergeCellGroup(cell)) {
                            width = scene.table.getColsWidth(cell.mergeStartCol, cell.mergeEndCol);
                            height = scene.table.getRowsHeight(cell.mergeStartRow, cell.mergeEndRow);
                        }
                        const customResult = dealWithCustom(customLayout, customRender, col, row, width, height, false, scene.table.isAutoRowHeight(row), padding, isMergeCellGroup(cell)
                            ? {
                                start: { col: cell.mergeStartCol, row: cell.mergeStartRow },
                                end: { col: cell.mergeEndCol, row: cell.mergeEndRow }
                            }
                            : undefined, scene.table);
                        customElementsGroup = customResult.elementsGroup;
                        renderDefault = customResult.renderDefault;
                    }
                    if (cell.childrenCount > 0 && customElementsGroup) {
                        cell.insertBefore(customElementsGroup, cell.firstChild);
                    }
                    else if (customElementsGroup) {
                        cell.appendChild(customElementsGroup);
                    }
                }
            }
            updateMergeCellContentHeight(cell, distHeight, detaY, scene.table.isAutoRowHeight(row), renderDefault, scene.table);
        }
    }
    function updateMergeCellContentHeight(cellGroup, distHeight, detaY, autoRowHeight, renderDefault, table) {
        if (isMergeCellGroup(cellGroup)) {
            distHeight = 0;
            for (let row = cellGroup.mergeStartRow; row <= cellGroup.mergeEndRow; row++) {
                distHeight += table.getRowHeight(row);
            }
            const { colStart, colEnd, rowStart, rowEnd } = getCellMergeRange(cellGroup, table.scenegraph);
            for (let col = colStart; col <= colEnd; col++) {
                for (let row = rowStart; row <= rowEnd; row++) {
                    const singleCellGroup = table.scenegraph.getCell(col, row);
                    if (singleCellGroup.role !== 'cell') {
                        continue;
                    }
                    singleCellGroup.forEachChildren((child) => {
                        child.setAttributes({
                            dx: 0,
                            dy: 0
                        });
                    });
                    if (renderDefault) {
                        const style = table._getCellStyle(colStart, rowStart);
                        const padding = getQuadProps(getProp('padding', style, col, row, table));
                        updateCellContentHeight(singleCellGroup, distHeight, detaY, autoRowHeight, padding, style.textAlign, style.textBaseline, table);
                    }
                    const rangeHeight = table.getRowHeight(row);
                    const rangeWidth = table.getColWidth(col);
                    singleCellGroup.contentHeight = distHeight;
                    const { widthChange } = resizeCellGroup(singleCellGroup, rangeWidth, rangeHeight, {
                        start: {
                            col: cellGroup.mergeStartCol,
                            row: cellGroup.mergeStartRow
                        },
                        end: {
                            col: cellGroup.mergeEndCol,
                            row: cellGroup.mergeEndRow
                        }
                    }, table);
                    if (widthChange) {
                        singleCellGroup.needUpdateWidth = true;
                    }
                }
            }
        }
        else {
            const style = table._getCellStyle(cellGroup.col, cellGroup.row);
            const padding = getQuadProps(getProp('padding', style, cellGroup.col, cellGroup.row, table));
            updateCellContentHeight(cellGroup, distHeight, detaY, autoRowHeight, padding, style.textAlign, style.textBaseline, table);
        }
    }

    function updateColWidth(scene, col, detaX, skipTableWidthMap) {
        if (!skipTableWidthMap) {
            scene.table._setColWidth(col, scene.table.getColWidth(col) + detaX, true);
        }
        const colOrCornerHeaderColumn = scene.getColGroup(col, true);
        const rightTopColumn = scene.getColGroupInRightTopCorner(col);
        if (colOrCornerHeaderColumn && !rightTopColumn) {
            updateColunmWidth(colOrCornerHeaderColumn, detaX, 'col-corner', scene);
        }
        if (rightTopColumn) {
            updateColunmWidth(rightTopColumn, detaX, 'right-top', scene);
        }
        const rowHeaderOrBodyColumn = scene.getColGroup(col);
        if (rowHeaderOrBodyColumn) {
            updateColunmWidth(rowHeaderOrBodyColumn, detaX, 'row-body', scene);
        }
        const leftBottomColumn = scene.getColGroupInLeftBottomCorner(col);
        if (leftBottomColumn) {
            updateColunmWidth(leftBottomColumn, detaX, 'left-bottom', scene);
        }
        const bottomColumn = scene.getColGroupInBottom(col);
        if (bottomColumn) {
            updateColunmWidth(bottomColumn, detaX, 'bottom', scene);
        }
        const rightBottomColumn = scene.getColGroupInRightBottomCorner(col);
        if (rightBottomColumn) {
            updateColunmWidth(rightBottomColumn, detaX, 'right-bottom', scene);
        }
        if (col < scene.frozenColCount) {
            scene.cornerHeaderGroup.forEachChildrenSkipChild((column, index) => {
                if (column.col > col) {
                    column.setAttribute('x', column.attribute.x + detaX);
                }
            });
            scene.rowHeaderGroup.forEachChildrenSkipChild((column, index) => {
                if (column.col > col) {
                    column.setAttribute('x', column.attribute.x + detaX);
                }
            });
        }
        else {
            scene.colHeaderGroup.forEachChildrenSkipChild((column, index) => {
                if (column.col > col) {
                    column.setAttribute('x', column.attribute.x + detaX);
                }
            });
            scene.bodyGroup.forEachChildrenSkipChild((column, index) => {
                if (column.col > col) {
                    column.setAttribute('x', column.attribute.x + detaX);
                }
            });
        }
        if (leftBottomColumn) {
            scene.leftBottomCornerGroup.forEachChildrenSkipChild((column, index) => {
                if (column.col > col) {
                    column.setAttribute('x', column.attribute.x + detaX);
                }
            });
        }
        if (bottomColumn) {
            scene.bottomFrozenGroup.forEachChildrenSkipChild((column, index) => {
                if (column.col > col) {
                    column.setAttribute('x', column.attribute.x + detaX);
                }
            });
        }
        if (rightBottomColumn) {
            scene.rightBottomCornerGroup.forEachChildrenSkipChild((column, index) => {
                if (column.col > col) {
                    column.setAttribute('x', column.attribute.x + detaX);
                }
            });
        }
    }
    function updateColunmWidth(columnGroup, detaX, mode, scene) {
        let needRerangeRow = false;
        const oldColumnWidth = columnGroup?.attribute.width ?? 0;
        columnGroup?.setAttribute('width', oldColumnWidth + detaX);
        columnGroup?.forEachChildren((cell, index) => {
            const isHeightChange = updateCellWidth(scene, cell, cell.col, cell.row, oldColumnWidth, oldColumnWidth + detaX, detaX, mode === 'row-body' ? cell.col < scene.table.rowHeaderLevelCount : true, scene.table.internalProps.autoWrapText);
            if (isHeightChange) {
                const mergeInfo = getCellMergeInfo(scene.table, cell.col, cell.row);
                if (mergeInfo && mergeInfo.end.row - mergeInfo.start.row) {
                    for (let row = mergeInfo.start.row; row <= mergeInfo.end.row; row++) {
                        resetRowHeight(scene, row);
                    }
                }
                else {
                    resetRowHeight(scene, cell.row);
                }
                needRerangeRow = true;
            }
        });
        if (needRerangeRow) {
            let newTotalHeight = 0;
            let colGroup;
            let oldContainerHeight;
            let row;
            for (let col = 0; col < scene.table.colCount; col++) {
                if (mode === 'col-corner') {
                    row = 0;
                    colGroup = scene.getColGroup(col, true);
                    oldContainerHeight = scene.colHeaderGroup.attribute.height ?? 0;
                }
                else if (mode === 'row-body') {
                    row = scene.table.frozenRowCount;
                    colGroup = scene.getColGroup(col, false);
                    oldContainerHeight = scene.bodyGroup.attribute.height ?? 0;
                }
                else if (mode === 'bottom') {
                    row = scene.table.rowCount - scene.table.bottomFrozenRowCount;
                    colGroup = scene.getColGroupInBottom(col);
                    oldContainerHeight = scene.bottomFrozenGroup.attribute.height ?? 0;
                }
                else if (mode === 'left-bottom') {
                    row = scene.table.rowCount - scene.table.bottomFrozenRowCount;
                    colGroup = scene.getColGroupInLeftBottomCorner(col);
                    oldContainerHeight = scene.leftBottomCornerGroup.attribute.height ?? 0;
                }
                else if (mode === 'right-top') {
                    row = 0;
                    colGroup = scene.getColGroupInRightTopCorner(col);
                    oldContainerHeight = scene.rightTopCornerGroup.attribute.height ?? 0;
                }
                else if (mode === 'right-bottom') {
                    row = scene.table.rowCount - scene.table.bottomFrozenRowCount;
                    colGroup = scene.getColGroupInRightBottomCorner(col);
                    oldContainerHeight = scene.rightBottomCornerGroup.attribute.height ?? 0;
                }
                if (!colGroup) {
                    continue;
                }
                let y = 0;
                colGroup.forEachChildren((cellGroup) => {
                    cellGroup.setAttribute('y', y);
                    y += scene.table.getRowHeight(cellGroup.row) ?? 0;
                });
                newTotalHeight = y;
            }
            scene.updateContainerHeight(row, newTotalHeight - oldContainerHeight);
            for (let col = 0; col < scene.table.frozenColCount; col++) {
                const leftBottomFrozenColumnGroup = scene.getColGroupInLeftBottomCorner(col);
                let y = 0;
                leftBottomFrozenColumnGroup?.forEachChildren((cellGroup) => {
                    cellGroup.setAttribute('y', y);
                    y += scene.table.getRowHeight(cellGroup.row);
                });
            }
            for (let col = scene.table.colCount - scene.table.rightFrozenColCount; col < scene.table.colCount; col++) {
                const rightBottomFrozenColumnGroup = scene.getColGroupInRightBottomCorner(col);
                let y = 0;
                rightBottomFrozenColumnGroup?.forEachChildren((cellGroup) => {
                    cellGroup.setAttribute('y', y);
                    y += scene.table.getRowHeight(cellGroup.row);
                });
            }
            for (let col = scene.table.frozenColCount; col < scene.table.colCount - scene.table.rightFrozenColCount; col++) {
                const rightBottomFrozenColumnGroup = scene.getColGroupInBottom(col);
                let y = 0;
                rightBottomFrozenColumnGroup?.forEachChildren((cellGroup) => {
                    cellGroup.setAttribute('y', y);
                    y += scene.table.getRowHeight(cellGroup.row);
                });
            }
        }
    }
    function updateCellWidth(scene, cell, col, row, oldWidth, distWidth, detaX, isHeader, autoWrapText) {
        if (cell.attribute.width === distWidth && !cell.needUpdateWidth) {
            return false;
        }
        cell.needUpdateWidth = false;
        cell.setAttribute('width', distWidth);
        const cellGroup = cell;
        if (!cellGroup) {
            return false;
        }
        const autoRowHeight = scene.table.isAutoRowHeight(row);
        const isVtableMerge = scene.table.getCellRawRecord(col, row)?.vtableMerge;
        const isCustomMerge = !!scene.table.getCustomMerge(col, row);
        const type = isVtableMerge || isCustomMerge
            ? 'text'
            : scene.table.isHeader(col, row)
                ? scene.table._getHeaderLayoutMap(col, row).headerType ?? 'text'
                : scene.table.getBodyColumnType(col, row) ?? 'text';
        let isHeightChange = false;
        if (type === 'progressbar') {
            const columnDefine = scene.table.getBodyColumnDefine(col, row);
            const style = scene.table._getCellStyle(col, row);
            const value = scene.table.getCellValue(col, row);
            const dataValue = scene.table.getCellOriginValue(col, row);
            const padding = getQuadProps(getProp('padding', style, col, row, scene.table));
            let range;
            if (columnDefine?.mergeCell) {
                range = scene.table.getCellRange(col, row);
            }
            const createProgressBarCell = Factory.getFunction('createProgressBarCell');
            const newBarCell = createProgressBarCell(columnDefine, style, cellGroup.attribute.width, value, dataValue, col, row, padding, scene.table, range);
            const oldBarCell = cellGroup.getChildByName('progress-bar');
            cellGroup.insertBefore(newBarCell, oldBarCell);
            cellGroup.removeChild(oldBarCell);
            oldBarCell.removeAllChild();
            oldBarCell.release();
            const cellChange = updateMergeCellContentWidth(cellGroup, distWidth, detaX, autoRowHeight, true, scene.table);
            isHeightChange = isHeightChange || cellChange;
        }
        else if (type === 'sparkline') {
            cellGroup.removeAllChild();
            const headerStyle = scene.table._getCellStyle(col, row);
            const padding = getQuadProps(getProp('padding', headerStyle, col, row, scene.table));
            const createSparkLineCellGroup = Factory.getFunction('createSparkLineCellGroup');
            createSparkLineCellGroup(cellGroup, cellGroup.parent, cellGroup.attribute.x, cellGroup.attribute.y, col, row, cellGroup.attribute.width, cellGroup.attribute.height, padding, scene.table, getStyleTheme(headerStyle, scene.table, col, row, getProp).theme, false);
        }
        else if (type === 'image' || type === 'video') {
            updateImageCellContentWhileResize(cellGroup, col, row, detaX, 0, scene.table);
        }
        else if (cellGroup.firstChild?.name === 'axis') {
            const axisConfig = scene.table.internalProps.layoutMap.getAxisConfigInPivotChart(col, row);
            const cellStyle = scene.table._getCellStyle(col, row);
            const padding = getQuadProps(getProp('padding', cellStyle, col, row, scene.table));
            if (axisConfig) {
                const CartesianAxis = Factory.getComponent('axis');
                const axis = new CartesianAxis(axisConfig, cellGroup.attribute.width, cellGroup.attribute.height, axisConfig.__vtablePadding ?? padding, scene.table);
                cellGroup.clear();
                cellGroup.appendChild(axis.component);
                axis.overlap();
            }
        }
        else if (cell.firstChild?.name === 'axis') {
            cell.firstChild?.originAxis.resize(cell.attribute.width, cell.attribute.height);
        }
        else {
            let renderDefault = true;
            const customContainer = cell.getChildByName(CUSTOM_CONTAINER_NAME) ||
                cell.getChildByName(CUSTOM_MERGE_CONTAINER_NAME);
            if (customContainer) {
                let customElementsGroup;
                cell.removeChild(customContainer);
                const customMergeRange = getCustomCellMergeCustom(col, row, cell, scene.table);
                if (customMergeRange) {
                    for (let mergeCol = customMergeRange.start.col; mergeCol <= customMergeRange.end.col; mergeCol++) {
                        if (mergeCol === col) {
                            continue;
                        }
                        const mergedCell = scene.getCell(mergeCol, row);
                        const customContainer = mergedCell.getChildByName(CUSTOM_CONTAINER_NAME) ||
                            mergedCell.getChildByName(CUSTOM_MERGE_CONTAINER_NAME);
                        customContainer.removeAllChild();
                        mergedCell.removeChild(customContainer);
                        getCustomCellMergeCustom(mergeCol, row, mergedCell, scene.table);
                    }
                }
                else {
                    let customRender;
                    let customLayout;
                    const cellType = scene.table.getCellLocation(col, row);
                    const { vtableMerge } = scene.table.getCellRawRecord(col, row) || {};
                    if (vtableMerge && scene.table.options.groupTitleCustomLayout) {
                        customLayout = scene.table.options.groupTitleCustomLayout;
                    }
                    else if (cellType !== 'body') {
                        const define = scene.table.getHeaderDefine(col, row);
                        customRender = define?.headerCustomRender;
                        customLayout = define?.headerCustomLayout;
                    }
                    else {
                        const define = scene.table.getBodyColumnDefine(col, row);
                        customRender = define?.customRender || scene.table.customRender;
                        customLayout = define?.customLayout;
                    }
                    if ((customRender || customLayout) && isMergeCellGroup(cellGroup)) {
                        for (let mergeCol = cellGroup.mergeStartCol; mergeCol <= cellGroup.mergeEndCol; mergeCol++) {
                            if (mergeCol !== col) {
                                for (let mergeRow = cellGroup.mergeStartRow; mergeRow <= cellGroup.mergeEndRow; mergeRow++) {
                                    scene.updateCellContent(mergeCol, mergeRow);
                                }
                            }
                        }
                    }
                    if (customLayout || customRender) {
                        const style = scene.table._getCellStyle(col, row);
                        const padding = getQuadProps(getProp('padding', style, col, row, scene.table));
                        let width = cellGroup.attribute.width;
                        let height = cellGroup.attribute.height;
                        if (isMergeCellGroup(cellGroup)) {
                            width = scene.table.getColsWidth(cellGroup.mergeStartCol, cellGroup.mergeEndCol);
                            height = scene.table.getRowsHeight(cellGroup.mergeStartRow, cellGroup.mergeEndRow);
                        }
                        const customResult = dealWithCustom(customLayout, customRender, col, row, width, height, false, scene.table.isAutoRowHeight(row), padding, isMergeCellGroup(cellGroup)
                            ? {
                                start: { col: cellGroup.mergeStartCol, row: cellGroup.mergeStartRow },
                                end: { col: cellGroup.mergeEndCol, row: cellGroup.mergeEndRow }
                            }
                            : undefined, scene.table);
                        customElementsGroup = customResult.elementsGroup;
                        renderDefault = customResult.renderDefault;
                        isHeightChange = true;
                    }
                    if (cell.childrenCount > 0 && customElementsGroup) {
                        cell.insertBefore(customElementsGroup, cell.firstChild);
                    }
                    else if (customElementsGroup) {
                        cell.appendChild(customElementsGroup);
                    }
                }
            }
            const cellChange = updateMergeCellContentWidth(cellGroup, distWidth, detaX, autoRowHeight, renderDefault, scene.table);
            isHeightChange = isHeightChange || cellChange;
        }
        if (!autoWrapText) {
            const style = scene.table._getCellStyle(col, row);
            autoWrapText = style.autoWrapText;
        }
        return autoRowHeight && autoWrapText ? isHeightChange : false;
    }
    function updateMergeCellContentWidth(cellGroup, distWidth, detaX, autoRowHeight, renderDefault, table) {
        if (isMergeCellGroup(cellGroup)) {
            distWidth = 0;
            let isHeightChange = false;
            for (let col = cellGroup.mergeStartCol; col <= cellGroup.mergeEndCol; col++) {
                distWidth += table.getColWidth(col);
            }
            let cellHeight = 0;
            for (let row = cellGroup.mergeStartRow; row <= cellGroup.mergeEndRow; row++) {
                cellHeight += table.getRowHeight(row);
            }
            const { colStart, colEnd, rowStart, rowEnd } = getCellMergeRange(cellGroup, table.scenegraph);
            for (let col = colStart; col <= colEnd; col++) {
                for (let row = rowStart; row <= rowEnd; row++) {
                    if (col === cellGroup.col && row !== cellGroup.row) {
                        continue;
                    }
                    const singleCellGroup = table.scenegraph.getCell(col, row);
                    if (singleCellGroup.role !== 'cell') {
                        continue;
                    }
                    singleCellGroup.forEachChildren((child) => {
                        child.setAttributes({
                            dx: 0,
                            dy: 0
                        });
                    });
                    let changed = false;
                    if (renderDefault) {
                        const style = table._getCellStyle(colStart, rowStart);
                        const padding = getQuadProps(getProp('padding', style, col, row, table));
                        const textAlign = style.textAlign;
                        const textBaseline = style.textBaseline;
                        changed = updateCellContentWidth(singleCellGroup, distWidth, cellHeight, detaX, autoRowHeight, padding, textAlign, textBaseline, table.scenegraph);
                        const hierarchyOffset = getHierarchyOffset(singleCellGroup.col, singleCellGroup.row, table);
                        if (hierarchyOffset) {
                            const text = singleCellGroup.getChildByName('text');
                            const icon = singleCellGroup.getChildByName('expand') || singleCellGroup.getChildByName('collapse');
                            if (icon?.role !== 'icon-left' && text) {
                                text.setAttribute('dx', hierarchyOffset);
                            }
                        }
                    }
                    const rangeHeight = table.getRowHeight(row);
                    const rangeWidth = table.getColWidth(col);
                    singleCellGroup.contentWidth = distWidth;
                    const { heightChange } = resizeCellGroup(singleCellGroup, rangeWidth, rangeHeight, {
                        start: {
                            col: cellGroup.mergeStartCol,
                            row: cellGroup.mergeStartRow
                        },
                        end: {
                            col: cellGroup.mergeEndCol,
                            row: cellGroup.mergeEndRow
                        }
                    }, table);
                    if (heightChange) {
                        singleCellGroup.needUpdateHeight = true;
                    }
                    isHeightChange = isHeightChange || changed;
                }
            }
            return isHeightChange;
        }
        const style = table._getCellStyle(cellGroup.col, cellGroup.row);
        const padding = getQuadProps(getProp('padding', style, cellGroup.col, cellGroup.row, table));
        const textAlign = style.textAlign;
        const textBaseline = style.textBaseline;
        return updateCellContentWidth(cellGroup, distWidth, table.getRowHeight(cellGroup.row), detaX, autoRowHeight, padding, textAlign, textBaseline, table.scenegraph);
    }
    function resetRowHeight(scene, row) {
        const maxHeight = Math.round(computeRowHeight(row, 0, scene.table.colCount - 1, scene.table));
        scene.table._setRowHeight(row, maxHeight, true);
        for (let col = 0; col < scene.table.colCount; col++) {
            const distHeight = maxHeight;
            const cell = scene.highPerformanceGetCell(col, row);
            if (cell.role === 'empty') {
                continue;
            }
            updateCellHeightForRow(scene, cell, col, row, distHeight, distHeight - cell.attribute.height, scene.table.isHeader(col, row));
        }
    }

    var MenuType;
    (function (MenuType) {
        MenuType["dropDown"] = "dropDown";
        MenuType["contextmenu"] = "contextmenu";
        MenuType["custom"] = "custom";
    })(MenuType || (MenuType = {}));
    const menuStyle = {
        fontSize: 12,
        fontFamily: 'Arial,sans-serif',
        color: '#000',
        highlightColor: '#2E68CF',
        hoverBgColor: '#EEE',
        lineHeight: 12 + 9 + 9,
        bgColor: '#FFF',
        cornerRadius: 4,
        borderWidth: 0.5,
        borderColor: '#CCC',
        menuPadding: 6,
        menuItemPadding: 9,
        maxLineWidth: 200
    };
    let MenuHandler$1 = class MenuHandler {
        _table;
        _menuInstance;
        _menuInfo;
        constructor(table) {
            this._table = table;
            this._menuInstance = new Group$1({
                x: 0,
                y: 0,
                fill: menuStyle.bgColor,
                stroke: menuStyle.borderColor,
                cornerRadius: menuStyle.cornerRadius,
                lineWidth: menuStyle.borderWidth
            });
            this._menuInfo = {
                x: -1,
                y: -1,
                col: -1,
                row: -1,
                type: MenuType.dropDown,
                menuInfo: [],
                highlightIndex: -1
            };
        }
        bindTableComponent(componentGroup) {
            componentGroup.appendChild(this._menuInstance);
            this.bindEvent();
        }
        release() {
        }
        attach(x, y, col, row, type, menuInfo) {
            if (type === MenuType.dropDown && this.checkDropDownMenuChange(col, row)) {
                const tableMenuInfo = this.getMenuInfo(col, row, type);
                if (!tableMenuInfo) {
                    return;
                }
                const { menuInfo, highlightIndex } = tableMenuInfo;
                this.updateMenuInfo(col, row, type, menuInfo, highlightIndex);
                this.updateMenuInstance(menuInfo, highlightIndex);
            }
            else if (type === MenuType.contextmenu) {
                if (this.checkContextMenuChange(x, y)) {
                    const tableMenuInfo = this.getMenuInfo(col, row, type);
                    if (!tableMenuInfo) {
                        return;
                    }
                    const { menuInfo, highlightIndex } = tableMenuInfo;
                    this.updateMenuInfo(col, row, type, menuInfo, highlightIndex);
                    this.updateMenuInstance(menuInfo, highlightIndex);
                }
            }
            this.updatePosition(x - this._table.scenegraph.x, y - this._table.scenegraph.y);
            this.addToScene();
        }
        updateMenuInfo(col, row, type, menuInfo, highlightIndex) {
            this._menuInfo.col = col;
            this._menuInfo.row = row;
            this._menuInfo.type = type;
            this._menuInfo.menuInfo = menuInfo;
            this._menuInfo.highlightIndex = highlightIndex;
        }
        checkDropDownMenuChange(col, row) {
            const { type, col: curCol, row: curRow } = this._menuInfo;
            if (type === MenuType.dropDown && col === curCol && row === curRow) {
                return false;
            }
            return true;
        }
        checkContextMenuChange(x, y) {
            const { type, menuInfo } = this._menuInfo;
            if (type === MenuType.contextmenu && menuInfo === this._table.internalProps.menu?.contextMenuItems) {
                return false;
            }
            return true;
        }
        updateMenuInstance(menuInfo, highlightIndex) {
            this._menuInstance.removeAllChild();
            let y = menuStyle.menuPadding;
            const x = menuStyle.menuPadding;
            let maxWidth = 0;
            menuInfo.forEach((item, index) => {
                const isisHighlight = highlightIndex === index;
                let icon;
                let text;
                if (typeof item === 'string') {
                    text = item;
                }
                else if (typeof item === 'object') {
                    text = item.text;
                    if (isisHighlight) {
                        icon = item.selectedIcon;
                    }
                    else {
                        icon = item.icon;
                    }
                }
                const group = new Group$1({
                    y,
                    x,
                    height: menuStyle.lineHeight,
                    fill: menuStyle.bgColor
                });
                group.role = 'menu-item';
                this._menuInstance.appendChild(group);
                group.stateProxy = (stateName) => {
                    if (stateName === 'hover') {
                        return {
                            fill: menuStyle.hoverBgColor
                        };
                    }
                    return {
                        fill: menuStyle.bgColor
                    };
                };
                group.addEventListener('pointerenter', (e) => {
                    group.addState('hover', true, false);
                    this._table.scenegraph.updateNextFrame();
                });
                group.addEventListener('pointerleave', (e) => {
                    group.removeState('hover', false);
                    this._table.scenegraph.updateNextFrame();
                });
                const textMark = new Text$1({
                    x: menuStyle.menuItemPadding,
                    y: menuStyle.menuItemPadding,
                    fill: isisHighlight ? menuStyle.highlightColor : menuStyle.color,
                    text,
                    textBaseline: 'top',
                    fontSize: menuStyle.fontSize,
                    fontFamily: menuStyle.fontFamily,
                    pickable: false,
                    maxLineWidth: menuStyle.maxLineWidth,
                    ellipsis: '…'
                });
                group.addChild(textMark);
                if (icon) {
                    textMark.AABBBounds.height();
                    const iconWidth = icon.width ?? 16;
                    const iconHeight = icon.height ?? 16;
                    const iconMark = new Icon$1({
                        x: menuStyle.menuItemPadding,
                        y: (menuStyle.lineHeight - iconHeight) / 2,
                        width: iconWidth,
                        height: iconHeight,
                        image: icon.svg,
                        pickable: false
                    });
                    iconMark.role = 'menu-icon';
                    group.insertBefore(iconMark, textMark);
                    textMark.setAttribute('x', iconWidth + menuStyle.menuItemPadding);
                }
                maxWidth = Math.max(group.AABBBounds.width(), maxWidth);
                y += menuStyle.lineHeight;
            });
            this._menuInstance.setAttributes({
                width: maxWidth + menuStyle.menuItemPadding * 2 + menuStyle.menuPadding * 2,
                height: y + menuStyle.menuPadding
            });
            this._menuInstance.forEachChildren((itemGroup) => {
                itemGroup.setAttribute('width', maxWidth + menuStyle.menuItemPadding * 2);
            });
        }
        updatePosition(x, y) {
            this._menuInstance.setAttributes({
                x: this._menuInfo.type === MenuType.dropDown ? x - this._menuInstance.attribute.width : x,
                y
            });
            this._menuInfo.x = MenuType.dropDown ? x - this._menuInstance.attribute.width : x;
            this._menuInfo.y = y;
        }
        addToScene() {
            this._table.scenegraph.updateNextFrame();
        }
        detach() {
            this._menuInstance.setAttributes({
                x: -1000,
                y: -1000
            });
            this._table.scenegraph.updateNextFrame();
        }
        getMenuInfo(col, row, type) {
            if (type === MenuType.dropDown) {
                let dropDownMenu = this._table.globalDropDownMenu;
                dropDownMenu = this._table._getHeaderLayoutMap(col, row).dropDownMenu;
                if (typeof dropDownMenu === 'function') {
                    dropDownMenu = dropDownMenu({ row, col, table: this._table });
                }
                let highlightIndex = -1;
                if (Array.isArray(dropDownMenu)) {
                    for (let i = 0; i < dropDownMenu.length; i++) {
                        if (this._table._dropDownMenuIsHighlight(col, row, i)) {
                            highlightIndex = i;
                            break;
                        }
                    }
                }
                return {
                    menuInfo: dropDownMenu,
                    highlightIndex
                };
            }
            else if (type === MenuType.contextmenu) {
                const contextmenu = this._table.internalProps.menu?.contextMenuItems;
                let menuInfo;
                if (Array.isArray(contextmenu)) {
                    menuInfo = contextmenu;
                }
                else if (typeof contextmenu === 'function') {
                    const { field } = (this._table.isHeader(col, row)
                        ? this._table.getHeaderDefine(col, row)
                        : this._table.getBodyColumnDefine(col, row));
                    menuInfo = contextmenu(field, row, col);
                }
                return {
                    menuInfo,
                    highlightIndex: -1
                };
            }
            return undefined;
        }
        bindEvent() {
            this._menuInstance.addEventListener('click', (e) => {
                const { target } = e;
                if (target && target.role === 'menu-item') {
                    const resultMenuInfo = this.getEventInfo(target);
                    const resultTableInfo = this._table.getMenuInfo(this._menuInfo.col, this._menuInfo.row, this._menuInfo.type);
                    const result = Object.assign(resultMenuInfo, resultTableInfo);
                    result.event = e.nativeEvent;
                    this._table.fireListeners(TABLE_EVENT_TYPE.DROPDOWN_MENU_CLICK, result);
                }
            });
        }
        getEventInfo(target) {
            const parent = target.parent;
            let index = 0;
            parent.forEachChildren((child, i) => {
                if (child === target) {
                    index = i - 1;
                    return true;
                }
                return false;
            });
            const text = typeof this._menuInfo.menuInfo[index] === 'string'
                ? this._menuInfo.menuInfo[index]
                : this._menuInfo.menuInfo[index].text;
            const menuKey = typeof this._menuInfo.menuInfo[index] === 'string'
                ? text
                : this._menuInfo.menuInfo[index].menuKey || text;
            return {
                col: this._menuInfo.col,
                row: this._menuInfo.row,
                dropDownIndex: index,
                highlight: index === this._menuInfo.highlightIndex,
                text,
                menuKey
            };
        }
        get bounds() {
            return this._menuInstance.globalAABBBounds;
        }
    };

    const regedIcons$1 = get$2();
    class DrillIcon {
        icon;
        constructor() {
            const iconOption = regedIcons$1.drillDown;
            this.icon = new Icon$1({
                x: -1000,
                y: -1000,
                image: iconOption.svg,
                width: iconOption.width,
                height: iconOption.height,
                dx: -iconOption.width / 2,
                dy: -iconOption.height / 2,
                visible: false,
                funcType: iconOption.funcType,
                cursor: iconOption.cursor
            });
            this.icon.role = 'icon-drill';
        }
        appand(parent) {
            parent.appendChild(this.icon);
        }
        update(visible, x, y, drillDown, drillUp, scene) {
            if (!visible || (drillDown && drillUp)) {
                this.icon.setAttributes({
                    x: -1000,
                    y: -1000,
                    visible: false
                });
                scene.updateNextFrame();
                return;
            }
            const drillDownOption = regedIcons$1.drillDown;
            const drillUpOption = regedIcons$1.drillUp;
            this.icon.setAttributes({
                x,
                y,
                image: drillDown ? drillDownOption.svg : drillUpOption.svg,
                visible: true
            });
            this.icon.loadImage(this.icon.attribute.image);
            scene.updateNextFrame();
        }
    }

    class CellMover {
        columnMoverLabel;
        columnMoverLine;
        columnMoverBack;
        table;
        x;
        constructor(table) {
            const columnMoverLineWidth = table.theme.dragHeaderSplitLine.lineWidth;
            const columnMoverLineColor = table.theme.dragHeaderSplitLine.lineColor;
            const columnMoverShadowBlockColor = table.theme.dragHeaderSplitLine.shadowBlockColor;
            this.columnMoverLabel = createSymbol({
                visible: false,
                pickable: false,
                x: 0,
                y: 0,
                symbolType: 'triangle',
                fill: columnMoverLineColor
            });
            this.columnMoverLine = createLine({
                visible: false,
                pickable: false,
                stroke: columnMoverLineColor,
                lineWidth: columnMoverLineWidth,
                x: 0,
                y: 0,
                points: [
                    { x: 0, y: 0 },
                    { x: 0, y: 0 }
                ]
            });
            this.columnMoverBack = createRect({
                visible: false,
                pickable: false,
                fill: columnMoverShadowBlockColor,
                x: 0,
                y: 0,
                width: 0,
                height: 0
            });
            this.table = table;
        }
        appand(parent) {
            parent.appendChild(this.columnMoverLabel);
            parent.appendChild(this.columnMoverLine);
            parent.appendChild(this.columnMoverBack);
        }
        show(col, row, delta) {
            const cellLocation = this.table.getCellLocation(col, row);
            const mergeInfo = getCellMergeInfo(this.table, col, row);
            if (mergeInfo) {
                col = mergeInfo.start.col;
                row = mergeInfo.start.row;
            }
            let rectX = 0;
            let rectY = 0;
            let rectWidth = 0;
            let rectHeight = 0;
            let rectDx = 0;
            let rectDy = 0;
            let symbolX = 0;
            let symbolY = 0;
            let symbolRotate = Math.PI;
            const linePoints = [];
            if (cellLocation === 'columnHeader') {
                rectX = this.table.getColsWidth(0, col - 1) - this.table.stateManager.scroll.horizontalBarPos;
                rectY = this.table.getRowsHeight(0, this.table.frozenRowCount - 1);
                rectHeight = this.table.tableNoFrameHeight;
                if (mergeInfo) {
                    rectWidth = this.table.getColsWidth(mergeInfo.start.col, mergeInfo.end.col);
                }
                else {
                    rectWidth = this.table.getColWidth(col);
                }
                rectDx = rectX - delta;
                symbolX = rectX + rectWidth;
                symbolY = 2;
                linePoints.push({ x: 0, y: 0 });
                linePoints.push({ x: 0, y: this.table.tableNoFrameHeight });
            }
            else if (cellLocation === 'rowHeader' ||
                this.table.internalProps.layoutMap.isSeriesNumberInBody(col, row)) {
                rectY = this.table.getRowsHeight(0, row - 1) - this.table.stateManager.scroll.verticalBarPos;
                rectX = this.table.getColsWidth(0, this.table.frozenColCount - 1);
                rectWidth = this.table.tableNoFrameWidth;
                if (mergeInfo) {
                    rectHeight = this.table.getRowsHeight(mergeInfo.start.row, mergeInfo.end.row);
                }
                else {
                    rectHeight = this.table.getRowHeight(row);
                }
                rectDy = rectY - delta;
                symbolX = 2;
                symbolY = rectY + rectHeight;
                symbolRotate = Math.PI / 2;
                linePoints.push({ x: 0, y: 0 });
                linePoints.push({ x: this.table.tableNoFrameWidth, y: 0 });
            }
            this.columnMoverBack.setAttributes({
                visible: true,
                x: rectX - rectDx,
                y: rectY - rectDy,
                width: rectWidth,
                height: rectHeight,
                dx: rectDx,
                dy: rectDy
            });
            this.columnMoverLine.setAttributes({
                x: symbolX,
                y: symbolY,
                visible: true,
                points: linePoints
            });
            this.columnMoverLabel.setAttributes({
                visible: true,
                x: symbolX,
                y: symbolY,
                angle: symbolRotate
            });
            return {
                backX: rectX - rectDx,
                lineX: symbolX,
                backY: rectY - rectDy,
                lineY: symbolY
            };
        }
        hide() {
            this.columnMoverLabel.setAttribute('visible', false);
            this.columnMoverLine.setAttribute('visible', false);
            this.columnMoverBack.setAttribute('visible', false);
        }
        update(backX, lineX, backY, lineY) {
            if (typeof backX === 'number' && typeof lineX === 'number') {
                this.columnMoverLabel.setAttribute('x', lineX);
                this.columnMoverLine.setAttribute('x', lineX);
                this.columnMoverBack.setAttribute('x', backX);
            }
            else if (typeof backY === 'number' && typeof lineY === 'number') {
                this.columnMoverLabel.setAttribute('y', lineY);
                this.columnMoverLine.setAttribute('y', lineY);
                this.columnMoverBack.setAttribute('y', backY);
            }
        }
        updateStyle() {
            const columnMoverLineWidth = this.table.theme.dragHeaderSplitLine.lineWidth;
            const columnMoverLineColor = this.table.theme.dragHeaderSplitLine.lineColor;
            const columnMoverShadowBlockColor = this.table.theme.dragHeaderSplitLine.shadowBlockColor;
            this.columnMoverLabel.setAttributes({
                fill: columnMoverLineColor
            });
            this.columnMoverLine.setAttributes({
                stroke: columnMoverLineColor,
                lineWidth: columnMoverLineWidth
            });
            this.columnMoverBack.setAttributes({
                fill: columnMoverShadowBlockColor
            });
        }
    }

    function getColX(col, table, isRightFrozen) {
        if (isRightFrozen) {
            return Math.min(table.tableNoFrameWidth, table.getAllColsWidth()) - table.getColsWidth(col, table.colCount - 1);
        }
        let colX = table.getColsWidth(0, col);
        if (col >= table.frozenColCount) {
            colX -= table.scrollLeft;
        }
        return colX;
    }
    function getRowY(row, table, isBottomFrozen) {
        if (isBottomFrozen) {
            return Math.min(table.tableNoFrameWidth, table.getAllRowsHeight()) - table.getRowsHeight(row, table.rowCount - 1);
        }
        let rowY = table.getRowsHeight(0, row);
        if (row >= table.frozenRowCount) {
            rowY -= table.scrollTop;
        }
        return rowY;
    }

    class TableComponent {
        table;
        border;
        columnResizeLine;
        columnResizeBgLine;
        columnResizeLabel;
        rowResizeLine;
        rowResizeBgLine;
        rowResizeLabel;
        menu;
        vScrollBar;
        hScrollBar;
        frozenShadowLine;
        rightFrozenShadowLine;
        drillIcon;
        cellMover;
        labelVisible;
        constructor(table) {
            this.table = table;
            const theme = this.table.theme;
            this.createScrollBar();
            const columnResizeColor = theme.columnResize?.lineColor;
            const columnResizeWidth = theme.columnResize?.lineWidth;
            const columnResizeBgColor = theme.columnResize?.bgColor;
            const columnResizeBgWidth = theme.columnResize?.width;
            const labelVisible = theme.columnResize?.labelVisible ?? true;
            const labelColor = theme.columnResize?.labelColor;
            const labelFontSize = theme.columnResize?.labelFontSize;
            const labelFontFamily = theme.columnResize?.labelFontFamily;
            const labelBackgroundFill = theme.columnResize?.labelBackgroundFill;
            const labelBackgroundCornerRadius = theme.columnResize?.labelBackgroundCornerRadius;
            this.labelVisible = labelVisible;
            this.columnResizeLine = createLine({
                visible: false,
                pickable: false,
                stroke: columnResizeColor,
                lineWidth: columnResizeWidth,
                x: 0,
                y: 0,
                points: [
                    { x: 0, y: 0 },
                    { x: 0, y: 0 }
                ]
            });
            this.columnResizeBgLine = createLine({
                visible: false,
                pickable: false,
                stroke: columnResizeBgColor,
                lineWidth: columnResizeBgWidth,
                x: 0,
                y: 0,
                points: [
                    { x: 0, y: 0 },
                    { x: 0, y: 0 }
                ]
            });
            const columnResizeLabelText = createText({
                visible: false,
                pickable: false,
                x: 0,
                y: 0,
                fontSize: labelFontSize,
                fill: labelColor,
                fontFamily: labelFontFamily,
                text: '',
                textBaseline: 'top',
                dx: 12 + 4,
                dy: -labelFontSize / 2
            });
            const columnResizeLabelBack = createRect({
                visible: false,
                pickable: false,
                fill: labelBackgroundFill,
                x: 0,
                y: 0,
                width: 5 * labelFontSize * 0.8,
                height: labelFontSize + 8,
                cornerRadius: labelBackgroundCornerRadius,
                dx: 12,
                dy: -labelFontSize / 2 - 4
            });
            this.columnResizeLabel = createGroup({
                visible: false,
                pickable: false,
                x: 0,
                y: 0
            });
            this.columnResizeLabel.appendChild(columnResizeLabelBack);
            this.columnResizeLabel.appendChild(columnResizeLabelText);
            this.rowResizeLine = createLine({
                visible: false,
                pickable: false,
                stroke: columnResizeColor,
                lineWidth: columnResizeWidth,
                x: 0,
                y: 0,
                points: [
                    { x: 0, y: 0 },
                    { x: 0, y: 0 }
                ]
            });
            this.rowResizeBgLine = createLine({
                visible: false,
                pickable: false,
                stroke: columnResizeBgColor,
                lineWidth: columnResizeBgWidth,
                x: 0,
                y: 0,
                points: [
                    { x: 0, y: 0 },
                    { x: 0, y: 0 }
                ]
            });
            const rowResizeLabelText = createText({
                visible: false,
                pickable: false,
                x: 0,
                y: 0,
                fontSize: labelFontSize,
                fill: labelColor,
                fontFamily: labelFontFamily,
                text: '',
                textBaseline: 'top',
                dx: 12 + 4,
                dy: -labelFontSize / 2
            });
            const rowResizeLabelBack = createRect({
                visible: false,
                pickable: false,
                fill: labelBackgroundFill,
                x: 0,
                y: 0,
                width: 5 * labelFontSize * 0.8,
                height: labelFontSize + 8,
                cornerRadius: labelBackgroundCornerRadius,
                dx: 12,
                dy: -labelFontSize / 2 - 4
            });
            this.rowResizeLabel = createGroup({
                visible: false,
                pickable: false,
                x: 0,
                y: 0
            });
            this.rowResizeLabel.appendChild(rowResizeLabelBack);
            this.rowResizeLabel.appendChild(rowResizeLabelText);
            this.cellMover = new CellMover(this.table);
            const shadowWidth = theme.frozenColumnLine?.shadow?.width;
            const shadowStartColor = theme.frozenColumnLine?.shadow?.startColor;
            const shadowEndColor = theme.frozenColumnLine?.shadow?.endColor;
            const visible = theme.frozenColumnLine?.shadow?.visible;
            this.frozenShadowLine = createRect({
                visible: visible === 'always',
                pickable: false,
                x: 0,
                y: 0,
                width: shadowWidth,
                height: 0,
                fill: {
                    gradient: 'linear',
                    x0: 0,
                    y0: 0,
                    x1: 1,
                    y1: 0,
                    stops: [
                        { color: shadowStartColor, offset: 0 },
                        { color: shadowEndColor, offset: 1 }
                    ]
                }
            });
            this.rightFrozenShadowLine = createRect({
                visible: visible === 'always',
                pickable: false,
                x: 0,
                y: 0,
                width: shadowWidth,
                height: 0,
                fill: {
                    gradient: 'linear',
                    x0: 0,
                    y0: 0,
                    x1: 1,
                    y1: 0,
                    stops: [
                        { color: shadowEndColor, offset: 0 },
                        { color: shadowStartColor, offset: 1 }
                    ]
                }
            });
            this.menu = new MenuHandler$1(this.table);
            this.drillIcon = new DrillIcon();
        }
        addToGroup(componentGroup) {
            componentGroup.addChild(this.frozenShadowLine);
            componentGroup.addChild(this.rightFrozenShadowLine);
            componentGroup.addChild(this.columnResizeBgLine);
            componentGroup.addChild(this.columnResizeLine);
            componentGroup.addChild(this.columnResizeLabel);
            componentGroup.addChild(this.rowResizeBgLine);
            componentGroup.addChild(this.rowResizeLine);
            componentGroup.addChild(this.rowResizeLabel);
            const hoverOn = this.table.theme.scrollStyle.hoverOn;
            if (hoverOn && !this.table.theme.scrollStyle.barToSide) {
                componentGroup.addChild(this.hScrollBar);
                componentGroup.addChild(this.vScrollBar);
            }
            else {
                componentGroup.stage.defaultLayer.addChild(this.hScrollBar);
                componentGroup.stage.defaultLayer.addChild(this.vScrollBar);
            }
            this.menu.bindTableComponent(componentGroup);
            this.drillIcon.appand(componentGroup);
            this.cellMover.appand(componentGroup);
        }
        createScrollBar() {
            const theme = this.table.theme;
            const scrollRailColor = theme.scrollStyle?.scrollRailColor;
            const scrollSliderColor = theme.scrollStyle?.scrollSliderColor;
            const scrollSliderCornerRadius = theme.scrollStyle?.scrollSliderCornerRadius;
            const width = theme.scrollStyle?.width;
            const horizontalPadding = theme.scrollStyle?.horizontalPadding;
            const verticalPadding = theme.scrollStyle?.verticalPadding;
            let sliderStyle;
            if (isValid$3(scrollSliderCornerRadius)) {
                sliderStyle = {
                    cornerRadius: scrollSliderCornerRadius,
                    fill: scrollSliderColor
                };
            }
            else {
                sliderStyle = {
                    fill: scrollSliderColor
                };
            }
            this.hScrollBar = new ScrollBar({
                direction: 'horizontal',
                x: -this.table.tableNoFrameWidth * 2,
                y: -this.table.tableNoFrameHeight * 2,
                width: this.table.tableNoFrameWidth,
                height: width,
                padding: horizontalPadding,
                railStyle: {
                    fill: scrollRailColor
                },
                sliderStyle,
                range: [0, 0.1],
                visible: false
            });
            this.hScrollBar.render();
            this.hScrollBar.hideAll();
            this.vScrollBar = new ScrollBar({
                direction: 'vertical',
                x: -this.table.tableNoFrameWidth * 2,
                y: -this.table.tableNoFrameHeight * 2,
                width,
                height: this.table.tableNoFrameHeight - this.table.getFrozenRowsHeight(),
                padding: verticalPadding,
                railStyle: {
                    fill: scrollRailColor
                },
                sliderStyle,
                range: [0, 0.1],
                visible: false
            });
            this.vScrollBar.render();
            this.vScrollBar.hideAll();
        }
        updateScrollBar() {
            const oldHorizontalBarPos = this.table.stateManager.scroll.horizontalBarPos;
            const oldVerticalBarPos = this.table.stateManager.scroll.verticalBarPos;
            const theme = this.table.theme;
            const width = theme.scrollStyle?.width;
            const visible1 = theme.scrollStyle?.visible;
            const horizontalVisible = theme.scrollStyle?.horizontalVisible ?? visible1;
            const verticalVisible = theme.scrollStyle?.verticalVisible ?? visible1;
            const tableWidth = Math.ceil(this.table.scenegraph.tableGroup.attribute.width);
            const tableHeight = Math.ceil(this.table.scenegraph.tableGroup.attribute.height);
            const totalHeight = this.table.getAllRowsHeight();
            const totalWidth = this.table.getAllColsWidth();
            const frozenRowsHeight = this.table.getFrozenRowsHeight();
            const frozenColsWidth = this.table.getFrozenColsWidth();
            const bottomFrozenRowsHeight = this.table.getBottomFrozenRowsHeight();
            const rightFrozenColsWidth = this.table.getRightFrozenColsWidth();
            const sizeTolerance = this.table.options.customConfig?._disableColumnAndRowSizeRound ? 1 : 0;
            if (totalWidth > tableWidth + sizeTolerance) {
                const y = Math.min(tableHeight, totalHeight);
                const rangeEnd = Math.max(0.05, (tableWidth - frozenColsWidth) / (totalWidth - frozenColsWidth));
                const hoverOn = this.table.theme.scrollStyle.hoverOn;
                let attrY = 0;
                if (this.table.theme.scrollStyle.barToSide) {
                    attrY =
                        this.table.tableNoFrameHeight -
                            (hoverOn ? width : -this.table.scenegraph.tableGroup.attribute.y) +
                            this.table.tableY;
                }
                else {
                    attrY = y - (hoverOn ? width : -this.table.scenegraph.tableGroup.attribute.y);
                }
                this.hScrollBar.setAttributes({
                    x: frozenColsWidth + (!hoverOn ? this.table.scenegraph.tableGroup.attribute.x : 0),
                    y: attrY,
                    width: tableWidth - frozenColsWidth - rightFrozenColsWidth,
                    range: [0, rangeEnd],
                    visible: horizontalVisible === 'always'
                });
                const bounds = this.hScrollBar.AABBBounds && this.hScrollBar.globalAABBBounds;
                this.hScrollBar._viewPosition = {
                    x: bounds.x1,
                    y: bounds.y1
                };
                if (horizontalVisible === 'always') {
                    this.hScrollBar.showAll();
                }
            }
            else {
                this.hScrollBar.setAttributes({
                    x: -this.table.tableNoFrameWidth * 2,
                    y: -this.table.tableNoFrameHeight * 2,
                    width: 0,
                    visible: false
                });
            }
            if (totalHeight > tableHeight + sizeTolerance) {
                const x = Math.min(tableWidth, totalWidth);
                const rangeEnd = Math.max(0.05, (tableHeight - frozenRowsHeight) / (totalHeight - frozenRowsHeight));
                let attrX = 0;
                const hoverOn = this.table.theme.scrollStyle.hoverOn;
                if (this.table.theme.scrollStyle.barToSide) {
                    attrX =
                        this.table.tableNoFrameWidth -
                            (hoverOn ? width : -this.table.scenegraph.tableGroup.attribute.x) +
                            this.table.tableX;
                }
                else {
                    attrX = x - (hoverOn ? width : -this.table.scenegraph.tableGroup.attribute.x);
                }
                this.vScrollBar.setAttributes({
                    x: attrX,
                    y: frozenRowsHeight + (!hoverOn ? this.table.scenegraph.tableGroup.attribute.y : 0),
                    height: tableHeight - frozenRowsHeight - bottomFrozenRowsHeight,
                    range: [0, rangeEnd],
                    visible: verticalVisible === 'always'
                });
                const bounds = this.vScrollBar.AABBBounds && this.vScrollBar.globalAABBBounds;
                this.vScrollBar._viewPosition = {
                    x: bounds.x1,
                    y: bounds.y1
                };
                if (verticalVisible === 'always') {
                    this.vScrollBar.showAll();
                }
            }
            else {
                this.vScrollBar.setAttributes({
                    x: -this.table.tableNoFrameWidth * 2,
                    y: -this.table.tableNoFrameHeight * 2,
                    height: 0,
                    visible: false
                });
            }
            this.table.stateManager.setScrollLeft(oldHorizontalBarPos);
            this.table.stateManager.setScrollTop(oldVerticalBarPos);
        }
        hideResizeCol() {
            this.columnResizeLine.setAttribute('visible', false);
            this.columnResizeBgLine.setAttribute('visible', false);
            this.columnResizeLabel.setAttribute('visible', false);
            this.columnResizeLabel.hideAll();
        }
        showResizeCol(col, y, isRightFrozen) {
            const colX = getColX(col, this.table, isRightFrozen);
            this.columnResizeLine.setAttributes({
                visible: true,
                x: colX,
                points: [
                    { x: 0, y: 0 },
                    { x: 0, y: this.table.getRowsHeight(0, this.table.rowCount - 1) }
                ]
            });
            this.columnResizeBgLine.setAttributes({
                visible: true,
                x: colX,
                points: [
                    { x: 0, y: 0 },
                    { x: 0, y: this.table.getRowsHeight(0, this.table.rowCount - 1) }
                ]
            });
            if (this.labelVisible) {
                this.columnResizeLabel.showAll();
                this.columnResizeLabel.setAttributes({
                    visible: true,
                    x: colX,
                    y
                });
                this.columnResizeLabel.lastChild.setAttribute('text', `${this.table.getColWidth(col)}px`);
            }
        }
        updateResizeCol(col, y, isRightFrozen) {
            const colX = getColX(col, this.table, isRightFrozen);
            this.columnResizeLine.setAttributes({
                x: colX,
                points: [
                    { x: 0, y: 0 },
                    { x: 0, y: this.table.getRowsHeight(0, this.table.rowCount - 1) }
                ]
            });
            this.columnResizeBgLine.setAttributes({
                x: colX,
                points: [
                    { x: 0, y: 0 },
                    { x: 0, y: this.table.getRowsHeight(0, this.table.rowCount - 1) }
                ]
            });
            if (this.labelVisible) {
                this.columnResizeLabel.setAttributes({
                    x: colX,
                    y
                });
                this.columnResizeLabel.lastChild.setAttribute('text', `${Math.floor(this.table.getColWidth(col))}px`);
            }
        }
        hideResizeRow() {
            this.rowResizeLine.setAttribute('visible', false);
            this.rowResizeBgLine.setAttribute('visible', false);
            this.rowResizeLabel.setAttribute('visible', false);
            this.rowResizeLabel.hideAll();
        }
        showResizeRow(row, x, isRightFrozen) {
            const rowY = getRowY(row, this.table, isRightFrozen);
            this.rowResizeLine.setAttributes({
                visible: true,
                y: rowY,
                points: [
                    { y: 0, x: 0 },
                    { y: 0, x: this.table.getColsWidth(0, this.table.colCount - 1) }
                ]
            });
            this.rowResizeBgLine.setAttributes({
                visible: true,
                y: rowY,
                points: [
                    { y: 0, x: 0 },
                    { y: 0, x: this.table.getColsWidth(0, this.table.colCount - 1) }
                ]
            });
            if (this.labelVisible) {
                this.rowResizeLabel.showAll();
                this.rowResizeLabel.setAttributes({
                    visible: true,
                    y: rowY,
                    x
                });
                this.rowResizeLabel.lastChild.setAttribute('text', `${this.table.getRowHeight(row)}px`);
            }
        }
        updateResizeRow(row, x, isBottomFrozen) {
            const rowY = getRowY(row, this.table, isBottomFrozen);
            this.rowResizeLine.setAttributes({
                y: rowY,
                points: [
                    { y: 0, x: 0 },
                    { y: 0, x: this.table.getColsWidth(0, this.table.colCount - 1) }
                ]
            });
            this.rowResizeBgLine.setAttributes({
                y: rowY,
                points: [
                    { y: 0, x: 0 },
                    { y: 0, x: this.table.getColsWidth(0, this.table.colCount - 1) }
                ]
            });
            if (this.labelVisible) {
                this.rowResizeLabel.setAttributes({
                    y: rowY,
                    x
                });
                this.rowResizeLabel.lastChild.setAttribute('text', `${Math.floor(this.table.getRowHeight(row))}px`);
            }
        }
        hideMoveCol() {
            this.cellMover.hide();
        }
        showMoveCol(col, row, delta) {
            return this.cellMover.show(col, row, delta);
        }
        updateMoveCol(backX, lineX, backY, lineY) {
            this.cellMover.update(backX, lineX, backY, lineY);
        }
        setFrozenColumnShadow(col, isRightFrozen) {
            const colX = getColX(col, this.table, isRightFrozen);
            if (col < 0 || this.table.theme.frozenColumnLine?.shadow?.visible !== 'always') {
                this.frozenShadowLine.setAttributes({
                    visible: false,
                    x: colX,
                    height: this.table.getDrawRange().height
                });
            }
            else {
                this.frozenShadowLine.setAttributes({
                    visible: true,
                    x: colX,
                    height: this.table.getDrawRange().height
                });
            }
        }
        setRightFrozenColumnShadow(col) {
            const colX = getColX(col, this.table, true);
            if (col >= this.table.colCount || this.table.theme.frozenColumnLine?.shadow?.visible !== 'always') {
                this.rightFrozenShadowLine.setAttributes({
                    visible: false,
                    x: colX - this.rightFrozenShadowLine.attribute.width,
                    height: this.table.getDrawRange().height
                });
            }
            else {
                this.rightFrozenShadowLine.setAttributes({
                    visible: true,
                    x: colX - this.rightFrozenShadowLine.attribute.width,
                    height: this.table.getDrawRange().height
                });
            }
        }
        hideFrozenColumnShadow() {
            const visible1 = this.table.theme.frozenColumnLine?.shadow?.visible;
            const visible = this.table.theme.frozenColumnLine?.shadow?.visible ?? visible1;
            if (visible !== 'scrolling') {
                return;
            }
            this.frozenShadowLine.setAttribute('visible', false);
            this.rightFrozenShadowLine.setAttribute('visible', false);
            this.table.scenegraph.updateNextFrame();
        }
        showFrozenColumnShadow() {
            const visible1 = this.table.theme.frozenColumnLine?.shadow?.visible;
            const visible = this.table.theme.frozenColumnLine?.shadow?.visible ?? visible1;
            if (visible !== 'scrolling') {
                return;
            }
            this.frozenShadowLine.setAttribute('visible', true);
            this.rightFrozenShadowLine.setAttribute('visible', true);
            this.table.scenegraph.updateNextFrame();
        }
        hideVerticalScrollBar() {
            const visible1 = this.table.theme.scrollStyle.visible;
            const verticalVisible = this.table.theme.scrollStyle.verticalVisible ?? visible1;
            if (verticalVisible !== 'focus' && verticalVisible !== 'scrolling') {
                return;
            }
            this.vScrollBar.setAttribute('visible', false);
            this.vScrollBar.hideAll();
            this.table.scenegraph.updateNextFrame();
        }
        showVerticalScrollBar() {
            const visible1 = this.table.theme.scrollStyle.visible;
            const verticalVisible = this.table.theme.scrollStyle.verticalVisible ?? visible1;
            if (verticalVisible !== 'focus' && verticalVisible !== 'scrolling') {
                return;
            }
            this.vScrollBar.setAttribute('visible', true);
            this.vScrollBar.showAll();
            this.table.scenegraph.updateNextFrame();
        }
        hideHorizontalScrollBar() {
            const visible1 = this.table.theme.scrollStyle.visible;
            const horizontalVisible = this.table.theme.scrollStyle.horizontalVisible ?? visible1;
            if (horizontalVisible !== 'focus' && horizontalVisible !== 'scrolling') {
                return;
            }
            this.hScrollBar.setAttribute('visible', false);
            this.hScrollBar.hideAll();
            this.table.scenegraph.updateNextFrame();
        }
        showHorizontalScrollBar() {
            const visible1 = this.table.theme.scrollStyle.visible;
            const horizontalVisible = this.table.theme.scrollStyle.horizontalVisible ?? visible1;
            if (horizontalVisible !== 'focus' && horizontalVisible !== 'scrolling') {
                return;
            }
            this.hScrollBar.setAttribute('visible', true);
            this.hScrollBar.showAll();
            this.table.scenegraph.updateNextFrame();
        }
        updateVerticalScrollBarPos(topRatio) {
            const range = this.vScrollBar.attribute.range;
            const size = range[1] - range[0];
            const range0 = topRatio * (1 - size);
            this.vScrollBar.setAttribute('range', [range0, range0 + size]);
            const bounds = this.vScrollBar.AABBBounds && this.vScrollBar.globalAABBBounds;
            this.vScrollBar._viewPosition = {
                x: bounds.x1,
                y: bounds.y1
            };
        }
        updateHorizontalScrollBarPos(leftRatio) {
            const range = this.hScrollBar.attribute.range;
            const size = range[1] - range[0];
            const range0 = leftRatio * (1 - size);
            this.hScrollBar.setAttribute('range', [range0, range0 + size]);
            const bounds = this.hScrollBar.AABBBounds && this.hScrollBar.globalAABBBounds;
            this.hScrollBar._viewPosition = {
                x: bounds.x1,
                y: bounds.y1
            };
        }
        updateStyle() {
            const theme = this.table.theme;
            const scrollRailColor = theme.scrollStyle?.scrollRailColor;
            const scrollSliderColor = theme.scrollStyle?.scrollSliderColor;
            const scrollSliderCornerRadius = theme.scrollStyle?.scrollSliderCornerRadius;
            const width = theme.scrollStyle?.width;
            const horizontalPadding = theme.scrollStyle?.horizontalPadding;
            const verticalPadding = theme.scrollStyle?.verticalPadding;
            let sliderStyle;
            if (isValid$3(scrollSliderCornerRadius)) {
                sliderStyle = {
                    cornerRadius: scrollSliderCornerRadius,
                    fill: scrollSliderColor
                };
            }
            else {
                sliderStyle = {
                    fill: scrollSliderColor
                };
            }
            this.hScrollBar.setAttributes({
                height: width,
                padding: horizontalPadding,
                railStyle: {
                    fill: scrollRailColor
                },
                sliderStyle
            });
            this.vScrollBar.setAttributes({
                width,
                padding: verticalPadding,
                railStyle: {
                    fill: scrollRailColor
                },
                sliderStyle
            });
            const columnResizeColor = theme.columnResize?.lineColor;
            const columnResizeWidth = theme.columnResize?.lineWidth;
            const columnResizeBgColor = theme.columnResize?.bgColor;
            const columnResizeBgWidth = theme.columnResize?.width;
            this.columnResizeLine.setAttributes({
                stroke: columnResizeColor,
                lineWidth: columnResizeWidth
            });
            this.columnResizeBgLine = createLine({
                stroke: columnResizeBgColor,
                lineWidth: columnResizeBgWidth
            });
            const labelColor = theme.columnResize?.labelColor;
            const labelFontSize = theme.columnResize?.labelFontSize;
            const labelFontFamily = theme.columnResize?.labelFontFamily;
            const labelBackgroundFill = theme.columnResize?.labelBackgroundFill;
            const labelBackgroundCornerRadius = theme.columnResize?.labelBackgroundCornerRadius;
            const labelVisible = theme.columnResize?.labelVisible ?? true;
            this.labelVisible = labelVisible;
            this.columnResizeLabel.lastChild.setAttributes({
                fontSize: labelFontSize,
                fill: labelColor,
                fontFamily: labelFontFamily,
                dy: -labelFontSize / 2
            });
            this.columnResizeLabel.firstChild.setAttributes({
                fill: labelBackgroundFill,
                width: 5 * labelFontSize * 0.8,
                height: labelFontSize + 8,
                cornerRadius: labelBackgroundCornerRadius,
                dy: -labelFontSize / 2 - 4
            });
            this.rowResizeLabel.lastChild.setAttributes({
                fontSize: labelFontSize,
                fill: labelColor,
                fontFamily: labelFontFamily,
                dy: -labelFontSize / 2
            });
            this.rowResizeLabel.firstChild.setAttributes({
                fill: labelBackgroundFill,
                width: 5 * labelFontSize * 0.8,
                height: labelFontSize + 8,
                cornerRadius: labelBackgroundCornerRadius,
                dy: -labelFontSize / 2 - 4
            });
            const shadowWidth = theme.frozenColumnLine?.shadow?.width;
            const shadowStartColor = theme.frozenColumnLine?.shadow?.startColor;
            const shadowEndColor = theme.frozenColumnLine?.shadow?.endColor;
            this.frozenShadowLine.setAttributes({
                width: shadowWidth,
                fill: {
                    gradient: 'linear',
                    x0: 0,
                    y0: 0,
                    x1: 1,
                    y1: 0,
                    stops: [
                        { color: shadowStartColor, offset: 0 },
                        { color: shadowEndColor, offset: 1 }
                    ]
                }
            });
            this.rightFrozenShadowLine.setAttributes({
                width: shadowWidth,
                fill: {
                    gradient: 'linear',
                    x0: 0,
                    y0: 0,
                    x1: 1,
                    y1: 0,
                    stops: [
                        { color: shadowEndColor, offset: 0 },
                        { color: shadowStartColor, offset: 1 }
                    ]
                }
            });
            this.cellMover.updateStyle();
        }
    }

    function createFrameBorder(group, frameTheme, role, strokeArray, justForXYPosition) {
        if (!frameTheme) {
            return;
        }
        const isTableGroup = role === 'table';
        const { shadowBlur, shadowOffsetX, shadowOffsetY, shadowColor, cornerRadius, borderColor, borderLineWidth, borderLineDash } = frameTheme;
        let hasShadow = false;
        const groupAttributes = {};
        const rectAttributes = {
            pickable: false
        };
        if (shadowBlur && isTableGroup) {
            rectAttributes.shadowBlur = shadowBlur;
            rectAttributes.shadowOffsetX = shadowOffsetX;
            rectAttributes.shadowOffsetY = shadowOffsetY;
            rectAttributes.shadowColor = shadowColor;
            rectAttributes.stroke = true;
            rectAttributes.stroke = shadowColor;
            rectAttributes.lineWidth = 1;
            hasShadow = true;
        }
        if (borderLineWidth) {
            rectAttributes.stroke = true;
            rectAttributes.fill = false;
            rectAttributes.stroke = getStroke(borderColor ?? '#E1E4E8', strokeArray, borderLineWidth);
            rectAttributes.lineWidth = borderLineWidth;
            borderLineDash && (rectAttributes.lineDash = borderLineDash);
            rectAttributes.lineCap = 'butt';
        }
        if (Array.isArray(borderColor)) {
            rectAttributes.strokeArrayColor = getQuadProps(borderColor);
        }
        if (Array.isArray(borderLineWidth)) {
            rectAttributes.strokeArrayWidth = getQuadProps(borderLineWidth);
            rectAttributes.lineWidth = 1;
        }
        if (cornerRadius) {
            rectAttributes.cornerRadius = cornerRadius;
            groupAttributes.cornerRadius = cornerRadius;
        }
        const borderTop = rectAttributes.strokeArrayWidth
            ? rectAttributes.strokeArrayWidth[0]
            : rectAttributes.lineWidth ?? 0;
        const borderRight = rectAttributes.strokeArrayWidth
            ? rectAttributes.strokeArrayWidth[1]
            : rectAttributes.lineWidth ?? 0;
        const borderBottom = rectAttributes.strokeArrayWidth
            ? rectAttributes.strokeArrayWidth[2]
            : rectAttributes.lineWidth ?? 0;
        const borderLeft = rectAttributes.strokeArrayWidth
            ? rectAttributes.strokeArrayWidth[3]
            : rectAttributes.lineWidth ?? 0;
        group.setAttributes(groupAttributes);
        if (justForXYPosition) {
            return;
        }
        if (rectAttributes.stroke) {
            rectAttributes.x = borderLeft / 2;
            rectAttributes.y = borderTop / 2;
            rectAttributes.pickable = false;
            if (isTableGroup) {
                if (cornerRadius) {
                    if (Array.isArray(cornerRadius)) {
                        const cornerRadiusArr = getQuadProps(cornerRadius);
                        rectAttributes.cornerRadius = cornerRadiusArr;
                        groupAttributes.cornerRadius = cornerRadiusArr;
                        cornerRadiusArr[0] && (cornerRadiusArr[0] = cornerRadiusArr[0] + Math.min(borderLeft, borderTop) / 2);
                        cornerRadiusArr[1] && (cornerRadiusArr[1] = cornerRadiusArr[1] + Math.min(borderTop, borderRight) / 2);
                        cornerRadiusArr[2] && (cornerRadiusArr[2] = cornerRadiusArr[2] + Math.min(borderRight, borderBottom) / 2);
                        cornerRadiusArr[3] && (cornerRadiusArr[3] = cornerRadiusArr[3] + Math.min(borderBottom, borderLeft) / 2);
                    }
                    else if (isArray$7(borderLineWidth)) {
                        const cornerRadiusArr = [];
                        rectAttributes.cornerRadius = cornerRadiusArr;
                        groupAttributes.cornerRadius = cornerRadiusArr;
                        cornerRadiusArr[0] = cornerRadius + Math.min(borderLeft, borderTop) / 2;
                        cornerRadiusArr[1] = cornerRadius + Math.min(borderTop, borderRight) / 2;
                        cornerRadiusArr[2] = cornerRadius + Math.min(borderRight, borderBottom) / 2;
                        cornerRadiusArr[3] = cornerRadius + Math.min(borderBottom, borderLeft) / 2;
                    }
                    else {
                        rectAttributes.cornerRadius = cornerRadius + (rectAttributes.lineWidth ?? 0) / 2;
                        groupAttributes.cornerRadius = cornerRadius + (rectAttributes.lineWidth ?? 0) / 2;
                    }
                }
                if (frameTheme.innerBorder) {
                    rectAttributes.x = group.attribute.x + borderLeft / 2;
                    rectAttributes.y = group.attribute.y + borderTop / 2;
                    rectAttributes.width = group.attribute.width - borderLeft / 2 - borderRight / 2;
                    rectAttributes.height = group.attribute.height - borderTop / 2 - borderBottom / 2;
                }
                else {
                    rectAttributes.x = group.attribute.x - borderLeft / 2;
                    rectAttributes.y = group.attribute.y - borderTop / 2;
                    rectAttributes.width = group.attribute.width + borderLeft / 2 + borderRight / 2;
                    rectAttributes.height = group.attribute.height + borderTop / 2 + borderBottom / 2;
                }
                let shadowRect;
                let borderRect;
                if (hasShadow) {
                    rectAttributes.fill = 'white';
                    rectAttributes.notAdjustPos = true;
                    borderRect = createGroup(rectAttributes);
                    borderRect.name = 'table-border-rect';
                    shadowRect = createRect({
                        x: borderLeft / 2,
                        y: borderTop / 2,
                        width: group.attribute.width,
                        height: group.attribute.height,
                        fill: 'red',
                        cornerRadius: group.attribute.cornerRadius,
                        globalCompositeOperation: 'destination-out'
                    });
                    borderRect.addChild(shadowRect);
                    const hackRect = createRect({
                        x: borderLeft / 2,
                        y: borderTop / 2,
                        width: group.attribute.width,
                        height: group.attribute.height,
                        fill: 'transparent',
                        pickable: false,
                        globalCompositeOperation: 'source-over'
                    });
                    borderRect.addChild(hackRect);
                }
                else {
                    borderRect = createRect(rectAttributes);
                    borderRect.name = 'table-border-rect';
                }
                if (frameTheme.innerBorder && !hasShadow) {
                    group.parent.insertAfter(borderRect, group);
                }
                else {
                    group.parent.insertBefore(borderRect, group);
                }
                group.border = borderRect;
            }
            else {
                rectAttributes.width = group.attribute.width - borderLeft / 2 - borderRight / 2;
                rectAttributes.height = group.attribute.height - borderTop / 2 - borderBottom / 2;
                const borderRect = createRect(rectAttributes);
                borderRect.name = 'border-rect';
                group.addChild(borderRect);
                group.border = borderRect;
            }
        }
        else {
            const borderRect = createRect({
                fill: false,
                stroke: false,
                pickable: false,
                lineWidth: 0
            });
            borderRect.name = 'border-rect';
            group.addChild(borderRect);
            group.border = borderRect;
        }
    }
    function updateFrameBorder(group, frameTheme, strokeArray) {
        if (!frameTheme) {
            return;
        }
        const { borderColor } = frameTheme;
        group.border?.setAttribute('stroke', getStroke(borderColor, strokeArray));
    }
    function getStroke(borderColor, strokeArray, strokeLineWidth) {
        let stroke = true;
        if ((strokeArray || isArray$7(strokeLineWidth)) && !isArray$7(borderColor)) {
            stroke = (strokeArray ?? strokeLineWidth).map(stroke => {
                if (stroke) {
                    return borderColor;
                }
                return false;
            });
        }
        else if (strokeArray) {
            stroke = strokeArray;
        }
        else if (!strokeArray && !isArray$7(borderColor)) {
            stroke = borderColor;
        }
        else if (isArray$7(borderColor)) {
            stroke = true;
        }
        return stroke;
    }
    function updateFrameBorderSize(group) {
        if (!group.border) {
            return;
        }
        const borderTop = group.border.attribute.strokeArrayWidth
            ? group.border.attribute.strokeArrayWidth[0]
            : group.border.attribute.lineWidth ?? 0;
        const borderRight = group.border.attribute.strokeArrayWidth
            ? group.border.attribute.strokeArrayWidth[1]
            : group.border.attribute.lineWidth ?? 0;
        const borderBottom = group.border.attribute.strokeArrayWidth
            ? group.border.attribute.strokeArrayWidth[2]
            : group.border.attribute.lineWidth ?? 0;
        const borderLeft = group.border.attribute.strokeArrayWidth
            ? group.border.attribute.strokeArrayWidth[3]
            : group.border.attribute.lineWidth ?? 0;
        group.border.setAttributes({
            borderLeft,
            borderTop,
            borderRight,
            borderBottom,
            width: group.attribute.width - borderLeft / 2 - borderRight / 2,
            height: group.attribute.height - borderTop / 2 - borderBottom / 2
        });
        if (group.border.type === 'group') {
            group.border.firstChild.setAttributes({
                width: group.attribute.width,
                height: group.attribute.height
            });
        }
    }
    function updateCornerRadius(table) {
        if (!table.theme.frameStyle.cornerRadius) {
            return;
        }
        const cornerRadius = table.theme.frameStyle.cornerRadius;
        const { cornerHeaderGroup, colHeaderGroup, rowHeaderGroup, bodyGroup, rightTopCornerGroup, leftBottomCornerGroup, rightBottomCornerGroup, rightFrozenGroup, bottomFrozenGroup } = table.scenegraph;
        cornerHeaderGroup.setAttribute('cornerRadius', 0);
        colHeaderGroup.setAttribute('cornerRadius', 0);
        rowHeaderGroup.setAttribute('cornerRadius', 0);
        bodyGroup.setAttribute('cornerRadius', 0);
        rightTopCornerGroup.setAttribute('cornerRadius', 0);
        leftBottomCornerGroup.setAttribute('cornerRadius', 0);
        rightBottomCornerGroup.setAttribute('cornerRadius', 0);
        rightFrozenGroup.setAttribute('cornerRadius', 0);
        bottomFrozenGroup.setAttribute('cornerRadius', 0);
        const cornerRadiusArray = toBoxArray$1(cornerRadius);
        if (cornerHeaderGroup.attribute.width > 0 && cornerHeaderGroup.attribute.height > 0) {
            setCornerRadius(cornerHeaderGroup, [cornerRadiusArray[0], 0, 0, 0]);
        }
        else if (colHeaderGroup.attribute.height > 0) {
            setCornerRadius(colHeaderGroup, [cornerRadiusArray[0], 0, 0, 0]);
        }
        else if (rowHeaderGroup.attribute.width > 0) {
            setCornerRadius(rowHeaderGroup, [cornerRadiusArray[0], 0, 0, 0]);
        }
        else {
            setCornerRadius(bodyGroup, [cornerRadiusArray[0], 0, 0, 0]);
        }
        if (leftBottomCornerGroup.attribute.width > 0 && leftBottomCornerGroup.attribute.height > 0) {
            setCornerRadius(leftBottomCornerGroup, [0, 0, 0, cornerRadiusArray[3]]);
        }
        else if (bottomFrozenGroup.attribute.height > 0) {
            setCornerRadius(bottomFrozenGroup, [0, 0, 0, cornerRadiusArray[3]]);
        }
        else if (rowHeaderGroup.attribute.width > 0) {
            setCornerRadius(rowHeaderGroup, [0, 0, 0, cornerRadiusArray[3]]);
        }
        else {
            setCornerRadius(bodyGroup, [0, 0, 0, cornerRadiusArray[3]]);
        }
        if (rightTopCornerGroup.attribute.width > 0 && rightTopCornerGroup.attribute.height > 0) {
            setCornerRadius(rightTopCornerGroup, [0, cornerRadiusArray[1], 0, 0]);
        }
        else if (colHeaderGroup.attribute.height > 0) {
            setCornerRadius(colHeaderGroup, [0, cornerRadiusArray[1], 0, 0]);
        }
        else if (rightFrozenGroup.attribute.width > 0) {
            setCornerRadius(rightFrozenGroup, [0, cornerRadiusArray[1], 0, 0]);
        }
        else {
            setCornerRadius(bodyGroup, [0, cornerRadiusArray[1], 0, 0]);
        }
        if (rightBottomCornerGroup.attribute.width > 0 && rightBottomCornerGroup.attribute.height > 0) {
            setCornerRadius(rightBottomCornerGroup, [0, 0, cornerRadiusArray[2], 0]);
        }
        else if (rightFrozenGroup.attribute.width > 0) {
            setCornerRadius(rightFrozenGroup, [0, 0, cornerRadiusArray[2], 0]);
        }
        else if (bottomFrozenGroup.attribute.height > 0) {
            setCornerRadius(bottomFrozenGroup, [0, 0, cornerRadiusArray[2], 0]);
        }
        else {
            setCornerRadius(bodyGroup, [0, 0, cornerRadiusArray[2], 0]);
        }
    }
    function setCornerRadius(group, cornerRadius) {
        group.setAttribute('cornerRadius', cornerRadius);
        if (group.border) {
            group.border.setAttribute('cornerRadius', cornerRadius);
        }
    }

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    function __decorate(decorators, target, key, desc) {
      var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
        d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    const CHART_NUMBER_TYPE = genNumberType();
    class Chart extends Rect$2 {
        type = 'chart';
        chartInstance;
        activeChartInstance;
        active;
        cacheCanvas;
        isShareChartSpec;
        constructor(isShareChartSpec, params) {
            super(params);
            this.numberType = CHART_NUMBER_TYPE;
            this.isShareChartSpec = isShareChartSpec;
            if (!params.chartInstance) {
                const chartInstance = (this.chartInstance = new params.ClassType(params.spec, merge$1({}, this.attribute.tableChartOption, {
                    renderCanvas: params.canvas,
                    mode: this.attribute.mode === 'node' ? 'node' : 'desktop-browser',
                    modeParams: this.attribute.modeParams,
                    canvasControled: false,
                    viewBox: { x1: 0, x2: 0, y1: 0, y2: 0 },
                    dpr: params.dpr,
                    interactive: false,
                    animation: false,
                    autoFit: false
                })));
                chartInstance.renderSync();
                chartInstance.getStage().enableDirtyBounds();
                params.chartInstance = this.chartInstance = chartInstance;
            }
            else {
                this.chartInstance = params.chartInstance;
            }
        }
        activate(table) {
            this.active = true;
            const { col, row } = this.parent;
            const { x1, y1, x2, y2 } = this.getViewBox();
            const tableBound = getTableBounds(col, row, table);
            const clipBound = tableBound.intersect({
                x1: x1 - table.scrollLeft,
                x2: x2 - table.scrollLeft,
                y1: y1 - table.scrollTop,
                y2: y2 - table.scrollTop
            });
            this.activeChartInstance?.release();
            this.activeChartInstance = new this.attribute.ClassType(this.attribute.spec, merge$1({}, this.attribute.tableChartOption, {
                renderCanvas: this.attribute.canvas,
                mode: 'desktop-browser',
                canvasControled: false,
                viewBox: {
                    x1: 0,
                    x2: x2 - x1,
                    y1: 0,
                    y2: y2 - y1
                },
                dpr: table.internalProps.pixelRatio,
                animation: false,
                interactive: true,
                autoFit: false,
                beforeRender: (chartStage) => {
                    const stage = this.stage;
                    const ctx = chartStage.window.getContext();
                    const stageMatrix = stage.window.getViewBoxTransform();
                    const viewBox = stage.window.getViewBox();
                    ctx.inuse = true;
                    ctx.clearMatrix();
                    ctx.setTransform(stageMatrix.a, stageMatrix.b, stageMatrix.c, stageMatrix.d, stageMatrix.e, stageMatrix.f, true);
                    ctx.translate(viewBox.x1, viewBox.y1);
                    ctx.setTransformForCurrent(true);
                    ctx.beginPath();
                    ctx.rect(clipBound.x1, clipBound.y1, clipBound.x2 - clipBound.x1, clipBound.y2 - clipBound.y1);
                    ctx.clip();
                    ctx.clearMatrix();
                    if (table.options.canvas && !chartStage.needRender) {
                        chartStage.pauseRender();
                        table.scenegraph.stage.dirtyBounds.union(this.globalAABBBounds);
                        table.scenegraph.updateNextFrame();
                    }
                },
                afterRender(stage) {
                    const ctx = stage.window.getContext();
                    ctx.inuse = false;
                    stage.needRender = false;
                    chartStage.resumeRender();
                }
            }));
            const chartStage = this.activeChartInstance.getStage();
            const matrix = this.globalTransMatrix.clone();
            const stageMatrix = this.stage.window.getViewBoxTransform();
            matrix.multiply(stageMatrix.a, stageMatrix.b, stageMatrix.c, stageMatrix.d, stageMatrix.e, stageMatrix.f);
            chartStage.window.setViewBoxTransform &&
                chartStage.window.setViewBoxTransform(matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f);
            this.activeChartInstance.renderSync();
            table.internalProps.layoutMap?.updateDataStateToActiveChartInstance?.(this.activeChartInstance);
            this.activeChartInstance.on('click', (params) => {
                if (this.attribute.spec.select?.enable === false) {
                    table.scenegraph.updateChartState(null);
                }
                else if (Chart.temp) {
                    table.scenegraph.updateChartState(params?.datum);
                }
            });
            this.activeChartInstance.on('brushEnd', (params) => {
                table.scenegraph.updateChartState(params?.value?.inBrushData);
                Chart.temp = 0;
                setTimeout(() => {
                    Chart.temp = 1;
                }, 0);
            });
            table._bindChartEvent?.(this.activeChartInstance);
        }
        static temp = 1;
        deactivate() {
            this.active = false;
            this.activeChartInstance?.updateViewBox({
                x1: -1000,
                x2: -800,
                y1: -1000,
                y2: -800
            }, false, false);
            this.activeChartInstance?.release();
            this.activeChartInstance = null;
        }
        updateData(data) {
            this.attribute.data = data;
        }
        getViewBox() {
            const cellGroup = this.parent;
            const padding = this.attribute.cellPadding;
            const table = this.stage.table;
            const { x1, y1, x2, y2 } = cellGroup.globalAABBBounds;
            return {
                x1: Math.ceil(x1 + padding[3] + table.scrollLeft + (table.options.viewBox?.x1 ?? 0)),
                x2: Math.ceil(x1 + cellGroup.attribute.width - padding[1] + table.scrollLeft + (table.options.viewBox?.x1 ?? 0)),
                y1: Math.ceil(y1 + padding[0] + table.scrollTop + (table.options.viewBox?.y1 ?? 0)),
                y2: Math.ceil(y1 + cellGroup.attribute.height - padding[2] + table.scrollTop + (table.options.viewBox?.y1 ?? 0))
            };
        }
    }
    function getTableBounds(col, row, table) {
        const { layoutMap } = table.internalProps;
        const bodyBound = new Bounds();
        const tableBound = table.scenegraph.tableGroup.globalAABBBounds;
        bodyBound.x1 = tableBound.x1;
        bodyBound.x2 = tableBound.x2;
        bodyBound.y1 = tableBound.y1;
        bodyBound.y2 = tableBound.y2;
        if (layoutMap.isLeftBottomCorner(col, row) ||
            layoutMap.isRightTopCorner(col, row) ||
            layoutMap.isLeftTopCorner(col, row) ||
            layoutMap.isRightBottomCorner(col, row)) ;
        else if (layoutMap.isFrozenColumn(col, row)) {
            bodyBound.y1 = tableBound.y1 + table.getFrozenRowsHeight();
            bodyBound.y2 = tableBound.y2 - table.getBottomFrozenRowsHeight();
        }
        else if (layoutMap.isFrozenRow(col, row)) {
            bodyBound.x1 = tableBound.x1 + table.getFrozenColsWidth();
            bodyBound.x2 = tableBound.x2 - table.getRightFrozenColsWidth();
        }
        else if (layoutMap.isRightFrozenColumn(col, row)) {
            bodyBound.y1 = tableBound.y1 + table.getFrozenRowsHeight();
            bodyBound.y2 = tableBound.y2 - table.getBottomFrozenRowsHeight();
        }
        else if (layoutMap.isBottomFrozenRow(col, row)) {
            bodyBound.x1 = tableBound.x1 + table.getFrozenColsWidth();
            bodyBound.x2 = tableBound.x2 - table.getRightFrozenColsWidth();
        }
        else if (!layoutMap.isFrozenColumn(col, row) && !layoutMap.isRightFrozenColumn(col, row)) {
            bodyBound.x1 = tableBound.x1 + table.getFrozenColsWidth();
            bodyBound.x2 = tableBound.x2 - table.getRightFrozenColsWidth();
            bodyBound.y1 = tableBound.y1 + table.getFrozenRowsHeight();
            bodyBound.y2 = tableBound.y2 - table.getBottomFrozenRowsHeight();
        }
        bodyBound.x1 = bodyBound.x1 + (table.options.viewBox?.x1 ?? 0);
        bodyBound.x2 = bodyBound.x2 + (table.options.viewBox?.x1 ?? 0);
        bodyBound.y1 = bodyBound.y1 + (table.options.viewBox?.y1 ?? 0);
        bodyBound.y2 = bodyBound.y2 + (table.options.viewBox?.y1 ?? 0);
        return bodyBound;
    }

    let chartRenderKeys = [];
    let chartRenderQueueList = [];
    let batchRenderChartCount = 5;
    let isHandlingChartQueue = false;
    let requestAnimationFrameId;
    function setBatchRenderChartCount(count) {
        if (isValid$3(count)) {
            batchRenderChartCount = count;
        }
    }
    function clearChartRenderQueue() {
        chartRenderKeys = [];
        chartRenderQueueList = [];
        isHandlingChartQueue = false;
        cancelAnimationFrame(requestAnimationFrameId);
    }
    function IsHandlingChartQueue() {
        return isHandlingChartQueue;
    }
    function renderChart(chart) {
        const { axes, dataId, data, spec, ClassType, canvas, mode, modeParams, dpr } = chart.attribute;
        let { chartInstance } = chart;
        if (!chartInstance) {
            chartInstance = new ClassType(spec, {
                renderCanvas: canvas,
                mode: mode === 'node' ? 'node' : 'desktop-browser',
                modeParams: modeParams,
                canvasControled: false,
                viewBox: { x1: 0, x2: 0, y1: 0, y2: 0 },
                dpr: dpr,
                interactive: false,
                animation: false,
                autoFit: false
            });
            chartInstance.renderSync();
            chart.chartInstance = chartInstance;
        }
        const viewBox = chart.getViewBox();
        if (viewBox.x2 <= viewBox.x1) {
            viewBox.x2 = viewBox.x1 + 1;
        }
        if (viewBox.y2 <= viewBox.y1) {
            viewBox.y2 = viewBox.y1 + 1;
        }
        chartInstance.updateViewBox({
            x1: 0,
            x2: viewBox.x2 - viewBox.x1,
            y1: 0,
            y2: viewBox.y2 - viewBox.y1
        }, false, false);
        const chartStage = chartInstance.getStage();
        const matrix = chart.globalTransMatrix.clone();
        const stageMatrix = chart.stage.window.getViewBoxTransform();
        matrix.multiply(stageMatrix.a, stageMatrix.b, stageMatrix.c, stageMatrix.d, stageMatrix.e, stageMatrix.f);
        chartStage.window.setViewBoxTransform &&
            chartStage.window.setViewBoxTransform(matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f);
        const { table } = chart.getRootNode();
        let updateSpec = false;
        if (table.options.specFormat) {
            const formatResult = table.options.specFormat(chart.attribute.spec, chartInstance, chart);
            if (formatResult.needFormatSpec && formatResult.spec) {
                const spec = formatResult.spec;
                chartInstance.updateSpecSync(spec);
                updateSpec = formatResult.updateSpec ?? true;
            }
        }
        if (!updateSpec) {
            axes?.forEach((axis, index) => {
                if (axis.type === 'band') {
                    chartInstance.updateModelSpec({ type: 'axes', index }, { domain: axis.domain.slice(0) }, true);
                }
                else {
                    chartInstance.updateModelSpecSync({ type: 'axes', index }, {
                        min: axis.range?.min ?? 0,
                        max: axis.range?.max ?? 0,
                        tick: {
                            tickMode: axis.tick?.tickMode
                        }
                    }, true);
                }
            });
            table.internalProps.layoutMap?.updateDataStateToActiveChartInstance?.(chartInstance);
            if (typeof dataId === 'string') {
                chartInstance.updateDataSync(dataId, data ?? []);
            }
            else {
                const dataBatch = [];
                for (const dataIdStr in dataId) {
                    const dataIdAndField = dataId[dataIdStr];
                    const series = spec.series.find((item) => item?.data?.id === dataIdStr);
                    dataBatch.push({
                        id: dataIdStr,
                        values: dataIdAndField
                            ? data?.filter((item) => {
                                return item.hasOwnProperty(dataIdAndField);
                            }) ?? []
                            : data ?? [],
                        fields: series?.data?.fields
                    });
                    if (!chartInstance.updateFullDataSync) {
                        chartInstance.updateDataSync(dataIdStr, dataIdAndField
                            ? data?.filter((item) => {
                                return item.hasOwnProperty(dataIdAndField);
                            }) ?? []
                            : data ?? []);
                    }
                }
                chartInstance.updateFullDataSync?.(dataBatch);
            }
        }
        table.fireListeners('before_cache_chart_image', { chartInstance });
        const sg = chartInstance.getStage();
        cacheStageCanvas(sg, chart);
    }
    function startRenderChartQueue(table) {
        isHandlingChartQueue = true;
        if (chartRenderQueueList.length > 0) {
            requestAnimationFrameId = requestAnimationFrame(() => {
                const chartsToRender = chartRenderQueueList.splice(0, batchRenderChartCount);
                chartRenderKeys.splice(0, batchRenderChartCount);
                chartsToRender.forEach(chart => {
                    renderChart(chart);
                    chart.addUpdateBoundTag();
                });
                table.render();
                startRenderChartQueue(table);
            });
        }
        else {
            isHandlingChartQueue = false;
        }
    }
    const cacheCanvasSizeLimit = 2000;
    function cacheStageCanvas(stage, chart) {
        const { viewWidth, viewHeight } = stage;
        if (viewWidth < cacheCanvasSizeLimit && viewHeight < cacheCanvasSizeLimit) {
            chart.cacheCanvas = toCanvas(stage);
            if (!chart.isShareChartSpec) {
                chart.chartInstance?.release();
                chart.chartInstance = null;
                chart.setAttribute('chartInstance', null);
            }
            return;
        }
        const rows = Math.ceil(viewHeight / cacheCanvasSizeLimit);
        const columns = Math.ceil(viewWidth / cacheCanvasSizeLimit);
        const cacheCanvas = [];
        for (let row = 0; row < rows; row++) {
            for (let col = 0; col < columns; col++) {
                const startX = col * cacheCanvasSizeLimit;
                const startY = row * cacheCanvasSizeLimit;
                const endX = startX + cacheCanvasSizeLimit > viewWidth ? viewWidth : startX + cacheCanvasSizeLimit;
                const endY = startY + cacheCanvasSizeLimit > viewHeight ? viewHeight : startY + cacheCanvasSizeLimit;
                const width = endX - startX;
                const height = endY - startY;
                const bounds = new Bounds();
                bounds.setValue(startX, startY, endX, endY);
                const canvas = toCanvas(stage, false, bounds);
                cacheCanvas.push({
                    canvas,
                    x: startX,
                    y: startY,
                    width,
                    height
                });
            }
        }
        chart.cacheCanvas = cacheCanvas;
    }
    function toCanvas(stage, fullImage = true, viewBox) {
        if (stage.releaseStatus === 'released') {
            return null;
        }
        const matrix = stage.window.getViewBoxTransform();
        const window = renderToNewWindow(stage, fullImage, viewBox);
        window.setViewBoxTransform(matrix.a, matrix.b, matrix.c, matrix.d, 0, 0);
        stage.renderTo(window);
        const c = window.getNativeHandler();
        if (c.nativeCanvas) {
            return c.nativeCanvas;
        }
        return null;
    }
    function renderToNewWindow(stage, fullImage = true, viewBox) {
        const matrix = stage.window.getViewBoxTransform();
        const window = container.get(VWindow);
        const x1 = viewBox ? -viewBox.x1 : 0;
        const y1 = viewBox ? -viewBox.y1 : 0;
        const x2 = viewBox ? viewBox.x2 : stage.viewWidth;
        const y2 = viewBox ? viewBox.y2 : stage.viewHeight;
        const width = viewBox ? viewBox.width() : stage.viewWidth;
        const height = viewBox ? viewBox.height() : stage.viewHeight;
        if (fullImage) {
            window.create({
                viewBox: { x1, y1, x2, y2 },
                width: width * matrix.a,
                height: height * matrix.d,
                dpr: stage.window.dpr,
                canvasControled: true,
                offscreen: true,
                title: ''
            });
        }
        else {
            window.create({
                viewBox: { x1, y1, x2, y2 },
                width: width * matrix.a,
                height: height * matrix.d,
                dpr: stage.window.dpr,
                canvasControled: true,
                offscreen: true,
                title: ''
            });
        }
        stage.renderTo(window);
        return window;
    }

    const ChartRender = Symbol.for('ChartRender');
    let DefaultCanvasChartRender = class DefaultCanvasChartRender extends BaseRender {
        type;
        numberType = CHART_NUMBER_TYPE;
        drawShape(chart, context, x, y, drawContext, params, fillCb, strokeCb) {
            const groupAttribute = getTheme(chart, params?.theme).group;
            const { dataId, data, spec } = chart.attribute;
            chart.getViewBox();
            const { width = groupAttribute.width, height = groupAttribute.height } = chart.attribute;
            const { table } = chart.getRootNode();
            const { active, cacheCanvas, activeChartInstance } = chart;
            if (!active && cacheCanvas) {
                if (isArray$7(cacheCanvas)) {
                    cacheCanvas.forEach(singleCacheCanvas => {
                        const { x, y, width, height, canvas } = singleCacheCanvas;
                        context.drawImage(canvas, x, y, width, height);
                    });
                }
                else {
                    context.drawImage(cacheCanvas, x, y, width, height);
                }
            }
            else if (activeChartInstance) {
                if (table.options.specFormat) {
                    const formatResult = table.options.specFormat(chart.attribute.spec, activeChartInstance, chart);
                    if (formatResult.needFormatSpec && formatResult.spec) {
                        const spec = formatResult.spec;
                        activeChartInstance.updateSpecSync(spec);
                    }
                }
                const viewBox = chart.getViewBox();
                activeChartInstance.updateViewBox({
                    x1: 0,
                    x2: viewBox.x2 - viewBox.x1,
                    y1: 0,
                    y2: viewBox.y2 - viewBox.y1
                }, false, false);
                const chartStage = activeChartInstance.getStage();
                chartStage.needRender = true;
                const matrix = chart.globalTransMatrix.clone();
                const stageMatrix = chart.stage.window.getViewBoxTransform().clone();
                stageMatrix.multiply(matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f);
                chartStage.window.setViewBoxTransform(stageMatrix.a, stageMatrix.b, stageMatrix.c, stageMatrix.d, stageMatrix.e, stageMatrix.f);
                if (typeof dataId === 'string') {
                    activeChartInstance.updateDataSync(dataId, data ?? []);
                }
                else {
                    const dataBatch = [];
                    for (const dataIdStr in dataId) {
                        const dataIdAndField = dataId[dataIdStr];
                        const series = spec.series.find((item) => item?.data?.id === dataIdStr);
                        dataBatch.push({
                            id: dataIdStr,
                            values: dataIdAndField
                                ? data?.filter((item) => {
                                    return item.hasOwnProperty(dataIdAndField);
                                }) ?? []
                                : data ?? [],
                            fields: series?.data?.fields
                        });
                        if (!activeChartInstance.updateFullDataSync) {
                            activeChartInstance.updateDataSync(dataIdStr, dataIdAndField
                                ? data?.filter((item) => {
                                    return item.hasOwnProperty(dataIdAndField);
                                }) ?? []
                                : data ?? []);
                        }
                    }
                    activeChartInstance.updateFullDataSync?.(dataBatch);
                }
            }
            else {
                if (table.internalProps.renderChartAsync) {
                    if (chartRenderKeys.indexOf(`${chart.parent.col}+${chart.parent.row}`) === -1) {
                        chartRenderKeys.push(`${chart.parent.col}+${chart.parent.row}`);
                        chartRenderQueueList.push(chart);
                    }
                    if (!IsHandlingChartQueue()) {
                        startRenderChartQueue(table);
                    }
                }
                else {
                    renderChart(chart);
                }
            }
        }
        draw(chart, renderService, drawContext, params) {
            this._draw(chart, {}, false, drawContext, params);
        }
    };
    DefaultCanvasChartRender = __decorate([
        injectable()
    ], DefaultCanvasChartRender);

    let BeforeImageRenderContribution = class BeforeImageRenderContribution {
        time = BaseRenderContributionTime.beforeFillStroke;
        useStyle = true;
        order = 0;
        drawShape(image, context, x, y, doFill, doStroke, fVisible, sVisible, imageAttribute, drawContext, fillCb, strokeCb, doFillOrStroke) {
            const { shape } = image.attribute;
            if (shape === 'circle') {
                const { width = imageAttribute.width, height = imageAttribute.height } = image.attribute;
                context.beginPath();
                context.arc(x + width / 2, y + height / 2, Math.min(width, height) / 2, 0, 2 * Math.PI);
                context.closePath();
                context.save();
                context.clip();
            }
        }
    };
    BeforeImageRenderContribution = __decorate([
        injectable()
    ], BeforeImageRenderContribution);
    let AfterImageRenderContribution = class AfterImageRenderContribution {
        time = BaseRenderContributionTime.afterFillStroke;
        useStyle = true;
        order = 0;
        drawShape(image, context, x, y, doFill, doStroke, fVisible, sVisible, imageAttribute, drawContext, fillCb, strokeCb, doFillOrStroke) {
            const { shape } = image.attribute;
            if (shape === 'circle') {
                context.restore();
            }
        }
    };
    AfterImageRenderContribution = __decorate([
        injectable()
    ], AfterImageRenderContribution);
    let BeforeGifImageRenderContribution = class BeforeGifImageRenderContribution {
        time = BaseRenderContributionTime.beforeFillStroke;
        useStyle = true;
        order = 0;
        drawShape(image, context, x, y, doFill, doStroke, fVisible, sVisible, imageAttribute, drawContext, fillCb, strokeCb, doFillOrStroke) {
            const { isGif } = image.attribute;
            if (isGif && image.playing) {
                image.attribute.opacity = 0;
            }
        }
    };
    BeforeGifImageRenderContribution = __decorate([
        injectable()
    ], BeforeGifImageRenderContribution);
    let AfterGifImageRenderContribution = class AfterGifImageRenderContribution {
        time = BaseRenderContributionTime.afterFillStroke;
        useStyle = true;
        order = 0;
        drawShape(image, context, x, y, doFill, doStroke, fVisible, sVisible, imageAttribute, drawContext, fillCb, strokeCb, doFillOrStroke) {
            const { isGif } = image.attribute;
            if (isGif && image.playing) {
                image.attribute.opacity = 1;
                context.globalAlpha = image.attribute.opacity;
                image.renderFrame(context, x, y);
            }
        }
    };
    AfterGifImageRenderContribution = __decorate([
        injectable()
    ], AfterGifImageRenderContribution);

    function getCellHoverColor(cellGroup, table) {
        let colorKey;
        if (cellGroup.role === 'cell' &&
            isValid$3(cellGroup.mergeStartCol) &&
            isValid$3(cellGroup.mergeStartRow) &&
            isValid$3(cellGroup.mergeEndCol) &&
            isValid$3(cellGroup.mergeEndRow)) {
            const { colStart, colEnd, rowStart, rowEnd } = getCellMergeRange(cellGroup, table.scenegraph);
            for (let col = colStart; col <= colEnd; col++) {
                for (let row = rowStart; row <= rowEnd; row++) {
                    const key = isCellHover(table.stateManager, col, row, cellGroup);
                    if (key && (!colorKey || key === 'cellBgColor')) {
                        colorKey = key;
                    }
                }
            }
        }
        else if (cellGroup.role === 'cell') {
            colorKey = isCellHover(table.stateManager, cellGroup.col, cellGroup.row, cellGroup);
        }
        if (!colorKey) {
            return undefined;
        }
        let hoverStyle;
        const layout = table.internalProps.layoutMap;
        if (layout.isCornerHeader(cellGroup.col, cellGroup.row)) {
            hoverStyle = table.theme.cornerHeaderStyle?.hover || table.theme.headerStyle?.hover;
        }
        else if (layout.isColumnHeader(cellGroup.col, cellGroup.row)) {
            hoverStyle = table.theme.headerStyle?.hover;
        }
        else if (layout.isRowHeader(cellGroup.col, cellGroup.row)) {
            hoverStyle = table.theme.rowHeaderStyle?.hover;
        }
        else if (layout.isBottomFrozenRow(cellGroup.col, cellGroup.row)) {
            hoverStyle =
                table.theme.bottomFrozenStyle?.hover ||
                    (table.isListTable() ? table.theme.bodyStyle?.hover : table.theme.headerStyle?.hover);
        }
        else if (layout.isRightFrozenColumn(cellGroup.col, cellGroup.row)) {
            hoverStyle =
                table.theme.rightFrozenStyle?.hover ||
                    (table.isListTable() ? table.theme.bodyStyle?.hover : table.theme.rowHeaderStyle?.hover);
        }
        else if (!table.isHeader(cellGroup.col, cellGroup.row)) {
            hoverStyle = table.theme.bodyStyle?.hover;
        }
        const fillColor = getProp(colorKey, hoverStyle, cellGroup.col, cellGroup.row, table);
        return fillColor;
    }
    function isCellHover(state, col, row, cellGroup) {
        const { highlightScope, disableHeader, cellPos } = state.hover;
        const table = state.table;
        const isHeader = table.isHeader(col, row);
        if (isHeader && disableHeader) {
            return undefined;
        }
        let hoverMode;
        if (highlightScope === HighlightScope.single && cellPos.col === col && cellPos.row === row) {
            hoverMode = 'cellBgColor';
        }
        else if (highlightScope === HighlightScope.column && cellPos.col === col) {
            if (cellPos.col === col && cellPos.row === row) {
                hoverMode = 'cellBgColor';
            }
            else {
                hoverMode = 'inlineColumnBgColor';
            }
        }
        else if (highlightScope === HighlightScope.row && cellPos.row === row) {
            if (cellPos.col === col && cellPos.row === row) {
                hoverMode = 'cellBgColor';
            }
            else {
                hoverMode = 'inlineRowBgColor';
            }
        }
        else if (highlightScope === HighlightScope.cross) {
            if (cellPos.col === col && cellPos.row === row) {
                hoverMode = 'cellBgColor';
            }
            else if (cellPos.col === col) {
                hoverMode = 'inlineColumnBgColor';
            }
            else if (cellPos.row === row) {
                hoverMode = 'inlineRowBgColor';
            }
        }
        if (hoverMode) {
            let cellDisable;
            if (isHeader) {
                const define = table.getHeaderDefine(col, row);
                cellDisable = define?.disableHeaderHover;
                if (cellGroup.firstChild && cellGroup.firstChild.name === 'axis' && table.options.hover?.disableAxisHover) {
                    cellDisable = true;
                }
            }
            else {
                const define = table.getBodyColumnDefine(col, row);
                cellDisable = define?.disableHover;
            }
            if (cellDisable) {
                hoverMode = undefined;
            }
        }
        return hoverMode;
    }

    function getCellSelectColor(cellGroup, table) {
        let colorKey;
        if (cellGroup.role === 'cell' &&
            isValid$3(cellGroup.mergeStartCol) &&
            isValid$3(cellGroup.mergeStartRow) &&
            isValid$3(cellGroup.mergeEndCol) &&
            isValid$3(cellGroup.mergeEndRow)) {
            const { colStart, colEnd, rowStart, rowEnd } = getCellMergeRange(cellGroup, table.scenegraph);
            for (let col = colStart; col <= colEnd; col++) {
                for (let row = rowStart; row <= rowEnd; row++) {
                    const key = isCellSelected(table.stateManager, col, row);
                    if (key && (!colorKey || key === 'cellBgColor')) {
                        colorKey = key;
                    }
                }
            }
        }
        else if (cellGroup.role === 'cell') {
            colorKey = isCellSelected(table.stateManager, cellGroup.col, cellGroup.row);
        }
        if (!colorKey) {
            return undefined;
        }
        let selectStyle;
        const layout = table.internalProps.layoutMap;
        if (layout.isCornerHeader(cellGroup.col, cellGroup.row)) {
            selectStyle = table.theme.cornerHeaderStyle?.select || table.theme.headerStyle?.select;
        }
        else if (layout.isColumnHeader(cellGroup.col, cellGroup.row)) {
            selectStyle = table.theme.headerStyle?.select;
        }
        else if (layout.isRowHeader(cellGroup.col, cellGroup.row)) {
            selectStyle = table.theme.rowHeaderStyle?.select;
        }
        else if (layout.isBottomFrozenRow(cellGroup.col, cellGroup.row)) {
            selectStyle =
                table.theme.bottomFrozenStyle?.select ||
                    (table.isListTable() ? table.theme.bodyStyle?.select : table.theme.headerStyle?.select);
        }
        else if (layout.isRightFrozenColumn(cellGroup.col, cellGroup.row)) {
            selectStyle =
                table.theme.rightFrozenStyle?.select ||
                    (table.isListTable() ? table.theme.bodyStyle?.select : table.theme.rowHeaderStyle?.select);
        }
        else if (!table.isHeader(cellGroup.col, cellGroup.row)) {
            selectStyle = table.theme.bodyStyle?.select;
        }
        const fillColor = getProp(colorKey, selectStyle, cellGroup.col, cellGroup.row, table);
        return fillColor;
    }
    function isSelectMultipleRange(range) {
        return range.start.col !== range.end.col || range.start.row !== range.end.row;
    }
    function getSelectModeRange(state, col, row) {
        let selectMode;
        const { highlightScope, cellPos, ranges } = state.select;
        const range = ranges[0];
        const rangeColStart = Math.min(range.start.col, range.end.col);
        const rangeColEnd = Math.max(range.start.col, range.end.col);
        const rangeRowStart = Math.min(range.start.row, range.end.row);
        const rangeRowEnd = Math.max(range.start.row, range.end.row);
        if (highlightScope === HighlightScope.single && cellPos.col === col && cellPos.row === row) {
            selectMode = 'cellBgColor';
        }
        else if (highlightScope === HighlightScope.column && col >= rangeColStart && col <= rangeColEnd) {
            if (cellInRange(ranges[0], col, row)) {
                selectMode = 'cellBgColor';
            }
            else {
                selectMode = 'inlineColumnBgColor';
            }
        }
        else if (highlightScope === HighlightScope.row && row >= rangeRowStart && row <= rangeRowEnd) {
            if (cellInRange(ranges[0], col, row)) {
                selectMode = 'cellBgColor';
            }
            else {
                selectMode = 'inlineRowBgColor';
            }
        }
        else if (highlightScope === HighlightScope.cross) {
            if (cellInRange(ranges[0], col, row)) {
                selectMode = 'cellBgColor';
            }
            else if (col >= rangeColStart && col <= rangeColEnd) {
                selectMode = 'inlineColumnBgColor';
            }
            else if (row >= rangeRowStart && row <= rangeRowEnd) {
                selectMode = 'inlineRowBgColor';
            }
        }
        return selectMode;
    }
    function getSelectMode(state, col, row) {
        let selectMode;
        const { highlightScope, cellPos } = state.select;
        if (highlightScope === HighlightScope.single && cellPos.col === col && cellPos.row === row) {
            selectMode = 'cellBgColor';
        }
        else if (highlightScope === HighlightScope.column && cellPos.col === col) {
            if (cellPos.col === col && cellPos.row === row) {
                selectMode = 'cellBgColor';
            }
            else {
                selectMode = 'inlineColumnBgColor';
            }
        }
        else if (highlightScope === HighlightScope.row && cellPos.row === row) {
            if (cellPos.col === col && cellPos.row === row) {
                selectMode = 'cellBgColor';
            }
            else {
                selectMode = 'inlineRowBgColor';
            }
        }
        else if (highlightScope === HighlightScope.cross) {
            if (cellPos.col === col && cellPos.row === row) {
                selectMode = 'cellBgColor';
            }
            else if (cellPos.col === col) {
                selectMode = 'inlineColumnBgColor';
            }
            else if (cellPos.row === row) {
                selectMode = 'inlineRowBgColor';
            }
        }
        return selectMode;
    }
    function isCellSelected(state, col, row, cellGroup) {
        const { highlightInRange, disableHeader, ranges } = state.select;
        let selectMode;
        const isSelectRange = ranges.length === 1 && isSelectMultipleRange(ranges?.[0]) && highlightInRange;
        if (isSelectRange
            ? ranges?.length === 1 && ranges[0].start && ranges[0].end
            : ranges?.length === 1 && ranges[0].end.col === ranges[0].start.col && ranges[0].end.row === ranges[0].start.row) {
            const table = state.table;
            const isHeader = table.isHeader(col, row);
            if (isHeader && disableHeader) {
                return undefined;
            }
            selectMode = isSelectRange ? getSelectModeRange(state, col, row) : getSelectMode(state, col, row);
            if (selectMode) {
                const cellDisable = isCellDisableSelect(state.table, col, row);
                if (cellDisable) {
                    selectMode = undefined;
                }
            }
        }
        else if (state.table.theme.selectionStyle.selectionFillMode === 'replace') {
            for (let i = 0; i < ranges.length; i++) {
                const range = ranges[i];
                const rangeColStart = Math.min(range.start.col, range.end.col);
                const rangeColEnd = Math.max(range.start.col, range.end.col);
                const rangeRowStart = Math.min(range.start.row, range.end.row);
                const rangeRowEnd = Math.max(range.start.row, range.end.row);
                if (rangeColStart <= col && rangeRowStart <= row && rangeColEnd >= col && rangeRowEnd >= row) {
                    selectMode = 'cellBgColor';
                    break;
                }
            }
        }
        return selectMode;
    }
    function isCellDisableSelect(table, col, row) {
        const globalDisableSelect = table.options.select?.disableSelect;
        const cellDisable = typeof globalDisableSelect === 'function' ? globalDisableSelect(col, row, table) : globalDisableSelect;
        if (cellDisable) {
            return true;
        }
        if (table.isHeader(col, row)) {
            let cellDisable = table.options.select?.disableHeaderSelect;
            if (cellDisable) {
                return true;
            }
            const columnDefine = table.getHeaderDefine(col, row);
            cellDisable = columnDefine?.disableHeaderSelect;
            if (cellDisable) {
                return true;
            }
        }
        else {
            const columnDefine = table.getBodyColumnDefine(col, row);
            const disableSelect = columnDefine?.disableSelect;
            const cellDisable = typeof disableSelect === 'function' ? disableSelect(col, row, table) : disableSelect;
            if (cellDisable) {
                return true;
            }
        }
        return false;
    }

    let SplitGroupBeforeRenderContribution = class SplitGroupBeforeRenderContribution {
        time = BaseRenderContributionTime.beforeFillStroke;
        useStyle = true;
        order = 0;
        drawShape(group, context, x, y, doFill, doStroke, fVisible, sVisible, groupAttribute, drawContext, fillCb, strokeCb, doFillOrStroke) {
            const { stroke = groupAttribute.stroke, strokeArrayWidth = groupAttribute.strokeArrayWidth, strokeArrayColor = groupAttribute.strokeArrayColor } = group.attribute;
            if (stroke && (Array.isArray(strokeArrayWidth) || Array.isArray(strokeArrayColor))) {
                doFillOrStroke.doStroke = false;
            }
        }
    };
    SplitGroupBeforeRenderContribution = __decorate([
        injectable()
    ], SplitGroupBeforeRenderContribution);
    let SplitGroupAfterRenderContribution = class SplitGroupAfterRenderContribution {
        time = BaseRenderContributionTime.afterFillStroke;
        useStyle = true;
        order = 0;
        drawShape(group, context, x, y, doFill, doStroke, fVisible, sVisible, groupAttribute, drawContext, fillCb, strokeCb) {
            const { stroke = groupAttribute.stroke, strokeArrayColor = groupAttribute.strokeArrayColor, strokeArrayWidth = groupAttribute.strokeArrayWidth, lineWidth = groupAttribute.lineWidth, strokeColor = groupAttribute.stroke, cornerRadius = groupAttribute.cornerRadius } = group.attribute;
            let { width = groupAttribute.width, height = groupAttribute.height } = group.attribute;
            if (!stroke || (!Array.isArray(strokeArrayWidth) && lineWidth === 0)) {
                return;
            }
            let widthForStroke;
            let heightForStroke;
            if (Array.isArray(strokeArrayColor) || Array.isArray(strokeArrayWidth)) {
                if ((typeof lineWidth === 'number' && lineWidth & 1) ||
                    (Array.isArray(strokeArrayWidth) && strokeArrayWidth.some(width => width & 1))) {
                    const table = group.stage.table;
                    if (!table) {
                        return;
                    }
                    const bottomRight = table?.theme?.cellBorderClipDirection === 'bottom-right';
                    if (bottomRight) {
                        x = Math.floor(x) - 0.5;
                        y = Math.floor(y) - 0.5;
                        if (group.role === 'cell') {
                            const col = group.col;
                            const row = group.row;
                            if (col === 0) {
                                x += 1;
                            }
                            if (row === 0) {
                                y += 1;
                            }
                        }
                    }
                    else {
                        x = Math.floor(x) + 0.5;
                        y = Math.floor(y) + 0.5;
                    }
                    if (table.options.customConfig?._disableColumnAndRowSizeRound) {
                        width = Math.round(width);
                        height = Math.round(height);
                    }
                    const { width: widthFroDraw, height: heightFroDraw } = getCellSizeForDraw(group, Math.ceil(width), Math.ceil(height), bottomRight);
                    widthForStroke = widthFroDraw;
                    heightForStroke = heightFroDraw;
                }
                else {
                    widthForStroke = Math.ceil(width);
                    heightForStroke = Math.ceil(height);
                }
                if (!(cornerRadius === 0 || (isArray$7(cornerRadius) && cornerRadius.every(num => num === 0)))) {
                    context.beginPath();
                    createRectPath(context, x, y, widthForStroke, heightForStroke, cornerRadius, true, new Array(4).fill(0).map((_, i) => (x1, y1, x2, y2) => {
                        renderStrokeWithCornerRadius(i, x1, y1, x2, y2, group, context, x, y, groupAttribute, stroke, strokeArrayWidth || lineWidth, strokeArrayColor || strokeColor, widthForStroke, heightForStroke);
                    }));
                    context.stroke();
                }
                else {
                    renderStroke(group, context, x, y, groupAttribute, stroke, strokeArrayWidth || lineWidth, strokeArrayColor || strokeColor, widthForStroke, heightForStroke);
                }
            }
        }
    };
    SplitGroupAfterRenderContribution = __decorate([
        injectable()
    ], SplitGroupAfterRenderContribution);
    function getWidthInfo(widthArray) {
        if (!Array.isArray(widthArray)) {
            return {
                isSplitDraw: false,
                width: widthArray
            };
        }
        let temp;
        for (let i = 0; i < widthArray.length; i++) {
            const width = widthArray[i];
            if (width) {
                if (!temp) {
                    temp = width;
                }
                else if (width !== temp) {
                    return {
                        isSplitDraw: true
                    };
                }
            }
        }
        return {
            isSplitDraw: false,
            width: temp
        };
    }
    function renderStroke(group, context, x, y, groupAttribute, stroke, strokeArrayWidth, strokeArrayColor, width, height, isHighlight, part) {
        const widthInfo = getWidthInfo(strokeArrayWidth);
        const isWidthNumber = !Array.isArray(strokeArrayWidth);
        const isStrokeTrue = !Array.isArray(stroke);
        const isPart = Array.isArray(part);
        const isSplitDraw = Array.isArray(strokeArrayColor) || widthInfo.isSplitDraw;
        context.setStrokeStyle(group, group.attribute, x, y, groupAttribute);
        const { lineDash = groupAttribute.lineDash } = group.attribute;
        let isDash = false;
        if (lineDash.length && lineDash.some((dash) => Array.isArray(dash))) {
            isDash = true;
        }
        context.beginPath();
        context.moveTo(x, y);
        const strokeTop = (isStrokeTrue || stroke[0]) && (isWidthNumber || strokeArrayWidth[0]);
        const strokeRight = (isStrokeTrue || stroke[1]) && (isWidthNumber || strokeArrayWidth[1]);
        const strokeBottom = (isStrokeTrue || stroke[2]) && (isWidthNumber || strokeArrayWidth[2]);
        const strokeLeft = (isStrokeTrue || stroke[3]) && (isWidthNumber || strokeArrayWidth[3]);
        if (strokeTop) {
            const deltaLeft = (isWidthNumber ? widthInfo.width : strokeArrayWidth[0]) / 2;
            const deltaRight = (isWidthNumber ? widthInfo.width : strokeArrayWidth[0]) / 2;
            if (isPart && Array.isArray(part[0])) {
                context.moveTo(x - deltaLeft + (width + deltaLeft + deltaRight) * part[0][0], y);
                context.lineTo(x - deltaLeft + (width + deltaLeft + deltaRight) * (part[0][1] - part[0][0]), y);
                context.moveTo(x + width + deltaRight, y);
            }
            else {
                context.moveTo(x - deltaLeft, y);
                context.lineTo(x + width + deltaRight, y);
            }
            if (isSplitDraw || isDash) {
                if (strokeArrayColor && strokeArrayColor[0]) {
                    context.strokeStyle = strokeArrayColor[0];
                }
                else if (strokeArrayColor && !strokeArrayColor[0]) {
                    context.strokeStyle = 'transparent';
                }
                if (!isWidthNumber) {
                    context.lineWidth = strokeArrayWidth[0];
                }
                context.lineDashOffset = context.currentMatrix.e / context.currentMatrix.a;
                if (isDash) {
                    context.setLineDash(lineDash[0] ?? []);
                }
                context.stroke();
                context.beginPath();
                context.moveTo(x + width, y);
            }
        }
        else {
            context.moveTo(x + width, y);
        }
        if (strokeRight) {
            const deltaTop = (isWidthNumber ? widthInfo.width : strokeArrayWidth[1]) / 2;
            const deltaBottom = (isWidthNumber ? widthInfo.width : strokeArrayWidth[1]) / 2;
            if (isPart && Array.isArray(part[1])) {
                context.moveTo(x + width, y - deltaTop + height * part[1][0]);
                context.lineTo(x + width, y - deltaTop + (height + deltaTop + deltaBottom) * (part[1][1] - part[1][0]));
                context.moveTo(x + width, y + height + deltaBottom);
            }
            else {
                context.moveTo(x + width, y - deltaTop);
                context.lineTo(x + width, y + height + deltaBottom);
            }
            if (isSplitDraw || isDash) {
                if (strokeArrayColor && strokeArrayColor[1]) {
                    context.strokeStyle = strokeArrayColor[1];
                }
                else if (strokeArrayColor && !strokeArrayColor[1]) {
                    context.strokeStyle = 'transparent';
                }
                if (!isWidthNumber) {
                    context.lineWidth = strokeArrayWidth[1];
                }
                context.lineDashOffset = context.currentMatrix.f / context.currentMatrix.d;
                if (isDash) {
                    context.setLineDash(lineDash[1] ?? []);
                }
                context.stroke();
                context.beginPath();
                context.moveTo(x + width, y + height);
            }
        }
        else {
            context.moveTo(x + width, y + height);
        }
        if (strokeBottom) {
            const deltaLeft = (isWidthNumber ? widthInfo.width : strokeArrayWidth[2]) / 2;
            const deltaRight = (isWidthNumber ? widthInfo.width : strokeArrayWidth[2]) / 2;
            if (isPart && Array.isArray(part[2])) {
                context.moveTo(x - deltaLeft + (width + deltaLeft + deltaRight) * part[2][0], y + height);
                context.lineTo(x - deltaLeft + (width + deltaLeft + deltaRight) * (part[2][1] - part[2][0]), y + height);
                context.moveTo(x - deltaLeft, y + height);
            }
            else {
                context.moveTo(x - deltaLeft, y + height);
                context.lineTo(x + width + deltaRight, y + height);
            }
            if (isSplitDraw || isDash) {
                if (strokeArrayColor && strokeArrayColor[2]) {
                    context.strokeStyle = strokeArrayColor[2];
                }
                else if (strokeArrayColor && !strokeArrayColor[2]) {
                    context.strokeStyle = 'transparent';
                }
                if (!isWidthNumber) {
                    context.lineWidth = strokeArrayWidth[2];
                }
                context.lineDashOffset = context.currentMatrix.e / context.currentMatrix.a;
                if (isDash) {
                    context.setLineDash(lineDash[2] ?? []);
                }
                context.stroke();
                context.beginPath();
                context.moveTo(x, y + height);
            }
        }
        else {
            context.moveTo(x, y + height);
        }
        if (strokeLeft) {
            const deltaTop = (isWidthNumber ? widthInfo.width : strokeArrayWidth[3]) / 2;
            const deltaBottom = (isWidthNumber ? widthInfo.width : strokeArrayWidth[3]) / 2;
            if (isPart && Array.isArray(part[3])) {
                context.moveTo(x, y - deltaTop + (height + deltaTop + deltaBottom) * part[3][0]);
                context.lineTo(x, y - deltaTop + (height + deltaTop + deltaBottom) * (part[3][1] - part[3][0]));
                context.moveTo(x, y - deltaTop);
            }
            else {
                context.moveTo(x, y - deltaTop);
                context.lineTo(x, y + height + deltaBottom);
            }
            if (isSplitDraw || isDash) {
                if (strokeArrayColor && strokeArrayColor[3]) {
                    context.strokeStyle = strokeArrayColor[3];
                }
                else if (strokeArrayColor && !strokeArrayColor[3]) {
                    context.strokeStyle = 'transparent';
                }
                if (!isWidthNumber) {
                    context.lineWidth = strokeArrayWidth[3];
                }
                context.lineDashOffset = context.currentMatrix.f / context.currentMatrix.d;
                if (isDash) {
                    context.setLineDash(lineDash[3] ?? []);
                }
                context.stroke();
                context.beginPath();
                context.moveTo(x, y);
            }
        }
        else {
            context.moveTo(x, y);
        }
        if (!isSplitDraw && !isDash) {
            if (!isWidthNumber && widthInfo.width) {
                context.lineWidth = widthInfo.width;
            }
            context.stroke();
        }
        context.lineDashOffset = 0;
        context.setLineDash([]);
    }
    let DashGroupBeforeRenderContribution = class DashGroupBeforeRenderContribution {
        time = BaseRenderContributionTime.beforeFillStroke;
        useStyle = true;
        order = 0;
        drawShape(group, context, x, y, doFill, doStroke, fVisible, sVisible, groupAttribute, drawContext, fillCb, strokeCb, doFillOrStroke) {
            const { lineDash = groupAttribute.lineDash, stroke = groupAttribute.stroke, strokeArrayColor = groupAttribute.strokeArrayColor, strokeArrayWidth = groupAttribute.strokeArrayWidth } = group.attribute;
            if (stroke &&
                Array.isArray(lineDash) &&
                lineDash.length &&
                lineDash[0]?.length &&
                !Array.isArray(strokeArrayColor) &&
                !Array.isArray(strokeArrayWidth)) {
                doFillOrStroke.doStroke = false;
            }
        }
    };
    DashGroupBeforeRenderContribution = __decorate([
        injectable()
    ], DashGroupBeforeRenderContribution);
    let DashGroupAfterRenderContribution = class DashGroupAfterRenderContribution {
        time = BaseRenderContributionTime.afterFillStroke;
        useStyle = true;
        order = 0;
        drawShape(group, context, x, y, doFill, doStroke, fVisible, sVisible, groupAttribute, drawContext, fillCb, strokeCb) {
            const { lineDash = groupAttribute.lineDash, stroke = groupAttribute.stroke, strokeArrayColor = groupAttribute.strokeArrayColor, strokeArrayWidth = groupAttribute.strokeArrayWidth, lineWidth = groupAttribute.lineWidth } = group.attribute;
            if (!stroke ||
                !(Array.isArray(lineDash) && lineDash.length && lineDash[0]?.length) ||
                Array.isArray(strokeArrayColor) ||
                Array.isArray(strokeArrayWidth)) {
                return;
            }
            const table = group.stage.table;
            if (!table) {
                return;
            }
            const splitLineDash = isArray$7(lineDash[0]) ? getQuadLineDash(lineDash) : [lineDash, lineDash, lineDash, lineDash];
            let { width = groupAttribute.width, height = groupAttribute.height } = group.attribute;
            if (table.options.customConfig?._disableColumnAndRowSizeRound) {
                width = Math.round(width);
                height = Math.round(height);
            }
            else {
                width = Math.ceil(width);
                height = Math.ceil(height);
            }
            let widthForStroke;
            let heightForStroke;
            if (lineWidth & 1) {
                const bottomRight = table.theme.cellBorderClipDirection === 'bottom-right';
                const deltaWidth = 0;
                const deltaHeight = 0;
                if (bottomRight) {
                    x = Math.floor(x) - 0.5;
                    y = Math.floor(y) - 0.5;
                    if (group.role === 'cell') {
                        const col = group.col;
                        const row = group.row;
                        if (col === 0) {
                            x += 1;
                        }
                        if (row === 0) {
                            y += 1;
                        }
                    }
                }
                else {
                    x = Math.floor(x) + 0.5;
                    y = Math.floor(y) + 0.5;
                }
                const { width: widthFroDraw, height: heightFroDraw } = getCellSizeForDraw(group, Math.ceil(width + deltaWidth), Math.ceil(height + deltaHeight), bottomRight);
                widthForStroke = widthFroDraw;
                heightForStroke = heightFroDraw;
            }
            else {
                widthForStroke = Math.ceil(width);
                heightForStroke = Math.ceil(height);
            }
            context.setStrokeStyle(group, group.attribute, x, y, groupAttribute);
            context.beginPath();
            context.moveTo(x, y);
            context.lineTo(x + widthForStroke, y);
            context.lineDashOffset = context.currentMatrix.e / context.currentMatrix.a;
            context.setLineDash(splitLineDash[0] ?? []);
            context.stroke();
            context.beginPath();
            context.moveTo(x + widthForStroke, y);
            context.lineTo(x + widthForStroke, y + heightForStroke);
            context.lineDashOffset = context.currentMatrix.f / context.currentMatrix.d;
            context.setLineDash(splitLineDash[1] ?? []);
            context.stroke();
            context.beginPath();
            context.moveTo(x, y + heightForStroke);
            context.lineTo(x + widthForStroke, y + heightForStroke);
            context.lineDashOffset = context.currentMatrix.e / context.currentMatrix.a;
            context.setLineDash(splitLineDash[2] ?? []);
            context.stroke();
            context.beginPath();
            context.moveTo(x, y);
            context.lineTo(x, y + heightForStroke);
            context.lineDashOffset = context.currentMatrix.f / context.currentMatrix.d;
            context.setLineDash(splitLineDash[3] ?? []);
            context.stroke();
            context.lineDashOffset = 0;
            context.setLineDash([]);
        }
    };
    DashGroupAfterRenderContribution = __decorate([
        injectable()
    ], DashGroupAfterRenderContribution);
    let AdjustPosGroupBeforeRenderContribution = class AdjustPosGroupBeforeRenderContribution {
        time = BaseRenderContributionTime.beforeFillStroke;
        useStyle = true;
        order = 0;
        drawShape(group, context, x, y, doFill, doStroke, fVisible, sVisible, groupAttribute, drawContext, fillCb, strokeCb, doFillOrStroke) {
            const { lineWidth = groupAttribute.lineWidth, stroke = groupAttribute.stroke, lineDash = groupAttribute.lineDash, strokeArrayWidth = groupAttribute.strokeArrayWidth, strokeArrayColor = groupAttribute.strokeArrayColor, notAdjustPos } = group.attribute;
            if (notAdjustPos !== true &&
                stroke &&
                Array.isArray(lineDash) &&
                !lineDash.length &&
                !Array.isArray(strokeArrayColor) &&
                !Array.isArray(strokeArrayWidth) &&
                lineWidth & 1) {
                doFillOrStroke.doStroke = false;
            }
        }
    };
    AdjustPosGroupBeforeRenderContribution = __decorate([
        injectable()
    ], AdjustPosGroupBeforeRenderContribution);
    let AdjustPosGroupAfterRenderContribution = class AdjustPosGroupAfterRenderContribution {
        time = BaseRenderContributionTime.afterFillStroke;
        useStyle = true;
        order = 0;
        drawShape(group, context, x, y, doFill, doStroke, fVisible, sVisible, groupAttribute, drawContext, fillCb, strokeCb) {
            const { lineWidth = groupAttribute.lineWidth, stroke = groupAttribute.stroke, lineDash = groupAttribute.lineDash, strokeArrayWidth = groupAttribute.strokeArrayWidth, strokeArrayColor = groupAttribute.strokeArrayColor, notAdjustPos, cornerRadius = groupAttribute.cornerRadius } = group.attribute;
            let { width = groupAttribute.width, height = groupAttribute.height } = group.attribute;
            if (notAdjustPos !== true &&
                stroke &&
                Array.isArray(lineDash) &&
                !lineDash.length &&
                !Array.isArray(strokeArrayColor) &&
                !Array.isArray(strokeArrayWidth) &&
                lineWidth & 1) {
                const table = group.stage.table;
                if (!table) {
                    return;
                }
                if (table.options.customConfig?._disableColumnAndRowSizeRound) {
                    width = Math.round(width);
                    height = Math.round(height);
                }
                context.beginPath();
                const bottomRight = table?.theme?.cellBorderClipDirection === 'bottom-right';
                const deltaWidth = 0;
                const deltaHeight = 0;
                if (bottomRight) {
                    x = Math.floor(x) - 0.5;
                    y = Math.floor(y) - 0.5;
                    if (group.role === 'cell') {
                        const col = group.col;
                        const row = group.row;
                        if (col === 0) {
                            x += 1;
                        }
                        if (row === 0) {
                            y += 1;
                        }
                    }
                }
                else {
                    x = Math.floor(x) + 0.5;
                    y = Math.floor(y) + 0.5;
                }
                const { width: widthFroDraw, height: heightFroDraw } = getCellSizeForDraw(group, Math.ceil(width), Math.ceil(height), bottomRight);
                if (cornerRadius) {
                    createRectPath(context, x, y, widthFroDraw + deltaWidth, heightFroDraw + deltaHeight, cornerRadius);
                }
                else {
                    context.rect(x, y, widthFroDraw, heightFroDraw);
                }
                context.setStrokeStyle(group, group.attribute, x, y, groupAttribute);
                context.stroke();
            }
        }
    };
    AdjustPosGroupAfterRenderContribution = __decorate([
        injectable()
    ], AdjustPosGroupAfterRenderContribution);
    let AdjustColorGroupBeforeRenderContribution = class AdjustColorGroupBeforeRenderContribution {
        time = BaseRenderContributionTime.beforeFillStroke;
        useStyle = true;
        order = 0;
        drawShape(group, context, x, y, doFill, doStroke, fVisible, sVisible, groupAttribute, drawContext, fillCb, strokeCb, doFillOrStroke) {
            if (group.role === 'cell') {
                const table = group.stage.table;
                if (table) {
                    const selectColor = getCellSelectColor(group, table);
                    if (selectColor) {
                        group.attribute._vtableHightLightFill = selectColor;
                    }
                    else if (table.stateManager.interactionState !== InteractionState.scrolling) {
                        const hoverColor = getCellHoverColor(group, table);
                        if (hoverColor) {
                            group.attribute._vtableHightLightFill = hoverColor;
                        }
                    }
                }
            }
        }
    };
    AdjustColorGroupBeforeRenderContribution = __decorate([
        injectable()
    ], AdjustColorGroupBeforeRenderContribution);
    let AdjustColorGroupAfterRenderContribution = class AdjustColorGroupAfterRenderContribution {
        time = BaseRenderContributionTime.afterFillStroke;
        useStyle = true;
        order = 0;
        drawShape(group, context, x, y, doFill, doStroke, fVisible, sVisible, groupAttribute, drawContext, fillCb, strokeCb) {
            if (group.attribute._vtableHightLightFill) {
                if (fillCb) ;
                else if (fVisible) {
                    const oldColor = group.attribute.fill;
                    group.attribute.fill = group.attribute._vtableHightLightFill;
                    context.setCommonStyle(group, group.attribute, x, y, groupAttribute);
                    context.fill();
                    group.attribute.fill = oldColor;
                    group.attribute._vtableHightLightFill = undefined;
                }
            }
        }
    };
    AdjustColorGroupAfterRenderContribution = __decorate([
        injectable()
    ], AdjustColorGroupAfterRenderContribution);
    let ClipBodyGroupBeforeRenderContribution = class ClipBodyGroupBeforeRenderContribution {
        time = BaseRenderContributionTime.beforeFillStroke;
        useStyle = true;
        order = 0;
        drawShape(group, context, xOrigin, yOrigin, doFill, doStroke, fVisible, sVisible, groupAttribute, drawContext, fillCb, strokeCb, doFillOrStroke) {
            const table = group.stage.table;
            if (!table) {
                return;
            }
            if (group.role === 'body') {
                const x = -(group.attribute.x ?? 0) + table.getFrozenColsWidth();
                const y = -(group.attribute.y ?? 0) + table.getFrozenRowsHeight();
                const width = group.parent.attribute.width - table.getFrozenColsWidth() - table.getRightFrozenColsWidth();
                const height = group.parent.attribute.height - table.getFrozenRowsHeight() - table.getBottomFrozenRowsHeight();
                drawClipRect(context, x, y, width, height);
            }
            else if (group.role === 'row-header') {
                const x = 0;
                const y = -(group.attribute.y ?? 0) + table.getFrozenRowsHeight();
                const width = table.getFrozenColsWidth();
                const height = group.parent.attribute.height - table.getFrozenRowsHeight() - table.getBottomFrozenRowsHeight();
                drawClipRect(context, x, y, width, height);
            }
            else if (group.role === 'col-header') {
                const x = -(group.attribute.x ?? 0) + table.getFrozenColsWidth();
                const y = 0;
                const width = group.parent.attribute.width - table.getFrozenColsWidth() - table.getRightFrozenColsWidth();
                const height = table.getFrozenRowsHeight();
                drawClipRect(context, x, y, width, height);
            }
            else if (group.role === 'right-frozen') {
                const x = 0;
                const y = -(group.attribute.y ?? 0) + table.getFrozenRowsHeight();
                const width = table.getRightFrozenColsWidth();
                const height = group.parent.attribute.height - table.getFrozenRowsHeight() - table.getBottomFrozenRowsHeight();
                drawClipRect(context, x, y, width, height);
            }
            else if (group.role === 'bottom-frozen') {
                const x = -(group.attribute.x ?? 0) + table.getFrozenColsWidth();
                const y = 0;
                const width = group.parent.attribute.width - table.getFrozenColsWidth() - table.getRightFrozenColsWidth();
                const height = table.getBottomFrozenRowsHeight();
                drawClipRect(context, x, y, width, height);
            }
            else if (group.role === 'corner-header') {
                const x = 0;
                const y = 0;
                const width = table.getFrozenColsWidth();
                const height = table.getFrozenRowsHeight();
                drawClipRect(context, x, y, width, height);
            }
            else if (group.role === 'corner-right-top-header') {
                const x = 0;
                const y = 0;
                const width = table.getRightFrozenColsWidth();
                const height = table.getFrozenRowsHeight();
                drawClipRect(context, x, y, width, height);
            }
            else if (group.role === 'corner-right-bottom-header') {
                const x = 0;
                const y = 0;
                const width = table.getRightFrozenColsWidth();
                const height = table.getBottomFrozenRowsHeight();
                drawClipRect(context, x, y, width, height);
            }
            else if (group.role === 'corner-left-bottom-header') {
                const x = 0;
                const y = 0;
                const width = table.getFrozenColsWidth();
                const height = table.getBottomFrozenRowsHeight();
                drawClipRect(context, x, y, width, height);
            }
        }
    };
    ClipBodyGroupBeforeRenderContribution = __decorate([
        injectable()
    ], ClipBodyGroupBeforeRenderContribution);
    const precision = Math.pow(2, 24);
    function drawClipRect(context, x, y, width, height) {
        context.beginPath();
        const matrix = context.applyedMatrix;
        if (Math.abs(matrix.f) > precision || Math.abs(matrix.g) > precision) {
            context.rect(x - precision, y - precision, width + precision * 2, height + precision * 2);
        }
        else {
            context.rect(x, y, width, height);
        }
    }
    function getCellSizeForDraw(group, width, height, bottomRight) {
        const table = group.stage.table;
        if (!table) {
            return { width, height };
        }
        if (group.role === 'cell') {
            let col = group.col;
            let row = group.row;
            const mergeInfo = getCellMergeInfo(table, col, row);
            if (mergeInfo) {
                col = mergeInfo.end.col;
                row = mergeInfo.end.row;
            }
            if (col === table.colCount - 1 && !bottomRight) {
                width -= 1;
            }
            else if (col === table.frozenColCount - 1 && table.scrollLeft && !bottomRight) {
                width -= 1;
            }
            else if (col === 0 && bottomRight) {
                width -= 1;
            }
            if (row === table.rowCount - 1 && !bottomRight) {
                height -= 1;
            }
            else if (row === table.frozenRowCount - 1 && table.scrollTop && !bottomRight) {
                height -= 1;
            }
            else if (row === 0 && bottomRight) {
                height -= 1;
            }
        }
        else if (group.role === 'corner-frozen') {
            if (table.scrollLeft && !bottomRight) {
                width -= 1;
            }
            if (table.scrollTop && !bottomRight) {
                height -= 1;
            }
        }
        return { width, height };
    }
    function getQuadLineDash(lineDash) {
        if (lineDash.length === 1) {
            return [lineDash[0], lineDash[0], lineDash[0], lineDash[0]];
        }
        else if (lineDash.length === 2) {
            return [lineDash[0], lineDash[1], lineDash[0], lineDash[1]];
        }
        return lineDash;
    }

    let SplitRectBeforeRenderContribution = class SplitRectBeforeRenderContribution {
        time = BaseRenderContributionTime.beforeFillStroke;
        useStyle = true;
        order = 0;
        drawShape(rect, context, x, y, doFill, doStroke, fVisible, sVisible, rectAttribute, drawContext, fillCb, strokeCb, doFillOrStroke) {
            const { stroke = rectAttribute.stroke, strokeArrayWidth = rectAttribute.strokeArrayWidth, strokeArrayColor = rectAttribute.strokeArrayColor } = rect.attribute;
            if (stroke && (Array.isArray(stroke) || Array.isArray(strokeArrayWidth) || Array.isArray(strokeArrayColor))) {
                doFillOrStroke.doStroke = false;
            }
        }
    };
    SplitRectBeforeRenderContribution = __decorate([
        injectable()
    ], SplitRectBeforeRenderContribution);
    let SplitRectAfterRenderContribution = class SplitRectAfterRenderContribution {
        time = BaseRenderContributionTime.afterFillStroke;
        useStyle = true;
        order = 0;
        drawShape(rect, context, x, y, doFill, doStroke, fVisible, sVisible, rectAttribute, drawContext, fillCb, strokeCb) {
            const { width = rectAttribute.width, height = rectAttribute.height, stroke = rectAttribute.stroke, strokeArrayColor = rectAttribute.strokeArrayColor, strokeArrayWidth = rectAttribute.strokeArrayWidth, lineWidth = rectAttribute.lineWidth, strokeColor = rectAttribute.stroke, cornerRadius = rectAttribute.cornerRadius } = rect.attribute;
            if (!stroke || (!Array.isArray(strokeArrayWidth) && lineWidth === 0)) {
                return;
            }
            if (Array.isArray(stroke) || Array.isArray(strokeArrayColor) || Array.isArray(strokeArrayWidth)) {
                const deltaWidth = 0;
                const deltaHeight = 0;
                if (rect.name !== 'border-rect' &&
                    rect.name !== 'table-border-rect' &&
                    ((typeof lineWidth === 'number' && lineWidth & 1) ||
                        (Array.isArray(strokeArrayWidth) && strokeArrayWidth.some(width => width & 1)))) {
                    x = Math.floor(x) + 0.5;
                    y = Math.floor(y) + 0.5;
                }
                if (!(cornerRadius === 0 || (isArray$7(cornerRadius) && cornerRadius.every(num => num === 0)))) {
                    context.beginPath();
                    createRectPath(context, x, y, width, height, cornerRadius, true, new Array(4).fill(0).map((_, i) => (x1, y1, x2, y2) => {
                        renderStrokeWithCornerRadius(i, x1, y1, x2, y2, rect, context, x, y, rectAttribute, stroke, strokeArrayWidth || lineWidth, strokeArrayColor || strokeColor, Math.ceil(width + deltaWidth), Math.ceil(height + deltaHeight));
                    }));
                    context.stroke();
                }
                else {
                    renderStroke(rect, context, x, y, rectAttribute, stroke, strokeArrayWidth || lineWidth, strokeArrayColor || strokeColor, rect.name !== 'table-border-rect' ? Math.ceil(width + deltaWidth) : width + deltaWidth, rect.name !== 'table-border-rect' ? Math.ceil(height + deltaHeight) : height + deltaHeight);
                }
            }
        }
    };
    SplitRectAfterRenderContribution = __decorate([
        injectable()
    ], SplitRectAfterRenderContribution);
    function renderStrokeWithCornerRadius(i, x1, y1, x2, y2, rect, context, x, y, rectAttribute, stroke, strokeArrayWidth, strokeArrayColor, width, height) {
        const group = rect;
        const groupAttribute = rectAttribute;
        const widthInfo = getWidthInfo(strokeArrayWidth);
        const isWidthNumber = !Array.isArray(strokeArrayWidth);
        const isStrokeTrue = !Array.isArray(stroke);
        const isSplitDraw = Array.isArray(strokeArrayColor) || widthInfo.isSplitDraw;
        context.stroke();
        context.setStrokeStyle(rect, rect.attribute, x, y, rectAttribute);
        const { lineDash = groupAttribute.lineDash } = group.attribute;
        let isDash = false;
        if (lineDash.length && lineDash.some((dash) => Array.isArray(dash))) {
            isDash = true;
        }
        context.beginPath();
        context.moveTo(x, y);
        const strokeTop = (isStrokeTrue || stroke[0]) && (isWidthNumber || strokeArrayWidth[0]);
        const strokeRight = (isStrokeTrue || stroke[1]) && (isWidthNumber || strokeArrayWidth[1]);
        const strokeBottom = (isStrokeTrue || stroke[2]) && (isWidthNumber || strokeArrayWidth[2]);
        const strokeLeft = (isStrokeTrue || stroke[3]) && (isWidthNumber || strokeArrayWidth[3]);
        if (strokeTop && i === 0) {
            (isWidthNumber ? widthInfo.width : strokeArrayWidth[0]) / 2;
            (isWidthNumber ? widthInfo.width : strokeArrayWidth[0]) / 2;
            context.moveTo(x1, y1);
            context.lineTo(x2, y2);
            if (isSplitDraw || isDash) {
                if (strokeArrayColor && strokeArrayColor[0]) {
                    context.strokeStyle = strokeArrayColor[0];
                }
                else if (strokeArrayColor && !strokeArrayColor[0]) {
                    context.strokeStyle = 'transparent';
                }
                if (!isWidthNumber) {
                    context.lineWidth = strokeArrayWidth[0];
                }
                context.lineDashOffset = context.currentMatrix.e / context.currentMatrix.a;
                if (isDash) {
                    context.setLineDash(lineDash[0] ?? []);
                }
                context.stroke();
                context.beginPath();
            }
        }
        else if (i === 0) {
            context.moveTo(x + width, y);
        }
        if (strokeRight && i === 1) {
            (isWidthNumber ? widthInfo.width : strokeArrayWidth[1]) / 2;
            (isWidthNumber ? widthInfo.width : strokeArrayWidth[1]) / 2;
            context.moveTo(x1, y1);
            context.lineTo(x2, y2);
            if (isSplitDraw || isDash) {
                if (strokeArrayColor && strokeArrayColor[1]) {
                    context.strokeStyle = strokeArrayColor[1];
                }
                else if (strokeArrayColor && !strokeArrayColor[1]) {
                    context.strokeStyle = 'transparent';
                }
                if (!isWidthNumber) {
                    context.lineWidth = strokeArrayWidth[1];
                }
                context.lineDashOffset = context.currentMatrix.f / context.currentMatrix.d;
                if (isDash) {
                    context.setLineDash(lineDash[1] ?? []);
                }
                context.stroke();
                context.beginPath();
                context.moveTo(x + width, y + height);
            }
        }
        else if (i === 1) {
            context.moveTo(x + width, y + height);
        }
        if (strokeBottom && i === 2) {
            (isWidthNumber ? widthInfo.width : strokeArrayWidth[2]) / 2;
            (isWidthNumber ? widthInfo.width : strokeArrayWidth[2]) / 2;
            context.moveTo(x1, y1);
            context.lineTo(x2, y2);
            if (isSplitDraw || isDash) {
                if (strokeArrayColor && strokeArrayColor[2]) {
                    context.strokeStyle = strokeArrayColor[2];
                }
                else if (strokeArrayColor && !strokeArrayColor[2]) {
                    context.strokeStyle = 'transparent';
                }
                if (!isWidthNumber) {
                    context.lineWidth = strokeArrayWidth[2];
                }
                context.lineDashOffset = context.currentMatrix.e / context.currentMatrix.a;
                if (isDash) {
                    context.setLineDash(lineDash[2] ?? []);
                }
                context.stroke();
                context.beginPath();
                context.moveTo(x, y + height);
            }
        }
        else if (i === 2) {
            context.moveTo(x, y + height);
        }
        if (strokeLeft && i === 3) {
            (isWidthNumber ? widthInfo.width : strokeArrayWidth[3]) / 2;
            (isWidthNumber ? widthInfo.width : strokeArrayWidth[3]) / 2;
            context.moveTo(x1, y1);
            context.lineTo(x2, y2);
            if (isSplitDraw || isDash) {
                if (strokeArrayColor && strokeArrayColor[3]) {
                    context.strokeStyle = strokeArrayColor[3];
                }
                else if (strokeArrayColor && !strokeArrayColor[3]) {
                    context.strokeStyle = 'transparent';
                }
                if (!isWidthNumber) {
                    context.lineWidth = strokeArrayWidth[3];
                }
                context.lineDashOffset = context.currentMatrix.f / context.currentMatrix.d;
                if (isDash) {
                    context.setLineDash(lineDash[3] ?? []);
                }
                context.stroke();
                context.beginPath();
                context.moveTo(x, y);
            }
        }
        else if (i === 3) {
            context.moveTo(x, y);
        }
        context.closePath();
        if (!isSplitDraw && !isDash) {
            if (!isWidthNumber && widthInfo.width) {
                context.lineWidth = widthInfo.width;
            }
            context.stroke();
        }
        context.lineDashOffset = 0;
        context.setLineDash([]);
        context.beginPath();
    }

    let loadingImage;
    let VTableDrawItemInterceptorContribution = class VTableDrawItemInterceptorContribution {
        order = 1;
        interceptors;
        constructor() {
            this.interceptors = [new ImageDrawItemInterceptorContribution()];
        }
        afterDrawItem(graphic, renderService, drawContext, drawContribution, params) {
            for (let i = 0; i < this.interceptors.length; i++) {
                if (this.interceptors[i].afterDrawItem &&
                    this.interceptors[i].afterDrawItem(graphic, renderService, drawContext, drawContribution, params)) {
                    return true;
                }
            }
            return false;
        }
        beforeDrawItem(graphic, renderService, drawContext, drawContribution, params) {
            if ((!graphic.in3dMode || drawContext.in3dInterceptor) &&
                !graphic.shadowRoot &&
                !(graphic.baseGraphic || graphic.attribute.globalZIndex || graphic.interactiveGraphic)) {
                return false;
            }
            for (let i = 0; i < this.interceptors.length; i++) {
                if (this.interceptors[i].beforeDrawItem &&
                    this.interceptors[i].beforeDrawItem(graphic, renderService, drawContext, drawContribution, params)) {
                    return true;
                }
            }
            return false;
        }
    };
    VTableDrawItemInterceptorContribution = __decorate([
        injectable()
    ], VTableDrawItemInterceptorContribution);
    class ImageDrawItemInterceptorContribution {
        order = 1;
        afterDrawItem(graphic, renderService, drawContext, drawContribution, params) {
            if (graphic.type === 'image') {
                this.drawItem(graphic, renderService, drawContext, drawContribution, params);
            }
            return false;
        }
        drawItem(graphic, renderService, drawContext, drawContribution, params) {
            const { image: url, gif } = graphic.attribute;
            if (gif && graphic.playing) {
                return false;
            }
            if (!url || !graphic.resources) {
                return false;
            }
            const res = graphic.resources.get(url);
            if (!res || res.state !== 'loading') {
                return false;
            }
            if (!loadingImage) {
                const regedIcons = get$2();
                const svg = regedIcons.loading_pic.svg;
                const width = regedIcons.loading_pic.width;
                const height = regedIcons.loading_pic.height;
                loadingImage = createImage({
                    width,
                    height,
                    image: svg
                });
            }
            const { image: loadingUrl } = loadingImage.attribute;
            if (!url || !loadingImage.resources) {
                return false;
            }
            const loadingRes = loadingImage.resources.get(loadingUrl);
            if (loadingRes.state !== 'success') {
                return false;
            }
            const { context } = drawContext;
            context.highPerformanceSave();
            graphic.parent && context.setTransformFromMatrix(graphic.parent.globalTransMatrix, true);
            graphic.glyphHost &&
                graphic.glyphHost.parent &&
                context.setTransformFromMatrix(graphic.glyphHost.parent.globalTransMatrix, true);
            const b = graphic.AABBBounds;
            const { width, height } = calcKeepAspectRatioSize(loadingRes.data.width, loadingRes.data.height, b.width(), b.height());
            context.drawImage(loadingRes.data, b.x1 + (b.width() - width) / 2, b.y1 + (b.height() - height) / 2, width, height);
            context.highPerformanceRestore();
            return true;
        }
    }

    let SuffixTextBeforeRenderContribution = class SuffixTextBeforeRenderContribution {
        time = BaseRenderContributionTime.afterFillStroke;
        useStyle = true;
        order = 0;
        drawShape(text, context, x, y, doFill, doStroke, fVisible, sVisible, textAttribute, drawContext, fillCb, strokeCb, doFillOrStroke) {
            const { text: str, underline = textAttribute.underline, lineThrough = textAttribute.lineThrough, direction = textAttribute.direction, whiteSpace = textAttribute.whiteSpace, fontSize = textAttribute.fontSize, verticalMode = textAttribute.verticalMode, ellipsis = textAttribute.ellipsis, textAlign = textAttribute.textAlign, textBaseline = textAttribute.textBaseline, x: originX = textAttribute.x, y: originY = textAttribute.y } = text.attribute;
            let isEmpty = false;
            if (Array.isArray(text)) {
                const layoutData = text.cache?.layoutData;
                if (ellipsis && layoutData && layoutData.lines.every(line => line.str === '')) {
                    isEmpty = true;
                }
            }
            else {
                const { cache } = text;
                if (ellipsis && cache && cache.clipedText === '' && cache.clipedWidth === 0) {
                    isEmpty = true;
                }
            }
            if (!isEmpty) {
                return;
            }
            const textStr = isString$4(ellipsis) ? ellipsis : '...';
            const lineHeight = calculateLineHeight(text.attribute.lineHeight, fontSize) ?? fontSize;
            let dy = 0;
            if (lineHeight !== fontSize) {
                if (textBaseline === 'top') {
                    dy = (lineHeight - fontSize) / 2;
                }
                else if (textBaseline === 'middle') ;
                else if (textBaseline === 'bottom') {
                    dy = -(lineHeight - fontSize) / 2;
                }
                else ;
            }
            if (doStroke) {
                if (strokeCb) {
                    strokeCb(context, text.attribute, textAttribute);
                }
                else if (sVisible) {
                    context.setStrokeStyle(text, text.attribute, originX - x, originY - y, textAttribute);
                    context.strokeText(textStr, originX, originY + dy);
                }
            }
            if (doFill) {
                if (fillCb) {
                    fillCb(context, text.attribute, textAttribute);
                }
                else if (fVisible) {
                    context.setCommonStyle(text, text.attribute, originX - x, originY - y, textAttribute);
                    context.fillText(textStr, originX, originY + dy);
                    this.drawUnderLine(underline, lineThrough, text, originX, originY + dy, 0, textAttribute, context, textStr);
                }
            }
        }
        drawUnderLine(underline, lineThrough, text, x, y, z, textAttribute, context, textStr) {
            if (lineThrough + underline <= 0) {
                return;
            }
            const { textAlign = textAttribute.textAlign, textBaseline = textAttribute.textBaseline, fontSize = textAttribute.fontSize, fontFamily = textAttribute.fontFamily, fontWeight = textAttribute.fontWeight, fontStyle = textAttribute.fontStyle, fill = textAttribute.fill, opacity = textAttribute.opacity, underlineOffset = textAttribute.underlineOffset, underlineDash = textAttribute.underlineDash, fillOpacity = textAttribute.fillOpacity } = text.attribute;
            if (!underline && !lineThrough) {
                return;
            }
            const w = textMeasure.measureTextWidth(textStr, {
                fontSize,
                fontFamily,
                fontWeight,
                fontStyle
            });
            const offsetX = textDrawOffsetX(textAlign, w);
            const offsetY = textLayoutOffsetY(textBaseline, fontSize, fontSize);
            const attribute = { lineWidth: 0, stroke: fill, opacity, strokeOpacity: fillOpacity };
            if (underline) {
                attribute.lineWidth = underline;
                context.setStrokeStyle(text, attribute, x, y, textAttribute);
                context.setLineDash(underlineDash);
                context.beginPath();
                const dy = y + offsetY + fontSize + underlineOffset;
                context.moveTo(x + offsetX, dy, z);
                context.lineTo(x + offsetX + w, dy, z);
                context.stroke();
            }
            if (lineThrough) {
                attribute.lineWidth = lineThrough;
                context.setStrokeStyle(text, attribute, x, y, textAttribute);
                context.beginPath();
                const dy = y + offsetY + fontSize / 2;
                context.moveTo(x + offsetX, dy, z);
                context.lineTo(x + offsetX + w, dy, z);
                context.stroke();
            }
        }
    };
    SuffixTextBeforeRenderContribution = __decorate([
        injectable()
    ], SuffixTextBeforeRenderContribution);

    let VChartPicker = class VChartPicker {
        type = 'chart';
        numberType = CHART_NUMBER_TYPE;
        contains(chart, point, params) {
            if (!chart.AABBBounds.containsPoint(point)) {
                return false;
            }
            return true;
        }
    };
    VChartPicker = __decorate([
        injectable()
    ], VChartPicker);

    var splitModule = new ContainerModule((bind, unbind, isBound, rebind) => {
        if (isBound(SplitRectBeforeRenderContribution$1)) {
            rebind(SplitRectBeforeRenderContribution$1).to(SplitRectBeforeRenderContribution).inSingletonScope();
        }
        else {
            bind(SplitRectBeforeRenderContribution).toSelf().inSingletonScope();
            bind(RectRenderContribution).toService(SplitRectBeforeRenderContribution);
        }
        if (isBound(SplitRectAfterRenderContribution$1)) {
            rebind(SplitRectAfterRenderContribution$1).to(SplitRectAfterRenderContribution).inSingletonScope();
        }
        else {
            bind(SplitRectAfterRenderContribution).toSelf().inSingletonScope();
            bind(RectRenderContribution).toService(SplitRectAfterRenderContribution);
        }
        bind(DefaultCanvasChartRender).toSelf().inSingletonScope();
        bind(ChartRender).to(DefaultCanvasChartRender);
        bind(GraphicRender).to(DefaultCanvasChartRender);
        bind(VChartPicker).toSelf().inSingletonScope();
        bind(CanvasPickerContribution).toService(VChartPicker);
        bind(BeforeImageRenderContribution).toSelf().inSingletonScope();
        bind(ImageRenderContribution).toService(BeforeImageRenderContribution);
        bind(AfterImageRenderContribution).toSelf().inSingletonScope();
        bind(ImageRenderContribution).toService(AfterImageRenderContribution);
        bind(BeforeGifImageRenderContribution).toSelf().inSingletonScope();
        bind(ImageRenderContribution).toService(BeforeGifImageRenderContribution);
        bind(AfterGifImageRenderContribution).toSelf().inSingletonScope();
        bind(ImageRenderContribution).toService(AfterGifImageRenderContribution);
        bind(AdjustColorGroupBeforeRenderContribution).toSelf().inSingletonScope();
        bind(GroupRenderContribution).toService(AdjustColorGroupBeforeRenderContribution);
        bind(AdjustColorGroupAfterRenderContribution).toSelf().inSingletonScope();
        bind(GroupRenderContribution).toService(AdjustColorGroupAfterRenderContribution);
        bind(SplitGroupAfterRenderContribution).toSelf().inSingletonScope();
        bind(GroupRenderContribution).toService(SplitGroupAfterRenderContribution);
        bind(SplitGroupBeforeRenderContribution).toSelf().inSingletonScope();
        bind(GroupRenderContribution).toService(SplitGroupBeforeRenderContribution);
        bind(DashGroupBeforeRenderContribution).toSelf().inSingletonScope();
        bind(GroupRenderContribution).toService(DashGroupBeforeRenderContribution);
        bind(DashGroupAfterRenderContribution).toSelf().inSingletonScope();
        bind(GroupRenderContribution).toService(DashGroupAfterRenderContribution);
        bind(AdjustPosGroupBeforeRenderContribution).toSelf().inSingletonScope();
        bind(GroupRenderContribution).toService(AdjustPosGroupBeforeRenderContribution);
        bind(AdjustPosGroupAfterRenderContribution).toSelf().inSingletonScope();
        bind(GroupRenderContribution).toService(AdjustPosGroupAfterRenderContribution);
        bind(ClipBodyGroupBeforeRenderContribution).toSelf().inSingletonScope();
        bind(GroupRenderContribution).toService(ClipBodyGroupBeforeRenderContribution);
        bind(VTableDrawItemInterceptorContribution).toSelf().inSingletonScope();
        bind(DrawItemInterceptor).toService(VTableDrawItemInterceptorContribution);
        bind(SuffixTextBeforeRenderContribution).toSelf().inSingletonScope();
        bind(TextRenderContribution).toService(SuffixTextBeforeRenderContribution);
    });

    function computeColsWidth(table, colStart, colEnd, update) {
        table.internalProps.columnWidthConfig &&
            table._parseColumnWidthConfig(table.internalProps.columnWidthConfig);
        table.isPivotTable() &&
            table.internalProps.columnWidthConfigForRowHeader &&
            table._parseColumnWidthConfigForRowHeader(table.internalProps.columnWidthConfigForRowHeader);
        colStart = colStart ?? 0;
        colEnd = colEnd ?? table.colCount - 1;
        if (colStart === 0 && colEnd === table.colCount - 1) {
            table._clearColRangeWidthsMap();
        }
        const layoutMap = table.internalProps.layoutMap;
        if (table.isPivotTable()) {
            layoutMap.enableUseGetBodyCache();
            layoutMap.enableUseHeaderPathCache();
        }
        const oldColWidths = [];
        const newWidths = [];
        if (update) {
            for (let col = 0; col < table.colCount; col++) {
                oldColWidths[col] = table.getColWidth(col);
            }
        }
        for (let col = colStart; col <= colEnd; col++) {
            let maxWidth;
            if (!table.internalProps.transpose &&
                (table.internalProps.layoutMap.columnObjects?.[col]?.columnWidthComputeMode === 'only-header' ||
                    table.columnWidthComputeMode === 'only-header') &&
                'showHeader' in table.internalProps.layoutMap) {
                const temp = table.internalProps.layoutMap.showHeader;
                table.internalProps.layoutMap.showHeader = true;
                maxWidth = computeColWidth(col, 0, table.internalProps.layoutMap.headerLevelCount - 1, table);
                table.internalProps.layoutMap.showHeader = temp;
            }
            else if (!table.internalProps.transpose &&
                (table.internalProps.layoutMap.columnObjects?.[col]?.columnWidthComputeMode === 'only-body' ||
                    table.columnWidthComputeMode === 'only-body')) {
                maxWidth = computeColWidth(col, table.internalProps.layoutMap.getBodyRange().start.row, table.internalProps.layoutMap.getBodyRange().end.row, table);
            }
            else {
                maxWidth = computeColWidth(col, 0, table.rowCount - 1, table);
            }
            table._setColContentWidth(col, maxWidth);
            const oldWidth = table.getColWidth(col);
            if (oldWidth !== maxWidth) {
                table._clearColRangeWidthsMap(col);
            }
            if (update) {
                newWidths[col] = Math.round(table._adjustColWidth(col, maxWidth));
            }
            else {
                table._setColWidth(col, table._adjustColWidth(col, maxWidth), false, true);
            }
        }
        if (table.widthMode === 'adaptive') {
            table._clearColRangeWidthsMap();
            const canvasWidth = table.tableNoFrameWidth;
            let actualHeaderWidth = 0;
            let startCol = 0;
            let endCol = table.colCount;
            if (table.widthAdaptiveMode === 'only-body') {
                for (let col = 0; col < table.colCount; col++) {
                    const colWidth = update ? newWidths[col] ?? table.getColWidth(col) : table.getColWidth(col);
                    if (col < table.rowHeaderLevelCount ||
                        (table.isPivotChart() && col >= table.colCount - table.rightFrozenColCount)) {
                        actualHeaderWidth += colWidth;
                    }
                }
                startCol = table.rowHeaderLevelCount;
                endCol = table.isPivotChart() ? table.colCount - table.rightFrozenColCount : table.colCount;
            }
            getAdaptiveWidth(canvasWidth - actualHeaderWidth, startCol, endCol, update, newWidths, table);
        }
        else if (table.autoFillWidth) {
            table._clearColRangeWidthsMap();
            const canvasWidth = table.tableNoFrameWidth;
            let actualHeaderWidth = 0;
            let actualWidth = 0;
            for (let col = 0; col < table.colCount; col++) {
                const colWidth = update ? newWidths[col] ?? table.getColWidth(col) : table.getColWidth(col);
                if (col < table.rowHeaderLevelCount + table.leftRowSeriesNumberCount ||
                    (table.isPivotChart() && col >= table.colCount - table.rightFrozenColCount)) {
                    actualHeaderWidth += colWidth;
                }
                actualWidth += colWidth;
            }
            if (actualWidth < canvasWidth && actualWidth > actualHeaderWidth) {
                const startCol = table.rowHeaderLevelCount + table.leftRowSeriesNumberCount;
                const endCol = table.isPivotChart() ? table.colCount - table.rightFrozenColCount : table.colCount;
                getAdaptiveWidth(canvasWidth - actualHeaderWidth, startCol, endCol, update, newWidths, table);
            }
        }
        if (update) {
            for (let col = 0; col < table.colCount; col++) {
                const newColWidth = newWidths[col] ?? table.getColWidth(col) ?? table.getColWidth(col);
                if (newColWidth !== oldColWidths[col]) {
                    table._setColWidth(col, newColWidth, false, true);
                }
            }
            table.stateManager.checkFrozen();
            for (let col = 0; col < table.colCount; col++) {
                const newColWidth = table.getColWidth(col);
                if (newColWidth !== oldColWidths[col]) {
                    table.scenegraph.updateColWidth(col, newColWidth - oldColWidths[col], true, true);
                }
            }
            table.scenegraph.updateContainer(true);
        }
        if (table.isPivotTable()) {
            layoutMap.disableUseGetBodyCache();
            layoutMap.disableUseHeaderPathCache();
        }
    }
    function computeColWidth(col, startRow, endRow, table, forceCompute = false) {
        let width = getColWidthDefinedWidthResizedWidth(col, table);
        if (table.internalProps.transpose &&
            width === 'auto' &&
            ((table.columnWidthComputeMode === 'only-header' && col >= table.rowHeaderLevelCount) ||
                (table.columnWidthComputeMode === 'only-body' && col < table.rowHeaderLevelCount))) {
            width = table.getDefaultColumnWidth(col);
        }
        if (forceCompute && !table.internalProps.transpose) {
            return computeAutoColWidth(width, col, startRow, endRow, forceCompute, table);
        }
        else if (typeof width === 'number') {
            return width;
        }
        else if (width !== 'auto' && typeof width === 'string') {
            return table._adjustColWidth(col, table._colWidthDefineToPxWidth(width));
        }
        return computeAutoColWidth(width, col, startRow, endRow, forceCompute, table);
    }
    function computeAutoColWidth(widthDeifne, col, startRow, endRow, forceCompute, table) {
        let maxWidth = 0;
        let deltaRow = 1;
        let prepareDeltaRow = 1;
        if (endRow - startRow > 5000) {
            prepareDeltaRow = Math.ceil((endRow - startRow) / 5000);
        }
        if (table.isPivotChart() && col >= table.rowHeaderLevelCount && col < table.colCount - table.rightFrozenColCount) {
            if (!table.internalProps.layoutMap.indicatorsAsCol) {
                const optimunWidth = table.internalProps.layoutMap.getOptimunWidthForChart(col);
                if (optimunWidth > 0) {
                    return optimunWidth;
                }
            }
            else {
                return table.defaultColWidth;
            }
        }
        for (let row = startRow; row <= endRow; row += deltaRow) {
            if (table.isPivotChart()) {
                const layout = table.internalProps.layoutMap;
                const axisConfig = layout.getAxisConfigInPivotChart(col, row);
                if (axisConfig) {
                    const computeAxisComponentWidth = Factory.getFunction('computeAxisComponentWidth');
                    const axisWidth = computeAxisComponentWidth(axisConfig, table);
                    if (typeof axisWidth === 'number') {
                        maxWidth = Math.max(axisWidth, maxWidth);
                        continue;
                    }
                }
                else if (layout.isLeftBottomCorner(col, row) ||
                    layout.isRightTopCorner(col, row) ||
                    layout.isRightBottomCorner(col, row)) {
                    continue;
                }
            }
            const customWidth = computeCustomRenderWidth(col, row, table);
            if (customWidth) {
                maxWidth = Math.max(customWidth.width, maxWidth);
                if (!customWidth.renderDefault) {
                    continue;
                }
            }
            const indicatorWidth = widthDeifne;
            if (typeof indicatorWidth === 'number' && table.widthMode === 'standard' && !forceCompute) {
                maxWidth = Math.max(indicatorWidth, maxWidth);
                continue;
            }
            const cellType = table.isHeader(col, row)
                ? table._getHeaderLayoutMap(col, row)?.headerType
                : table.getBodyColumnType(col, row);
            if (isValid$3(cellType) &&
                cellType !== 'text' &&
                cellType !== 'link' &&
                cellType !== 'progressbar' &&
                cellType !== 'checkbox' &&
                cellType !== 'radio' &&
                cellType !== 'switch' &&
                cellType !== 'button') {
                maxWidth = Math.max(maxWidth, table.getColWidthDefinedNumber(col) || 0);
                continue;
            }
            let cellHierarchyIndent = 0;
            const layoutMap = table.internalProps.layoutMap;
            if (layoutMap.isHeader(col, row)) {
                const hd = layoutMap.getHeader(col, row);
                if (hd?.define?.columnWidthComputeMode === 'only-body') {
                    continue;
                }
                if (isValid$3(hd?.hierarchyLevel)) {
                    cellHierarchyIndent =
                        (hd.hierarchyLevel ?? 0) *
                            (layoutMap.rowHierarchyType === 'tree'
                                ? layoutMap.rowHierarchyIndent ?? 0
                                : 0);
                    if (layoutMap.rowHierarchyTextStartAlignment &&
                        !table.internalProps.headerHelper.getHierarchyIcon(col, row)) {
                        cellHierarchyIndent += table.internalProps.headerHelper.getHierarchyIconWidth();
                    }
                }
            }
            else if (table.isListTable()) {
                deltaRow = prepareDeltaRow;
                const define = table.getBodyColumnDefine(col, row);
                if (define?.tree) {
                    const indexArr = table.dataSource.getIndexKey(table.getRecordShowIndexByCell(col, row));
                    cellHierarchyIndent =
                        Array.isArray(indexArr) && table.getHierarchyState(col, row) !== HierarchyState.none
                            ? (indexArr.length - 1) * (layoutMap.hierarchyIndent ?? 0)
                            : 0;
                    if (layoutMap.hierarchyTextStartAlignment &&
                        !table.internalProps.bodyHelper.getHierarchyIcon(col, row)) {
                        cellHierarchyIndent += table.internalProps.headerHelper.getHierarchyIconWidth();
                    }
                }
            }
            const textWidth = computeTextWidth(col, row, cellType, table);
            maxWidth = Math.max(textWidth + cellHierarchyIndent, maxWidth);
            if (deltaRow > 1 &&
                table.bottomFrozenRowCount > 0 &&
                row < table.rowCount - table.bottomFrozenRowCount &&
                row + deltaRow >= table.rowCount - table.bottomFrozenRowCount) {
                row = table.rowCount - table.bottomFrozenRowCount - deltaRow;
                deltaRow = 1;
                prepareDeltaRow = 1;
            }
        }
        const colMinWidth = table.getMinColWidth(col);
        const colMaxWidth = table.getMaxColWidth(col);
        if (maxWidth < colMinWidth) {
            return colMinWidth;
        }
        else if (maxWidth > colMaxWidth) {
            return colMaxWidth;
        }
        else if (maxWidth <= 0) {
            maxWidth = table.defaultColWidth;
        }
        return maxWidth;
    }
    function computeCustomRenderWidth(col, row, table) {
        const customRender = table.getCustomRender(col, row);
        let customLayout = table.getCustomLayout(col, row);
        if (customRender || customLayout) {
            let spanCol = 1;
            let width = 0;
            let renderDefault = false;
            let enableCellPadding = false;
            let cellRange;
            if (table.isHeader(col, row) ||
                table.getBodyColumnDefine(col, row)?.mergeCell ||
                table.hasCustomMerge()) {
                cellRange = table.getCellRange(col, row);
                spanCol = cellRange.end.col - cellRange.start.col + 1;
            }
            const arg = {
                col: cellRange?.start.col ?? col,
                row: cellRange?.start.row ?? row,
                dataValue: table.getCellOriginValue(col, row),
                value: table.getCellValue(col, row) || '',
                rect: getCellRect(col, row, table),
                table,
                originCol: col,
                originRow: row,
                forComputation: true
            };
            if (customLayout === 'react-custom-layout') {
                customLayout = table.reactCustomLayout?.getCustomLayoutFunc(col, row) || emptyCustomLayout;
            }
            if (isFunction$5(customLayout)) {
                const customLayoutObj = customLayout(arg);
                if (customLayoutObj.rootContainer) {
                    customLayoutObj.rootContainer = decodeReactDom(customLayoutObj.rootContainer);
                    dealPercentCalc(customLayoutObj.rootContainer, 0, table.getRowHeight(row));
                    const setedWidth = customLayoutObj.rootContainer.attribute.width;
                    customLayoutObj.rootContainer.setStage(table.scenegraph.stage);
                    width = setedWidth > 0 ? setedWidth : customLayoutObj.rootContainer.AABBBounds.width() ?? 0;
                    renderDefault = customLayoutObj.renderDefault;
                    enableCellPadding = customLayoutObj.enableCellPadding;
                }
                else {
                    width = 0;
                    renderDefault = customLayoutObj.renderDefault;
                    enableCellPadding = customLayoutObj.enableCellPadding;
                }
            }
            else if (typeof customRender === 'function') {
                const customRenderObj = customRender(arg);
                width = customRenderObj?.expectedWidth ?? 0;
                renderDefault = customRenderObj?.renderDefault;
            }
            else {
                width = customRender?.expectedWidth ?? 0;
                renderDefault = customRender?.renderDefault;
            }
            width = Math.ceil(width);
            if (enableCellPadding) {
                const actStyle = table._getCellStyle(col, row);
                const padding = getQuadProps(getProp('padding', actStyle, col, row, table));
                width += padding[1] + padding[3];
            }
            return {
                width: width / spanCol,
                renderDefault
            };
        }
        return undefined;
    }
    function computeTextWidth(col, row, cellType, table) {
        let maxWidth = 0;
        const cellValue = table.getCellValue(col, row);
        const actStyle = table._getCellStyle(col, row);
        let iconWidth = 0;
        let mayHaveIcon = false;
        if (table.getCellLocation(col, row) !== 'body') {
            mayHaveIcon = true;
        }
        else {
            const define = table.getBodyColumnDefine(col, row);
            mayHaveIcon = !!define?.icon || !!define?.tree || define?.dragOrder;
        }
        if (mayHaveIcon) {
            const icons = table.getCellIcons(col, row);
            icons?.forEach(icon => {
                if (icon.positionType !== IconPosition.absoluteRight) {
                    iconWidth += (icon.width ?? 0) + (icon.marginLeft ?? 0) + (icon.marginRight ?? 0);
                }
            });
        }
        let spanCol = 1;
        if (table.isHeader(col, row) ||
            table.getBodyColumnDefine(col, row)?.mergeCell ||
            table.hasCustomMerge()) {
            const cellRange = table.getCellRange(col, row);
            spanCol = cellRange.end.col - cellRange.start.col + 1;
        }
        const padding = getQuadProps(getProp('padding', actStyle, col, row, table));
        const paddingWidth = padding[1] + padding[3];
        const fontSize = getProp('fontSize', actStyle, col, row, table);
        const fontFamily = getProp('fontFamily', actStyle, col, row, table);
        const fontWeight = getProp('fontWeight', actStyle, col, row, table);
        let text;
        if (cellType === 'checkbox') {
            text = isObject$7(cellValue) ? cellValue.text : cellValue;
        }
        else if (cellType === 'radio') {
            if (isArray$7(cellValue)) {
                text = '';
                const define = table.getBodyColumnDefine(col, row);
                const radioDirectionInCell = define?.radioDirectionInCell ?? 'vertical';
                if (radioDirectionInCell === 'vertical') {
                    cellValue.forEach(line => {
                        text += (isObject$7(line) ? line.text : line).toString() + '\n';
                    });
                }
                else if (radioDirectionInCell === 'horizontal') {
                    cellValue.forEach(line => {
                        text += (isObject$7(line) ? line.text : line).toString();
                    });
                }
            }
            else {
                text = isObject$7(cellValue) ? cellValue.text : cellValue;
            }
        }
        else if (cellType === 'button') {
            const define = table.getBodyColumnDefine(col, row);
            const buttonTextValue = getOrApply(define.text, {
                col,
                row,
                table,
                context: null,
                value: cellValue,
                dataValue: table.getCellOriginValue(col, row)
            });
            text = buttonTextValue ?? cellValue ?? '';
        }
        else {
            text = cellValue;
        }
        const lines = breakString(text, table).text;
        if (lines.length >= 1 && !(lines.length === 1 && lines[0] === '')) {
            lines.forEach((line) => {
                const width = table.measureText(line, {
                    fontSize,
                    fontFamily,
                    fontWeight
                }).width;
                maxWidth = Math.max((width + paddingWidth + 4 + iconWidth) / spanCol, maxWidth);
            });
        }
        else {
            maxWidth = Math.max((paddingWidth + 4 + iconWidth) / spanCol, maxWidth);
        }
        if (table.internalProps.limitMaxAutoWidth !== false) {
            maxWidth = Math.min(typeof table.internalProps.limitMaxAutoWidth === 'number' ? table.internalProps.limitMaxAutoWidth : 450, maxWidth);
        }
        if (cellType === 'checkbox') {
            const size = getProp('size', actStyle, col, row, table);
            maxWidth += size;
            if (text) {
                const spaceBetweenTextAndIcon = getProp('spaceBetweenTextAndIcon', actStyle, col, row, table);
                maxWidth += spaceBetweenTextAndIcon;
            }
        }
        else if (cellType === 'radio') {
            const size = getProp('size', actStyle, col, row, table);
            const outerRadius = getProp('outerRadius', actStyle, col, row, table);
            const circleSize = isNumber$4(outerRadius) ? outerRadius * 2 : size;
            const spaceBetweenTextAndIcon = getProp('spaceBetweenTextAndIcon', actStyle, col, row, table);
            if (isArray$7(cellValue)) {
                const define = table.getBodyColumnDefine(col, row);
                const spaceBetweenRadio = getProp('spaceBetweenRadio', actStyle, col, row, table);
                const radioDirectionInCell = define?.radioDirectionInCell ?? 'vertical';
                if (radioDirectionInCell === 'vertical') {
                    maxWidth += circleSize;
                    maxWidth += spaceBetweenTextAndIcon;
                }
                else if (radioDirectionInCell === 'horizontal') {
                    maxWidth += (circleSize + spaceBetweenTextAndIcon) * cellValue.length;
                    maxWidth += spaceBetweenRadio * (cellValue.length - 1);
                }
            }
            else {
                maxWidth += circleSize;
                if (text) {
                    maxWidth += spaceBetweenTextAndIcon;
                }
            }
        }
        else if (cellType === 'switch') {
            const boxWidth = getProp('boxWidth', actStyle, col, row, table);
            maxWidth = boxWidth;
        }
        else if (cellType === 'button') {
            const buttonPadding = getProp('buttonPadding', actStyle, col, row, table);
            maxWidth += buttonPadding * 2;
        }
        return maxWidth;
    }
    function getCellRect(col, row, table) {
        return {
            left: 0,
            top: 0,
            right: table.getColWidth(col),
            bottom: table.getRowHeight(row),
            width: null,
            height: null
        };
    }
    function getColWidthDefinedWidthResizedWidth(col, table) {
        const widthDefined = table.getColWidthDefined(col);
        if (table.internalProps._widthResizedColMap.has(col)) {
            return table.getColWidth(col);
        }
        return widthDefined;
    }
    function getAdaptiveWidth(totalDrawWidth, startCol, endColPlus1, update, newWidths, table, fromScenegraph) {
        let actualWidth = 0;
        const adaptiveColumns = [];
        const sparklineColumns = [];
        let totalSparklineAbleWidth = 0;
        for (let col = startCol; col < endColPlus1; col++) {
            const width = update ? newWidths[col] ?? table.getColWidth(col) : table.getColWidth(col);
            const maxWidth = table.getMaxColWidth(col);
            const minWidth = table.getMinColWidth(col);
            if (width !== maxWidth && width !== minWidth) {
                actualWidth += width;
                adaptiveColumns.push(col);
            }
            else {
                totalDrawWidth -= width;
            }
            if (table.options.customConfig?.shrinkSparklineFirst) {
                const bodyCellType = table.getBodyColumnType(col, 0);
                if (bodyCellType === 'sparkline') {
                    sparklineColumns.push({ col, width });
                    totalSparklineAbleWidth += width - table.defaultColWidth;
                }
            }
        }
        const factor = totalDrawWidth / actualWidth;
        if (table.options.customConfig?.shrinkSparklineFirst &&
            factor < 1 &&
            actualWidth - totalDrawWidth < totalSparklineAbleWidth) {
            for (let i = 0; i < sparklineColumns.length; i++) {
                const { col, width } = sparklineColumns[i];
                const deltaWidth = (actualWidth - totalDrawWidth) / sparklineColumns.length;
                const colWidth = Math.floor(width - deltaWidth);
                if (update) {
                    newWidths[col] = table._adjustColWidth(col, colWidth);
                }
                else if (fromScenegraph) {
                    table.scenegraph.setColWidth(col, table._adjustColWidth(col, colWidth));
                }
                else {
                    table._setColWidth(col, table._adjustColWidth(col, colWidth), false, true);
                }
            }
            return;
        }
        for (let i = 0; i < adaptiveColumns.length; i++) {
            const col = adaptiveColumns[i];
            let colWidth;
            if (i === adaptiveColumns.length - 1) {
                colWidth =
                    totalDrawWidth -
                        adaptiveColumns.reduce((acr, cur, index) => {
                            if (cur !== col) {
                                return acr + (update ? newWidths[cur] ?? table.getColWidth(col) : table.getColWidth(cur));
                            }
                            return acr;
                        }, 0);
            }
            else {
                colWidth = Math.round((update ? newWidths[col] ?? table.getColWidth(col) : table.getColWidth(col)) * factor);
            }
            if (update) {
                newWidths[col] = table._adjustColWidth(col, colWidth);
            }
            else if (fromScenegraph) {
                table.scenegraph.setColWidth(col, table._adjustColWidth(col, colWidth));
            }
            else {
                table._setColWidth(col, table._adjustColWidth(col, colWidth), false, true);
            }
        }
    }

    const emptyGroup = new Group$1({});
    emptyGroup.role = 'empty';

    function createComplexColumn(columnGroup, col, colWidth, rowStart, rowEnd, mergeMap, defaultRowHeight, table, rowLimit) {
        let padding;
        let textAlign;
        let textBaseline;
        let y = 0;
        if (columnGroup.lastChild && columnGroup.lastChild.row === rowStart - 1) {
            y = columnGroup.lastChild.attribute.y + columnGroup.lastChild.attribute.height;
        }
        else if (columnGroup.colHeight) {
            y = columnGroup.colHeight;
        }
        for (let j = rowStart; j <= rowEnd; j++) {
            const row = j;
            let cellLocation = table.getCellLocation(col, row);
            let value = table.getCellValue(col, row);
            let cellWidth = colWidth;
            let cellHeight = table.getRowHeight(row);
            let range;
            let isMerge;
            let customStyle;
            let customResult;
            let isCustomMerge = false;
            if (table.internalProps.customMergeCell) {
                const customMerge = table.getCustomMerge(col, row);
                if (customMerge) {
                    const { range: customMergeRange, text: customMergeText, style: customMergeStyle, customLayout, customRender } = customMerge;
                    range = customMergeRange;
                    isMerge = range.start.col !== range.end.col || range.start.row !== range.end.row;
                    if (isMerge) {
                        const needUpdateRange = rowStart > range.start.row;
                        const mergeSize = dealMerge(range, mergeMap, table, needUpdateRange);
                        cellWidth = mergeSize.cellWidth;
                        cellHeight = mergeSize.cellHeight;
                    }
                    value = customMergeText;
                    customStyle = customMergeStyle;
                    if (customLayout || customRender) {
                        customResult = dealWithCustom(customLayout, customRender, customMergeRange.start.col, customMergeRange.start.row, table.getColsWidth(customMergeRange.start.col, customMergeRange.end.col), table.getRowsHeight(customMergeRange.start.row, customMergeRange.end.row), false, table.isAutoRowHeight(row), [0, 0, 0, 0], range, table);
                    }
                    isCustomMerge = true;
                }
            }
            let colForDefine = col;
            let rowForDefine = row;
            if (range) {
                colForDefine = range.start.col;
                rowForDefine = range.start.row;
            }
            if (!table.isPivotTable() &&
                (cellLocation === 'columnHeader' || cellLocation === 'cornerHeader') &&
                row >= table.columnHeaderLevelCount) {
                cellLocation = 'body';
            }
            let define;
            if (!table.isPivotTable() && table.isSeriesNumberInBody(col, row)) {
                define = table.getBodyColumnDefine(colForDefine, rowForDefine);
            }
            else {
                define =
                    cellLocation !== 'body'
                        ? table.getHeaderDefine(colForDefine, rowForDefine)
                        : table.getBodyColumnDefine(colForDefine, rowForDefine);
            }
            const isAggregation = 'isAggregation' in table.internalProps.layoutMap && table.internalProps.layoutMap.isAggregation(col, row);
            const isSeriesNumber = table.internalProps.layoutMap.isSeriesNumber(col, row);
            let mayHaveIcon = cellLocation !== 'body'
                ? true
                : (define?.dragOrder || !!define?.icon || !!define?.tree) &&
                    !(isAggregation && isSeriesNumber);
            if (!range &&
                (table.internalProps.enableTreeNodeMerge || cellLocation !== 'body' || define?.mergeCell)) {
                range = table.getCellRange(col, row);
                isMerge = range.start.col !== range.end.col || range.start.row !== range.end.row;
                if (isMerge) {
                    const needUpdateRange = rowStart > range.start.row;
                    const mergeSize = dealMerge(range, mergeMap, table, needUpdateRange);
                    cellWidth = mergeSize.cellWidth;
                    cellHeight = mergeSize.cellHeight;
                }
            }
            let isVtableMerge = false;
            if (table.internalProps.enableTreeNodeMerge && isMerge) {
                const rawRecord = table.getCellRawRecord(range.start.col, range.start.row);
                const { vtableMergeName, vtableMerge } = rawRecord ?? {};
                isVtableMerge = vtableMerge;
                if (vtableMerge) {
                    mayHaveIcon = true;
                    if (table.options.groupTitleCustomLayout) {
                        customResult = dealWithCustom(table.options.groupTitleCustomLayout, undefined, range.start.col, range.start.row, table.getColsWidth(range.start.col, range.end.col), table.getRowsHeight(range.start.row, range.end.row), false, table.isAutoRowHeight(row), [0, 0, 0, 0], range, table);
                    }
                    if (table.options.groupTitleFieldFormat) {
                        value = table.options.groupTitleFieldFormat(rawRecord, col, row, table);
                    }
                    else if (vtableMergeName) {
                        value = vtableMergeName;
                    }
                }
            }
            const type = isVtableMerge || isCustomMerge
                ? 'text'
                : (table.isHeader(col, row)
                    ? table._getHeaderLayoutMap(col, row).headerType ?? 'text'
                    : table.getBodyColumnType(col, row)) ?? 'text';
            if (isPromise(value)) {
                createEmptyCellGroup(col, row, 0, y, cellWidth, cellHeight, columnGroup);
                dealPromiseData(value, table, callCreateCellForPromiseValue.bind(null, {
                    type,
                    value,
                    define,
                    table,
                    col,
                    row,
                    colWidth,
                    cellWidth,
                    cellHeight,
                    columnGroup,
                    y,
                    customStyle,
                    mayHaveIcon,
                    cellLocation,
                    range,
                    customResult,
                    defaultRowHeight
                }));
                columnGroup.updateColumnRowNumber(row);
                const height = table.getRowHeight(row);
                columnGroup.updateColumnHeight(height);
                y += height;
            }
            else {
                const cellStyle = customStyle || table._getCellStyle(range ? range.start.col : col, range ? range.start.row : row);
                const cellTheme = getStyleTheme(cellStyle, table, range ? range.start.col : col, range ? range.start.row : row, getProp).theme;
                cellTheme.group.cornerRadius = getCellCornerRadius(col, row, table);
                cellTheme.group.width = colWidth;
                cellTheme.group.height = Array.isArray(defaultRowHeight) ? defaultRowHeight[row] : defaultRowHeight;
                if (cellTheme._vtable.padding) {
                    padding = cellTheme._vtable.padding;
                }
                if (cellTheme.text.textAlign) {
                    textAlign = cellTheme.text.textAlign;
                }
                if (cellTheme.text.textBaseline) {
                    textBaseline = cellTheme.text.textBaseline;
                }
                if (cellLocation !== 'body' && !cellTheme.group.fill) {
                    cellTheme.group.fill = '#fff';
                }
                const cellGroup = createCell(type, value, define, table, col, row, colWidth, cellWidth, cellHeight, columnGroup, y, padding, textAlign, textBaseline, mayHaveIcon, cellTheme, range, customResult);
                columnGroup.updateColumnRowNumber(row);
                if (isMerge) {
                    const rangeHeight = table.getRowHeight(row);
                    table.getColWidth(col);
                    const { width: contentWidth } = cellGroup.attribute;
                    const { height: contentHeight } = cellGroup.attribute;
                    cellGroup.contentWidth = contentWidth;
                    cellGroup.contentHeight = contentHeight;
                    dealWithMergeCellSize(range, contentWidth, contentHeight, padding, textAlign, textBaseline, table);
                    columnGroup.updateColumnHeight(rangeHeight);
                    y += rangeHeight;
                }
                else {
                    columnGroup.updateColumnHeight(cellHeight);
                    y += cellHeight;
                }
            }
            if (rowLimit && row > rowLimit) {
                break;
            }
        }
        columnGroup.setAttribute('width', colWidth);
        return {
            width: colWidth,
            height: y
        };
    }
    function callCreateCellForPromiseValue(createCellArgs) {
        let padding;
        let textAlign;
        let textBaseline;
        const { type, value, define, table, col, row, colWidth, cellWidth, cellHeight, columnGroup, y, cellLocation, mayHaveIcon, customStyle, range, customResult, defaultRowHeight } = createCellArgs;
        const cellStyle = customStyle || table._getCellStyle(range ? range.start.col : col, range ? range.start.row : row);
        const cellTheme = getStyleTheme(cellStyle, table, range ? range.start.col : col, range ? range.start.row : row, getProp).theme;
        cellTheme.group.cornerRadius = getCellCornerRadius(col, row, table);
        cellTheme.group.width = colWidth;
        cellTheme.group.height = Array.isArray(defaultRowHeight) ? defaultRowHeight[row] : defaultRowHeight;
        if (cellTheme._vtable.padding) {
            padding = cellTheme._vtable.padding;
        }
        if (cellTheme.text.textAlign) {
            textAlign = cellTheme.text.textAlign;
        }
        if (cellTheme.text.textBaseline) {
            textBaseline = cellTheme.text.textBaseline;
        }
        if (cellLocation !== 'body' && !cellTheme.group.fill) {
            cellTheme.group.fill = '#fff';
        }
        createCell(type, value, define, table, col, row, colWidth, cellWidth, cellHeight, columnGroup, y, padding, textAlign, textBaseline, mayHaveIcon, cellTheme, range, customResult);
    }
    function dealMerge(range, mergeMap, table, forceUpdate) {
        let cellWidth = 0;
        let cellHeight = 0;
        const mergeResult = mergeMap.get(`${range.start.col},${range.start.row};${range.end.col},${range.end.row}`);
        if (!mergeResult || forceUpdate) {
            for (let col = range.start.col; col <= range.end.col; col++) {
                cellWidth += table.getColWidth(col);
            }
            for (let i = range.start.row; i <= range.end.row; i++) {
                cellHeight += table.getRowHeight(i);
            }
            mergeMap.set(`${range.start.col},${range.start.row};${range.end.col},${range.end.row}`, {
                cellWidth,
                cellHeight
            });
        }
        else {
            cellWidth = mergeResult.cellWidth;
            cellHeight = mergeResult.cellHeight;
        }
        return {
            cellWidth,
            cellHeight
        };
    }
    function createEmptyCellGroup(col, row, x, y, width, height, columnGroup) {
        const cellGroup = new Group$1({
            x,
            y,
            width,
            height
        });
        cellGroup.role = 'cell';
        cellGroup.col = col;
        cellGroup.row = row;
        columnGroup.addChild(cellGroup);
    }

    function createColGroup(containerGroup, xOrigin, yOrigin, colStart, colEnd, rowStart, rowEnd, cellLocation, table, rowLimit) {
        if (colStart > colEnd || rowStart > rowEnd) {
            return;
        }
        const { layoutMap, defaultHeaderRowHeight, defaultColWidth } = table.internalProps;
        const defaultRowHeight = table.defaultRowHeight;
        let x = 0;
        let heightMax = 0;
        for (let i = colStart; i <= colEnd; i++) {
            const col = i;
            const colWidth = table.getColWidth(col);
            const columnGroup = new Group$1({
                x: xOrigin + x,
                y: yOrigin,
                width: colWidth,
                height: 0,
                clip: false,
                pickable: false
            });
            columnGroup.role = 'column';
            columnGroup.col = i;
            containerGroup.addChild(columnGroup);
            const { width: default2Width, height: default2Height } = createComplexColumn(columnGroup, col, colWidth, rowStart, rowEnd, table.scenegraph.mergeMap, cellLocation === 'columnHeader' && isNumber$4(defaultHeaderRowHeight)
                ? defaultHeaderRowHeight
                : defaultRowHeight, table, rowLimit);
            x += default2Width;
            heightMax = Math.max(heightMax, default2Height);
        }
        containerGroup.setAttribute('width', x);
        containerGroup.setAttribute('height', heightMax);
    }

    function createGroupForFirstScreen(cornerHeaderGroup, colHeaderGroup, rowHeaderGroup, rightFrozenGroup, bottomFrozenGroup, bodyGroup, xOrigin, yOrigin, proxy) {
        const { table } = proxy;
        const { leftBottomCornerGroup, rightTopCornerGroup, rightBottomCornerGroup } = table.scenegraph;
        proxy.setParamsForRow();
        proxy.setParamsForColumn();
        let distCol;
        let distRow;
        let distColForCompute;
        let distRowForCompute;
        if (table.widthMode === 'adaptive' ||
            (table.options.autoWrapText &&
                (table.heightMode === 'adaptive' || table.isAutoRowHeight(table.columnHeaderLevelCount)))) {
            distColForCompute = table.colCount - 1;
            distCol = Math.min(proxy.firstScreenColLimit - 1, table.colCount - 1);
        }
        else {
            distCol = Math.min(proxy.firstScreenColLimit - 1, table.colCount - 1);
        }
        if (table.heightMode === 'adaptive') {
            distRowForCompute = table.rowCount - 1;
            distRow = Math.min(proxy.firstScreenRowLimit - 1, table.rowCount - 1);
        }
        else {
            distRow = Math.min(proxy.firstScreenRowLimit - 1, table.rowCount - 1);
        }
        if (table.internalProps._widthResizedColMap.size === 0) {
            computeColsWidth(table, 0, distColForCompute ?? distCol);
        }
        if (table.internalProps._heightResizedRowMap.size === 0) {
            computeRowsHeight(table, 0, table.options.canvasHeight === 'auto' ? table.rowCount - 1 : distRowForCompute ?? distRow);
        }
        if (distCol < table.colCount - table.rightFrozenColCount) {
            if (table.colCount - table.rightFrozenColCount <= table.colCount - 1) {
                computeColsWidth(table, table.colCount - table.rightFrozenColCount, table.colCount - 1);
            }
        }
        if (distRow < table.rowCount - table.bottomFrozenRowCount) {
            if (table.rowCount - table.bottomFrozenRowCount <= table.rowCount - 1) {
                computeRowsHeight(table, table.rowCount - table.bottomFrozenRowCount, table.rowCount - 1);
            }
        }
        table.scenegraph.colHeaderGroup.setAttribute('x', table.getFrozenColsWidth());
        table.scenegraph.rowHeaderGroup.setAttribute('y', table.getFrozenRowsHeight());
        table.scenegraph.bottomFrozenGroup.setAttribute('x', table.getFrozenColsWidth());
        table.scenegraph.rightFrozenGroup.setAttribute('y', table.getFrozenRowsHeight());
        table.scenegraph.bodyGroup.setAttributes({
            x: table.getFrozenColsWidth(),
            y: table.getFrozenRowsHeight()
        });
        createColGroup(cornerHeaderGroup, xOrigin, yOrigin, 0, table.frozenColCount - 1, 0, table.frozenRowCount - 1, table.isListTable() ? 'columnHeader' : 'cornerHeader', table);
        distCol - table.rightFrozenColCount >= table.frozenColCount &&
            createColGroup(colHeaderGroup, xOrigin, yOrigin, table.frozenColCount, distCol - table.rightFrozenColCount, 0, table.frozenRowCount - 1, 'columnHeader', table);
        if (table.frozenColCount > 0) {
            if (table.leftRowSeriesNumberCount > 0) {
                createColGroup(rowHeaderGroup, xOrigin, yOrigin, 0, table.leftRowSeriesNumberCount - 1, table.frozenRowCount, distRow - table.bottomFrozenRowCount, 'rowHeader', table);
            }
            if (table.frozenColCount > table.leftRowSeriesNumberCount) {
                createColGroup(rowHeaderGroup, xOrigin, yOrigin, table.leftRowSeriesNumberCount, Math.min(table.frozenColCount - 1, table.rowHeaderLevelCount + table.leftRowSeriesNumberCount - 1), table.frozenRowCount, distRow - table.bottomFrozenRowCount, 'rowHeader', table);
            }
            if (table.frozenColCount > table.rowHeaderLevelCount + table.leftRowSeriesNumberCount) {
                createColGroup(rowHeaderGroup, xOrigin, yOrigin, table.rowHeaderLevelCount + table.leftRowSeriesNumberCount, table.frozenColCount - 1, table.frozenRowCount, distRow - table.bottomFrozenRowCount, 'body', table);
            }
        }
        if (table.bottomFrozenRowCount > 0) {
            if (table.frozenColCount > 0) {
                if (table.leftRowSeriesNumberCount > 0) {
                    createColGroup(leftBottomCornerGroup, xOrigin, yOrigin, 0, table.leftRowSeriesNumberCount - 1, table.rowCount - 1 - table.bottomFrozenRowCount + 1, table.rowCount - 1, 'rowHeader', table);
                }
                if (table.rowHeaderLevelCount > 0) {
                    createColGroup(leftBottomCornerGroup, xOrigin, yOrigin, table.leftRowSeriesNumberCount, table.leftRowSeriesNumberCount + table.rowHeaderLevelCount - 1, table.rowCount - 1 - table.bottomFrozenRowCount + 1, table.rowCount - 1, 'rowHeader', table);
                }
                if (table.frozenColCount > table.rowHeaderLevelCount + table.leftRowSeriesNumberCount) {
                    createColGroup(leftBottomCornerGroup, xOrigin, yOrigin, table.rowHeaderLevelCount + table.leftRowSeriesNumberCount, table.frozenColCount - 1, table.rowCount - 1 - table.bottomFrozenRowCount + 1, table.rowCount - 1, 'body', table);
                }
            }
            distCol - table.rightFrozenColCount >= table.frozenColCount &&
                createColGroup(bottomFrozenGroup, xOrigin, yOrigin, table.frozenColCount, distCol - table.rightFrozenColCount, table.rowCount - 1 - table.bottomFrozenRowCount + 1, table.rowCount - 1, table.isPivotChart() ? 'rowHeader' : 'body', table);
        }
        if (table.rightFrozenColCount > 0) {
            createColGroup(rightTopCornerGroup, xOrigin, yOrigin, table.colCount - 1 - table.rightFrozenColCount + 1, table.colCount - 1, 0, table.frozenRowCount - 1, 'columnHeader', table);
            createColGroup(rightFrozenGroup, xOrigin, yOrigin, table.colCount - 1 - table.rightFrozenColCount + 1, table.colCount - 1, table.frozenRowCount, distRow - table.bottomFrozenRowCount, table.isPivotChart() ? 'rowHeader' : 'body', table);
        }
        if (table.bottomFrozenRowCount > 0 && table.rightFrozenColCount > 0) {
            createColGroup(rightBottomCornerGroup, xOrigin, yOrigin, table.colCount - 1 - table.rightFrozenColCount + 1, table.colCount - 1, table.rowCount - 1 - table.bottomFrozenRowCount + 1, table.rowCount - 1, 'body', table);
        }
        distCol - table.rightFrozenColCount >= table.frozenColCount &&
            createColGroup(bodyGroup, xOrigin, yOrigin, table.frozenColCount, distCol - table.rightFrozenColCount, table.frozenRowCount, distRow - table.bottomFrozenRowCount, 'body', table);
        if (!bodyGroup.firstChild &&
            !colHeaderGroup.firstChild &&
            !cornerHeaderGroup.firstChild &&
            !rowHeaderGroup.firstChild) {
            proxy.currentRow = proxy.totalRow;
            proxy.rowEnd = proxy.currentRow;
            proxy.rowUpdatePos = proxy.rowEnd + 1;
            proxy.referenceRow = proxy.rowStart + Math.floor((proxy.rowEnd - proxy.rowStart) / 2);
            proxy.currentCol = proxy.totalCol;
            proxy.colEnd = proxy.currentCol;
            proxy.colUpdatePos = proxy.colEnd + 1;
            proxy.referenceCol = proxy.colStart + Math.floor((proxy.colEnd - proxy.colStart) / 2);
        }
        else {
            proxy.currentRow =
                bodyGroup.firstChild?.rowNumber ?? rowHeaderGroup.firstChild?.rowNumber ?? proxy.totalRow;
            proxy.rowEnd = proxy.currentRow;
            proxy.rowUpdatePos = proxy.rowEnd + 1;
            proxy.referenceRow = proxy.rowStart + Math.floor((proxy.rowEnd - proxy.rowStart) / 2);
            proxy.currentCol =
                bodyGroup.lastChild?.col ??
                    colHeaderGroup.lastChild?.col ??
                    rowHeaderGroup.lastChild?.col ??
                    cornerHeaderGroup.lastChild?.col ??
                    proxy.totalCol;
            proxy.colEnd = proxy.currentCol;
            proxy.colUpdatePos = proxy.colEnd + 1;
            proxy.referenceCol = proxy.colStart + Math.floor((proxy.colEnd - proxy.colStart) / 2);
            proxy.progress();
        }
    }

    function getFirstChild(containerGroup) {
        let child = containerGroup.firstChild;
        while (child && child.type !== 'group') {
            child = child._next;
        }
        return child;
    }
    function getLastChild(containerGroup) {
        let child = containerGroup.lastChild;
        while (child && child.type !== 'group') {
            child = child._prev;
        }
        return child;
    }
    function getPrevGroup(group) {
        let child = group._prev;
        while (child && child.type !== 'group') {
            child = child._prev;
        }
        return child;
    }
    function getNextGroup(group) {
        let child = group._next;
        while (child && child.type !== 'group') {
            child = child._next;
        }
        return child;
    }

    function updateAutoColumn(colStart, colEnd, table, direction = 'left') {
        for (let col = colStart; col <= colEnd; col++) {
            const bodyColGroup = table.scenegraph.getColGroup(col);
            if (bodyColGroup) {
                moveColumnGroup(bodyColGroup, table, direction);
            }
            const columnHeaderColGroup = table.scenegraph.getColGroup(col, true);
            if (columnHeaderColGroup) {
                moveColumnGroup(columnHeaderColGroup, table, direction);
            }
            const bottomColGroup = table.scenegraph.getColGroupInBottom(col);
            if (bottomColGroup) {
                moveColumnGroup(bottomColGroup, table, direction);
            }
        }
        const totalActualBodyColumnCount = Math.min(table.scenegraph.proxy.colLimit, table.scenegraph.proxy.bodyRightCol - table.scenegraph.proxy.bodyLeftCol + 1);
        const totalBodyWidth = table.getColsWidth(table.frozenColCount, table.frozenColCount + totalActualBodyColumnCount);
        const totalWidth = table.getColsWidth(table.frozenColCount, table.colCount - 1);
        table.scenegraph.proxy.xLimitLeft = totalBodyWidth / 2;
        table.scenegraph.proxy.xLimitRight = totalWidth - totalBodyWidth / 2;
    }
    function moveColumnGroup(colGroup, table, direction = 'left') {
        if (direction === 'left') {
            let x;
            const prevCellGroup = getPrevGroup(colGroup);
            if (prevCellGroup) {
                x = prevCellGroup.attribute.x + table.getColWidth(colGroup._prev.col);
            }
            else {
                x = table.getColsWidth(table.frozenColCount, colGroup.col - 1);
            }
            colGroup.setAttribute('x', x);
        }
        else {
            let x;
            const nextCellGroup = getNextGroup(colGroup);
            if (nextCellGroup) {
                x = nextCellGroup.attribute.x - table.getColWidth(colGroup.col);
            }
            else {
                x = table.getColsWidth(table.frozenColCount, colGroup.col - 1);
            }
            colGroup.setAttribute('x', x);
        }
    }

    async function dynamicSetX(x, screenLeft, isEnd, proxy) {
        if (!screenLeft) {
            return;
        }
        const screenLeftCol = screenLeft.col;
        const screenLeftX = screenLeft.left;
        let deltaCol;
        if (isEnd) {
            deltaCol = proxy.bodyRightCol - proxy.colEnd;
        }
        else {
            deltaCol = proxy.screenLeftCol - proxy.referenceCol;
        }
        move$1(deltaCol, screenLeftCol, screenLeftX, x, proxy);
        if (isEnd) {
            const colGroup = proxy.table.scenegraph.getColGroup(proxy.colEnd);
            if (colGroup) {
                const deltaX = colGroup.attribute.x +
                    colGroup.attribute.width -
                    (proxy.table.tableNoFrameWidth - proxy.table.getFrozenColsWidth() - proxy.table.getRightFrozenColsWidth()) -
                    x;
                proxy.deltaX = -deltaX;
                proxy.table.scenegraph.setBodyAndColHeaderX(-x + proxy.deltaX);
            }
        }
        proxy.table.scenegraph.updateNextFrame();
    }
    function move$1(deltaCol, screenLeftCol, screenLeftX, x, proxy) {
        if (deltaCol > 0) {
            moveColumn(deltaCol, 'left', proxy.screenLeftCol, screenLeftX, x, proxy);
            proxy.updateDeltaX(x, screenLeftX, screenLeftCol);
            proxy.table.scenegraph.setBodyAndColHeaderX(-x + proxy.deltaX);
        }
        else if (deltaCol < 0) {
            moveColumn(-deltaCol, 'right', proxy.screenLeftCol, screenLeftX, x, proxy);
            proxy.updateDeltaX(x, screenLeftX, screenLeftCol);
            proxy.table.scenegraph.setBodyAndColHeaderX(-x + proxy.deltaX);
        }
        else {
            proxy.updateDeltaX(x, screenLeftX, screenLeftCol);
            proxy.table.scenegraph.setBodyAndColHeaderX(-x + proxy.deltaX);
        }
    }
    async function moveColumn(count, direction, screenLeftCol, screenLeftX, x, proxy) {
        if (direction === 'left' && proxy.colEnd + count > proxy.bodyRightCol) {
            count = proxy.bodyRightCol - proxy.colEnd;
        }
        else if (direction === 'right' && proxy.colStart - count < proxy.bodyLeftCol) {
            count = proxy.colStart - proxy.bodyLeftCol;
        }
        if (count === 0) {
            return;
        }
        if (count < 0) {
            direction = direction === 'left' ? 'right' : 'left';
            count = -count;
        }
        if (count < proxy.colEnd - proxy.colStart) {
            const startCol = direction === 'left' ? proxy.colStart : proxy.colEnd - count + 1;
            const endCol = direction === 'left' ? proxy.colStart + count - 1 : proxy.colEnd;
            const distStartCol = direction === 'left' ? proxy.colEnd + 1 : proxy.colStart - count;
            const distEndCol = direction === 'left' ? proxy.colEnd + count : proxy.colStart - 1;
            computeColsWidth(proxy.table, distStartCol, distEndCol);
            updatePartColPosition(startCol, endCol, direction, proxy);
            const syncLeftCol = distStartCol;
            const syncRightCol = distEndCol;
            proxy.colStart = direction === 'left' ? proxy.colStart + count : proxy.colStart - count;
            proxy.colEnd = direction === 'left' ? proxy.colEnd + count : proxy.colEnd - count;
            updateColContent(syncLeftCol, syncRightCol, proxy);
            updateAutoColumn(syncLeftCol, syncRightCol, proxy.table, direction);
            const colGroup = proxy.table.scenegraph.getColGroup(screenLeftCol) || proxy.table.scenegraph.getColGroup(screenLeftCol, true);
            const deltaX = screenLeftX - (colGroup.attribute.x + proxy.table.getFrozenColsWidth() + proxy.table.scenegraph.proxy.deltaX);
            proxy.table.scenegraph.proxy.deltaX += deltaX;
            proxy.currentCol = direction === 'left' ? proxy.currentCol + count : proxy.currentCol - count;
            proxy.totalCol = Math.max(0, Math.min(proxy.table.colCount - 1, direction === 'left' ? proxy.totalCol + count : proxy.totalCol - count));
            proxy.referenceCol = proxy.colStart + Math.floor((proxy.colEnd - proxy.colStart) / 2);
            proxy.colUpdatePos = distStartCol;
            proxy.colUpdateDirection = direction;
            proxy.table.scenegraph.updateNextFrame();
        }
        else {
            const distStartCol = direction === 'left' ? proxy.colStart + count : proxy.colStart - count;
            const distEndCol = direction === 'left' ? proxy.colEnd + count : proxy.colEnd - count;
            computeColsWidth(proxy.table, distStartCol, distEndCol);
            const distStartColY = proxy.table.getColsWidth(proxy.bodyLeftCol, distStartCol - 1);
            updateAllColPosition(distStartColY, count, direction, proxy);
            const syncLeftCol = distStartCol;
            const syncRightCol = distEndCol;
            proxy.colStart = distStartCol;
            proxy.colEnd = distEndCol;
            updateColContent(syncLeftCol, syncRightCol, proxy);
            updateAutoColumn(syncLeftCol, syncRightCol, proxy.table, distEndCol > proxy.bodyRightCol - (proxy.colEnd - proxy.colStart + 1) ? 'right' : 'left');
            proxy.currentCol = direction === 'left' ? proxy.currentCol + count : proxy.currentCol - count;
            proxy.totalCol = Math.max(0, Math.min(proxy.table.colCount - 1, direction === 'left' ? proxy.totalCol + count : proxy.totalCol - count));
            proxy.referenceCol = proxy.colStart + Math.floor((proxy.colEnd - proxy.colStart) / 2);
            proxy.colUpdatePos = proxy.colStart;
            proxy.colUpdateDirection = distEndCol > proxy.bodyRightCol - (proxy.colEnd - proxy.colStart + 1) ? 'right' : 'left';
            proxy.table.scenegraph.updateNextFrame();
        }
    }
    function updateColGroupPosition(colGroup, newCol, x) {
        colGroup.col = newCol;
        colGroup.forEachChildren((cellGroup) => {
            cellGroup.col = newCol;
            cellGroup.needUpdate = true;
        });
        colGroup.setAttribute('x', x);
        colGroup.needUpdate = true;
    }
    function updateColGroupContent(colGroup, proxy) {
        if (!colGroup) {
            return;
        }
        let cellGroup = colGroup.firstChild;
        while (cellGroup) {
            const newCellGroup = proxy.updateCellGroupContent(cellGroup);
            cellGroup = newCellGroup._next;
        }
        colGroup.needUpdate = false;
        colGroup.setAttribute('width', proxy.table.getColWidth(colGroup.col));
    }
    function updateColGroupContentAsync(colGroup, proxy) {
        if (!colGroup) {
            return;
        }
        const screenTopRow = proxy.screenTopRow;
        const topRow = Math.max(proxy.bodyTopRow, screenTopRow - proxy.screenRowCount * 1);
        const bottomRow = Math.min(proxy.bodyBottomRow, screenTopRow + proxy.screenRowCount * 2, proxy.table.rowCount - 1);
        for (let row = topRow; row <= bottomRow; row++) {
            const cellGroup = proxy.highPerformanceGetCell(colGroup.col, row, true);
            proxy.updateCellGroupContent(cellGroup);
        }
        proxy.rowUpdatePos = proxy.rowStart;
        colGroup.needUpdate = false;
        colGroup.setAttribute('width', proxy.table.getColWidth(colGroup.col));
    }
    function updatePartColPosition(startCol, endCol, direction, proxy) {
        for (let col = startCol; col <= endCol; col++) {
            if (proxy.table.scenegraph.bodyGroup.childrenCount > 0 &&
                proxy.table.scenegraph.bodyGroup.firstChild.type === 'group') {
                updateColPosition(proxy.table.scenegraph.bodyGroup, direction, proxy);
            }
            if (proxy.table.scenegraph.colHeaderGroup.childrenCount > 0 &&
                proxy.table.scenegraph.colHeaderGroup.firstChild.type === 'group') {
                updateColPosition(proxy.table.scenegraph.colHeaderGroup, direction, proxy);
            }
            if (proxy.table.scenegraph.bottomFrozenGroup.childrenCount > 0 &&
                proxy.table.scenegraph.bottomFrozenGroup.firstChild.type === 'group') {
                updateColPosition(proxy.table.scenegraph.bottomFrozenGroup, direction, proxy);
            }
        }
    }
    function updateColPosition(containerGroup, direction, proxy) {
        if (direction === 'left') {
            const colGroup = getFirstChild(containerGroup);
            const lastChild = getLastChild(containerGroup);
            updateColGroupPosition(colGroup, lastChild.col + 1, lastChild.attribute.x + proxy.table.getColWidth(lastChild.col));
            containerGroup.appendChild(colGroup);
            if (containerGroup.border) {
                containerGroup.appendChild(containerGroup.border);
            }
        }
        else {
            const colGroup = getLastChild(containerGroup);
            const firstChild = getFirstChild(containerGroup);
            updateColGroupPosition(colGroup, firstChild.col - 1, firstChild.attribute.x - proxy.table.getColWidth(firstChild.col - 1));
            containerGroup.insertBefore(colGroup, containerGroup.firstChild);
        }
    }
    function updateColContent(syncLeftCol, syncRightCol, proxy) {
        for (let col = syncLeftCol; col <= syncRightCol; col++) {
            const colHeaderColGroup = proxy.table.scenegraph.getColGroup(col, true);
            colHeaderColGroup && updateColGroupContent(colHeaderColGroup, proxy);
            const bottomColGroup = proxy.table.scenegraph.getColGroupInBottom(col);
            bottomColGroup && updateColGroupContent(bottomColGroup, proxy);
            const rightTopColGroup = proxy.table.scenegraph.getColGroupInRightTopCorner(col);
            rightTopColGroup && updateColGroupContent(rightTopColGroup, proxy);
            const rightBottomColGroup = proxy.table.scenegraph.getColGroupInRightBottomCorner(col);
            rightBottomColGroup && updateColGroupContent(rightBottomColGroup, proxy);
            const colGroup = proxy.table.scenegraph.getColGroup(col);
            colGroup && updateColGroupContentAsync(colGroup, proxy);
        }
        updateColumnContainerWidth(proxy.table.scenegraph.colHeaderGroup);
        updateColumnContainerWidth(proxy.table.scenegraph.bottomFrozenGroup);
        updateColumnContainerWidth(proxy.table.scenegraph.bodyGroup);
        proxy.progress();
    }
    function updateAllColPosition(distStartColY, count, direction, proxy) {
        proxy.table.scenegraph.colHeaderGroup.forEachChildren((colGroup, index) => {
            if (colGroup.type === 'group') {
                updateColGroupPosition(colGroup, direction === 'left' ? colGroup.col + count : colGroup.col - count, index === 0
                    ? distStartColY
                    : colGroup._prev.attribute.x + proxy.table.getColWidth(colGroup._prev.col));
            }
        });
        proxy.table.scenegraph.bottomFrozenGroup.forEachChildren((colGroup, index) => {
            if (colGroup.type === 'group') {
                updateColGroupPosition(colGroup, direction === 'left' ? colGroup.col + count : colGroup.col - count, index === 0
                    ? distStartColY
                    : colGroup._prev.attribute.x + proxy.table.getColWidth(colGroup._prev.col));
            }
        });
        proxy.table.scenegraph.bodyGroup.forEachChildren((colGroup, index) => {
            if (colGroup.type === 'group') {
                updateColGroupPosition(colGroup, direction === 'left' ? colGroup.col + count : colGroup.col - count, index === 0
                    ? distStartColY
                    : colGroup._prev.attribute.x + proxy.table.getColWidth(colGroup._prev.col));
            }
        });
    }
    function updateColumnContainerWidth(containerGroup) {
        const lastColGroup = getLastChild(containerGroup);
        if (!lastColGroup) {
            return;
        }
        containerGroup.setAttribute('width', lastColGroup.attribute.x + lastColGroup.attribute.width);
        if (containerGroup.border) {
            const border = containerGroup.border;
            border.setAttribute('width', lastColGroup.attribute.x +
                lastColGroup.attribute.width -
                (border.attribute.borderLeft ?? 0) / 2 -
                (border.attribute.borderRight ?? 0) / 2);
        }
    }

    function updateAutoRow(colStart, colEnd, rowStart, rowEnd, table, direction = 'up', part) {
        if (direction === 'up') {
            for (let col = colStart; col <= colEnd; col++) {
                for (let row = rowStart; row <= rowEnd; row++) {
                    const cellGroup = table.scenegraph.highPerformanceGetCell(col, row, true);
                    if (cellGroup.role !== 'cell' || !cellGroup.row) {
                        continue;
                    }
                    let y;
                    if (cellGroup._prev) {
                        y = cellGroup._prev?.attribute.y + table.getRowHeight(cellGroup._prev.row);
                    }
                    else if (part) {
                        const baseRowIndex = rowEnd === table.rowCount - table.bottomFrozenRowCount - 1 ? rowEnd : rowEnd + 1;
                        const baseCellGroup = table.scenegraph.highPerformanceGetCell(col, baseRowIndex, true);
                        y = baseCellGroup.attribute.y;
                        if (isValid$3(y)) {
                            for (let r = row; r < baseRowIndex; r++) {
                                y -= table.getRowHeight(r);
                            }
                        }
                    }
                    else {
                        y = getEstimatePosition(cellGroup.row, table);
                    }
                    if (isValid$3(y)) {
                        cellGroup.setAttribute('y', y);
                    }
                }
            }
        }
        else {
            for (let col = colStart; col <= colEnd; col++) {
                for (let row = rowEnd; row >= rowStart; row--) {
                    const cellGroup = table.scenegraph.highPerformanceGetCell(col, row, true);
                    if (cellGroup.role !== 'cell' || !cellGroup.row) {
                        continue;
                    }
                    let y;
                    if (cellGroup._next) {
                        y = cellGroup._next?.attribute.y - table.getRowHeight(cellGroup.row);
                    }
                    else if (part) {
                        const baseRowIndex = rowStart <= table.frozenRowCount ? table.frozenRowCount : rowStart - 1;
                        if (rowStart <= table.frozenRowCount) {
                            y = 0;
                        }
                        else {
                            const baseCellGroup = table.scenegraph.highPerformanceGetCell(col, baseRowIndex, true);
                            y = baseCellGroup.attribute.y;
                        }
                        for (let r = baseRowIndex; r < row; r++) {
                            const height = table.getRowHeight(r);
                            y += height;
                        }
                    }
                    else {
                        y = getEstimatePosition(cellGroup.row, table);
                    }
                    if (isValid$3(y)) {
                        cellGroup.setAttribute('y', y);
                    }
                }
            }
        }
        const totalActualBodyRowCount = Math.min(table.scenegraph.proxy.rowLimit, table.scenegraph.proxy.bodyBottomRow - table.scenegraph.proxy.bodyTopRow + 1);
        const totalBodyHeight = table.getRowsHeight(table.frozenRowCount, table.frozenRowCount + totalActualBodyRowCount);
        const totalHeight = table.getRowsHeight(table.frozenRowCount, table.rowCount - 1);
        table.scenegraph.proxy.yLimitTop = totalBodyHeight / 2;
        table.scenegraph.proxy.yLimitBottom = totalHeight - totalBodyHeight / 2;
    }
    function getEstimatePosition(row, table) {
        let y;
        if (row < table.frozenRowCount) {
            y = table.getRowsHeight(0, row - 1);
        }
        else if (row >= table.rowCount - table.bottomFrozenRowCount) {
            y = table.getRowsHeight(table.rowCount - table.bottomFrozenRowCount, row - 1);
        }
        else {
            y = table.getRowsHeight(table.frozenRowCount, row - 1);
        }
        return y;
    }

    async function dynamicSetY(y, screenTop, isEnd, proxy) {
        if (!screenTop) {
            return;
        }
        const screenTopRow = screenTop.row;
        const screenTopY = screenTop.top;
        let deltaRow;
        if (isEnd) {
            deltaRow = proxy.bodyBottomRow - proxy.rowEnd;
        }
        else {
            deltaRow = screenTopRow - proxy.referenceRow;
        }
        move(deltaRow, screenTopRow, screenTopY, y, proxy);
        if (isEnd) {
            const cellGroup = proxy.table.scenegraph.highPerformanceGetCell(proxy.colStart, proxy.rowEnd, true);
            if (cellGroup.role === 'cell') {
                const deltaY = cellGroup.attribute.y +
                    cellGroup.attribute.height -
                    (proxy.table.tableNoFrameHeight - proxy.table.getFrozenRowsHeight() - proxy.table.getBottomFrozenRowsHeight()) -
                    y;
                proxy.deltaY = -deltaY;
                proxy.updateBody(y - proxy.deltaY);
            }
        }
    }
    function move(deltaRow, screenTopRow, screenTopY, y, proxy) {
        if (deltaRow > 0) {
            moveCell(deltaRow, 'up', screenTopRow, screenTopY, y, proxy);
            proxy.updateDeltaY(y, screenTopY, screenTopRow);
            proxy.updateBody(y - proxy.deltaY);
        }
        else if (deltaRow < 0) {
            moveCell(-deltaRow, 'down', screenTopRow, screenTopY, y, proxy);
            proxy.updateDeltaY(y, screenTopY, screenTopRow);
            proxy.updateBody(y - proxy.deltaY);
        }
        else {
            proxy.updateDeltaY(y, screenTopY, screenTopRow);
            proxy.updateBody(y - proxy.deltaY);
        }
    }
    async function moveCell(count, direction, screenTopRow, screenTopY, y, proxy) {
        if (direction === 'up' && proxy.rowEnd + count > proxy.bodyBottomRow) {
            count = proxy.bodyBottomRow - proxy.rowEnd;
        }
        else if (direction === 'down' && proxy.rowStart - count < proxy.bodyTopRow) {
            count = proxy.rowStart - proxy.bodyTopRow;
        }
        if (count === 0) {
            return;
        }
        if (count < 0) {
            direction = direction === 'up' ? 'down' : 'up';
            count = -count;
        }
        if (count < proxy.rowEnd - proxy.rowStart) {
            const startRow = direction === 'up' ? proxy.rowStart : proxy.rowEnd - count + 1;
            const endRow = direction === 'up' ? proxy.rowStart + count - 1 : proxy.rowEnd;
            const distStartRow = direction === 'up' ? proxy.rowEnd + 1 : proxy.rowStart - count;
            const distEndRow = direction === 'up' ? proxy.rowEnd + count : proxy.rowStart - 1;
            let syncTopRow;
            let syncBottomRow;
            if (proxy.table.isAutoRowHeight(startRow)) {
                syncTopRow = distStartRow;
                syncBottomRow = distEndRow;
            }
            else {
                const topRow = Math.max(proxy.bodyTopRow, screenTopRow - proxy.screenRowCount * 1);
                const bottomRow = Math.min(proxy.bodyBottomRow, screenTopRow + proxy.screenRowCount * 2, proxy.table.rowCount - 1);
                syncTopRow = topRow;
                syncBottomRow = bottomRow;
            }
            computeRowsHeight(proxy.table, syncTopRow, syncBottomRow, false);
            updatePartRowPosition(startRow, endRow, direction, proxy);
            proxy.rowStart = direction === 'up' ? proxy.rowStart + count : proxy.rowStart - count;
            proxy.rowEnd = direction === 'up' ? proxy.rowEnd + count : proxy.rowEnd - count;
            const sync = updateRowContent(syncTopRow, syncBottomRow, proxy, true);
            if (proxy.table.isAutoRowHeight(startRow)) {
                updateAutoRow(proxy.bodyLeftCol, proxy.bodyRightCol, syncTopRow, syncBottomRow, proxy.table, distEndRow > proxy.bodyBottomRow - (proxy.rowEnd - proxy.rowStart + 1) ? 'down' : 'up', true);
                updateAutoRow(0, proxy.table.frozenColCount - 1, syncTopRow, syncBottomRow, proxy.table, distEndRow > proxy.bodyBottomRow - (proxy.rowEnd - proxy.rowStart + 1) ? 'down' : 'up', true);
                updateAutoRow(proxy.table.colCount - proxy.table.rightFrozenColCount, proxy.table.colCount - 1, syncTopRow, syncBottomRow, proxy.table, distEndRow > proxy.bodyBottomRow - (proxy.rowEnd - proxy.rowStart + 1) ? 'down' : 'up', true);
            }
            proxy.currentRow = direction === 'up' ? proxy.currentRow + count : proxy.currentRow - count;
            proxy.totalRow = Math.max(0, Math.min(proxy.bodyBottomRow, direction === 'up' ? proxy.totalRow + count : proxy.totalRow - count, proxy.table.rowCount - 1));
            proxy.referenceRow = proxy.rowStart + Math.floor((proxy.rowEnd - proxy.rowStart) / 2);
            if (proxy.table.isAutoRowHeight(startRow) && sync) {
                proxy.rowUpdatePos = Math.min(proxy.rowUpdatePos, proxy.rowEnd + 1);
            }
            else {
                proxy.rowUpdatePos = Math.min(proxy.rowUpdatePos, distStartRow);
            }
            proxy.rowUpdateDirection = direction;
            proxy.table.scenegraph.updateNextFrame();
            await proxy.progress();
        }
        else {
            const distStartRow = direction === 'up' ? proxy.rowStart + count : proxy.rowStart - count;
            const distEndRow = Math.min(proxy.table.rowCount - 1, direction === 'up' ? proxy.rowEnd + count : proxy.rowEnd - count);
            const distStartRowY = proxy.table.getRowsHeight(proxy.bodyTopRow, distStartRow - 1);
            let syncTopRow;
            let syncBottomRow;
            if (proxy.table.isAutoRowHeight(distStartRow)) {
                syncTopRow = distStartRow;
                syncBottomRow = distEndRow;
            }
            else {
                syncTopRow = Math.max(proxy.bodyTopRow, screenTopRow - proxy.screenRowCount * 1);
                syncBottomRow = Math.min(proxy.bodyBottomRow, screenTopRow + proxy.screenRowCount * 2, proxy.table.rowCount - 1);
            }
            computeRowsHeight(proxy.table, syncTopRow, syncBottomRow, false);
            updateAllRowPosition(distStartRowY, count, direction, proxy);
            proxy.rowStart = distStartRow;
            proxy.rowEnd = distEndRow;
            const sync = updateRowContent(syncTopRow, syncBottomRow, proxy, true);
            if (proxy.table.isAutoRowHeight(distStartRow)) {
                updateAutoRow(proxy.bodyLeftCol, proxy.bodyRightCol, syncTopRow, syncBottomRow, proxy.table, distEndRow > proxy.bodyBottomRow - (proxy.rowEnd - proxy.rowStart + 1) ? 'down' : 'up');
                updateAutoRow(0, proxy.table.frozenColCount - 1, syncTopRow, syncBottomRow, proxy.table, distEndRow > proxy.bodyBottomRow - (proxy.rowEnd - proxy.rowStart + 1) ? 'down' : 'up');
                updateAutoRow(proxy.table.colCount - proxy.table.rightFrozenColCount, proxy.table.colCount - 1, syncTopRow, syncBottomRow, proxy.table, distEndRow > proxy.bodyBottomRow - (proxy.rowEnd - proxy.rowStart + 1) ? 'down' : 'up');
            }
            proxy.currentRow = direction === 'up' ? proxy.currentRow + count : proxy.currentRow - count;
            proxy.totalRow = Math.max(0, Math.min(proxy.bodyBottomRow, direction === 'up' ? proxy.totalRow + count : proxy.totalRow - count, proxy.table.rowCount - 1));
            proxy.referenceRow = proxy.rowStart + Math.floor((proxy.rowEnd - proxy.rowStart) / 2);
            if (proxy.table.isAutoRowHeight(distStartRow) && sync) {
                proxy.rowUpdatePos = proxy.rowEnd + 1;
            }
            else {
                proxy.rowUpdatePos = proxy.rowStart;
            }
            proxy.rowUpdateDirection = distEndRow > proxy.bodyBottomRow - (proxy.rowEnd - proxy.rowStart + 1) ? 'down' : 'up';
            proxy.table.scenegraph.updateNextFrame();
            await proxy.progress();
        }
    }
    function updatePartRowPosition(startRow, endRow, direction, proxy) {
        for (let col = 0; col < proxy.table.frozenColCount; col++) {
            const colGroup = proxy.table.scenegraph.getColGroup(col);
            if (!colGroup) {
                continue;
            }
            for (let row = startRow; row <= endRow; row++) {
                updateCellGroupPosition(colGroup, direction, proxy);
            }
        }
        for (let col = proxy.table.colCount - proxy.table.rightFrozenColCount; col < proxy.table.colCount; col++) {
            const colGroup = proxy.table.scenegraph.getColGroup(col);
            if (!colGroup) {
                continue;
            }
            for (let row = startRow; row <= endRow; row++) {
                updateCellGroupPosition(colGroup, direction, proxy);
            }
        }
        for (let col = proxy.bodyLeftCol; col <= proxy.bodyRightCol; col++) {
            const colGroup = proxy.table.scenegraph.getColGroup(col);
            if (colGroup) {
                for (let row = startRow; row <= endRow; row++) {
                    updateCellGroupPosition(colGroup, direction, proxy);
                }
            }
        }
    }
    function updateCellGroupPosition(colGroup, direction, proxy) {
        if (colGroup.childrenCount >= 1) {
            if (direction === 'up') {
                const cellGroup = colGroup.firstChild;
                proxy.updateCellGroupPosition(cellGroup, colGroup.lastChild.row + 1, colGroup.lastChild.attribute.y + proxy.table.getRowHeight(colGroup.lastChild.row));
                colGroup.appendChild(cellGroup);
            }
            else {
                const cellGroup = colGroup.lastChild;
                proxy.updateCellGroupPosition(cellGroup, colGroup.firstChild.row - 1, colGroup.firstChild.attribute.y - proxy.table.getRowHeight(cellGroup.row));
                colGroup.insertBefore(cellGroup, colGroup.firstChild);
            }
        }
    }
    function updateAllRowPosition(distStartRowY, count, direction, proxy) {
        for (let col = 0; col < proxy.table.frozenColCount; col++) {
            const colGroup = proxy.table.scenegraph.getColGroup(col);
            colGroup?.forEachChildren((cellGroup, index) => {
                proxy.updateCellGroupPosition(cellGroup, direction === 'up' ? cellGroup.row + count : cellGroup.row - count, index === 0
                    ? distStartRowY
                    : cellGroup._prev.attribute.y + proxy.table.getRowHeight(cellGroup._prev.row));
            });
        }
        for (let col = proxy.table.colCount - proxy.table.rightFrozenColCount; col < proxy.table.colCount; col++) {
            const colGroup = proxy.table.scenegraph.getColGroup(col);
            colGroup?.forEachChildren((cellGroup, index) => {
                proxy.updateCellGroupPosition(cellGroup, direction === 'up' ? cellGroup.row + count : cellGroup.row - count, index === 0
                    ? distStartRowY
                    : cellGroup._prev.attribute.y + proxy.table.getRowHeight(cellGroup._prev.row));
            });
        }
        for (let col = proxy.bodyLeftCol; col <= proxy.bodyRightCol; col++) {
            const colGroup = proxy.table.scenegraph.getColGroup(col);
            colGroup?.forEachChildren((cellGroup, index) => {
                proxy.updateCellGroupPosition(cellGroup, direction === 'up' ? cellGroup.row + count : cellGroup.row - count, index === 0
                    ? distStartRowY
                    : cellGroup._prev.attribute.y + proxy.table.getRowHeight(cellGroup._prev.row));
            });
        }
    }
    function updateRowContent(syncTopRow, syncBottomRow, proxy, async = false) {
        for (let col = 0; col < proxy.table.frozenColCount; col++) {
            for (let row = syncTopRow; row <= syncBottomRow; row++) {
                const cellGroup = proxy.highPerformanceGetCell(col, row, true);
                proxy.updateCellGroupContent(cellGroup);
            }
        }
        for (let col = proxy.table.colCount - proxy.table.rightFrozenColCount; col < proxy.table.colCount; col++) {
            for (let row = syncTopRow; row <= syncBottomRow; row++) {
                const cellGroup = proxy.highPerformanceGetCell(col, row);
                proxy.updateCellGroupContent(cellGroup);
            }
        }
        let leftCol = proxy.bodyLeftCol;
        let rightCol = proxy.bodyRightCol;
        let sync = true;
        if (async) {
            const screenLeftCol = proxy.screenLeftCol;
            leftCol = Math.max(proxy.bodyLeftCol, screenLeftCol - proxy.screenColCount * 1);
            rightCol = Math.min(proxy.bodyRightCol, screenLeftCol + proxy.screenColCount * 2);
            if (leftCol !== proxy.bodyLeftCol || rightCol !== proxy.bodyRightCol) {
                sync = false;
            }
        }
        for (let col = leftCol; col <= rightCol; col++) {
            for (let row = syncTopRow; row <= syncBottomRow; row++) {
                const cellGroup = proxy.highPerformanceGetCell(col, row);
                proxy.updateCellGroupContent(cellGroup);
            }
        }
        updateColumnContainerHeight(proxy.table.scenegraph.rowHeaderGroup);
        updateColumnContainerHeight(proxy.table.scenegraph.rightFrozenGroup);
        updateColumnContainerHeight(proxy.table.scenegraph.bodyGroup);
        proxy.table.scenegraph.updateNextFrame();
        return sync;
    }
    function updateColumnContainerHeight(containerGroup) {
        const lastColGroup = getLastChild(containerGroup);
        if (!lastColGroup) {
            return;
        }
        const lastCellGroup = getLastChild(lastColGroup);
        if (!lastCellGroup) {
            return;
        }
        containerGroup.setAttribute('height', lastCellGroup.attribute.y + lastCellGroup.attribute.height);
        if (containerGroup.border) {
            const border = containerGroup.border;
            border.setAttribute('height', lastCellGroup.attribute.y +
                lastCellGroup.attribute.height -
                (border.attribute.borderTop ?? 0) / 2 -
                (border.attribute.borderBottom ?? 0) / 2);
        }
    }

    async function sortVertical(proxy) {
        proxy.table.scenegraph.bodyGroup.forEachChildren((colGroup, index) => {
            if (colGroup.type === 'group') {
                colGroup.needUpdate = true;
                colGroup?.forEachChildren((cellGroup) => {
                    cellGroup.needUpdate = true;
                });
            }
        });
        let syncTopRow;
        let syncBottomRow;
        if (proxy.table.isAutoRowHeight(proxy.rowStart)) {
            syncTopRow = proxy.rowStart;
            syncBottomRow = proxy.rowEnd;
        }
        else {
            syncTopRow = Math.max(proxy.bodyTopRow, proxy.screenTopRow - proxy.screenRowCount * 1);
            syncBottomRow = Math.min(proxy.bodyBottomRow, proxy.screenTopRow + proxy.screenRowCount * 2, proxy.table.rowCount - 1);
        }
        const oldBodyHeight = proxy.table.getAllRowsHeight();
        computeRowsHeight(proxy.table, syncTopRow, syncBottomRow);
        const newBodyHeight = proxy.table.getAllRowsHeight();
        if (oldBodyHeight !== newBodyHeight) {
            proxy.table.scenegraph.updateContainerHeight(proxy.table.frozenRowCount, newBodyHeight - oldBodyHeight);
        }
        for (let col = 0; col < (proxy.table.frozenColCount ?? 0); col++) {
            const columnGroup = proxy.table.scenegraph.getColGroup(col);
            columnGroup?.setAttribute('chartInstance', undefined);
            for (let row = proxy.rowStart; row <= proxy.rowEnd; row++) {
                proxy.table.scenegraph.updateCellContent(col, row);
            }
            for (let row = proxy.table.rowCount - proxy.table.bottomFrozenRowCount; row < proxy.table.rowCount; row++) {
                proxy.table.scenegraph.updateCellContent(col, row);
            }
        }
        for (let col = proxy.colStart; col <= proxy.colEnd; col++) {
            const columnGroup = proxy.table.scenegraph.getColGroup(col);
            columnGroup?.setAttribute('chartInstance', undefined);
            for (let row = proxy.table.rowCount - proxy.table.bottomFrozenRowCount; row < proxy.table.rowCount; row++) {
                proxy.table.scenegraph.updateCellContent(col, row);
            }
        }
        for (let col = proxy.table.colCount - proxy.table.rightFrozenColCount; col < proxy.table.colCount; col++) {
            const columnGroup = proxy.table.scenegraph.getColGroup(col);
            columnGroup?.setAttribute('chartInstance', undefined);
            for (let row = proxy.rowStart; row <= proxy.rowEnd; row++) {
                proxy.table.scenegraph.updateCellContent(col, row);
            }
            for (let row = proxy.table.rowCount - proxy.table.bottomFrozenRowCount; row < proxy.table.rowCount; row++) {
                proxy.table.scenegraph.updateCellContent(col, row);
            }
        }
        updateRowContent(syncTopRow, syncBottomRow, proxy);
        if (proxy.table.isAutoRowHeight(syncTopRow)) {
            updateAutoRow(proxy.bodyLeftCol, proxy.bodyRightCol, syncTopRow, syncBottomRow, proxy.table, proxy.rowEnd > proxy.bodyBottomRow - (proxy.rowEnd - proxy.rowStart + 1) ? 'down' : 'up');
        }
        proxy.rowUpdatePos = proxy.rowStart;
        proxy.rowUpdateDirection = proxy.rowEnd > proxy.bodyBottomRow - (proxy.rowEnd - proxy.rowStart + 1) ? 'down' : 'up';
        proxy.table.scenegraph.updateNextFrame();
        if (!proxy.table.isAutoRowHeight(proxy.rowStart)) {
            await proxy.progress();
        }
    }

    async function sortHorizontal(proxy) {
        proxy.table.scenegraph.bodyGroup.forEachChildren((colGroup, index) => {
            if (colGroup.type === 'group') {
                colGroup.needUpdate = true;
                colGroup?.forEachChildren((cellGroup) => {
                    cellGroup.needUpdate = true;
                });
            }
        });
        const syncLeftCol = Math.max(proxy.bodyLeftCol, proxy.screenLeftCol - proxy.screenColCount * 1);
        const syncRightCol = Math.min(proxy.bodyRightCol, proxy.screenLeftCol + proxy.screenColCount * 2);
        computeColsWidth(proxy.table, syncLeftCol, syncRightCol);
        for (let col = proxy.colStart; col <= proxy.colEnd; col++) {
            const columnGroup = proxy.table.scenegraph.getColGroup(col);
            columnGroup?.setAttribute('chartInstance', undefined);
            for (let row = proxy.table.rowCount - proxy.table.bottomFrozenRowCount; row < proxy.table.rowCount; row++) {
                proxy.table.scenegraph.updateCellContent(col, row);
            }
        }
        for (let col = proxy.table.colCount - proxy.table.rightFrozenColCount; col < proxy.table.colCount; col++) {
            const columnGroup = proxy.table.scenegraph.getColGroup(col);
            columnGroup?.setAttribute('chartInstance', undefined);
            for (let row = proxy.rowStart; row <= proxy.rowEnd; row++) {
                proxy.table.scenegraph.updateCellContent(col, row);
            }
            for (let row = proxy.table.rowCount - proxy.table.bottomFrozenRowCount; row < proxy.table.rowCount; row++) {
                proxy.table.scenegraph.updateCellContent(col, row);
            }
        }
        updateColContent(syncLeftCol, syncRightCol, proxy);
        proxy.colUpdatePos = proxy.colStart;
        proxy.colUpdateDirection = proxy.colEnd > proxy.bodyRightCol - (proxy.colEnd - proxy.colStart + 1) ? 'right' : 'left';
        proxy.table.scenegraph.updateNextFrame();
        await proxy.progress();
    }

    function resetTextStick(table) {
        const { changedCells } = table.internalProps.stick;
        changedCells.forEach((cellPos) => {
            const cellGroup = table.scenegraph.getCell(cellPos.col, cellPos.row);
            cellGroup.forEachChildren((child) => {
                child.setAttributes({
                    dx: cellPos.dx,
                    dy: cellPos.dy
                });
            });
        });
        changedCells.clear();
        return changedCells;
    }
    function handleTextStick(table) {
        const changedCells = resetTextStick(table);
        const { scrollTop, scrollLeft, frozenRowCount, frozenColCount } = table;
        const frozenRowsHeight = table.getFrozenRowsHeight();
        const frozenColsWidth = table.getFrozenColsWidth();
        const { row: rowTop } = table.getRowAt(scrollTop + frozenRowsHeight + 1);
        const { col: colLeft } = table.getColAt(scrollLeft + frozenColsWidth + 1);
        const rowStart = Math.max(rowTop, table.frozenRowCount);
        const colStart = Math.max(colLeft, table.frozenColCount);
        const rowEnd = table.getAllRowsHeight() > table.tableNoFrameHeight
            ? table.getRowAt(scrollTop + table.tableNoFrameHeight - table.getBottomFrozenRowsHeight() - 1).row
            : table.rowCount - table.bottomFrozenRowCount - 1;
        const colEnd = table.getAllColsWidth() > table.tableNoFrameWidth
            ? table.getColAt(scrollLeft + table.tableNoFrameWidth - table.getRightFrozenColsWidth() - 1).col
            : table.colCount - table.rightFrozenColCount - 1;
        if (colEnd < 0 || rowEnd < 0) {
            return;
        }
        for (let row = 0; row < frozenRowCount; row++) {
            if (colEnd < colStart) {
                break;
            }
            [colStart, colEnd].forEach((col) => {
                const style = table._getCellStyle(col, row);
                if (style?.textStick && style?.textStick !== 'vertical') {
                    const cellGroup = table.scenegraph.getCell(col, row);
                    adjustCellContentHorizontalLayout(cellGroup, frozenColsWidth + table.tableX, table.tableNoFrameWidth - table.getRightFrozenColsWidth() + table.tableX, changedCells, style?.textStickBaseOnAlign, table);
                }
            });
        }
        for (let col = 0; col < frozenColCount; col++) {
            if (rowEnd < rowStart) {
                break;
            }
            [rowStart, rowEnd].forEach((row) => {
                const style = table._getCellStyle(col, row);
                if (style?.textStick &&
                    style?.textStick !== 'horizontal') {
                    const cellGroup = table.scenegraph.getCell(col, row);
                    adjustCellContentVerticalLayout(cellGroup, frozenRowsHeight + table.tableY, table.tableNoFrameHeight - table.getBottomFrozenRowsHeight() + table.tableY, changedCells, style?.textStickBaseOnAlign, table);
                }
            });
        }
        for (let col = colStart; col <= colEnd; col++) {
            if (rowEnd < rowStart) {
                break;
            }
            [rowStart, rowEnd].forEach((row) => {
                const style = table._getCellStyle(col, row);
                if (style?.textStick && style?.textStick !== 'horizontal') {
                    const cellGroup = table.scenegraph.getCell(col, row);
                    adjustCellContentVerticalLayout(cellGroup, frozenRowsHeight + table.tableY, table.tableNoFrameHeight - table.getBottomFrozenRowsHeight() + table.tableY, changedCells, style?.textStickBaseOnAlign, table);
                }
            });
        }
        for (let row = rowStart; row <= rowEnd; row++) {
            if (colEnd < colStart) {
                break;
            }
            [colStart, colEnd].forEach((col) => {
                const style = table._getCellStyle(col, row);
                if (style?.textStick && style?.textStick !== 'vertical') {
                    const cellGroup = table.scenegraph.getCell(col, row);
                    adjustCellContentHorizontalLayout(cellGroup, frozenColsWidth + table.tableX, table.tableNoFrameWidth - table.getRightFrozenColsWidth() + table.tableX, changedCells, style?.textStickBaseOnAlign, table);
                }
            });
        }
    }
    function adjustCellContentVerticalLayout(cellGroup, minTop, maxTop, changedCells, textStickBaseOnAlign, table) {
        if (isNumber$4(cellGroup.mergeStartCol) &&
            isNumber$4(cellGroup.mergeStartRow) &&
            isNumber$4(cellGroup.mergeEndCol) &&
            isNumber$4(cellGroup.mergeEndRow)) {
            const { colStart, colEnd, rowStart, rowEnd } = getCellMergeRange(cellGroup, table.scenegraph);
            for (let col = colStart; col <= colEnd; col++) {
                for (let row = rowStart; row <= rowEnd; row++) {
                    const singleCellGroup = table.scenegraph.getCell(col, row);
                    if (singleCellGroup.role !== 'cell') {
                        continue;
                    }
                    dealVertical(singleCellGroup, minTop, maxTop, changedCells, textStickBaseOnAlign);
                }
            }
        }
        else {
            dealVertical(cellGroup, minTop, maxTop, changedCells, textStickBaseOnAlign);
        }
    }
    function dealVertical(cellGroup, minTop, maxTop, changedCells, textStickBaseOnAlign) {
        const graphic = cellGroup.getChildByName('text', true) || cellGroup.getChildByName('image', true);
        if (!graphic) {
            return;
        }
        if (graphic.type === 'image') {
            const { image: url } = graphic.attribute;
            if (!url || !graphic.resources) {
                return;
            }
            const res = graphic.resources.get(url);
            if (res.state !== 'success') {
                return;
            }
        }
        const textBaseline = graphic.textBaseline ?? 'top';
        graphic.AABBBounds.width();
        const textTop = graphic.globalAABBBounds.y1;
        const textBottom = graphic.globalAABBBounds.y2;
        if (textBaseline === 'middle' && textStickBaseOnAlign) {
            const cellTop = cellGroup.globalAABBBounds.y1 + (cellGroup.firstChild?.attribute.dy ?? 0);
            const cellBottom = cellTop + (cellGroup.contentHeight ?? cellGroup.attribute.height ?? 0);
            if (cellTop < minTop || cellBottom > maxTop) {
                const visibleCellTop = Math.max(cellTop, minTop);
                const visibleCellBottom = Math.min(cellBottom, maxTop);
                const delta = graphic.globalTransMatrix.f - (visibleCellBottom + visibleCellTop) / 2 + graphic.AABBBounds.height() / 2;
                !changedCells.has(`${cellGroup.col}-${cellGroup.row}`) &&
                    changedCells.set(`${cellGroup.col}-${cellGroup.row}`, {
                        col: cellGroup.col,
                        row: cellGroup.row,
                        dx: cellGroup.firstChild?.attribute.dx ?? 0,
                        dy: cellGroup.firstChild?.attribute.dy ?? 0
                    });
                cellGroup.forEachChildren((child) => {
                    child.setAttribute('dy', (child.attribute.dy ?? 0) - delta + 2);
                });
            }
        }
        else if (textTop < minTop) {
            const deltaHeight = textTop - minTop;
            !changedCells.has(`${cellGroup.col}-${cellGroup.row}`) &&
                changedCells.set(`${cellGroup.col}-${cellGroup.row}`, {
                    col: cellGroup.col,
                    row: cellGroup.row,
                    dx: cellGroup.firstChild?.attribute.dx ?? 0,
                    dy: cellGroup.firstChild?.attribute.dy ?? 0
                });
            cellGroup.forEachChildren((child) => {
                child.setAttribute('dy', (child.attribute.dy ?? 0) - deltaHeight + 2);
            });
        }
        else if (textBottom > maxTop) {
            const deltaHeight = textBottom - maxTop;
            !changedCells.has(`${cellGroup.col}-${cellGroup.row}`) &&
                changedCells.set(`${cellGroup.col}-${cellGroup.row}`, {
                    col: cellGroup.col,
                    row: cellGroup.row,
                    dx: cellGroup.firstChild?.attribute.dx ?? 0,
                    dy: cellGroup.firstChild?.attribute.dy ?? 0
                });
            cellGroup.forEachChildren((child) => {
                child.setAttribute('dy', (child.attribute.dy ?? 0) - deltaHeight);
            });
        }
    }
    function adjustCellContentHorizontalLayout(cellGroup, minLeft, maxLeft, changedCells, textStickBaseOnAlign, table) {
        if (isNumber$4(cellGroup.mergeStartCol) &&
            isNumber$4(cellGroup.mergeStartRow) &&
            isNumber$4(cellGroup.mergeEndCol) &&
            isNumber$4(cellGroup.mergeEndRow)) {
            const { colStart, colEnd, rowStart, rowEnd } = getCellMergeRange(cellGroup, table.scenegraph);
            for (let col = colStart; col <= colEnd; col++) {
                for (let row = rowStart; row <= rowEnd; row++) {
                    const singleCellGroup = table.scenegraph.getCell(col, row);
                    if (singleCellGroup.role !== 'cell') {
                        continue;
                    }
                    dealHorizontal(singleCellGroup, minLeft, maxLeft, changedCells, textStickBaseOnAlign);
                }
            }
        }
        else {
            dealHorizontal(cellGroup, minLeft, maxLeft, changedCells, textStickBaseOnAlign);
        }
    }
    function dealHorizontal(cellGroup, minLeft, maxLeft, changedCells, textStickBaseOnAlign) {
        const graphic = cellGroup.getChildByName('text', true) || cellGroup.getChildByName('image', true);
        if (!graphic) {
            return;
        }
        if (graphic.type === 'image') {
            const { image: url } = graphic.attribute;
            if (!url || !graphic.resources) {
                return;
            }
            const res = graphic.resources.get(url);
            if (res.state !== 'success') {
                return;
            }
        }
        const textAlign = graphic.attribute.textAlign ?? graphic.textAlign ?? 'left';
        graphic.AABBBounds.width();
        const textLeft = graphic.globalAABBBounds.x1;
        const textRight = graphic.globalAABBBounds.x2;
        if (textAlign === 'center' && textStickBaseOnAlign) {
            const cellLeft = cellGroup.globalAABBBounds.x1 + (cellGroup.firstChild?.attribute.dx ?? 0);
            const cellRight = cellLeft + (cellGroup.contentWidth ?? cellGroup.attribute.width ?? 0);
            if (cellLeft < minLeft || cellRight > maxLeft) {
                const visibleCellLeft = Math.max(cellLeft, minLeft);
                const visibleCellRight = Math.min(cellRight, maxLeft);
                const delta = graphic.globalTransMatrix.e - (visibleCellRight + visibleCellLeft) / 2;
                !changedCells.has(`${cellGroup.col}-${cellGroup.row}`) &&
                    changedCells.set(`${cellGroup.col}-${cellGroup.row}`, {
                        col: cellGroup.col,
                        row: cellGroup.row,
                        dx: cellGroup.firstChild?.attribute.dx ?? 0,
                        dy: cellGroup.firstChild?.attribute.dy ?? 0
                    });
                cellGroup.forEachChildren((child) => {
                    child.setAttribute('dx', (child.attribute.dx ?? 0) - delta + 2);
                });
            }
        }
        else if (textLeft < minLeft) {
            const deltaWidth = textLeft - minLeft;
            !changedCells.has(`${cellGroup.col}-${cellGroup.row}`) &&
                changedCells.set(`${cellGroup.col}-${cellGroup.row}`, {
                    col: cellGroup.col,
                    row: cellGroup.row,
                    dx: cellGroup.firstChild?.attribute.dx ?? 0,
                    dy: cellGroup.firstChild?.attribute.dy ?? 0
                });
            cellGroup.forEachChildren((child) => {
                child.setAttribute('dx', (child.attribute.dx ?? 0) - deltaWidth + 2);
            });
        }
        else if (textRight > maxLeft) {
            const deltaWidth = textRight - maxLeft;
            !changedCells.has(`${cellGroup.col}-${cellGroup.row}`) &&
                changedCells.set(`${cellGroup.col}-${cellGroup.row}`, {
                    col: cellGroup.col,
                    row: cellGroup.row,
                    dx: cellGroup.firstChild?.attribute.dx ?? 0,
                    dy: cellGroup.firstChild?.attribute.dy ?? 0
                });
            cellGroup.forEachChildren((child) => {
                child.setAttribute('dx', (child.attribute.dx ?? 0) - deltaWidth);
            });
        }
    }
    function checkHaveTextStick(table) {
        const headerObjects = table.internalProps.layoutMap.headerObjects;
        const columnObjects = table.internalProps.layoutMap.columnObjects;
        for (let i = 0; i < headerObjects.length; i++) {
            const header = headerObjects[i];
            if (header && header.style?.textStick) {
                return true;
            }
        }
        for (let i = 0; i < columnObjects.length; i++) {
            const column = columnObjects[i];
            if (column && column.style?.textStick) {
                return true;
            }
        }
        const themeStick = table.theme.headerStyle.textStick || table.theme.rowHeaderStyle.textStick || table.theme.bodyStyle.textStick;
        if (themeStick) {
            return true;
        }
        return false;
    }

    class SceneProxy {
        table;
        isRelease = false;
        mode = 'column';
        isProgressing;
        rowLimit = 200;
        currentRow = 0;
        totalRow;
        yLimitTop;
        yLimitBottom;
        rowStart = 0;
        rowEnd = 0;
        referenceRow = 0;
        bodyBottomRow;
        screenRowCount;
        firstScreenRowLimit;
        taskRowCount;
        rowUpdatePos;
        rowUpdateDirection;
        screenTopRow = 0;
        totalActualBodyRowCount;
        deltaY = 0;
        deltaHeight = 0;
        colLimit = 100;
        bodyRightCol;
        totalCol;
        colStart;
        colEnd;
        taskColCount;
        xLimitLeft;
        xLimitRight;
        screenColCount;
        firstScreenColLimit;
        colUpdatePos;
        currentCol;
        referenceCol;
        screenLeftCol = 0;
        colUpdateDirection;
        totalActualBodyColCount;
        deltaX = 0;
        deltaWidth = 0;
        cellCache = new Map();
        constructor(table) {
            this.table = table;
            if (this.table.isPivotChart()) {
                this.rowLimit = Math.max(100, Math.ceil((table.tableNoFrameHeight * 2) / table.defaultRowHeight));
                this.colLimit = Math.max(100, Math.ceil((table.tableNoFrameWidth * 2) / table.defaultColWidth));
            }
            else if (this.table.isAutoRowHeight(table.columnHeaderLevelCount)) {
                this.rowLimit = Math.max(100, Math.ceil((table.tableNoFrameHeight * 2) / table.defaultRowHeight));
            }
            else if (this.table.widthMode === 'autoWidth') {
                this.colLimit = Math.max(100, Math.ceil((table.tableNoFrameWidth * 2) / table.defaultColWidth));
            }
            else {
                this.rowLimit = Math.max(200, Math.ceil((table.tableNoFrameHeight * 2) / table.defaultRowHeight));
                this.colLimit = Math.max(100, Math.ceil((table.tableNoFrameWidth * 2) / table.defaultColWidth));
            }
            if (this.table.internalProps.transpose) {
                this.mode = 'row';
            }
            else if (this.table.isPivotTable()) {
                this.mode = 'pivot';
            }
            if (this.table.options.maintainedDataCount) {
                this.rowLimit = this.table.options.maintainedDataCount;
            }
            if (this.table.options.maintainedColumnCount) {
                this.colLimit = this.table.options.maintainedColumnCount;
            }
            if (this.table.heightMode === 'adaptive') {
                this.rowLimit = this.table.rowCount;
            }
            if (this.table.widthMode === 'adaptive') {
                this.colLimit = this.table.colCount;
            }
        }
        get bodyLeftCol() {
            return this.table.frozenColCount;
        }
        get bodyTopRow() {
            return this.table.frozenRowCount;
        }
        setParamsForColumn() {
            this.bodyRightCol = this.table.colCount - 1 - this.table.rightFrozenColCount;
            const totalActualBodyColCount = Math.min(this.colLimit, this.bodyRightCol - this.bodyLeftCol + 1);
            this.totalActualBodyColCount = totalActualBodyColCount;
            this.totalCol = this.bodyLeftCol + totalActualBodyColCount - 1;
            this.colStart = this.bodyLeftCol;
            this.colEnd = this.totalCol;
            const defaultColWidth = this.table.defaultColWidth;
            this.taskColCount = Math.ceil(this.table.tableNoFrameWidth / defaultColWidth) * 1;
            const totalBodyWidth = defaultColWidth * totalActualBodyColCount;
            const totalWidth = defaultColWidth * (this.bodyRightCol - this.bodyLeftCol + 1);
            this.xLimitLeft = totalBodyWidth / 2;
            this.xLimitRight = totalWidth - totalBodyWidth / 2;
            const widthLimit = this.table.tableNoFrameWidth * 5;
            this.screenColCount = Math.ceil(this.table.tableNoFrameWidth / defaultColWidth);
            this.firstScreenColLimit = Math.max(15, this.bodyLeftCol + Math.min(this.colLimit, Math.ceil(widthLimit / defaultColWidth)));
            this.colUpdatePos = this.bodyRightCol;
        }
        setParamsForRow() {
            this.bodyBottomRow = this.table.rowCount - 1 - this.table.bottomFrozenRowCount;
            const totalActualBodyRowCount = Math.min(this.rowLimit, this.bodyBottomRow - this.bodyTopRow + 1);
            this.totalActualBodyRowCount = totalActualBodyRowCount;
            this.totalRow = this.bodyTopRow + totalActualBodyRowCount - 1;
            this.rowStart = this.bodyTopRow;
            this.rowEnd = this.totalRow;
            const defaultRowHeight = this.table.defaultRowHeight;
            this.taskRowCount = Math.ceil(this.table.tableNoFrameHeight / defaultRowHeight) * 1;
            const totalBodyHeight = defaultRowHeight * totalActualBodyRowCount;
            const totalHeight = defaultRowHeight * (this.bodyBottomRow - this.bodyTopRow + 1);
            this.yLimitTop = totalBodyHeight / 2;
            this.yLimitBottom = totalHeight - totalBodyHeight / 2;
            const heightLimit = this.table.tableNoFrameHeight * 5;
            this.screenRowCount = Math.ceil(this.table.tableNoFrameHeight / defaultRowHeight);
            this.firstScreenRowLimit = Math.max(30, this.bodyTopRow + Math.min(this.rowLimit, Math.ceil(heightLimit / defaultRowHeight)));
            this.rowUpdatePos = this.bodyBottomRow;
        }
        refreshRowCount() {
            this.bodyBottomRow = this.table.rowCount - 1 - this.table.bottomFrozenRowCount;
            const totalActualBodyRowCount = Math.min(this.rowLimit, this.bodyBottomRow - this.bodyTopRow + 1);
            this.totalActualBodyRowCount = totalActualBodyRowCount;
            this.totalRow = this.rowStart + totalActualBodyRowCount - 1;
        }
        refreshColCount() {
            this.bodyRightCol = this.table.colCount - 1 - this.table.rightFrozenColCount;
            const totalActualBodyColCount = Math.min(this.colLimit, this.bodyRightCol - this.bodyLeftCol + 1);
            this.totalActualBodyColCount = totalActualBodyColCount;
            this.totalCol = this.bodyLeftCol + totalActualBodyColCount - 1;
            this.colStart = this.bodyLeftCol;
            this.colEnd = this.totalCol;
        }
        resize() {
            const defaultColWidth = this.table.defaultColWidth;
            this.taskColCount = Math.ceil(this.table.tableNoFrameWidth / defaultColWidth) * 1;
            const widthLimit = this.table.tableNoFrameWidth * 5;
            this.screenColCount = Math.ceil(this.table.tableNoFrameWidth / defaultColWidth);
            this.firstScreenColLimit = this.bodyLeftCol + Math.min(this.colLimit, Math.ceil(widthLimit / defaultColWidth));
            const defaultRowHeight = this.table.defaultRowHeight;
            this.taskRowCount = Math.ceil(this.table.tableNoFrameHeight / defaultRowHeight) * 1;
            const heightLimit = this.table.tableNoFrameHeight * 5;
            this.screenRowCount = Math.ceil(this.table.tableNoFrameHeight / defaultRowHeight);
            this.firstScreenRowLimit = this.bodyTopRow + Math.min(this.rowLimit, Math.ceil(heightLimit / defaultRowHeight));
        }
        createGroupForFirstScreen(cornerHeaderGroup, colHeaderGroup, rowHeaderGroup, rightFrozenGroup, bottomFrozenGroup, bodyGroup, xOrigin, yOrigin) {
            createGroupForFirstScreen(cornerHeaderGroup, colHeaderGroup, rowHeaderGroup, rightFrozenGroup, bottomFrozenGroup, bodyGroup, xOrigin, yOrigin, this);
        }
        async progress() {
            if (this.isProgressing) {
                return;
            }
            this.isProgressing = true;
            return new Promise((resolve, reject) => {
                setTimeout(async () => {
                    this.isProgressing = false;
                    if (this.isRelease) {
                        return;
                    }
                    if (this.colUpdatePos <= this.colEnd) {
                        await this.updateColCellGroupsAsync();
                        await this.progress();
                    }
                    else if (this.rowUpdatePos <= this.rowEnd) {
                        await this.updateRowCellGroupsAsync();
                        await this.progress();
                    }
                    else if (this.currentCol < this.totalCol) {
                        await this.createCol();
                        await this.progress();
                    }
                    else if (this.currentRow < this.totalRow) {
                        await this.createRow();
                        await this.progress();
                    }
                    handleTextStick(this.table);
                    this.table.scenegraph.updateNextFrame();
                    resolve();
                }, 16);
            });
        }
        async createRow() {
            if (!this.taskRowCount) {
                return;
            }
            this.createRowCellGroup(this.taskRowCount);
        }
        async createCol() {
            if (!this.taskColCount) {
                return;
            }
            this.createColGroup(this.taskRowCount);
        }
        createRowCellGroup(onceCount) {
            const endRow = Math.min(this.totalRow, this.currentRow + onceCount);
            if (this.table.heightMode !== 'adaptive') {
                computeRowsHeight(this.table, this.currentRow + 1, endRow, false);
            }
            this.rowEnd = endRow;
            if (this.table.frozenColCount) {
                let maxHeight = 0;
                for (let col = 0; col < this.table.frozenColCount; col++) {
                    const colGroup = this.table.scenegraph.getColGroup(col);
                    this.table.isListTable() ? 'body' : 'rowHeader';
                    const { height } = createComplexColumn(colGroup, col, colGroup.attribute.width, this.currentRow + 1, endRow, this.table.scenegraph.mergeMap, this.table.defaultRowHeight, this.table);
                    maxHeight = Math.max(maxHeight, height);
                    this.table.scenegraph.rowHeaderGroup.setAttribute('height', maxHeight);
                }
            }
            if (this.table.rightFrozenColCount) {
                let maxHeight = 0;
                for (let col = this.table.colCount - this.table.rightFrozenColCount; col < this.table.colCount; col++) {
                    const colGroup = this.table.scenegraph.getColGroup(col);
                    this.table.isPivotChart() ? 'rowHeader' : 'body';
                    const { height } = createComplexColumn(colGroup, col, colGroup.attribute.width, this.currentRow + 1, endRow, this.table.scenegraph.mergeMap, this.table.defaultRowHeight, this.table);
                    maxHeight = Math.max(maxHeight, height);
                    this.table.scenegraph.rightFrozenGroup.setAttribute('height', maxHeight);
                }
            }
            let maxHeight = 0;
            for (let col = this.bodyLeftCol; col <= this.bodyRightCol; col++) {
                const colGroup = this.table.scenegraph.getColGroup(col);
                if (!colGroup) {
                    continue;
                }
                col < this.table.rowHeaderLevelCount ? 'rowHeader' : 'body';
                const { height } = createComplexColumn(colGroup, col, colGroup.attribute.width, this.currentRow + 1, endRow, this.table.scenegraph.mergeMap, this.table.defaultRowHeight, this.table);
                maxHeight = Math.max(maxHeight, height);
            }
            this.table.scenegraph.bodyGroup.setAttribute('height', maxHeight);
            this.currentRow = endRow;
            this.rowUpdatePos = this.rowEnd;
            this.table.scenegraph.updateContainer();
            this.table.scenegraph.updateBorderSizeAndPosition();
        }
        createColGroup(onceCount) {
            const endCol = Math.min(this.totalCol, this.currentCol + onceCount);
            if (this.table.widthMode !== 'adaptive') {
                computeColsWidth(this.table, this.currentCol + 1, endCol);
            }
            this.colEnd = endCol;
            for (let row = 0; row < this.table.rowCount; row++) {
                const cellGroup = this.highPerformanceGetCell(this.currentCol, row);
                if (cellGroup.role === 'cell' && isNumber$4(cellGroup.mergeStartCol) && cellGroup.mergeStartCol > this.currentCol) {
                    this.table.scenegraph.updateCellContent(cellGroup.col, cellGroup.row);
                }
            }
            if (this.table.frozenRowCount) {
                const lastColumnGroup = (this.table.scenegraph.colHeaderGroup.lastChild instanceof Group$1
                    ? this.table.scenegraph.colHeaderGroup.lastChild
                    : this.table.scenegraph.colHeaderGroup.lastChild._prev);
                const xOrigin = lastColumnGroup.attribute.x + lastColumnGroup.attribute.width;
                const yOrigin = lastColumnGroup.attribute.y;
                createColGroup(this.table.scenegraph.colHeaderGroup, xOrigin, yOrigin, this.currentCol + 1, endCol, 0, this.table.frozenRowCount - 1, 'columnHeader', this.table);
            }
            if (this.table.bottomFrozenRowCount) {
                const lastColumnGroup = (this.table.scenegraph.bottomFrozenGroup.lastChild instanceof Group$1
                    ? this.table.scenegraph.bottomFrozenGroup.lastChild
                    : this.table.scenegraph.bottomFrozenGroup.lastChild._prev);
                const xOrigin = lastColumnGroup.attribute.x + lastColumnGroup.attribute.width;
                const yOrigin = lastColumnGroup.attribute.y;
                createColGroup(this.table.scenegraph.bottomFrozenGroup, xOrigin, yOrigin, this.currentCol + 1, endCol, this.table.rowCount - this.table.bottomFrozenRowCount, this.table.rowCount - 1, 'columnHeader', this.table);
            }
            let lastColumnGroup = this.table.scenegraph.bodyGroup.lastChild &&
                (this.table.scenegraph.bodyGroup.lastChild instanceof Group$1
                    ? this.table.scenegraph.bodyGroup.lastChild
                    : this.table.scenegraph.bodyGroup.lastChild._prev);
            if (!lastColumnGroup) {
                lastColumnGroup =
                    this.table.scenegraph.colHeaderGroup.lastChild &&
                        (this.table.scenegraph.colHeaderGroup.lastChild instanceof Group$1
                            ? this.table.scenegraph.colHeaderGroup.lastChild
                            : this.table.scenegraph.colHeaderGroup.lastChild._prev);
            }
            const xOrigin = lastColumnGroup.attribute.x + lastColumnGroup.attribute.width;
            const yOrigin = lastColumnGroup.attribute.y;
            createColGroup(this.table.scenegraph.bodyGroup, xOrigin, yOrigin, this.currentCol + 1, endCol, this.rowStart, this.rowEnd, 'body', this.table);
            this.currentCol = endCol;
            this.colUpdatePos = this.colEnd;
            this.table.scenegraph.updateContainer();
            this.table.scenegraph.updateBorderSizeAndPosition();
        }
        async setY(y, isEnd = false) {
            const yLimitTop = this.table.getRowsHeight(this.bodyTopRow, this.bodyTopRow + (this.rowEnd - this.rowStart + 1)) / 2;
            const yLimitBottom = this.table.getAllRowsHeight() - yLimitTop;
            const screenTop = this.table.getTargetRowAt(y + this.table.scenegraph.colHeaderGroup.attribute.height);
            if (screenTop) {
                this.screenTopRow = screenTop.row;
            }
            if (y < yLimitTop && this.rowStart === this.bodyTopRow) {
                this.updateDeltaY(y);
                this.updateBody(y - this.deltaY);
            }
            else if (y > yLimitBottom && this.rowEnd === this.bodyBottomRow) {
                this.updateDeltaY(y);
                this.updateBody(y - this.deltaY);
            }
            else if ((!this.table.scenegraph.bodyGroup.firstChild ||
                this.table.scenegraph.bodyGroup.firstChild.type !== 'group' ||
                this.table.scenegraph.bodyGroup.firstChild.childrenCount === 0) &&
                (!this.table.scenegraph.rowHeaderGroup.firstChild ||
                    this.table.scenegraph.rowHeaderGroup.firstChild.type !== 'group' ||
                    this.table.scenegraph.rowHeaderGroup.firstChild.childrenCount === 0)) {
                this.updateDeltaY(y);
                this.updateBody(y - this.deltaY);
            }
            else {
                this.dynamicSetY(y, screenTop, isEnd);
            }
        }
        async setX(x, isEnd = false) {
            const xLimitLeft = this.table.getColsWidth(this.bodyLeftCol, this.bodyLeftCol + (this.colEnd - this.colStart + 1)) / 2;
            const xLimitRight = this.table.getAllColsWidth() - xLimitLeft;
            const screenLeft = this.table.getTargetColAt(x + this.table.scenegraph.rowHeaderGroup.attribute.width);
            if (screenLeft) {
                this.screenLeftCol = screenLeft.col;
            }
            if (x < xLimitLeft && this.colStart === this.bodyLeftCol) {
                this.updateDeltaX(x);
                this.table.scenegraph.setBodyAndColHeaderX(-x + this.deltaX);
            }
            else if (x > xLimitRight && this.colEnd === this.bodyRightCol) {
                this.updateDeltaX(x);
                this.table.scenegraph.setBodyAndColHeaderX(-x + this.deltaX);
            }
            else if (this.table.scenegraph.bodyGroup.firstChild &&
                this.table.scenegraph.bodyGroup.firstChild.type === 'group' &&
                this.table.scenegraph.bodyGroup.firstChild.childrenCount === 0) {
                this.updateDeltaX(x);
                this.table.scenegraph.setBodyAndColHeaderX(-x + this.deltaX);
            }
            else {
                this.dynamicSetX(x, screenLeft, isEnd);
            }
        }
        async dynamicSetY(y, screenTop, isEnd = false) {
            dynamicSetY(y, screenTop, isEnd, this);
        }
        async dynamicSetX(x, screenLeft, isEnd = false) {
            dynamicSetX(x, screenLeft, isEnd, this);
        }
        updateBody(y) {
            this.table.scenegraph.setBodyAndRowHeaderY(-y);
        }
        async updateRowCellGroupsAsync() {
            this.updateCellGroups(this.taskRowCount);
        }
        updateCellGroups(count) {
            const distRow = Math.min(this.bodyBottomRow, this.rowUpdatePos + count);
            if (this.table.isAutoRowHeight(this.rowUpdatePos)) {
                computeRowsHeight(this.table, this.rowUpdatePos, distRow, false);
            }
            updateRowContent(this.rowUpdatePos, distRow, this);
            if (this.table.isAutoRowHeight(this.rowUpdatePos)) {
                updateAutoRow(this.bodyLeftCol, this.bodyRightCol, this.rowUpdatePos, distRow, this.table, this.rowUpdateDirection, true);
                updateAutoRow(0, this.table.frozenColCount - 1, this.rowUpdatePos, distRow, this.table, this.rowUpdateDirection, true);
                updateAutoRow(this.table.colCount - this.table.rightFrozenColCount, this.table.colCount - 1, this.rowUpdatePos, distRow, this.table, this.rowUpdateDirection, true);
            }
            this.rowUpdatePos = distRow + 1;
        }
        updateBottomFrozenCellGroups() {
            const startRow = this.table.rowCount - this.table.bottomFrozenRowCount;
            const endRow = this.table.rowCount - 1;
            if (this.table.isAutoRowHeight(startRow)) {
                computeRowsHeight(this.table, startRow, endRow, false);
            }
            updateRowContent(startRow, endRow, this);
            if (this.table.isAutoRowHeight(startRow)) {
                updateAutoRow(this.bodyLeftCol, this.bodyRightCol, startRow, endRow, this.table, this.rowUpdateDirection);
                updateAutoRow(0, this.table.frozenColCount - 1, startRow, endRow, this.table, this.rowUpdateDirection);
                updateAutoRow(this.table.colCount - this.table.rightFrozenColCount, this.table.colCount - 1, startRow, endRow, this.table, this.rowUpdateDirection);
            }
        }
        updateRightFrozenCellGroups() {
            const startCol = this.table.colCount - this.table.rightFrozenColCount;
            const endCol = this.table.colCount - 1;
            if (this.table.widthMode === 'autoWidth') {
                computeColsWidth(this.table, startCol, endCol, false);
            }
            updateColContent(startCol, endCol, this);
            if (this.table.isAutoRowHeight(this.rowStart)) {
                updateAutoColumn(startCol, endCol, this.table, this.colUpdateDirection);
            }
        }
        async updateColCellGroupsAsync() {
            this.updateColGroups(this.taskRowCount);
        }
        updateColGroups(count) {
            const distCol = Math.min(this.bodyRightCol, this.colUpdatePos + count);
            if (this.table.widthMode === 'autoWidth') {
                computeColsWidth(this.table, this.colUpdatePos, distCol);
            }
            updateColContent(this.colUpdatePos, distCol, this);
            this.colUpdatePos = distCol + 1;
        }
        updateCellGroupPosition(cellGroup, newRow, y) {
            cellGroup.row = newRow;
            cellGroup.mergeStartCol = undefined;
            cellGroup.mergeStartRow = undefined;
            cellGroup.mergeEndCol = undefined;
            cellGroup.mergeEndRow = undefined;
            cellGroup.setAttribute('y', y);
            cellGroup.needUpdate = true;
            cellGroup.needUpdateForAutoRowHeight = true;
        }
        updateCellGroupContent(cellGroup) {
            if (!cellGroup.needUpdate || cellGroup.role !== 'cell') {
                return cellGroup;
            }
            const newCellGroup = this.table.scenegraph.updateCellContent(cellGroup.col, cellGroup.row);
            cellGroup.needUpdate = false;
            return newCellGroup || cellGroup;
        }
        async sortCellVertical() {
            await sortVertical(this);
        }
        async sortCellHorizontal() {
            await sortHorizontal(this);
        }
        highPerformanceGetCell(col, row, getShadow) {
            if (row >= this.table.frozenRowCount &&
                row < this.table.rowCount - this.table.bottomFrozenRowCount &&
                (row < this.rowStart || row > this.rowEnd)) {
                return emptyGroup;
            }
            if (col >= this.table.frozenColCount &&
                col < this.table.colCount - this.table.rightFrozenColCount &&
                (col < this.colStart || col > this.colEnd)) {
                return emptyGroup;
            }
            if (this.cellCache.get(col)) {
                const cacheCellGoup = this.cellCache.get(col);
                if ((cacheCellGoup._next || cacheCellGoup._prev) && Math.abs(cacheCellGoup.row - row) < row) {
                    let cellGroup = getCellByCache(cacheCellGoup, row);
                    if (!cellGroup || (!getShadow && cellGroup.role === 'shadow-cell')) {
                        cellGroup = this.table.scenegraph.getCell(col, row, getShadow);
                    }
                    cellGroup.row && this.cellCache.set(col, cellGroup);
                    return cellGroup;
                }
                const cellGroup = this.table.scenegraph.getCell(col, row, getShadow);
                if (cellGroup.col === col && cellGroup.row) {
                    this.cellCache.set(col, cellGroup);
                }
                return cellGroup;
            }
            const cellGroup = this.table.scenegraph.getCell(col, row, getShadow);
            if (cellGroup.col === col && cellGroup.row) {
                this.cellCache.set(col, cellGroup);
            }
            return cellGroup;
        }
        updateDeltaY(y, screenTopY, screenTopRow) {
            if (this.rowStart === this.bodyTopRow) {
                const cellGroup = this.table.scenegraph.highPerformanceGetCell(this.colStart, this.rowStart, true);
                if (cellGroup.role === 'cell') {
                    const deltaY = cellGroup.attribute.y;
                    this.deltaY = -deltaY;
                }
            }
            else if (this.rowEnd === this.bodyBottomRow) {
                const cellGroup = this.table.scenegraph.highPerformanceGetCell(this.colStart, this.rowEnd, true);
                if (cellGroup.role === 'cell') {
                    const deltaY = cellGroup.attribute.y +
                        cellGroup.attribute.height -
                        (this.table.getAllRowsHeight() - this.table.getFrozenRowsHeight() - this.table.getBottomFrozenRowsHeight());
                    this.deltaY = -deltaY;
                }
            }
            else if (isValid$3(screenTopY) && isValid$3(screenTopRow)) {
                let cellGroup = this.table.scenegraph.highPerformanceGetCell(this.colStart, screenTopRow, true);
                if (cellGroup.role !== 'cell') {
                    cellGroup = this.table.scenegraph.highPerformanceGetCell(0, screenTopRow, true);
                }
                const bodyY = y - this.deltaY;
                const distRowYOffset = screenTopY - bodyY;
                const currentRowYOffset = cellGroup.attribute.y - bodyY + this.table.getFrozenRowsHeight();
                this.deltaY = distRowYOffset - currentRowYOffset;
            }
        }
        updateDeltaX(x, screenLeftX, screenLeftCol) {
            if (this.colStart === this.bodyLeftCol) {
                const colGroup = this.table.scenegraph.getColGroup(this.colStart);
                if (colGroup) {
                    const deltaX = colGroup.attribute.x;
                    this.deltaX = -deltaX;
                }
            }
            else if (this.colEnd === this.bodyRightCol) {
                const colGroup = this.table.scenegraph.getColGroup(this.colEnd);
                if (colGroup) {
                    const deltaX = colGroup.attribute.x +
                        colGroup.attribute.width -
                        (this.table.getAllColsWidth() - this.table.getFrozenColsWidth() - this.table.getRightFrozenColsWidth());
                    this.deltaX = -deltaX;
                }
            }
            else if (isValid$3(screenLeftX) && isValid$3(screenLeftCol)) {
                const colGroup = this.table.scenegraph.getColGroup(screenLeftCol) || this.table.scenegraph.getColGroup(screenLeftCol, true);
                const bodyX = x - this.deltaX;
                const distColXOffset = screenLeftX - bodyX;
                const currentColXOffset = colGroup.attribute.x - bodyX + this.table.getFrozenColsWidth();
                this.deltaX = distColXOffset - currentColXOffset;
            }
        }
        release() {
            this.isRelease = true;
        }
    }
    function getCellByCache(cacheCellGroup, row) {
        if (!cacheCellGroup) {
            return null;
        }
        if (cacheCellGroup.row === row) {
            return cacheCellGroup;
        }
        const prev = cacheCellGroup._prev;
        const next = cacheCellGroup._next;
        if (cacheCellGroup.row > row && prev && prev.row === cacheCellGroup.row - 1) {
            return getCellByCache(prev, row);
        }
        if (cacheCellGroup.row < row && next && next.row === cacheCellGroup.row + 1) {
            return getCellByCache(next, row);
        }
        return null;
    }

    function moveHeaderPosition(updateColStart, updateColEnd, updateRowStart, updateRowEnd, moveType, table) {
        const scene = table.scenegraph;
        for (let col = updateColStart; col <= updateColEnd; col++) {
            const columnWidth = table.getColWidth(col);
            const columnHeaderGroup = table.scenegraph.getColGroup(col, true);
            const columnGroup = table.scenegraph.getColGroup(col);
            const columnBottomGroup = table.scenegraph.getColGroupInBottom(col);
            const columnLeftBottomGroup = table.scenegraph.getColGroupInLeftBottomCorner(col);
            const columnRightBottomGroup = table.scenegraph.getColGroupInRightBottomCorner(col);
            if (columnHeaderGroup) {
                columnHeaderGroup.setAttribute('width', columnWidth);
                columnHeaderGroup.forEachChildren((child) => {
                    child.setAttribute('width', columnWidth);
                });
            }
            if (columnGroup) {
                columnGroup.setAttribute('width', columnWidth);
                columnGroup.forEachChildren((child) => {
                    child.setAttribute('width', columnWidth);
                });
            }
            if (columnBottomGroup) {
                columnBottomGroup.setAttribute('width', columnWidth);
                columnBottomGroup.forEachChildren((child) => {
                    child.setAttribute('width', columnWidth);
                });
            }
            if (columnRightBottomGroup) {
                columnRightBottomGroup.setAttribute('width', columnWidth);
                columnRightBottomGroup.forEachChildren((child) => {
                    child.setAttribute('width', columnWidth);
                });
            }
            if (columnLeftBottomGroup) {
                columnLeftBottomGroup.setAttribute('width', columnWidth);
                columnLeftBottomGroup.forEachChildren((child) => {
                    child.setAttribute('width', columnWidth);
                });
            }
        }
        scene.updateContainer();
        if (moveType === 'column') {
            for (let col = updateColStart; col <= updateColEnd; col++) {
                const columnGroup = table.scenegraph.getColGroup(col);
                columnGroup?.setAttribute('chartInstance', undefined);
                for (let row = 0; row <= table.frozenRowCount - 1; row++) {
                    scene.updateCellContent(col, row);
                }
                for (let row = scene.bodyRowStart; row <= scene.bodyRowEnd; row++) {
                    scene.updateCellContent(col, row);
                }
                for (let row = table.rowCount - table.bottomFrozenRowCount; row <= table.rowCount - 1; row++) {
                    scene.updateCellContent(col, row);
                }
            }
        }
        else {
            for (let col = 0; col <= table.frozenColCount - 1; col++) {
                const columnGroup = table.scenegraph.getColGroup(col);
                columnGroup?.setAttribute('chartInstance', undefined);
                for (let row = updateRowStart; row <= updateRowEnd; row++) {
                    scene.updateCellContent(col, row);
                }
            }
            for (let col = scene.bodyColStart; col <= scene.bodyColEnd; col++) {
                const columnGroup = table.scenegraph.getColGroup(col);
                columnGroup?.setAttribute('chartInstance', undefined);
                for (let row = updateRowStart; row <= updateRowEnd; row++) {
                    scene.updateCellContent(col, row);
                }
            }
            for (let col = table.colCount - table.rightFrozenColCount; col <= table.colCount - 1; col++) {
                const columnGroup = table.scenegraph.getColGroup(col);
                columnGroup?.setAttribute('chartInstance', undefined);
                for (let row = updateRowStart; row <= updateRowEnd; row++) {
                    scene.updateCellContent(col, row);
                }
            }
        }
    }

    function updateAllSelectComponent(scene) {
        scene.customSelectedRangeComponents.forEach((selectComp, key) => {
            updateComponent(selectComp, key, scene);
        });
        scene.selectingRangeComponents.forEach((selectComp, key) => {
            updateComponent(selectComp, key, scene);
        });
        scene.selectedRangeComponents.forEach((selectComp, key) => {
            updateComponent(selectComp, key, scene);
        });
    }
    function updateComponent(selectComp, key, scene) {
        const table = scene.table;
        const [startColStr, startRowStr, endColStr, endRowStr] = key.split('-');
        const startCol = parseInt(startColStr, 10);
        const startRow = parseInt(startRowStr, 10);
        const endCol = parseInt(endColStr, 10);
        const endRow = parseInt(endRowStr, 10);
        let computeRectCellRangeStartCol = startCol;
        let computeRectCellRangeStartRow = startRow;
        let computeRectCellRangeEndCol = endCol;
        let computeRectCellRangeEndRow = endRow;
        let visibleCellRange;
        switch (selectComp.role) {
            case 'rowHeader':
                visibleCellRange = table.getBodyVisibleRowRange();
                if (visibleCellRange) {
                    computeRectCellRangeStartRow = Math.max(startRow, visibleCellRange.rowStart - 1);
                    computeRectCellRangeEndRow = Math.min(endRow, visibleCellRange.rowEnd + 1);
                }
                break;
            case 'columnHeader':
                visibleCellRange = table.getBodyVisibleCellRange();
                if (visibleCellRange) {
                    computeRectCellRangeStartCol = Math.max(startCol, visibleCellRange.colStart - 1);
                    computeRectCellRangeEndCol = Math.min(endCol, visibleCellRange.colEnd + 1);
                }
                break;
            case 'cornerHeader':
                break;
            case 'bottomFrozen':
                visibleCellRange = table.getBodyVisibleCellRange();
                if (visibleCellRange) {
                    computeRectCellRangeStartCol = Math.max(startCol, visibleCellRange.colStart - 1);
                    computeRectCellRangeEndCol = Math.min(endCol, visibleCellRange.colEnd + 1);
                }
                break;
            case 'rightFrozen':
                visibleCellRange = table.getBodyVisibleCellRange();
                if (visibleCellRange) {
                    computeRectCellRangeStartRow = Math.max(startRow, visibleCellRange.rowStart - 1);
                    computeRectCellRangeEndRow = Math.min(endRow, visibleCellRange.rowEnd + 1);
                }
                break;
            case 'rightTopCorner':
                break;
            case 'leftBottomCorner':
                break;
            case 'rightBottomCorner':
                break;
            default:
                visibleCellRange = table.getBodyVisibleCellRange();
                if (visibleCellRange) {
                    computeRectCellRangeStartRow = Math.max(startRow, visibleCellRange.rowStart - 1);
                    computeRectCellRangeEndRow = Math.min(endRow, visibleCellRange.rowEnd + 1);
                    computeRectCellRangeStartCol = Math.max(startCol, visibleCellRange.colStart - 1);
                    computeRectCellRangeEndCol = Math.min(endCol, visibleCellRange.colEnd + 1);
                }
                break;
        }
        const colsWidth = table.getColsWidth(computeRectCellRangeStartCol, computeRectCellRangeEndCol);
        const rowsHeight = table.getRowsHeight(computeRectCellRangeStartRow, computeRectCellRangeEndRow);
        const firstCellBound = scene.highPerformanceGetCell(computeRectCellRangeStartCol, computeRectCellRangeStartRow).globalAABBBounds;
        selectComp.rect.setAttributes({
            x: firstCellBound.x1 - scene.tableGroup.attribute.x,
            y: firstCellBound.y1 - scene.tableGroup.attribute.y,
            width: colsWidth,
            height: rowsHeight,
            visible: true
        });
        if (selectComp.fillhandle) {
            const fillHandle = scene.table.options.excelOptions?.fillHandle;
            let visible = true;
            if (typeof fillHandle === 'function') {
                visible = fillHandle({ selectRanges: scene.table.stateManager.select.ranges, table: scene.table });
            }
            let lastCellBound;
            if (computeRectCellRangeEndCol < table.colCount - 1) {
                lastCellBound = scene.highPerformanceGetCell(computeRectCellRangeEndCol, computeRectCellRangeEndRow).globalAABBBounds;
            }
            else {
                lastCellBound = scene.highPerformanceGetCell(computeRectCellRangeStartCol - 1, computeRectCellRangeEndRow).globalAABBBounds;
            }
            const handlerX = lastCellBound.x2 - scene.tableGroup.attribute.x - 3;
            if (computeRectCellRangeEndRow < table.rowCount - 1) {
                lastCellBound = scene.highPerformanceGetCell(computeRectCellRangeEndCol, computeRectCellRangeEndRow).globalAABBBounds;
            }
            else {
                lastCellBound = scene.highPerformanceGetCell(computeRectCellRangeEndCol, computeRectCellRangeStartRow - 1).globalAABBBounds;
            }
            const handlerY = lastCellBound.y2 - scene.tableGroup.attribute.y - 3;
            selectComp.fillhandle?.setAttributes({
                x: handlerX,
                y: handlerY,
                width: 6,
                height: 6,
                visible
            });
        }
        let isNearRowHeader = table.frozenColCount ? startCol === table.frozenColCount : false;
        if (!isNearRowHeader && table.frozenColCount && table.scrollLeft > 0 && startCol >= table.frozenColCount) {
            const startColRelativePosition = table.getColsWidth(0, startCol - 1) - table.scrollLeft;
            if (startColRelativePosition < table.getFrozenColsWidth()) {
                isNearRowHeader = true;
            }
        }
        let isNearRightRowHeader = table.rightFrozenColCount
            ? table.rightFrozenColCount > 0 && endCol === table.colCount - table.rightFrozenColCount - 1
            : false;
        if (!isNearRightRowHeader && table.rightFrozenColCount && endCol < table.colCount - table.rightFrozenColCount) {
            const endColRelativePosition = table.getColsWidth(0, endCol) - table.scrollLeft;
            if (endColRelativePosition > table.tableNoFrameWidth - table.getRightFrozenColsWidth()) {
                isNearRightRowHeader = true;
            }
        }
        let isNearColHeader = table.frozenRowCount ? startRow === table.frozenRowCount : true;
        if (!isNearColHeader && table.frozenRowCount && table.scrollTop > 0 && startRow >= table.frozenRowCount) {
            const startRowRelativePosition = table.getRowsHeight(0, startRow - 1) - table.scrollTop;
            if (startRowRelativePosition < table.getFrozenRowsHeight()) {
                isNearColHeader = true;
            }
        }
        let isNearBottomColHeader = table.bottomFrozenRowCount
            ? endRow === table.rowCount - table.bottomFrozenRowCount - 1
            : false;
        if (!isNearBottomColHeader && table.bottomFrozenRowCount && endRow < table.rowCount - table.bottomFrozenRowCount) {
            const endRowRelativePosition = table.getRowsHeight(0, endRow) - table.scrollTop;
            if (endRowRelativePosition > table.tableNoFrameHeight - table.getBottomFrozenRowsHeight()) {
                isNearBottomColHeader = true;
            }
        }
        const { dynamicUpdateSelectionSize } = table.theme.selectionStyle;
        if ((isNearRowHeader && (selectComp.rect.attribute.stroke[3] || dynamicUpdateSelectionSize)) ||
            (isNearRightRowHeader && (selectComp.rect.attribute.stroke[1] || dynamicUpdateSelectionSize)) ||
            (isNearColHeader && (selectComp.rect.attribute.stroke[0] || dynamicUpdateSelectionSize)) ||
            (isNearBottomColHeader && (selectComp.rect.attribute.stroke[2] || dynamicUpdateSelectionSize))) {
            if (isNearRowHeader && selectComp.rect.attribute.stroke[3]) {
                scene.tableGroup.insertAfter(selectComp.rect, selectComp.role === 'columnHeader'
                    ? scene.cornerHeaderGroup
                    : selectComp.role === 'bottomFrozen'
                        ? scene.leftBottomCornerGroup
                        : scene.rowHeaderGroup);
            }
            if (isNearBottomColHeader && selectComp.rect.attribute.stroke[2]) {
                scene.tableGroup.insertAfter(selectComp.rect, selectComp.role === 'rowHeader'
                    ? scene.leftBottomCornerGroup
                    : selectComp.role === 'rightFrozen'
                        ? scene.rightBottomCornerGroup
                        : scene.bottomFrozenGroup);
            }
            if (isNearColHeader && selectComp.rect.attribute.stroke[0]) {
                scene.tableGroup.insertAfter(selectComp.rect, selectComp.role === 'rowHeader'
                    ? scene.cornerHeaderGroup
                    : selectComp.role === 'rightFrozen'
                        ? scene.rightTopCornerGroup
                        : scene.colHeaderGroup);
            }
            if (isNearRightRowHeader && selectComp.rect.attribute.stroke[1]) {
                scene.tableGroup.insertAfter(selectComp.rect, selectComp.role === 'columnHeader'
                    ? scene.rightTopCornerGroup
                    : selectComp.role === 'bottomFrozen'
                        ? scene.rightBottomCornerGroup
                        : scene.rightFrozenGroup);
            }
            if (selectComp.rect.attribute.x < table.getFrozenColsWidth() &&
                table.scrollLeft > 0 &&
                (selectComp.role === 'body' || selectComp.role === 'columnHeader' || selectComp.role === 'bottomFrozen')) {
                const width = selectComp.rect.attribute.width - (table.getFrozenColsWidth() - selectComp.rect.attribute.x);
                selectComp.rect.setAttributes({
                    x: selectComp.rect.attribute.x + (table.getFrozenColsWidth() - selectComp.rect.attribute.x),
                    width: width > 0 ? width : 0
                });
                selectComp.fillhandle?.setAttributes({
                    visible: width > 0
                });
            }
            if (table.getRightFrozenColsWidth() > 0 &&
                scene.rightFrozenGroup.attribute.height > 0 &&
                selectComp.rect.attribute.x + selectComp.rect.attribute.width > scene.rightFrozenGroup.attribute.x &&
                (selectComp.role === 'body' || selectComp.role === 'columnHeader' || selectComp.role === 'bottomFrozen')) {
                const width = scene.rightFrozenGroup.attribute.x - selectComp.rect.attribute.x;
                selectComp.rect.setAttributes({
                    x: selectComp.rect.attribute.x,
                    width: width > 0 ? width : 0
                });
                selectComp.fillhandle?.setAttributes({
                    visible: width - colsWidth > 0
                });
            }
            if (selectComp.rect.attribute.y < scene.colHeaderGroup.attribute.height &&
                table.scrollTop > 0 &&
                (selectComp.role === 'body' || selectComp.role === 'rowHeader' || selectComp.role === 'rightFrozen')) {
                const height = selectComp.rect.attribute.height - (scene.colHeaderGroup.attribute.height - selectComp.rect.attribute.y);
                selectComp.rect.setAttributes({
                    y: selectComp.rect.attribute.y + (scene.colHeaderGroup.attribute.height - selectComp.rect.attribute.y),
                    height: height > 0 ? height : 0
                });
                selectComp.fillhandle?.setAttributes({
                    visible: height > 0
                });
            }
            if (scene.bottomFrozenGroup.attribute.width > 0 &&
                scene.bottomFrozenGroup.attribute.height > 0 &&
                selectComp.rect.attribute.y + selectComp.rect.attribute.height > scene.bottomFrozenGroup.attribute.y &&
                (selectComp.role === 'body' || selectComp.role === 'rowHeader' || selectComp.role === 'rightFrozen')) {
                const height = scene.bottomFrozenGroup.attribute.y - selectComp.rect.attribute.y;
                selectComp.rect.setAttributes({
                    y: selectComp.rect.attribute.y,
                    height: height > 0 ? height : 0
                });
                selectComp.fillhandle?.setAttributes({
                    visible: height - rowsHeight > 0
                });
            }
        }
        else {
            scene.tableGroup.insertAfter(selectComp.rect, selectComp.role === 'body'
                ? scene.bodyGroup
                : selectComp.role === 'columnHeader'
                    ? scene.colHeaderGroup
                    : selectComp.role === 'rowHeader'
                        ? scene.rowHeaderGroup
                        : selectComp.role === 'cornerHeader'
                            ? scene.cornerHeaderGroup
                            : selectComp.role === 'rightTopCorner'
                                ? scene.rightTopCornerGroup
                                : selectComp.role === 'rightFrozen'
                                    ? scene.rightFrozenGroup
                                    : selectComp.role === 'leftBottomCorner'
                                        ? scene.leftBottomCornerGroup
                                        : selectComp.role === 'bottomFrozen'
                                            ? scene.bottomFrozenGroup
                                            : scene.rightBottomCornerGroup);
        }
        let diffSize = 0;
        if (typeof selectComp.rect.attribute.lineWidth === 'number') {
            diffSize = Math.ceil(selectComp.rect.attribute.lineWidth / 2);
        }
        if (endCol === table.colCount - 1) {
            if (Array.isArray(selectComp.rect.attribute.lineWidth)) {
                diffSize = Math.ceil((selectComp.rect.attribute.lineWidth[1] ?? 0) / 2);
            }
            selectComp.rect.setAttributes({
                width: selectComp.rect.attribute.width - diffSize
            });
        }
        if (startCol === 0) {
            if (Array.isArray(selectComp.rect.attribute.lineWidth)) {
                diffSize = Math.ceil((selectComp.rect.attribute.lineWidth[3] ?? 0) / 2);
            }
            selectComp.rect.setAttributes({
                x: selectComp.rect.attribute.x + diffSize,
                width: selectComp.rect.attribute.width - diffSize
            });
        }
        if (endRow === table.rowCount - 1) {
            if (Array.isArray(selectComp.rect.attribute.lineWidth)) {
                diffSize = Math.ceil((selectComp.rect.attribute.lineWidth[2] ?? 0) / 2);
            }
            selectComp.rect.setAttributes({
                height: selectComp.rect.attribute.height - diffSize
            });
        }
        if (startRow === 0) {
            if (Array.isArray(selectComp.rect.attribute.lineWidth)) {
                diffSize = Math.ceil((selectComp.rect.attribute.lineWidth[0] ?? 0) / 2);
            }
            selectComp.rect.setAttributes({
                y: selectComp.rect.attribute.y + diffSize,
                height: selectComp.rect.attribute.height - diffSize
            });
        }
    }
    function updateCellSelectBorder(scene, selectRange, ifExtendSelectRange = true) {
        const table = scene.table;
        const newStartCol = selectRange.start.col;
        const newStartRow = selectRange.start.row;
        const newEndCol = selectRange.end.col;
        const newEndRow = selectRange.end.row;
        const skipBodyMerge = selectRange.skipBodyMerge;
        let startCol = Math.max(Math.min(newEndCol, newStartCol), 0);
        let startRow = Math.max(Math.min(newEndRow, newStartRow), 0);
        let endCol = Math.min(Math.max(newEndCol, newStartCol), table.colCount - 1);
        let endRow = Math.min(Math.max(newEndRow, newStartRow), table.rowCount - 1);
        const extendSelectRange = () => {
            let isExtend = false;
            for (let col = startCol; col <= endCol; col++) {
                if (col === startCol) {
                    for (let row = startRow; row <= endRow; row++) {
                        if (!table.isHeader(col, row) && skipBodyMerge) {
                            continue;
                        }
                        const mergeInfo = getCellMergeInfo(table, col, row);
                        if (mergeInfo && mergeInfo.start.col < startCol) {
                            startCol = mergeInfo.start.col;
                            isExtend = true;
                            break;
                        }
                    }
                }
                if (!isExtend && col === endCol) {
                    for (let row = startRow; row <= endRow; row++) {
                        if (!table.isHeader(col, row) && skipBodyMerge) {
                            continue;
                        }
                        const mergeInfo = getCellMergeInfo(table, col, row);
                        if (mergeInfo && Math.min(mergeInfo.end.col, table.colCount - 1) > endCol) {
                            endCol = mergeInfo.end.col;
                            isExtend = true;
                            break;
                        }
                    }
                }
                if (isExtend) {
                    break;
                }
            }
            if (!isExtend) {
                for (let row = startRow; row <= endRow; row++) {
                    if (row === startRow) {
                        for (let col = startCol; col <= endCol; col++) {
                            if (!table.isHeader(col, row) && skipBodyMerge) {
                                continue;
                            }
                            const mergeInfo = getCellMergeInfo(table, col, row);
                            if (mergeInfo && mergeInfo.start.row < startRow) {
                                startRow = mergeInfo.start.row;
                                isExtend = true;
                                break;
                            }
                        }
                    }
                    if (!isExtend && row === endRow) {
                        for (let col = startCol; col <= endCol; col++) {
                            if (!table.isHeader(col, row) && skipBodyMerge) {
                                continue;
                            }
                            const mergeInfo = getCellMergeInfo(table, col, row);
                            if (mergeInfo && Math.min(mergeInfo.end.row, table.rowCount - 1) > endRow) {
                                endRow = mergeInfo.end.row;
                                isExtend = true;
                                break;
                            }
                        }
                    }
                    if (isExtend) {
                        break;
                    }
                }
            }
            if (isExtend) {
                extendSelectRange();
            }
        };
        if (ifExtendSelectRange) {
            extendSelectRange();
            if (selectRange.start.col > selectRange.end.col) {
                selectRange.start.col = Math.max(startCol, endCol);
                selectRange.end.col = Math.min(startCol, endCol);
            }
            else {
                selectRange.start.col = Math.min(startCol, endCol);
                selectRange.end.col = Math.max(startCol, endCol);
            }
            if (selectRange.start.row > selectRange.end.row) {
                selectRange.start.row = Math.max(startRow, endRow);
                selectRange.end.row = Math.min(startRow, endRow);
            }
            else {
                selectRange.start.row = Math.min(startRow, endRow);
                selectRange.end.row = Math.max(startRow, endRow);
            }
        }
        scene.selectingRangeComponents.forEach((selectComp, key) => {
            selectComp.rect.delete();
            selectComp.fillhandle?.delete();
        });
        scene.selectingRangeComponents = new Map();
        let needRowHeader = false;
        let needRightRowHeader = false;
        let needColumnHeader = false;
        let needBottomColumnHeader = false;
        let needBody = false;
        let needCornerHeader = false;
        let needRightTopCornerHeader = false;
        let needRightBottomCornerHeader = false;
        let needLeftBottomCornerHeader = false;
        if (startCol <= table.frozenColCount - 1 && startRow <= table.frozenRowCount - 1) {
            needCornerHeader = true;
        }
        if (endCol >= table.colCount - table.rightFrozenColCount && startRow <= table.frozenRowCount - 1) {
            needRightTopCornerHeader = true;
        }
        if (startCol <= table.frozenColCount - 1 && endRow >= table.rowCount - table.bottomFrozenRowCount) {
            needLeftBottomCornerHeader = true;
        }
        if (endCol >= table.colCount - table.rightFrozenColCount && endRow >= table.rowCount - table.bottomFrozenRowCount) {
            needRightBottomCornerHeader = true;
        }
        if (startCol <= table.frozenColCount - 1 &&
            endRow >= table.frozenRowCount &&
            startRow <= table.rowCount - table.bottomFrozenRowCount - 1) {
            needRowHeader = true;
        }
        if (endCol >= table.colCount - table.rightFrozenColCount &&
            endRow >= table.frozenRowCount &&
            startRow <= table.rowCount - table.bottomFrozenRowCount - 1) {
            needRightRowHeader = true;
        }
        if (startRow <= table.frozenRowCount - 1 &&
            endCol >= table.frozenColCount &&
            startCol <= table.colCount - table.rightFrozenColCount - 1) {
            needColumnHeader = true;
        }
        if (endRow >= table.rowCount - table.bottomFrozenRowCount &&
            endCol >= table.frozenColCount &&
            startCol <= table.colCount - table.rightFrozenColCount - 1) {
            needBottomColumnHeader = true;
        }
        if (startCol <= table.colCount - table.rightFrozenColCount - 1 &&
            endCol >= table.frozenColCount &&
            startRow <= table.rowCount - table.bottomFrozenRowCount - 1 &&
            endRow >= table.frozenRowCount) {
            needBody = true;
        }
        if (needCornerHeader) {
            const cornerEndCol = Math.min(endCol, table.frozenColCount - 1);
            const cornerEndRow = Math.min(endRow, table.frozenRowCount - 1);
            const strokeArray = [true, !needColumnHeader, !needRowHeader, true];
            scene.createCellSelectBorder(startCol, startRow, cornerEndCol, cornerEndRow, 'cornerHeader', `${startCol}${startRow}${endCol}${endRow}`, strokeArray);
        }
        if (needRightTopCornerHeader) {
            const cornerStartCol = Math.max(startCol, table.colCount - table.rightFrozenColCount);
            const cornerEndRow = Math.min(endRow, table.frozenRowCount - 1);
            const strokeArray = [true, true, !needRightRowHeader, !needColumnHeader];
            scene.createCellSelectBorder(cornerStartCol, startRow, endCol, cornerEndRow, 'rightTopCorner', `${startCol}${startRow}${endCol}${endRow}`, strokeArray);
        }
        if (needLeftBottomCornerHeader) {
            const cornerEndCol = Math.min(endCol, table.frozenColCount - 1);
            const cornerStartRow = Math.max(startRow, table.rowCount - table.bottomFrozenRowCount);
            const strokeArray = [!needRowHeader, !needBottomColumnHeader, true, true];
            scene.createCellSelectBorder(startCol, cornerStartRow, cornerEndCol, endRow, 'leftBottomCorner', `${startCol}${startRow}${endCol}${endRow}`, strokeArray);
        }
        if (needRightBottomCornerHeader) {
            const cornerStartCol = Math.max(startCol, table.colCount - table.rightFrozenColCount);
            const cornerStartRow = Math.max(startRow, table.rowCount - table.bottomFrozenRowCount);
            const strokeArray = [!needRightRowHeader, true, true, !needBottomColumnHeader];
            scene.createCellSelectBorder(cornerStartCol, cornerStartRow, endCol, endRow, 'rightBottomCorner', `${startCol}${startRow}${endCol}${endRow}`, strokeArray);
        }
        if (needColumnHeader) {
            const columnHeaderStartCol = Math.max(startCol, table.frozenColCount);
            const columnHeaderEndCol = Math.min(endCol, table.colCount - table.rightFrozenColCount - 1);
            const columnHeaderEndRow = Math.min(endRow, table.frozenRowCount - 1);
            const strokeArray = [true, !needRightTopCornerHeader, !needBody, !needCornerHeader];
            scene.createCellSelectBorder(columnHeaderStartCol, startRow, columnHeaderEndCol, columnHeaderEndRow, 'columnHeader', `${startCol}${startRow}${endCol}${endRow}`, strokeArray);
        }
        if (needBottomColumnHeader) {
            const columnHeaderStartCol = Math.max(startCol, table.frozenColCount);
            const columnHeaderEndCol = Math.min(endCol, table.colCount - table.rightFrozenColCount - 1);
            const columnHeaderStartRow = Math.max(startRow, table.rowCount - table.bottomFrozenRowCount);
            const strokeArray = [!needBody, !needRightBottomCornerHeader, true, !needLeftBottomCornerHeader];
            scene.createCellSelectBorder(columnHeaderStartCol, columnHeaderStartRow, columnHeaderEndCol, endRow, 'bottomFrozen', `${startCol}${startRow}${endCol}${endRow}`, strokeArray);
        }
        if (needRowHeader) {
            const columnHeaderStartRow = Math.max(startRow, table.frozenRowCount);
            const columnHeaderEndRow = Math.min(endRow, table.rowCount - table.bottomFrozenRowCount - 1);
            const columnHeaderEndCol = Math.min(endCol, table.frozenColCount - 1);
            const strokeArray = [!needCornerHeader, !needBody, !needLeftBottomCornerHeader, true];
            scene.createCellSelectBorder(startCol, columnHeaderStartRow, columnHeaderEndCol, columnHeaderEndRow, 'rowHeader', `${startCol}${startRow}${endCol}${endRow}`, strokeArray);
        }
        if (needRightRowHeader) {
            const columnHeaderStartRow = Math.max(startRow, table.frozenRowCount);
            const columnHeaderEndRow = Math.min(endRow, table.rowCount - table.bottomFrozenRowCount - 1);
            const columnHeaderStartCol = Math.max(startCol, table.colCount - table.rightFrozenColCount);
            const strokeArray = [!needRightTopCornerHeader, true, !needRightBottomCornerHeader, !needBody];
            scene.createCellSelectBorder(columnHeaderStartCol, columnHeaderStartRow, endCol, columnHeaderEndRow, 'rightFrozen', `${startCol}${startRow}${endCol}${endRow}`, strokeArray);
        }
        if (needBody) {
            const columnHeaderStartCol = Math.max(startCol, table.frozenColCount);
            const columnHeaderStartRow = Math.max(startRow, table.frozenRowCount);
            const columnHeaderEndCol = Math.min(endCol, table.colCount - table.rightFrozenColCount - 1);
            const columnHeaderEndRow = Math.min(endRow, table.rowCount - table.bottomFrozenRowCount - 1);
            const strokeArray = [!needColumnHeader, !needRightRowHeader, !needBottomColumnHeader, !needRowHeader];
            scene.createCellSelectBorder(columnHeaderStartCol, columnHeaderStartRow, columnHeaderEndCol, columnHeaderEndRow, 'body', `${startCol}${startRow}${endCol}${endRow}`, strokeArray);
        }
    }
    function hideCellSelectBorder(scene) {
        scene.selectingRangeComponents.forEach((selectComp, key) => {
            selectComp.rect.setAttribute('opacity', 0);
        });
        scene.selectedRangeComponents.forEach((selectComp, key) => {
            selectComp.rect.setAttribute('opacity', 0);
        });
    }
    function restoreCellSelectBorder(scene) {
        scene.selectingRangeComponents.forEach((selectComp, key) => {
            selectComp.rect.setAttribute('opacity', 1);
        });
        scene.selectedRangeComponents.forEach((selectComp, key) => {
            selectComp.rect.setAttribute('opacity', 1);
        });
    }

    function createCellSelectBorder(scene, start_Col, start_Row, end_Col, end_Row, selectRangeType, selectId, strokes) {
        let isHasFillHandleRect = !!scene.table.options.excelOptions?.fillHandle;
        if (scene.table.stateManager.select.ranges?.length > 1) {
            isHasFillHandleRect = false;
            scene.removeFillHandleFromSelectComponents();
        }
        else if (scene.table.stateManager.select.ranges?.length === 1) {
            const maxRow = Math.max(scene.table.stateManager.select.ranges[0].start.row, scene.table.stateManager.select.ranges[0].end.row);
            const maxCol = Math.max(scene.table.stateManager.select.ranges[0].start.col, scene.table.stateManager.select.ranges[0].end.col);
            if (scene.table.isHeader(maxCol, maxRow)) {
                isHasFillHandleRect = false;
            }
        }
        if (Array.isArray(strokes) && (strokes[1] === false || strokes[2] === false)) {
            isHasFillHandleRect = false;
        }
        const startCol = Math.min(start_Col, end_Col);
        const startRow = Math.min(start_Row, end_Row);
        const endCol = Math.max(start_Col, end_Col);
        const endRow = Math.max(start_Row, end_Row);
        const firstCellBound = scene.highPerformanceGetCell(startCol, startRow).globalAABBBounds;
        const lastCellBound = scene.highPerformanceGetCell(endCol, endRow).globalAABBBounds;
        const theme = scene.table.theme;
        const bodyClickBorderColor = theme.selectionStyle?.cellBorderColor;
        const bodyClickLineWidth = theme.selectionStyle?.cellBorderLineWidth;
        const rect = createRect({
            pickable: false,
            fill: theme.selectionStyle?.selectionFillMode === 'replace'
                ? false
                : theme.selectionStyle?.cellBgColor ?? 'rgba(0, 0, 255,0.1)',
            lineWidth: bodyClickLineWidth,
            stroke: strokes.map(stroke => {
                if (stroke) {
                    return bodyClickBorderColor;
                }
                return false;
            }),
            x: firstCellBound.x1 - scene.tableGroup.attribute.x,
            y: firstCellBound.y1 - scene.tableGroup.attribute.y,
            width: 0,
            height: 0,
            visible: true,
            cornerRadius: getCornerRadius(selectRangeType, scene.table.theme.frameStyle?.cornerRadius, start_Col, start_Row, end_Col, end_Row, scene.table)
        });
        let fillhandle;
        if (isHasFillHandleRect) {
            fillhandle = createRect({
                pickable: false,
                fill: bodyClickBorderColor,
                stroke: bodyClickBorderColor,
                x: lastCellBound.x2 - 3,
                y: lastCellBound.y2 - 3,
                width: 6,
                height: 6,
                visible: true
            });
        }
        scene.lastSelectId = selectId;
        scene.selectingRangeComponents.set(`${startCol}-${startRow}-${endCol}-${endRow}-${selectId}`, {
            rect,
            fillhandle,
            role: selectRangeType
        });
        scene.tableGroup.insertAfter(rect, selectRangeType === 'body'
            ? scene.bodyGroup
            : selectRangeType === 'columnHeader'
                ? scene.colHeaderGroup
                : selectRangeType === 'rowHeader'
                    ? scene.rowHeaderGroup
                    : selectRangeType === 'cornerHeader'
                        ? scene.cornerHeaderGroup
                        : selectRangeType === 'rightTopCorner'
                            ? scene.rightTopCornerGroup
                            : selectRangeType === 'rightFrozen'
                                ? scene.rightFrozenGroup
                                : selectRangeType === 'leftBottomCorner'
                                    ? scene.leftBottomCornerGroup
                                    : selectRangeType === 'bottomFrozen'
                                        ? scene.bottomFrozenGroup
                                        : scene.rightBottomCornerGroup);
        isHasFillHandleRect &&
            scene.tableGroup.insertAfter(fillhandle, selectRangeType === 'body'
                ? scene.bodyGroup
                : selectRangeType === 'columnHeader'
                    ? scene.colHeaderGroup
                    : selectRangeType === 'rowHeader'
                        ? scene.rowHeaderGroup
                        : selectRangeType === 'cornerHeader'
                            ? scene.cornerHeaderGroup
                            : selectRangeType === 'rightTopCorner'
                                ? scene.rightTopCornerGroup
                                : selectRangeType === 'rightFrozen'
                                    ? scene.rightFrozenGroup
                                    : selectRangeType === 'leftBottomCorner'
                                        ? scene.leftBottomCornerGroup
                                        : selectRangeType === 'bottomFrozen'
                                            ? scene.bottomFrozenGroup
                                            : scene.rightBottomCornerGroup);
    }
    function getCornerRadius(selectRangeType, cornerRadius, start_Col, start_Row, end_Col, end_Row, table) {
        if (!cornerRadius) {
            return undefined;
        }
        const cornerRadiusArray = Array.isArray(cornerRadius)
            ? cornerRadius
            : [cornerRadius, cornerRadius, cornerRadius, cornerRadius];
        const tableStartCol = 0;
        const tableStartRow = 0;
        const tableEndCol = table.colCount - 1;
        const tableEndRow = table.rowCount - 1;
        const result = [0, 0, 0, 0];
        let changed = false;
        if (start_Col === tableStartCol && start_Row === tableStartRow) {
            result[0] = cornerRadiusArray[0];
            changed = true;
        }
        else if (end_Col === tableEndCol && end_Row === tableEndRow) {
            result[2] = cornerRadiusArray[2];
            changed = true;
        }
        else if (start_Col === tableStartCol && end_Row === tableEndRow) {
            result[3] = cornerRadiusArray[3];
            changed = true;
        }
        else if (end_Col === tableEndCol && start_Row === tableStartRow) {
            result[1] = cornerRadiusArray[1];
            changed = true;
        }
        if (changed) {
            return result;
        }
        return undefined;
    }

    function moveSelectingRangeComponentsToSelectedRangeComponents(scene) {
        scene.selectingRangeComponents.forEach((rangeComponent, key) => {
            if (scene.selectedRangeComponents.get(key)) {
                scene.selectingRangeComponents.get(key).rect.delete();
                scene.selectingRangeComponents.get(key).fillhandle?.delete();
            }
            scene.selectedRangeComponents.set(key, rangeComponent);
        });
        scene.selectingRangeComponents = new Map();
        scene.updateNextFrame();
    }

    function deleteLastSelectedRangeComponents(scene) {
        scene.selectedRangeComponents.forEach((selectComp, key) => {
            const lastSelectId = key.split('-')[4];
            if (lastSelectId === scene.lastSelectId) {
                selectComp.rect.delete();
                selectComp.fillhandle?.delete();
                scene.selectedRangeComponents.delete(key);
            }
        });
    }
    function deleteAllSelectBorder(scene) {
        scene.selectedRangeComponents.forEach((selectComp, key) => {
            selectComp.rect.delete();
            selectComp.fillhandle?.delete();
        });
        scene.selectedRangeComponents = new Map();
    }
    function deleteAllSelectingBorder(scene) {
        scene.selectingRangeComponents.forEach((selectComp, key) => {
            selectComp.rect.delete();
            selectComp.fillhandle?.delete();
        });
        scene.selectingRangeComponents = new Map();
    }
    function removeFillHandleFromSelectComponents(scene) {
        scene.selectedRangeComponents.forEach((selectComp, key) => {
            selectComp.fillhandle?.delete();
            selectComp.fillhandle = undefined;
        });
    }

    function updateRow(removeCells, addCells, updateCells, table, skipUpdateProxy) {
        if (checkHaveTextStick(table)) {
            resetTextStick(table);
        }
        const scene = table.scenegraph;
        const removeRows = deduplication$1(removeCells.map(cell => cell.row)).sort((a, b) => b - a);
        const addRows = deduplication$1(addCells.map(cell => cell.row)).sort((a, b) => a - b);
        const updateRows = deduplication$1(updateCells.map(cell => cell.row)).sort((a, b) => a - b);
        let rowUpdatePos;
        if (updateRows.length) {
            const beforeRow = updateRows[0] - 1;
            const afterRow = updateRows[updateRows.length - 1] + 1;
            rowUpdatePos = _getUpdateRowIndexUseCellNode(beforeRow, afterRow, scene);
        }
        if (addRows.length) {
            const beforeRow = addRows[0] - 1;
            const afterRow = addRows[addRows.length - 1] + 1;
            const pos = _getUpdateRowIndexUseCellNode(beforeRow, afterRow, scene);
            rowUpdatePos = isValid$3(rowUpdatePos) ? (isValid$3(pos) ? Math.min(rowUpdatePos, pos) : rowUpdatePos) : pos;
        }
        if (removeRows.length) {
            const beforeRow = removeRows[0] - 1;
            const afterRow = removeRows[removeRows.length - 1] + 1;
            const pos = _getUpdateRowIndexUseCellNode(beforeRow, afterRow, scene);
            rowUpdatePos = isValid$3(rowUpdatePos) ? (isValid$3(pos) ? Math.min(rowUpdatePos, pos) : rowUpdatePos) : pos;
        }
        removeRows.forEach(row => {
            removeRow(row, scene, skipUpdateProxy);
        });
        const rowHeightsMap = table.rowHeightsMap;
        removeRows.forEach(row => {
            rowHeightsMap.delete(row);
        });
        if (removeRows.length) {
            resetRowNumber(scene);
            const beforeRow = removeRows[removeRows.length - 1] - 1;
            const afterRow = removeRows[0] - removeRows.length + 1;
            const pos = _getUpdateRowIndex(beforeRow, afterRow, scene);
            rowUpdatePos = isValid$3(rowUpdatePos) ? (isValid$3(pos) ? Math.min(rowUpdatePos, pos) : rowUpdatePos) : pos;
        }
        scene.table._clearRowRangeHeightsMap();
        let updateAfter;
        addRows.forEach(row => {
            const needUpdateAfter = addRow(row, scene, skipUpdateProxy);
            updateAfter = updateAfter ?? needUpdateAfter;
            rowHeightsMap.insert(row);
        });
        resetRowNumberAndY(scene);
        if (addRows.length) {
            const beforeRow = addRows[0] - 1;
            const afterRow = addRows[addRows.length - 1] + 1;
            const pos = _getUpdateRowIndex(beforeRow, afterRow, scene);
            rowUpdatePos = isValid$3(rowUpdatePos) ? (isValid$3(pos) ? Math.min(rowUpdatePos, pos) : rowUpdatePos) : pos;
        }
        for (let col = 0; col < table.colCount; col++) {
            updateRows.forEach(row => {
                if (row < table.frozenRowCount) {
                    const mergeInfo = getCellMergeInfo(scene.table, col, row);
                    if (mergeInfo) {
                        for (let col = mergeInfo.start.col; col <= mergeInfo.end.col; col++) {
                            for (let row = mergeInfo.start.row; row <= mergeInfo.end.row; row++) {
                                updateCell$1(col, row, scene.table, false);
                            }
                        }
                    }
                    else {
                        updateCell$1(col, row, scene.table, false);
                    }
                }
                else if (row > table.rowCount - 1 ||
                    (row < scene.table.rowCount - scene.table.bottomFrozenRowCount &&
                        (row < scene.proxy.rowStart || row > scene.proxy.rowEnd))) {
                    removeCellGroup(row, scene);
                }
                else {
                    const mergeInfo = getCellMergeInfo(scene.table, col, row);
                    if (mergeInfo) {
                        for (let col = mergeInfo.start.col; col <= mergeInfo.end.col; col++) {
                            for (let row = mergeInfo.start.row; row <= mergeInfo.end.row; row++) {
                                updateCell$1(col, row, scene.table, false);
                            }
                        }
                    }
                    else {
                        updateCell$1(col, row, scene.table, false);
                    }
                }
            });
        }
        if (updateRows.length) {
            const beforeRow = updateRows[0] - 1;
            const afterRow = updateRows[updateRows.length - 1] + 1;
            const pos = _getUpdateRowIndex(beforeRow, afterRow, scene);
            rowUpdatePos = isValid$3(rowUpdatePos) ? (isValid$3(pos) ? Math.min(rowUpdatePos, pos) : rowUpdatePos) : pos;
        }
        if (isNumber$4(updateAfter)) {
            for (let col = 0; col < Math.max(table.colCount, table.internalProps._oldColCount ?? table.colCount); col++) {
                for (let row = updateAfter; row < Math.max(table.rowCount, table.internalProps._oldRowCount ?? table.rowCount); row++) {
                    const cellGroup = scene.highPerformanceGetCell(col, row, true);
                    cellGroup && (cellGroup.needUpdate = true);
                }
            }
            rowUpdatePos = isValid$3(rowUpdatePos)
                ? isValid$3(updateAfter)
                    ? Math.min(rowUpdatePos, updateAfter)
                    : rowUpdatePos
                : updateAfter;
        }
        isNumber$4(rowUpdatePos) && (scene.proxy.rowUpdatePos = Math.min(scene.proxy.rowUpdatePos, rowUpdatePos));
        if (addRows.length) {
            if (!isNumber$4(updateAfter)) {
                const minRow = Math.min(...addRows);
                scene.proxy.rowUpdatePos = Math.min(minRow, scene.proxy.rowUpdatePos);
            }
            scene.proxy.rowUpdateDirection = 'up';
            scene.proxy.updateCellGroups(scene.proxy.screenRowCount * 2);
            updateBottomFrozeCellGroups();
        }
        else if (removeRows.length) {
            setRowSeriesNumberCellNeedUpdate(removeRows[removeRows.length - 1], scene);
            scene.proxy.updateCellGroups(scene.proxy.screenRowCount * 2);
            updateBottomFrozeCellGroups();
        }
        scene.proxy.progress();
        const newTotalHeight = table.getRowsHeight(table.frozenRowCount, table.rowCount - 1 - table.bottomFrozenRowCount);
        scene.updateContainerHeight(scene.table.frozenRowCount, newTotalHeight - scene.bodyGroup.attribute.height);
        function updateBottomFrozeCellGroups() {
            if (addRows?.[addRows?.length - 1] >= table.rowCount - table.bottomFrozenRowCount ||
                updateRows?.[updateRows?.length - 1] >= table.rowCount - table.bottomFrozenRowCount ||
                removeRows?.[0] >= table.rowCount - table.bottomFrozenRowCount) {
                for (let col = 0; col < table.colCount; col++) {
                    for (let row = table.rowCount - table.bottomFrozenRowCount; row < table.rowCount; row++) {
                        const cellGroup = scene.highPerformanceGetCell(col, row, true);
                        cellGroup && (cellGroup.needUpdate = true);
                    }
                }
                scene.proxy.updateBottomFrozenCellGroups();
            }
        }
    }
    function removeRow(row, scene, skipUpdateProxy) {
        const proxy = scene.proxy;
        if (row >= proxy.rowStart && row <= proxy.rowEnd) {
            removeCellGroup(row, scene);
            proxy.rowEnd--;
            proxy.currentRow--;
        }
        if (!skipUpdateProxy) {
            proxy.bodyBottomRow--;
            const totalActualBodyRowCount = Math.min(proxy.rowLimit, proxy.bodyBottomRow - proxy.bodyTopRow + 1);
            proxy.totalActualBodyRowCount = totalActualBodyRowCount;
            proxy.totalRow = Math.min(proxy.table.rowCount - 1, proxy.rowStart + totalActualBodyRowCount - 1);
        }
    }
    function addRow(row, scene, skipUpdateProxy) {
        const proxy = scene.proxy;
        if (!skipUpdateProxy) {
            proxy.bodyBottomRow++;
            const totalActualBodyRowCount = Math.min(proxy.rowLimit, proxy.bodyBottomRow - proxy.bodyTopRow + 1);
            proxy.totalActualBodyRowCount = totalActualBodyRowCount;
            proxy.totalRow = proxy.rowStart + totalActualBodyRowCount - 1;
        }
        if (row < proxy.rowStart) {
            return undefined;
        }
        else if (row > proxy.rowEnd) {
            if (proxy.rowEnd - proxy.rowStart + 1 < proxy.rowLimit) {
                proxy.rowEnd++;
                proxy.currentRow++;
                addRowCellGroup(row, scene);
                return row;
            }
            return undefined;
        }
        if (proxy.rowEnd - proxy.rowStart + 1 < proxy.rowLimit) {
            proxy.rowEnd++;
            proxy.currentRow++;
            addRowCellGroup(row, scene);
            return row;
        }
        return row;
    }
    function resetRowNumber(scene) {
        scene.bodyGroup.forEachChildren((colGroup) => {
            let rowIndex = scene.bodyRowStart;
            colGroup?.forEachChildren((cellGroup) => {
                processCell(cellGroup, rowIndex);
                rowIndex++;
            });
        });
        scene.rowHeaderGroup.forEachChildren((colGroup) => {
            let rowIndex = scene.bodyRowStart;
            colGroup?.forEachChildren((cellGroup) => {
                processCell(cellGroup, rowIndex);
                rowIndex++;
            });
        });
        scene.rightFrozenGroup.forEachChildren((colGroup) => {
            let rowIndex = scene.bodyRowStart;
            colGroup?.forEachChildren((cellGroup) => {
                processCell(cellGroup, rowIndex);
                rowIndex++;
            });
        });
        scene.bottomFrozenGroup.forEachChildren((colGroup) => {
            let rowIndex = scene.table.rowCount - scene.table.bottomFrozenRowCount;
            colGroup?.forEachChildren((cellGroup) => {
                processCell(cellGroup, rowIndex);
                rowIndex++;
            });
        });
        scene.leftBottomCornerGroup.forEachChildren((colGroup) => {
            let rowIndex = scene.table.rowCount - scene.table.bottomFrozenRowCount;
            colGroup?.forEachChildren((cellGroup) => {
                processCell(cellGroup, rowIndex);
                rowIndex++;
            });
        });
        scene.rightBottomCornerGroup.forEachChildren((colGroup) => {
            let rowIndex = scene.table.rowCount - scene.table.bottomFrozenRowCount;
            colGroup?.forEachChildren((cellGroup) => {
                processCell(cellGroup, rowIndex);
                rowIndex++;
            });
        });
        function processCell(cellGroup, rowIndex) {
            cellGroup.row = rowIndex;
            const merge = getCellMergeInfo(scene.table, cellGroup.col, cellGroup.row);
            if (merge) {
                cellGroup.mergeStartCol = merge.start.col;
                cellGroup.mergeEndCol = merge.end.col;
                cellGroup.mergeStartRow = merge.start.row;
                cellGroup.mergeEndRow = merge.end.row;
            }
            else {
                cellGroup.mergeStartCol = undefined;
                cellGroup.mergeEndCol = undefined;
                cellGroup.mergeStartRow = undefined;
                cellGroup.mergeEndRow = undefined;
            }
        }
    }
    function resetRowNumberAndY(scene) {
        scene.bodyGroup.forEachChildren((colGroup) => {
            let rowIndex = scene.bodyRowStart;
            let y = scene.getCellGroupY(rowIndex);
            colGroup?.forEachChildren((cellGroup) => {
                processCell(cellGroup, rowIndex, y);
                rowIndex++;
                y += cellGroup.attribute.height;
            });
        });
        scene.rowHeaderGroup.forEachChildren((colGroup) => {
            let rowIndex = scene.bodyRowStart;
            let y = scene.getCellGroupY(rowIndex);
            colGroup?.forEachChildren((cellGroup) => {
                processCell(cellGroup, rowIndex, y);
                rowIndex++;
                y += cellGroup.attribute.height;
            });
        });
        scene.rightFrozenGroup.forEachChildren((colGroup) => {
            let rowIndex = scene.bodyRowStart;
            let y = scene.getCellGroupY(rowIndex);
            colGroup?.forEachChildren((cellGroup) => {
                processCell(cellGroup, rowIndex, y);
                rowIndex++;
                y += cellGroup.attribute.height;
            });
        });
        scene.bottomFrozenGroup.forEachChildren((colGroup) => {
            let rowIndex = scene.table.rowCount - scene.table.bottomFrozenRowCount;
            let y = 0;
            colGroup?.forEachChildren((cellGroup) => {
                processCell(cellGroup, rowIndex, y);
                rowIndex++;
                y += cellGroup.attribute.height;
            });
        });
        scene.leftBottomCornerGroup.forEachChildren((colGroup) => {
            let rowIndex = scene.table.rowCount - scene.table.bottomFrozenRowCount;
            let y = 0;
            colGroup?.forEachChildren((cellGroup) => {
                processCell(cellGroup, rowIndex, y);
                rowIndex++;
                y += cellGroup.attribute.height;
            });
        });
        scene.rightBottomCornerGroup.forEachChildren((colGroup) => {
            let rowIndex = scene.table.rowCount - scene.table.bottomFrozenRowCount;
            let y = 0;
            colGroup?.forEachChildren((cellGroup) => {
                processCell(cellGroup, rowIndex, y);
                rowIndex++;
                y += cellGroup.attribute.height;
            });
        });
        function processCell(cellGroup, rowIndex, y) {
            cellGroup.row = rowIndex;
            cellGroup.setAttribute('y', y);
            const merge = getCellMergeInfo(scene.table, cellGroup.col, cellGroup.row);
            if (merge) {
                cellGroup.mergeStartCol = merge.start.col;
                cellGroup.mergeEndCol = merge.end.col;
                cellGroup.mergeStartRow = merge.start.row;
                cellGroup.mergeEndRow = merge.end.row;
            }
            else {
                cellGroup.mergeStartCol = undefined;
                cellGroup.mergeEndCol = undefined;
                cellGroup.mergeStartRow = undefined;
                cellGroup.mergeEndRow = undefined;
            }
        }
    }
    function addRowCellGroup(row, scene) {
        for (let col = 0; col < scene.table.colCount; col++) {
            const cellGroup = new Group$1({
                x: 0,
                y: 0,
                width: scene.table.getColWidth(col),
                height: scene.table.getRowHeight(row)
            });
            cellGroup.role = 'cell';
            cellGroup.col = col;
            cellGroup.row = row;
            cellGroup.needUpdate = true;
            if (!cellGroup) {
                continue;
            }
            const colGroup = scene.getColGroup(col);
            if (!colGroup) {
                continue;
            }
            if (colGroup.firstChild && row < colGroup.firstChild.row) {
                colGroup.insertBefore(cellGroup, colGroup.firstChild);
                colGroup.firstChild.row = colGroup.firstChild.row + 1;
            }
            else if (colGroup.lastChild && row > colGroup.lastChild.row) {
                colGroup.appendChild(cellGroup);
            }
            else {
                const cellBefore = scene.highPerformanceGetCell(col, row, true);
                if (cellBefore !== cellGroup) {
                    colGroup.insertBefore(cellGroup, cellBefore);
                    cellBefore && (cellBefore.row = cellBefore.row + 1);
                    if (cellBefore !== colGroup.lastChild) {
                        colGroup.lastChild && (colGroup.lastChild.row = colGroup.lastChild.row + 1);
                    }
                }
            }
        }
    }
    function removeCellGroup(row, scene) {
        for (let col = 0; col < scene.table.colCount; col++) {
            const colGroup = scene.getColGroup(col, false);
            if (!colGroup) {
                continue;
            }
            let cellGroup;
            colGroup.forEachChildren((cell) => {
                if (cell.row === row) {
                    cellGroup = cell;
                    return true;
                }
                return false;
            });
            if (cellGroup) {
                colGroup.updateColumnHeight(-cellGroup.attribute.height);
                colGroup.removeChild(cellGroup);
            }
        }
    }
    function _getUpdateRowIndex(beforeRow, afterRow, scene) {
        let updateRow;
        for (let col = 0; col < scene.table.colCount; col++) {
            const rangeBefore = scene.table.getCellRange(col, beforeRow);
            let row;
            if (rangeBefore.start.row <= beforeRow + 1 && rangeBefore.end.row >= beforeRow + 1) {
                addNeedUpdateTag(rangeBefore, scene);
                row = rangeBefore.start.row;
            }
            const rangeAfter = scene.table.getCellRange(col, afterRow);
            if (rangeAfter.start.row <= afterRow + 1 && rangeAfter.end.row >= afterRow + 1) {
                addNeedUpdateTag(rangeAfter, scene);
                row = rangeAfter.start.row;
            }
            if (isValid$3(row)) {
                updateRow = isValid$3(updateRow) ? Math.min(updateRow, row) : row;
            }
        }
        return updateRow;
    }
    function _getUpdateRowIndexUseCellNode(beforeRow, afterRow, scene) {
        let updateRow;
        for (let col = 0; col < scene.table.colCount; col++) {
            let row;
            const beforeCell = scene.highPerformanceGetCell(col, beforeRow);
            if (beforeCell.mergeStartRow && beforeCell.mergeEndRow && beforeCell.mergeEndRow > beforeRow) {
                addNeedUpdateTag({
                    start: {
                        row: beforeCell.mergeStartRow,
                        col: scene.table.isAutoRowHeight(afterRow) ? 0 : beforeCell.mergeStartCol
                    },
                    end: {
                        row: beforeCell.mergeEndRow,
                        col: scene.table.isAutoRowHeight(afterRow) ? scene.table.colCount - 1 : beforeCell.mergeEndCol
                    }
                }, scene);
                row = beforeCell.mergeStartRow;
            }
            const afterCell = scene.highPerformanceGetCell(col, afterRow);
            if (afterCell.mergeStartRow && afterCell.mergeEndRow && afterCell.mergeStartRow < afterRow) {
                addNeedUpdateTag({
                    start: {
                        row: afterCell.mergeStartRow,
                        col: scene.table.isAutoRowHeight(afterRow) ? 0 : afterCell.mergeStartCol
                    },
                    end: {
                        row: afterCell.mergeEndRow,
                        col: scene.table.isAutoRowHeight(afterRow) ? scene.table.colCount - 1 : afterCell.mergeEndCol
                    }
                }, scene);
                row = afterCell.mergeStartRow;
            }
            if (isValid$3(row)) {
                updateRow = isValid$3(updateRow) ? Math.min(updateRow, row) : row;
            }
        }
        return updateRow;
    }
    function addNeedUpdateTag(range, scene) {
        const { start, end } = range;
        for (let col = start.col; col <= end.col; col++) {
            for (let row = start.row; row <= end.row; row++) {
                const cellGroup = scene.highPerformanceGetCell(col, row, true);
                if (!cellGroup) {
                    continue;
                }
                cellGroup.needUpdate = true;
            }
        }
    }
    function setRowSeriesNumberCellNeedUpdate(startUpdateRow, scene) {
        if (scene.table.isHasSeriesNumber()) {
            for (let row = startUpdateRow; row <= scene.table.rowCount - 1; row++) {
                updateCell$1(0, row, scene.table, false);
            }
        }
    }

    function createReactContainer(table) {
        const { internalProps } = table;
        internalProps.bodyDomContainer = document.createElement('div');
        internalProps.bodyDomContainer.id = 'vtable-body-dom-container';
        internalProps.bodyDomContainer.classList.add('table-component-container');
        internalProps.element.appendChild(internalProps.bodyDomContainer);
        internalProps.headerDomContainer = document.createElement('div');
        internalProps.headerDomContainer.id = 'vtable-header-dom-container';
        internalProps.headerDomContainer.classList.add('table-component-container');
        internalProps.element.appendChild(internalProps.headerDomContainer);
        internalProps.frozenBodyDomContainer = document.createElement('div');
        internalProps.frozenBodyDomContainer.id = 'vtable-frozen-body-dom-container';
        internalProps.frozenBodyDomContainer.classList.add('table-component-container');
        internalProps.element.appendChild(internalProps.frozenBodyDomContainer);
        internalProps.frozenHeaderDomContainer = document.createElement('div');
        internalProps.frozenHeaderDomContainer.id = 'vtable-frozen-header-dom-container';
        internalProps.frozenHeaderDomContainer.classList.add('table-component-container');
        internalProps.element.appendChild(internalProps.frozenHeaderDomContainer);
        internalProps.rightFrozenBodyDomContainer = document.createElement('div');
        internalProps.rightFrozenBodyDomContainer.id = 'vtable-right-frozen-body-dom-container';
        internalProps.rightFrozenBodyDomContainer.classList.add('table-component-container');
        internalProps.element.appendChild(internalProps.rightFrozenBodyDomContainer);
        internalProps.rightFrozenHeaderDomContainer = document.createElement('div');
        internalProps.rightFrozenHeaderDomContainer.id = 'vtable-right-frozen-header-dom-container';
        internalProps.rightFrozenHeaderDomContainer.classList.add('table-component-container');
        internalProps.element.appendChild(internalProps.rightFrozenHeaderDomContainer);
        internalProps.frozenBottomDomContainer = document.createElement('div');
        internalProps.frozenBottomDomContainer.id = 'vtable-frozen-bottom-dom-container';
        internalProps.frozenBottomDomContainer.classList.add('table-component-container');
        internalProps.element.appendChild(internalProps.frozenBottomDomContainer);
        internalProps.bottomDomContainer = document.createElement('div');
        internalProps.bottomDomContainer.id = 'vtable-bottom-dom-container';
        internalProps.bottomDomContainer.classList.add('table-component-container');
        internalProps.element.appendChild(internalProps.bottomDomContainer);
        internalProps.rightFrozenBottomDomContainer = document.createElement('div');
        internalProps.rightFrozenBottomDomContainer.id = 'vtable-right-frozen-bottom-dom-container';
        internalProps.rightFrozenBottomDomContainer.classList.add('table-component-container');
        internalProps.element.appendChild(internalProps.rightFrozenBottomDomContainer);
    }
    function updateReactContainer(table) {
        const { headerDomContainer, bodyDomContainer, frozenBodyDomContainer, frozenHeaderDomContainer, rightFrozenBodyDomContainer, rightFrozenHeaderDomContainer, bottomDomContainer, frozenBottomDomContainer, rightFrozenBottomDomContainer } = table.internalProps;
        if (!headerDomContainer &&
            !bodyDomContainer &&
            !frozenBodyDomContainer &&
            !frozenHeaderDomContainer &&
            !rightFrozenBodyDomContainer &&
            !rightFrozenHeaderDomContainer &&
            !bottomDomContainer &&
            !frozenBottomDomContainer &&
            !rightFrozenBottomDomContainer) {
            return;
        }
        const allColsWidth = table.getAllColsWidth();
        const tableNoFrameWidth = Math.min(allColsWidth, table.tableNoFrameWidth);
        const frozenColsWidth = table.getFrozenColsWidth();
        const rightFrozenColsWidth = table.getRightFrozenColsWidth();
        const totalFrozenColsWidth = frozenColsWidth + rightFrozenColsWidth;
        const bodyWidth = Math.min(allColsWidth - totalFrozenColsWidth, tableNoFrameWidth - totalFrozenColsWidth);
        const allRowsHeight = table.getAllRowsHeight();
        const tableNoFrameHeight = Math.min(allRowsHeight, table.tableNoFrameHeight);
        const frozenRowsHeight = table.getFrozenRowsHeight();
        const bottomFrozenRowsHeight = table.getBottomFrozenRowsHeight();
        const totalFrozenRowsHeight = frozenRowsHeight + bottomFrozenRowsHeight;
        const bodyHeight = Math.min(allRowsHeight - totalFrozenRowsHeight, tableNoFrameHeight - totalFrozenRowsHeight);
        if (table.frozenColCount > 0) {
            headerDomContainer.style.left = `${table.tableX + frozenColsWidth}px`;
            bodyDomContainer.style.left = `${table.tableX + frozenColsWidth}px`;
            bottomDomContainer.style.left = `${table.tableX + frozenColsWidth}px`;
        }
        else if (table.frozenColCount === 0) {
            headerDomContainer.style.left = `${table.tableX}px`;
            bodyDomContainer.style.left = `${table.tableX}px`;
            bottomDomContainer.style.left = `${table.tableX}px`;
        }
        frozenBodyDomContainer.style.left = `${table.tableX}px`;
        frozenHeaderDomContainer.style.left = `${table.tableX}px`;
        headerDomContainer.style.width = `${bodyWidth}px`;
        headerDomContainer.style.height = `${frozenRowsHeight}px`;
        bodyDomContainer.style.top = `${table.tableY}px`;
        bodyDomContainer.style.width = `${bodyWidth}px`;
        bodyDomContainer.style.height = `${bodyHeight}px`;
        bodyDomContainer.style.top = `${table.tableY + frozenRowsHeight}px`;
        frozenBodyDomContainer.style.width = `${frozenColsWidth}px`;
        frozenBodyDomContainer.style.height = `${bodyHeight}px`;
        frozenBodyDomContainer.style.top = `${table.tableY + frozenRowsHeight}px`;
        frozenHeaderDomContainer.style.width = `${frozenColsWidth}px`;
        frozenHeaderDomContainer.style.height = `${frozenRowsHeight}px`;
        frozenHeaderDomContainer.style.top = `${table.tableY}px`;
        rightFrozenBodyDomContainer.style.width = `${rightFrozenColsWidth}px`;
        rightFrozenBodyDomContainer.style.height = `${bodyHeight}px`;
        rightFrozenBodyDomContainer.style.top = `${table.tableY + frozenRowsHeight}px`;
        rightFrozenBodyDomContainer.style.left = `${table.tableX + tableNoFrameWidth - rightFrozenColsWidth}px`;
        rightFrozenHeaderDomContainer.style.width = `${rightFrozenColsWidth}px`;
        rightFrozenHeaderDomContainer.style.height = `${frozenRowsHeight}px`;
        rightFrozenHeaderDomContainer.style.top = `${table.tableY}px`;
        rightFrozenHeaderDomContainer.style.left = `${table.tableX + tableNoFrameWidth - rightFrozenColsWidth}px`;
        bottomDomContainer.style.width = `${bodyWidth}px`;
        bottomDomContainer.style.height = `${bottomFrozenRowsHeight}px`;
        bottomDomContainer.style.top = `${table.tableY + tableNoFrameHeight - bottomFrozenRowsHeight}px`;
        frozenBottomDomContainer.style.width = `${frozenColsWidth}px`;
        frozenBottomDomContainer.style.height = `${bottomFrozenRowsHeight}px`;
        frozenBottomDomContainer.style.top = `${table.tableY + tableNoFrameHeight - bottomFrozenRowsHeight}px`;
        rightFrozenBottomDomContainer.style.width = `${rightFrozenColsWidth}px`;
        rightFrozenBottomDomContainer.style.height = `${bottomFrozenRowsHeight}px`;
        rightFrozenBottomDomContainer.style.top = `${table.tableY + tableNoFrameHeight - bottomFrozenRowsHeight}px`;
        rightFrozenBottomDomContainer.style.left = `${table.tableX + tableNoFrameWidth - rightFrozenColsWidth}px`;
    }
    function updateReactComponentContainer(scene) {
        if (!scene.table.reactCustomLayout) {
            return;
        }
        const { table, stage } = scene;
        const plugin = stage.pluginService.findPluginsByName('ReactAttributePlugin')[0];
        const { htmlMap, renderId: stageRenderId } = plugin;
        for (const key in htmlMap) {
            const item = htmlMap[key];
            const { graphic, wrapContainer, renderId } = item;
            if (renderId !== stageRenderId) {
                continue;
            }
            let targetContainer;
            if (scene.frozenColCount > table.frozenColCount) {
                const targetCell = getTargetCell(graphic);
                if (!targetCell) {
                    continue;
                }
                const { col, row } = targetCell;
                if (row >= table.rowCount - table.bottomFrozenRowCount &&
                    col < scene.frozenColCount &&
                    col >= table.frozenColCount &&
                    graphic.attribute.react.container === table.frozenBottomDomContainer) {
                    targetContainer = table.bottomDomContainer;
                }
                else if (row >= table.frozenRowCount &&
                    col < scene.frozenColCount &&
                    col >= table.frozenColCount &&
                    graphic.attribute.react.container === table.frozenBodyDomContainer) {
                    targetContainer = table.bodyDomContainer;
                }
                else if (row < table.frozenRowCount &&
                    col < scene.frozenColCount &&
                    col >= table.frozenColCount &&
                    graphic.attribute.react.container === table.frozenHeaderDomContainer) {
                    targetContainer = table.headerDomContainer;
                }
            }
            else if (scene.frozenColCount < table.frozenColCount) {
                const targetCell = getTargetCell(graphic);
                if (!targetCell) {
                    continue;
                }
                const { col, row } = targetCell;
                if (row >= table.rowCount - table.bottomFrozenRowCount &&
                    col < table.frozenColCount &&
                    col >= scene.frozenColCount &&
                    graphic.attribute.react.container === table.bottomDomContainer) {
                    targetContainer = table.frozenBottomDomContainer;
                }
                else if (row >= table.frozenRowCount &&
                    col < table.frozenColCount &&
                    col >= scene.frozenColCount &&
                    graphic.attribute.react.container === table.bodyDomContainer) {
                    targetContainer = table.frozenBodyDomContainer;
                }
                else if (row < table.frozenRowCount &&
                    col < table.frozenColCount &&
                    col >= scene.frozenColCount &&
                    graphic.attribute.react.container === table.headerDomContainer) {
                    targetContainer = table.frozenHeaderDomContainer;
                }
            }
            if (targetContainer) {
                targetContainer.appendChild(wrapContainer);
                item.nativeContainer = targetContainer;
                item.container = targetContainer;
                graphic.attribute.react.container = targetContainer;
                plugin.updateStyleOfWrapContainer(graphic, stage, wrapContainer, targetContainer, graphic.attribute.react);
            }
        }
    }

    function dealFrozen(scene) {
        if (scene.table.frozenColCount > scene.table.rowHeaderLevelCount) {
            scene.rowHeaderGroup.setAttribute('height', scene.bodyGroup.attribute.height);
            scene.rowHeaderGroup.setAttribute('y', scene.bodyGroup.attribute.y);
            scene.cornerHeaderGroup.setAttribute('height', scene.colHeaderGroup.attribute.height);
            for (let i = 0; i < scene.table.frozenColCount - scene.table.rowHeaderLevelCount; i++) {
                moveColumnFromBodyToRowHeader(scene);
                moveColumnFromColHeaderToCornerHeader(scene);
                moveColumnFromBottomToLeftBottomCorner(scene);
            }
        }
        else if (scene.table.frozenColCount < scene.table.rowHeaderLevelCount) {
            scene.bodyGroup.setAttribute('height', scene.rowHeaderGroup.attribute.height);
            scene.bodyGroup.setAttribute('y', scene.rowHeaderGroup.attribute.y);
            scene.colHeaderGroup.setAttribute('height', scene.cornerHeaderGroup.attribute.height);
            for (let i = 0; i < scene.table.rowHeaderLevelCount - scene.table.frozenColCount; i++) {
                moveColumnFromRowHeaderToBody(scene);
                moveColumnFromCornerHeaderToColHeader(scene);
                moveColumnFromLeftBottomCornerToBottom(scene);
            }
        }
        scene.bodyGroup.setAttribute('x', scene.rowHeaderGroup.attribute.width);
        scene.colHeaderGroup.setAttribute('x', scene.cornerHeaderGroup.attribute.width);
        scene.updateContainer();
        scene.updateBorderSizeAndPosition();
        if (!scene.isPivot && !scene.table.transpose) {
            scene.component.setFrozenColumnShadow(scene.table.frozenColCount - 1);
            scene.component.setRightFrozenColumnShadow(scene.table.colCount - scene.table.rightFrozenColCount);
        }
        else if (scene.table.options.frozenColCount) {
            scene.component.setFrozenColumnShadow(scene.table.frozenColCount - 1);
        }
        else if (scene.table.options.frozenColCount) {
            scene.component.setRightFrozenColumnShadow(scene.table.colCount - scene.table.rightFrozenColCount);
        }
        scene.hasFrozen = true;
        scene.frozenColCount = scene.table.frozenColCount;
        scene.frozenRowCount =
            scene.colHeaderGroup.firstChild?.childrenCount ??
                scene.cornerHeaderGroup.firstChild?.childrenCount ??
                scene.table.frozenRowCount;
    }
    function resetFrozen(scene) {
        if (scene.frozenColCount > scene.table.frozenColCount) {
            scene.bodyGroup.setAttribute('height', scene.rowHeaderGroup.attribute.height);
            scene.bodyGroup.setAttribute('y', scene.rowHeaderGroup.attribute.y);
            scene.colHeaderGroup.setAttribute('height', scene.cornerHeaderGroup.attribute.height);
            for (let i = 0; i < scene.frozenColCount - scene.table.frozenColCount; i++) {
                moveColumnFromRowHeaderToBody(scene);
                moveColumnFromCornerHeaderToColHeader(scene);
                moveColumnFromLeftBottomCornerToBottom(scene);
            }
        }
        else if (scene.frozenColCount < scene.table.frozenColCount) {
            scene.rowHeaderGroup.setAttribute('height', scene.bodyGroup.attribute.height);
            scene.rowHeaderGroup.setAttribute('y', scene.bodyGroup.attribute.y);
            scene.cornerHeaderGroup.setAttribute('height', scene.colHeaderGroup.attribute.height);
            for (let i = 0; i < scene.table.frozenColCount - scene.frozenColCount; i++) {
                moveColumnFromBodyToRowHeader(scene);
                moveColumnFromColHeaderToCornerHeader(scene);
                moveColumnFromBottomToLeftBottomCorner(scene);
            }
        }
        updateReactComponentContainer(scene);
        scene.recreateAllSelectRangeComponents();
        scene.frozenColCount = scene.table.frozenColCount;
        scene.frozenRowCount =
            scene.colHeaderGroup.firstChild?.childrenCount ??
                scene.cornerHeaderGroup.firstChild?.childrenCount ??
                scene.table.frozenRowCount;
        scene.proxy.colStart = scene.bodyGroup.firstChild?.col ?? scene.table.frozenColCount;
        scene.bodyGroup.setAttribute('x', scene.rowHeaderGroup.attribute.width);
        scene.colHeaderGroup.setAttribute('x', scene.cornerHeaderGroup.attribute.width);
        scene.updateContainer();
        scene.updateBorderSizeAndPosition();
        if (!scene.isPivot && !scene.table.transpose) {
            scene.component.setFrozenColumnShadow(scene.table.frozenColCount - 1);
            scene.component.setRightFrozenColumnShadow(scene.table.colCount - scene.table.rightFrozenColCount);
        }
        else if (scene.table.options.frozenColCount) {
            scene.component.setFrozenColumnShadow(scene.table.frozenColCount - 1);
        }
        else if (scene.table.options.rightFrozenColCount) {
            scene.component.setRightFrozenColumnShadow(scene.table.colCount - scene.table.rightFrozenColCount);
        }
        scene.hasFrozen = true;
    }
    function moveColumnFromBodyToRowHeader(scene) {
        const column = scene.bodyGroup.firstChild instanceof Group$1 ? scene.bodyGroup.firstChild : null;
        if (column) {
            scene.rowHeaderGroup.appendChild(column);
            scene.rowHeaderGroup.setAttribute('width', scene.rowHeaderGroup.attribute.width + column.attribute.width);
            scene.bodyGroup.setAttribute('width', scene.bodyGroup.attribute.width - column.attribute.width);
        }
    }
    function moveColumnFromColHeaderToCornerHeader(scene) {
        const headerColumn = scene.colHeaderGroup.firstChild instanceof Group$1 ? scene.colHeaderGroup.firstChild : null;
        if (headerColumn) {
            scene.cornerHeaderGroup.appendChild(headerColumn);
            scene.cornerHeaderGroup.setAttribute('width', scene.cornerHeaderGroup.attribute.width + headerColumn.attribute.width);
            scene.colHeaderGroup.setAttribute('width', scene.colHeaderGroup.attribute.width - headerColumn.attribute.width);
        }
    }
    function moveColumnFromRowHeaderToBody(scene) {
        const column = scene.rowHeaderGroup.lastChild instanceof Group$1
            ? scene.rowHeaderGroup.lastChild
            : scene.rowHeaderGroup.lastChild?._prev;
        if (column) {
            insertBefore(scene.bodyGroup, column, scene.bodyGroup.firstChild);
            scene.bodyGroup.setAttribute('width', scene.bodyGroup.attribute.width + column.attribute.width);
            scene.rowHeaderGroup.setAttribute('width', scene.rowHeaderGroup.attribute.width - column.attribute.width);
        }
    }
    function moveColumnFromCornerHeaderToColHeader(scene) {
        const headerColumn = scene.cornerHeaderGroup.lastChild instanceof Group$1
            ? scene.cornerHeaderGroup.lastChild
            : scene.cornerHeaderGroup.lastChild?._prev;
        if (headerColumn) {
            insertBefore(scene.colHeaderGroup, headerColumn, scene.colHeaderGroup.firstChild);
            scene.colHeaderGroup.setAttribute('width', scene.colHeaderGroup.attribute.width + headerColumn.attribute.width);
            scene.cornerHeaderGroup.setAttribute('width', scene.cornerHeaderGroup.attribute.width - headerColumn.attribute.width);
        }
    }
    function moveColumnFromBottomToLeftBottomCorner(scene) {
        const column = scene.bottomFrozenGroup.firstChild instanceof Group$1 ? scene.bottomFrozenGroup.firstChild : null;
        if (column) {
            scene.leftBottomCornerGroup.appendChild(column);
            scene.leftBottomCornerGroup.setAttribute('width', scene.leftBottomCornerGroup.attribute.width + column.attribute.width);
            scene.bottomFrozenGroup.setAttribute('width', scene.bottomFrozenGroup.attribute.width - column.attribute.width);
            if (scene.table.isPivotChart()) {
                column.forEachChildren((child) => {
                    child.setAttributes({
                        stroke: false,
                        fill: false
                    });
                });
            }
        }
    }
    function moveColumnFromLeftBottomCornerToBottom(scene) {
        const column = scene.leftBottomCornerGroup.lastChild instanceof Group$1
            ? scene.leftBottomCornerGroup.lastChild
            : scene.leftBottomCornerGroup.lastChild?._prev;
        if (column) {
            insertBefore(scene.bottomFrozenGroup, column, scene.bottomFrozenGroup.firstChild);
            scene.bottomFrozenGroup.setAttribute('width', scene.bottomFrozenGroup.attribute.width + column.attribute.width);
            scene.leftBottomCornerGroup.setAttribute('width', scene.leftBottomCornerGroup.attribute.width - column.attribute.width);
            if (scene.table.isPivotChart()) {
                column.forEachChildren((child) => {
                    const cellStyle = scene.table._getCellStyle(child.col, child.row);
                    const range = scene.table.getCellRange(child.col, child.row);
                    const cellTheme = getStyleTheme(cellStyle, scene.table, range ? range.start.col : child.col, range ? range.start.row : child.row, getProp).theme;
                    child.setAttributes({
                        fill: cellTheme?.group?.fill ?? undefined,
                        stroke: cellTheme?.group?.stroke ?? undefined
                    });
                });
            }
        }
    }
    function dealRightFrozen(distRightFrozenCol, scene) {
        const { table, proxy, rightTopCornerGroup, rightFrozenGroup, rightBottomCornerGroup, bottomFrozenGroup, bodyGroup, colHeaderGroup } = scene;
        const currentRightFrozenCol = scene.table.rightFrozenColCount;
        if (distRightFrozenCol > currentRightFrozenCol) {
            for (let col = table.colCount - currentRightFrozenCol - 1; col >= table.colCount - distRightFrozenCol; col--) {
                const colGroup = scene.getColGroup(col);
                insertBefore(rightFrozenGroup, colGroup, rightFrozenGroup.firstChild);
                const headerColGroup = scene.getColGroup(col, true);
                insertBefore(rightTopCornerGroup, headerColGroup, rightTopCornerGroup.firstChild);
                const bottomColGroup = scene.getColGroupInBottom(col);
                insertBefore(rightBottomCornerGroup, bottomColGroup, rightBottomCornerGroup.firstChild);
            }
            let x = 0;
            rightFrozenGroup.forEachChildren((columnGroup) => {
                columnGroup.setAttribute('x', x);
                x += columnGroup.attribute.width;
            });
            x = 0;
            rightTopCornerGroup.forEachChildren((columnGroup) => {
                columnGroup.setAttribute('x', x);
                x += columnGroup.attribute.width;
            });
            x = 0;
            rightBottomCornerGroup.forEachChildren((columnGroup) => {
                columnGroup.setAttribute('x', x);
                x += columnGroup.attribute.width;
            });
        }
        else if (distRightFrozenCol < currentRightFrozenCol) {
            for (let col = table.colCount - currentRightFrozenCol; col < table.colCount - distRightFrozenCol; col++) {
                const colGroup = scene.getColGroup(col);
                colGroup.setAttribute('x', bodyGroup.lastChild.attribute.x + table.getColWidth(bodyGroup.lastChild.col));
                bodyGroup.appendChild(colGroup);
                const headerColGroup = scene.getColGroupInRightTopCorner(col);
                headerColGroup.setAttribute('x', colHeaderGroup.lastChild.attribute.x + table.getColWidth(colHeaderGroup.lastChild.col));
                colHeaderGroup.appendChild(headerColGroup);
                const bottomColGroup = scene.getColGroupInRightBottomCorner(col);
                bottomColGroup.setAttribute('x', bottomFrozenGroup.lastChild.attribute.x +
                    table.getColWidth(bottomFrozenGroup.lastChild.col));
                bottomFrozenGroup.appendChild(bottomColGroup);
            }
            let x = 0;
            rightFrozenGroup.forEachChildren((columnGroup) => {
                columnGroup.setAttribute('x', x);
                x += columnGroup.attribute.width;
            });
            x = 0;
            rightTopCornerGroup.forEachChildren((columnGroup) => {
                columnGroup.setAttribute('x', x);
                x += columnGroup.attribute.width;
            });
            x = 0;
            rightBottomCornerGroup.forEachChildren((columnGroup) => {
                columnGroup.setAttribute('x', x);
                x += columnGroup.attribute.width;
            });
        }
        rightFrozenGroup.setAttribute('width', table.getColsWidth(table.colCount - distRightFrozenCol, table.colCount - 1));
        rightTopCornerGroup.setAttribute('width', table.getColsWidth(table.colCount - distRightFrozenCol, table.colCount - 1));
        rightBottomCornerGroup.setAttribute('width', table.getColsWidth(table.colCount - distRightFrozenCol, table.colCount - 1));
        table.internalProps.rightFrozenColCount = distRightFrozenCol;
        scene.updateContainer();
        scene.component.updateScrollBar();
        scene.updateNextFrame();
    }
    function dealBottomFrozen(distBottomFrozenRow, scene) {
        const { table, proxy, bottomFrozenGroup, leftBottomCornerGroup, rightBottomCornerGroup } = scene;
        if (!bottomFrozenGroup.childrenCount) {
            if (!proxy.table.isPivotChart()) {
                createColGroup(leftBottomCornerGroup, 0, 0, 0, table.frozenColCount - 1, 0, -1, 'rowHeader', table);
                createColGroup(rightBottomCornerGroup, 0, 0, table.colCount - table.rightFrozenColCount, table.colCount - 1, 0, -1, 'body', table);
            }
            createColGroup(bottomFrozenGroup, 0, 0, proxy.colStart, proxy.colEnd, 0, -1, 'body', table);
        }
        const currentBottomFrozenRow = scene.table.bottomFrozenRowCount;
        if (distBottomFrozenRow > currentBottomFrozenRow) {
            for (let col = 0; col < table.frozenColCount; col++) {
                const bottomFrozenColumnGroup = scene.getColGroupInLeftBottomCorner(col);
                for (let row = table.rowCount - currentBottomFrozenRow - 1; row >= table.rowCount - distBottomFrozenRow; row--) {
                    const cellGroup = scene.getCell(col, row, true);
                    insertBefore(bottomFrozenColumnGroup, cellGroup, bottomFrozenColumnGroup.firstChild);
                }
                let y = 0;
                bottomFrozenColumnGroup.forEachChildren((cellGroup) => {
                    cellGroup.setAttribute('y', y);
                    y += table.getRowHeight(cellGroup.row);
                });
            }
            for (let col = proxy.colStart; col <= proxy.colEnd; col++) {
                const bottomFrozenColumnGroup = scene.getColGroupInBottom(col);
                for (let row = table.rowCount - currentBottomFrozenRow - 1; row >= table.rowCount - distBottomFrozenRow; row--) {
                    const cellGroup = scene.getCell(col, row, true);
                    insertBefore(bottomFrozenColumnGroup, cellGroup, bottomFrozenColumnGroup.firstChild);
                }
                let y = 0;
                bottomFrozenColumnGroup.forEachChildren((cellGroup) => {
                    cellGroup.setAttribute('y', y);
                    y += table.getRowHeight(cellGroup.row);
                });
            }
            if (table.rightFrozenColCount > 0) {
                for (let col = table.colCount - table.rightFrozenColCount; col < table.colCount; col++) {
                    const bottomFrozenColumnGroup = scene.getColGroupInRightBottomCorner(col);
                    for (let row = table.rowCount - currentBottomFrozenRow - 1; row >= table.rowCount - distBottomFrozenRow; row--) {
                        const cellGroup = scene.getCell(col, row, true);
                        insertBefore(bottomFrozenColumnGroup, cellGroup, bottomFrozenColumnGroup.firstChild);
                    }
                    let y = 0;
                    bottomFrozenColumnGroup.forEachChildren((cellGroup) => {
                        cellGroup.setAttribute('y', y);
                        y += table.getRowHeight(cellGroup.row);
                    });
                }
            }
        }
        else if (distBottomFrozenRow < currentBottomFrozenRow) {
            for (let col = 0; col < table.rowHeaderLevelCount; col++) {
                const columnGroup = scene.getColGroup(col);
                for (let row = table.rowCount - currentBottomFrozenRow; row < table.rowCount - distBottomFrozenRow; row++) {
                    const cellGroup = scene.getCell(col, row, true);
                    cellGroup.setAttribute('y', columnGroup.lastChild.attribute.y + table.getRowHeight(columnGroup.lastChild.row));
                    columnGroup.appendChild(cellGroup);
                }
                const bottomFrozenColumnGroup = scene.getColGroupInLeftBottomCorner(col);
                let y = 0;
                bottomFrozenColumnGroup.forEachChildren((cellGroup) => {
                    cellGroup.setAttribute('y', y);
                    y += table.getRowHeight(cellGroup.row);
                });
            }
            for (let col = proxy.colStart; col <= proxy.colEnd; col++) {
                const columnGroup = scene.getColGroup(col);
                for (let row = table.rowCount - currentBottomFrozenRow; row < table.rowCount - distBottomFrozenRow; row++) {
                    const cellGroup = scene.getCell(col, row, true);
                    cellGroup.setAttribute('y', columnGroup.lastChild.attribute.y + table.getRowHeight(columnGroup.lastChild.row));
                    columnGroup.appendChild(cellGroup);
                }
                const bottomFrozenColumnGroup = scene.getColGroupInBottom(col);
                let y = 0;
                bottomFrozenColumnGroup.forEachChildren((cellGroup) => {
                    cellGroup.setAttribute('y', y);
                    y += table.getRowHeight(cellGroup.row);
                });
            }
            if (table.rightFrozenColCount > 0) {
                for (let col = table.colCount - table.rightFrozenColCount; col < table.colCount; col++) {
                    const columnGroup = scene.getColGroup(col);
                    for (let row = table.rowCount - currentBottomFrozenRow; row < table.rowCount - distBottomFrozenRow; row++) {
                        const cellGroup = scene.getCell(col, row, true);
                        cellGroup.setAttribute('y', columnGroup.lastChild.attribute.y + table.getRowHeight(columnGroup.lastChild.row));
                        columnGroup.appendChild(cellGroup);
                    }
                    const bottomFrozenColumnGroup = scene.getColGroupInRightBottomCorner(col);
                    let y = 0;
                    bottomFrozenColumnGroup.forEachChildren((cellGroup) => {
                        cellGroup.setAttribute('y', y);
                        y += table.getRowHeight(cellGroup.row);
                    });
                }
            }
        }
        bottomFrozenGroup.setAttribute('height', table.getRowsHeight(table.rowCount - distBottomFrozenRow, table.rowCount - 1));
        leftBottomCornerGroup.setAttribute('height', table.getRowsHeight(table.rowCount - distBottomFrozenRow, table.rowCount - 1));
        rightBottomCornerGroup.setAttribute('height', table.getRowsHeight(table.rowCount - distBottomFrozenRow, table.rowCount - 1));
        table.internalProps.bottomFrozenRowCount = distBottomFrozenRow;
        scene.updateContainer();
        scene.component.updateScrollBar();
        scene.updateNextFrame();
    }
    function insertBefore(container, newNode, targetGroup) {
        if (!newNode || !container) {
            return;
        }
        if (targetGroup) {
            container.insertBefore(newNode, targetGroup);
        }
        else {
            container.appendChild(newNode);
        }
    }
    function resetRowFrozen(scene) {
        if (scene.frozenRowCount > scene.table.frozenRowCount) {
            scene.bodyGroup.setAttribute('width', scene.colHeaderGroup.attribute.width);
            scene.bodyGroup.setAttribute('x', scene.colHeaderGroup.attribute.x);
            scene.rowHeaderGroup.setAttribute('width', scene.cornerHeaderGroup.attribute.width);
            for (let i = 0; i < scene.frozenRowCount - scene.table.frozenRowCount; i++) {
                moveRowFromColHeaderToBody(scene);
                moveRowFromCornerHeaderToRowHeader(scene);
                moveRowFromTopRightCornerToRight(scene);
            }
        }
        else if (scene.frozenRowCount < scene.table.frozenRowCount) {
            scene.colHeaderGroup.setAttribute('width', scene.bodyGroup.attribute.width);
            scene.colHeaderGroup.setAttribute('x', scene.bodyGroup.attribute.x);
            scene.cornerHeaderGroup.setAttribute('width', scene.rowHeaderGroup.attribute.width);
            for (let i = 0; i < scene.table.frozenRowCount - scene.frozenRowCount; i++) {
                moveRowFromBodyToColHeader(scene);
                moveRowFromRowHeaderToCornerHeader(scene);
                moveRowFromRightToTopRightCorner(scene);
            }
        }
        updateReactComponentContainer(scene);
        scene.recreateAllSelectRangeComponents();
        scene.frozenRowCount = scene.table.frozenRowCount;
        scene.frozenColCount = scene.rowHeaderGroup?.childrenCount ?? 0;
        scene.proxy.rowStart = scene.bodyGroup.firstChild?.firstChild?.row ?? scene.table.frozenRowCount;
        scene.bodyGroup.setAttribute('y', scene.colHeaderGroup.attribute.height);
        scene.rowHeaderGroup.setAttribute('y', scene.cornerHeaderGroup.attribute.height);
        scene.updateContainer();
        scene.updateBorderSizeAndPosition();
        scene.hasFrozen = true;
    }
    function moveRowFromBodyToColHeader(scene) {
        let hasSetedHeight = false;
        for (let i = 0; i < scene.bodyGroup.childrenCount; i++) {
            const child = scene.bodyGroup.children[i];
            if (!checkBeforeMove(child)) {
                continue;
            }
            const rowCell = child.firstChild;
            scene.colHeaderGroup.children[i]?.appendChild(rowCell);
            if (!hasSetedHeight) {
                scene.colHeaderGroup.setAttribute('height', scene.colHeaderGroup.attribute.height + rowCell.attribute.height);
                scene.bodyGroup.setAttribute('height', scene.bodyGroup.attribute.height - rowCell.attribute.height);
                hasSetedHeight = true;
            }
        }
    }
    function moveRowFromRowHeaderToCornerHeader(scene) {
        let hasSetedHeight = false;
        for (let i = 0; i < scene.rowHeaderGroup.childrenCount; i++) {
            const child = scene.rowHeaderGroup.children[i];
            if (!checkBeforeMove(child)) {
                continue;
            }
            const rowCell = child.firstChild;
            scene.cornerHeaderGroup.children[i]?.appendChild(rowCell);
            if (!hasSetedHeight) {
                scene.cornerHeaderGroup.setAttribute('height', scene.cornerHeaderGroup.attribute.height + rowCell.attribute.height);
                scene.rowHeaderGroup.setAttribute('height', scene.rowHeaderGroup.attribute.height - rowCell.attribute.height);
                hasSetedHeight = true;
            }
        }
    }
    function moveRowFromRightToTopRightCorner(scene) {
        let hasSetedHeight = false;
        for (let i = 0; i < scene.rightFrozenGroup.childrenCount; i++) {
            const child = scene.rightFrozenGroup.children[i];
            if (!checkBeforeMove(child)) {
                continue;
            }
            const rowCell = child.firstChild;
            scene.rightTopCornerGroup.children[i]?.appendChild(rowCell);
            if (!hasSetedHeight) {
                scene.rightTopCornerGroup.setAttribute('height', scene.rightTopCornerGroup.attribute.height + rowCell.attribute.height);
                scene.rightFrozenGroup.setAttribute('height', scene.rightFrozenGroup.attribute.height - rowCell.attribute.height);
                hasSetedHeight = true;
            }
        }
    }
    function moveRowFromColHeaderToBody(scene) {
        let hasSetedHeight = false;
        for (let i = 0; i < scene.colHeaderGroup.childrenCount; i++) {
            const child = scene.colHeaderGroup.children[i];
            if (!checkBeforeMove(child)) {
                continue;
            }
            const target = scene.bodyGroup.children[i];
            if (!target) {
                continue;
            }
            const rowCell = child.lastChild;
            insertBefore(target, rowCell, target.firstChild);
            if (!hasSetedHeight) {
                scene.colHeaderGroup.setAttribute('height', scene.colHeaderGroup.attribute.height - rowCell.attribute.height);
                scene.bodyGroup.setAttribute('height', scene.bodyGroup.attribute.height + rowCell.attribute.height);
                hasSetedHeight = true;
            }
        }
    }
    function moveRowFromCornerHeaderToRowHeader(scene) {
        let hasSetedHeight = false;
        for (let i = 0; i < scene.cornerHeaderGroup.childrenCount; i++) {
            const child = scene.cornerHeaderGroup.children[i];
            if (!checkBeforeMove(child)) {
                continue;
            }
            const target = scene.rowHeaderGroup.children[i];
            if (!target) {
                continue;
            }
            const rowCell = child.lastChild;
            insertBefore(target, rowCell, target.firstChild);
            if (!hasSetedHeight) {
                scene.cornerHeaderGroup.setAttribute('height', scene.cornerHeaderGroup.attribute.height - rowCell.attribute.height);
                scene.rowHeaderGroup.setAttribute('height', scene.rowHeaderGroup.attribute.height + rowCell.attribute.height);
                hasSetedHeight = true;
            }
        }
    }
    function moveRowFromTopRightCornerToRight(scene) {
        let hasSetedHeight = false;
        for (let i = 0; i < scene.rightTopCornerGroup.childrenCount; i++) {
            const child = scene.rightTopCornerGroup.children[i];
            if (!checkBeforeMove(child)) {
                continue;
            }
            const target = scene.rightFrozenGroup.children[i];
            if (!target) {
                continue;
            }
            const rowCell = child.lastChild;
            insertBefore(target, rowCell, target.firstChild);
            if (!hasSetedHeight) {
                scene.rightTopCornerGroup.setAttribute('height', scene.rightTopCornerGroup.attribute.height - rowCell.attribute.height);
                scene.rightFrozenGroup.setAttribute('height', scene.rightFrozenGroup.attribute.height + rowCell.attribute.height);
                hasSetedHeight = true;
            }
        }
    }
    function checkBeforeMove(child) {
        return child instanceof Group$1 && child?.name !== 'table-border-rect';
    }

    function updateChartSizeForResizeColWidth(scenegraph, col) {
        const { table } = scenegraph;
        const layout = table.internalProps.layoutMap;
        const columnResizeType = col === -1 ? 'all' : table.internalProps.columnResizeType;
        if (columnResizeType === 'column') {
            const columnGroup = scenegraph.getColGroup(col);
            const columnHeaderGroup = scenegraph.getColGroup(col, true);
            const columnBottomGroup = scenegraph.getColGroupInBottom(col, true);
            columnGroup?.forEachChildren((cellNode) => {
                const width = table.getColWidth(cellNode.col);
                const height = table.getRowHeight(cellNode.row);
                updateChartGraphicSize(cellNode, width, height);
            });
            columnHeaderGroup?.forEachChildren((cellNode) => {
                const width = table.getColWidth(cellNode.col);
                const height = table.getRowHeight(cellNode.row);
                updateChartGraphicSize(cellNode, width, height);
            });
            columnBottomGroup?.forEachChildren((cellNode) => {
                const width = table.getColWidth(cellNode.col);
                const height = table.getRowHeight(cellNode.row);
                updateChartGraphicSize(cellNode, width, height);
            });
            if (table.widthMode === 'adaptive' && col < table.colCount - 1) {
                const columnGroup = scenegraph.getColGroup(col + 1);
                const columnHeaderGroup = scenegraph.getColGroup(col + 1, true);
                const columnBottomGroup = scenegraph.getColGroupInBottom(col + 1, true);
                columnGroup?.forEachChildren((cellNode) => {
                    const width = table.getColWidth(cellNode.col);
                    const height = table.getRowHeight(cellNode.row);
                    updateChartGraphicSize(cellNode, width, height);
                });
                columnHeaderGroup?.forEachChildren((cellNode) => {
                    const width = table.getColWidth(cellNode.col);
                    const height = table.getRowHeight(cellNode.row);
                    updateChartGraphicSize(cellNode, width, height);
                });
                columnBottomGroup?.forEachChildren((cellNode) => {
                    const width = table.getColWidth(cellNode.col);
                    const height = table.getRowHeight(cellNode.row);
                    updateChartGraphicSize(cellNode, width, height);
                });
            }
        }
        else {
            let startCol = table.rowHeaderLevelCount;
            let endCol = table.colCount - 1;
            let resizeIndicatorKey;
            let resizeDimensionKey;
            let resizeDimensionValue;
            if (columnResizeType === 'indicator') {
                if (layout.indicatorsAsCol) {
                    resizeIndicatorKey = layout.getIndicatorKey(col, table.columnHeaderLevelCount);
                }
                else {
                    const headerPaths = layout.getCellHeaderPaths(col, table.columnHeaderLevelCount - 1);
                    const headerPath = headerPaths.colHeaderPaths[headerPaths.colHeaderPaths.length - 1];
                    resizeDimensionKey = headerPath.dimensionKey;
                    resizeDimensionValue = headerPath.value;
                }
            }
            else if (columnResizeType === 'indicatorGroup') {
                const layout = table.internalProps.layoutMap;
                const headerPaths = layout.getCellHeaderPaths(table.stateManager.columnResize.col, table.columnHeaderLevelCount);
                const node = layout.getHeadNodeByRowOrColDimensions(headerPaths.colHeaderPaths.slice(0, headerPaths.colHeaderPaths.length - 1));
                startCol = node.startInTotal + table.frozenColCount;
                endCol = node.startInTotal + table.frozenColCount + node.size - 1;
            }
            for (let c = startCol; c <= endCol; c++) {
                const columnGroup = scenegraph.getColGroup(c);
                const columnHeaderGroup = scenegraph.getColGroup(c, true);
                const columnBottomGroup = scenegraph.getColGroupInBottom(c, true);
                if (columnGroup) {
                    if (columnResizeType === 'indicator') {
                        const indicatorKey = layout.getIndicatorKey(c, table.columnHeaderLevelCount);
                        if (layout.indicatorsAsCol && indicatorKey !== resizeIndicatorKey) {
                            continue;
                        }
                        else if (!layout.indicatorsAsCol) {
                            const headerPaths = layout.getCellHeaderPaths(c, table.columnHeaderLevelCount - 1);
                            const headerPath = headerPaths?.colHeaderPaths[headerPaths.colHeaderPaths.length - 1];
                            if (!headerPath ||
                                resizeDimensionKey !== headerPath.dimensionKey ||
                                resizeDimensionValue !== headerPath.value) {
                                continue;
                            }
                        }
                    }
                    columnGroup.forEachChildren((cellNode) => {
                        const width = table.getColWidth(cellNode.col);
                        const height = table.getRowHeight(cellNode.row);
                        updateChartGraphicSize(cellNode, width, height);
                    });
                    columnHeaderGroup?.forEachChildren((cellNode) => {
                        const width = table.getColWidth(cellNode.col);
                        const height = table.getRowHeight(cellNode.row);
                        updateChartGraphicSize(cellNode, width, height);
                    });
                    columnBottomGroup?.forEachChildren((cellNode) => {
                        const width = table.getColWidth(cellNode.col);
                        const height = table.getRowHeight(cellNode.row);
                        updateChartGraphicSize(cellNode, width, height);
                    });
                }
            }
        }
    }
    function updateChartSizeForResizeRowHeight(scenegraph, row) {
        const { table } = scenegraph;
        const layout = table.internalProps.layoutMap;
        const state = table.stateManager;
        const rowResizeType = row === -1 ? 'all' : table.internalProps.rowResizeType;
        let startRow = table.columnHeaderLevelCount;
        let endRow = table.rowCount - 1;
        let resizeIndicatorKey;
        let resizeDimensionKey;
        let resizeDimensionValue;
        if (rowResizeType === 'indicator') {
            if (!layout.indicatorsAsCol) {
                resizeIndicatorKey = layout.getIndicatorKey(table.rowHeaderLevelCount, row);
            }
            else {
                const headerPaths = layout.getCellHeaderPaths(table.rowHeaderLevelCount - 1, row);
                const headerPath = headerPaths.rowHeaderPaths?.[headerPaths.rowHeaderPaths.length - 1];
                resizeDimensionKey = headerPath?.dimensionKey;
                resizeDimensionValue = headerPath?.value;
            }
        }
        else if (rowResizeType === 'indicatorGroup') {
            const layout = table.internalProps.layoutMap;
            const headerPaths = layout.getCellHeaderPaths(table.rowHeaderLevelCount, row);
            const node = layout.getHeadNodeByRowOrColDimensions(headerPaths.rowHeaderPaths.slice(0, headerPaths.rowHeaderPaths.length - 1));
            startRow = node.startInTotal + table.frozenRowCount;
            endRow = node.startInTotal + table.frozenRowCount + node.size - 1;
        }
        const colsRange = [{ startCol: scenegraph.proxy.colStart, endCol: scenegraph.proxy.colEnd }];
        if (table.frozenColCount) {
            colsRange.push({ startCol: 0, endCol: table.frozenColCount - 1 });
        }
        if (table.rightFrozenColCount) {
            colsRange.push({ startCol: table.colCount - table.rightFrozenColCount, endCol: table.colCount - 1 });
        }
        colsRange.forEach(({ startCol, endCol }) => {
            for (let col = startCol; col <= endCol; col++) {
                if (rowResizeType === 'row') {
                    const cellNode = scenegraph.highPerformanceGetCell(col, row);
                    if (cellNode.role !== 'cell') {
                        continue;
                    }
                    const width = table.getColWidth(cellNode.col);
                    const height = table.getRowHeight(cellNode.row);
                    updateChartGraphicSize(cellNode, width, height);
                    if (table.heightMode === 'adaptive' && row < table.rowCount - 1) {
                        const cellNode = scenegraph.highPerformanceGetCell(col, row + 1);
                        const width = table.getColWidth(cellNode.col);
                        const height = table.getRowHeight(cellNode.row);
                        updateChartGraphicSize(cellNode, width, height);
                    }
                }
                else {
                    for (let r = startRow; r <= endRow; r++) {
                        if (rowResizeType === 'indicator') {
                            const indicatorKey = layout.getIndicatorKey(state.table.rowHeaderLevelCount, r);
                            if (!layout.indicatorsAsCol && indicatorKey !== resizeIndicatorKey) {
                                continue;
                            }
                            else if (layout.indicatorsAsCol) {
                                const headerPaths = layout.getCellHeaderPaths(state.table.rowHeaderLevelCount - 1, r);
                                const headerPath = headerPaths?.rowHeaderPaths[headerPaths.rowHeaderPaths.length - 1];
                                if (!headerPath ||
                                    resizeDimensionKey !== headerPath.dimensionKey ||
                                    resizeDimensionValue !== headerPath.value) {
                                    continue;
                                }
                            }
                        }
                        const cellNode = scenegraph.highPerformanceGetCell(col, r);
                        if (cellNode.role !== 'cell') {
                            continue;
                        }
                        const width = table.getColWidth(cellNode.col);
                        const height = table.getRowHeight(cellNode.row);
                        updateChartGraphicSize(cellNode, width, height);
                    }
                }
            }
        });
    }
    function clearChartCacheImage(scenegraph) {
        for (let c = scenegraph.proxy.colStart; c <= scenegraph.proxy.colEnd; c++) {
            const columnGroup = scenegraph.getColGroup(c);
            columnGroup?.getChildren()?.forEach((cellNode) => {
                cellNode.children.forEach((node) => {
                    if (node.type === 'chart') {
                        node.cacheCanvas = null;
                        node.addUpdateBoundTag();
                    }
                });
            });
        }
    }
    function clearCellChartCacheImage(col, row, scenegraph) {
        const cellGroup = scenegraph.getCell(col, row);
        cellGroup.children.forEach((node) => {
            if (node.type === 'chart') {
                node.cacheCanvas = null;
                node.addUpdateBoundTag();
            }
        });
    }
    function updateChartData(scenegraph) {
        const table = scenegraph.table;
        for (let c = scenegraph.proxy.colStart; c <= scenegraph.proxy.colEnd; c++) {
            const columnGroup = scenegraph.getColGroup(c);
            columnGroup?.getChildren()?.forEach((cellNode) => {
                const col = cellNode.col;
                const row = cellNode.row;
                cellNode.children.forEach((node) => {
                    if (node.type === 'chart') {
                        node.updateData(table.getCellValue(col, row));
                        const chartSpec = node.attribute.spec;
                        const chartType = chartSpec.type;
                        if (chartType !== 'gauge' && chartType !== 'rose' && chartType !== 'radar') {
                            const newAxes = table.internalProps.layoutMap.getChartAxes(col, row);
                            node.setAttribute('axes', newAxes);
                            chartSpec.axes = newAxes;
                        }
                        node.setAttribute('spec', chartSpec);
                    }
                });
            });
        }
        updateTableAxes(scenegraph.rowHeaderGroup, scenegraph.table);
        updateTableAxes(scenegraph.colHeaderGroup, scenegraph.table);
        updateTableAxes(scenegraph.rightFrozenGroup, scenegraph.table);
        updateTableAxes(scenegraph.bottomFrozenGroup, scenegraph.table);
    }
    function updateChartState(scenegraph, datum) {
        const table = scenegraph.table;
        if (table.isPivotChart()) {
            const preSelectItemsCount = table._selectedDataItemsInChart.length;
            if ((datum === null || datum?.length === 0 || Object.keys(datum).length === 0) && preSelectItemsCount === 0) {
                return;
            }
            const newSelectedDataItemsInChart = [];
            if (Array.isArray(datum)) {
                datum.forEach((dataItem) => {
                    if (dataItem && dataItem.key !== 0 && Object.keys(dataItem).length > 0) {
                        const selectedState = {};
                        for (const itemKey in dataItem) {
                            if (!itemKey.startsWith('VGRAMMAR_') && !itemKey.startsWith('__VCHART')) {
                                selectedState[itemKey] = dataItem[itemKey];
                            }
                        }
                        newSelectedDataItemsInChart.push(selectedState);
                    }
                });
            }
            else if (datum && datum.key !== 0 && Object.keys(datum).length > 0) {
                const selectedState = {};
                for (const itemKey in datum) {
                    if (!itemKey.startsWith('VGRAMMAR_') && !itemKey.startsWith('__VCHART')) {
                        selectedState[itemKey] = datum[itemKey];
                    }
                }
                newSelectedDataItemsInChart.push(selectedState);
            }
            if (!isEqual(table._selectedDataItemsInChart, newSelectedDataItemsInChart)) {
                table._selectedDataItemsInChart = newSelectedDataItemsInChart;
                table.internalProps.layoutMap.updateDataStateToChartInstance();
                clearChartCacheImage(scenegraph);
                table.scenegraph.updateNextFrame();
            }
        }
    }
    function updateTableAxes(containerGroup, table) {
        containerGroup.forEachChildren((column) => {
            if (column.role === 'column') {
                column.forEachChildren((cell) => {
                    if (cell.role === 'cell') {
                        let isAxisComponent = false;
                        cell.forEachChildren((mark) => {
                            if (mark.name === 'axis') {
                                isAxisComponent = true;
                                return true;
                            }
                            return false;
                        });
                        if (isAxisComponent) {
                            const axisConfig = table.internalProps.layoutMap.getAxisConfigInPivotChart(cell.col, cell.row);
                            const cellStyle = table._getCellStyle(cell.col, cell.row);
                            const padding = getQuadProps(getProp('padding', cellStyle, cell.col, cell.row, table));
                            const CartesianAxis = Factory.getComponent('axis');
                            const axis = new CartesianAxis(axisConfig, cell.attribute.width, cell.attribute.height, axisConfig.__vtablePadding ?? padding, table);
                            cell.clear();
                            cell.appendChild(axis.component);
                            axis.overlap();
                        }
                    }
                });
            }
        });
    }
    function updateChartGraphicSize(cellNode, width, height) {
        cellNode.forEachChildren((graphic) => {
            if (graphic.type === 'chart') {
                graphic.cacheCanvas = null;
                graphic.setAttributes({
                    width: Math.ceil(width - graphic.attribute.cellPadding[3] - graphic.attribute.cellPadding[1]),
                    height: Math.ceil(height - graphic.attribute.cellPadding[0] - graphic.attribute.cellPadding[2])
                });
            }
        });
    }

    function initSceneGraph(scene) {
        const width = scene.table.tableNoFrameWidth;
        const height = scene.table.tableNoFrameHeight;
        scene.tableGroup = new Group$1({ x: 0, y: 0, width, height, clip: true, pickable: false });
        scene.tableGroup.role = 'table';
        const colHeaderGroup = createContainerGroup(0, 0, !scene.table.options.enableTreeStickCell);
        colHeaderGroup.role = 'col-header';
        scene.colHeaderGroup = colHeaderGroup;
        const cornerHeaderGroup = createContainerGroup(0, 0, !scene.table.options.enableTreeStickCell);
        cornerHeaderGroup.role = 'corner-header';
        scene.cornerHeaderGroup = cornerHeaderGroup;
        const rowHeaderGroup = createContainerGroup(0, 0, true);
        rowHeaderGroup.role = 'row-header';
        scene.rowHeaderGroup = rowHeaderGroup;
        const bodyGroup = createContainerGroup(width, 0, true);
        bodyGroup.role = 'body';
        scene.bodyGroup = bodyGroup;
        const rightFrozenGroup = createContainerGroup(0, 0, true);
        rightFrozenGroup.role = 'right-frozen';
        scene.rightFrozenGroup = rightFrozenGroup;
        const bottomFrozenGroup = createContainerGroup(0, 0, true);
        bottomFrozenGroup.role = 'bottom-frozen';
        scene.bottomFrozenGroup = bottomFrozenGroup;
        const componentGroup = createContainerGroup(0, 0);
        componentGroup.role = 'component';
        scene.componentGroup = componentGroup;
        const rightTopCornerGroup = createContainerGroup(0, 0, true);
        rightTopCornerGroup.role = 'corner-right-top-header';
        scene.rightTopCornerGroup = rightTopCornerGroup;
        const rightBottomCornerGroup = createContainerGroup(0, 0, true);
        rightBottomCornerGroup.role = 'corner-right-bottom-header';
        scene.rightBottomCornerGroup = rightBottomCornerGroup;
        const leftBottomCornerGroup = createContainerGroup(0, 0, true);
        leftBottomCornerGroup.role = 'corner-left-bottom-header';
        scene.leftBottomCornerGroup = leftBottomCornerGroup;
        scene.tableGroup.addChild(bodyGroup);
        scene.tableGroup.addChild(rowHeaderGroup);
        scene.tableGroup.addChild(bottomFrozenGroup);
        scene.tableGroup.addChild(colHeaderGroup);
        scene.tableGroup.addChild(rightFrozenGroup);
        scene.tableGroup.addChild(rightBottomCornerGroup);
        scene.tableGroup.addChild(rightTopCornerGroup);
        scene.tableGroup.addChild(leftBottomCornerGroup);
        scene.tableGroup.addChild(cornerHeaderGroup);
        scene.tableGroup.addChild(componentGroup);
    }
    function createContainerGroup(width, height, clip) {
        return new Group$1({
            x: 0,
            y: 0,
            width,
            height,
            clip: clip ?? false,
            pickable: false
        });
    }

    function updateContainerChildrenX(containerGroup, x) {
        containerGroup.forEachChildrenSkipChild((column, index) => {
            column.setAttribute('x', x);
            x += column.attribute.width;
        });
        return x;
    }

    function hideHoverIcon(col, row, scene) {
        if (col === -1 || row === -1) {
            return;
        }
        updateCellRangeIcon(col, row, (icon) => icon.attribute.visibleTime === 'mouseenter_cell', (icon) => {
            icon.setAttribute('opacity', 0);
            const iconBack = icon.parent.getChildByName('icon-back');
            if (iconBack) {
                iconBack.setAttribute('visible', false);
            }
        }, scene);
        scene.updateNextFrame();
    }
    function showHoverIcon(col, row, scene) {
        if (col === -1 || row === -1) {
            return;
        }
        updateCellRangeIcon(col, row, (icon) => icon.attribute.visibleTime === 'mouseenter_cell', (icon) => {
            icon.setAttribute('opacity', 1);
        }, scene);
        scene.updateNextFrame();
    }
    function hideClickIcon(col, row, scene) {
        if (col === -1 || row === -1) {
            return;
        }
        updateCellRangeIcon(col, row, (icon) => icon.attribute.visibleTime === 'click_cell', (icon) => {
            icon.setAttribute('opacity', 0);
        }, scene);
        scene.updateNextFrame();
    }
    function showClickIcon(col, row, scene) {
        if (col === -1 || row === -1) {
            return;
        }
        updateCellRangeIcon(col, row, (icon) => icon.attribute.visibleTime === 'click_cell', (icon) => {
            icon.setAttribute('opacity', 1);
        }, scene);
        scene.updateNextFrame();
    }
    function getIconByXY(col, row, x, y, scene) {
        const cellGroup = scene.getCell(col, row);
        let pickMark;
        cellGroup.forEachChildren((mark) => {
            if (mark.role && mark.role.startsWith('icon') && mark.containsPoint(x, y, IContainPointMode.GLOBAL)) {
                pickMark = mark;
            }
        });
        return pickMark;
    }
    function setIconHoverStyle(baseIcon, col, row, cellGroup, scene) {
        if (baseIcon.attribute.backgroundColor || baseIcon.attribute.hoverImage) {
            updateCellRangeIcon(col, row, (icon) => icon.name === baseIcon.name, (icon) => {
                if (icon.attribute.backgroundColor) {
                    let iconBack = icon.parent.getChildByName('icon-back');
                    if (iconBack) {
                        iconBack.setAttributes({
                            x: (icon.attribute.x ?? 0) +
                                (icon.AABBBounds.width() - icon.backgroundWidth) / 2,
                            y: (icon.attribute.y ?? 0) + (icon.AABBBounds.height() - icon.backgroundHeight) / 2,
                            dx: icon.attribute.dx ?? 0,
                            dy: icon.attribute.dy ?? 0,
                            width: icon.backgroundWidth,
                            height: icon.backgroundHeight,
                            fill: icon.attribute.backgroundColor,
                            cornerRadius: 5,
                            visible: true
                        });
                    }
                    else {
                        iconBack = createRect({
                            x: (icon.attribute.x ?? 0) +
                                (icon.AABBBounds.width() - icon.backgroundWidth) / 2,
                            y: (icon.attribute.y ?? 0) + (icon.AABBBounds.height() - icon.backgroundHeight) / 2,
                            dx: icon.attribute.dx ?? 0,
                            dy: icon.attribute.dy ?? 0,
                            width: icon.backgroundWidth,
                            height: icon.backgroundHeight,
                            fill: icon.attribute.backgroundColor,
                            cornerRadius: 5,
                            pickable: false,
                            visible: true
                        });
                        iconBack.name = 'icon-back';
                    }
                    icon.parent.insertBefore(iconBack, icon);
                }
                if (icon.attribute.hoverImage && icon.attribute.image !== icon.attribute.hoverImage) {
                    icon.image = icon.attribute.hoverImage;
                }
            }, scene);
        }
        if (baseIcon.tooltip) {
            const { x1: left, x2: right, y1: top, y2: bottom } = baseIcon.globalAABBBounds;
            const tooltipOptions = {
                content: baseIcon.tooltip.title,
                referencePosition: {
                    rect: {
                        left: left,
                        right: right,
                        top: top,
                        bottom: bottom,
                        width: baseIcon.globalAABBBounds.width(),
                        height: baseIcon.globalAABBBounds.height()
                    },
                    placement: baseIcon.tooltip.placement
                },
                disappearDelay: baseIcon.tooltip.disappearDelay,
                style: Object.assign({}, scene.table.internalProps.theme?.tooltipStyle, baseIcon.tooltip?.style)
            };
            if (!scene.table.internalProps.tooltipHandler.isBinded(tooltipOptions)) {
                scene.table.showTooltip(col, row, tooltipOptions);
            }
        }
    }
    function setIconNormalStyle(baseIcon, col, row, scene) {
        if (baseIcon.attribute.backgroundColor || baseIcon.attribute.hoverImage) {
            updateCellRangeIcon(col, row, (icon) => icon.name === baseIcon.name, (icon) => {
                const iconBack = icon.parent.getChildByName('icon-back');
                if (iconBack) {
                    iconBack.setAttribute('visible', false);
                }
                if (icon.attribute.hoverImage && icon.attribute.image !== icon.attribute.originImage) {
                    icon.image = icon.attribute.originImage;
                }
            }, scene);
        }
    }
    function updateIcon(baseIcon, iconConfig, col, row, scene) {
        const iconName = baseIcon.name;
        updateCellRangeIcon(col, row, (icon) => icon.name === iconName, (icon) => {
            dealWithIcon(iconConfig, icon);
            icon.name = iconConfig.name;
        }, scene);
        scene.updateNextFrame();
    }
    function resetSortIcon(oldSortCol, oldSortRow, iconConfig, scene) {
        const oldSortCell = scene.getCell(oldSortCol, oldSortRow);
        if (isValid$3(oldSortCell.mergeStartCol) &&
            isValid$3(oldSortCell.mergeStartRow) &&
            isValid$3(oldSortCell.mergeEndCol) &&
            isValid$3(oldSortCell.mergeEndRow)) {
            for (let col = oldSortCell.mergeStartCol; col <= oldSortCell.mergeEndCol; col++) {
                for (let row = oldSortCell.mergeStartRow; row <= oldSortCell.mergeEndRow; row++) {
                    let oldIconMark;
                    scene.getCell(col, row).forEachChildren((mark) => {
                        if (mark.attribute.funcType === 'sort') {
                            oldIconMark = mark;
                            return true;
                        }
                        return false;
                    });
                    if (oldIconMark) {
                        dealWithIcon(iconConfig, oldIconMark);
                        oldIconMark.name = iconConfig.name;
                    }
                }
            }
        }
        else {
            let oldIconMark;
            traverseObject(oldSortCell, 'children', (mark) => {
                if (mark.attribute.funcType === 'sort') {
                    oldIconMark = mark;
                    return true;
                }
                return false;
            });
            if (oldIconMark) {
                dealWithIcon(iconConfig, oldIconMark);
                oldIconMark.name = iconConfig.name;
            }
        }
    }
    function checkSameCell(col1, row1, col2, row2, table) {
        const range1 = table.getCellRange(col1, row1);
        const range2 = table.getCellRange(col2, row2);
        if (range1.start.col === range2.start.col &&
            range1.start.row === range2.start.row &&
            range1.end.col === range2.end.col &&
            range1.end.row === range2.end.row) {
            return true;
        }
        return false;
    }
    function updateSortIcon(options) {
        const { col, row, iconMark, order, oldSortCol, oldSortRow, oldIconMark, scene } = options;
        const icon = scene.table.internalProps.headerHelper.getSortIcon(order, scene.table, col, row);
        if (iconMark) {
            updateIcon(iconMark, icon, col, row, scene);
        }
        if (!checkSameCell(col, row, oldSortCol, oldSortRow, scene.table)) {
            const oldIcon = scene.table.internalProps.headerHelper.getSortIcon('normal', scene.table, oldSortCol, oldSortRow);
            if (oldIconMark) {
                updateIcon(oldIconMark, oldIcon, oldSortCol, oldSortRow, scene);
            }
            else {
                resetSortIcon(oldSortCol, oldSortRow, oldIcon, scene);
            }
        }
    }
    function updateFrozenIcon(scene) {
        for (let col = 0; col < scene.table.colCount; col++) {
            for (let row = 0; row < scene.table.columnHeaderLevelCount; row++) {
                updateCellRangeIcon(col, row, (icon) => icon.attribute.funcType === 'frozen', (icon) => {
                    const iconConfig = scene.table.internalProps.headerHelper.getFrozenIcon(col, row);
                    dealWithIcon(iconConfig, icon);
                    icon.name = iconConfig.name;
                }, scene);
            }
        }
    }
    function updateHierarchyIcon(col, row, scene) {
        let iconConfig;
        if (scene.table.isHeader(col, row)) {
            iconConfig = scene.table.internalProps.headerHelper.getHierarchyIcon(col, row);
        }
        else {
            iconConfig = scene.table.internalProps.bodyHelper.getHierarchyIcon(col, row);
        }
        updateCellRangeIcon(col, row, (icon) => icon.attribute.funcType === IconFuncTypeEnum.collapse || icon.attribute.funcType === IconFuncTypeEnum.expand, (icon) => {
            dealWithIcon(iconConfig, icon);
            icon.name = iconConfig.name;
        }, scene);
    }
    function updateCellGroupIcon(cellGroup, filter, dealer) {
        if (!cellGroup || cellGroup.role === 'empty') {
            return;
        }
        cellGroup.forEachChildren((child) => {
            if (child.type === 'group') {
                updateCellGroupIcon(child, filter, dealer);
            }
            else if (filter(child)) {
                dealer(child);
            }
        });
    }
    function updateCellRangeIcon(col, row, filter, dealer, scene) {
        const cellGroup = scene.getCell(col, row);
        if (cellGroup.role === 'cell' &&
            isValid$3(cellGroup.mergeStartCol) &&
            isValid$3(cellGroup.mergeStartRow) &&
            isValid$3(cellGroup.mergeEndCol) &&
            isValid$3(cellGroup.mergeEndRow)) {
            const { colStart, colEnd, rowStart, rowEnd } = getCellMergeRange(cellGroup, scene);
            for (let col = colStart; col <= colEnd; col++) {
                for (let row = rowStart; row <= rowEnd; row++) {
                    updateCellGroupIcon(scene.highPerformanceGetCell(col, row), filter, dealer);
                }
            }
        }
        else {
            updateCellGroupIcon(cellGroup, filter, dealer);
        }
    }
    function residentHoverIcon(col, row, scene) {
        updateCellRangeIcon(col, row, (icon) => icon.attribute.funcType === IconFuncTypeEnum.dropDown, (icon) => {
            icon.oldVisibleTime = icon.attribute.visibleTime;
            icon.setAttribute('visibleTime', 'always');
            icon.setAttribute('opacity', 1);
        }, scene);
    }
    function resetResidentHoverIcon(col, row, scene) {
        updateCellRangeIcon(col, row, (icon) => icon.attribute.funcType === IconFuncTypeEnum.dropDown, (icon) => {
            icon.oldVisibleTime && icon.setAttribute('visibleTime', icon.oldVisibleTime);
            icon.setAttribute('opacity', icon.attribute.visibleTime === 'always' ? 1 : 0);
        }, scene);
    }

    function createCornerCell(cellGroup, frameTheme) {
        const { bgColor, borderColor, borderLineWidth, borderLineDash } = frameTheme;
        const rectAttributes = {
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            visible: false,
            pickable: true,
            fill: bgColor
        };
        rectAttributes.stroke = getStroke(borderColor, undefined);
        rectAttributes.lineWidth = borderLineWidth;
        borderLineDash && (rectAttributes.lineDash = borderLineDash);
        rectAttributes.lineCap = 'butt';
        if (Array.isArray(borderColor)) {
            rectAttributes.strokeArrayColor = getQuadProps(borderColor);
        }
        if (Array.isArray(borderLineWidth)) {
            rectAttributes.strokeArrayWidth = getQuadProps(borderLineWidth);
            rectAttributes.lineWidth = 1;
        }
        cellGroup.setAttributes(rectAttributes);
        cellGroup.role = 'corner-frozen';
        return cellGroup;
    }

    function updateCol(removeCells, addCells, updateCells, table) {
        if (checkHaveTextStick(table)) {
            resetTextStick(table);
        }
        const scene = table.scenegraph;
        const removeCols = deduplication(removeCells.map(cell => cell.col)).sort((a, b) => b - a);
        const addCols = deduplication(addCells.map(cell => cell.col)).sort((a, b) => a - b);
        const updateCols = deduplication(updateCells.map(cell => cell.col)).sort((a, b) => a - b);
        removeCols.forEach(col => {
            removeCol(col, scene);
        });
        const colWidthsMap = table.colWidthsMap;
        removeCols.forEach(col => {
            colWidthsMap.delAndReorder(col);
        });
        if (removeCols.length) {
            resetColNumber(scene);
        }
        scene.table._clearColRangeWidthsMap();
        let updateAfter;
        addCols.forEach(col => {
            const needUpdateAfter = addCol(col, scene);
            resetColNumber(scene);
            updateAfter = updateAfter ?? needUpdateAfter;
            colWidthsMap.addAndReorder(col);
        });
        resetColNumberAndX(scene);
        updateCols.forEach(col => {
            for (let row = 0; row < table.rowCount; row++) {
                const mergeInfo = getCellMergeInfo(scene.table, col, row);
                if (mergeInfo) {
                    for (let col = mergeInfo.start.col; col <= mergeInfo.end.col; col++) {
                        for (let col = mergeInfo.start.col; col <= mergeInfo.end.col; col++) {
                            updateCell$1(col, row, scene.table, false);
                        }
                    }
                }
                else {
                    updateCell$1(col, row, scene.table, false);
                }
            }
        });
        if (isNumber$4(updateAfter)) {
            for (let col = updateAfter; col < Math.max(table.colCount, table.internalProps._oldColCount ?? table.colCount); col++) {
                for (let row = 0; row < Math.max(table.rowCount, table.internalProps._oldRowCount ?? table.rowCount); row++) {
                    const cellGroup = scene.highPerformanceGetCell(col, row, true);
                    cellGroup && (cellGroup.needUpdate = true);
                }
            }
            scene.proxy.colUpdatePos = updateAfter;
        }
        if (addCols.length) {
            if (!isNumber$4(updateAfter)) {
                const minCol = Math.min(...addCols);
                scene.proxy.colUpdatePos = minCol;
            }
            scene.proxy.colUpdateDirection = 'left';
            scene.proxy.updateColGroups(scene.proxy.screenColCount * 2);
            updateRightFrozeCellGroups();
            scene.proxy.progress();
        }
        else if (removeCols.length) {
            scene.proxy.updateColGroups(scene.proxy.screenColCount * 2);
            updateRightFrozeCellGroups();
            scene.proxy.progress();
        }
        const newTotalWidth = table.getColsWidth(table.frozenColCount, table.colCount - 1);
        scene.updateContainerWidth(scene.table.frozenColCount, newTotalWidth - scene.bodyGroup.attribute.width);
        function updateRightFrozeCellGroups() {
            if (addCols?.[addCols?.length - 1] >= table.colCount - table.rightFrozenColCount ||
                updateCols?.[updateCols?.length - 1] >= table.colCount - table.rightFrozenColCount ||
                removeCols?.[0] >= table.colCount - table.rightFrozenColCount) {
                for (let col = table.colCount - table.rightFrozenColCount; col < table.colCount; col++) {
                    for (let row = 0; row < table.rowCount; row++) {
                        const cellGroup = scene.highPerformanceGetCell(col, row, true);
                        cellGroup && (cellGroup.needUpdate = true);
                    }
                }
                scene.proxy.updateRightFrozenCellGroups();
            }
        }
    }
    function removeCol(col, scene) {
        const proxy = scene.proxy;
        if (col >= scene.table.rowHeaderLevelCount) {
            if (col >= scene.table.colCount - scene.table.rightFrozenColCount) ;
            else {
                const colGroup = scene.getColGroup(col, false);
                if (colGroup && colGroup.parent === scene.bodyGroup) {
                    scene.bodyGroup.removeChild(colGroup);
                }
                const bottomColGroup = scene.getColGroupInBottom(col);
                if (bottomColGroup && bottomColGroup.parent === scene.bottomFrozenGroup) {
                    scene.bottomFrozenGroup.removeChild(bottomColGroup);
                }
                const headerColGroup = scene.getColGroup(col, true);
                if (headerColGroup && headerColGroup.parent === scene.colHeaderGroup) {
                    scene.colHeaderGroup.removeChild(headerColGroup);
                }
            }
        }
        if (col >= proxy.colStart && col <= proxy.colEnd) {
            proxy.colEnd--;
            proxy.currentCol--;
        }
        proxy.bodyRightCol--;
        const totalActualBodyColCount = Math.min(proxy.colLimit, proxy.bodyRightCol - proxy.bodyLeftCol + 1);
        proxy.totalActualBodyColCount = totalActualBodyColCount;
        proxy.totalCol = proxy.colStart + totalActualBodyColCount - 1;
    }
    function addCol(col, scene) {
        const proxy = scene.proxy;
        proxy.bodyRightCol++;
        const totalActualBodyColCount = Math.min(proxy.colLimit, proxy.bodyRightCol - proxy.bodyLeftCol + 1);
        proxy.totalActualBodyColCount = totalActualBodyColCount;
        proxy.totalCol = proxy.colStart + totalActualBodyColCount - 1;
        if (col < proxy.colStart) {
            return undefined;
        }
        else if (col > proxy.colEnd) {
            if (proxy.colEnd - proxy.colStart + 1 < proxy.colLimit) {
                proxy.colEnd++;
                proxy.currentCol++;
                addColGroup(col, scene);
                return col;
            }
            return undefined;
        }
        if (proxy.colEnd - proxy.colStart + 1 < proxy.colLimit) {
            proxy.colEnd++;
            proxy.currentCol++;
            addColGroup(col, scene);
            return col;
        }
        return col;
    }
    function deduplication(array) {
        const result = [];
        for (let i = 0; i < array.length; i++) {
            if (result.indexOf(array[i]) === -1) {
                result.push(array[i]);
            }
        }
        return result;
    }
    function resetColNumber(scene) {
        let colIndex = scene.bodyColStart;
        scene.bodyGroup.forEachChildren((colGroup) => {
            colGroup.col = colIndex;
            colGroup?.forEachChildren((cellGroup) => {
                processCell(cellGroup);
            });
            colIndex++;
        });
        colIndex = scene.bodyColStart;
        scene.colHeaderGroup.forEachChildren((colGroup) => {
            colGroup.col = colIndex;
            colGroup?.forEachChildren((cellGroup) => {
                processCell(cellGroup);
            });
            colIndex++;
        });
        colIndex = scene.bodyColStart;
        scene.bottomFrozenGroup.forEachChildren((colGroup) => {
            colGroup.col = colIndex;
            colGroup?.forEachChildren((cellGroup) => {
                processCell(cellGroup);
            });
            colIndex++;
        });
        function processCell(cellGroup) {
            cellGroup.col = colIndex;
            const merge = getCellMergeInfo(scene.table, cellGroup.col, cellGroup.row);
            if (merge) {
                cellGroup.mergeStartCol = merge.start.col;
                cellGroup.mergeStartCol = merge.start.col;
                cellGroup.mergeEndCol = merge.end.col;
                cellGroup.mergeEndCol = merge.end.col;
            }
            if (cellGroup.role !== 'cell') {
                return;
            }
        }
    }
    function resetColNumberAndX(scene) {
        let colIndex = scene.bodyColStart;
        let x = scene.getCellGroupX(colIndex);
        scene.bodyGroup.forEachChildren((colGroup) => {
            colGroup.col = colIndex;
            colGroup?.forEachChildren((cellGroup) => {
                processCell(cellGroup);
            });
            colGroup.setAttribute('x', x);
            x += colGroup.attribute.width;
            colIndex++;
        });
        colIndex = scene.bodyColStart;
        x = scene.getCellGroupX(colIndex);
        scene.colHeaderGroup.forEachChildren((colGroup) => {
            colGroup.col = colIndex;
            colGroup?.forEachChildren((cellGroup) => {
                processCell(cellGroup);
            });
            colGroup.setAttribute('x', x);
            x += colGroup.attribute.width;
            colIndex++;
        });
        colIndex = scene.bodyColStart;
        x = scene.getCellGroupX(colIndex);
        scene.bottomFrozenGroup.forEachChildren((colGroup) => {
            colGroup.col = colIndex;
            colGroup?.forEachChildren((cellGroup) => {
                processCell(cellGroup);
            });
            colGroup.setAttribute('x', x);
            x += colGroup.attribute.width;
            colIndex++;
        });
        colIndex = scene.table.colCount - scene.table.rightFrozenColCount;
        x = 0;
        scene.rightFrozenGroup.forEachChildren((colGroup) => {
            colGroup.col = colIndex;
            colGroup?.forEachChildren((cellGroup) => {
                processCell(cellGroup);
            });
            colGroup.setAttribute('x', x);
            x += colGroup.attribute.width;
            colIndex++;
        });
        colIndex = scene.table.colCount - scene.table.rightFrozenColCount;
        x = 0;
        scene.rightTopCornerGroup.forEachChildren((colGroup) => {
            colGroup.col = colIndex;
            colGroup?.forEachChildren((cellGroup) => {
                processCell(cellGroup);
            });
            colGroup.setAttribute('x', x);
            x += colGroup.attribute.width;
            colIndex++;
        });
        colIndex = scene.table.colCount - scene.table.rightFrozenColCount;
        x = 0;
        scene.rightBottomCornerGroup.forEachChildren((colGroup) => {
            colGroup.col = colIndex;
            colGroup?.forEachChildren((cellGroup) => {
                processCell(cellGroup);
            });
            colGroup.setAttribute('x', x);
            x += colGroup.attribute.width;
            colIndex++;
        });
        function processCell(cellGroup) {
            cellGroup.col = colIndex;
            const merge = getCellMergeInfo(scene.table, cellGroup.col, cellGroup.row);
            if (merge) {
                cellGroup.mergeStartCol = merge.start.col;
                cellGroup.mergeStartCol = merge.start.col;
                cellGroup.mergeEndCol = merge.end.col;
                cellGroup.mergeEndCol = merge.end.col;
            }
            if (cellGroup.role !== 'cell') {
                return;
            }
        }
    }
    function addColGroup(col, scene) {
        if (scene.colHeaderGroup && scene.table.columnHeaderLevelCount > 0) {
            const columnGroup = new Group$1({
                x: 0,
                y: 0,
                width: scene.table.getColWidth(col),
                height: 0,
                clip: false,
                pickable: false
            });
            columnGroup.role = 'column';
            columnGroup.col = col;
            const colAfter = scene.getColGroup(col, true);
            if (colAfter) {
                scene.colHeaderGroup.insertBefore(columnGroup, colAfter);
            }
            else {
                scene.colHeaderGroup.appendChild(columnGroup);
            }
            generateCellGroup(columnGroup, col, 0, scene.table.columnHeaderLevelCount - 1);
        }
        if (scene.bodyGroup) {
            const columnGroup = new Group$1({
                x: 0,
                y: 0,
                width: scene.table.getColWidth(col),
                height: 0,
                clip: false,
                pickable: false
            });
            columnGroup.role = 'column';
            columnGroup.col = col;
            const colAfter = scene.getColGroup(col, false);
            if (colAfter) {
                scene.bodyGroup.insertBefore(columnGroup, colAfter);
            }
            else {
                scene.bodyGroup.appendChild(columnGroup);
            }
            generateCellGroup(columnGroup, col, scene.bodyRowStart, scene.bodyRowEnd);
        }
        if (scene.bottomFrozenGroup && scene.table.bottomFrozenRowCount > 0) {
            const columnGroup = new Group$1({
                x: 0,
                y: 0,
                width: scene.table.getColWidth(col),
                height: 0,
                clip: false,
                pickable: false
            });
            columnGroup.role = 'column';
            columnGroup.col = col;
            const colAfter = scene.getColGroupInBottom(col);
            if (colAfter) {
                scene.bottomFrozenGroup.insertBefore(columnGroup, colAfter);
            }
            else {
                scene.bottomFrozenGroup.appendChild(columnGroup);
            }
            generateCellGroup(columnGroup, col, scene.table.rowCount - scene.table.bottomFrozenRowCount, scene.table.rowCount - 1);
        }
        function generateCellGroup(group, col, rowStart, rowEnd) {
            for (let row = rowStart; row <= rowEnd; row++) {
                const cellGroup = new Group$1({
                    x: 0,
                    y: 0,
                    width: scene.table.getColWidth(col),
                    height: scene.table.getRowHeight(row)
                });
                cellGroup.role = 'cell';
                cellGroup.col = col;
                cellGroup.row = row;
                cellGroup.needUpdate = true;
                group.appendChild(cellGroup);
            }
        }
    }

    function dealWithAnimationAppear(table) {
        if (!table.options.animationAppear) {
            return;
        }
        let duration;
        let delay;
        let type;
        let direction;
        if (table.options.animationAppear === true) {
            duration = 500;
            delay = 0;
            type = 'one-by-one';
            direction = 'column';
        }
        else {
            duration = table.options.animationAppear.duration ?? 500;
            delay = table.options.animationAppear.delay ?? 0;
            type = table.options.animationAppear.type ?? 'one-by-one';
            direction = table.options.animationAppear.direction ?? 'row';
        }
        const { scenegraph: scene, frozenColCount, frozenRowCount } = table;
        const { colStart, colEnd, rowStart, rowEnd } = scene.proxy;
        for (let col = 0; col <= colEnd; col++) {
            for (let row = 0; row <= rowEnd; row++) {
                const cellGroup = scene.highPerformanceGetCell(col, row);
                if (cellGroup && cellGroup.role === 'cell') {
                    cellGroup.forEachChildren((child) => {
                        child.setAttribute('opacity', 0);
                        child
                            .animate()
                            .wait(type === 'one-by-one' ? (direction === 'row' ? row : col) * (duration - delay) : delay)
                            .to({ opacity: 1 }, duration, 'linear');
                    });
                }
            }
        }
    }

    function temporarilyUpdateSelectRectStyle(rectAttribute, scene) {
        const { selectedRangeComponents } = scene;
        selectedRangeComponents.forEach((selectComp, key) => {
            selectComp.rect.setAttributes(rectAttribute);
        });
        scene.updateNextFrame();
    }

    registerForVrender();
    container.load(splitModule);
    container.load(textMeasureModule);
    class Scenegraph {
        proxy;
        tableGroup;
        colHeaderGroup;
        cornerHeaderGroup;
        rowHeaderGroup;
        bodyGroup;
        rightFrozenGroup;
        bottomFrozenGroup;
        rightTopCornerGroup;
        leftBottomCornerGroup;
        rightBottomCornerGroup;
        componentGroup;
        selectedRangeComponents;
        selectingRangeComponents;
        customSelectedRangeComponents;
        lastSelectId;
        component;
        stage;
        table;
        isPivot;
        hasFrozen;
        frozenColCount;
        frozenRowCount;
        clear;
        mergeMap;
        _dealAutoFillHeightOriginRowsHeight;
        _needUpdateContainer = false;
        constructor(table) {
            this.table = table;
            this.hasFrozen = false;
            this.clear = true;
            this.mergeMap = new Map();
            setPoptipTheme(this.table.theme.textPopTipStyle);
            let width;
            let height;
            if (Env.mode === 'node') {
                vglobal.setEnv('node', table.options.modeParams);
                width = table.canvasWidth;
                height = table.canvasHeight;
            }
            else if (table.options.canvas && table.options.viewBox) {
                vglobal.setEnv('browser');
                width = table.options.viewBox.x2 - table.options.viewBox.x1;
                height = table.options.viewBox.y2 - table.options.viewBox.y1;
            }
            else {
                vglobal.setEnv('browser');
                width = table.canvas.width;
                height = table.canvas.height;
            }
            this.stage = createStage({
                canvas: table.canvas,
                width,
                height,
                disableDirtyBounds: false,
                background: table.theme.underlayBackgroundColor,
                dpr: table.internalProps.pixelRatio,
                enableLayout: true,
                beforeRender: (stage) => {
                    this.table.options.beforeRender && this.table.options.beforeRender(stage);
                    this.table.animationManager.ticker.start();
                },
                afterRender: (stage) => {
                    this.table.options.afterRender && this.table.options.afterRender(stage);
                    this.table.fireListeners('after_render', null);
                },
                canvasControled: !table.options.canvas,
                viewBox: table.options.viewBox,
                ...table.options.renderOption
            });
            this.stage.defaultLayer.setTheme({
                group: {
                    boundsPadding: 0,
                    strokeBoundsBuffer: 0,
                    lineJoin: 'round'
                },
                text: {
                    ignoreBuf: true
                }
            });
            this.initSceneGraph();
            this.stage.defaultLayer.add(this.tableGroup);
            this.stage.table = this.table;
            this.createComponent();
        }
        get width() {
            return this.tableGroup.attribute?.width ?? 0;
        }
        get height() {
            return this.tableGroup.attribute?.height ?? 0;
        }
        get x() {
            return this.tableGroup.attribute?.x ?? 0;
        }
        get y() {
            return this.tableGroup.attribute?.y ?? 0;
        }
        get bodyRowStart() {
            return this.proxy.rowStart ?? 0;
        }
        get bodyRowEnd() {
            return this.proxy.rowEnd ?? this.table.rowCount - 1;
        }
        get bodyColStart() {
            return this.proxy.colStart ?? 0;
        }
        get bodyColEnd() {
            return this.proxy.colEnd ?? this.table.colCount - 1;
        }
        initSceneGraph() {
            this.isPivot = this.table.isPivotTable();
            initSceneGraph(this);
        }
        clearCells() {
            this.table.animationManager.clear();
            if (this.table.isPivotChart() || this.table._hasCustomRenderOrLayout()) {
                this.stage.pluginService.findPluginsByName('poptipForText').forEach(plugin => {
                    plugin.deactivate(this.stage.pluginService);
                });
            }
            this.clear = true;
            this.hasFrozen = false;
            this.mergeMap.clear();
            this.colHeaderGroup.clear();
            delete this.colHeaderGroup.border;
            this.rowHeaderGroup.clear();
            delete this.rowHeaderGroup.border;
            this.cornerHeaderGroup.clear();
            delete this.cornerHeaderGroup.border;
            this.bodyGroup.clear();
            delete this.bodyGroup.border;
            this.bottomFrozenGroup.clear();
            delete this.bottomFrozenGroup.border;
            this.rightFrozenGroup.clear();
            delete this.rightFrozenGroup.border;
            this.rightTopCornerGroup.clear();
            delete this.rightTopCornerGroup.border;
            this.rightBottomCornerGroup.clear();
            delete this.rightBottomCornerGroup.border;
            this.leftBottomCornerGroup.clear();
            delete this.leftBottomCornerGroup.border;
            this.colHeaderGroup.setAttributes({
                x: 0,
                y: 0,
                width: 0,
                height: 0
            });
            this.rowHeaderGroup.setAttributes({
                x: 0,
                y: 0,
                width: 0,
                height: 0
            });
            this.cornerHeaderGroup.setAttributes({
                x: 0,
                y: 0,
                width: 0,
                height: 0
            });
            this.bodyGroup.setAttributes({
                x: 0,
                y: 0,
                width: 0,
                height: 0
            });
            this.rightFrozenGroup.setAttributes({
                x: 0,
                y: 0,
                width: 0,
                height: 0
            });
            this.bottomFrozenGroup.setAttributes({
                x: 0,
                y: 0,
                width: 0,
                height: 0
            });
            this.rightTopCornerGroup.setAttributes({
                x: 0,
                y: 0,
                width: 0,
                height: 0,
                visible: false
            });
            this.leftBottomCornerGroup.setAttributes({
                x: 0,
                y: 0,
                width: 0,
                height: 0,
                visible: false
            });
            this.rightBottomCornerGroup.setAttributes({
                x: 0,
                y: 0,
                width: 0,
                height: 0,
                visible: false
            });
            this.tableGroup.setAttributes({
                x: this.table.tableX,
                y: this.table.tableY,
                width: 0,
                height: 0
            });
            if (this.tableGroup.border) {
                this.tableGroup.parent.removeChild(this.tableGroup.border);
                delete this.tableGroup.border;
            }
            this.proxy?.release();
            this.table.reactCustomLayout?.clearCache();
        }
        updateStageBackground() {
            this.stage.background = this.table.theme.underlayBackgroundColor;
            this.stage.renderNextFrame();
        }
        createComponent() {
            this.component = new TableComponent(this.table);
            this.component.addToGroup(this.componentGroup);
            this.selectedRangeComponents = new Map();
            this.selectingRangeComponents = new Map();
            this.customSelectedRangeComponents = new Map();
        }
        updateComponent() {
            this.component.updateStyle();
        }
        createSceneGraph(skipRowHeightClear = false) {
            if (!skipRowHeightClear) {
                this.table.rowHeightsMap.clear();
                this.table.internalProps.layoutMap.clearCellRangeMap();
            }
            if (this.table.isPivotChart() || this.table._hasCustomRenderOrLayout()) {
                this.stage.pluginService.autoEnablePlugins.getContributions().forEach((p) => {
                    if (p.name === 'poptipForText') {
                        this.stage.pluginService.register(p);
                    }
                });
            }
            this.clear = false;
            this.frozenColCount = this.table.frozenColCount;
            this.frozenRowCount = this.table.frozenRowCount;
            this.proxy = new SceneProxy(this.table);
            createFrameBorder(this.tableGroup, this.table.theme.frameStyle, this.tableGroup.role, undefined, true);
            if (this.table.isPivotChart()) {
                createCornerCell(this.rightTopCornerGroup, this.table.theme.cornerRightTopCellStyle || this.table.theme.cornerHeaderStyle || {});
                createCornerCell(this.leftBottomCornerGroup, this.table.theme.cornerLeftBottomCellStyle || this.table.theme.cornerHeaderStyle || {});
                createCornerCell(this.rightBottomCornerGroup, this.table.theme.cornerRightBottomCellStyle || this.table.theme.cornerHeaderStyle || {});
            }
            this.proxy.createGroupForFirstScreen(this.cornerHeaderGroup, this.colHeaderGroup, this.rowHeaderGroup, this.rightFrozenGroup, this.bottomFrozenGroup, this.bodyGroup, 0, 0);
            this.afterScenegraphCreated();
        }
        renderSceneGraph() {
            this.stage.render();
        }
        getCell(col, row, getShadow) {
            let cell;
            if (this.table.rightFrozenColCount > 0 &&
                col >= this.table.colCount - this.table.rightFrozenColCount &&
                row < this.table.frozenRowCount) {
                cell = this.rightTopCornerGroup.getColGroup(col)?.getRowGroup(row);
            }
            else if (this.table.bottomFrozenRowCount > 0 &&
                row >= this.table.rowCount - this.table.bottomFrozenRowCount &&
                col < this.table.frozenColCount) {
                cell = this.leftBottomCornerGroup.getColGroup(col)?.getRowGroup(row);
            }
            else if (this.table.rightFrozenColCount > 0 &&
                this.table.bottomFrozenRowCount > 0 &&
                col >= this.table.colCount - this.table.rightFrozenColCount &&
                row >= this.table.rowCount - this.table.bottomFrozenRowCount) {
                cell = this.rightBottomCornerGroup.getColGroup(col)?.getRowGroup(row);
            }
            else if (this.table.rightFrozenColCount > 0 && col > this.table.colCount - 1 - this.table.rightFrozenColCount) {
                cell = this.rightFrozenGroup.getColGroup(col)?.getRowGroup(row);
            }
            else if (this.table.bottomFrozenRowCount > 0 && row > this.table.rowCount - 1 - this.table.bottomFrozenRowCount) {
                cell = this.bottomFrozenGroup.getColGroup(col)?.getRowGroup(row);
            }
            else {
                cell = this.getColGroup(col, row < this.frozenRowCount)?.getRowGroup(row);
            }
            if (cell && cell.role === 'shadow-cell' && !getShadow) {
                const range = this.table.getCellRange(col, row);
                if (range.start.col === col && range.start.row === row) ;
                else {
                    cell = this.getCell(range.start.col, range.start.row);
                }
            }
            return cell || emptyGroup;
        }
        highPerformanceGetCell(col, row, getShadow) {
            return this.proxy.highPerformanceGetCell(col, row, getShadow);
        }
        getColGroup(col, isCornerOrColHeader = false) {
            let element;
            if (col < this.frozenColCount && isCornerOrColHeader) {
                element = this.cornerHeaderGroup.getColGroup(col);
            }
            else if (col < this.frozenColCount) {
                element = this.rowHeaderGroup.getColGroup(col);
            }
            else if (isCornerOrColHeader &&
                this.table.rightFrozenColCount > 0 &&
                col > this.table.colCount - 1 - this.table.rightFrozenColCount) {
                element = this.rightTopCornerGroup.getColGroup(col);
            }
            else if (!isCornerOrColHeader &&
                this.table.rightFrozenColCount > 0 &&
                col > this.table.colCount - 1 - this.table.rightFrozenColCount) {
                element = this.rightFrozenGroup.getColGroup(col);
            }
            else if (isCornerOrColHeader) {
                element = this.colHeaderGroup.getColGroup(col);
            }
            else {
                element = this.bodyGroup.getColGroup(col);
            }
            return element || undefined;
        }
        getColGroupInBottom(col, isCornerOrColHeader = false) {
            if (isCornerOrColHeader) {
                const element = this.getColGroupInLeftBottomCorner(col) ?? this.getColGroupInRightBottomCorner(col);
                if (element) {
                    return element;
                }
            }
            if (this.table.bottomFrozenRowCount > 0) {
                return this.bottomFrozenGroup.getColGroup(col);
            }
            return undefined;
        }
        getColGroupInLeftBottomCorner(col) {
            if (this.table.bottomFrozenRowCount > 0) {
                return this.leftBottomCornerGroup.getColGroup(col);
            }
            return undefined;
        }
        getColGroupInRightTopCorner(col) {
            if (this.table.rightFrozenColCount > 0) {
                return this.rightTopCornerGroup.getColGroup(col);
            }
            return undefined;
        }
        getColGroupInRightBottomCorner(col) {
            if (this.table.rightFrozenColCount > 0 && this.table.bottomFrozenRowCount > 0) {
                return this.rightBottomCornerGroup.getColGroup(col);
            }
            return undefined;
        }
        getCellSize(col, row) {
            const cell = this.getCell(col, row);
            const mergeInfo = getCellMergeInfo(this.table, col, row);
            let width = cell.attribute.width;
            let height = cell.attribute.height;
            if (mergeInfo) {
                width = width / (mergeInfo.end.col - mergeInfo.start.col + 1);
                height = height / (mergeInfo.end.row - mergeInfo.start.row + 1);
            }
            return { width, height };
        }
        updateNextFrame() {
            this.updateContainerSync();
            this.resetAllSelectComponent();
            this.stage.renderNextFrame();
        }
        resetAllSelectComponent() {
            if (this.table.stateManager.select?.ranges?.length > 0 ||
                this.table.stateManager.select?.customSelectRanges?.length > 0) {
                updateAllSelectComponent(this);
            }
        }
        hideHoverIcon(col, row) {
            hideHoverIcon(col, row, this);
        }
        showHoverIcon(col, row) {
            showHoverIcon(col, row, this);
        }
        hideClickIcon(col, row) {
            hideClickIcon(col, row, this);
        }
        showClickIcon(col, row) {
            showClickIcon(col, row, this);
        }
        getIcon(col, row, x, y) {
            return getIconByXY(col, row, x, y, this);
        }
        setIconHoverStyle(icon, col, row, cellGroup) {
            setIconHoverStyle(icon, col, row, cellGroup, this);
        }
        updateSortIcon(options) {
            const { col, row, iconMark, order, oldSortCol, oldSortRow, oldIconMark } = options;
            updateSortIcon({ col, row, iconMark, order, oldSortCol, oldSortRow, oldIconMark, scene: this });
        }
        updateFrozenIcon(col, oldFrozenCol) {
            updateFrozenIcon(this);
        }
        updateHierarchyIcon(col, row) {
            updateHierarchyIcon(col, row, this);
        }
        setIconNormalStyle(icon, col, row) {
            setIconNormalStyle(icon, col, row, this);
        }
        residentHoverIcon(col, row) {
            residentHoverIcon(col, row, this);
        }
        resetResidentHoverIcon(col, row) {
            resetResidentHoverIcon(col, row, this);
        }
        deactivateChart(col, row) {
            if (col === -1 || row === -1) {
                return;
            }
            const cellGroup = this.getCell(col, row);
            cellGroup?.firstChild?.deactivate?.();
        }
        activateChart(col, row) {
            if (col === -1 || row === -1) {
                return;
            }
            const cellGroup = this.getCell(col, row);
            cellGroup?.firstChild?.activate?.(this.table);
            return cellGroup?.firstChild?.activeChartInstance;
        }
        removeInteractionBorder(col, row) {
            const cellGroup = this.getCell(col, row);
            cellGroup.setAttribute('highlightStroke', undefined);
            cellGroup.setAttribute('highlightStrokeArrayWidth', undefined);
            cellGroup.setAttribute('highlightStrokeArrayColor', undefined);
        }
        createCellSelectBorder(start_Col, start_Row, end_Col, end_Row, selectRangeType, selectId, strokes) {
            createCellSelectBorder(this, start_Col, start_Row, end_Col, end_Row, selectRangeType, selectId, strokes);
        }
        moveSelectingRangeComponentsToSelectedRangeComponents() {
            moveSelectingRangeComponentsToSelectedRangeComponents(this);
        }
        deleteLastSelectedRangeComponents() {
            deleteLastSelectedRangeComponents(this);
        }
        deleteAllSelectBorder() {
            deleteAllSelectBorder(this);
            deleteAllSelectingBorder(this);
        }
        updateCellSelectBorder(selectRange, extendSelectRange = true) {
            updateCellSelectBorder(this, selectRange, extendSelectRange);
        }
        removeFillHandleFromSelectComponents() {
            removeFillHandleFromSelectComponents(this);
        }
        recreateAllSelectRangeComponents() {
            deleteAllSelectBorder(this);
            this.table.stateManager.select.ranges.forEach((cellRange) => {
                updateCellSelectBorder(this, cellRange);
                moveSelectingRangeComponentsToSelectedRangeComponents(this);
            });
        }
        updateColWidth(col, detaX, skipUpdateContainer, skipTableWidthMap) {
            updateColWidth(this, col, Math.round(detaX), skipTableWidthMap);
            if (!skipUpdateContainer) {
                this.updateContainer(true);
            }
        }
        updateChartSizeForResizeColWidth(col) {
            updateChartSizeForResizeColWidth(this, col);
        }
        updateChartSizeForResizeRowHeight(row) {
            updateChartSizeForResizeRowHeight(this, row);
        }
        updateChartState(datum) {
            this.table.isPivotChart() && updateChartState(this, datum);
        }
        updateCheckboxCellState(col, row, checked) {
            if (this.table.transpose) {
                this.bodyGroup.children?.forEach((columnGroup) => {
                    columnGroup
                        .getChildAt(row)
                        ?.getChildren()
                        .forEach((node) => {
                        if (node.name === 'checkbox') {
                            if (checked === 'indeterminate') {
                                node.setAttribute('indeterminate', true);
                                node.setAttribute('checked', undefined);
                            }
                            else {
                                node.setAttribute('indeterminate', undefined);
                                node.setAttribute('checked', checked);
                            }
                        }
                    });
                });
            }
            else {
                const columnGroup = this.getColGroup(col);
                columnGroup?.children?.forEach((cellNode) => {
                    cellNode.getChildren().find(node => {
                        if (node.name === 'checkbox') {
                            if (checked === 'indeterminate') {
                                node.setAttribute('indeterminate', true);
                                node.setAttribute('checked', undefined);
                            }
                            else {
                                node.setAttribute('indeterminate', undefined);
                                node.setAttribute('checked', checked);
                            }
                        }
                    });
                });
            }
        }
        updateHeaderCheckboxCellState(col, row, checked) {
            if (this.table.transpose) {
                this.rowHeaderGroup.children?.forEach((columnGroup) => {
                    columnGroup
                        .getChildAt(row)
                        .getChildren()
                        .forEach((node) => {
                        if (node.name === 'checkbox') {
                            if (checked === 'indeterminate') {
                                node.setAttribute('indeterminate', true);
                                node.setAttribute('checked', undefined);
                            }
                            else {
                                node.setAttribute('indeterminate', undefined);
                                node.setAttribute('checked', checked);
                            }
                        }
                    });
                });
            }
            else {
                const columnGroup = this.getColGroup(col, true);
                columnGroup.children?.forEach((cellNode) => {
                    cellNode.getChildren().find(node => {
                        if (node.name === 'checkbox') {
                            if (checked === 'indeterminate') {
                                node.setAttribute('indeterminate', true);
                                node.setAttribute('checked', undefined);
                            }
                            else {
                                node.setAttribute('indeterminate', undefined);
                                node.setAttribute('checked', checked);
                            }
                        }
                    });
                });
            }
        }
        updateAutoColWidth(col) {
            this.table.internalProps._widthResizedColMap.delete(col);
            const oldWidth = this.table.getColWidth(col);
            const newWidth = computeColWidth(col, 0, this.table.rowCount - 1, this.table, true);
            if (newWidth !== oldWidth) {
                this.updateColWidth(col, newWidth - oldWidth);
            }
        }
        recalculateColWidths() {
            const table = this.table;
            if (table.widthMode === 'adaptive' || table.autoFillWidth || table.internalProps.transpose) {
                computeColsWidth(this.table, 0, this.table.colCount - 1, true);
            }
            else {
                table._clearColRangeWidthsMap();
                if (table.frozenColCount > 0) {
                    computeColsWidth(this.table, 0, table.frozenColCount - 1, true);
                }
                if (table.rightFrozenColCount > 0) {
                    computeColsWidth(this.table, table.rightFrozenColCount, table.colCount - 1, true);
                }
                computeColsWidth(table, this.proxy.colStart, this.proxy.colEnd, true);
            }
        }
        recalculateRowHeights() {
            const table = this.table;
            table.internalProps.useOneRowHeightFillAll = false;
            if (table.heightMode === 'adaptive' || table.autoFillHeight) {
                computeRowsHeight(this.table, 0, this.table.rowCount - 1, true, true);
            }
            else {
                if (table.frozenRowCount > 0) {
                    computeRowsHeight(this.table, 0, table.frozenRowCount - 1, true, true);
                }
                if (table.bottomFrozenRowCount > 0) {
                    computeRowsHeight(this.table, table.bottomFrozenRowCount, table.rowCount - 1, true, true);
                }
                computeRowsHeight(table, this.proxy.rowStart, this.proxy.rowEnd, true, true);
            }
        }
        resize() {
            this.proxy.resize();
            if (this.table.widthMode === 'adaptive' || this.table.autoFillWidth) {
                if (this.table.internalProps._widthResizedColMap.size === 0) {
                    this.recalculateColWidths();
                }
                else {
                    this.dealWidthMode();
                }
            }
            if (this.table.heightMode === 'adaptive') {
                if (this.table.internalProps._heightResizedRowMap.size === 0) {
                    this.recalculateRowHeights();
                }
                else {
                    this.dealHeightMode();
                }
            }
            else if (this.table.autoFillHeight) {
                this.dealHeightMode();
            }
            this.resetFrozen();
            this.updateTableSize();
            this.updateBorderSizeAndPosition();
            this.component.updateScrollBar();
            if (this.table.widthMode === 'adaptive' ||
                this.table.heightMode === 'adaptive' ||
                this.table.autoFillWidth ||
                this.table.autoFillHeight) {
                this.updateChartSizeForResizeColWidth(-1);
            }
            this.proxy.progress();
            this.updateNextFrame();
        }
        updateTableSize() {
            this.tableGroup.setAttributes({
                x: this.table.tableX,
                y: this.table.tableY,
                width: Math.min(this.table.tableNoFrameWidth, Math.max(this.colHeaderGroup.attribute.width, this.bodyGroup.attribute.width, this.bottomFrozenGroup.attribute.width, 0) +
                    Math.max(this.cornerHeaderGroup.attribute.width, this.rowHeaderGroup.attribute.width, this.leftBottomCornerGroup.attribute.width, 0) +
                    Math.max(this.rightTopCornerGroup.attribute.width, this.rightFrozenGroup.attribute.width, this.rightBottomCornerGroup.attribute.width, 0)),
                height: Math.min(this.table.tableNoFrameHeight, Math.max(this.colHeaderGroup.attribute.height, this.cornerHeaderGroup.attribute.height, this.rightTopCornerGroup.attribute.height, 0) +
                    Math.max(this.rowHeaderGroup.attribute.height, this.bodyGroup.attribute.height, this.rightFrozenGroup.attribute.height, 0) +
                    Math.max(this.leftBottomCornerGroup.attribute.height, this.bottomFrozenGroup.attribute.height, this.rightBottomCornerGroup.attribute.height, 0))
            });
            if (this.tableGroup.border) {
                const rectAttributes = this.tableGroup.border?.attribute;
                let borderTop;
                let borderRight;
                let borderBottom;
                let borderLeft;
                if (rectAttributes?.strokeArrayWidth) {
                    borderTop = rectAttributes.strokeArrayWidth
                        ? rectAttributes.strokeArrayWidth[0]
                        : rectAttributes.lineWidth ?? 0;
                    borderRight = rectAttributes.strokeArrayWidth
                        ? rectAttributes.strokeArrayWidth[1]
                        : rectAttributes.lineWidth ?? 0;
                    borderBottom = rectAttributes.strokeArrayWidth
                        ? rectAttributes.strokeArrayWidth[2]
                        : rectAttributes.lineWidth ?? 0;
                    borderLeft = rectAttributes.strokeArrayWidth
                        ? rectAttributes.strokeArrayWidth[3]
                        : rectAttributes.lineWidth ?? 0;
                }
                else {
                    borderTop = rectAttributes?.lineWidth ?? 0;
                    borderRight = rectAttributes?.lineWidth ?? 0;
                    borderBottom = rectAttributes?.lineWidth ?? 0;
                    borderLeft = rectAttributes?.lineWidth ?? 0;
                }
                if (this.tableGroup.border.type === 'rect') {
                    if (this.table.theme.frameStyle?.innerBorder) {
                        this.tableGroup.border.setAttributes({
                            x: this.table.tableX + borderLeft / 2,
                            y: this.table.tableY + borderTop / 2,
                            width: this.tableGroup.attribute.width - borderLeft / 2 - borderRight / 2,
                            height: this.tableGroup.attribute.height - borderTop / 2 - borderBottom / 2
                        });
                    }
                    else {
                        this.tableGroup.border.setAttributes({
                            x: this.table.tableX - borderLeft / 2,
                            y: this.table.tableY - borderTop / 2,
                            width: this.tableGroup.attribute.width + borderLeft / 2 + borderRight / 2,
                            height: this.tableGroup.attribute.height + borderTop / 2 + borderBottom / 2
                        });
                    }
                }
                else if (this.tableGroup.border.type === 'group') {
                    if (this.table.theme.frameStyle?.innerBorder) {
                        this.tableGroup.border.setAttributes({
                            x: this.table.tableX + borderLeft / 2,
                            y: this.table.tableY + borderTop / 2,
                            width: this.tableGroup.attribute.width - borderLeft / 2 - borderRight / 2,
                            height: this.tableGroup.attribute.height - borderTop / 2 - borderBottom / 2
                        });
                        this.tableGroup.border.firstChild?.setAttributes({
                            x: 0,
                            y: 0,
                            width: this.tableGroup.attribute.width - borderLeft / 2 - borderRight / 2,
                            height: this.tableGroup.attribute.height - borderTop / 2 - borderBottom / 2
                        });
                    }
                    else {
                        this.tableGroup.border.setAttributes({
                            x: this.table.tableX - borderLeft / 2,
                            y: this.table.tableY - borderTop / 2,
                            width: this.tableGroup.attribute.width + borderLeft / 2 + borderRight / 2,
                            height: this.tableGroup.attribute.height + borderTop / 2 + borderBottom / 2
                        });
                        this.tableGroup.border.firstChild?.setAttributes({
                            x: borderLeft / 2,
                            y: borderTop / 2,
                            width: this.tableGroup.attribute.width,
                            height: this.tableGroup.attribute.height
                        });
                    }
                }
            }
            if (this.table.bottomFrozenRowCount > 0) {
                this.bottomFrozenGroup.setAttribute('y', this.tableGroup.attribute.height - this.table.getBottomFrozenRowsHeight());
                this.leftBottomCornerGroup.setAttributes({
                    visible: true,
                    y: this.tableGroup.attribute.height - this.table.getBottomFrozenRowsHeight(),
                    height: this.table.getBottomFrozenRowsHeight(),
                    width: this.table.getFrozenColsWidth()
                });
                this.rightBottomCornerGroup.setAttributes({
                    visible: true,
                    y: this.tableGroup.attribute.height - this.table.getBottomFrozenRowsHeight(),
                    height: this.table.getBottomFrozenRowsHeight()
                });
            }
            if (this.table.rightFrozenColCount > 0) {
                this.rightFrozenGroup.setAttribute('x', this.tableGroup.attribute.width - this.table.getRightFrozenColsWidth());
                this.rightTopCornerGroup.setAttributes({
                    visible: true,
                    x: this.tableGroup.attribute.width - this.table.getRightFrozenColsWidth(),
                    width: this.table.getRightFrozenColsWidth(),
                    height: this.table.getFrozenRowsHeight()
                });
                this.rightBottomCornerGroup.setAttributes({
                    visible: true,
                    x: this.tableGroup.attribute.width - this.table.getRightFrozenColsWidth(),
                    width: this.table.getRightFrozenColsWidth()
                });
            }
            this.updateDomContainer();
        }
        updateRowHeight(row, detaY, skipTableHeightMap) {
            detaY = Math.round(detaY);
            updateRowHeight(this, row, detaY, skipTableHeightMap);
            this.updateContainerHeight(row, detaY);
        }
        updateRowsHeight(rows, detaYs, skipTableHeightMap) {
            for (let i = 0; i < rows.length; i++) {
                const row = rows[i];
                if (row >= this.proxy.rowStart && row <= this.proxy.rowEnd) {
                    const detaY = detaYs[i];
                    updateRowHeight(this, row, Math.round(detaY), skipTableHeightMap);
                    this._updateContainerHeight(row, detaY);
                }
            }
            this.updateTableSize();
            this.component.updateScrollBar();
            this.updateNextFrame();
        }
        updateContainerWidth(col, detaX) {
            if (col < this.frozenColCount) {
                this.rowHeaderGroup.setDeltaWidth(detaX);
                this.cornerHeaderGroup.setDeltaWidth(detaX);
                this.colHeaderGroup.setDeltaX(detaX);
                this.bodyGroup.setDeltaX(detaX);
            }
            else {
                this.colHeaderGroup.setDeltaWidth(detaX);
                this.bodyGroup.setDeltaWidth(detaX);
            }
            this.updateTableSize();
            this.component.updateScrollBar();
            this.updateNextFrame();
        }
        _updateContainerHeight(row, detaY) {
            if (row < this.table.frozenRowCount) {
                this.colHeaderGroup.setDeltaHeight(detaY);
                this.cornerHeaderGroup.setDeltaHeight(detaY);
                this.rowHeaderGroup.setDeltaY(detaY);
                this.bodyGroup.setDeltaY(detaY);
                this.table.rightFrozenColCount && this.rightFrozenGroup.setDeltaY(detaY);
            }
            else if (row >= this.table.rowCount - this.table.bottomFrozenRowCount) {
                this.leftBottomCornerGroup.setDeltaHeight(detaY);
                this.bottomFrozenGroup.setDeltaHeight(detaY);
                this.table.rightFrozenColCount && this.rightBottomCornerGroup.setDeltaHeight(detaY);
            }
            else {
                this.rowHeaderGroup.setDeltaHeight(detaY);
                this.bodyGroup.setDeltaHeight(detaY);
                this.table.rightFrozenColCount && this.rightFrozenGroup.setDeltaHeight(detaY);
            }
        }
        updateContainerHeight(row, detaY) {
            this._updateContainerHeight(row, detaY);
            this.updateTableSize();
            this.component.updateScrollBar();
            this.updateNextFrame();
        }
        setColWidth(col, width) {
            const oldWidth = this.table.getColWidth(col);
            if (oldWidth === width) {
                return;
            }
            this.updateColWidth(col, width - oldWidth);
            this.table._clearColRangeWidthsMap(col);
        }
        setRowHeight(row, height) {
            const oldHeight = this.table.getRowHeight(row);
            if (oldHeight === height) {
                return;
            }
            if ((row >= this.proxy.rowStart && row <= this.proxy.rowEnd) ||
                (row >= this.table.rowCount - this.table.bottomFrozenRowCount && row <= this.table.rowCount - 1) ||
                row < this.table.frozenRowCount) {
                this.updateRowHeight(row, height - oldHeight);
            }
            this.table._clearRowRangeHeightsMap(row);
        }
        setX(x, isEnd = false) {
            this.table.scenegraph.proxy.setX(-x, isEnd);
        }
        setY(y, isEnd = false) {
            this.table.scenegraph.proxy.setY(-y, isEnd);
        }
        setBodyAndRowHeaderY(y) {
            const firstBodyCell = this.bodyGroup.firstChild?.firstChild ?? this.rowHeaderGroup.firstChild?.firstChild;
            const lastBodyCell = this.bodyGroup.firstChild?.lastChild ?? this.rowHeaderGroup.firstChild?.lastChild;
            if (y === 0 &&
                firstBodyCell &&
                firstBodyCell.row === this.table.frozenRowCount &&
                firstBodyCell.attribute.y + y < 0) {
                y = -firstBodyCell.attribute.y;
            }
            else if (lastBodyCell &&
                this.table.tableNoFrameHeight < this.table.getAllRowsHeight() &&
                lastBodyCell.row === this.table.rowCount - this.table.bottomFrozenRowCount - 1 &&
                lastBodyCell.attribute.y + lastBodyCell.attribute.height + y <
                    this.table.tableNoFrameHeight - this.table.getFrozenRowsHeight() - this.table.getBottomFrozenRowsHeight()) {
                y =
                    this.table.tableNoFrameHeight -
                        this.table.getFrozenRowsHeight() -
                        this.table.getBottomFrozenRowsHeight() -
                        lastBodyCell.attribute.y -
                        lastBodyCell.attribute.height;
            }
            if (this.colHeaderGroup.attribute.height + y === this.bodyGroup.attribute.y) {
                return;
            }
            this.bodyGroup.setAttribute('y', this.colHeaderGroup.attribute.height + y);
            this.rowHeaderGroup.setAttribute('y', this.cornerHeaderGroup.attribute.height + y);
            if (this.table.rightFrozenColCount > 0) {
                this.rightFrozenGroup.setAttribute('y', this.rightTopCornerGroup.attribute.height + y);
            }
            this.updateNextFrame();
        }
        setBodyAndColHeaderX(x) {
            const firstBodyCol = this.bodyGroup.firstChild;
            const lastBodyCol = this.bodyGroup.lastChild;
            if (x === 0 && firstBodyCol && firstBodyCol.col === this.table.frozenColCount && firstBodyCol.attribute.x + x < 0) {
                x = -firstBodyCol.attribute.x;
            }
            else if (lastBodyCol &&
                this.table.tableNoFrameWidth < this.table.getAllColsWidth() &&
                lastBodyCol.col === this.table.colCount - this.table.rightFrozenColCount - 1 &&
                lastBodyCol.attribute.x + lastBodyCol.attribute.width + x <
                    this.table.tableNoFrameWidth - this.table.getFrozenColsWidth() - this.table.getRightFrozenColsWidth()) {
                x =
                    this.table.tableNoFrameWidth -
                        this.table.getFrozenColsWidth() -
                        this.table.getRightFrozenColsWidth() -
                        lastBodyCol.attribute.x -
                        lastBodyCol.attribute.width;
            }
            if (this.table.getFrozenColsWidth() + x === this.bodyGroup.attribute.x) {
                return;
            }
            this.bodyGroup.setAttribute('x', this.table.getFrozenColsWidth() + x);
            this.colHeaderGroup.setAttribute('x', this.table.getFrozenColsWidth() + x);
            if (this.table.bottomFrozenRowCount > 0) {
                this.bottomFrozenGroup.setAttribute('x', this.table.getFrozenColsWidth() + x);
            }
            this.updateNextFrame();
        }
        afterScenegraphCreated() {
            if (!this.isPivot && !this.table.transpose) {
                this.component.setFrozenColumnShadow(this.table.frozenColCount - 1);
                this.component.setRightFrozenColumnShadow(this.table.colCount - this.table.rightFrozenColCount);
            }
            else if (this.table.options.frozenColCount) {
                this.component.setFrozenColumnShadow(this.table.frozenColCount - 1);
            }
            else if (this.table.options.rightFrozenColCount) {
                this.component.setRightFrozenColumnShadow(this.table.colCount - this.table.rightFrozenColCount);
            }
            else {
                this.component.setFrozenColumnShadow(-1);
            }
            this.table.stateManager.checkFrozen();
            this.updateContainer();
            this.createFrameBorder();
            this.updateBorderSizeAndPosition();
            this.component.updateScrollBar();
            handleTextStick(this.table);
            if (this.table.options.animationAppear) {
                dealWithAnimationAppear(this.table);
            }
            this.updateNextFrame();
        }
        dealWidthMode() {
            const table = this.table;
            if (table.widthMode === 'adaptive') {
                table._clearColRangeWidthsMap();
                const canvasWidth = table.tableNoFrameWidth;
                let actualHeaderWidth = 0;
                let startCol = 0;
                let endCol = table.colCount;
                if (table.widthAdaptiveMode === 'only-body') {
                    for (let col = 0; col < table.colCount; col++) {
                        if (col < table.rowHeaderLevelCount ||
                            (table.isPivotChart() && col >= table.colCount - table.rightFrozenColCount)) {
                            const colWidth = table.getColWidth(col);
                            actualHeaderWidth += colWidth;
                        }
                    }
                    startCol = table.rowHeaderLevelCount;
                    endCol = table.isPivotChart() ? table.colCount - table.rightFrozenColCount : table.colCount;
                }
                getAdaptiveWidth(canvasWidth - actualHeaderWidth, startCol, endCol, false, [], table, true);
            }
            else if (table.autoFillWidth) {
                table._clearColRangeWidthsMap();
                const canvasWidth = table.tableNoFrameWidth;
                let actualHeaderWidth = 0;
                let actualWidth = 0;
                for (let col = 0; col < table.colCount; col++) {
                    const colWidth = table.getColWidth(col);
                    if (col < table.rowHeaderLevelCount ||
                        (table.isPivotChart() && col >= table.colCount - table.rightFrozenColCount)) {
                        actualHeaderWidth += colWidth;
                    }
                    actualWidth += colWidth;
                }
                if (actualWidth < canvasWidth && actualWidth > actualHeaderWidth) {
                    const startCol = table.rowHeaderLevelCount;
                    const endCol = table.isPivotChart() ? table.colCount - table.rightFrozenColCount : table.colCount;
                    getAdaptiveWidth(canvasWidth - actualHeaderWidth, startCol, endCol, false, [], table, true);
                }
            }
            let bodyWidth = 0;
            this.bodyGroup.forEachChildrenSkipChild((column) => {
                bodyWidth += column.attribute.width;
            });
            this.bodyGroup.setAttribute('width', bodyWidth);
            let colHeaderWidth = 0;
            this.colHeaderGroup.forEachChildrenSkipChild((column) => {
                colHeaderWidth += column.attribute.width;
            });
            this.colHeaderGroup.setAttribute('width', colHeaderWidth);
            let rowHeaderWidth = 0;
            this.rowHeaderGroup.forEachChildrenSkipChild((column) => {
                rowHeaderWidth += column.attribute.width;
            });
            this.rowHeaderGroup.setAttribute('width', rowHeaderWidth);
            let cornerHeaderWidth = 0;
            this.cornerHeaderGroup.forEachChildrenSkipChild((column) => {
                cornerHeaderWidth += column.attribute.width;
            });
            this.cornerHeaderGroup.setAttribute('width', cornerHeaderWidth);
            this.colHeaderGroup.setAttribute('x', this.cornerHeaderGroup.attribute.width);
            this.rowHeaderGroup.setAttribute('y', this.cornerHeaderGroup.attribute.height);
            this.bodyGroup.setAttributes({
                x: this.rowHeaderGroup.attribute.width,
                y: this.colHeaderGroup.attribute.height
            });
        }
        dealHeightMode() {
            const table = this.table;
            if (table.heightMode === 'adaptive') {
                table._clearRowRangeHeightsMap();
                const columnHeaderHeight = table.getRowsHeight(0, table.columnHeaderLevelCount - 1);
                const bottomHeaderHeight = table.isPivotChart() ? table.getBottomFrozenRowsHeight() : 0;
                const totalDrawHeight = table.tableNoFrameHeight - columnHeaderHeight - bottomHeaderHeight;
                const startRow = table.columnHeaderLevelCount;
                const endRow = table.isPivotChart() ? table.rowCount - table.bottomFrozenRowCount : table.rowCount;
                let actualHeight = 0;
                for (let row = startRow; row < endRow; row++) {
                    actualHeight += table.getRowHeight(row);
                }
                const factor = totalDrawHeight / actualHeight;
                for (let row = startRow; row < endRow; row++) {
                    let rowHeight;
                    if (row === endRow - 1) {
                        rowHeight = totalDrawHeight - table.getRowsHeight(startRow, endRow - 2);
                    }
                    else {
                        rowHeight = Math.round(table.getRowHeight(row) * factor);
                    }
                    this.setRowHeight(row, rowHeight);
                }
            }
            else if (table.autoFillHeight) {
                table._clearRowRangeHeightsMap();
                const canvasHeight = table.tableNoFrameHeight;
                let actualHeight = 0;
                let actualHeaderHeight = 0;
                for (let row = 0; row < table.rowCount; row++) {
                    const rowHeight = table.getRowHeight(row);
                    if (row < table.columnHeaderLevelCount ||
                        (table.isPivotChart() && row >= table.rowCount - table.bottomFrozenRowCount)) {
                        actualHeaderHeight += rowHeight;
                    }
                    actualHeight += rowHeight;
                }
                if ((this._dealAutoFillHeightOriginRowsHeight ?? actualHeight) < canvasHeight &&
                    actualHeight - actualHeaderHeight > 0) {
                    const startRow = table.columnHeaderLevelCount;
                    const endRow = table.isPivotChart() ? table.rowCount - table.bottomFrozenRowCount : table.rowCount;
                    const factor = (canvasHeight - actualHeaderHeight) / (actualHeight - actualHeaderHeight);
                    for (let row = startRow; row < endRow; row++) {
                        let rowHeight;
                        if (row === endRow - 1) {
                            rowHeight = canvasHeight - actualHeaderHeight - table.getRowsHeight(startRow, endRow - 2);
                        }
                        else {
                            rowHeight = Math.round(table.getRowHeight(row) * factor);
                        }
                        this.setRowHeight(row, rowHeight);
                    }
                }
            }
        }
        dealFrozen() {
            dealFrozen(this);
        }
        resetFrozen() {
            resetFrozen(this);
        }
        resetRowFrozen() {
            resetRowFrozen(this);
        }
        updateCellLayoutWidthCertainWidth(columnGroup, detaRow, col) {
            const width = columnGroup.attribute.width;
            let isUpdate = false;
            columnGroup.forEachChildren((cellGroup, row) => {
                row += detaRow;
                const mergeInfo = getCellMergeInfo(this.table, col, row);
                if (mergeInfo) {
                    cellGroup = this.getCell(mergeInfo.start.col, mergeInfo.start.row);
                }
                else {
                    cellGroup.setAttribute('width', width);
                }
                const headerStyle = this.table._getCellStyle(col, row);
                const padding = getQuadProps(getProp('padding', headerStyle, col, row, this.table));
                const text = cellGroup.getChildByName('text');
                let oldCellHeight = 0;
                let newCellHeight = 0;
                if (text) {
                    oldCellHeight = text.AABBBounds.height() + (padding[0] + padding[2]);
                    text.setAttribute('maxLineWidth', width - (padding[1] + padding[3]));
                    newCellHeight = text.AABBBounds.height() + (padding[0] + padding[2]);
                }
                else {
                    const group = cellGroup.getChildAt(1);
                    oldCellHeight = group.AABBBounds.height() + (padding[0] + padding[2]);
                    group._cellWidth = width - (padding[1] + padding[3]);
                    group.layout();
                    newCellHeight = group.AABBBounds.height() + (padding[0] + padding[2]);
                }
                const rowHeight = this.table.getRowHeight(row);
                if (cellGroup.attribute.height !== newCellHeight) {
                    cellGroup.setAttribute('height', newCellHeight);
                    if (rowHeight === oldCellHeight) {
                        isUpdate = true;
                    }
                    else if (newCellHeight > rowHeight) {
                        isUpdate = true;
                    }
                }
            });
            return isUpdate;
        }
        updateHeaderPosition(updateColStart, updateColEnd, updateRowStart, updateRowEnd, moveType) {
            moveHeaderPosition(updateColStart, updateColEnd, updateRowStart, updateRowEnd, moveType, this.table);
        }
        updateContainerAttrWidthAndX() {
            const cornerX = updateContainerChildrenX(this.cornerHeaderGroup, 0);
            const rowHeaderX = updateContainerChildrenX(this.rowHeaderGroup, 0);
            const colHeaderX = this.colHeaderGroup.hasChildNodes() && this.colHeaderGroup.firstChild
                ? updateContainerChildrenX(this.colHeaderGroup, this.colHeaderGroup.firstChild.col > 0
                    ? this.table.getColsWidth(this.table.frozenColCount ?? 0, this.colHeaderGroup.firstChild.col - 1)
                    : 0)
                : 0;
            const bodyX = this.bodyGroup.hasChildNodes() && this.bodyGroup.firstChild
                ? updateContainerChildrenX(this.bodyGroup, this.bodyGroup.firstChild.col > 0
                    ? this.table.getColsWidth(this.table.frozenColCount ?? 0, this.bodyGroup.firstChild.col - 1)
                    : 0)
                : 0;
            const rightX = updateContainerChildrenX(this.rightFrozenGroup.childrenCount > 0 ? this.rightFrozenGroup : this.rightTopCornerGroup, 0);
            this.bottomFrozenGroup.hasChildNodes() &&
                this.bottomFrozenGroup.firstChild &&
                updateContainerChildrenX(this.bottomFrozenGroup, this.bottomFrozenGroup.firstChild.col > 0
                    ? this.table.getColsWidth(this.table.frozenColCount ?? 0, this.bottomFrozenGroup.firstChild.col - 1)
                    : 0);
            updateContainerChildrenX(this.leftBottomCornerGroup, 0);
            updateContainerChildrenX(this.rightTopCornerGroup, 0);
            updateContainerChildrenX(this.rightBottomCornerGroup, 0);
            this.cornerHeaderGroup.setDeltaWidth(cornerX - this.cornerHeaderGroup.attribute.width);
            this.leftBottomCornerGroup.setDeltaWidth(cornerX - this.leftBottomCornerGroup.attribute.width);
            this.colHeaderGroup.setDeltaWidth(colHeaderX - this.colHeaderGroup.attribute.width);
            this.rowHeaderGroup.setDeltaWidth(rowHeaderX - this.rowHeaderGroup.attribute.width);
            this.bottomFrozenGroup.setDeltaWidth(colHeaderX - this.bottomFrozenGroup.attribute.width);
            this.rightFrozenGroup.setDeltaWidth(rightX - this.rightFrozenGroup.attribute.width);
            this.rightTopCornerGroup.setDeltaWidth(rightX - this.rightTopCornerGroup.attribute.width);
            this.rightBottomCornerGroup.setDeltaWidth(rightX - this.rightBottomCornerGroup.attribute.width);
            this.bodyGroup.setDeltaWidth(bodyX - this.bodyGroup.attribute.width);
            this.colHeaderGroup.setAttribute('x', this.cornerHeaderGroup.attribute.width);
            this.bottomFrozenGroup.setAttribute('x', this.table.getFrozenColsWidth());
            this.bodyGroup.setAttribute('x', this.rowHeaderGroup.attribute.width);
        }
        updateContainer(async = false) {
            if (async) {
                if (!this._needUpdateContainer) {
                    this._needUpdateContainer = true;
                    setTimeout(() => {
                        this.updateContainerSync();
                    }, 0);
                }
            }
            else {
                this._needUpdateContainer = true;
                this.updateContainerSync();
            }
        }
        updateContainerSync() {
            if (!this._needUpdateContainer) {
                return;
            }
            this._needUpdateContainer = false;
            this.updateContainerAttrWidthAndX();
            this.updateTableSize();
            this.component.updateScrollBar();
            this.updateNextFrame();
        }
        updateCellContentWhileResize(col, row) {
            const isVtableMerge = this.table.getCellRawRecord(col, row)?.vtableMerge;
            const type = isVtableMerge
                ? 'text'
                : this.table.isHeader(col, row)
                    ? this.table._getHeaderLayoutMap(col, row).headerType
                    : this.table.getBodyColumnType(col, row);
            const cellGroup = this.getCell(col, row);
            if (type === 'image' || type === 'video') {
                updateImageCellContentWhileResize(cellGroup, col, row, 0, 0, this.table);
            }
        }
        createFrameBorder() {
            this.updateTableSize();
            const isListTableWithFrozen = !this.isPivot && !this.table.internalProps.transpose;
            createFrameBorder(this.bodyGroup, this.table.theme.bodyStyle.frameStyle, this.bodyGroup.role, isListTableWithFrozen ? [true, true, true, false] : undefined);
            createFrameBorder(this.rowHeaderGroup, this.isPivot
                ? this.table.theme.rowHeaderStyle.frameStyle
                : this.table.internalProps.transpose
                    ? this.table.theme.rowHeaderStyle.frameStyle
                    : this.table.theme.bodyStyle.frameStyle, this.rowHeaderGroup.role, isListTableWithFrozen ? [true, false, true, true] : undefined);
            createFrameBorder(this.colHeaderGroup, this.table.theme.headerStyle.frameStyle, this.colHeaderGroup.role, isListTableWithFrozen ? [true, true, true, false] : undefined);
            createFrameBorder(this.cornerHeaderGroup, this.isPivot ? this.table.theme.cornerHeaderStyle.frameStyle : this.table.theme.headerStyle.frameStyle, this.cornerHeaderGroup.role, isListTableWithFrozen ? [true, false, true, true] : undefined);
            this.table.theme.cornerLeftBottomCellStyle?.frameStyle &&
                createFrameBorder(this.leftBottomCornerGroup, this.table.theme.cornerLeftBottomCellStyle.frameStyle, this.leftBottomCornerGroup.role, isListTableWithFrozen ? [true, false, true, true] : undefined);
            this.table.theme.bottomFrozenStyle?.frameStyle &&
                createFrameBorder(this.bottomFrozenGroup, this.table.theme.bottomFrozenStyle.frameStyle, this.bottomFrozenGroup.role, isListTableWithFrozen ? [true, true, true, false] : undefined);
            this.table.theme.rightFrozenStyle?.frameStyle &&
                createFrameBorder(this.rightFrozenGroup, this.table.theme.rightFrozenStyle.frameStyle, this.rightFrozenGroup.role, undefined);
            this.table.theme.cornerRightTopCellStyle?.frameStyle &&
                createFrameBorder(this.rightTopCornerGroup, this.table.theme.cornerRightTopCellStyle.frameStyle, this.rightTopCornerGroup.role, undefined);
            this.table.theme.cornerRightBottomCellStyle?.frameStyle &&
                createFrameBorder(this.rightBottomCornerGroup, this.table.theme.cornerRightBottomCellStyle.frameStyle, this.rightBottomCornerGroup.role, undefined);
            createFrameBorder(this.tableGroup, this.table.theme.frameStyle, this.tableGroup.role, undefined);
        }
        getResizeColAt(abstractX, abstractY, cellGroup) {
            const offset = this.table.theme.columnResize.resizeHotSpotSize / 2;
            let cell;
            if (!cellGroup) {
                const drawRange = this.table.getDrawRange();
                if (abstractY >= drawRange.top && abstractY <= drawRange.bottom) {
                    cell = this.table.getCellAtRelativePosition(abstractX - offset, abstractY);
                    if (cell.col === this.table.colCount - 1) {
                        return cell;
                    }
                }
                return { col: -1, row: -1 };
            }
            if (!cellGroup.stage) {
                return { col: -1, row: -1 };
            }
            if (abstractX < cellGroup.globalAABBBounds.x1 + offset) {
                cell = { col: cellGroup.col - 1, row: cellGroup.row, x: cellGroup.globalAABBBounds.x1 };
            }
            else if (cellGroup.globalAABBBounds.x2 - offset < abstractX) {
                cell = { col: cellGroup.col, row: cellGroup.row, x: cellGroup.globalAABBBounds.x2 };
            }
            if (cell &&
                this.table.rightFrozenColCount > 0 &&
                cell.col >= this.table.colCount - this.table.rightFrozenColCount - 1 &&
                this.table.tableNoFrameWidth -
                    this.table.getFrozenColsWidth() -
                    this.table.getRightFrozenColsWidth() +
                    this.table.scrollLeft <
                    this.bodyGroup.attribute.width) {
                cell.col = cell.col + 1;
                cell.rightFrozen = true;
            }
            if (cell) {
                return cell;
            }
            return { col: -1, row: -1 };
        }
        getResizeRowAt(abstractX, abstractY, cellGroup) {
            const offset = this.table.theme.columnResize.resizeHotSpotSize / 2;
            if (!cellGroup) ;
            else {
                let cell;
                if (abstractY < cellGroup.globalAABBBounds.y1 + offset) {
                    cell = { col: cellGroup.col, row: cellGroup.row - 1, y: cellGroup.globalAABBBounds.y1 };
                }
                else if (cellGroup.globalAABBBounds.y2 - offset < abstractY) {
                    cell = { col: cellGroup.col, row: cellGroup.row, y: cellGroup.globalAABBBounds.y2 };
                }
                if (cell &&
                    this.table.bottomFrozenRowCount > 0 &&
                    cell.row >= this.table.rowCount - this.table.bottomFrozenRowCount - 1 &&
                    this.table.tableNoFrameHeight -
                        this.table.getFrozenRowsHeight() -
                        this.table.getBottomFrozenRowsHeight() +
                        this.table.scrollTop <
                        this.bodyGroup.attribute.height) {
                    cell.row = cell.row + 1;
                    cell.bottomFrozen = true;
                }
                if (cell) {
                    return cell;
                }
            }
            return { col: -1, row: -1 };
        }
        updateFrozen() {
            if (this.clear) {
                return;
            }
            this.resetFrozen();
            this.component.updateScrollBar();
        }
        updateRowFrozen() {
            if (this.clear) {
                return;
            }
            this.resetRowFrozen();
            this.component.updateScrollBar();
        }
        dealWidthRightFrozen(rightFrozenColCount) {
            if (this.clear) {
                this.table.internalProps.rightFrozenColCount = rightFrozenColCount;
                return;
            }
            dealRightFrozen(rightFrozenColCount, this);
        }
        dealWidthBottomFrozen(bottomFrozenRowCount) {
            if (this.clear) {
                this.table.internalProps.bottomFrozenRowCount = bottomFrozenRowCount;
                return;
            }
            dealBottomFrozen(bottomFrozenRowCount, this);
        }
        updateBorderSizeAndPosition() {
            if (this.bodyGroup.border) {
                this.bodyGroup.appendChild(this.bodyGroup.border);
                updateFrameBorderSize(this.bodyGroup);
                if (this.rowHeaderGroup.attribute.width === 0) {
                    updateFrameBorder(this.bodyGroup, this.table.theme.bodyStyle.frameStyle);
                }
                else {
                    updateFrameBorder(this.bodyGroup, this.table.theme.bodyStyle.frameStyle);
                }
            }
            if (this.colHeaderGroup.border) {
                this.colHeaderGroup.appendChild(this.colHeaderGroup.border);
                updateFrameBorderSize(this.colHeaderGroup);
                if (this.cornerHeaderGroup.attribute.width === 0) {
                    updateFrameBorder(this.colHeaderGroup, this.table.theme.headerStyle.frameStyle);
                }
                else {
                    updateFrameBorder(this.colHeaderGroup, this.table.theme.headerStyle.frameStyle);
                }
            }
            if (this.rowHeaderGroup.border) {
                this.rowHeaderGroup.appendChild(this.rowHeaderGroup.border);
                updateFrameBorderSize(this.rowHeaderGroup);
            }
            if (this.cornerHeaderGroup.border) {
                this.cornerHeaderGroup.appendChild(this.cornerHeaderGroup.border);
                updateFrameBorderSize(this.cornerHeaderGroup);
            }
            if (this.leftBottomCornerGroup.border) {
                this.leftBottomCornerGroup.appendChild(this.leftBottomCornerGroup.border);
                updateFrameBorderSize(this.leftBottomCornerGroup);
            }
            if (this.bottomFrozenGroup.border) {
                this.bottomFrozenGroup.appendChild(this.bottomFrozenGroup.border);
                updateFrameBorderSize(this.bottomFrozenGroup);
            }
            if (this.rightFrozenGroup.border) {
                this.rightFrozenGroup.appendChild(this.rightFrozenGroup.border);
                updateFrameBorderSize(this.rightFrozenGroup);
            }
            if (this.rightTopCornerGroup.border) {
                this.rightTopCornerGroup.appendChild(this.rightTopCornerGroup.border);
                updateFrameBorderSize(this.rightTopCornerGroup);
            }
            if (this.rightBottomCornerGroup.border) {
                this.rightBottomCornerGroup.appendChild(this.rightBottomCornerGroup.border);
                updateFrameBorderSize(this.rightBottomCornerGroup);
            }
            updateCornerRadius(this.table);
        }
        sortCell() {
            if (this.isPivot) ;
            else if (this.table.transpose) {
                this.proxy.sortCellHorizontal();
            }
            else {
                this.proxy.sortCellVertical();
            }
        }
        getCellOverflowText(col, row) {
            const cellGroup = this.getCell(col, row);
            const text = cellGroup.getChildByName('text', true);
            if (text && text.type === 'text') {
                if (text.attribute.moreThanMaxCharacters) {
                    return this.table.getCellValue(col, row);
                }
                if (text.cliped) {
                    return this.table.getCellValue(col, row);
                }
            }
            else if (text && text.type === 'richtext') {
                const richtext = text;
                if (richtext.attribute.ellipsis &&
                    richtext._frameCache &&
                    richtext.attribute.height < richtext._frameCache.actualHeight) {
                    richtext.attribute.textConfig.find((item) => item.text);
                    return this.table.getCellValue(col, row);
                }
            }
            return null;
        }
        updateDrill(visible, x, y, drillDown, drillUp) {
            this.component.drillIcon.update(visible, x, y, drillDown, drillUp, this);
        }
        updateCellContent(col, row, forceFastUpdate = false) {
            if (this.clear) {
                return undefined;
            }
            return updateCell$1(col, row, this.table, undefined, undefined, forceFastUpdate);
        }
        setPixelRatio(pixelRatio) {
            this.stage.disableDirtyBounds();
            this.stage.window.setDpr(pixelRatio);
            this.stage.render();
            this.stage.enableDirtyBounds();
        }
        updateRow(removeCells, addCells, updateCells = [], recalculateColWidths = true, skipUpdateProxy) {
            this.table.internalProps.layoutMap.clearCellRangeMap();
            this.table.internalProps.useOneRowHeightFillAll = false;
            const addRows = deduplication$1(addCells.map(cell => cell.row)).sort((a, b) => a - b);
            const updateRows = deduplication$1(updateCells.map(cell => cell.row)).sort((a, b) => a - b);
            const isNotFillHeight = this.table.getAllRowsHeight() -
                [...addRows, ...updateRows].reduce((tolHeight, rowNumber) => {
                    return tolHeight + this.table.getRowHeight(rowNumber);
                }, 0) <=
                this.table.tableNoFrameHeight;
            updateRow(removeCells, addCells, updateCells, this.table, skipUpdateProxy);
            recalculateColWidths && this.recalculateColWidths();
            if (this.table.heightMode === 'adaptive' ||
                (this.table.autoFillHeight && (this.table.getAllRowsHeight() <= this.table.tableNoFrameHeight || isNotFillHeight))) {
                this.table.scenegraph.recalculateRowHeights();
            }
            else if (this.table.isAutoRowHeight(this.table.columnHeaderLevelCount)) {
                for (let i = 0; i < updateRows.length; i++) {
                    const row = updateRows[i];
                    const oldHeight = this.table.getRowHeight(row);
                    const newHeight = computeRowHeight(row, 0, this.table.colCount - 1, this.table);
                    if ((row >= this.proxy.rowStart && row <= this.proxy.rowEnd) ||
                        (row >= this.table.rowCount - this.table.bottomFrozenRowCount && row <= this.table.rowCount - 1)) {
                        this.table.scenegraph.updateRowHeight(row, newHeight - oldHeight);
                    }
                }
            }
            this.table.stateManager.checkFrozen();
            if (!this.isPivot && !this.table.transpose) {
                this.component.setFrozenColumnShadow(this.table.frozenColCount - 1);
                this.component.setRightFrozenColumnShadow(this.table.colCount - this.table.rightFrozenColCount);
            }
            else if (this.table.options.frozenColCount) {
                this.component.setFrozenColumnShadow(this.table.frozenColCount - 1);
            }
            else if (this.table.options.rightFrozenColCount) {
                this.component.setRightFrozenColumnShadow(this.table.colCount - this.table.rightFrozenColCount);
            }
            this.component.updateScrollBar();
            this.updateNextFrame();
        }
        updateCol(removeCells, addCells, updateCells = []) {
            updateCol(removeCells, addCells, updateCells, this.table);
            this.recalculateColWidths();
            this.recalculateRowHeights();
            this.table.stateManager.checkFrozen();
            if (!this.isPivot && !this.table.transpose) {
                this.component.setFrozenColumnShadow(this.table.frozenColCount - 1);
                this.component.setRightFrozenColumnShadow(this.table.colCount - this.table.rightFrozenColCount);
            }
            else if (this.table.options.frozenColCount) {
                this.component.setFrozenColumnShadow(this.table.frozenColCount - 1);
            }
            else if (this.table.options.rightFrozenColCount) {
                this.component.setRightFrozenColumnShadow(this.table.colCount - this.table.rightFrozenColCount);
            }
            this.component.updateScrollBar();
            this.updateNextFrame();
        }
        updateCornerHeaderCells() {
            for (let col = 0; col < this.table.frozenColCount; col++) {
                for (let row = 0; row < this.table.frozenRowCount; row++) {
                    updateCell$1(col, row, this.table, false);
                }
            }
        }
        updateRowHeaderCells() {
            for (let col = 0; col < this.table.frozenColCount; col++) {
                for (let row = this.table.frozenRowCount; row < this.table.rowCount; row++) {
                    updateCell$1(col, row, this.table, false);
                }
            }
        }
        updateColumnHeaderCells() {
            for (let row = 0; row < this.table.frozenRowCount; row++) {
                for (let col = this.table.frozenColCount; col < this.table.colCount; col++) {
                    updateCell$1(col, row, this.table, false);
                }
            }
        }
        getColumnGroupX(col) {
            if (col < this.table.rowHeaderLevelCount) {
                return this.table.getColsWidth(0, col - 1);
            }
            else if (col < this.table.colCount - this.table.rightFrozenColCount) {
                return this.table.getColsWidth(this.table.rowHeaderLevelCount, col - 1);
            }
            else if (col < this.table.colCount) {
                return this.table.getColsWidth(this.table.colCount - this.table.bottomFrozenRowCount, col - 1);
            }
            return 0;
        }
        getCellGroupY(row) {
            if (row < this.table.frozenRowCount) {
                return this.table.getRowsHeight(0, row - 1);
            }
            else if (row < this.table.rowCount - this.table.bottomFrozenRowCount) {
                return this.table.getRowsHeight(this.table.frozenRowCount, row - 1);
            }
            else if (row < this.table.rowCount) {
                return this.table.getRowsHeight(this.table.rowCount - this.table.bottomFrozenRowCount, row - 1);
            }
            return 0;
        }
        getCellGroupX(col) {
            if (col < this.table.rowHeaderLevelCount) {
                return this.table.getColsWidth(0, col - 1);
            }
            else if (col < this.table.colCount - this.table.rightFrozenColCount) {
                return this.table.getColsWidth(this.table.rowHeaderLevelCount, col - 1);
            }
            else if (col < this.table.colCount) {
                return this.table.getColsWidth(this.table.colCount - this.table.rightFrozenColCount, col - 1);
            }
            return 0;
        }
        updateDomContainer() {
            updateReactContainer(this.table);
        }
        setLoadingHierarchyState(col, row) {
            const cellGroup = this.getCell(col, row);
            const iconGraphic = cellGroup.getChildByName('collapse', true) || cellGroup.getChildByName('expand', true);
            if (iconGraphic) {
                const regedIcons = get$2();
                const loadingIcon = regedIcons[InternalIconName.loadingIconName];
                if (loadingIcon) {
                    dealWithIcon(loadingIcon, iconGraphic, col, row);
                }
            }
        }
        temporarilyUpdateSelectRectStyle(rectAttribute) {
            temporarilyUpdateSelectRectStyle(rectAttribute, this);
        }
        resetSelectRectStyle() {
            this.recreateAllSelectRangeComponents();
        }
    }

    function checkCellInSelect(col, row, cellRanges) {
        for (let i = 0; i < cellRanges.length; i++) {
            const range = cellRanges[i];
            const _in = cellInRange(range, col, row);
            if (_in) {
                return true;
            }
        }
        return false;
    }
    function checkMultiCellInSelect(cellPosStart, cellPosEnd, selectRangs, selectMode) {
        for (let i = 0; i < selectRangs.length; i++) {
            const range = selectRangs[i];
            const inSelect = rangeIntersected(range, { start: cellPosStart, end: cellPosEnd });
            if (inSelect) {
                return true;
            }
        }
        return false;
    }

    function updateCell(scenegraph, col, row) {
        const cellGroup = scenegraph.highPerformanceGetCell(col, row);
        if (cellGroup.role === 'cell' &&
            isValid$3(cellGroup.mergeStartCol) &&
            isValid$3(cellGroup.mergeStartRow) &&
            isValid$3(cellGroup.mergeEndCol) &&
            isValid$3(cellGroup.mergeEndRow)) {
            const { colStart, colEnd, rowStart, rowEnd } = getCellMergeRange(cellGroup, scenegraph);
            for (let col = colStart; col <= colEnd; col++) {
                for (let row = rowStart; row <= rowEnd; row++) {
                    const mergeCell = scenegraph.highPerformanceGetCell(col, row);
                    if (mergeCell.role !== 'cell') {
                        continue;
                    }
                    mergeCell.addUpdateBoundTag();
                }
            }
        }
        else {
            cellGroup.addUpdateBoundTag();
        }
    }

    function clearColHover(scenegraph, col, rowOrigin, selectRanges, selectMode) {
        const table = scenegraph.table;
        for (let row = 0; row < table.columnHeaderLevelCount; row++) {
            updateCell(scenegraph, col, row);
        }
        const cellGroup = scenegraph.getColGroup(col);
        cellGroup?.addUpdateBoundTag();
        return true;
    }
    function updateColHover(scenegraph, col, rowOrigin, selectRanges, selectMode, singleStyle) {
        const table = scenegraph.table;
        for (let row = 0; row < table.columnHeaderLevelCount; row++) {
            updateCell(scenegraph, col, row);
        }
        const cellGroup = scenegraph.getColGroup(col);
        cellGroup?.addUpdateBoundTag();
        return true;
    }

    function clearRowHover(scenegraph, colOrigin, row, selectRanges, selectMode) {
        const table = scenegraph.table;
        for (let col = 0; col < table.colCount; col++) {
            updateCell(scenegraph, col, row);
        }
        return true;
    }
    function updateRowHover(scenegraph, colOrigin, row, selectRanges, selectMode, singleStyle) {
        const table = scenegraph.table;
        for (let col = 0; col < table.colCount; col++) {
            updateCell(scenegraph, col, row);
        }
        return true;
    }

    function clearSingleHover(scenegraph, col, row, selectRanges, selectMode) {
        updateCell(scenegraph, col, row);
        return true;
    }
    function updateSingleHover(scenegraph, col, row, selectRanges, selectMode) {
        updateCell(scenegraph, col, row);
        return true;
    }

    function updateHoverPosition(state, col, row) {
        const { table } = state;
        const { scenegraph } = table;
        const { highlightScope, singleStyle, disableHeader, cellPos, cellPosContainHeader } = state.hover;
        const prevHoverCellCol = cellPos.col;
        const prevHoverCellRow = cellPos.row;
        if (highlightScope === HighlightScope.none ||
            (disableHeader && (cellPosContainHeader.col !== col || cellPosContainHeader.row !== row))) {
            const prevHoverCellCol = cellPosContainHeader.col;
            const prevHoverCellRow = cellPosContainHeader.row;
            scenegraph.hideHoverIcon(prevHoverCellCol, prevHoverCellRow);
            scenegraph.showHoverIcon(col, row);
            cellPosContainHeader.col = col;
            cellPosContainHeader.row = row;
        }
        if ((disableHeader && table.isHeader(col, row)) || highlightScope === HighlightScope.none) {
            col = -1;
            row = -1;
        }
        if (prevHoverCellCol === col && prevHoverCellRow === row) {
            return;
        }
        if (!state.table.options.customConfig?.disableBuildInChartActive) {
            scenegraph.deactivateChart(prevHoverCellCol, prevHoverCellRow);
            scenegraph.activateChart(col, row);
        }
        let updateScenegraph = false;
        const { ranges, highlightScope: selectMode } = state.select;
        if (prevHoverCellCol !== -1 && prevHoverCellRow !== -1) {
            updateScenegraph = clearHover(scenegraph, prevHoverCellCol, prevHoverCellRow, ranges, singleStyle, highlightScope);
            if (!disableHeader) {
                scenegraph.hideHoverIcon(prevHoverCellCol, prevHoverCellRow);
            }
        }
        if (col === -1 || row === -1) {
            cellPos.col = -1;
            cellPos.row = -1;
            if (updateScenegraph && (prevHoverCellCol !== col || prevHoverCellRow !== row)) {
                state.table.scenegraph.updateNextFrame();
            }
            return;
        }
        if (highlightScope === HighlightScope.single) {
            updateScenegraph = updateSingleHover(scenegraph, col, row) ? true : updateScenegraph;
        }
        else if (highlightScope === HighlightScope.row) {
            updateScenegraph = updateRowHover(scenegraph, col, row)
                ? true
                : updateScenegraph;
        }
        else if (highlightScope === HighlightScope.column) {
            updateScenegraph = updateColHover(scenegraph, col)
                ? true
                : updateScenegraph;
        }
        else if (highlightScope === HighlightScope.cross) {
            updateScenegraph = updateRowHover(scenegraph, col, row) ? true : updateScenegraph;
            updateScenegraph = updateColHover(scenegraph, col) ? true : updateScenegraph;
        }
        if (highlightScope !== HighlightScope.none && !disableHeader) {
            scenegraph.showHoverIcon(col, row);
        }
        cellPos.col = col;
        cellPos.row = row;
        if (updateScenegraph) {
            state.table.scenegraph.updateNextFrame();
        }
    }
    function clearHover(scenegraph, col, row, selectRanges, singleStyle, mode, selectMode) {
        let updateScenegraph = false;
        if (mode === HighlightScope.single) {
            updateScenegraph = clearSingleHover(scenegraph, col, row) ? true : updateScenegraph;
        }
        else if (mode === HighlightScope.row) {
            updateScenegraph = clearRowHover(scenegraph, col, row) ? true : updateScenegraph;
        }
        else if (mode === HighlightScope.column) {
            updateScenegraph = clearColHover(scenegraph, col) ? true : updateScenegraph;
        }
        else if (mode === HighlightScope.cross) {
            updateScenegraph = clearRowHover(scenegraph, col, row) ? true : updateScenegraph;
            updateScenegraph = clearColHover(scenegraph, col) ? true : updateScenegraph;
        }
        return updateScenegraph;
    }

    function dealFreeze(col, row, table) {
        if (table.frozenColCount > 0) {
            if (col !== table.frozenColCount - 1) {
                table.setFrozenColCount(col + 1);
            }
            else {
                table.setFrozenColCount(0);
            }
        }
        else {
            table.setFrozenColCount(col + 1);
        }
    }

    function dealSort(col, row, table, event) {
        let range1 = null;
        let tableState;
        let isTargetCell = false;
        if (Array.isArray(table.sortState)) {
            for (let i = 0; i < table.sortState.length; i++) {
                tableState = table.sortState[i];
                if (tableState) {
                    range1 = table._getHeaderCellBySortState(tableState);
                }
                range1 && (isTargetCell = isTarget(col, row, range1.col, range1.row, table));
                if (isTargetCell) {
                    break;
                }
            }
        }
        else {
            tableState = table.sortState;
            if (tableState) {
                range1 = table._getHeaderCellBySortState(tableState);
            }
            range1 && (isTargetCell = isTarget(col, row, range1.col, range1.row, table));
        }
        const headerC = table.getHeaderDefine(col, row);
        if (tableState && isTargetCell && headerC?.sort) {
            tableState.order = tableState.order === 'asc' ? 'desc' : tableState.order === 'desc' ? 'normal' : 'asc';
        }
        else if (headerC?.sort) {
            tableState = {
                field: table.getHeaderField(col, row),
                order: 'asc'
            };
        }
        else if (isTargetCell && headerC?.showSort) ;
        else {
            tableState = {
                field: table.getHeaderField(col, row),
                order: 'normal'
            };
        }
        tableState.event = event;
        const sortEventReturns = table.fireListeners(TABLE_EVENT_TYPE.SORT_CLICK, tableState);
        if (sortEventReturns.includes(false)) {
            return;
        }
        let isArraySortState = false;
        let sortState = table.internalProps.sortState
            ? Array.isArray(table.internalProps.sortState) && (isArraySortState = true)
                ? table.internalProps.sortState
                : [table.internalProps.sortState]
            : [];
        if (Array.isArray(sortState)) {
            const index = sortState.findIndex(item => item.field === tableState.field);
            if (index >= 0) {
                sortState[index] = tableState;
            }
            else {
                sortState.push(tableState);
            }
        }
        sortState = sortState.filter(item => item.order !== 'normal');
        sortState = table.internalProps.multipleSort && (isArraySortState = true) ? sortState : sortState.splice(-1);
        sortState = isArraySortState && sortState.length ? sortState : sortState[0];
        table.internalProps.sortState = sortState;
        table.stateManager.setSortState(sortState);
        if (headerC?.sort) {
            executeSort(sortState, table);
        }
        table.internalProps.useOneRowHeightFillAll = false;
        table.internalProps.layoutMap.clearCellRangeMap();
        table.scenegraph.sortCell();
        const isHasSelected = !!table.stateManager.select.ranges?.length;
        table.stateManager.updateSelectPos(-1, -1);
        table.stateManager.endSelectCells(true, isHasSelected);
    }
    function executeSort(newState, table, headerDefine) {
        newState = Array.isArray(newState) || !newState ? newState : [newState];
        table.dataSource.sort((newState || []).map(item => {
            const hd = table.internalProps.layoutMap.headerObjects.find((col) => col && col.field === item.field);
            return {
                field: item.field,
                order: item.order || 'asc',
                orderFn: typeof hd?.define?.sort === 'function' ? hd?.define?.sort : defaultOrderFn
            };
        }));
    }
    function isTarget(col, row, range1Col, range1Row, table) {
        return table._getLayoutCellId(col, row) === table._getLayoutCellId(range1Col, range1Row);
    }

    function updateSelectPosition(state, col, row, isShift, isCtrl, isSelectAll, makeSelectCellVisible = true, skipBodyMerge = false) {
        const { table, interactionState } = state;
        const { scenegraph } = table;
        const { highlightScope, disableHeader, cellPos, disableCtrlMultiSelect } = state.select;
        if (col !== -1 && row !== -1 && makeSelectCellVisible) {
            table._makeVisibleCell(col, row);
        }
        if (col !== -1 && row !== -1 && makeSelectCellVisible) {
            if (interactionState === InteractionState.grabing && state.select.ranges.length > 0) {
                const currentRange = state.select.ranges[state.select.ranges.length - 1];
                if (col > currentRange.start.col && col > currentRange.end.col) {
                    table._makeVisibleCell(col + 1, row);
                }
                if (row > currentRange.start.row && row > currentRange.end.row) {
                    table._makeVisibleCell(col, row + 1);
                }
                if (col < currentRange.start.col && col < currentRange.end.col) {
                    table._makeVisibleCell(col - 1, row);
                }
                if (row < currentRange.start.row && row < currentRange.end.row) {
                    table._makeVisibleCell(col, row - 1);
                }
            }
            else {
                table._makeVisibleCell(col, row);
            }
        }
        if (isSelectAll) {
            state.select.ranges = [];
            scenegraph.deleteAllSelectBorder();
            let _startCol = 0;
            let _startRow = 0;
            const { disableHeaderSelect, disableRowSeriesNumberSelect } = table.options.keyboardOptions?.selectAllOnCtrlA || {};
            if (disableHeaderSelect) {
                _startCol = table.rowHeaderLevelCount;
                _startRow = table.columnHeaderLevelCount;
            }
            if ((disableRowSeriesNumberSelect || (disableHeaderSelect && table.transpose)) &&
                table.options.rowSeriesNumber) {
                _startCol += 1;
            }
            state.select.ranges.push({
                start: { col: _startCol, row: _startRow },
                end: { col: table.colCount - 1, row: table.rowCount - 1 }
            });
            const currentRange = state.select.ranges[state.select.ranges.length - 1];
            scenegraph.updateCellSelectBorder(currentRange, false);
        }
        else if (cellPos.col !== -1 && cellPos.row !== -1 && (col === -1 || row === -1)) {
            cellPos.col = -1;
            cellPos.row = -1;
            state.select.ranges = [];
            scenegraph.deleteAllSelectBorder();
        }
        else if (interactionState === InteractionState.default &&
            !table.eventManager.isDraging &&
            !table.stateManager.isResizeCol()) {
            const currentRange = state.select.ranges[state.select.ranges.length - 1];
            if (isShift && currentRange) {
                if (!isCtrl || disableCtrlMultiSelect) {
                    cellPos.col = col;
                    cellPos.row = row;
                }
                if (state.select.headerSelectMode !== 'cell' && table.isColumnHeader(col, row)) {
                    const startCol = Math.min(currentRange.start.col, currentRange.end.col, col);
                    const endCol = Math.max(currentRange.start.col, currentRange.end.col, col);
                    const startRow = Math.min(currentRange.start.row, currentRange.end.row, row);
                    const endRow = table.rowCount - 1;
                    if (state.select.headerSelectMode === 'body') {
                        currentRange.start = { col: startCol, row: table.columnHeaderLevelCount };
                        currentRange.end = { col: endCol, row: table.rowCount - 1 };
                    }
                    else {
                        currentRange.start = { col: startCol, row: startRow };
                        currentRange.end = { col: endCol, row: endRow };
                    }
                }
                else if (state.select.headerSelectMode !== 'cell' && table.isRowHeader(col, row)) {
                    const startCol = Math.min(currentRange.start.col, currentRange.end.col, col);
                    const endCol = table.colCount - 1;
                    const startRow = Math.min(currentRange.start.row, currentRange.end.row, row);
                    const endRow = Math.max(currentRange.start.row, currentRange.end.row, row);
                    if (state.select.headerSelectMode === 'body') {
                        currentRange.start = { col: table.leftRowSeriesNumberCount + table.rowHeaderLevelCount, row: startRow };
                        currentRange.end = { col: table.colCount - 1, row: endRow };
                    }
                    else {
                        currentRange.start = { col: startCol, row: startRow };
                        currentRange.end = { col: endCol, row: endRow };
                    }
                }
                else if (state.select.headerSelectMode !== 'cell' && table.isSeriesNumberInBody(col, row)) {
                    const startCol = Math.min(currentRange.start.col, currentRange.end.col, col);
                    const endCol = table.colCount - 1;
                    const startRow = Math.min(currentRange.start.row, currentRange.end.row, row);
                    const endRow = Math.max(currentRange.start.row, currentRange.end.row, row);
                    if (state.select.headerSelectMode === 'body') {
                        currentRange.start = { col: table.leftRowSeriesNumberCount, row: startRow };
                        currentRange.end = { col: table.colCount - 1, row: endRow };
                    }
                    else {
                        currentRange.start = { col: startCol, row: startRow };
                        currentRange.end = { col: endCol, row: endRow };
                    }
                }
                else {
                    currentRange.end = { col, row };
                }
                scenegraph.deleteLastSelectedRangeComponents();
                scenegraph.updateCellSelectBorder(currentRange);
            }
            else {
                let extendSelectRange = true;
                if (cellPos.col !== -1 && cellPos.row !== -1 && (!isCtrl || disableCtrlMultiSelect)) {
                    state.select.ranges = [];
                    scenegraph.deleteAllSelectBorder();
                }
                if (state.select.headerSelectMode !== 'cell' && table.isColumnHeader(col, row)) {
                    const cellRange = table.getCellRange(col, row);
                    if (state.select.headerSelectMode === 'body') {
                        state.select.ranges.push({
                            start: { col: cellRange.start.col, row: table.columnHeaderLevelCount },
                            end: { col: cellRange.end.col, row: table.rowCount - 1 },
                            skipBodyMerge: true
                        });
                    }
                    else {
                        state.select.ranges.push({
                            start: { col: cellRange.start.col, row: cellRange.start.row },
                            end: { col: cellRange.end.col, row: table.rowCount - 1 },
                            skipBodyMerge: true
                        });
                    }
                }
                else if (state.select.headerSelectMode !== 'cell' && table.isRowHeader(col, row)) {
                    const cellRange = table.getCellRange(col, row);
                    if (state.select.headerSelectMode === 'body') {
                        state.select.ranges.push({
                            start: { col: table.rowHeaderLevelCount + table.leftRowSeriesNumberCount, row: cellRange.start.row },
                            end: { col: table.colCount - 1, row: cellRange.end.row },
                            skipBodyMerge: true
                        });
                    }
                    else {
                        state.select.ranges.push({
                            start: { col: cellRange.start.col, row: cellRange.start.row },
                            end: { col: table.colCount - 1, row: cellRange.end.row },
                            skipBodyMerge: true
                        });
                    }
                }
                else if (table.internalProps.layoutMap.isSeriesNumberInHeader(col, row)) {
                    extendSelectRange = false;
                    const { cornerHeaderSelectMode } = state.select;
                    if (cornerHeaderSelectMode === 'body') {
                        state.select.ranges.push({
                            start: {
                                col: table.leftRowSeriesNumberCount,
                                row: table.columnHeaderLevelCount
                            },
                            end: { col: table.colCount - 1, row: table.rowCount - 1 },
                            skipBodyMerge: true
                        });
                    }
                    else if (cornerHeaderSelectMode === 'inline') {
                        const cellRange = skipBodyMerge ? { start: { col, row }, end: { col, row } } : table.getCellRange(col, row);
                        state.select.ranges.push({
                            start: { col: cellRange.start.col, row: cellRange.start.row },
                            end: { col: cellRange.end.col, row: table.rowCount - 1 },
                            skipBodyMerge: true
                        });
                    }
                    else if (cornerHeaderSelectMode === 'cell') {
                        const cellRange = skipBodyMerge ? { start: { col, row }, end: { col, row } } : table.getCellRange(col, row);
                        state.select.ranges.push({
                            start: { col: cellRange.start.col, row: cellRange.start.row },
                            end: { col: cellRange.end.col, row: cellRange.end.row },
                            skipBodyMerge: skipBodyMerge || undefined
                        });
                    }
                    else {
                        state.select.ranges.push({
                            start: { col: 0, row: 0 },
                            end: { col: table.colCount - 1, row: table.rowCount - 1 },
                            skipBodyMerge: true
                        });
                    }
                }
                else if (table.internalProps.layoutMap.isSeriesNumberInBody(col, row)) {
                    extendSelectRange = false;
                    if (state.select.headerSelectMode === 'body') {
                        state.select.ranges.push({
                            start: {
                                col: table.leftRowSeriesNumberCount,
                                row
                            },
                            end: { col: table.colCount - 1, row: row },
                            skipBodyMerge: true
                        });
                    }
                    else {
                        state.select.ranges.push({
                            start: { col, row },
                            end: { col: table.colCount - 1, row: row },
                            skipBodyMerge: true
                        });
                    }
                }
                else if (table.internalProps.layoutMap.isCornerHeader(col, row)) {
                    extendSelectRange = false;
                    const { cornerHeaderSelectMode } = state.select;
                    if (cornerHeaderSelectMode === 'body') {
                        state.select.ranges.push({
                            start: {
                                col: table.rowHeaderLevelCount + table.leftRowSeriesNumberCount,
                                row: table.columnHeaderLevelCount
                            },
                            end: { col: table.colCount - 1, row: table.rowCount - 1 },
                            skipBodyMerge: true
                        });
                    }
                    else if (cornerHeaderSelectMode === 'cell') {
                        const cellRange = skipBodyMerge ? { start: { col, row }, end: { col, row } } : table.getCellRange(col, row);
                        state.select.ranges.push({
                            start: { col: cellRange.start.col, row: cellRange.start.row },
                            end: { col: cellRange.end.col, row: cellRange.end.row },
                            skipBodyMerge: skipBodyMerge || undefined
                        });
                    }
                    else if (cornerHeaderSelectMode === 'inline') {
                        const cellRange = skipBodyMerge ? { start: { col, row }, end: { col, row } } : table.getCellRange(col, row);
                        state.select.ranges.push({
                            start: { col: cellRange.start.col, row: cellRange.start.row },
                            end: { col: cellRange.end.col, row: table.rowCount - 1 },
                            skipBodyMerge: true
                        });
                    }
                    else if (cornerHeaderSelectMode === 'all') {
                        state.select.ranges.push({
                            start: {
                                col: table.leftRowSeriesNumberCount,
                                row: 0
                            },
                            end: { col: table.colCount - 1, row: table.rowCount - 1 },
                            skipBodyMerge: true
                        });
                    }
                    else {
                        state.select.ranges.push({
                            start: {
                                col: table.leftRowSeriesNumberCount,
                                row: 0
                            },
                            end: { col: table.colCount - 1, row: table.rowCount - 1 },
                            skipBodyMerge: true
                        });
                    }
                }
                else if (col >= 0 && row >= 0) {
                    const cellRange = skipBodyMerge ? { start: { col, row }, end: { col, row } } : table.getCellRange(col, row);
                    state.select.ranges.push({
                        start: { col: cellRange.start.col, row: cellRange.start.row },
                        end: { col: cellRange.end.col, row: cellRange.end.row },
                        skipBodyMerge: skipBodyMerge || undefined
                    });
                }
                cellPos.col = col;
                cellPos.row = row;
                const currentRange = state.select.ranges?.[state.select.ranges.length - 1];
                if (currentRange &&
                    currentRange.start.row <= table.rowCount - 1 &&
                    currentRange.end.row <= table.rowCount - 1 &&
                    currentRange.start.col <= table.colCount - 1 &&
                    currentRange.end.col <= table.colCount - 1) {
                    scenegraph.updateCellSelectBorder(currentRange, extendSelectRange);
                }
            }
        }
        else if ((interactionState === InteractionState.grabing || table.eventManager.isDraging) &&
            !table.stateManager.isResizeCol()) {
            let extendSelectRange = true;
            if (cellPos.col === -1) {
                cellPos.col = col;
            }
            if (cellPos.row === -1) {
                cellPos.row = row;
            }
            cellPos.col = col;
            cellPos.row = row;
            const currentRange = state.select.ranges[state.select.ranges.length - 1];
            if (currentRange) {
                if (table.internalProps.layoutMap.isSeriesNumberInBody(currentRange.start.col, currentRange.start.row)) {
                    extendSelectRange = false;
                    currentRange.end = {
                        col: table.colCount - 1,
                        row
                    };
                }
                else {
                    if (state.fillHandle.isFilling) {
                        if (state.fillHandle.direction === 'top') {
                            if (row === state.fillHandle.beforeFillMinRow && row === state.fillHandle.beforeFillMaxRow) {
                                currentRange.start.row = currentRange.end.row = row;
                            }
                            else if (row <= state.fillHandle.beforeFillMinRow) {
                                if (currentRange.start.row < currentRange.end.row) {
                                    const temp = currentRange.start.row;
                                    currentRange.start.row = currentRange.end.row;
                                    currentRange.end.row = temp;
                                }
                                currentRange.end.row = row;
                            }
                            else if (row === state.fillHandle.beforeFillMaxRow) {
                                if (currentRange.start.row > currentRange.end.row) {
                                    currentRange.start.row = row;
                                }
                                else {
                                    currentRange.end.row = row;
                                }
                            }
                        }
                        else if (state.fillHandle.direction === 'bottom') {
                            if (row >= state.fillHandle.beforeFillMaxRow) {
                                if (currentRange.start.row > currentRange.end.row) {
                                    const temp = currentRange.start.row;
                                    currentRange.start.row = currentRange.end.row;
                                    currentRange.end.row = temp;
                                }
                                currentRange.end.row = row;
                            }
                        }
                        else if (state.fillHandle.direction === 'left') {
                            if (col === state.fillHandle.beforeFillMinCol && col === state.fillHandle.beforeFillMaxCol) {
                                currentRange.start.col = currentRange.end.col = col;
                            }
                            else if (col <= state.fillHandle.beforeFillMinCol) {
                                if (currentRange.start.col < currentRange.end.col) {
                                    const temp = currentRange.start.col;
                                    currentRange.start.col = currentRange.end.col;
                                    currentRange.end.col = temp;
                                }
                                currentRange.end.col = col;
                            }
                            else if (col === state.fillHandle.beforeFillMaxCol) {
                                if (currentRange.start.col > currentRange.end.col) {
                                    currentRange.start.col = col;
                                }
                                else {
                                    currentRange.end.col = col;
                                }
                            }
                        }
                        else if (state.fillHandle.direction === 'right') {
                            if (col >= state.fillHandle.beforeFillMaxCol) {
                                if (currentRange.start.col > currentRange.end.col) {
                                    const temp = currentRange.start.col;
                                    currentRange.start.col = currentRange.end.col;
                                    currentRange.end.col = temp;
                                }
                                currentRange.end.col = col;
                            }
                        }
                    }
                    else {
                        currentRange.end = {
                            col,
                            row
                        };
                        const cellRange = skipBodyMerge ? { start: { col, row }, end: { col, row } } : table.getCellRange(col, row);
                        if (currentRange.start.col < cellRange.end.col) {
                            currentRange.end.col = cellRange.end.col;
                        }
                        else if (currentRange.start.col > cellRange.start.col) {
                            currentRange.end.col = cellRange.start.col;
                        }
                        if (currentRange.start.row < cellRange.end.row) {
                            currentRange.end.row = cellRange.end.row;
                        }
                        else if (currentRange.start.row > cellRange.start.row) {
                            currentRange.end.row = cellRange.start.row;
                        }
                        if (state.select.headerSelectMode === 'body') {
                            if (table.isRowHeader(col, row)) {
                                currentRange.start.col = table.rowHeaderLevelCount + table.leftRowSeriesNumberCount;
                                currentRange.end.col = table.colCount - 1;
                            }
                            else if (table.isColumnHeader(col, row)) {
                                currentRange.start.row = table.columnHeaderLevelCount;
                                currentRange.end.row = table.rowCount - 1;
                            }
                            else if (table.internalProps.layoutMap.isSeriesNumberInBody(col, row)) {
                                currentRange.start.col = table.leftRowSeriesNumberCount;
                                currentRange.end.col = table.colCount - 1;
                            }
                            else if (table.isCornerHeader(col, row)) {
                                currentRange.start.col = table.rowHeaderLevelCount + table.leftRowSeriesNumberCount;
                                currentRange.start.row = table.columnHeaderLevelCount;
                                currentRange.end.col = table.colCount - 1;
                                currentRange.end.row = table.rowCount - 1;
                            }
                            else if (table.isSeriesNumber(col, row)) {
                                currentRange.start.col = table.leftRowSeriesNumberCount;
                                currentRange.start.row = table.columnHeaderLevelCount;
                                currentRange.end.col = table.colCount - 1;
                                currentRange.end.row = table.rowCount - 1;
                            }
                        }
                        if (skipBodyMerge) {
                            currentRange.skipBodyMerge = true;
                        }
                    }
                }
                if (currentRange &&
                    currentRange.start.row <= table.rowCount - 1 &&
                    currentRange.end.row <= table.rowCount - 1 &&
                    currentRange.start.col <= table.colCount - 1 &&
                    currentRange.end.col <= table.colCount - 1) {
                    scenegraph.updateCellSelectBorder(currentRange, extendSelectRange);
                }
            }
        }
        scenegraph.updateNextFrame();
    }
    function selectEnd(scenegraph) {
        scenegraph.moveSelectingRangeComponentsToSelectedRangeComponents();
    }

    const PIVOT_TABLE_EVENT_TYPE = extend(TABLE_EVENT_TYPE, {
        PIVOT_SORT_CLICK: 'pivot_sort_click',
        DRILLMENU_CLICK: 'drillmenu_click'
    });
    const PIVOT_CHART_EVENT_TYPE = extend(TABLE_EVENT_TYPE, {
        VCHART_EVENT_TYPE: 'vchart_event_type'
    });

    function updateDrill(col, row, drillDown, drillUp, table) {
        const headerType = table.getCellLocation(col, row);
        let x = 0;
        let y = 0;
        let visible = false;
        if (headerType === 'columnHeader') {
            x = table.getColsWidth(0, table.rowHeaderLevelCount - 1) - (table.frozenColCount === 0 ? table.scrollLeft : 0);
            y = table.getRowsHeight(0, row - 1) + table.getRowHeight(row) / 2;
            visible = true;
        }
        else if (headerType === 'rowHeader') {
            y = table.getRowsHeight(0, table.columnHeaderLevelCount - 1);
            x = table.getColsWidth(0, col - 1) + table.getColWidth(col) / 2;
            visible = true;
        }
        table.scenegraph.updateDrill(visible, x, y, drillDown, drillUp);
    }

    function clearChartHover(col, row, table) {
        const cellGroup = table.scenegraph.getCell(col, row);
        const sparkline = cellGroup.getChildByName('sparkline');
        const highlightLine = sparkline?.getChildByName('highlight-line');
        const highlightSymbol = sparkline?.getChildByName('highlight-symbol');
        if (highlightLine) {
            highlightLine.setAttributes({
                visible: false,
                pickable: false
            });
        }
        if (highlightSymbol) {
            highlightSymbol.setAttributes({
                visible: false,
                pickable: false
            });
        }
        table.scenegraph.updateNextFrame();
    }
    function updateChartHover(col, row, x, y, table) {
        const cellGroup = table.scenegraph.getCell(col, row);
        const sparkline = cellGroup.getChildByName('sparkline');
        const line = sparkline?.getChildByName('sparkline-line');
        const symbol = sparkline?.getChildByName('sparkline-symbol-group');
        if (!line) {
            return false;
        }
        const bandwidth = line.bandwidth;
        const min = line.min;
        const max = line.max;
        const points = line.attribute.points;
        x = x - sparkline.globalAABBBounds.x1;
        y = y - sparkline.globalAABBBounds.y1;
        let chartPoint;
        for (let i = 0; i < points.length; i++) {
            const { x: pointX, y: pointY, defined, rawData } = points[i];
            if (Math.abs(x - pointX) < bandwidth / 2) {
                chartPoint = {
                    point: points[i],
                    points,
                    pointsBandWidth: bandwidth,
                    pointData: rawData
                };
                if (defined) {
                    const highlightLine = sparkline.getChildByName('highlight-line');
                    if (highlightLine) {
                        highlightLine.setAttributes({
                            points: [
                                { x: pointX, y: max },
                                { x: pointX, y: min }
                            ],
                            visible: true,
                            pickable: true
                        });
                    }
                    else {
                        const highlightLine = createLine({
                            points: [
                                { x: pointX, y: max },
                                { x: pointX, y: min }
                            ],
                            lineWidth: line.hover?.strokeWidth,
                            stroke: line.hover?.stroke
                        });
                        highlightLine.name = 'highlight-line';
                        sparkline.addChild(highlightLine);
                    }
                    const highlightSymbol = sparkline.getChildByName('highlight-symbol');
                    if (highlightSymbol) {
                        highlightSymbol.setAttributes({
                            x: pointX,
                            y: pointY,
                            visible: true,
                            pickable: true
                        });
                    }
                    else {
                        const highlightSymbol = createSymbol({
                            x: pointX,
                            y: pointY,
                            stroke: symbol.hover.stroke,
                            lineWidth: symbol.hover.strokeWidth,
                            fill: symbol.hover.fill,
                            size: symbol.hover.size * 2,
                            symbolType: 'circle'
                        });
                        highlightSymbol.name = 'highlight-symbol';
                        sparkline.addChild(highlightSymbol);
                    }
                    break;
                }
            }
        }
        table.scenegraph.updateNextFrame();
        if (chartPoint) {
            const eventInfo = {
                col,
                row,
                field: table.getHeaderField(col, row),
                value: table.getCellValue(col, row),
                dataValue: table.getCellOriginValue(col, row),
                cellHeaderPaths: table.internalProps.layoutMap.getCellHeaderPaths(col, row),
                title: table.getBodyColumnDefine(col, row).title,
                cellRange: table.getCellRelativeRect(col, row),
                sparkline: {
                    pointData: chartPoint.pointData
                },
                scaleRatio: table.canvas.getBoundingClientRect().width / table.canvas.offsetWidth
            };
            table.fireListeners(TABLE_EVENT_TYPE.MOUSEOVER_CHART_SYMBOL, eventInfo);
        }
        return true;
    }

    function adjustMoveHeaderTarget(source, target, table) {
        const sourceCellRange = table.getCellRange(source.col, source.row);
        if (table.isColumnHeader(source.col, source.row)) {
            const targetCellRange = table.getCellRange(target.col, sourceCellRange.start.row);
            if (target.row >= table.columnHeaderLevelCount) {
                target.row = table.columnHeaderLevelCount - 1;
            }
            if (target.col >= source.col) {
                target.col = targetCellRange.end.col;
            }
            else {
                target.col = targetCellRange.start.col;
            }
        }
        else if (table.isRowHeader(source.col, source.row)) {
            const layoutMap = table.internalProps.layoutMap;
            const targetCellRange = table.getCellRange(sourceCellRange.start.col, target.row);
            if (target.col >= table.rowHeaderLevelCount + layoutMap.leftRowSeriesNumberColumnCount) {
                target.col = table.rowHeaderLevelCount + layoutMap.leftRowSeriesNumberColumnCount - 1;
            }
            if (layoutMap.rowHierarchyType === 'tree') {
                const sourceRowHeaderPaths = layoutMap.getCellHeaderPathsWithTreeNode(source.col, source.row)
                    .rowHeaderPaths;
                const targetRowHeaderPaths = layoutMap.getCellHeaderPathsWithTreeNode(target.col, target.row)
                    .rowHeaderPaths;
                if (sourceRowHeaderPaths.length <= targetRowHeaderPaths.length) {
                    const targetPathNode = targetRowHeaderPaths[sourceRowHeaderPaths.length - 1];
                    if (targetPathNode) {
                        if (target.row >= source.row) {
                            target.row = targetPathNode.startInTotal + targetPathNode.size - 1 + table.columnHeaderLevelCount;
                        }
                        else {
                            target.row = targetPathNode.startInTotal + table.columnHeaderLevelCount;
                        }
                    }
                }
            }
            else if (target.row >= source.row) {
                target.row = targetCellRange.end.row;
            }
            else {
                target.row = targetCellRange.start.row;
            }
        }
        return target;
    }

    function startMoveCol(col, row, x, y, state, event) {
        if (!('canMoveHeaderPosition' in state.table.internalProps.layoutMap)) {
            return;
        }
        state.columnMove.moving = true;
        state.columnMove.colSource = col;
        state.columnMove.rowSource = row;
        state.columnMove.x = x - state.table.tableX;
        state.columnMove.y = y - state.table.tableY;
        const cellLocation = state.table.getCellLocation(col, row);
        const delta = cellLocation === 'columnHeader'
            ? state.columnMove.x
            : cellLocation === 'rowHeader' ||
                state.table.internalProps.layoutMap.isSeriesNumberInBody(col, row)
                ? state.columnMove.y
                : 0;
        const { backX, lineX, backY, lineY } = state.table.scenegraph.component.showMoveCol(col, row, delta);
        state.table.fireListeners(TABLE_EVENT_TYPE.CHANGE_HEADER_POSITION_START, {
            col,
            row,
            x,
            y,
            backX,
            lineX,
            backY,
            lineY,
            event
        });
        const isHasSelected = !!state.select.ranges?.length;
        state.table.stateManager.updateSelectPos(-1, -1);
        state.table.stateManager.endSelectCells(true, isHasSelected);
        state.table.scenegraph.updateNextFrame();
    }
    function updateMoveCol(col, row, x, y, state, event) {
        if (!('canMoveHeaderPosition' in state.table.internalProps.layoutMap)) {
            return;
        }
        const targetCell = adjustMoveHeaderTarget({ col: state.columnMove.colSource, row: state.columnMove.rowSource }, { col, row }, state.table);
        const canMove = state.table.internalProps.layoutMap.canMoveHeaderPosition({ col: state.columnMove.colSource, row: state.columnMove.rowSource }, { col: targetCell.col, row: targetCell.row });
        if (!canMove) {
            state.updateCursor('not-allowed');
            state.columnMove.colTarget = state.columnMove.colSource;
            state.columnMove.rowTarget = state.columnMove.rowSource;
        }
        else {
            state.columnMove.x = x - state.table.tableX;
            state.columnMove.y = y - state.table.tableY;
            state.columnMove.colTarget = targetCell.col;
            state.columnMove.rowTarget = targetCell.row;
            state.updateCursor('grabbing');
            let lineX;
            let backX;
            let lineY;
            let backY;
            const cellLocation = state.table.getCellLocation(state.columnMove.colSource, state.columnMove.rowSource);
            if (cellLocation === 'columnHeader') {
                backX = state.columnMove.x;
                if (state.table.isLeftFrozenColumn(col)) {
                    lineX =
                        state.columnMove.colTarget >= state.columnMove.colSource
                            ? state.table.getColsWidth(0, state.columnMove.colTarget)
                            : state.table.getColsWidth(0, state.columnMove.colTarget - 1);
                }
                else if (state.table.isRightFrozenColumn(col)) {
                    lineX = state.table.tableNoFrameWidth - state.table.getColsWidth(targetCell.col + 1, state.table.colCount - 1);
                }
                else {
                    lineX =
                        (state.columnMove.colTarget >= state.columnMove.colSource
                            ? state.table.getColsWidth(0, state.columnMove.colTarget)
                            : state.table.getColsWidth(0, state.columnMove.colTarget - 1)) -
                            state.table.stateManager.scroll.horizontalBarPos;
                }
            }
            else if (cellLocation === 'rowHeader' ||
                state.table.internalProps.layoutMap.isSeriesNumberInBody(col, row)) {
                backY = state.columnMove.y;
                if (state.table.isFrozenRow(row)) {
                    lineY =
                        state.columnMove.rowTarget >= state.columnMove.rowSource
                            ? state.table.getRowsHeight(0, state.columnMove.rowTarget)
                            : state.table.getRowsHeight(0, state.columnMove.rowTarget - 1);
                }
                else if (state.table.isBottomFrozenRow(row)) {
                    lineY =
                        state.table.tableNoFrameHeight - state.table.getRowsHeight(targetCell.row + 1, state.table.rowCount - 1);
                }
                else {
                    lineY =
                        (state.columnMove.rowTarget >= state.columnMove.rowSource
                            ? state.table.getRowsHeight(0, state.columnMove.rowTarget)
                            : state.table.getRowsHeight(0, state.columnMove.rowTarget - 1)) -
                            state.table.stateManager.scroll.verticalBarPos;
                }
            }
            state.table.scenegraph.component.updateMoveCol(backX, lineX, backY, lineY);
            state.table.fireListeners(TABLE_EVENT_TYPE.CHANGING_HEADER_POSITION, {
                col,
                row,
                x,
                y,
                backX,
                lineX,
                backY,
                lineY,
                event
            });
            state.table.scenegraph.updateNextFrame();
        }
    }
    function endMoveCol(state) {
        let moveColResult = false;
        if ('canMoveHeaderPosition' in state.table.internalProps.layoutMap &&
            state.columnMove.moving &&
            state.columnMove.colSource >= 0 &&
            state.columnMove.rowSource >= 0 &&
            state.columnMove.colTarget >= 0 &&
            state.columnMove.rowTarget >= 0 &&
            state.table.options.customConfig?.notUpdateInColumnRowMove !== true) {
            const oldSourceMergeInfo = state.table.getCellRange(state.columnMove.colSource, state.columnMove.rowSource);
            const oldTargetMergeInfo = state.table.getCellRange(state.columnMove.colTarget, state.columnMove.rowTarget);
            const moveContext = state.table._moveHeaderPosition({ col: state.columnMove.colSource, row: state.columnMove.rowSource }, { col: state.columnMove.colTarget, row: state.columnMove.rowTarget });
            if (moveContext && moveContext.targetIndex !== moveContext.sourceIndex) {
                state.table.internalProps.useOneRowHeightFillAll = false;
                state.table.internalProps.layoutMap.clearCellRangeMap();
                const sourceMergeInfo = state.table.getCellRange(state.columnMove.colSource, state.columnMove.rowSource);
                const targetMergeInfo = state.table.getCellRange(state.columnMove.colTarget, state.columnMove.rowTarget);
                const colMin = Math.min(sourceMergeInfo.start.col, targetMergeInfo.start.col, oldSourceMergeInfo.start.col, oldTargetMergeInfo.start.col);
                const colMax = Math.max(sourceMergeInfo.end.col, targetMergeInfo.end.col, oldSourceMergeInfo.end.col, oldTargetMergeInfo.end.col);
                const rowMin = Math.min(sourceMergeInfo.start.row, targetMergeInfo.start.row, oldSourceMergeInfo.start.row, oldTargetMergeInfo.start.row);
                let rowMax = Math.max(sourceMergeInfo.end.row, targetMergeInfo.end.row, oldSourceMergeInfo.end.row, oldTargetMergeInfo.end.row);
                if (moveContext.moveType === 'row' &&
                    state.table.internalProps.layoutMap.rowHierarchyType === 'tree') {
                    if (moveContext.targetIndex > moveContext.sourceIndex) {
                        rowMax = rowMax + moveContext.targetSize - 1;
                    }
                    else {
                        rowMax = rowMax + moveContext.sourceSize - 1;
                    }
                }
                if (!state.table.transpose &&
                    state.table.internalProps.layoutMap.isSeriesNumberInBody(state.columnMove.colSource, state.columnMove.rowSource)) {
                    state.table.changeRecordOrder(moveContext.sourceIndex, moveContext.targetIndex);
                    state.changeCheckboxAndRadioOrder(moveContext.sourceIndex, moveContext.targetIndex);
                }
                if (moveContext.moveType === 'column') {
                    clearWidthsAndHeightsCache(colMin, colMax, 0, -1, state.table);
                }
                else {
                    clearWidthsAndHeightsCache(0, -1, rowMin, rowMax, state.table);
                }
                state.table.clearCellStyleCache();
                if (state.table.internalProps.layoutMap.isSeriesNumberInBody(state.columnMove.colSource, state.columnMove.rowSource)) {
                    state.table.scenegraph.updateHeaderPosition(state.table.scenegraph.proxy.colStart, state.table.scenegraph.proxy.colEnd, state.table.scenegraph.proxy.rowStart, state.table.scenegraph.proxy.rowEnd, moveContext.moveType);
                }
                else if (moveContext.moveType === 'column') {
                    state.table.scenegraph.updateHeaderPosition(colMin, colMax, 0, -1, moveContext.moveType);
                }
                else {
                    state.table.scenegraph.updateHeaderPosition(0, -1, rowMin, rowMax, moveContext.moveType);
                }
                if (state.table.internalProps.frozenColDragHeaderMode === 'adjustFrozenCount' && state.table.isListTable()) {
                    if (state.table.isLeftFrozenColumn(state.columnMove.colTarget) &&
                        !state.table.isLeftFrozenColumn(state.columnMove.colSource)) {
                        state.table.frozenColCount +=
                            sourceMergeInfo.end.col - sourceMergeInfo.start.col + 1;
                    }
                    else if (state.table.isLeftFrozenColumn(state.columnMove.colSource) &&
                        !state.table.isLeftFrozenColumn(state.columnMove.colTarget)) {
                        state.table.frozenColCount -=
                            sourceMergeInfo.end.col - sourceMergeInfo.start.col + 1;
                    }
                    if (state.table.isRightFrozenColumn(state.columnMove.colTarget) &&
                        !state.table.isRightFrozenColumn(state.columnMove.colSource)) {
                        state.table.rightFrozenColCount +=
                            sourceMergeInfo.end.col - sourceMergeInfo.start.col + 1;
                    }
                    else if (state.table.isRightFrozenColumn(state.columnMove.colSource) &&
                        !state.table.isRightFrozenColumn(state.columnMove.colTarget)) {
                        state.table.rightFrozenColCount -=
                            sourceMergeInfo.end.col - sourceMergeInfo.start.col + 1;
                    }
                }
                moveColResult = true;
            }
            else {
                state.updateCursor();
                state.columnMove.moving = false;
                delete state.columnMove.colSource;
                delete state.columnMove.rowSource;
                delete state.columnMove.colTarget;
                delete state.columnMove.rowTarget;
                state.table.scenegraph.component.hideMoveCol();
                state.table.scenegraph.updateNextFrame();
                return false;
            }
        }
        state.columnMove.moving = false;
        setTimeout(() => {
            delete state.columnMove.colSource;
            delete state.columnMove.rowSource;
            delete state.columnMove.colTarget;
            delete state.columnMove.rowTarget;
        }, 0);
        state.table.scenegraph.component.hideMoveCol();
        if (state.columnResize.col < state.table.frozenColCount &&
            !state.table.isPivotTable() &&
            !state.table.transpose) {
            state.table.scenegraph.component.setFrozenColumnShadow(state.table.frozenColCount - 1, state.columnResize.isRightFrozen);
            state.table.scenegraph.component.setRightFrozenColumnShadow(state.table.colCount - state.table.rightFrozenColCount);
        }
        else if (state.columnResize.col >= state.table.colCount - state.table.rightFrozenColCount &&
            !state.table.isPivotTable() &&
            !state.table.transpose) {
            state.table.scenegraph.component.setRightFrozenColumnShadow(state.table.colCount - state.table.rightFrozenColCount);
        }
        else if (state.table.options.frozenColCount) {
            state.table.scenegraph.component.setFrozenColumnShadow(state.table.frozenColCount - 1);
        }
        else if (state.table.options.rightFrozenColCount) {
            state.table.scenegraph.component.setRightFrozenColumnShadow(state.table.colCount - state.table.rightFrozenColCount);
        }
        state.table.scenegraph.updateNextFrame();
        if (state.table.options.customConfig?.notUpdateInColumnRowMove === true) {
            return true;
        }
        return moveColResult;
    }
    function clearWidthsAndHeightsCache(colMin, colMax, rowMin, rowMax, table) {
        for (let col = colMin; col <= colMax; col++) {
            table._clearColRangeWidthsMap(col);
        }
        for (let row = rowMin; row <= rowMax; row++) {
            table._clearRowRangeHeightsMap(row);
        }
    }

    function getIconAndPositionFromTarget(target) {
        if (!target) {
            return undefined;
        }
        const icon = target.role?.startsWith('icon')
            ? target
            : target.type === 'richtext'
                ? target._currentHoverIcon
                : undefined;
        if (!icon) {
            return undefined;
        }
        if (target.type === 'richtext') {
            return {
                icon: icon,
                position: {
                    left: target.globalAABBBounds.x1 + icon.globalAABBBounds.x1,
                    right: target.globalAABBBounds.x1 + icon.globalAABBBounds.x2,
                    top: target.globalAABBBounds.y1 + icon.globalAABBBounds.y1,
                    bottom: target.globalAABBBounds.y1 + icon.globalAABBBounds.y2,
                    width: icon.globalAABBBounds.x2 - icon.globalAABBBounds.x1,
                    height: icon.globalAABBBounds.y2 - icon.globalAABBBounds.y1
                },
                type: 'richtext-icon'
            };
        }
        return {
            icon: icon,
            position: {
                left: icon.globalAABBBounds.x1,
                right: icon.globalAABBBounds.x2,
                top: icon.globalAABBBounds.y1,
                bottom: icon.globalAABBBounds.y2,
                width: icon.globalAABBBounds.x2 - icon.globalAABBBounds.x1,
                height: icon.globalAABBBounds.y2 - icon.globalAABBBounds.y1
            },
            type: 'icon'
        };
    }

    function updateResizeColumn(xInTable, yInTable, state) {
        xInTable = Math.ceil(xInTable);
        yInTable = Math.ceil(yInTable);
        let detaX = state.columnResize.isRightFrozen ? state.columnResize.x - xInTable : xInTable - state.columnResize.x;
        if (Math.abs(detaX) < 1) {
            return;
        }
        const widthCache = state.table.getColWidth(state.columnResize.col);
        let width = widthCache;
        width += detaX;
        const minWidth = state.table.getMinColWidth(state.columnResize.col);
        const maxWidth = state.table.getMaxColWidth(state.columnResize.col);
        if (width < minWidth || width > maxWidth) {
            if (widthCache === minWidth || widthCache === maxWidth) {
                return;
            }
            else if (widthCache - minWidth > maxWidth - widthCache) {
                detaX = maxWidth - widthCache;
            }
            else {
                detaX = minWidth - widthCache;
            }
        }
        let afterSize = state.table.getColWidth(state.columnResize.col) + detaX;
        if (afterSize < state.table.internalProps.limitMinWidth) {
            afterSize = state.table.internalProps.limitMinWidth;
            detaX = afterSize - state.table.getColWidth(state.columnResize.col);
        }
        if (state.table.widthMode === 'adaptive' && state.columnResize.col < state.table.colCount - 1) {
            const rightColWidthCache = state.table.getColWidth(state.columnResize.col + 1);
            const rightColMinWidth = state.table.getMinColWidth(state.columnResize.col + 1);
            const rightColMaxWidth = state.table.getMaxColWidth(state.columnResize.col + 1);
            let rightColWidth = rightColWidthCache;
            rightColWidth -= detaX;
            if (rightColWidth < rightColMinWidth || rightColWidth > rightColMaxWidth) {
                if (rightColWidthCache === rightColMinWidth || rightColWidthCache === rightColMaxWidth) {
                    return;
                }
                else if (rightColWidthCache - rightColMinWidth > rightColMaxWidth - rightColWidthCache) {
                    detaX = rightColMaxWidth - rightColWidthCache;
                }
                else {
                    detaX = rightColMinWidth - rightColWidthCache;
                }
            }
            if (rightColWidth - detaX < state.table.internalProps.limitMinWidth) {
                detaX = rightColWidth - state.table.internalProps.limitMinWidth;
            }
        }
        detaX = Math.ceil(detaX);
        if (state.columnResize.col < state.table.rowHeaderLevelCount ||
            state.columnResize.col >= state.table.colCount - state.table.rightFrozenColCount) {
            updateResizeColForColumn(detaX, state);
        }
        else if (state.table.internalProps.columnResizeType === 'indicator') {
            updateResizeColForIndicator$1(detaX, state);
        }
        else if (state.table.internalProps.columnResizeType === 'indicatorGroup') {
            updateResizeColForIndicatorGroup$1(detaX, state);
        }
        else if (state.table.internalProps.columnResizeType === 'all') {
            updateResizeColForAll$1(detaX, state);
        }
        else {
            updateResizeColForColumn(detaX, state);
        }
        state.columnResize.x = xInTable;
        state.table.scenegraph.component.updateResizeCol(state.columnResize.col, yInTable, state.columnResize.isRightFrozen);
        if (state.columnResize.col < state.table.frozenColCount &&
            !state.table.isPivotTable() &&
            !state.table.transpose) {
            state.table.scenegraph.component.setFrozenColumnShadow(state.table.frozenColCount - 1, state.columnResize.isRightFrozen);
        }
        else if (state.table.options.frozenColCount) {
            state.table.scenegraph.component.setFrozenColumnShadow(state.table.frozenColCount - 1);
        }
        if (state.columnResize.col >= state.table.colCount - state.table.rightFrozenColCount &&
            !state.table.isPivotTable() &&
            !state.table.transpose) {
            state.table.scenegraph.component.setRightFrozenColumnShadow(state.table.colCount - state.table.rightFrozenColCount);
        }
        else if (state.table.options.rightFrozenColCount) {
            state.table.scenegraph.component.setRightFrozenColumnShadow(state.table.colCount - state.table.rightFrozenColCount);
        }
        state.table.scenegraph.updateNextFrame();
    }
    function updateResizeColForColumn(detaX, state) {
        if (state.table.widthMode === 'adaptive' && state.columnResize.col < state.table.colCount - 1) {
            state.table.scenegraph.updateColWidth(state.columnResize.col, detaX);
            state.table.scenegraph.updateColWidth(state.columnResize.col + 1, -detaX);
            state.table.internalProps._widthResizedColMap.add(state.columnResize.col);
            state.table.internalProps._widthResizedColMap.add(state.columnResize.col + 1);
        }
        else {
            state.table.scenegraph.updateColWidth(state.columnResize.col, detaX);
            state.table.internalProps._widthResizedColMap.add(state.columnResize.col);
        }
    }
    function updateResizeColForAll$1(detaX, state) {
        const layout = state.table.internalProps.layoutMap;
        for (let col = state.table.frozenColCount; col < state.table.colCount - state.table.rightFrozenColCount; col++) {
            if (!(state.table.internalProps.transpose || (state.table.isPivotTable() && !layout.indicatorsAsCol))) {
                const cellDefine = layout.getBody(col, state.table.columnHeaderLevelCount);
                if (cellDefine?.disableColumnResize) {
                    continue;
                }
            }
            state.table.scenegraph.updateColWidth(col, detaX);
            state.table.internalProps._widthResizedColMap.add(col);
        }
    }
    function updateResizeColForIndicator$1(detaX, state) {
        const layout = state.table.internalProps.layoutMap;
        let resizeIndicatorKey;
        let resizeDimensionKey;
        let resizeDimensionValue;
        if (layout.indicatorsAsCol) {
            resizeIndicatorKey = layout.getIndicatorKey(state.columnResize.col, state.table.columnHeaderLevelCount);
        }
        else {
            const headerPaths = layout.getCellHeaderPaths(state.columnResize.col, state.table.columnHeaderLevelCount - 1);
            const headerPath = headerPaths.colHeaderPaths[headerPaths.colHeaderPaths.length - 1];
            resizeDimensionKey = headerPath.dimensionKey;
            resizeDimensionValue = headerPath.value;
        }
        for (let col = state.table.rowHeaderLevelCount; col < state.table.colCount - state.table.rightFrozenColCount; col++) {
            const indicatorKey = layout.getIndicatorKey(col, state.table.columnHeaderLevelCount);
            if (layout.indicatorsAsCol && indicatorKey === resizeIndicatorKey) {
                state.table.scenegraph.updateColWidth(col, detaX);
                state.table.internalProps._widthResizedColMap.add(col);
            }
            else if (!layout.indicatorsAsCol) {
                const headerPaths = layout.getCellHeaderPaths(col, state.table.columnHeaderLevelCount - 1);
                const headerPath = headerPaths?.colHeaderPaths[headerPaths.colHeaderPaths.length - 1];
                if (headerPath && resizeDimensionKey === headerPath.dimensionKey && resizeDimensionValue === headerPath.value) {
                    state.table.scenegraph.updateColWidth(col, detaX);
                    state.table.internalProps._widthResizedColMap.add(col);
                }
            }
        }
    }
    function updateResizeColForIndicatorGroup$1(detaX, state) {
        const layout = state.table.internalProps.layoutMap;
        const headerPaths = layout.getCellHeaderPaths(state.columnResize.col, state.table.columnHeaderLevelCount);
        const node = layout.getHeadNodeByRowOrColDimensions(headerPaths.colHeaderPaths.slice(0, headerPaths.colHeaderPaths.length - 1));
        const startCol = node.startInTotal + state.table.frozenColCount;
        const endCol = node.startInTotal + state.table.frozenColCount + node.size - 1;
        const totalColWidth = state.table.getColsWidth(startCol, endCol);
        const moveX = detaX;
        for (let col = startCol; col <= endCol; col++) {
            if (!(state.table.internalProps.transpose || (state.table.isPivotTable() && !layout.indicatorsAsCol))) {
                const cellDefine = layout.getBody(col, state.table.columnHeaderLevelCount);
                if (cellDefine?.disableColumnResize) {
                    continue;
                }
            }
            const prevWidth = state.table.getColWidth(col);
            let deltaWidth = (prevWidth / totalColWidth) * moveX;
            if (deltaWidth > 0 && deltaWidth < 0.5) {
                deltaWidth = 0.5;
            }
            else if (deltaWidth < 0 && deltaWidth >= -0.5) {
                deltaWidth = -0.5;
            }
            state.table.scenegraph.updateColWidth(col, deltaWidth);
            state.table.internalProps._widthResizedColMap.add(col);
        }
    }

    function setRadioState(col, row, field, type, indexInCell, state) {
        const recordIndex = state.table.getRecordShowIndexByCell(col, row);
        if (recordIndex >= 0) {
            const dataIndex = state.table.dataSource.getIndexKey(recordIndex);
            if (type === 'column') {
                if (isNumber$4(indexInCell)) {
                    state.radioState[field] = {};
                    state.radioState[field][dataIndex] = indexInCell;
                }
                else {
                    state.radioState[field] = dataIndex;
                }
            }
            else {
                if (!state.radioState[field]) {
                    state.radioState[field] = {};
                }
                if (isNumber$4(indexInCell)) {
                    state.radioState[field][dataIndex] = indexInCell;
                }
                else {
                    state.radioState[field][dataIndex] = true;
                }
            }
        }
    }
    function getCellRadioState(col, row, table) {
        const define = table.getBodyColumnDefine(col, row);
        const field = define?.field;
        const cellType = table.getCellType(col, row);
        if (isValid$3(field) && cellType === 'radio') {
            const dataIndex = table.dataSource.getIndexKey(table.getRecordShowIndexByCell(col, row));
            const columnState = table.stateManager.radioState?.[field];
            if (isNumber$4(columnState)) {
                if (columnState === dataIndex) {
                    return true;
                }
            }
            else if (isObject$7(columnState)) {
                const cellState = columnState[dataIndex];
                if (isNumber$4(cellState)) {
                    return cellState;
                }
            }
        }
        return false;
    }
    function syncRadioState(col, row, field, type, indexInCell, isChecked, state) {
        const recordIndex = state.table.getRecordShowIndexByCell(col, row);
        if (recordIndex >= 0) {
            const dataIndex = state.table.dataSource.getIndexKey(recordIndex);
            if (type === 'column') {
                if (!isValid$3(state.radioState[field]) && isChecked) {
                    if (isNumber$4(indexInCell)) {
                        state.radioState[field] = {};
                        state.radioState[field][dataIndex] = indexInCell;
                    }
                    else {
                        state.radioState[field] = dataIndex;
                    }
                    return true;
                }
                else if (isNumber$4(state.radioState[field]) && !isNumber$4(indexInCell)) {
                    return state.radioState[field] === dataIndex;
                }
                else if (isNumber$4(state.radioState[field]) && isNumber$4(indexInCell)) {
                    return false;
                }
                else if (isObject$7(state.radioState[field]) && !isNumber$4(indexInCell)) {
                    return false;
                }
                else if (isObject$7(state.radioState[field]) && isNumber$4(indexInCell)) {
                    return state.radioState[field][dataIndex] === indexInCell;
                }
            }
            else if (type === 'cell') {
                if (!isValid$3(state.radioState[field]) && isChecked) {
                    state.radioState[field] = {};
                    if (isNumber$4(indexInCell)) {
                        state.radioState[field][dataIndex] = indexInCell;
                    }
                    else {
                        state.radioState[field][dataIndex] = true;
                    }
                    return true;
                }
                else if (!isValid$3(state.radioState[field]?.[dataIndex]) && isChecked) {
                    if (isNumber$4(indexInCell)) {
                        state.radioState[field][dataIndex] = indexInCell;
                    }
                    else {
                        state.radioState[field][dataIndex] = true;
                    }
                    return true;
                }
                else if (isBoolean$4(state.radioState[field]?.[dataIndex]) && !isNumber$4(indexInCell)) {
                    return state.radioState[field][dataIndex];
                }
                else if (isBoolean$4(state.radioState[field]?.[dataIndex]) && isNumber$4(indexInCell)) {
                    return false;
                }
                else if (isNumber$4(state.radioState[field]?.[dataIndex]) && !isNumber$4(indexInCell)) {
                    return false;
                }
                else if (isNumber$4(state.radioState[field]?.[dataIndex]) && isNumber$4(indexInCell)) {
                    return state.radioState[field][dataIndex] === indexInCell;
                }
            }
        }
        return isChecked;
    }
    function setCellRadioState(col, row, index, table) {
        const cellGoup = table.scenegraph.getCell(col, row);
        if (!cellGoup) {
            return;
        }
        if (isNumber$4(index)) {
            const radio = cellGoup.getChildAt(index);
            radio?._handlePointerUp();
        }
        else {
            const radio = cellGoup.getChildByName('radio');
            radio?._handlePointerUp();
        }
    }
    function changeRadioOrder(sourceIndex, targetIndex, state) {
        const { radioState, table } = state;
        if (table.internalProps.transpose) {
            sourceIndex = table.getRecordShowIndexByCell(sourceIndex, 0);
            targetIndex = table.getRecordShowIndexByCell(targetIndex, 0);
        }
        else {
            sourceIndex = table.getRecordShowIndexByCell(0, sourceIndex);
            targetIndex = table.getRecordShowIndexByCell(0, targetIndex);
        }
        if (sourceIndex > targetIndex) {
            const sourceRecord = radioState[sourceIndex];
            for (let i = sourceIndex; i > targetIndex; i--) {
                radioState[i] = radioState[i - 1];
            }
            radioState[targetIndex] = sourceRecord;
        }
        else if (sourceIndex < targetIndex) {
            const sourceRecord = radioState[sourceIndex];
            for (let i = sourceIndex; i < targetIndex; i++) {
                radioState[i] = radioState[i + 1];
            }
            radioState[targetIndex] = sourceRecord;
        }
    }

    function setCheckedState(col, row, field, checked, state) {
        const table = state.table;
        const cellRange = table.getCellRange(col, row);
        if (cellRange.start.col !== cellRange.end.col || cellRange.start.row !== cellRange.end.row) {
            for (let i = cellRange.start.col; i <= cellRange.end.col; i++) {
                for (let j = cellRange.start.row; j <= cellRange.end.row; j++) {
                    setSingleCheckedState(i, j, field, checked, state);
                }
            }
        }
        else {
            setSingleCheckedState(col, row, field, checked, state);
        }
    }
    function setSingleCheckedState(col, row, field, checked, state) {
        const recordIndex = state.table.getRecordShowIndexByCell(col, row);
        if (recordIndex >= 0) {
            const dataIndex = state.table.dataSource.getIndexKey(recordIndex).toString();
            if (state.checkedState.get(dataIndex)) {
                state.checkedState.get(dataIndex)[field] = checked;
            }
            else {
                state.checkedState.set(dataIndex, {
                    [field]: checked
                });
            }
        }
    }
    function setHeaderCheckedState(field, checked, state) {
        state.headerCheckedState[field] = checked;
        state.checkedState?.forEach(recordCheckState => {
            recordCheckState[field] = checked;
        });
    }
    function syncCheckedState(col, row, field, checked, state) {
        if (state.table.isHeader(col, row)) {
            if (isValid$3(state.headerCheckedState[field])) {
                return state.headerCheckedState[field];
            }
            else if (typeof checked === 'function') {
                return undefined;
            }
            else if (isValid$3(checked)) {
                state.headerCheckedState[field] = checked;
            }
            else if (state.checkedState?.size > 0) {
                const isAllChecked = state.updateHeaderCheckedState(field, col, row);
                return isAllChecked;
            }
            return state.headerCheckedState[field];
        }
        const recordIndex = state.table.getRecordShowIndexByCell(col, row);
        if (recordIndex >= 0) {
            const dataIndex = state.table.dataSource.getIndexKey(recordIndex).toString();
            if (isValid$3(state.checkedState.get(dataIndex)?.[field])) {
                return state.checkedState.get(dataIndex)[field];
            }
            if (state.checkedState.get(dataIndex)) {
                state.checkedState.get(dataIndex)[field] = checked;
            }
            else if (dataIndex.includes(',')) {
                const parentDataIndex = dataIndex.split(',').slice(0, -1).join(',');
                if (state.checkedState.has(parentDataIndex) && state.checkedState.get(parentDataIndex)[field] === true) {
                    state.checkedState.set(dataIndex, {
                        [field]: true
                    });
                }
                else {
                    state.checkedState.set(dataIndex, {
                        [field]: checked
                    });
                }
            }
            else {
                state.checkedState.set(dataIndex, {
                    [field]: checked
                });
            }
        }
        return checked;
    }
    function initCheckedState(records, state) {
        state.checkedState.clear();
        state.headerCheckedState = {};
        state.radioState = {};
        let isNeedInitHeaderCheckedStateFromRecord = false;
        state._checkboxCellTypeFields = [];
        state._headerCheckFuncs = {};
        state.table.internalProps.layoutMap.headerObjects.forEach((hd, index) => {
            if (hd.headerType === 'checkbox') {
                const headerChecked = hd.define.checked;
                if (headerChecked === undefined || headerChecked === null || typeof headerChecked === 'function') {
                    isNeedInitHeaderCheckedStateFromRecord = true;
                    if (typeof headerChecked === 'function') {
                        state._headerCheckFuncs[hd.field] = headerChecked;
                    }
                }
                else {
                    state.headerCheckedState[hd.field] = headerChecked;
                }
                if ((hd.define.cellType === 'checkbox' || isFunction$5(hd.define.cellType)) && !hd.fieldFormat) {
                    state._checkboxCellTypeFields.push(hd.field);
                }
            }
        });
        if (state.table.leftRowSeriesNumberCount === 1) {
            state.headerCheckedState._vtable_rowSeries_number = false;
            state._checkboxCellTypeFields.push('_vtable_rowSeries_number');
            isNeedInitHeaderCheckedStateFromRecord = true;
        }
        else if (state.table.leftRowSeriesNumberCount > 1) {
            for (let i = 0; i < state.table.leftRowSeriesNumberCount; i++) {
                state.headerCheckedState[`_vtable_rowSeries_number_${i}`] = false;
                state._checkboxCellTypeFields.push(`_vtable_rowSeries_number_${i}`);
            }
            isNeedInitHeaderCheckedStateFromRecord = true;
        }
        if (isNeedInitHeaderCheckedStateFromRecord) {
            initRecordCheckState(records, state);
        }
    }
    function updateHeaderCheckedState(field, state, col, row) {
        let allChecked = true;
        let allUnChecked = true;
        let hasChecked = false;
        state.checkedState.forEach((check_state, index) => {
            if (index.includes(',')) {
                index = index.split(',').map(item => {
                    return Number(item);
                });
            }
            else {
                index = Number(index);
            }
            const tableIndex = state.table.getTableIndexByRecordIndex(index);
            const mergeCell = state.table.transpose
                ? state.table.getCustomMerge(tableIndex, row)
                : state.table.getCustomMerge(col, tableIndex);
            const data = state.table.dataSource?.get(index);
            if (mergeCell || (!state.table.internalProps.rowSeriesNumber?.enableTreeCheckbox && data?.vtableMerge)) {
                return;
            }
            if (check_state?.[field] !== true) {
                allChecked = false;
            }
            else {
                allUnChecked = false;
                hasChecked = true;
            }
        });
        if (allChecked) {
            state.headerCheckedState[field] = true;
            return allChecked;
        }
        if (allUnChecked) {
            state.headerCheckedState[field] = false;
            return false;
        }
        if (hasChecked) {
            state.headerCheckedState[field] = 'indeterminate';
            return 'indeterminate';
        }
        return false;
    }
    function initLeftRecordsCheckState(records, state) {
        for (let index = state.checkedState.size; index < records.length; index++) {
            const record = records[index];
            state._checkboxCellTypeFields.forEach(field => {
                const value = record[field];
                let isChecked;
                if (isObject$7(value)) {
                    isChecked = value.checked;
                }
                else if (typeof value === 'boolean') {
                    isChecked = value;
                }
                const dataIndex = index.toString();
                if (!state.checkedState.get(dataIndex)) {
                    state.checkedState.set(dataIndex, {});
                }
                state.checkedState.get(dataIndex)[field] = isChecked;
            });
        }
    }
    function setCellCheckboxState(col, row, checked, table) {
        const cellGroup = table.scenegraph.getCell(col, row);
        const checkbox = cellGroup?.getChildByName('checkbox');
        if (!checkbox) {
            const field = table.getHeaderField(col, row);
            if (table.isHeader(col, row)) {
                table.stateManager.setHeaderCheckedState(field, checked);
                const cellType = table.getCellType(col, row);
                if (cellType === 'checkbox') {
                    table.scenegraph.updateCheckboxCellState(col, row, checked);
                }
            }
            else {
                table.stateManager.setCheckedState(col, row, field, checked);
                const cellType = table.getCellType(col, row);
                if (cellType === 'checkbox') {
                    const oldHeaderCheckedState = table.stateManager.headerCheckedState[field];
                    const newHeaderCheckedState = table.stateManager.updateHeaderCheckedState(field, col, row);
                    if (oldHeaderCheckedState !== newHeaderCheckedState) {
                        table.scenegraph.updateHeaderCheckboxCellState(col, row, newHeaderCheckedState);
                    }
                }
            }
            return;
        }
        const { checked: oldChecked, indeterminate } = checkbox.attribute;
        if (indeterminate) {
            if (checked) {
                checkbox._handlePointerUp();
            }
            else {
                checkbox._handlePointerUp();
                checkbox._handlePointerUp();
            }
        }
        else if (oldChecked) {
            if (checked) ;
            else {
                checkbox._handlePointerUp();
            }
        }
        else {
            if (checked) {
                checkbox._handlePointerUp();
            }
        }
    }
    function setCellCheckboxStateByAttribute(col, row, checked, table) {
        const cellGroup = table.scenegraph.getCell(col, row);
        const checkbox = cellGroup?.getChildByName('checkbox');
        if (checkbox) {
            if (checked === 'indeterminate') {
                checkbox.setAttribute('indeterminate', true);
                checkbox.setAttribute('checked', undefined);
            }
            else {
                checkbox.setAttribute('indeterminate', undefined);
                checkbox.setAttribute('checked', checked);
            }
        }
    }
    function changeCheckboxOrder(sourceIndex, targetIndex, state) {
        const { checkedState, table } = state;
        let source;
        let target;
        if (table.internalProps.transpose) {
            sourceIndex = table.getRecordShowIndexByCell(sourceIndex, 0);
            targetIndex = table.getRecordShowIndexByCell(targetIndex, 0);
        }
        else {
            source = table.isPivotTable() ? undefined : table.getRecordIndexByCell(0, sourceIndex);
            target = table.isPivotTable() ? undefined : table.getRecordIndexByCell(0, targetIndex);
        }
        if (isNumber$4(source) && isNumber$4(target)) {
            sourceIndex = source;
            targetIndex = target;
            if (sourceIndex > targetIndex) {
                const sourceRecord = checkedState.get(sourceIndex.toString());
                for (let i = sourceIndex; i > targetIndex; i--) {
                    checkedState.set(i.toString(), checkedState.get((i - 1).toString()));
                }
                checkedState.set(targetIndex.toString(), sourceRecord);
            }
            else if (sourceIndex < targetIndex) {
                const sourceRecord = checkedState.get(sourceIndex.toString());
                for (let i = sourceIndex; i < targetIndex; i++) {
                    checkedState.set(i.toString(), checkedState.get((i + 1).toString()));
                }
                checkedState.set(targetIndex.toString(), sourceRecord);
            }
        }
        else if (isArray$7(source) && isArray$7(target)) {
            sourceIndex = source[source.length - 1];
            targetIndex = target[target.length - 1];
            if (sourceIndex > targetIndex) {
                const sourceRecord = checkedState.get(source.toString());
                for (let i = sourceIndex; i > targetIndex; i--) {
                    const now = [...source];
                    now[now.length - 1] = i;
                    const last = [...source];
                    last[last.length - 1] = i - 1;
                    checkedState.set(now.toString(), checkedState.get(last.toString()));
                }
                checkedState.set(target.toString(), sourceRecord);
            }
            else if (sourceIndex < targetIndex) {
                const sourceRecord = checkedState.get(source.toString());
                for (let i = sourceIndex; i < targetIndex; i++) {
                    const now = [...source];
                    now[now.length - 1] = i;
                    const next = [...source];
                    next[next.length - 1] = i + 1;
                    checkedState.set(now.toString(), checkedState.get(next.toString()));
                }
                checkedState.set(target.toString(), sourceRecord);
            }
        }
    }
    function getGroupCheckboxState(table) {
        const result = [];
        const dataSource = table.dataSource;
        const groupKeyLength = dataSource.dataConfig.groupByRules.length + 1;
        dataSource.currentIndexedData.forEach((indexArr, index) => {
            if (isArray$7(indexArr) && indexArr.length === groupKeyLength) {
                const vtableOriginIndex = dataSource.getOriginRecordIndexForGroup(indexArr);
                result[vtableOriginIndex] = table.stateManager.checkedState.get(indexArr.toString());
            }
        });
        return result;
    }
    function initRecordCheckState(records, state) {
        const table = state.table;
        const start = table.isPivotTable()
            ? 0
            : table.internalProps.transpose
                ? table.rowHeaderLevelCount
                : table.columnHeaderLevelCount;
        const end = table.isPivotTable()
            ? isArray$7(records)
                ? records.length
                : 0
            : table.internalProps.transpose
                ? table.colCount
                : table.rowCount;
        for (let index = 0; index + start < end; index++) {
            const record = table.isPivotTable() ? records[index] : table.dataSource.get(index);
            state._checkboxCellTypeFields.forEach(field => {
                const value = record && record[field];
                let isChecked;
                if (isObject$7(value)) {
                    isChecked = value.checked;
                }
                else if (typeof value === 'boolean') {
                    isChecked = value;
                }
                if (isChecked === undefined || isChecked === null) {
                    const headerCheckFunc = state._headerCheckFuncs[field];
                    if (headerCheckFunc) {
                        const cellAddr = state.table.getCellAddrByFieldRecord(field, index);
                        const globalChecked = getOrApply(headerCheckFunc, {
                            col: cellAddr.col,
                            row: cellAddr.row,
                            table: state.table,
                            context: null,
                            value
                        });
                        isChecked = globalChecked;
                    }
                }
                const dataIndex = table.isPivotTable() ? index.toString() : state.table.dataSource.getIndexKey(index).toString();
                if (!state.checkedState.get(dataIndex)) {
                    state.checkedState.set(dataIndex, {});
                }
                state.checkedState.get(dataIndex)[field] = isChecked;
            });
        }
    }

    function updateResizeRow(xInTable, yInTable, state) {
        xInTable = Math.ceil(xInTable);
        yInTable = Math.ceil(yInTable);
        let detaY = state.rowResize.isBottomFrozen ? state.rowResize.y - yInTable : yInTable - state.rowResize.y;
        if (Math.abs(detaY) < 1) {
            return;
        }
        state.table.getRowHeight(state.rowResize.row);
        let afterSize = state.table.getRowHeight(state.rowResize.row) + detaY;
        if (afterSize < state.table.internalProps.limitMinHeight) {
            afterSize = state.table.internalProps.limitMinHeight;
            detaY = afterSize - state.table.getRowHeight(state.rowResize.row);
        }
        if (state.table.heightMode === 'adaptive' && state.rowResize.row < state.table.rowCount - 1) {
            const bottomRowHeightCache = state.table.getRowHeight(state.rowResize.row + 1);
            let bottomRowHeight = bottomRowHeightCache;
            bottomRowHeight -= detaY;
            if (bottomRowHeight - detaY < state.table.internalProps.limitMinHeight) {
                detaY = bottomRowHeight - state.table.internalProps.limitMinHeight;
            }
        }
        detaY = Math.ceil(detaY);
        if (state.rowResize.row < state.table.columnHeaderLevelCount ||
            state.rowResize.row >= state.table.rowCount - state.table.bottomFrozenRowCount) {
            updateResizeColForRow(detaY, state);
        }
        else if (state.table.internalProps.rowResizeType === 'indicator') {
            updateResizeColForIndicator(detaY, state);
        }
        else if (state.table.internalProps.rowResizeType === 'indicatorGroup') {
            updateResizeColForIndicatorGroup(detaY, state);
        }
        else if (state.table.internalProps.rowResizeType === 'all') {
            updateResizeColForAll(detaY, state);
        }
        else {
            updateResizeColForRow(detaY, state);
        }
        state.rowResize.y = yInTable;
        state.table.scenegraph.component.updateResizeRow(state.rowResize.row, xInTable, state.rowResize.isBottomFrozen);
        state.table.scenegraph.updateNextFrame();
    }
    function updateResizeColForRow(detaY, state) {
        if (state.table.heightMode === 'adaptive' && state.rowResize.row < state.table.rowCount - 1) {
            state.table.scenegraph.updateRowHeight(state.rowResize.row, detaY);
            state.table.scenegraph.updateRowHeight(state.rowResize.row + 1, -detaY);
            state.table.internalProps._heightResizedRowMap.add(state.rowResize.row);
            state.table.internalProps._heightResizedRowMap.add(state.rowResize.row + 1);
        }
        else {
            state.table.scenegraph.updateRowHeight(state.rowResize.row, detaY);
            state.table.internalProps._heightResizedRowMap.add(state.rowResize.row);
        }
    }
    function updateResizeColForAll(detaY, state) {
        for (let row = state.table.frozenRowCount; row < state.table.rowCount - state.table.bottomFrozenRowCount; row++) {
            state.table.scenegraph.updateRowHeight(row, detaY);
            state.table.internalProps._heightResizedRowMap.add(row);
        }
    }
    function updateResizeColForIndicator(detaY, state) {
        const layout = state.table.internalProps.layoutMap;
        let resizeIndicatorKey;
        let resizeDimensionKey;
        let resizeDimensionValue;
        if (!layout.indicatorsAsCol) {
            resizeIndicatorKey = layout.getIndicatorKey(state.table.rowHeaderLevelCount, state.rowResize.row);
        }
        else {
            const headerPaths = layout.getCellHeaderPaths(state.table.rowHeaderLevelCount - 1, state.rowResize.row);
            const headerPath = headerPaths.rowHeaderPaths?.[headerPaths.rowHeaderPaths.length - 1];
            resizeDimensionKey = headerPath?.dimensionKey;
            resizeDimensionValue = headerPath?.value;
        }
        for (let row = state.table.columnHeaderLevelCount; row < state.table.rowCount - state.table.bottomFrozenRowCount; row++) {
            const indicatorKey = layout.getIndicatorKey(state.table.rowHeaderLevelCount, row);
            if (!layout.indicatorsAsCol && indicatorKey === resizeIndicatorKey) {
                state.table.scenegraph.updateRowHeight(row, detaY);
                state.table.internalProps._heightResizedRowMap.add(row);
            }
            else if (layout.indicatorsAsCol) {
                const headerPaths = layout.getCellHeaderPaths(state.table.rowHeaderLevelCount - 1, row);
                const headerPath = headerPaths?.rowHeaderPaths?.[headerPaths.rowHeaderPaths.length - 1];
                if (headerPath && resizeDimensionKey === headerPath.dimensionKey && resizeDimensionValue === headerPath.value) {
                    state.table.scenegraph.updateRowHeight(row, detaY);
                    state.table.internalProps._heightResizedRowMap.add(row);
                }
            }
        }
    }
    function updateResizeColForIndicatorGroup(detaY, state) {
        const layout = state.table.internalProps.layoutMap;
        const headerPaths = layout.getCellHeaderPaths(state.table.rowHeaderLevelCount, state.rowResize.row);
        const node = layout.getHeadNodeByRowOrColDimensions(headerPaths.rowHeaderPaths.slice(0, headerPaths.rowHeaderPaths.length - 1));
        const startRow = node.startInTotal + state.table.frozenRowCount;
        const endRow = node.startInTotal + state.table.frozenRowCount + node.size - 1;
        const totalRowHeight = state.table.getRowsHeight(startRow, endRow);
        const moveY = detaY;
        for (let row = startRow; row <= endRow; row++) {
            const prevHeight = state.table.getRowHeight(row);
            let deltaHeight = (prevHeight / totalRowHeight) * moveY;
            if (deltaHeight > 0 && deltaHeight < 0.5) {
                deltaHeight = 0.5;
            }
            else if (deltaHeight < 0 && deltaHeight >= -0.5) {
                deltaHeight = -0.51;
            }
            state.table.scenegraph.updateRowHeight(row, deltaHeight);
            state.table.internalProps._heightResizedRowMap.add(row);
        }
    }

    function deletaCustomSelectRanges(state) {
        const { customSelectedRangeComponents } = state.table.scenegraph;
        customSelectedRangeComponents.forEach((selectComp, key) => {
            selectComp.rect.delete();
        });
        customSelectedRangeComponents.clear();
        state.select.customSelectRanges = [];
    }
    function addCustomSelectRanges(customSelectRanges, state) {
        const { customSelectedRangeComponents } = state.table.scenegraph;
        customSelectRanges.forEach((customRange) => {
            const { range, style } = customRange;
            const rect = createRect({
                fill: style.cellBgColor ?? false,
                stroke: style.cellBorderColor ?? false,
                lineWidth: style.cellBorderLineWidth ?? 0,
                lineDash: style.cellBorderLineDash ?? [],
                pickable: false
            });
            customSelectedRangeComponents.set(`${range.start.col}-${range.start.row}-${range.end.col}-${range.end.row}`, {
                rect,
                role: 'body'
            });
        });
        state.select.customSelectRanges = customSelectRanges;
        updateAllSelectComponent(state.table.scenegraph);
        state.table.scenegraph.updateNextFrame();
    }

    class StateManager {
        table;
        interactionState;
        interactionStateBeforeScroll;
        select;
        fillHandle;
        hover;
        hoverIcon;
        residentHoverIcon;
        columnResize;
        rowResize;
        columnMove;
        menu;
        sort;
        frozen;
        scroll;
        tablePosition;
        drill;
        sparkLine;
        _clearVerticalScrollBar;
        _clearHorizontalScrollBar;
        fastScrolling = false;
        checkedState = new Map();
        headerCheckedState = {};
        _checkboxCellTypeFields = [];
        _headerCheckFuncs = {};
        radioState = {};
        resetInteractionState = debounce((state) => {
            this.updateInteractionState(state ?? InteractionState.default);
        }, 100);
        constructor(table) {
            this.table = table;
            this.initState();
            this.updateVerticalScrollBar = this.updateVerticalScrollBar.bind(this);
            this.updateHorizontalScrollBar = this.updateHorizontalScrollBar.bind(this);
        }
        initState() {
            this._initState();
            this.setHoverState();
            this.setSelectState();
            this.setFrozenState();
        }
        updateOptionSetState() {
            this._updateOptionSetState();
            this.setHoverState();
            this.setSelectState();
            this.setFrozenState();
        }
        _updateOptionSetState() {
            this.interactionState = InteractionState.default;
            this.hoverIcon = {
                col: -1,
                row: -1,
                icon: null
            };
            this.columnResize = {
                col: -1,
                x: 0,
                resizing: false
            };
            this.rowResize = {
                row: -1,
                y: 0,
                resizing: false
            };
            this.columnMove = {
                colSource: -1,
                colTarget: -1,
                rowSource: -1,
                rowTarget: -1,
                x: 0,
                y: 0,
                moving: false
            };
            this.menu = {
                x: -1,
                y: -1,
                isShow: false,
                itemList: [],
                bounds: new Bounds(),
                highlightIndex: -1,
                dropDownMenuHighlight: []
            };
            this.sort = [
                {
                    col: -1,
                    row: -1,
                    order: 'normal'
                }
            ];
            this.frozen = {
                col: -1,
                row: -1
            };
            this.tablePosition = {
                absoluteX: 0,
                absoluteY: 0
            };
            this.drill = {
                col: -1,
                row: -1
            };
            this.sparkLine = {
                col: -1,
                row: -1
            };
        }
        _initState() {
            this.interactionState = InteractionState.default;
            this.select = {
                highlightScope: HighlightScope.single,
                ranges: [],
                cellPos: {
                    col: -1,
                    row: -1
                },
                selecting: false
            };
            this.fillHandle = {
                isFilling: false,
                startX: undefined,
                startY: undefined
            };
            this.hover = {
                highlightScope: HighlightScope.single,
                cellPos: {
                    col: -1,
                    row: -1
                }
            };
            this.hoverIcon = {
                col: -1,
                row: -1,
                icon: null
            };
            this.columnResize = {
                col: -1,
                x: 0,
                resizing: false
            };
            this.rowResize = {
                row: -1,
                y: 0,
                resizing: false
            };
            this.columnMove = {
                colSource: -1,
                colTarget: -1,
                rowSource: -1,
                rowTarget: -1,
                x: 0,
                y: 0,
                moving: false
            };
            this.menu = {
                x: -1,
                y: -1,
                isShow: false,
                itemList: [],
                bounds: new Bounds(),
                highlightIndex: -1,
                dropDownMenuHighlight: []
            };
            this.sort = [
                {
                    col: -1,
                    row: -1,
                    order: 'normal'
                }
            ];
            this.frozen = {
                col: -1,
                row: -1
            };
            this.scroll = {
                horizontalBarPos: 0,
                verticalBarPos: 0
            };
            this.tablePosition = {
                absoluteX: 0,
                absoluteY: 0
            };
            this.drill = {
                col: -1,
                row: -1
            };
            this.sparkLine = {
                col: -1,
                row: -1
            };
        }
        setHoverState() {
            const { highlightMode, disableHover, disableHeaderHover } = this.table.options.hover ?? {
                highlightMode: 'cell'
            };
            if (!disableHover) {
                if (highlightMode === 'cross') {
                    this.hover.highlightScope = HighlightScope.cross;
                }
                else if (highlightMode === 'row') {
                    this.hover.highlightScope = HighlightScope.row;
                }
                else if (highlightMode === 'column') {
                    this.hover.highlightScope = HighlightScope.column;
                }
                else if (highlightMode === 'cell') {
                    this.hover.highlightScope = HighlightScope.single;
                }
            }
            else {
                this.hover.highlightScope = HighlightScope.none;
            }
            this.hover.singleStyle = !disableHover;
            this.hover.disableHeader = disableHeaderHover;
            if (this.hover.highlightScope === HighlightScope.none || disableHeaderHover) {
                this.hover.cellPosContainHeader = {
                    col: -1,
                    row: -1
                };
            }
        }
        setSelectState() {
            const { headerSelectMode, disableSelect, disableHeaderSelect, highlightMode, highlightInRange } = Object.assign({}, {
                headerSelectMode: 'inline',
                disableSelect: false,
                disableHeaderSelect: false,
                highlightMode: 'cell',
                highlightInRange: false
            }, this.table.options.select);
            const cornerHeaderSelectMode = this.table.options.select?.cornerHeaderSelectMode
                ? this.table.options.select?.cornerHeaderSelectMode
                : this.table.options.select?.headerSelectMode === 'body'
                    ? this.table.options.select?.headerSelectMode
                    : 'all';
            if (disableSelect === true) {
                this.select.highlightScope = HighlightScope.none;
            }
            else {
                if (highlightMode === 'cross') {
                    this.select.highlightScope = HighlightScope.cross;
                }
                else if (highlightMode === 'row') {
                    this.select.highlightScope = HighlightScope.row;
                }
                else if (highlightMode === 'column') {
                    this.select.highlightScope = HighlightScope.column;
                }
                else {
                    this.select.highlightScope = HighlightScope.single;
                }
            }
            this.select.singleStyle = !disableSelect;
            this.select.disableHeader = disableHeaderSelect;
            this.select.headerSelectMode = headerSelectMode;
            this.select.cornerHeaderSelectMode = cornerHeaderSelectMode;
            this.select.highlightInRange = highlightInRange;
            this.select.disableCtrlMultiSelect = this.table.options.keyboardOptions?.ctrlMultiSelect === false;
        }
        isSelected(col, row) {
            let seled = false;
            this.select.ranges.forEach((range) => {
                if (cellInRange(range, col, row)) {
                    seled = true;
                }
            });
            return seled;
        }
        setSortState(sortState) {
            const state = this;
            sortState = !sortState || Array.isArray(sortState) ? sortState : [sortState];
            function flattenColumns(columns) {
                const result = [];
                function flatten(cols, parentStartIndex = 0) {
                    cols.forEach((col) => {
                        const startIndex = col.startInTotal
                            ? col.startInTotal + state.table.internalProps.layoutMap.leftRowSeriesNumberColumnCount ?? 0
                            : parentStartIndex;
                        if (col.columns) {
                            flatten(col.columns, startIndex);
                        }
                        else {
                            result.push({
                                ...col,
                                startIndex
                            });
                        }
                    });
                }
                flatten(columns);
                return result;
            }
            const sort = sortState &&
                sortState.reduce((prev, item) => {
                    const column = flattenColumns(this.table.internalProps.columns)?.find(column => column?.field === item?.field);
                    if (this.table.internalProps.transpose) {
                        prev.push({
                            field: item.field,
                            order: item.order,
                            row: column?.startInTotal + this.table.internalProps.layoutMap.leftRowSeriesNumberColumnCount ?? 0,
                            col: column?.level
                        });
                    }
                    else {
                        prev.push({
                            field: item.field,
                            order: item.order,
                            col: column?.startInTotal + this.table.internalProps.layoutMap.leftRowSeriesNumberColumnCount ?? 0,
                            row: column?.level
                        });
                    }
                    return prev;
                }, []);
            this.sort = sort || [];
        }
        setFrozenState() {
            this.frozen.col = this.table.frozenColCount - 1;
        }
        updateInteractionState(mode) {
            if (this.interactionState === mode) {
                return;
            }
            if (mode === InteractionState.scrolling) {
                this.interactionStateBeforeScroll = this.interactionState;
            }
            const oldState = this.interactionState;
            this.interactionState = mode;
            if (oldState === InteractionState.scrolling && mode === InteractionState.default) ;
        }
        updateHoverhighlightScope(mode) {
            if (this.hover.highlightScope === mode) {
                return;
            }
            this.hover.highlightScope = mode;
        }
        updateHoverPos(col, row) {
            updateHoverPosition(this, col, row);
        }
        updateSelectPos(col, row, isShift = false, isCtrl = false, isSelectAll = false, makeSelectCellVisible = true, skipBodyMerge = false) {
            if (row !== -1 && row !== -1) {
                this.select.selecting = true;
            }
            if (col < 0) {
                col = -1;
            }
            if (row < 0) {
                row = -1;
            }
            if (col > this.table.colCount - 1) {
                col = this.table.colCount - 1;
            }
            if (row > this.table.rowCount - 1) {
                row = this.table.rowCount - 1;
            }
            updateSelectPosition(this, col, row, isShift, isCtrl, isSelectAll, makeSelectCellVisible, skipBodyMerge);
        }
        checkCellRangeInSelect(cellPosStart, cellPosEnd) {
            return checkMultiCellInSelect(cellPosStart, cellPosEnd, this.select.ranges, this.select.highlightScope);
        }
        updateHoverIcon(col, row, target, cellGroup) {
            if (this.residentHoverIcon?.icon && target === this.residentHoverIcon?.icon) {
                return;
            }
            const iconInfo = getIconAndPositionFromTarget(target);
            if (!iconInfo) {
                if (this.hoverIcon.icon && this.hoverIcon.icon !== this.residentHoverIcon?.icon) {
                    this.table.scenegraph.setIconNormalStyle(this.hoverIcon.icon, this.hoverIcon.col, this.hoverIcon.row);
                    this.hoverIcon.col = -1;
                    this.hoverIcon.col = -1;
                    this.hoverIcon.icon = null;
                    this.table.scenegraph.updateNextFrame();
                }
                return;
            }
            if (iconInfo.type === 'richtext-icon') {
                const inlineIcon = iconInfo.icon;
                if (this.hoverIcon.icon && this.hoverIcon.icon !== this.residentHoverIcon?.icon) {
                    this.table.scenegraph.setIconNormalStyle(this.hoverIcon.icon, this.hoverIcon.col, this.hoverIcon.row);
                    this.hoverIcon.col = -1;
                    this.hoverIcon.col = -1;
                    this.hoverIcon.icon = null;
                    this.table.scenegraph.updateNextFrame();
                }
                if (inlineIcon.attribute.tooltip) {
                    const tooltipOptions = {
                        content: inlineIcon.attribute.tooltip.title,
                        referencePosition: {
                            rect: iconInfo.position,
                            placement: inlineIcon.attribute.tooltip.placement
                        },
                        style: Object.assign({}, this.table.internalProps.theme?.tooltipStyle, inlineIcon.tooltip?.style, inlineIcon.attribute?.tooltip?.style),
                        disappearDelay: inlineIcon.attribute.tooltip.disappearDelay
                    };
                    if (!this.table.internalProps.tooltipHandler.isBinded(tooltipOptions)) {
                        this.table.showTooltip(col, row, tooltipOptions);
                    }
                }
            }
            else {
                const icon = iconInfo.icon;
                if (icon !== this.hoverIcon.icon) {
                    if (this.hoverIcon.icon && this.hoverIcon.icon !== this.residentHoverIcon?.icon) {
                        this.table.scenegraph.setIconNormalStyle(this.hoverIcon.icon, this.hoverIcon.col, this.hoverIcon.row);
                    }
                    this.hoverIcon.col = col;
                    this.hoverIcon.row = row;
                    this.hoverIcon.icon = icon;
                    this.table.scenegraph.setIconHoverStyle(icon, col, row, cellGroup);
                    this.table.scenegraph.updateNextFrame();
                }
            }
        }
        isResizeCol() {
            return this.columnResize.resizing;
        }
        isResizeRow() {
            return this.rowResize.resizing;
        }
        isFillHandle() {
            return this.fillHandle.isFilling;
        }
        isSelecting() {
            return this.select.selecting;
        }
        endSelectCells(fireListener = true, fireClear = true) {
            if (this.select.selecting) {
                this.select.selecting = false;
                if (this.select.ranges.length === 0) {
                    return;
                }
                const currentRange = this.select.ranges[this.select.ranges.length - 1];
                if (!this.table.isSeriesNumber(this.select.cellPos.col, this.select.cellPos.row) &&
                    !this.table.isHeader(this.select.cellPos.col, this.select.cellPos.row)) {
                    expendCellRange(currentRange, this.table);
                }
                let isSame = false;
                for (let i = 0; i < this.select.ranges.length - 1; i++) {
                    const range = this.select.ranges[i];
                    if (range &&
                        range.start.col === currentRange.start.col &&
                        range.start.row === currentRange.start.row &&
                        range.end.col === currentRange.end.col &&
                        range.end.row === currentRange.end.row) {
                        isSame = true;
                        break;
                    }
                }
                if (isSame) {
                    this.select.ranges.pop();
                    deleteAllSelectingBorder(this.table.scenegraph);
                    this.table.scenegraph.selectingRangeComponents.clear();
                }
                else {
                    selectEnd(this.table.scenegraph);
                }
                const lastCol = this.select.ranges[this.select.ranges.length - 1].end.col;
                const lastRow = this.select.ranges[this.select.ranges.length - 1].end.row;
                fireListener &&
                    this.table.fireListeners(TABLE_EVENT_TYPE.SELECTED_CELL, {
                        ranges: this.select.ranges,
                        col: lastCol,
                        row: lastRow
                    });
            }
            else if (fireClear) {
                if (this.select.ranges.length === 0) {
                    this.table.fireListeners(TABLE_EVENT_TYPE.SELECTED_CLEAR, {});
                }
            }
        }
        endResizeCol() {
            setTimeout(() => {
                this.columnResize.resizing = false;
            }, 0);
            this.table.scenegraph.updateChartSizeForResizeColWidth(this.columnResize.col);
            this.checkFrozen();
            this.table.scenegraph.component.hideResizeCol();
            this.table.scenegraph.updateNextFrame();
        }
        startResizeCol(col, x, y, isRightFrozen) {
            this.columnResize.resizing = true;
            this.columnResize.col = col;
            this.columnResize.x = x;
            this.columnResize.isRightFrozen = isRightFrozen;
            this.table.scenegraph.component.showResizeCol(col, y, isRightFrozen);
            this.table.scenegraph.updateNextFrame();
        }
        updateResizeCol(xInTable, yInTable) {
            updateResizeColumn(xInTable, yInTable, this);
        }
        endResizeRow() {
            setTimeout(() => {
                this.rowResize.resizing = false;
            }, 0);
            this.table.scenegraph.updateChartSizeForResizeRowHeight(this.rowResize.row);
            this.table.scenegraph.component.hideResizeRow();
            this.table.scenegraph.updateNextFrame();
        }
        startResizeRow(row, x, y, isBottomFrozen) {
            this.rowResize.resizing = true;
            this.rowResize.row = row;
            this.rowResize.y = y;
            this.rowResize.isBottomFrozen = isBottomFrozen;
            this.table.scenegraph.component.showResizeRow(row, x, isBottomFrozen);
            this.table.scenegraph.updateNextFrame();
        }
        updateResizeRow(xInTable, yInTable) {
            updateResizeRow(xInTable, yInTable, this);
        }
        startFillSelect(x, y) {
            this.fillHandle.isFilling = true;
            this.fillHandle.startX = x;
            this.fillHandle.startY = y;
            const currentRange = this.select.ranges[this.select.ranges.length - 1];
            this.fillHandle.beforeFillMinCol = Math.min(currentRange.start.col, currentRange.end.col);
            this.fillHandle.beforeFillMinRow = Math.min(currentRange.start.row, currentRange.end.row);
            this.fillHandle.beforeFillMaxCol = Math.max(currentRange.start.col, currentRange.end.col);
            this.fillHandle.beforeFillMaxRow = Math.max(currentRange.start.row, currentRange.end.row);
            this.table.fireListeners(TABLE_EVENT_TYPE.MOUSEDOWN_FILL_HANDLE, {});
        }
        endFillSelect() {
            this.fillHandle.isFilling = false;
            this.fillHandle.startX = undefined;
            this.fillHandle.startY = undefined;
            this.fillHandle.directionRow = undefined;
            const currentMinCol = Math.min(this.select.ranges[0].start.col, this.select.ranges[0].end.col);
            const currentMinRow = Math.min(this.select.ranges[0].start.row, this.select.ranges[0].end.row);
            const currentMaxCol = Math.max(this.select.ranges[0].start.col, this.select.ranges[0].end.col);
            const currentMaxRow = Math.max(this.select.ranges[0].start.row, this.select.ranges[0].end.row);
            if (this.fillHandle.beforeFillMinCol !== currentMinCol ||
                this.fillHandle.beforeFillMinRow !== currentMinRow ||
                this.fillHandle.beforeFillMaxCol !== currentMaxCol ||
                this.fillHandle.beforeFillMaxRow !== currentMaxRow) {
                this.table.eventManager.isDraging &&
                    this.table.fireListeners(TABLE_EVENT_TYPE.DRAG_FILL_HANDLE_END, { direction: this.fillHandle.direction });
            }
            this.fillHandle.beforeFillMaxCol = undefined;
            this.fillHandle.beforeFillMaxRow = undefined;
            this.fillHandle.beforeFillMinCol = undefined;
            this.fillHandle.beforeFillMinRow = undefined;
        }
        startMoveCol(col, row, x, y, event) {
            startMoveCol(col, row, x, y, this, event);
        }
        updateMoveCol(col, row, x, y, event) {
            updateMoveCol(col, row, x, y, this, event);
        }
        isMoveCol() {
            return this.columnMove.moving;
        }
        endMoveCol() {
            return endMoveCol(this);
        }
        checkFrozen() {
            let originalFrozenColCount = this.table.options.frozenColCount
                ? this.table.options.frozenColCount
                : this.table.isPivotTable() || (this.table.isListTable() && this.table.internalProps.transpose)
                    ? (this.table.rowHeaderLevelCount ?? 0) + this.table.internalProps.layoutMap.leftRowSeriesNumberColumnCount
                    : 0;
            if (originalFrozenColCount) {
                if (originalFrozenColCount > this.table.colCount) {
                    originalFrozenColCount = this.table.colCount;
                }
                const maxFrozenWidth = this.table._getMaxFrozenWidth();
                if (this.table.getColsWidth(0, originalFrozenColCount - 1) > maxFrozenWidth) {
                    if (this.table.internalProps.unfreezeAllOnExceedsMaxWidth) {
                        this.table._setFrozenColCount(0);
                        this.setFrozenCol(-1);
                    }
                    else {
                        const computedFrozenColCount = this.table._getComputedFrozenColCount(originalFrozenColCount);
                        this.table._setFrozenColCount(computedFrozenColCount);
                        this.setFrozenCol(computedFrozenColCount);
                    }
                }
                else if (this.table.frozenColCount !== originalFrozenColCount) {
                    this.table._setFrozenColCount(originalFrozenColCount);
                    this.setFrozenCol(originalFrozenColCount);
                }
            }
        }
        setFrozenCol(col) {
            if (col !== this.frozen.col) {
                this.frozen.col = col;
                this.table.scenegraph.updateFrozen();
                this.table.scenegraph.updateFrozenIcon(0, this.table.colCount - 1);
            }
            else {
                this.table.scenegraph.updateFrozenIcon(0, this.table.colCount - 1);
            }
        }
        setFrozenRow(row) {
            if (row !== this.frozen.row) {
                this.frozen.row = row;
                this.table.scenegraph.updateRowFrozen();
            }
        }
        checkVerticalScrollBarEnd() {
            const totalHeight = this.table.getAllRowsHeight();
            const scrollTop = this.scroll.verticalBarPos;
            const viewHeight = this.table.tableNoFrameHeight;
            if (scrollTop + viewHeight >= totalHeight) {
                this.table.fireListeners(TABLE_EVENT_TYPE.SCROLL_VERTICAL_END, {
                    scrollTop,
                    scrollLeft: this.scroll.horizontalBarPos,
                    scrollHeight: this.table.theme.scrollStyle?.width,
                    scrollWidth: this.table.theme.scrollStyle?.width,
                    viewHeight,
                    viewWidth: this.table.tableNoFrameWidth
                });
            }
        }
        checkHorizontalScrollBarEnd() {
            const totalWidth = this.table.getAllColsWidth();
            const scrollLeft = this.scroll.horizontalBarPos;
            const viewWidth = this.table.tableNoFrameWidth;
            if (scrollLeft + viewWidth >= totalWidth) {
                this.table.fireListeners(TABLE_EVENT_TYPE.SCROLL_HORIZONTAL_END, {
                    scrollTop: this.scroll.verticalBarPos,
                    scrollLeft,
                    scrollHeight: this.table.theme.scrollStyle?.width,
                    scrollWidth: this.table.theme.scrollStyle?.width,
                    viewHeight: this.table.tableNoFrameHeight,
                    viewWidth
                });
            }
        }
        updateVerticalScrollBar(yRatio) {
            const totalHeight = this.table.getAllRowsHeight();
            const oldVerticalBarPos = this.scroll.verticalBarPos;
            let verticalBarPos = Math.ceil(yRatio * (totalHeight - this.table.scenegraph.height));
            if (!isValid$3(verticalBarPos) || isNaN(verticalBarPos)) {
                verticalBarPos = 0;
            }
            const dy = verticalBarPos - this.table.scenegraph.proxy.deltaY - oldVerticalBarPos;
            const canScroll = this.table.fireListeners(TABLE_EVENT_TYPE.CAN_SCROLL, {
                event: undefined,
                scrollTop: verticalBarPos - this.table.scenegraph.proxy.deltaY,
                scrollLeft: this.scroll.horizontalBarPos,
                scrollHeight: this.table.theme.scrollStyle?.width,
                scrollWidth: this.table.theme.scrollStyle?.width,
                viewHeight: this.table.tableNoFrameHeight,
                viewWidth: this.table.tableNoFrameWidth,
                scrollDirection: 'vertical',
                scrollRatioY: yRatio,
                dy
            });
            if (canScroll.some(value => value === false)) {
                const yRatio = this.scroll.verticalBarPos / (totalHeight - this.table.scenegraph.height);
                this.table.scenegraph.component.updateVerticalScrollBarPos(yRatio);
                return;
            }
            this.scroll.verticalBarPos = verticalBarPos;
            this.table.scenegraph.setY(-this.scroll.verticalBarPos, yRatio === 1);
            this.scroll.verticalBarPos -= this.table.scenegraph.proxy.deltaY;
            this.table.scenegraph.proxy.deltaY = 0;
            this.updateHoverPos(-1, -1);
            this.table.fireListeners(TABLE_EVENT_TYPE.SCROLL, {
                event: undefined,
                scrollTop: this.scroll.verticalBarPos,
                scrollLeft: this.scroll.horizontalBarPos,
                scrollHeight: this.table.theme.scrollStyle?.width,
                scrollWidth: this.table.theme.scrollStyle?.width,
                viewHeight: this.table.tableNoFrameHeight,
                viewWidth: this.table.tableNoFrameWidth,
                scrollDirection: 'vertical',
                scrollRatioY: yRatio,
                dy
            });
            if (oldVerticalBarPos !== this.scroll.verticalBarPos) {
                this.checkVerticalScrollBarEnd();
            }
        }
        updateHorizontalScrollBar(xRatio) {
            const totalWidth = this.table.getAllColsWidth();
            const oldHorizontalBarPos = this.scroll.horizontalBarPos;
            let horizontalBarPos = Math.ceil(xRatio * (totalWidth - this.table.scenegraph.width));
            if (!isValid$3(horizontalBarPos) || isNaN(horizontalBarPos)) {
                horizontalBarPos = 0;
            }
            const dx = horizontalBarPos - this.table.scenegraph.proxy.deltaX - oldHorizontalBarPos;
            const canScroll = this.table.fireListeners(TABLE_EVENT_TYPE.CAN_SCROLL, {
                event: undefined,
                scrollTop: this.scroll.verticalBarPos,
                scrollLeft: horizontalBarPos - this.table.scenegraph.proxy.deltaX,
                scrollHeight: this.table.theme.scrollStyle?.width,
                scrollWidth: this.table.theme.scrollStyle?.width,
                viewHeight: this.table.tableNoFrameHeight,
                viewWidth: this.table.tableNoFrameWidth,
                scrollDirection: 'horizontal',
                scrollRatioX: xRatio,
                dx: dx
            });
            if (canScroll.some(value => value === false)) {
                const xRatio = this.scroll.horizontalBarPos / (totalWidth - this.table.scenegraph.width);
                this.table.scenegraph.component.updateHorizontalScrollBarPos(xRatio);
                return;
            }
            this.scroll.horizontalBarPos = horizontalBarPos;
            this.table.scenegraph.setX(-this.scroll.horizontalBarPos, xRatio === 1);
            this.scroll.horizontalBarPos -= this.table.scenegraph.proxy.deltaX;
            this.table.scenegraph.proxy.deltaX = 0;
            this.updateHoverPos(-1, -1);
            this.table.fireListeners(TABLE_EVENT_TYPE.SCROLL, {
                event: undefined,
                scrollTop: this.scroll.verticalBarPos,
                scrollLeft: this.scroll.horizontalBarPos,
                scrollHeight: this.table.theme.scrollStyle?.width,
                scrollWidth: this.table.theme.scrollStyle?.width,
                viewHeight: this.table.tableNoFrameHeight,
                viewWidth: this.table.tableNoFrameWidth,
                scrollDirection: 'horizontal',
                scrollRatioX: xRatio,
                dx: dx
            });
            if (oldHorizontalBarPos !== this.scroll.horizontalBarPos) {
                this.checkHorizontalScrollBarEnd();
            }
        }
        setScrollTop(top, event, triggerEvent = true) {
            const totalHeight = this.table.getAllRowsHeight();
            const sizeTolerance = this.table.options.customConfig?._disableColumnAndRowSizeRound ? 1 : 0;
            top = Math.max(0, Math.min(top, totalHeight - this.table.scenegraph.height - sizeTolerance));
            top = Math.ceil(top);
            const oldVerticalBarPos = this.scroll.verticalBarPos;
            const yRatio = top / (totalHeight - this.table.scenegraph.height);
            if ((oldVerticalBarPos !== top || this.table.options?.customConfig?.scrollEventAlwaysTrigger === true) &&
                triggerEvent) {
                let verticalBarPos = top;
                if (!isValid$3(verticalBarPos) || isNaN(verticalBarPos)) {
                    verticalBarPos = 0;
                }
                const dy = verticalBarPos - oldVerticalBarPos;
                const canScroll = this.table.fireListeners(TABLE_EVENT_TYPE.CAN_SCROLL, {
                    event: event?.nativeEvent,
                    scrollTop: verticalBarPos,
                    scrollLeft: this.scroll.horizontalBarPos,
                    scrollHeight: this.table.theme.scrollStyle?.width,
                    scrollWidth: this.table.theme.scrollStyle?.width,
                    viewHeight: this.table.tableNoFrameHeight,
                    viewWidth: this.table.tableNoFrameWidth,
                    scrollDirection: 'vertical',
                    scrollRatioY: yRatio,
                    dy
                });
                if (canScroll.some(value => value === false)) {
                    const yRatio = this.scroll.verticalBarPos / (totalHeight - this.table.scenegraph.height);
                    this.table.scenegraph.component.updateVerticalScrollBarPos(yRatio);
                    return;
                }
            }
            if (top !== this.scroll.verticalBarPos || this.table.isPivotChart()) {
                this.updateHoverPos(-1, -1);
            }
            this.scroll.verticalBarPos = top;
            if (!isValid$3(this.scroll.verticalBarPos) || isNaN(this.scroll.verticalBarPos)) {
                this.scroll.verticalBarPos = 0;
            }
            this.table.scenegraph.setY(-top);
            this.table.scenegraph.component.updateVerticalScrollBarPos(yRatio);
            const dy = this.scroll.verticalBarPos - oldVerticalBarPos;
            this.table.fireListeners(TABLE_EVENT_TYPE.SCROLL, {
                event: event?.nativeEvent,
                scrollTop: this.scroll.verticalBarPos,
                scrollLeft: this.scroll.horizontalBarPos,
                scrollHeight: this.table.theme.scrollStyle?.width,
                scrollWidth: this.table.theme.scrollStyle?.width,
                viewHeight: this.table.tableNoFrameHeight,
                viewWidth: this.table.tableNoFrameWidth,
                scrollDirection: 'vertical',
                scrollRatioY: yRatio,
                dy
            });
            if (oldVerticalBarPos !== top && triggerEvent) {
                this.checkVerticalScrollBarEnd();
            }
        }
        setScrollLeft(left, event, triggerEvent = true) {
            this.table.scrollLeft;
            const totalWidth = this.table.getAllColsWidth();
            this.table.getFrozenColsWidth();
            const sizeTolerance = this.table.options.customConfig?._disableColumnAndRowSizeRound ? 1 : 0;
            left = Math.max(0, Math.min(left, totalWidth - this.table.scenegraph.width - sizeTolerance));
            left = Math.ceil(left);
            const oldHorizontalBarPos = this.scroll.horizontalBarPos;
            const xRatio = left / (totalWidth - this.table.scenegraph.width);
            if ((oldHorizontalBarPos !== left || this.table.options?.customConfig?.scrollEventAlwaysTrigger === true) &&
                triggerEvent) {
                let horizontalBarPos = left;
                if (!isValid$3(horizontalBarPos) || isNaN(horizontalBarPos)) {
                    horizontalBarPos = 0;
                }
                const dx = horizontalBarPos - oldHorizontalBarPos;
                const canScroll = this.table.fireListeners(TABLE_EVENT_TYPE.CAN_SCROLL, {
                    event: event?.nativeEvent,
                    scrollTop: this.scroll.verticalBarPos,
                    scrollLeft: horizontalBarPos,
                    scrollHeight: this.table.theme.scrollStyle?.width,
                    scrollWidth: this.table.theme.scrollStyle?.width,
                    viewHeight: this.table.tableNoFrameHeight,
                    viewWidth: this.table.tableNoFrameWidth,
                    scrollDirection: 'horizontal',
                    scrollRatioX: xRatio,
                    dx
                });
                if (canScroll.some(value => value === false)) {
                    const xRatio = this.scroll.horizontalBarPos / (totalWidth - this.table.scenegraph.width);
                    this.table.scenegraph.component.updateHorizontalScrollBarPos(xRatio);
                    return;
                }
            }
            if (left !== this.scroll.horizontalBarPos) {
                this.updateHoverPos(-1, -1);
            }
            this.scroll.horizontalBarPos = left;
            if (!isValid$3(this.scroll.horizontalBarPos) || isNaN(this.scroll.horizontalBarPos)) {
                this.scroll.horizontalBarPos = 0;
            }
            this.table.scenegraph.setX(-left);
            this.table.scenegraph.component.updateHorizontalScrollBarPos(xRatio);
            const dx = this.scroll.horizontalBarPos - oldHorizontalBarPos;
            this.table.fireListeners(TABLE_EVENT_TYPE.SCROLL, {
                event: event?.nativeEvent,
                scrollTop: this.scroll.verticalBarPos,
                scrollLeft: this.scroll.horizontalBarPos,
                scrollHeight: this.table.theme.scrollStyle?.width,
                scrollWidth: this.table.theme.scrollStyle?.width,
                viewHeight: this.table.tableNoFrameHeight,
                viewWidth: this.table.tableNoFrameWidth,
                scrollDirection: 'horizontal',
                scrollRatioX: xRatio,
                dx
            });
            if (oldHorizontalBarPos !== left && triggerEvent) {
                this.checkHorizontalScrollBarEnd();
            }
        }
        hideVerticalScrollBar() {
            this.table.scenegraph.component.hideVerticalScrollBar();
        }
        showVerticalScrollBar(autoHide) {
            this.table.scenegraph.component.showVerticalScrollBar();
            if (autoHide) {
                clearTimeout(this._clearVerticalScrollBar);
                this._clearVerticalScrollBar = setTimeout(() => {
                    this.table.scenegraph?.component.hideVerticalScrollBar();
                }, 1000);
            }
        }
        hideHorizontalScrollBar() {
            this.table.scenegraph.component.hideHorizontalScrollBar();
        }
        showHorizontalScrollBar(autoHide) {
            this.table.scenegraph.component.showHorizontalScrollBar();
            this.table.scenegraph?.component.showFrozenColumnShadow();
            if (autoHide) {
                clearTimeout(this._clearHorizontalScrollBar);
                this._clearHorizontalScrollBar = setTimeout(() => {
                    this.table.scenegraph?.component.hideFrozenColumnShadow();
                    this.table.scenegraph?.component.hideHorizontalScrollBar();
                }, 1000);
            }
        }
        triggerContextMenu(col, row, x, y) {
            if (this.menu.isShow && this.menu.x === x && this.menu.y === y) {
                this.hideMenu();
            }
            else {
                this.showContextMenu(col, row, x, y);
            }
        }
        showContextMenu(col, row, x, y) {
            if (this.table.internalProps.menu?.contextMenuItems) {
                if (this.table.internalProps.menu.renderMode === 'html') {
                    this.menu.isShow = true;
                }
                else {
                    this.menu.isShow = true;
                    this.menu.x = x;
                    this.menu.y = y;
                    this.table.scenegraph.component.menu.attach(x, y, col, row, MenuType.contextmenu);
                }
                this.table.fireListeners(TABLE_EVENT_TYPE.SHOW_MENU, { x, y, col, row, type: 'contextmenu' });
            }
        }
        triggerDropDownMenu(col, row, x, y, event) {
            this.table.fireListeners(TABLE_EVENT_TYPE.DROPDOWN_ICON_CLICK, {
                col,
                row,
                event
            });
            if (this.menu.isShow) {
                this.hideMenu();
            }
            else {
                this.showDropDownMenu(col, row, x, y);
            }
        }
        showDropDownMenu(col, row, x, y) {
            if (this.table.internalProps.menu.renderMode === 'html') {
                this.menu.isShow = true;
            }
            else {
                this.menu.isShow = true;
                this.table.scenegraph.component.menu.attach(x, y, col, row, MenuType.dropDown);
                this.menu.bounds = this.table.scenegraph.component.menu.bounds;
            }
            this.table.fireListeners(TABLE_EVENT_TYPE.SHOW_MENU, { x, y, col, row, type: 'dropDown' });
            if (this.residentHoverIcon) {
                this.table.scenegraph.setIconNormalStyle(this.residentHoverIcon.icon, this.residentHoverIcon.col, this.residentHoverIcon.row);
            }
            const cellGroup = this.table.scenegraph.getCell(col, row);
            let icon;
            cellGroup.forEachChildren((child) => {
                if (child.attribute.funcType === IconFuncTypeEnum.dropDown) {
                    icon = child;
                    return true;
                }
                return false;
            });
            if (icon) {
                this.residentHoverIcon = {
                    col,
                    row,
                    icon
                };
                this.table.scenegraph.setIconHoverStyle(this.residentHoverIcon.icon, this.residentHoverIcon.col, this.residentHoverIcon.row, cellGroup);
                this.table.scenegraph.residentHoverIcon(col, row);
            }
        }
        hideMenu() {
            if (this.menu.isShow) {
                this.table.fireListeners(TABLE_EVENT_TYPE.DROPDOWN_MENU_CLEAR, null);
                this.table.fireListeners(TABLE_EVENT_TYPE.HIDE_MENU, null);
                this.menu.isShow = false;
                this.table.scenegraph.component.menu.detach();
                if (this.residentHoverIcon) {
                    this.table.scenegraph.setIconNormalStyle(this.residentHoverIcon.icon, this.residentHoverIcon.col, this.residentHoverIcon.row);
                    this.table.scenegraph.resetResidentHoverIcon(this.residentHoverIcon.col, this.residentHoverIcon.row);
                    this.residentHoverIcon = null;
                }
            }
        }
        setDropDownMenuHighlight(dropDownMenuInfo) {
            this.menu.dropDownMenuHighlight = dropDownMenuInfo;
            for (let i = 0; i < dropDownMenuInfo.length; i++) {
                const { col, row } = dropDownMenuInfo[i];
                const range = this.table.getCellRange(col, row);
                if (!range) {
                    continue;
                }
                for (let col = range.start.col; col <= range.end.col; col++) {
                    for (let row = range.start.row; row <= range.end.row; row++) {
                        this.table.scenegraph.updateCellContent(col, row);
                    }
                }
            }
        }
        dropDownMenuIsHighlight(colNow, rowNow, index) {
            const highlights = this.menu.dropDownMenuHighlight;
            if (Array.isArray(highlights)) {
                for (let i = 0; i < highlights.length; i++) {
                    const highlight = highlights[i];
                    let { col, row } = highlight;
                    const { field, menuKey } = highlight;
                    if (typeof col !== 'number' || typeof row !== 'number') {
                        if (this.table.isPivotTable() && typeof Array.isArray(field)) {
                            const cellAddress = this.table.internalProps.layoutMap.getPivotCellAdress(field);
                            if (!cellAddress) {
                                continue;
                            }
                            col = cellAddress.col;
                            row = cellAddress.row;
                        }
                        else {
                            const cellAddress = this.table.internalProps.layoutMap.getHeaderCellAddressByField(field);
                            if (!cellAddress) {
                                continue;
                            }
                            col = cellAddress.col;
                            row = cellAddress.row;
                        }
                    }
                    if (isValid$3(col) && isValid$3(row) && this.table.isCellRangeEqual(colNow, rowNow, col, row)) {
                        const headerC = this.table._getHeaderLayoutMap(col ?? colNow, row ?? rowNow);
                        let dropDownMenu = headerC.dropDownMenu || this.table.globalDropDownMenu;
                        if (typeof dropDownMenu === 'function') {
                            dropDownMenu = dropDownMenu({ row, col, table: this.table });
                        }
                        if (dropDownMenu) {
                            for (let i = 0; i < dropDownMenu.length; i++) {
                                const item = dropDownMenu[i];
                                if (isObject$7(item) && (item.menuKey || item.text) === (menuKey || '') && i === index) {
                                    return true;
                                }
                                else if (isString$4(item) && item === menuKey && i === index) {
                                    return true;
                                }
                            }
                        }
                    }
                }
            }
            return false;
        }
        triggerSort(col, row, iconMark, event) {
            if (this.table.isPivotTable()) {
                const sortState = this.table.getPivotSortState(col, row);
                const order = sortState ? sortState.toUpperCase() : 'NORMAL';
                const new_order = order === 'ASC' ? 'DESC' : order === 'DESC' ? 'NORMAL' : 'ASC';
                this.table.sort(col, row, new_order);
                this.table.fireListeners(PIVOT_TABLE_EVENT_TYPE.PIVOT_SORT_CLICK, {
                    col: col,
                    row: row,
                    order: order || 'normal',
                    dimensionInfo: this.table.internalProps.layoutMap.getPivotDimensionInfo(col, row),
                    cellLocation: this.table.getCellLocation(col, row),
                    event
                });
                return;
            }
            const previousSort = [...this.sort];
            const previousSortItem = this.table.internalProps.multipleSort || !previousSort.length ? null : this.sort[this.sort.length - 1];
            dealSort(col, row, this.table, event);
            const range = this.table.getCellRange(col, row);
            const currentSortItem = this.sort.find(item => item.col === range.start.col && item.row === range.start.row);
            const oldSortCol = this.table.internalProps.multipleSort || !previousSortItem ? null : previousSortItem.col;
            const oldSortRow = this.table.internalProps.multipleSort || !previousSortItem ? null : previousSortItem.row;
            const currentSortItemIndex = previousSort.findIndex(item => item.col === col && item.row === row);
            if (currentSortItemIndex >= 0) {
                previousSort.splice(currentSortItemIndex, 1);
            }
            this.table.scenegraph.updateSortIcon({
                col: col,
                row: row,
                iconMark,
                order: currentSortItem?.order,
                oldSortCol,
                oldSortRow,
                oldIconMark: previousSortItem?.icon
            });
            if (currentSortItem) {
                currentSortItem.icon = iconMark;
            }
            if (!this.table.internalProps.multipleSort) {
                previousSort.forEach((sortItem) => {
                    this.table.scenegraph.updateSortIcon({
                        col: null,
                        row: null,
                        iconMark: null,
                        order: 'normal',
                        oldSortCol: sortItem.col,
                        oldSortRow: sortItem.row,
                        oldIconMark: null
                    });
                });
            }
            this.table.fireListeners(PIVOT_TABLE_EVENT_TYPE.AFTER_SORT, {
                order: currentSortItem?.order,
                field: this.table.getHeaderField(col, row),
                event
            });
        }
        updateSortState(sortState) {
            sortState = Array.isArray(sortState) ? sortState : [sortState];
            for (let index = 0; index < sortState.length; index++) {
                if (sortState[index].field === this.sort[index]?.field &&
                    sortState[sortState.length - 1].order === this.sort[index]?.order) {
                    return;
                }
                const oldSortCol = this.table.internalProps.multipleSort ? null : this.sort[index]?.col || null;
                const oldSortRow = this.table.internalProps.multipleSort ? null : this.sort[index]?.row || null;
                this.sort[index]?.order === 'asc'
                    ? 'sort_downward'
                    : this.sort[index]?.order === 'desc'
                        ? 'sort_upward'
                        : 'sort_normal';
                this.setSortState(sortState.slice(0, index + 1));
                const cellAddress = this.table.internalProps.layoutMap.getHeaderCellAddressByField(sortState[index].field);
                this.sort[index].col = cellAddress.col;
                this.sort[index].row = cellAddress.row;
                const cellGroup = this.table.scenegraph.getCell(this.sort[index].col, this.sort[index].row);
                let iconMark;
                traverseObject(cellGroup, 'children', (mark) => {
                    if (mark.attribute.funcType === 'sort') {
                        iconMark = mark;
                        return true;
                    }
                    return false;
                });
                this.table.scenegraph.updateSortIcon({
                    col: this.sort[index].col,
                    row: this.sort[index].row,
                    iconMark,
                    order: this.sort[index].order,
                    oldSortCol,
                    oldSortRow,
                    oldIconMark: this.sort[index]?.icon
                });
            }
            const normalHeaders = [];
            this.table.internalProps.layoutMap.columnTree.tree.children.forEach((item) => {
                if (!sortState.some((state) => state.field === item.field)) {
                    normalHeaders.push(item);
                }
            });
            for (let index = 0; index < normalHeaders.length; index++) {
                const column = normalHeaders[index];
                this.table.scenegraph.updateSortIcon({
                    col: null,
                    row: null,
                    iconMark: null,
                    order: null,
                    oldSortCol: column.startInTotal + this.table.internalProps.layoutMap.leftRowSeriesNumberColumnCount ?? 0,
                    oldSortRow: column.level,
                    oldIconMark: null
                });
            }
        }
        triggerFreeze(col, row, iconMark) {
            if (this.table.isPivotTable() || this.table.transpose) {
                return;
            }
            dealFreeze(col, row, this.table);
            if (this.table.hasListeners(PIVOT_TABLE_EVENT_TYPE.FREEZE_CLICK)) {
                const fields = this.table.internalProps.layoutMap.columnObjects.slice(0, col + 1);
                this.table.fireListeners(PIVOT_TABLE_EVENT_TYPE.FREEZE_CLICK, {
                    col: col,
                    row: row,
                    fields: fields.reduce((pre, cur) => pre.concat(cur.field), []),
                    colCount: this.table.frozenColCount
                });
            }
            this.frozen.icon = iconMark;
        }
        updateCursor(mode = 'default') {
            this.table.getElement().style.cursor = mode;
        }
        updateDrillState(dimensionKey, title, drillDown, drillUp, col, row) {
            this.drill.dimensionKey = dimensionKey;
            this.drill.title = title;
            this.drill.drillDown = drillDown;
            this.drill.drillUp = drillUp;
            this.drill.col = col;
            this.drill.row = row;
            updateDrill(col, row, drillDown, drillUp, this.table);
        }
        updateSparklineHoverPose(col, row, x, y) {
            if (this.sparkLine.col !== -1 && this.sparkLine.row !== -1) {
                clearChartHover(this.sparkLine.col, this.sparkLine.row, this.table);
            }
            let isUpdated = false;
            if (col !== -1 && row !== -1) {
                isUpdated = updateChartHover(col, row, x, y, this.table);
            }
            if (isUpdated) {
                this.sparkLine.col = col;
                this.sparkLine.row = row;
            }
            else {
                this.sparkLine.col = -1;
                this.sparkLine.row = -1;
            }
        }
        setCheckedState(col, row, field, checked) {
            return setCheckedState(col, row, field, checked, this);
        }
        setHeaderCheckedState(field, checked) {
            return setHeaderCheckedState(field, checked, this);
        }
        syncCheckedState(col, row, field, checked) {
            return syncCheckedState(col, row, field, checked, this);
        }
        initCheckedState(records) {
            return initCheckedState(records, this);
        }
        updateHeaderCheckedState(field, col, row) {
            return updateHeaderCheckedState(field, this, col, row);
        }
        initLeftRecordsCheckState(records) {
            return initLeftRecordsCheckState(records, this);
        }
        setRadioState(col, row, field, radioType, indexInCell) {
            setRadioState(col, row, field, radioType, indexInCell, this);
        }
        syncRadioState(col, row, field, radioType, indexInCell, isChecked) {
            return syncRadioState(col, row, field, radioType, indexInCell, isChecked, this);
        }
        changeCheckboxAndRadioOrder(sourceIndex, targetIndex) {
            if (this.checkedState.size) {
                changeCheckboxOrder(sourceIndex, targetIndex, this);
            }
            if (this.radioState.length) {
                changeRadioOrder(sourceIndex, targetIndex, this);
            }
        }
        setCustomSelectRanges(customSelectRanges) {
            deletaCustomSelectRanges(this);
            addCustomSelectRanges(customSelectRanges, this);
        }
    }

    function bindMediaClick(table) {
        if (Env.mode === 'browser') {
            table.on(TABLE_EVENT_TYPE.CLICK_CELL, (e) => {
                const { col, row } = e;
                if (e.target.type === 'image' && e.target.role && e.target.role.startsWith('icon')) {
                    return;
                }
                let cellType;
                if (table.internalProps.layoutMap.isHeader(col, row)) {
                    cellType = table.isPivotTable()
                        ? table._getHeaderLayoutMap(col, row).headerType
                        : table.getHeaderDefine(col, row).headerType;
                }
                else {
                    cellType = table.getBodyColumnType(col, row);
                }
                const columnDefine = table.isHeader(col, row)
                    ? table.getHeaderDefine(col, row)
                    : table.getBodyColumnDefine(col, row);
                const cellValue = table.getCellValue(col, row);
                const cellOriginValue = table.getCellOriginValue(col, row);
                if (cellType === 'link') {
                    let linkJump = getOrApply(columnDefine.linkJump, {
                        col,
                        row,
                        table,
                        value: cellValue,
                        dataValue: cellOriginValue,
                        cellHeaderPaths: undefined
                    });
                    linkJump = linkJump !== false;
                    if (!linkJump) {
                        return;
                    }
                    const templateLink = columnDefine.templateLink;
                    let linkDetect = getOrApply(columnDefine.linkDetect, {
                        col,
                        row,
                        table,
                        value: cellValue,
                        dataValue: cellOriginValue,
                        cellHeaderPaths: undefined
                    });
                    linkDetect = linkDetect !== false;
                    let url;
                    if (templateLink) {
                        const rowData = table.getCellOriginRecord(col, row);
                        if (rowData && rowData.vtableMerge) {
                            return;
                        }
                        const data = Object.assign({
                            __value: cellValue,
                            __dataValue: cellOriginValue
                        }, rowData);
                        if (isFunction$5(templateLink)) {
                            url = templateLink(data, col, row, table);
                        }
                        else {
                            const re = /\{\s*(\S+?)\s*\}/g;
                            url = templateLink.replace(re, (matchs, key) => {
                                return data[key];
                            });
                        }
                    }
                    else if (!linkDetect) {
                        url = cellValue;
                    }
                    else if (regUrl.test(cellValue)) {
                        url = cellValue;
                    }
                    else {
                        return;
                    }
                    if (!url) {
                        return;
                    }
                    const linkTarget = columnDefine.linkTarget;
                    const linkWindowFeatures = columnDefine.linkWindowFeatures;
                    window.open(url, linkTarget, linkWindowFeatures);
                }
                else if (cellType === 'image') {
                    const { clickToPreview } = columnDefine;
                    if (clickToPreview === false) {
                        return;
                    }
                    const overlay = document.createElement('div');
                    overlay.style.width = '100%';
                    overlay.style.height = '100%';
                    overlay.style.position = 'absolute';
                    overlay.style.top = '0';
                    overlay.style.left = '0';
                    overlay.style.backgroundColor = 'rgba(30, 30, 30, 0.4)';
                    overlay.style.display = 'flex';
                    overlay.style.justifyContent = 'center';
                    overlay.style.alignItems = 'center';
                    overlay.style.overflow = 'hidden';
                    overlay.style.zIndex = '9999';
                    overlay.addEventListener('click', e => {
                        if (e.target === overlay) {
                            document.body.removeChild(overlay);
                        }
                    });
                    const image = new Image();
                    image.src = cellValue;
                    image.style.maxWidth = '80%';
                    image.style.maxHeight = '80%';
                    overlay.appendChild(image);
                    document.body.appendChild(overlay);
                }
                else if (cellType === 'video') {
                    const { clickToPreview } = columnDefine;
                    if (clickToPreview === false) {
                        return;
                    }
                    const overlay = document.createElement('div');
                    overlay.style.width = '100%';
                    overlay.style.height = '100%';
                    overlay.style.position = 'absolute';
                    overlay.style.top = '0';
                    overlay.style.left = '0';
                    overlay.style.backgroundColor = 'rgba(30, 30, 30, 0.4)';
                    overlay.style.display = 'flex';
                    overlay.style.justifyContent = 'center';
                    overlay.style.alignItems = 'center';
                    overlay.style.overflow = 'hidden';
                    overlay.style.zIndex = '9999';
                    overlay.addEventListener('click', e => {
                        if (e.target === overlay) {
                            document.body.removeChild(overlay);
                        }
                    });
                    const video = document.createElement('video');
                    video.src = cellValue;
                    video.style.maxWidth = '80%';
                    video.style.maxHeight = '80%';
                    video.setAttribute('preload', 'auto');
                    video.setAttribute('controls', 'true');
                    overlay.appendChild(video);
                    document.body.appendChild(overlay);
                }
            });
        }
    }

    function bindDrillEvent(table) {
        table.on(TABLE_EVENT_TYPE.MOUSEENTER_CELL, (e) => {
            const { col, row } = e;
            if (col === -1 || row === -1) {
                return;
            }
            const dimension = table.internalProps.layoutMap.getHeaderDimension(col, row);
            if (dimension?.drillDown || dimension?.drillUp) {
                table.stateManager.updateDrillState(dimension.dimensionKey, dimension.title, dimension.drillDown, dimension.drillUp, col, row);
            }
            else {
                table.stateManager.updateDrillState(undefined, undefined, false, false, -1, -1);
            }
        });
        table.on(TABLE_EVENT_TYPE.MOUSELEAVE_TABLE, (e) => {
            table.stateManager.updateDrillState(undefined, undefined, false, false, -1, -1);
        });
    }
    function drillClick(table) {
        table.fireListeners(PIVOT_TABLE_EVENT_TYPE.DRILLMENU_CLICK, table.stateManager.drill);
    }
    function checkHaveDrill(table) {
        const rowsDefine = table.internalProps.layoutMap.rowsDefine;
        const columnsDefine = table.internalProps.layoutMap.columnsDefine;
        for (let i = 0; i < rowsDefine.length; i++) {
            const row = rowsDefine[i];
            if (typeof row !== 'string' && (row.drillDown || row.drillUp)) {
                return true;
            }
        }
        for (let i = 0; i < columnsDefine.length; i++) {
            const column = columnsDefine[i];
            if (typeof column !== 'string' && (column.drillDown || column.drillUp)) {
                return true;
            }
        }
        return false;
    }

    function bindSparklineHoverEvent(table) {
        if (table.eventManager.bindSparklineHoverEvent) {
            return;
        }
        let hasSparkLine = false;
        if (table.isPivotTable()) {
            const layoutMap = table.internalProps.layoutMap;
            hasSparkLine = layoutMap.indicatorsDefine.some(indicator => {
                return typeof indicator !== 'string' && indicator.cellType === 'sparkline';
            });
        }
        else {
            const layoutMap = table.internalProps.layoutMap;
            hasSparkLine = layoutMap.columnObjects.some(column => {
                return column.cellType === 'sparkline' || typeof column.cellType === 'function';
            });
        }
        if (!hasSparkLine) {
            return;
        }
        table.eventManager.bindSparklineHoverEvent = true;
        table.on(TABLE_EVENT_TYPE.MOUSEMOVE_CELL, (e) => {
            const { col, row, x, y } = e;
            const type = table.getBodyColumnType(col, row);
            if (type !== 'sparkline') {
                table.stateManager.updateSparklineHoverPose(-1, -1, 0, 0);
            }
            table.stateManager.updateSparklineHoverPose(col, row, x, y);
        });
        table.on(TABLE_EVENT_TYPE.MOUSELEAVE_TABLE, (e) => {
            table.stateManager.updateSparklineHoverPose(-1, -1, 0, 0);
        });
    }

    function handleWhell(event, state, isWheelEvent = true) {
        let { deltaX, deltaY } = event;
        if (event.shiftKey && event.deltaY) {
            deltaX = deltaY;
            deltaY = 0;
        }
        const [optimizedDeltaX, optimizedDeltaY] = optimizeScrollXY(deltaX, deltaY, { horizontal: 1, vertical: 1 });
        if (optimizedDeltaX || optimizedDeltaY) {
            if (state.interactionState !== InteractionState.scrolling) {
                state.updateInteractionState(InteractionState.scrolling);
            }
        }
        if (optimizedDeltaX) {
            state.setScrollLeft(state.scroll.horizontalBarPos + optimizedDeltaX, event);
            state.showHorizontalScrollBar(true);
        }
        if (optimizedDeltaY) {
            state.setScrollTop(state.scroll.verticalBarPos + optimizedDeltaY, event);
            state.showVerticalScrollBar(true);
        }
        isWheelEvent && state.resetInteractionState(state.interactionStateBeforeScroll);
        if (event.nativeEvent?.cancelable &&
            (state.table.internalProps.overscrollBehavior === 'none' ||
                (Math.abs(deltaY) >= Math.abs(deltaX) && deltaY !== 0 && isVerticalScrollable(deltaY, state)) ||
                (Math.abs(deltaY) <= Math.abs(deltaX) && deltaX !== 0 && isHorizontalScrollable(deltaX, state)))) {
            event.nativeEvent.preventDefault();
        }
    }
    function optimizeScrollXY(x, y, ratio) {
        const ANGLE = 2;
        const angle = Math.abs(x / y);
        const deltaX = angle <= 1 / ANGLE ? 0 : x;
        const deltaY = angle > ANGLE ? 0 : y;
        return [Math.ceil(deltaX * (ratio.horizontal ?? 0)), Math.ceil(deltaY * (ratio.vertical ?? 0))];
    }
    function isVerticalScrollable(deltaY, state) {
        const totalHeight = state.table.getAllRowsHeight() - state.table.scenegraph.height;
        if (totalHeight === 0) {
            return false;
        }
        return !isScrollToTop(deltaY, state) && !isScrollToBottom(deltaY, state);
    }
    function isHorizontalScrollable(deltaX, state) {
        const totalWidth = state.table.getAllColsWidth() - state.table.scenegraph.width;
        if (totalWidth === 0) {
            return false;
        }
        return !isScrollToLeft(deltaX, state) && !isScrollToRight(deltaX, state);
    }
    function isScrollToTop(deltaY, state) {
        const totalHeight = state.table.getAllRowsHeight() - state.table.scenegraph.height;
        return totalHeight !== 0 && deltaY <= 0 && state.scroll.verticalBarPos < 1;
    }
    function isScrollToBottom(deltaY, state) {
        const sizeTolerance = state.table.options.customConfig?._disableColumnAndRowSizeRound ? 1 : 0;
        const totalHeight = state.table.getAllRowsHeight() - state.table.scenegraph.height;
        return totalHeight !== 0 && deltaY >= 0 && Math.abs(state.scroll.verticalBarPos - totalHeight) < 1 + sizeTolerance;
    }
    function isScrollToLeft(deltaX, state) {
        const totalWidth = state.table.getAllColsWidth() - state.table.scenegraph.width;
        return totalWidth !== 0 && deltaX <= 0 && state.scroll.horizontalBarPos < 1;
    }
    function isScrollToRight(deltaX, state) {
        const sizeTolerance = state.table.options.customConfig?._disableColumnAndRowSizeRound ? 1 : 0;
        const totalWidth = state.table.getAllColsWidth() - state.table.scenegraph.width;
        return totalWidth !== 0 && deltaX >= 0 && Math.abs(state.scroll.horizontalBarPos - totalWidth) < 1 + sizeTolerance;
    }
    class InertiaScroll {
        friction;
        lastTime;
        speedX;
        speedY;
        stateManager;
        runingId;
        scrollHandle;
        constructor(stateManager) {
            this.stateManager = stateManager;
        }
        setScrollHandle(scrollHandle) {
            this.scrollHandle = scrollHandle;
        }
        startInertia(speedX, speedY, friction) {
            this.lastTime = Date.now();
            this.speedX = speedX;
            this.speedY = speedY;
            this.friction = friction;
            if (!this.runingId) {
                this.runingId = requestAnimationFrame(this.inertia.bind(this));
            }
        }
        inertia() {
            const now = Date.now();
            const dffTime = now - this.lastTime;
            let stopped = true;
            const f = Math.pow(this.friction, dffTime / 16);
            const newSpeedX = f * this.speedX;
            const newSpeedY = f * this.speedY;
            let dx = 0;
            let dy = 0;
            if (Math.abs(newSpeedX) > 0.05) {
                stopped = false;
                dx = ((this.speedX + newSpeedX) / 2) * dffTime;
            }
            if (Math.abs(newSpeedY) > 0.05) {
                stopped = false;
                dy = ((this.speedY + newSpeedY) / 2) * dffTime;
            }
            this.scrollHandle?.(dx, dy);
            if (stopped) {
                this.runingId = null;
                return;
            }
            this.lastTime = now;
            this.speedX = newSpeedX;
            this.speedY = newSpeedY;
            this.runingId = requestAnimationFrame(this.inertia.bind(this));
        }
        endInertia() {
            cancelAnimationFrame(this.runingId);
            this.runingId = null;
        }
        isInertiaScrolling() {
            return !!this.runingId;
        }
    }

    function fireMoveColEventListeners(table, endMoveColSuccess, e) {
        if (endMoveColSuccess &&
            table.stateManager.columnMove?.colSource !== -1 &&
            table.stateManager.columnMove?.rowSource !== -1 &&
            table.stateManager.columnMove?.colTarget !== -1 &&
            table.stateManager.columnMove?.rowTarget !== -1) {
            if (table.hasListeners(TABLE_EVENT_TYPE.CHANGE_HEADER_POSITION)) {
                table.fireListeners(TABLE_EVENT_TYPE.CHANGE_HEADER_POSITION, {
                    target: { col: table.stateManager.columnMove.colTarget, row: table.stateManager.columnMove.rowTarget },
                    source: {
                        col: table.stateManager.columnMove.colSource,
                        row: table.stateManager.columnMove.rowSource
                    },
                    event: e
                });
            }
        }
        else if (!endMoveColSuccess) {
            if (table.hasListeners(TABLE_EVENT_TYPE.CHANGE_HEADER_POSITION_FAIL)) {
                table.fireListeners(TABLE_EVENT_TYPE.CHANGE_HEADER_POSITION_FAIL, {
                    target: { col: table.stateManager.columnMove.colTarget, row: table.stateManager.columnMove.rowTarget },
                    source: {
                        col: table.stateManager.columnMove.colSource,
                        row: table.stateManager.columnMove.rowSource
                    },
                    event: e
                });
            }
        }
    }

    function bindTableGroupListener(eventManager) {
        const table = eventManager.table;
        const stateManager = table.stateManager;
        table.scenegraph.tableGroup.addEventListener('pointermove', (e) => {
            const lastX = table.eventManager.LastPointerXY?.x ?? e.x;
            const lastY = table.eventManager.LastPointerXY?.y ?? e.y;
            table.eventManager.LastPointerXY = { x: e.x, y: e.y };
            if (eventManager.touchSetTimeout) {
                clearTimeout(eventManager.touchSetTimeout);
                eventManager.touchSetTimeout = undefined;
            }
            const eventArgsSet = getCellEventArgsSet(e);
            if (eventArgsSet.eventArgs && table.hasListeners(TABLE_EVENT_TYPE.MOUSEMOVE_TABLE)) {
                table.fireListeners(TABLE_EVENT_TYPE.MOUSEMOVE_TABLE, {
                    col: eventArgsSet.eventArgs.col,
                    row: eventArgsSet.eventArgs.row,
                    x: eventArgsSet.abstractPos.x,
                    y: eventArgsSet.abstractPos.y,
                    event: e.nativeEvent,
                    target: eventArgsSet?.eventArgs?.target,
                    mergeCellInfo: eventArgsSet.eventArgs?.mergeInfo
                });
            }
            if (stateManager.interactionState === InteractionState.grabing &&
                !table.editorManager?.editingEditor) {
                if (Math.abs(lastX - e.x) + Math.abs(lastY - e.y) >= 1) {
                    if (stateManager.isResizeCol() || stateManager.isResizeRow()) ;
                    else if (stateManager.isMoveCol()) {
                        eventManager.dealColumnMover(eventArgsSet);
                    }
                    else if (stateManager.isFillHandle()) {
                        eventManager.dealFillSelect(eventArgsSet, true);
                    }
                    else {
                        table.options.select?.disableDragSelect || eventManager.dealTableSelect(eventArgsSet, true);
                    }
                }
                return;
            }
            else if (!table.options.select?.disableDragSelect &&
                table.eventManager.isDraging &&
                stateManager.isSelecting() &&
                !table.editorManager?.editingEditor) {
                eventManager.dealTableSelect(eventArgsSet, true);
            }
            const cellGoup = e.path.find(node => node.role === 'cell');
            if (table.hasListeners(TABLE_EVENT_TYPE.MOUSELEAVE_CELL)) {
                if (table.stateManager.hover.cellPos.col !== -1 &&
                    table.stateManager.hover.cellPos.row !== -1 &&
                    (cellGoup?.col !== table.stateManager.hover.cellPos.col ||
                        cellGoup?.row !== table.stateManager.hover.cellPos.row)) {
                    table.fireListeners(TABLE_EVENT_TYPE.MOUSELEAVE_CELL, {
                        col: table.stateManager.hover.cellPos.col,
                        row: table.stateManager.hover.cellPos.row,
                        cellRange: table.getCellRangeRelativeRect({
                            col: table.stateManager.hover.cellPos.col,
                            row: table.stateManager.hover.cellPos.row
                        }),
                        scaleRatio: table.canvas.getBoundingClientRect().width / table.canvas.offsetWidth,
                        event: e.nativeEvent,
                        target: eventArgsSet?.eventArgs?.target
                    });
                }
            }
            if (table.hasListeners(TABLE_EVENT_TYPE.MOUSEENTER_CELL)) {
                if (cellGoup?.role === 'cell' &&
                    isValid$3(cellGoup.col) &&
                    isValid$3(cellGoup.row) &&
                    (cellGoup.col !== table.stateManager.hover.cellPos.col ||
                        cellGoup.row !== table.stateManager.hover.cellPos.row) &&
                    (cellGoup.col !== table.stateManager.hover.cellPosContainHeader?.col ||
                        cellGoup.row !== table.stateManager.hover.cellPosContainHeader?.row)) {
                    table.fireListeners(TABLE_EVENT_TYPE.MOUSEENTER_CELL, {
                        col: cellGoup.col,
                        row: cellGoup.row,
                        cellRange: table.getCellRangeRelativeRect({
                            col: cellGoup.col,
                            row: cellGoup.row
                        }),
                        scaleRatio: table.canvas.getBoundingClientRect().width / table.canvas.offsetWidth,
                        event: e.nativeEvent,
                        target: eventArgsSet?.eventArgs?.target,
                        mergeCellInfo: eventArgsSet.eventArgs?.mergeInfo
                    });
                }
            }
            eventManager.dealIconHover(eventArgsSet);
            eventManager.dealTableHover(eventArgsSet);
            if (table.theme.columnResize.visibleOnHover) {
                eventManager.checkColumnResize(eventArgsSet, true);
            }
            if (eventArgsSet.eventArgs && table.hasListeners(TABLE_EVENT_TYPE.MOUSEMOVE_CELL)) {
                let icon;
                let position;
                if (eventArgsSet.eventArgs?.target) {
                    const iconInfo = getIconAndPositionFromTarget(eventArgsSet.eventArgs?.target);
                    if (iconInfo) {
                        icon = iconInfo.icon;
                        position = iconInfo.position;
                    }
                }
                table.fireListeners(TABLE_EVENT_TYPE.MOUSEMOVE_CELL, {
                    col: eventArgsSet.eventArgs.col,
                    row: eventArgsSet.eventArgs.row,
                    x: eventArgsSet.abstractPos.x,
                    y: eventArgsSet.abstractPos.y,
                    event: e.nativeEvent,
                    targetIcon: icon
                        ? {
                            name: icon.name,
                            position: position,
                            funcType: icon.attribute.funcType
                        }
                        : undefined,
                    target: eventArgsSet?.eventArgs?.target,
                    mergeCellInfo: eventArgsSet.eventArgs?.mergeInfo
                });
            }
        });
        table.scenegraph.tableGroup.addEventListener('pointerout', (e) => {
            const eventArgsSet = getCellEventArgsSet(e);
            const cellGoup = eventArgsSet?.eventArgs?.target;
            if (cellGoup?.role === 'table') {
                eventManager.dealTableHover();
            }
        });
        table.scenegraph.tableGroup.addEventListener('pointerover', (e) => {
            const eventArgsSet = getCellEventArgsSet(e);
            const cellGoup = eventArgsSet?.eventArgs?.target;
            if (cellGoup &&
                table.hasListeners(TABLE_EVENT_TYPE.MOUSEOVER_CHART_SYMBOL) &&
                cellGoup.type === 'symbol') {
                const cellGroup = e.composedPath().find(p => p.roll === 'cell');
                if (cellGroup) {
                    const { col, row } = cellGroup;
                    const eventInfo = {
                        col,
                        row,
                        field: table.getHeaderField(col, row),
                        value: table.getCellValue(col, row),
                        dataValue: table.getCellOriginValue(col, row),
                        cellHeaderPaths: table.internalProps.layoutMap.getCellHeaderPaths(col, row),
                        title: table.getBodyColumnDefine(col, row).title,
                        cellRange: table.getCellRelativeRect(col, row),
                        event: e.nativeEvent,
                        sparkline: {
                            pointData: undefined
                        },
                        scaleRatio: table.canvas.getBoundingClientRect().width / table.canvas.offsetWidth,
                        target: eventArgsSet?.eventArgs?.target
                    };
                    table.fireListeners(TABLE_EVENT_TYPE.MOUSEOVER_CHART_SYMBOL, eventInfo);
                }
            }
        });
        table.scenegraph.tableGroup.addEventListener('pointerenter', (e) => {
            if ((table.theme.scrollStyle.horizontalVisible && table.theme.scrollStyle.horizontalVisible === 'focus') ||
                (!table.theme.scrollStyle.horizontalVisible && table.theme.scrollStyle.visible === 'focus')) {
                stateManager.showHorizontalScrollBar();
            }
            if ((table.theme.scrollStyle.verticalVisible && table.theme.scrollStyle.verticalVisible === 'focus') ||
                (!table.theme.scrollStyle.verticalVisible && table.theme.scrollStyle.visible === 'focus')) {
                stateManager.showVerticalScrollBar();
            }
            if (table.hasListeners(TABLE_EVENT_TYPE.MOUSEENTER_TABLE)) {
                table.fireListeners(TABLE_EVENT_TYPE.MOUSEENTER_TABLE, {
                    event: e.nativeEvent
                });
            }
        });
        table.scenegraph.tableGroup.addEventListener('pointerleave', (e) => {
            if (!stateManager.isResizeCol() &&
                !stateManager.isResizeRow() &&
                !stateManager.isMoveCol() &&
                !stateManager.isSelecting()) {
                stateManager.updateInteractionState(InteractionState.default);
                stateManager.updateCursor();
            }
            if ((table.theme.scrollStyle.horizontalVisible && table.theme.scrollStyle.horizontalVisible === 'focus') ||
                (!table.theme.scrollStyle.horizontalVisible && table.theme.scrollStyle.visible === 'focus')) {
                stateManager.hideHorizontalScrollBar();
            }
            if ((table.theme.scrollStyle.verticalVisible && table.theme.scrollStyle.verticalVisible === 'focus') ||
                (!table.theme.scrollStyle.verticalVisible && table.theme.scrollStyle.visible === 'focus')) {
                stateManager.hideVerticalScrollBar();
            }
            if (table.hasListeners(TABLE_EVENT_TYPE.MOUSELEAVE_CELL)) {
                if (table.stateManager.hover.cellPos.col !== -1 && table.stateManager.hover.cellPos.row !== -1) {
                    table.fireListeners(TABLE_EVENT_TYPE.MOUSELEAVE_CELL, {
                        col: table.stateManager.hover.cellPos.col,
                        row: table.stateManager.hover.cellPos.row,
                        cellRange: table.getCellRangeRelativeRect({
                            col: table.stateManager.hover.cellPos.col,
                            row: table.stateManager.hover.cellPos.row
                        }),
                        scaleRatio: table.canvas.getBoundingClientRect().width / table.canvas.offsetWidth,
                        event: e.nativeEvent,
                        target: undefined
                    });
                }
            }
            eventManager.dealTableHover();
            const target = e.target;
            if (target && !target.isDescendantsOf(table.scenegraph.tableGroup)) {
                table.fireListeners(TABLE_EVENT_TYPE.MOUSELEAVE_TABLE, {
                    event: e.nativeEvent
                });
            }
        });
        table.scenegraph.tableGroup.addEventListener('pointerdown', (e) => {
            if (table.hasListeners(TABLE_EVENT_TYPE.MOUSEDOWN_TABLE)) {
                table.fireListeners(TABLE_EVENT_TYPE.MOUSEDOWN_TABLE, {
                    event: e.nativeEvent
                });
            }
            table.eventManager.isDown = true;
            table.eventManager.LastBodyPointerXY = { x: e.x, y: e.y };
            table.eventManager.LastPointerXY = { x: e.x, y: e.y };
            if (e.button !== 0) {
                return;
            }
            const eventArgsSet = getCellEventArgsSet(e);
            eventManager.downIcon = undefined;
            if (stateManager.interactionState !== InteractionState.default) {
                return;
            }
            if (table.isPivotChart() && eventArgsSet?.eventArgs?.target.type !== 'chart') {
                table.scenegraph.updateChartState(null);
            }
            if (eventArgsSet.eventArgs?.target !== stateManager.residentHoverIcon?.icon) {
                stateManager.hideMenu();
            }
            if (eventArgsSet?.eventArgs?.target.type === 'chart') {
                return;
            }
            const isCompleteEdit = table.editorManager?.completeEdit(e.nativeEvent);
            getPromiseValue(isCompleteEdit, isCompleteEdit => {
                if (isCompleteEdit === false) {
                    return;
                }
                const hitIcon = eventArgsSet?.eventArgs?.target?.role?.startsWith('icon')
                    ? eventArgsSet.eventArgs.target
                    : e.target.role?.startsWith('icon')
                        ? e.target
                        : undefined;
                eventManager.downIcon = hitIcon;
                if (!hitIcon || hitIcon.attribute.interactive === false) {
                    if (eventManager.cellIsHeaderCheck(eventArgsSet)) {
                        return;
                    }
                    if (e.pointerType === 'touch') {
                        eventManager.touchEnd = false;
                        eventManager.touchSetTimeout = setTimeout(() => {
                            eventManager.isTouchdown = false;
                            eventManager.isLongTouch = true;
                            if (!eventManager.touchEnd &&
                                (eventManager.checkColumnResize(eventArgsSet, true) || eventManager.checkRowResize(eventArgsSet, true))) {
                                stateManager.updateInteractionState(InteractionState.grabing);
                                return;
                            }
                            if (!eventManager.touchEnd && eventManager.checkColumnMover(eventArgsSet)) {
                                stateManager.updateInteractionState(InteractionState.grabing);
                                return;
                            }
                            if (eventManager.dealTableSelect(eventArgsSet) && !eventManager.touchEnd) {
                                stateManager.updateInteractionState(InteractionState.grabing);
                            }
                        }, 500);
                        if (table.hasListeners(TABLE_EVENT_TYPE.MOUSEENTER_CELL)) {
                            const cellGoup = e.path.find(node => node.role === 'cell');
                            if (cellGoup?.role === 'cell' &&
                                isValid$3(cellGoup.col) &&
                                isValid$3(cellGoup.row) &&
                                (cellGoup.col !== table.stateManager.hover.cellPos.col ||
                                    cellGoup.row !== table.stateManager.hover.cellPos.row) &&
                                (cellGoup.col !== table.stateManager.hover.cellPosContainHeader?.col ||
                                    cellGoup.row !== table.stateManager.hover.cellPosContainHeader?.row)) {
                                table.fireListeners(TABLE_EVENT_TYPE.MOUSEENTER_CELL, {
                                    col: cellGoup.col,
                                    row: cellGoup.row,
                                    cellRange: table.getCellRangeRelativeRect({
                                        col: cellGoup.col,
                                        row: cellGoup.row
                                    }),
                                    scaleRatio: table.canvas.getBoundingClientRect().width / table.canvas.offsetWidth,
                                    event: e.nativeEvent,
                                    target: eventArgsSet?.eventArgs?.target,
                                    mergeCellInfo: eventArgsSet.eventArgs?.mergeInfo
                                });
                            }
                        }
                        eventManager.dealTableHover(eventArgsSet);
                    }
                    else {
                        if (!eventManager.checkCellFillhandle(eventArgsSet) &&
                            (eventManager.checkColumnResize(eventArgsSet, true) || eventManager.checkRowResize(eventArgsSet, true))) {
                            table.scenegraph.updateChartState(null);
                            stateManager.updateInteractionState(InteractionState.grabing);
                            return;
                        }
                        if (eventManager.checkColumnMover(eventArgsSet)) {
                            stateManager.updateInteractionState(InteractionState.grabing);
                            return;
                        }
                        if (eventManager.checkCellFillhandle(eventArgsSet, true) && eventManager.dealFillSelect(eventArgsSet)) {
                            stateManager.updateInteractionState(InteractionState.grabing);
                            return;
                        }
                        if (eventManager.dealTableSelect(eventArgsSet)) {
                            stateManager.updateInteractionState(InteractionState.grabing);
                        }
                    }
                }
                else if (hitIcon.attribute.funcType === IconFuncTypeEnum.dragReorder) {
                    stateManager.startMoveCol(eventArgsSet.eventArgs.col, eventArgsSet.eventArgs.row, eventArgsSet.abstractPos.x, eventArgsSet.abstractPos.y, eventArgsSet.eventArgs?.event?.nativeEvent);
                    stateManager.updateInteractionState(InteractionState.grabing);
                }
                if (table.hasListeners(TABLE_EVENT_TYPE.MOUSEDOWN_CELL)) {
                    const eventArgsSet = getCellEventArgsSet(e);
                    if (eventArgsSet.eventArgs) {
                        table.fireListeners(TABLE_EVENT_TYPE.MOUSEDOWN_CELL, {
                            col: eventArgsSet.eventArgs.col,
                            row: eventArgsSet.eventArgs.row,
                            event: e.nativeEvent,
                            target: eventArgsSet?.eventArgs?.target,
                            mergeCellInfo: eventArgsSet.eventArgs.mergeInfo
                        });
                    }
                }
            });
        });
        table.scenegraph.tableGroup.addEventListener('pointerup', (e) => {
            if (e.button !== 0) {
                return;
            }
            if (stateManager.interactionState === 'grabing') {
                stateManager.updateInteractionState(InteractionState.default);
                if (stateManager.isResizeCol()) {
                    endResizeCol(table);
                }
                else if (stateManager.isResizeRow()) {
                    endResizeRow(table);
                }
                else if (stateManager.isMoveCol()) {
                    const endMoveColSuccess = table.stateManager.endMoveCol();
                    fireMoveColEventListeners(table, endMoveColSuccess, e.nativeEvent);
                }
                else if (stateManager.isSelecting()) {
                    table.stateManager.endSelectCells();
                    if (table.stateManager.isFillHandle()) {
                        table.stateManager.endFillSelect();
                    }
                    const eventArgsSet = getCellEventArgsSet(e);
                    if (table.eventManager.isDraging &&
                        eventArgsSet.eventArgs &&
                        table.hasListeners(TABLE_EVENT_TYPE.DRAG_SELECT_END)) {
                        const cellsEvent = {
                            event: e.nativeEvent,
                            cells: [],
                            col: eventArgsSet.eventArgs.target.col,
                            row: eventArgsSet.eventArgs.target.row,
                            scaleRatio: table.canvas.getBoundingClientRect().width / table.canvas.offsetWidth,
                            target: eventArgsSet?.eventArgs?.target,
                            mergeCellInfo: eventArgsSet.eventArgs?.mergeInfo
                        };
                        cellsEvent.cells = table.getSelectedCellInfos();
                        table.fireListeners(TABLE_EVENT_TYPE.DRAG_SELECT_END, cellsEvent);
                    }
                }
            }
            else if (stateManager.interactionState === InteractionState.scrolling) {
                stateManager.updateInteractionState(InteractionState.default);
            }
            if (table.hasListeners(TABLE_EVENT_TYPE.MOUSEUP_CELL)) {
                const eventArgsSet = getCellEventArgsSet(e);
                if (eventArgsSet.eventArgs) {
                    table.fireListeners(TABLE_EVENT_TYPE.MOUSEUP_CELL, {
                        col: eventArgsSet.eventArgs.col,
                        row: eventArgsSet.eventArgs.row,
                        event: e.nativeEvent,
                        target: eventArgsSet?.eventArgs?.target,
                        mergeCellInfo: eventArgsSet.eventArgs?.mergeInfo
                    });
                }
            }
            setTimeout(() => {
                eventManager.isTouchdown = false;
                eventManager.isTouchMove = false;
                eventManager.isDraging = false;
                eventManager.touchMovePoints = [];
            }, 0);
        });
        table.scenegraph.tableGroup.addEventListener('rightdown', (e) => {
            const eventArgsSet = getCellEventArgsSet(e);
            if (eventArgsSet.eventArgs) {
                stateManager.triggerContextMenu(eventArgsSet.eventArgs.col, eventArgsSet.eventArgs.row, eventArgsSet.abstractPos.x, eventArgsSet.abstractPos.y);
                const { col, row } = eventArgsSet.eventArgs;
                if (table.hasListeners(TABLE_EVENT_TYPE.CONTEXTMENU_CELL)) {
                    const cellInfo = table.getCellInfo(col, row);
                    let icon;
                    let position;
                    if (eventArgsSet.eventArgs?.target) {
                        const iconInfo = getIconAndPositionFromTarget(eventArgsSet.eventArgs?.target);
                        if (iconInfo) {
                            icon = iconInfo.icon;
                            position = iconInfo.position;
                        }
                    }
                    const cellsEvent = {
                        ...cellInfo,
                        event: e.nativeEvent,
                        cells: [],
                        targetIcon: icon
                            ? {
                                name: icon.name,
                                position: position,
                                funcType: icon.attribute.funcType
                            }
                            : undefined,
                        target: eventArgsSet?.eventArgs?.target,
                        mergeCellInfo: eventArgsSet.eventArgs?.mergeInfo
                    };
                    if (cellInRanges(table.stateManager.select.ranges, col, row)) {
                        cellsEvent.cells = table.getSelectedCellInfos();
                    }
                    else {
                        cellsEvent.cells = [[cellInfo]];
                    }
                    table.fireListeners(TABLE_EVENT_TYPE.CONTEXTMENU_CELL, cellsEvent);
                }
            }
        });
        table.scenegraph.tableGroup.addEventListener('pointertap', (e) => {
            if (table.stateManager.columnResize.resizing) {
                return;
            }
            const eventArgsSet = getCellEventArgsSet(e);
            if (!eventManager.isTouchMove &&
                e.button === 0 &&
                eventArgsSet.eventArgs &&
                table.hasListeners(TABLE_EVENT_TYPE.CLICK_CELL)) {
                const { col, row } = eventArgsSet.eventArgs;
                const cellInfo = table.getCellInfo(col, row);
                let icon;
                let position;
                if (eventArgsSet.eventArgs?.target) {
                    const iconInfo = getIconAndPositionFromTarget(eventArgsSet.eventArgs?.target);
                    if (iconInfo) {
                        icon = iconInfo.icon;
                        position = iconInfo.position;
                    }
                }
                const cellsEvent = {
                    ...cellInfo,
                    event: e.nativeEvent,
                    federatedEvent: e,
                    cells: [],
                    targetIcon: icon
                        ? {
                            name: icon.name,
                            position: position,
                            funcType: icon.attribute.funcType
                        }
                        : undefined,
                    target: eventArgsSet?.eventArgs?.target,
                    mergeCellInfo: eventArgsSet.eventArgs?.mergeInfo
                };
                table.fireListeners(TABLE_EVENT_TYPE.CLICK_CELL, cellsEvent);
            }
            if (table.stateManager.columnResize.resizing || table.stateManager.columnMove.moving) {
                return;
            }
            eventManager.dealIconClick(e, eventArgsSet);
            if (!eventArgsSet?.eventArgs) {
                return;
            }
            if (eventManager.touchSetTimeout) {
                if (e.pointerType === 'touch') {
                    const eventArgsSet = getCellEventArgsSet(e);
                    if (eventManager.touchSetTimeout) {
                        clearTimeout(eventManager.touchSetTimeout);
                        const isHasSelected = !!stateManager.select.ranges?.length;
                        eventManager.dealTableSelect(eventArgsSet);
                        stateManager.endSelectCells(true, isHasSelected);
                        eventManager.touchSetTimeout = undefined;
                    }
                }
            }
        });
        table.scenegraph.stage.addEventListener('pointerdown', (e) => {
            const eventArgsSet = getCellEventArgsSet(e);
            if (!eventArgsSet.eventArgs?.target ||
                eventArgsSet.eventArgs?.target !== stateManager.residentHoverIcon?.icon) {
                stateManager.hideMenu();
            }
            const isCompleteEdit = table.editorManager?.completeEdit(e.nativeEvent);
            getPromiseValue(isCompleteEdit, isCompleteEdit => {
                if (isCompleteEdit === false) {
                    return;
                }
                const hitIcon = e.target.role?.startsWith('icon') ? e.target : undefined;
                eventManager.downIcon = hitIcon;
                if (e.pointerType !== 'touch' &&
                    !hitIcon &&
                    !eventManager.checkCellFillhandle(eventArgsSet) &&
                    !stateManager.columnResize.resizing &&
                    eventManager.checkColumnResize(eventArgsSet, true)) {
                    table.scenegraph.updateChartState(null);
                    stateManager.updateInteractionState(InteractionState.grabing);
                    const { eventArgs } = eventArgsSet;
                    if (!eventArgs?.targetCell) {
                        const cell = table.getCellAt(eventArgsSet.abstractPos.x - table.theme.columnResize.resizeHotSpotSize / 2, eventArgsSet.abstractPos.y);
                        if (cell) {
                            if (table.hasListeners(TABLE_EVENT_TYPE.MOUSEDOWN_TABLE)) {
                                table.fireListeners(TABLE_EVENT_TYPE.MOUSEDOWN_TABLE, {
                                    event: e.nativeEvent
                                });
                            }
                        }
                    }
                    return;
                }
            });
        });
        table.scenegraph.stage.addEventListener('pointerup', (e) => {
            if (stateManager.interactionState === 'grabing') {
                stateManager.updateInteractionState(InteractionState.default);
                if (stateManager.isResizeCol()) {
                    endResizeCol(table);
                }
                else if (stateManager.isResizeRow()) {
                    endResizeRow(table);
                }
            }
        });
        table.scenegraph.stage.addEventListener('pointertap', (e) => {
            const target = e.target;
            if (!table.eventManager.isDraging &&
                target &&
                (target.isDescendantsOf(table.scenegraph.stage) || target.stage === target) &&
                !target.isDescendantsOf(table.scenegraph.tableGroup)) {
                stateManager.updateInteractionState(InteractionState.default);
                eventManager.dealTableHover();
                const isHasSelected = !!stateManager.select.ranges?.length;
                if (table.options.select?.blankAreaClickDeselect ?? true) {
                    eventManager.dealTableSelect();
                }
                stateManager.endSelectCells(true, isHasSelected);
                stateManager.updateCursor();
                table.scenegraph.updateChartState(null);
            }
            else if (table.eventManager.isDraging && stateManager.isSelecting()) {
                stateManager.endSelectCells();
            }
        });
        table.scenegraph.stage.addEventListener('pointermove', (e) => {
            const eventArgsSet = getCellEventArgsSet(e);
            if (stateManager.isResizeCol() || eventManager.checkColumnResize(eventArgsSet)) {
                if (table.stateManager.select && eventManager.checkCellFillhandle(eventArgsSet)) {
                    stateManager.updateCursor('crosshair');
                }
                else {
                    stateManager.updateCursor('col-resize');
                }
            }
            else if (stateManager.isResizeRow() || eventManager.checkRowResize(eventArgsSet)) {
                if (table.stateManager.select && eventManager.checkCellFillhandle(eventArgsSet)) {
                    stateManager.updateCursor('crosshair');
                }
                else {
                    stateManager.updateCursor('row-resize');
                }
            }
            else if (stateManager.isMoveCol()) ;
            else {
                stateManager.updateCursor();
            }
        });
        table.scenegraph.tableGroup.addEventListener('checkbox_state_change', (e) => {
            const eventArgsSet = getCellEventArgsSet(e);
            const { col, row } = eventArgsSet.eventArgs;
            const cellInfo = table.getCellInfo(col, row);
            const mergeRange = getCellMergeInfo(table, col, row);
            if (mergeRange) {
                for (let col = mergeRange.start.col; col <= mergeRange.end.col; col++) {
                    for (let row = mergeRange.start.row; row <= mergeRange.end.row; row++) {
                        const cellGroup = table.scenegraph.getCell(col, row);
                        cellGroup.forEachChildren((checkbox) => {
                            if (checkbox.name === 'checkbox') {
                                checkbox.setAttributes({
                                    checked: e.target.attribute.checked,
                                    indeterminate: e.target.attribute.indeterminate
                                });
                            }
                        });
                    }
                }
            }
            const cellsEvent = {
                ...cellInfo,
                event: e.nativeEvent,
                target: eventArgsSet?.eventArgs?.target,
                mergeCellInfo: eventArgsSet?.eventArgs?.mergeInfo,
                checked: e.detail.checked
            };
            if (table.isHeader(col, row)) {
                table.stateManager.setHeaderCheckedState(cellInfo.field, e.detail.checked);
                const cellType = table.getCellType(col, row);
                if (cellType === 'checkbox') {
                    table.scenegraph.updateCheckboxCellState(col, row, e.detail.checked);
                }
            }
            else {
                table.stateManager.setCheckedState(col, row, cellInfo.field, e.detail.checked);
                const cellType = table.getCellType(col, row);
                if (cellType === 'checkbox') {
                    const oldHeaderCheckedState = table.stateManager.headerCheckedState[cellInfo.field];
                    const newHeaderCheckedState = table.stateManager.updateHeaderCheckedState(cellInfo.field, col, row);
                    if (oldHeaderCheckedState !== newHeaderCheckedState) {
                        table.scenegraph.updateHeaderCheckboxCellState(col, row, newHeaderCheckedState);
                    }
                }
            }
            table.fireListeners(TABLE_EVENT_TYPE.CHECKBOX_STATE_CHANGE, cellsEvent);
            table.scenegraph.updateNextFrame();
        });
        table.scenegraph.tableGroup.addEventListener('radio_checked', (e) => {
            const eventArgsSet = getCellEventArgsSet(e);
            const { col, row, target } = eventArgsSet.eventArgs;
            const cellInfo = table.getCellInfo(col, row);
            const indexInCell = regIndexReg.exec(target.id)?.[1];
            const mergeRange = getCellMergeInfo(table, col, row);
            if (mergeRange) {
                for (let col = mergeRange.start.col; col <= mergeRange.end.col; col++) {
                    for (let row = mergeRange.start.row; row <= mergeRange.end.row; row++) {
                        const cellGroup = table.scenegraph.getCell(col, row);
                        cellGroup.forEachChildren((radio) => {
                            if (radio.name === 'radio' && radio.id === target.id) {
                                radio.setAttributes({
                                    checked: true
                                });
                            }
                        });
                    }
                }
            }
            const define = table.getBodyColumnDefine(col, row);
            const radioCheckType = define.radioCheckType || 'column';
            if (radioCheckType === 'cell') {
                if (mergeRange) {
                    for (let col = mergeRange.start.col; col <= mergeRange.end.col; col++) {
                        for (let row = mergeRange.start.row; row <= mergeRange.end.row; row++) {
                            const cellGroup = table.scenegraph.getCell(col, row);
                            cellGroup.forEachChildren((radio) => {
                                if (radio.name === 'radio' && radio.id !== target.id) {
                                    radio.setAttributes({
                                        checked: false
                                    });
                                }
                            });
                        }
                    }
                }
                else {
                    const cellGroup = table.scenegraph.getCell(col, row);
                    cellGroup.forEachChildren((radio) => {
                        if (radio.name === 'radio' && radio.id !== target.id) {
                            radio.setAttributes({
                                checked: false
                            });
                        }
                    });
                }
            }
            else if (radioCheckType === 'column') {
                const columnGroup = table.scenegraph.getColGroup(col);
                columnGroup.forEachChildren((cellGroup) => {
                    cellGroup.forEachChildren((radio) => {
                        if (radio.name === 'radio' && radio.id !== target.id) {
                            radio.setAttributes({
                                checked: false
                            });
                        }
                    });
                });
            }
            const radioIndexInCell = indexInCell ? Number(indexInCell) : undefined;
            table.stateManager.setRadioState(col, row, cellInfo.field, radioCheckType, radioIndexInCell);
            const cellsEvent = {
                ...cellInfo,
                event: e.nativeEvent,
                target: eventArgsSet?.eventArgs?.target,
                mergeCellInfo: eventArgsSet?.eventArgs?.mergeInfo,
                radioIndexInCell
            };
            table.fireListeners(TABLE_EVENT_TYPE.RADIO_STATE_CHANGE, cellsEvent);
            table.scenegraph.updateNextFrame();
        });
        table.scenegraph.tableGroup.addEventListener('switch_state_change', (e) => {
            const eventArgsSet = getCellEventArgsSet(e);
            const { col, row, target } = eventArgsSet.eventArgs;
            const cellInfo = table.getCellInfo(col, row);
            const mergeRange = getCellMergeInfo(table, col, row);
            if (mergeRange) {
                for (let col = mergeRange.start.col; col <= mergeRange.end.col; col++) {
                    for (let row = mergeRange.start.row; row <= mergeRange.end.row; row++) {
                        const cellGroup = table.scenegraph.getCell(col, row);
                        cellGroup.forEachChildren((switchComponent) => {
                            if (switchComponent.name === 'switch') {
                                switchComponent.setAttributes({
                                    checked: e.target.attribute.checked
                                });
                            }
                        });
                    }
                }
            }
            const cellsEvent = {
                ...cellInfo,
                event: e.nativeEvent,
                target: eventArgsSet?.eventArgs?.target,
                mergeCellInfo: eventArgsSet?.eventArgs?.mergeInfo,
                checked: e.detail.checked
            };
            table.stateManager.setCheckedState(col, row, cellInfo.field, e.detail.checked);
            table.fireListeners(TABLE_EVENT_TYPE.SWITCH_STATE_CHANGE, cellsEvent);
            table.scenegraph.updateNextFrame();
        });
        table.scenegraph.stage.addEventListener('wheel', (e) => {
            const legend = e.path.find(node => node.name === 'legend');
            if (!legend) {
                table.editorManager?.completeEdit();
                if (table.eventManager._enableTableScroll) {
                    handleWhell(e, stateManager);
                }
            }
        });
    }
    function bindGesture(eventManager) {
        const table = eventManager.table;
        eventManager.gesture = new Gesture(table.scenegraph.tableGroup, {
            tap: {
                interval: 300
            }
        });
        eventManager.gesture.on('doubletap', e => {
            dblclickHandler(e, table);
        });
    }
    function endResizeCol(table) {
        table.stateManager.endResizeCol();
        const columns = [];
        for (let col = 0; col < table.colCount; col++) {
            columns.push(table.getColWidth(col));
        }
        table.fireListeners(TABLE_EVENT_TYPE.RESIZE_COLUMN_END, {
            col: table.stateManager.columnResize.col,
            colWidths: columns
        });
    }
    function endResizeRow(table) {
        table.stateManager.endResizeRow();
        table.fireListeners(TABLE_EVENT_TYPE.RESIZE_ROW_END, {
            row: table.stateManager.rowResize.row,
            rowHeight: table.getRowHeight(table.stateManager.rowResize.row)
        });
    }
    function dblclickHandler(e, table) {
        const eventArgsSet = getCellEventArgsSet(e);
        let col = -1;
        let row = -1;
        if (eventArgsSet.eventArgs) {
            col = eventArgsSet.eventArgs.col;
            row = eventArgsSet.eventArgs.row;
        }
        const value = table.getCellValue(col, row);
        const bounds = eventArgsSet.eventArgs?.targetCell?.globalAABBBounds;
        bounds &&
            table.internalProps.focusControl.setFocusRect(new Rect$1(bounds.x1 + table.scrollLeft, bounds.y1 + table.scrollTop, bounds.x2 - bounds.x1, bounds.y2 - bounds.y1), value);
        if (table.hasListeners(TABLE_EVENT_TYPE.DBLCLICK_CELL)) {
            const cellInfo = table.getCellInfo(col, row);
            let icon;
            let position;
            if (eventArgsSet.eventArgs?.target) {
                const iconInfo = getIconAndPositionFromTarget(eventArgsSet.eventArgs?.target);
                if (iconInfo) {
                    icon = iconInfo.icon;
                    position = iconInfo.position;
                }
            }
            const cellsEvent = {
                ...cellInfo,
                event: e.nativeEvent,
                federatedEvent: e,
                cells: [],
                targetIcon: icon
                    ? {
                        name: icon.name,
                        position: position,
                        funcType: icon.attribute.funcType
                    }
                    : undefined,
                target: eventArgsSet?.eventArgs?.target,
                mergeCellInfo: eventArgsSet?.eventArgs?.mergeInfo
            };
            table.fireListeners(TABLE_EVENT_TYPE.DBLCLICK_CELL, cellsEvent);
        }
    }

    function bindScrollBarListener(eventManager) {
        const table = eventManager.table;
        const stateManager = table.stateManager;
        const scenegraph = table.scenegraph;
        scenegraph.component.vScrollBar.addEventListener('pointerover', (e) => {
            stateManager.showVerticalScrollBar();
        });
        scenegraph.component.hScrollBar.addEventListener('pointerover', (e) => {
            stateManager.showHorizontalScrollBar();
        });
        scenegraph.component.vScrollBar.addEventListener('pointerout', (e) => {
            if (stateManager.interactionState === InteractionState.scrolling) {
                return;
            }
            stateManager.hideVerticalScrollBar();
        });
        scenegraph.component.hScrollBar.addEventListener('pointerout', (e) => {
            if (stateManager.interactionState === InteractionState.scrolling) {
                return;
            }
            stateManager.hideHorizontalScrollBar();
        });
        scenegraph.component.vScrollBar.addEventListener('pointermove', (e) => {
            scenegraph.table.stateManager.updateCursor('default');
            e.stopPropagation();
        });
        scenegraph.component.vScrollBar.addEventListener('pointerdown', (e) => {
            e.stopPropagation();
            if (scenegraph.table.hasListeners(TABLE_EVENT_TYPE.MOUSEDOWN_TABLE)) {
                scenegraph.table.fireListeners(TABLE_EVENT_TYPE.MOUSEDOWN_TABLE, {
                    event: e.nativeEvent
                });
            }
        });
        scenegraph.component.vScrollBar.addEventListener('scrollDown', (e) => {
            scenegraph.table.eventManager.LastBodyPointerXY = { x: e.x, y: e.y };
            scenegraph.table.eventManager.isDown = true;
            if (stateManager.interactionState !== InteractionState.scrolling) {
                stateManager.updateInteractionState(InteractionState.scrolling);
            }
            scenegraph.table.stateManager.hideMenu();
            scenegraph.table.editorManager?.completeEdit();
            if (scenegraph.table.hasListeners(TABLE_EVENT_TYPE.MOUSEDOWN_TABLE)) {
                scenegraph.table.fireListeners(TABLE_EVENT_TYPE.MOUSEDOWN_TABLE, {
                    event: e.nativeEvent
                });
            }
        });
        scenegraph.component.vScrollBar.addEventListener('pointerup', () => {
            stateManager.fastScrolling = false;
            scenegraph.table.eventManager.isDraging = false;
            if (stateManager.interactionState === InteractionState.scrolling) {
                stateManager.updateInteractionState(InteractionState.default);
            }
        });
        scenegraph.component.vScrollBar.addEventListener('pointerupoutside', () => {
            stateManager.fastScrolling = false;
            if (stateManager.interactionState === InteractionState.scrolling) {
                stateManager.updateInteractionState(InteractionState.default);
            }
        });
        scenegraph.component.vScrollBar.addEventListener('scrollUp', (e) => {
            scenegraph.table.eventManager.isDraging = false;
        });
        scenegraph.component.hScrollBar.addEventListener('pointermove', (e) => {
            scenegraph.table.stateManager.updateCursor('default');
            e.stopPropagation();
        });
        scenegraph.component.hScrollBar.addEventListener('pointerdown', (e) => {
            e.stopPropagation();
            if (scenegraph.table.hasListeners(TABLE_EVENT_TYPE.MOUSEDOWN_TABLE)) {
                scenegraph.table.fireListeners(TABLE_EVENT_TYPE.MOUSEDOWN_TABLE, {
                    event: e.nativeEvent
                });
            }
        });
        scenegraph.component.hScrollBar.addEventListener('scrollDown', (e) => {
            scenegraph.table.eventManager.LastBodyPointerXY = { x: e.x, y: e.y };
            scenegraph.table.eventManager.isDown = true;
            if (stateManager.interactionState !== InteractionState.scrolling) {
                stateManager.updateInteractionState(InteractionState.scrolling);
            }
            scenegraph.table.stateManager.hideMenu();
            scenegraph.table.editorManager?.completeEdit();
            if (scenegraph.table.hasListeners(TABLE_EVENT_TYPE.MOUSEDOWN_TABLE)) {
                scenegraph.table.fireListeners(TABLE_EVENT_TYPE.MOUSEDOWN_TABLE, {
                    event: e.nativeEvent
                });
            }
        });
        scenegraph.component.hScrollBar.addEventListener('pointerup', () => {
            stateManager.fastScrolling = false;
            scenegraph.table.eventManager.isDraging = false;
            if (stateManager.interactionState === InteractionState.scrolling) {
                stateManager.updateInteractionState(InteractionState.default);
            }
        });
        scenegraph.component.hScrollBar.addEventListener('pointerupoutside', () => {
            stateManager.fastScrolling = false;
            if (stateManager.interactionState === InteractionState.scrolling) {
                stateManager.updateInteractionState(InteractionState.default);
            }
        });
        scenegraph.component.hScrollBar.addEventListener('scrollUp', (e) => {
            scenegraph.table.eventManager.isDraging = false;
        });
        const throttleVerticalWheel = throttle(stateManager.updateVerticalScrollBar, 20);
        const throttleHorizontalWheel = throttle(stateManager.updateHorizontalScrollBar, 20);
        scenegraph.component.vScrollBar.addEventListener('scrollDrag', (e) => {
            if (scenegraph.table.eventManager.isDown) {
                scenegraph.table.eventManager.isDraging = true;
            }
            stateManager.fastScrolling = true;
            if (stateManager.interactionState !== InteractionState.scrolling) {
                stateManager.updateInteractionState(InteractionState.scrolling);
            }
            const ratio = e.detail.value[0] / (1 - e.detail.value[1] + e.detail.value[0]);
            throttleVerticalWheel(ratio, e);
        });
        scenegraph.component.hScrollBar.addEventListener('scrollDrag', (e) => {
            if (scenegraph.table.eventManager.isDown) {
                scenegraph.table.eventManager.isDraging = true;
            }
            stateManager.fastScrolling = true;
            if (stateManager.interactionState !== InteractionState.scrolling) {
                stateManager.updateInteractionState(InteractionState.scrolling);
            }
            const ratio = e.detail.value[0] / (1 - e.detail.value[1] + e.detail.value[0]);
            throttleHorizontalWheel(ratio);
        });
    }

    let defaultPixelRatio = 1;
    function getPixelRatio() {
        if (isNode) {
            defaultPixelRatio = 1;
        }
        else {
            defaultPixelRatio = Math.ceil(window.devicePixelRatio || 1);
            if (defaultPixelRatio > 1 && defaultPixelRatio % 2 !== 0) {
                defaultPixelRatio += 1;
            }
        }
        return defaultPixelRatio;
    }
    getPixelRatio();

    function bindContainerDomListener(eventManager) {
        const table = eventManager.table;
        const stateManager = table.stateManager;
        const handler = table.internalProps.handler;
        handler.on(table.getElement(), 'blur', (e) => {
            eventManager.dealTableHover();
        });
        handler.on(table.getElement(), 'keydown', (e) => {
            const beforeKeydownEvent = {
                keyCode: e.keyCode ?? e.which,
                code: e.code,
                event: e
            };
            table.fireListeners(TABLE_EVENT_TYPE.BEFORE_KEYDOWN, beforeKeydownEvent);
            if (e.key === 'a' && (e.ctrlKey || e.metaKey)) {
                if (table.keyboardOptions?.selectAllOnCtrlA) {
                    e.preventDefault();
                    eventManager.deelTableSelectAll();
                }
            }
            else if (stateManager.select.cellPos.col >= 0 &&
                stateManager.select.cellPos.row >= 0 &&
                (e.key === 'ArrowUp' || e.key === 'ArrowDown' || e.key === 'ArrowLeft' || e.key === 'ArrowRight')) {
                if ((!(table.options.keyboardOptions?.moveEditCellOnArrowKeys ?? false) &&
                    table.editorManager?.editingEditor) ||
                    table.options.keyboardOptions?.moveSelectedCellOnArrowKeys === false) {
                    return;
                }
                e.preventDefault();
                e.stopPropagation();
                let targetCol;
                let targetRow;
                if (e.key === 'ArrowUp') {
                    if (e.ctrlKey || e.metaKey) {
                        targetCol = stateManager.select.cellPos.col;
                        targetRow = 0;
                    }
                    else if (e.shiftKey) {
                        targetCol = stateManager.select.cellPos.col;
                        targetRow = Math.min(table.rowCount - 1, Math.max(0, stateManager.select.cellPos.row - 1));
                    }
                    else {
                        targetCol = stateManager.select.cellPos.col;
                        targetRow = Math.min(table.rowCount - 1, Math.max(0, stateManager.select.cellPos.row - 1));
                    }
                }
                else if (e.key === 'ArrowDown') {
                    if (e.ctrlKey || e.metaKey) {
                        targetCol = stateManager.select.cellPos.col;
                        targetRow = table.rowCount - 1;
                    }
                    else if (e.shiftKey) {
                        targetCol = stateManager.select.cellPos.col;
                        targetRow = Math.min(table.rowCount - 1, Math.max(0, stateManager.select.cellPos.row + 1));
                    }
                    else {
                        targetCol = stateManager.select.cellPos.col;
                        targetRow = Math.min(table.rowCount - 1, Math.max(0, stateManager.select.cellPos.row + 1));
                    }
                }
                else if (e.key === 'ArrowLeft') {
                    if (e.ctrlKey || e.metaKey) {
                        targetCol = 0;
                        targetRow = stateManager.select.cellPos.row;
                    }
                    else if (e.shiftKey) {
                        targetRow = stateManager.select.cellPos.row;
                        targetCol = Math.min(table.colCount - 1, Math.max(0, stateManager.select.cellPos.col - 1));
                    }
                    else {
                        targetRow = stateManager.select.cellPos.row;
                        targetCol = Math.min(table.colCount - 1, Math.max(0, stateManager.select.cellPos.col - 1));
                    }
                }
                else if (e.key === 'ArrowRight') {
                    if (e.ctrlKey || e.metaKey) {
                        targetCol = table.colCount - 1;
                        targetRow = stateManager.select.cellPos.row;
                    }
                    else if (e.shiftKey) {
                        targetRow = stateManager.select.cellPos.row;
                        targetCol = Math.min(table.colCount - 1, Math.max(0, stateManager.select.cellPos.col + 1));
                    }
                    else {
                        targetRow = stateManager.select.cellPos.row;
                        targetCol = Math.min(table.colCount - 1, Math.max(0, stateManager.select.cellPos.col + 1));
                    }
                }
                if (isCellDisableSelect(table, targetCol, targetRow)) {
                    return;
                }
                table.selectCell(targetCol, targetRow, e.shiftKey);
                if ((table.options.keyboardOptions?.moveEditCellOnArrowKeys ?? false) &&
                    table.editorManager?.editingEditor) {
                    table.editorManager.completeEdit();
                    table.getElement().focus();
                    if (table.getEditor(targetCol, targetRow)) {
                        table.editorManager.startEditCell(targetCol, targetRow);
                    }
                }
            }
            else if (e.key === 'Escape') {
                table.editorManager?.cancelEdit();
                table.getElement().focus();
            }
            else if (e.key === 'Enter') {
                if (table.editorManager?.editingEditor) {
                    handleKeydownListener(e);
                    table.editorManager.completeEdit();
                    table.getElement().focus();
                    if (table.options.keyboardOptions?.moveFocusCellOnEnter === true) {
                        const targetCol = stateManager.select.cellPos.col;
                        const targetRow = Math.min(table.rowCount - 1, Math.max(0, stateManager.select.cellPos.row + 1));
                        if (isCellDisableSelect(table, targetCol, targetRow)) {
                            return;
                        }
                        table.selectCell(targetCol, targetRow, e.shiftKey);
                    }
                    return;
                }
                if (table.options.keyboardOptions?.moveFocusCellOnEnter === true) {
                    const targetCol = stateManager.select.cellPos.col;
                    const targetRow = Math.min(table.rowCount - 1, Math.max(0, stateManager.select.cellPos.row + 1));
                    if (isCellDisableSelect(table, targetCol, targetRow)) {
                        return;
                    }
                    table.selectCell(targetCol, targetRow, e.shiftKey);
                }
                else if ((table.options.keyboardOptions?.editCellOnEnter ?? true) &&
                    (table.stateManager.select.ranges?.length ?? 0) === 1) {
                    const startCol = table.stateManager.select.ranges[0].start.col;
                    const startRow = table.stateManager.select.ranges[0].start.row;
                    const endCol = table.stateManager.select.ranges[0].end.col;
                    const endRow = table.stateManager.select.ranges[0].end.row;
                    if (startCol === endCol && startRow === endRow) {
                        if (table.getEditor(startCol, startRow)) {
                            table.editorManager.startEditCell(startCol, startRow);
                        }
                    }
                }
            }
            else if (e.key === 'Tab') {
                if (table.options.keyboardOptions?.moveFocusCellOnTab ?? true) {
                    if (stateManager.select.cellPos.col >= 0 && stateManager.select.cellPos.row >= 0) {
                        const isLastCell = stateManager.select.cellPos.col === table.colCount - 1 &&
                            stateManager.select.cellPos.row === table.rowCount - 1;
                        if (isLastCell) {
                            return;
                        }
                        e.preventDefault();
                        let targetCol;
                        let targetRow;
                        if (stateManager.select.cellPos.col === table.colCount - 1) {
                            targetRow = Math.min(table.rowCount - 1, stateManager.select.cellPos.row + 1);
                            targetCol = table.rowHeaderLevelCount;
                        }
                        else {
                            targetRow = stateManager.select.cellPos.row;
                            targetCol = stateManager.select.cellPos.col + 1;
                        }
                        if (isCellDisableSelect(table, targetCol, targetRow)) {
                            return;
                        }
                        table.selectCell(targetCol, targetRow);
                        if (table.editorManager?.editingEditor) {
                            table.editorManager.completeEdit();
                            table.getElement().focus();
                            if (table.getEditor(targetCol, targetRow)) {
                                table.editorManager.startEditCell(targetCol, targetRow);
                            }
                        }
                    }
                }
            }
            else if (!(e.ctrlKey || e.metaKey)) {
                const editCellTrigger = table.options.editCellTrigger;
                if ((editCellTrigger === 'keydown' || (Array.isArray(editCellTrigger) && editCellTrigger.includes('keydown'))) &&
                    !table.editorManager?.editingEditor) {
                    const allowedKeys = /^[a-zA-Z0-9+\-*\/%=.,\s]$/;
                    if (e.key.match(allowedKeys)) {
                        table.editorManager.beginTriggerEditCellMode = 'keydown';
                        table.editorManager.startEditCell(stateManager.select.cellPos.col, stateManager.select.cellPos.row, '');
                    }
                }
            }
            handleKeydownListener(e);
        });
        function handleKeydownListener(e) {
            if (table.hasListeners(TABLE_EVENT_TYPE.KEYDOWN)) {
                const cellsEvent = {
                    keyCode: e.keyCode ?? e.which,
                    code: e.code,
                    event: e,
                    scaleRatio: table.canvas.getBoundingClientRect().width / table.canvas.offsetWidth
                };
                table.fireListeners(TABLE_EVENT_TYPE.KEYDOWN, cellsEvent);
            }
        }
        handler.on(table.getElement(), 'copy', async (e) => {
            if (table.keyboardOptions?.copySelected) {
                const data = table.getCopyValue();
                if (isValid$3(data)) {
                    e.preventDefault();
                    const permissionState = await navigator.permissions.query({ name: 'clipboard-write' });
                    if (navigator.clipboard?.write && permissionState.state === 'granted') {
                        const setDataToHTML = (data) => {
                            const result = ['<table>'];
                            const META_HEAD = [
                                '<meta name="author" content="Visactor"/>',
                                '<style type="text/css">td{white-space:normal}br{mso-data-placement:same-cell}</style>'
                            ].join('');
                            const rows = data.split('\r\n');
                            rows.forEach(function (rowCells, rowIndex) {
                                const cells = rowCells.split('\t');
                                const rowValues = [];
                                if (rowIndex === 0) {
                                    result.push('<tbody>');
                                }
                                cells.forEach(function (cell, cellIndex) {
                                    const parsedCellData = !cell
                                        ? ' '
                                        : cell
                                            .toString()
                                            .replace(/&/g, '&amp;')
                                            .replace(/'/g, '&#39;')
                                            .replace(/</g, '&lt;')
                                            .replace(/>/g, '&gt;')
                                            .replace(/\n/g, '<br>')
                                            .replace(/(<br(\s*|\/)>(\r\n|\n)?|\r\n|\n)/g, '<br>\r\n')
                                            .replace(/\x20{2,}/gi, (substring) => {
                                            return `<span style="mso-spacerun: yes">${'&nbsp;'.repeat(substring.length - 1)} </span>`;
                                        })
                                            .replace(/\t/gi, '&#9;');
                                    rowValues.push(`<td>${parsedCellData}</td>`);
                                });
                                result.push('<tr>', ...rowValues, '</tr>');
                                if (rowIndex === rows.length - 1) {
                                    result.push('</tbody>');
                                }
                            });
                            result.push('</table>');
                            return [META_HEAD, result.join('')].join('');
                        };
                        const dataHTML = setDataToHTML(data);
                        navigator.clipboard.write([
                            new ClipboardItem({
                                'text/html': new Blob([dataHTML], { type: 'text/html' }),
                                'text/plain': new Blob([data], { type: 'text/plain' })
                            })
                        ]);
                    }
                    else {
                        if (browser.IE) {
                            window.clipboardData.setData('Text', data);
                        }
                        else {
                            e.clipboardData.setData('text/plain', data);
                        }
                    }
                    table.fireListeners(TABLE_EVENT_TYPE.COPY_DATA, {
                        cellRange: table.stateManager.select.ranges,
                        copyData: data
                    });
                }
            }
        });
        handler.on(table.getElement(), 'paste', (e) => {
            if (table.keyboardOptions?.pasteValueToCell && table.changeCellValues) {
                if (table.editorManager?.editingEditor) {
                    return;
                }
                if (table.stateManager.select.ranges?.length > 0) {
                    if (navigator.clipboard?.read) {
                        navigator.clipboard.read().then(clipboardItems => {
                            for (const item of clipboardItems) {
                                if (item.types.includes('text/html')) {
                                    pasteHtmlToTable(item);
                                }
                                else if (item.types.length === 1 && item.types[0] === 'text/plain') {
                                    pasteTextToTable(item);
                                }
                                else ;
                            }
                        });
                    }
                    else {
                        const ranges = table.stateManager.select.ranges;
                        const col = Math.min(ranges[0].start.col, ranges[0].end.col);
                        const row = Math.min(ranges[0].start.row, ranges[0].end.row);
                        const clipboardData = e.clipboardData || window.Clipboard;
                        const pastedData = clipboardData.getData('text');
                        const rows = pastedData.split('\n');
                        const values = [];
                        rows.forEach(function (rowCells, rowIndex) {
                            const cells = rowCells.split('\t');
                            const rowValues = [];
                            values.push(rowValues);
                            cells.forEach(function (cell, cellIndex) {
                                if (cellIndex === cells.length - 1) {
                                    cell = cell.trim();
                                }
                                rowValues.push(cell);
                            });
                        });
                        table.changeCellValues(col, row, values);
                    }
                }
            }
        });
        handler.on(table.getElement(), 'contextmenu', (e) => {
            if (table.eventOptions?.preventDefaultContextMenu !== false) {
                e.preventDefault();
            }
            else {
                globalPointerupCallback(e);
            }
        });
        if (!table.options.canvas) {
            handler.on(table.getContainer(), 'resize', e => {
                if (table.isReleased) {
                    return;
                }
                if (e.width === 0 && e.height === 0) {
                    return;
                }
                if (table.autoFillWidth || table.autoFillHeight) {
                    table.editorManager?.completeEdit();
                }
                if (!isValid$3(table.options.pixelRatio)) {
                    table.setPixelRatio(getPixelRatio());
                }
                if (!e.windowSizeNotChange) {
                    table.resize();
                }
            });
        }
        const regex = /<tr[^>]*>([\s\S]*?)<\/tr>/g;
        const cellRegex = /<td[^>]*>([\s\S]*?)<\/td>/g;
        function pasteHtmlToTable(item) {
            const ranges = table.stateManager.select.ranges;
            const selectRangeLength = ranges.length;
            const col = Math.min(ranges[selectRangeLength - 1].start.col, ranges[selectRangeLength - 1].end.col);
            const row = Math.min(ranges[selectRangeLength - 1].start.row, ranges[selectRangeLength - 1].end.row);
            const maxCol = Math.max(ranges[selectRangeLength - 1].start.col, ranges[selectRangeLength - 1].end.col);
            const maxRow = Math.max(ranges[selectRangeLength - 1].start.row, ranges[selectRangeLength - 1].end.row);
            let pasteValuesColCount = 0;
            let pasteValuesRowCount = 0;
            let values = [];
            item.getType('text/html').then((blob) => {
                blob.text().then((pastedData) => {
                    if (pastedData && /(<table)|(<TABLE)/g.test(pastedData)) {
                        const matches = Array.from(pastedData.matchAll(regex));
                        for (const match of matches) {
                            const rowContent = match[1];
                            const cellMatches = Array.from(rowContent.matchAll(cellRegex));
                            const rowValues = cellMatches.map(cellMatch => {
                                return (cellMatch[1]
                                    .replace(/(<(?!br)([^>]+)>)/gi, '')
                                    .replace(/<br(\s*|\/)>[\r\n]?/gim, '\n')
                                    .replace(/&amp;/g, '&')
                                    .replace(/&lt;/g, '<')
                                    .replace(/&gt;/g, '>')
                                    .replace(/&#9;/gi, '\t')
                                    .replace(/&nbsp;/g, ' '));
                            });
                            values.push(rowValues);
                            pasteValuesColCount = Math.max(pasteValuesColCount, rowValues?.length ?? 0);
                        }
                        pasteValuesRowCount = values.length ?? 0;
                        values = handlePasteValues(values, pasteValuesRowCount, pasteValuesColCount, maxRow - row + 1, maxCol - col + 1);
                        table.changeCellValues(col, row, values, true);
                    }
                    else {
                        navigator.clipboard.read().then(clipboardItems => {
                            for (const item of clipboardItems) {
                                if (item.types.includes('text/plain')) {
                                    item.getType('text/plain').then((blob) => {
                                        blob.text().then(_pasteValue);
                                    });
                                }
                            }
                        });
                    }
                });
            });
        }
        function _pasteValue(pastedData) {
            const ranges = table.stateManager.select.ranges;
            const selectRangeLength = ranges.length;
            const col = Math.min(ranges[selectRangeLength - 1].start.col, ranges[selectRangeLength - 1].end.col);
            const row = Math.min(ranges[selectRangeLength - 1].start.row, ranges[selectRangeLength - 1].end.row);
            const maxCol = Math.max(ranges[selectRangeLength - 1].start.col, ranges[selectRangeLength - 1].end.col);
            const maxRow = Math.max(ranges[selectRangeLength - 1].start.row, ranges[selectRangeLength - 1].end.row);
            let pasteValuesColCount = 0;
            let pasteValuesRowCount = 0;
            let values = [];
            const rows = pastedData.split('\n');
            rows.forEach(function (rowCells, rowIndex) {
                const cells = rowCells.split('\t');
                const rowValues = [];
                values.push(rowValues);
                cells.forEach(function (cell, cellIndex) {
                    if (cellIndex === cells.length - 1) {
                        cell = cell.trim();
                    }
                    rowValues.push(cell);
                });
                pasteValuesColCount = Math.max(pasteValuesColCount, rowValues?.length ?? 0);
            });
            pasteValuesRowCount = values.length ?? 0;
            values = handlePasteValues(values, pasteValuesRowCount, pasteValuesColCount, maxRow - row + 1, maxCol - col + 1);
            table.changeCellValues(col, row, values, true);
        }
        function pasteTextToTable(item) {
            const ranges = table.stateManager.select.ranges;
            const selectRangeLength = ranges.length;
            const col = Math.min(ranges[selectRangeLength - 1].start.col, ranges[selectRangeLength - 1].end.col);
            const row = Math.min(ranges[selectRangeLength - 1].start.row, ranges[selectRangeLength - 1].end.row);
            const maxCol = Math.max(ranges[selectRangeLength - 1].start.col, ranges[selectRangeLength - 1].end.col);
            const maxRow = Math.max(ranges[selectRangeLength - 1].start.row, ranges[selectRangeLength - 1].end.row);
            let pasteValuesColCount = 0;
            let pasteValuesRowCount = 0;
            item.getType('text/plain').then((blob) => {
                blob.text().then((pastedData) => {
                    const rows = pastedData.replace(/\r(?!\n)/g, '\r\n').split('\r\n');
                    let values = [];
                    if (rows.length > 1 && rows[rows.length - 1] === '') {
                        rows.pop();
                    }
                    rows.forEach(function (rowCells, rowIndex) {
                        const cells = rowCells.split('\t');
                        const rowValues = [];
                        values.push(rowValues);
                        cells.forEach(function (cell, cellIndex) {
                            if (cell.includes('\n')) {
                                cell = cell
                                    .replace(/^"(.*)"$/, '$1')
                                    .replace(/["]*/g, match => new Array(Math.floor(match.length / 2)).fill('"').join(''));
                            }
                            rowValues.push(cell);
                        });
                        pasteValuesColCount = Math.max(pasteValuesColCount, rowValues?.length ?? 0);
                    });
                    pasteValuesRowCount = values.length ?? 0;
                    values = handlePasteValues(values, pasteValuesRowCount, pasteValuesColCount, maxRow - row + 1, maxCol - col + 1);
                    table.changeCellValues(col, row, values, true);
                });
            });
        }
        function handlePasteValues(values, rowCount, colCount, selectedRowCount, selectedColCount) {
            if (selectedColCount > colCount || selectedRowCount > rowCount) {
                if (selectedColCount % colCount === 0 && selectedRowCount % rowCount === 0) {
                    const toPasteValues = [];
                    for (let i = 0; i < selectedRowCount; i++) {
                        const rowPasteValue = [];
                        toPasteValues.push(rowPasteValue);
                        for (let j = 0; j < selectedColCount; j++) {
                            const copiedRow = i % rowCount;
                            const copiedCol = j % colCount;
                            rowPasteValue.push(values[copiedRow][copiedCol]);
                        }
                    }
                    return toPasteValues;
                }
                return values;
            }
            return values;
        }
        const globalPointerdownCallback = (e) => {
            if (table.isReleased) {
                return;
            }
            table.eventManager.LastBodyPointerXY = { x: e.x, y: e.y };
            table.eventManager.isDown = true;
            const target = e.target;
            if (!table.getElement().contains(target) && !table.internalProps.menuHandler.containElement(target)) {
                const isCompleteEdit = table.editorManager?.completeEdit(e);
                getPromiseValue(isCompleteEdit, isCompleteEdit => {
                    if (isCompleteEdit === false) {
                        return;
                    }
                    if (table.options.select?.outsideClickDeselect) {
                        const isHasSelected = !!stateManager.select.ranges?.length;
                        eventManager.dealTableSelect();
                        stateManager.endSelectCells(true, isHasSelected);
                    }
                });
            }
        };
        eventManager.globalEventListeners.push({
            name: 'pointerdown',
            env: 'vglobal',
            callback: globalPointerdownCallback
        });
        vglobal.addEventListener('pointerdown', globalPointerdownCallback);
        const globalPointerupOutsideCallback = (e) => {
            if (stateManager.menu.isShow) {
                setTimeout(() => {
                    if (!table.internalProps.menuHandler.pointInMenuElement(e.clientX, e.clientY)) {
                        stateManager.menu.isShow && stateManager.hideMenu();
                    }
                }, 0);
            }
            if (stateManager.isResizeCol()) {
                endResizeCol(table);
            }
            else if (stateManager.isResizeRow()) {
                endResizeRow(table);
            }
            else if (stateManager.isMoveCol()) {
                const endMoveColSuccess = table.stateManager.endMoveCol();
                fireMoveColEventListeners(table, endMoveColSuccess, e);
            }
            else if (stateManager.isSelecting()) {
                if (table.stateManager.select?.ranges?.length) {
                    const lastCol = table.stateManager.select.ranges[table.stateManager.select.ranges.length - 1].end.col;
                    const lastRow = table.stateManager.select.ranges[table.stateManager.select.ranges.length - 1].end.row;
                    table.stateManager.endSelectCells();
                    if (table.hasListeners(TABLE_EVENT_TYPE.DRAG_SELECT_END)) {
                        const cellsEvent = {
                            event: e,
                            cells: [],
                            col: lastCol,
                            row: lastRow,
                            scaleRatio: table.canvas.getBoundingClientRect().width / table.canvas.offsetWidth,
                            target: undefined
                        };
                        cellsEvent.cells = table.getSelectedCellInfos();
                        table.fireListeners(TABLE_EVENT_TYPE.DRAG_SELECT_END, cellsEvent);
                    }
                }
            }
        };
        const globalPointerupCallback = (e) => {
            if (table.isReleased) {
                return;
            }
            const target = e.target;
            if (target !== table.canvas) {
                globalPointerupOutsideCallback(e);
            }
            table.eventManager.LastBodyPointerXY = null;
            table.eventManager.isDown = false;
            table.eventManager.isDraging = false;
            table.eventManager.inertiaScroll.endInertia();
            if (stateManager.interactionState === 'grabing' && stateManager.isResizeCol()) {
                endResizeCol(table);
            }
            else if (stateManager.interactionState === 'grabing' && stateManager.isResizeRow()) {
                endResizeRow(table);
            }
            else if (stateManager.isMoveCol()) {
                const endMoveColSuccess = table.stateManager.endMoveCol();
                fireMoveColEventListeners(table, endMoveColSuccess, e);
            }
            else if (table.editorManager.editingEditor) {
                if (!table.getElement().contains(target)) {
                    const isCompleteEdit = table.editorManager?.completeEdit(e);
                    getPromiseValue(isCompleteEdit, (isCompleteEdit) => {
                        if (isCompleteEdit === false) {
                            return;
                        }
                        stateManager.updateInteractionState(InteractionState.default);
                        eventManager.dealTableHover();
                    });
                }
            }
        };
        eventManager.globalEventListeners.push({
            name: 'pointerup',
            env: 'vglobal',
            callback: globalPointerupCallback
        });
        vglobal.addEventListener('pointerup', globalPointerupCallback);
        const globalPointermoveCallback = (e) => {
            if (table.eventManager.isDown && table.eventManager.LastBodyPointerXY) {
                const lastX = table.eventManager.LastBodyPointerXY?.x ?? e.x;
                const lastY = table.eventManager.LastBodyPointerXY?.y ?? e.y;
                if (Math.abs(lastX - e.x) > 1 || Math.abs(lastY - e.y) > 1) {
                    table.eventManager.isDraging = true;
                }
            }
            const { x, y } = table._getMouseAbstractPoint(e);
            if (stateManager.interactionState === InteractionState.grabing) {
                if (stateManager.isResizeCol()) {
                    eventManager.dealColumnResize(x, y);
                    if (table.hasListeners(TABLE_EVENT_TYPE.RESIZE_COLUMN)) {
                        table.fireListeners(TABLE_EVENT_TYPE.RESIZE_COLUMN, {
                            col: table.stateManager.columnResize.col,
                            colWidth: table.getColWidth(table.stateManager.columnResize.col)
                        });
                    }
                }
                else if (stateManager.isResizeRow()) {
                    eventManager.dealRowResize(x, y);
                    if (table.hasListeners(TABLE_EVENT_TYPE.RESIZE_ROW)) {
                        table.fireListeners(TABLE_EVENT_TYPE.RESIZE_ROW, {
                            row: table.stateManager.rowResize.row,
                            rowHeight: table.getRowHeight(table.stateManager.rowResize.row)
                        });
                    }
                }
            }
            const isSelecting = table.stateManager.isSelecting();
            if (eventManager._enableTableScroll &&
                eventManager.isDraging &&
                isSelecting &&
                table.stateManager.select.ranges?.length > 0) {
                const drawRange = table.getDrawRange();
                const topFrozenRowHeight = table.getFrozenRowsHeight();
                const bottomFrozenRowHeight = table.getBottomFrozenRowsHeight();
                const leftFrozenColsWidth = table.getFrozenColsWidth();
                const rightFrozenColsWidth = table.getRightFrozenColsWidth();
                const startCell = table.stateManager.select.ranges[table.stateManager.select.ranges.length - 1].start;
                if (table.isSeriesNumber(startCell.col, startCell.row)) {
                    return;
                }
                const endCell = table.stateManager.select.ranges[table.stateManager.select.ranges.length - 1].end;
                const canScrollY = (table.isFrozenRow(startCell.row) === false || table.isFrozenRow(endCell.row) === false) &&
                    table.getAllRowsHeight() > table.tableNoFrameHeight;
                const canScrollX = (table.isFrozenColumn(startCell.col) === false || table.isFrozenColumn(endCell.col) === false) &&
                    table.getAllColsWidth() > table.tableNoFrameWidth;
                if (((y > drawRange.bottom - bottomFrozenRowHeight || y < drawRange.top + topFrozenRowHeight) && canScrollY) ||
                    ((x > drawRange.right - rightFrozenColsWidth || x < drawRange.left + leftFrozenColsWidth) && canScrollX)) {
                    table.eventManager.scrollXSpeed = 0;
                    table.eventManager.scrollYSpeed = 0;
                    let bottom = false;
                    let top = false;
                    let right = false;
                    let left = false;
                    if (y > drawRange.bottom - bottomFrozenRowHeight &&
                        canScrollY &&
                        table.scrollTop + table.tableNoFrameHeight < table.getAllRowsHeight()) {
                        bottom = true;
                        table.eventManager.scrollYSpeed = -(y - drawRange.bottom + bottomFrozenRowHeight) / 50;
                    }
                    else if (y < drawRange.top + topFrozenRowHeight && canScrollY && table.scrollTop > 0) {
                        top = true;
                        table.eventManager.scrollYSpeed = -(y - drawRange.top - topFrozenRowHeight) / 50;
                    }
                    if (x > drawRange.right - rightFrozenColsWidth &&
                        canScrollX &&
                        table.scrollLeft + table.tableNoFrameWidth < table.getAllColsWidth()) {
                        right = true;
                        table.eventManager.scrollXSpeed = -(x - drawRange.right + rightFrozenColsWidth) / 50;
                    }
                    else if (x < drawRange.left + leftFrozenColsWidth && canScrollX && table.scrollLeft > 0) {
                        left = true;
                        table.eventManager.scrollXSpeed = -(x - drawRange.left - leftFrozenColsWidth) / 50;
                    }
                    table.eventManager.inertiaScroll.startInertia(table.eventManager.scrollXSpeed, table.eventManager.scrollYSpeed, 1);
                    table.eventManager.inertiaScroll.setScrollHandle((dx, dy) => {
                        handleWhell({ deltaX: -dx, deltaY: -dy }, table.stateManager, false);
                        let selectX;
                        let selectY;
                        if (bottom) {
                            selectY = table.scrollTop + drawRange.height - bottomFrozenRowHeight - 20;
                        }
                        else if (top) {
                            selectY = table.scrollTop + topFrozenRowHeight + 20;
                        }
                        if (right) {
                            selectX = table.scrollLeft + drawRange.width - rightFrozenColsWidth - 20;
                        }
                        else if (left) {
                            selectX = table.scrollLeft + leftFrozenColsWidth + 20;
                        }
                        let considerFrozenY = false;
                        let considerFrozenX = false;
                        if (!right && !left) {
                            if ((x > table.tableNoFrameWidth - table.getRightFrozenColsWidth() && x < table.tableNoFrameWidth) ||
                                (x > 0 && x < table.getFrozenColsWidth())) {
                                selectX = x;
                                considerFrozenX = true;
                            }
                            else {
                                selectX = table.scrollLeft + x;
                            }
                        }
                        if (!bottom && !top) {
                            if ((y > table.tableNoFrameHeight - table.getBottomFrozenRowsHeight() && y < table.tableNoFrameHeight) ||
                                (y > 0 && y < table.getFrozenRowsHeight())) {
                                selectY = y;
                                considerFrozenY = true;
                            }
                            else {
                                selectY = table.scrollTop + y;
                            }
                        }
                        table.stateManager.updateInteractionState(InteractionState.grabing);
                        const targetCol = table.getTargetColAtConsiderRightFrozen(selectX, considerFrozenX);
                        const targetRow = table.getTargetRowAtConsiderBottomFrozen(selectY, considerFrozenY);
                        if (!table.options.select?.disableDragSelect && isValid$3(targetCol) && isValid$3(targetRow)) {
                            table.stateManager.updateSelectPos(targetCol.col, targetRow.row, false, false, false, false);
                        }
                    });
                }
                else if (table.eventManager.inertiaScroll.isInertiaScrolling()) {
                    table.eventManager.inertiaScroll.endInertia();
                }
                else {
                    table.eventManager.scrollYSpeed = 0;
                }
            }
        };
        eventManager.globalEventListeners.push({
            name: 'pointermove',
            env: 'vglobal',
            callback: globalPointermoveCallback
        });
        vglobal.addEventListener('pointermove', globalPointermoveCallback);
    }

    function bindTouchListener(eventManager) {
        const table = eventManager.table;
        const stateManager = table.stateManager;
        const scenegraph = table.scenegraph;
        if (vglobal.envContribution.supportsTouchEvents === false) {
            return;
        }
        vglobal.addEventListener('contextmenu', e => {
            e.stopPropagation();
            e.preventDefault();
        }, { capture: true });
        eventManager.touchMovePoints = [];
        table.scenegraph.tableGroup.addEventListener('touchstart', (e) => {
            if (e.target.isChildOf(scenegraph.component.vScrollBar) || e.target.isChildOf(scenegraph.component.vScrollBar)) {
                return;
            }
            eventManager.isTouchdown = true;
            const touchEvent = e.nativeEvent;
            eventManager.touchMovePoints.push({
                x: table.rotateDegree ? touchEvent.changedTouches?.[0]?._canvasX ?? e.canvas?.x : e.page.x,
                y: table.rotateDegree ? touchEvent.changedTouches?.[0]?._canvasY ?? e.canvas?.y : e.page.y,
                timestamp: Date.now()
            });
        });
        const globalTouchMoveCallback = (e) => {
            if (eventManager.isLongTouch) {
                e.preventDefault();
            }
            if (!eventManager.isTouchdown || !isTouchEvent$1(e)) {
                return;
            }
            eventManager.isTouchMove = true;
            if (eventManager.downIcon?.attribute?.funcType === IconFuncTypeEnum.dragReorder) {
                e.preventDefault();
            }
            else {
                if (eventManager.touchMovePoints.length > 4) {
                    eventManager.touchMovePoints.shift();
                }
                eventManager.touchMovePoints.push({
                    x: table.rotateDegree ? e.changedTouches[0]._canvasX : e.changedTouches[0].pageX,
                    y: table.rotateDegree ? e.changedTouches[0]._canvasY : e.changedTouches[0].pageY,
                    timestamp: Date.now()
                });
                if (eventManager._enableTableScroll) {
                    const deltaX = -eventManager.touchMovePoints[eventManager.touchMovePoints.length - 1].x +
                        eventManager.touchMovePoints[eventManager.touchMovePoints.length - 2].x;
                    const deltaY = -eventManager.touchMovePoints[eventManager.touchMovePoints.length - 1].y +
                        eventManager.touchMovePoints[eventManager.touchMovePoints.length - 2].y;
                    handleWhell({ deltaX, deltaY }, stateManager);
                    if (e.cancelable &&
                        (table.internalProps.overscrollBehavior === 'none' ||
                            (Math.abs(deltaY) >= Math.abs(deltaX) && deltaY !== 0 && isVerticalScrollable(deltaY, stateManager)) ||
                            (Math.abs(deltaY) <= Math.abs(deltaX) && deltaX !== 0 && isHorizontalScrollable(deltaX, stateManager)))) {
                        e.preventDefault();
                    }
                }
            }
        };
        vglobal.addEventListener('touchmove', globalTouchMoveCallback, { passive: false });
        eventManager.globalEventListeners.push({
            name: 'touchmove',
            env: 'vglobal',
            callback: globalTouchMoveCallback
        });
        const globalTouchEndCallback = (e) => {
            eventManager.touchEnd = true;
            eventManager.isLongTouch = false;
            if (!eventManager.isTouchdown || !isTouchEvent$1(e)) {
                return;
            }
            if (eventManager.downIcon?.attribute?.funcType === IconFuncTypeEnum.dragReorder) {
                e.preventDefault();
            }
            else {
                if (eventManager.touchMovePoints?.length) {
                    if (eventManager.touchMovePoints.length > 4) {
                        eventManager.touchMovePoints.shift();
                    }
                    eventManager.touchMovePoints.push({
                        x: table.rotateDegree ? e.changedTouches[0]._canvasX : e.changedTouches[0].pageX,
                        y: table.rotateDegree ? e.changedTouches[0]._canvasY : e.changedTouches[0].pageY,
                        timestamp: Date.now()
                    });
                    if (eventManager._enableTableScroll) {
                        const firstPoint = eventManager.touchMovePoints[0];
                        const lastPoint = eventManager.touchMovePoints[eventManager.touchMovePoints?.length - 1];
                        const vX = (lastPoint.x - firstPoint.x) / (lastPoint.timestamp - firstPoint.timestamp);
                        const vY = (lastPoint.y - firstPoint.y) / (lastPoint.timestamp - firstPoint.timestamp);
                        eventManager.inertiaScroll.startInertia(vX, vY, 0.95);
                        table.eventManager.inertiaScroll.setScrollHandle((dx, dy) => {
                            handleWhell({ deltaX: -dx, deltaY: -dy }, table.stateManager);
                        });
                    }
                }
            }
            eventManager.isTouchdown = false;
            eventManager.isTouchMove = false;
            eventManager.isDraging = false;
            eventManager.touchMovePoints = [];
        };
        vglobal.addEventListener('touchend', globalTouchEndCallback);
        eventManager.globalEventListeners.push({
            name: 'touchend',
            env: 'vglobal',
            callback: globalTouchEndCallback
        });
        const globalTouchCancelCallback = (e) => {
            eventManager.touchEnd = true;
            eventManager.isLongTouch = false;
            if (!eventManager.isTouchdown) {
                return;
            }
            eventManager.isTouchdown = false;
            eventManager.isTouchMove = false;
            eventManager.touchMovePoints = [];
            eventManager.isDraging = false;
        };
        vglobal.addEventListener('touchcancel', globalTouchCancelCallback);
        eventManager.globalEventListeners.push({
            name: 'touchcancel',
            env: 'vglobal',
            callback: globalTouchCancelCallback
        });
    }
    function isTouchEvent$1(e) {
        return !!e.changedTouches;
    }

    function bindAxisClickEvent(table) {
        if (!table.isPivotChart()) {
            return;
        }
        table.scenegraph.tableGroup.addEventListener('click', (e) => {
            if (table.stateManager.columnMove.moving || table.stateManager.columnResize.resizing) {
                return;
            }
            if (e.target.name === 'axis-label') {
                const eventArgsSet = getCellEventArgsSet(e);
                const { col, row } = eventArgsSet.eventArgs;
                const layout = table.internalProps.layoutMap;
                let dimensionKey;
                let dimensions;
                if (layout.indicatorsAsCol) {
                    dimensionKey = layout.getDimensionKeyInChartSpec(layout.rowHeaderLevelCount, row);
                    dimensions = layout.getCellHeaderPaths(layout.rowHeaderLevelCount - 2, row).rowHeaderPaths;
                }
                else {
                    dimensionKey = layout.getDimensionKeyInChartSpec(col, layout.columnHeaderLevelCount);
                    dimensions = layout.getCellHeaderPaths(col, layout.columnHeaderLevelCount - 1).colHeaderPaths;
                }
                const filter = dimensions
                    .map(dimension => {
                    return {
                        key: dimension.dimensionKey,
                        value: dimension.value
                    };
                })
                    .filter(dimension => dimension.key);
                filter.push({ key: dimensionKey, value: e.target.attribute.text });
                if (table._selectedDimensionInChart.length &&
                    isSameSelectedDimension(table._selectedDimensionInChart, filter)) {
                    return;
                }
                table._selectedDimensionInChart = filter;
                layout.updateDataStateToChartInstance();
                clearChartCacheImage(table.scenegraph);
                table.scenegraph.updateNextFrame();
            }
            else if (table._selectedDimensionInChart?.length) {
                table._selectedDimensionInChart.length = 0;
                const layout = table.internalProps.layoutMap;
                layout.updateDataStateToChartInstance();
                clearChartCacheImage(table.scenegraph);
                table.scenegraph.updateNextFrame();
            }
        });
    }
    function isSameSelectedDimension(dimensions1, dimensions2) {
        if (dimensions1.length !== dimensions2.length) {
            return false;
        }
        for (let i = 0; i < dimensions1.length; i++) {
            if (dimensions1[i].key !== dimensions2[i].key || dimensions1[i].value !== dimensions2[i].value) {
                return false;
            }
        }
        return true;
    }

    function bindAxisHoverEvent(table) {
        if (!table.isPivotChart()) {
            return;
        }
        table.on(TABLE_EVENT_TYPE.MOUSEENTER_CELL, e => {
            const cellGroup = table.scenegraph.getCell(e.col, e.row);
            cellGroup.forEachChildren(child => {
                if (child.name === 'axis') {
                    const position = getAxisPosition(e.col, e.row, table.internalProps.layoutMap);
                    e.axisPosition = position;
                    table.fireListeners(TABLE_EVENT_TYPE.MOUSEENTER_AXIS, e);
                }
            });
        });
        table.on(TABLE_EVENT_TYPE.MOUSELEAVE_CELL, e => {
            const cellGroup = table.scenegraph.getCell(e.col, e.row);
            cellGroup.forEachChildren(child => {
                if (child.name === 'axis') {
                    const position = getAxisPosition(e.col, e.row, table.internalProps.layoutMap);
                    e.axisPosition = position;
                    table.fireListeners(TABLE_EVENT_TYPE.MOUSELEAVE_AXIS, e);
                }
            });
        });
    }
    function getAxisPosition(col, row, layout) {
        if (layout.indicatorsAsCol) {
            if (layout.hasTwoIndicatorAxes &&
                row === layout.columnHeaderLevelCount - 1 &&
                col >= layout.rowHeaderLevelCount &&
                col < layout.colCount - layout.rightFrozenColCount) {
                return 'top';
            }
            else if (row === layout.rowCount - layout.bottomFrozenRowCount &&
                col >= layout.rowHeaderLevelCount &&
                col < layout.colCount - layout.rightFrozenColCount) {
                return 'bottom';
            }
            else if (col === layout.rowHeaderLevelCount - 1 &&
                row >= layout.rowHeaderLevelCount &&
                row < layout.rowCount - layout.bottomFrozenRowCount) {
                return 'left';
            }
        }
        else {
            if (col === layout.rowHeaderLevelCount - 1 &&
                row >= layout.columnHeaderLevelCount &&
                row < layout.rowCount - layout.bottomFrozenRowCount) {
                return 'left';
            }
            else if (col === layout.colCount - layout.rightFrozenColCount &&
                row >= layout.columnHeaderLevelCount &&
                row < layout.rowCount - layout.bottomFrozenRowCount) {
                return 'right';
            }
            else if (row === layout.rowCount - layout.bottomFrozenRowCount &&
                col >= layout.rowHeaderLevelCount &&
                col < layout.colCount - layout.rightFrozenColCount) {
                return 'bottom';
            }
        }
        return 'bottom';
    }

    function bindGroupTitleCheckboxChange(table) {
        table.on('checkbox_state_change', args => {
            const { col, row, checked, field } = args;
            if (field !== '_vtable_rowSeries_number' || table.internalProps.rowSeriesNumber?.enableTreeCheckbox !== true) {
                return;
            }
            if (table.isHeader(col, row)) {
                return;
            }
            const record = table.getCellOriginRecord(col, row);
            const indexedData = table.dataSource.currentPagerIndexedData;
            const titleShowIndex = table.getRecordShowIndexByCell(col, row);
            let titleIndex = indexedData[titleShowIndex];
            if (isNumber$4(titleIndex)) {
                titleIndex = [titleIndex];
            }
            if (record.vtableMerge || record.children?.length) {
                if (checked) {
                    if (getHierarchyState(table, col, row) === HierarchyState.collapse) {
                        updateChildrenCheckboxState(true, titleIndex, table);
                    }
                    else {
                        setAllChildrenCheckboxState(true, titleShowIndex, titleIndex, indexedData, table);
                    }
                    updateGroupTitleCheckboxState(titleShowIndex, titleIndex, indexedData, table);
                }
                else {
                    if (getHierarchyState(table, col, row) === HierarchyState.collapse) {
                        updateChildrenCheckboxState(false, titleIndex, table);
                    }
                    else {
                        setAllChildrenCheckboxState(false, titleShowIndex, titleIndex, indexedData, table);
                    }
                    updateGroupTitleCheckboxState(titleShowIndex, titleIndex, indexedData, table);
                    const oldHeaderCheckedState = table.stateManager.headerCheckedState._vtable_rowSeries_number;
                    const newHeaderCheckedState = table.stateManager.updateHeaderCheckedState('_vtable_rowSeries_number', col, row);
                    if (oldHeaderCheckedState !== newHeaderCheckedState) {
                        table.scenegraph.updateHeaderCheckboxCellState(col, row, newHeaderCheckedState);
                    }
                }
            }
            else {
                updateGroupTitleCheckboxState(titleShowIndex, titleIndex, indexedData, table);
            }
        });
    }
    function setAllChildrenCheckboxState(state, titleShowIndex, titleIndex, indexedData, table) {
        let i = titleShowIndex + 1;
        while (isArray$7(indexedData[i]) && indexedData[i]?.length > titleIndex.length) {
            const row = table.columnHeaderLevelCount + i;
            table.stateManager.setCheckedState(0, row, '_vtable_rowSeries_number', state);
            setCellCheckboxStateByAttribute(0, row, state, table);
            i++;
        }
    }
    function updateGroupTitleCheckboxState(titleShowIndex, titleIndex, indexedData, table) {
        let parentLength = titleIndex.length - 1;
        if (parentLength > 0) {
            let i = titleShowIndex - 1;
            while (parentLength > 0 && i >= 0) {
                if ((isArray$7(indexedData[i]) && indexedData[i]?.length === parentLength) ||
                    (parentLength === 1 && isNumber$4(indexedData[i]))) {
                    const row = table.columnHeaderLevelCount + i;
                    updateParentCheckboxState(0, row, indexedData[i], table);
                    parentLength--;
                }
                i--;
            }
        }
    }
    function updateParentCheckboxState(col, row, currentIndex, table) {
        const { checkedState } = table.stateManager;
        const key = currentIndex.toString();
        const currentIndexLength = isArray$7(currentIndex) ? currentIndex.length : 1;
        let start = false;
        const result = [];
        const keys = Array.from(checkedState.keys()).sort((a, b) => {
            const aArr = a.split(',');
            const bArr = b.split(',');
            const maxLength = Math.max(aArr.length, bArr.length);
            for (let i = 0; i < maxLength; i++) {
                const a = Number(aArr[i]) ?? 0;
                const b = Number(bArr[i]) ?? 0;
                if (a !== b) {
                    return a - b;
                }
            }
            return 0;
        });
        const stateArr = keys.map(key => checkedState.get(key));
        stateArr.forEach((state, i) => {
            const index = keys[i];
            const value = state;
            if (start) {
                const indexData = index.split(',');
                if (indexData.length === currentIndexLength) {
                    start = false;
                }
                else {
                    result.push(value._vtable_rowSeries_number);
                }
            }
            if (index === key) {
                start = true;
            }
        });
        if (result.length === 0) {
            return;
        }
        const allChecked = result.every(item => !!item);
        const allUnChecked = result.every(item => !item);
        if (allChecked) {
            table.stateManager.setCheckedState(col, row, '_vtable_rowSeries_number', true);
            setCellCheckboxStateByAttribute(col, row, true, table);
        }
        else if (allUnChecked) {
            table.stateManager.setCheckedState(col, row, '_vtable_rowSeries_number', false);
            setCellCheckboxStateByAttribute(col, row, false, table);
        }
        else {
            table.stateManager.setCheckedState(col, row, '_vtable_rowSeries_number', 'indeterminate');
            setCellCheckboxStateByAttribute(col, row, 'indeterminate', table);
        }
    }
    function updateChildrenCheckboxState(parentState, currentIndex, table) {
        const { checkedState } = table.stateManager;
        const key = currentIndex.toString();
        const currentIndexLength = isArray$7(currentIndex) ? currentIndex.length : 1;
        let start = false;
        const keys = Array.from(checkedState.keys()).sort((a, b) => {
            const aArr = a.split(',');
            const bArr = b.split(',');
            const maxLength = Math.max(aArr.length, bArr.length);
            for (let i = 0; i < maxLength; i++) {
                const a = Number(aArr[i]) ?? 0;
                const b = Number(bArr[i]) ?? 0;
                if (a !== b) {
                    return a - b;
                }
            }
            return 0;
        });
        const stateArr = keys.map(key => checkedState.get(key));
        stateArr.forEach((state, i) => {
            const index = keys[i];
            const value = state;
            if (start) {
                const indexData = index.split(',');
                if (indexData.length === currentIndexLength) {
                    start = false;
                }
                else {
                    value._vtable_rowSeries_number = parentState;
                }
            }
            if (index === key) {
                start = true;
            }
        });
    }
    function bindHeaderCheckboxChange(table) {
        table.on('checkbox_state_change', args => {
            const { col, row, checked, field } = args;
            if (table.isHeader(col, row)) {
                table.stateManager.setHeaderCheckedState(field, checked);
                const cellType = table.getCellType(col, row);
                if (cellType === 'checkbox') {
                    table.scenegraph.updateCheckboxCellState(col, row, checked);
                }
            }
            else {
                table.stateManager.setCheckedState(col, row, field, checked);
                const cellType = table.getCellType(col, row);
                if (cellType === 'checkbox') {
                    const oldHeaderCheckedState = table.stateManager.headerCheckedState[field];
                    const newHeaderCheckedState = table.stateManager.updateHeaderCheckedState(field, col, row);
                    if (oldHeaderCheckedState !== newHeaderCheckedState) {
                        table.scenegraph.updateHeaderCheckboxCellState(col, row, newHeaderCheckedState);
                    }
                }
            }
        });
    }
    function getHierarchyState(table, col, row) {
        const index = table.getRecordShowIndexByCell(col, row);
        return table.dataSource.getHierarchyState(index);
    }

    function bindButtonClickEvent(table) {
        table.on(TABLE_EVENT_TYPE.CLICK_CELL, (e) => {
            const { col, row, target } = e;
            if (target.name === 'button' && !target.attribute.disable) {
                if (table.hasListeners(TABLE_EVENT_TYPE.BUTTON_CLICK)) {
                    table.fireListeners(TABLE_EVENT_TYPE.BUTTON_CLICK, { col, row, event: e.event });
                }
            }
        });
    }

    function bindIconClickEvent(table) {
        table.on(TABLE_EVENT_TYPE.ICON_CLICK, iconInfo => {
            const { col, row, x, y, funcType, icon, event } = iconInfo;
            const { stateManager } = table;
            if (funcType === IconFuncTypeEnum.dropDown) {
                stateManager.triggerDropDownMenu(col, row, x, y, event);
            }
            else if (funcType === IconFuncTypeEnum.sort) {
                stateManager.triggerSort(col, row, icon, event);
            }
            else if (funcType === IconFuncTypeEnum.frozen) {
                stateManager.triggerFreeze(col, row, icon);
            }
            else if (funcType === IconFuncTypeEnum.drillDown) {
                drillClick(table);
            }
            else if (funcType === IconFuncTypeEnum.collapse || funcType === IconFuncTypeEnum.expand) {
                const isHasSelected = !!stateManager.select.ranges?.length;
                stateManager.updateSelectPos(-1, -1);
                stateManager.endSelectCells(true, isHasSelected);
                table.toggleHierarchyState(col, row);
            }
        });
    }

    function bindDropdownMenuClickEvent(table) {
        table.on(TABLE_EVENT_TYPE.DROPDOWN_MENU_CLICK, () => {
            table.stateManager.hideMenu();
        });
    }

    function bindDBClickAutoColumnWidthEvent(table) {
        table.on(TABLE_EVENT_TYPE.DBLCLICK_CELL, (e) => {
            if (e.federatedEvent) {
                const eventArgsSet = getCellEventArgsSet(e.federatedEvent);
                const resizeCol = table.scenegraph.getResizeColAt(eventArgsSet.abstractPos.x, eventArgsSet.abstractPos.y, eventArgsSet.eventArgs?.targetCell);
                const disableDblclickAutoResizeColWidth = table.options.disableDblclickAutoResizeColWidth ?? table.options.resize?.disableDblclickAutoResizeColWidth;
                if (table.eventManager.checkCellFillhandle(eventArgsSet)) {
                    table.fireListeners(TABLE_EVENT_TYPE.DBLCLICK_FILL_HANDLE, {});
                }
                else if (table._canResizeColumn(resizeCol.col, resizeCol.row) &&
                    resizeCol.col >= 0 &&
                    !disableDblclickAutoResizeColWidth) {
                    table.scenegraph.updateAutoColWidth(resizeCol.col);
                    table.internalProps._widthResizedColMap.add(resizeCol.col);
                    table.scenegraph.updateChartSizeForResizeColWidth(resizeCol.col);
                    const state = table.stateManager;
                    if (state.columnResize.col < state.table.frozenColCount &&
                        !state.table.isPivotTable() &&
                        !state.table.transpose) {
                        state.table.scenegraph.component.setFrozenColumnShadow(state.table.frozenColCount - 1, state.columnResize.isRightFrozen);
                    }
                    const colWidths = [];
                    for (let col = 0; col < table.colCount; col++) {
                        colWidths.push(table.getColWidth(col));
                    }
                    table.fireListeners(TABLE_EVENT_TYPE.RESIZE_COLUMN_END, {
                        col: resizeCol.col,
                        colWidths
                    });
                }
            }
        });
    }

    function rightButtonClickEvent(table) {
        table.on(TABLE_EVENT_TYPE.CONTEXTMENU_CELL, e => {
            const { col, row } = e;
            const ranges = table.getSelectedCellRanges();
            let cellInRange = false;
            if (ranges.length > 0) {
                for (let i = 0; i < ranges.length; i++) {
                    const range = ranges[i];
                    if (col >= range.start.col && col <= range.end.col && row >= range.start.row && row <= range.end.row) {
                        cellInRange = true;
                        break;
                    }
                }
            }
            if (!cellInRange) {
                table.selectCell(col, row);
            }
        });
    }

    class EventManager {
        table;
        isTouchdown;
        isTouchMove;
        touchMovePoints;
        touchSetTimeout;
        touchEnd;
        isLongTouch;
        gesture;
        handleTextStickBindId;
        LastPointerXY;
        LastBodyPointerXY;
        isDown = false;
        isDraging = false;
        scrollYSpeed;
        scrollXSpeed;
        downIcon;
        globalEventListeners = [];
        inertiaScroll;
        bindSparklineHoverEvent;
        _enableTableScroll = true;
        constructor(table) {
            this.table = table;
            this.handleTextStickBindId = [];
            this.inertiaScroll = new InertiaScroll(table.stateManager);
            if (Env.mode === 'node' || table.options.disableInteraction) {
                return;
            }
            this.bindOuterEvent();
            setTimeout(() => {
                this.bindSelfEvent();
            }, 0);
        }
        bindOuterEvent() {
            bindTableGroupListener(this);
            bindContainerDomListener(this);
            bindScrollBarListener(this);
            bindTouchListener(this);
            bindGesture(this);
        }
        updateEventBinder() {
            setTimeout(() => {
                if (this.table.isReleased) {
                    return;
                }
                if (checkHaveTextStick(this.table) && this.handleTextStickBindId?.length === 0) {
                    this.handleTextStickBindId.push(this.table.on(TABLE_EVENT_TYPE.SCROLL, e => {
                        handleTextStick(this.table);
                    }));
                    this.handleTextStickBindId.push(this.table.on(TABLE_EVENT_TYPE.RESIZE_COLUMN_END, e => {
                        handleTextStick(this.table);
                    }));
                    this.handleTextStickBindId.push(this.table.on(TABLE_EVENT_TYPE.RESIZE_ROW_END, e => {
                        handleTextStick(this.table);
                    }));
                }
                else if (!checkHaveTextStick(this.table) && this.handleTextStickBindId) {
                    this.handleTextStickBindId.forEach(id => {
                        this.table.off(id);
                    });
                    this.handleTextStickBindId = [];
                }
                bindSparklineHoverEvent(this.table);
            }, 0);
        }
        bindSelfEvent() {
            if (this.table.isReleased) {
                return;
            }
            bindIconClickEvent(this.table);
            bindDropdownMenuClickEvent(this.table);
            this.updateEventBinder();
            bindMediaClick(this.table);
            bindDBClickAutoColumnWidthEvent(this.table);
            if (this.table.isPivotTable() && checkHaveDrill(this.table)) {
                bindDrillEvent(this.table);
            }
            bindSparklineHoverEvent(this.table);
            bindAxisClickEvent(this.table);
            bindAxisHoverEvent(this.table);
            bindGroupTitleCheckboxChange(this.table);
            bindHeaderCheckboxChange(this.table);
            bindButtonClickEvent(this.table);
            rightButtonClickEvent(this.table);
        }
        dealTableHover(eventArgsSet) {
            if (!eventArgsSet) {
                this.table.stateManager.updateHoverPos(-1, -1);
                return;
            }
            const { eventArgs } = eventArgsSet;
            if (eventArgs) {
                this.table.stateManager.updateHoverPos(eventArgs.col, eventArgs.row);
            }
            else {
                this.table.stateManager.updateHoverPos(-1, -1);
            }
        }
        dealIconHover(eventArgsSet) {
            const { eventArgs } = eventArgsSet;
            if (eventArgs) {
                this.table.stateManager.updateHoverIcon(eventArgs.col, eventArgs.row, eventArgs.target, eventArgs.targetCell);
            }
            else {
                this.table.stateManager.updateHoverIcon(-1, -1, undefined, undefined);
            }
        }
        dealMenuHover(eventArgsSet) {
        }
        dealTableSelect(eventArgsSet, isSelectMoving) {
            if (!eventArgsSet) {
                this.table.stateManager.updateSelectPos(-1, -1);
                return false;
            }
            const { eventArgs } = eventArgsSet;
            if (eventArgs) {
                if (eventArgs.target.name === 'checkbox' ||
                    eventArgs.target.name === 'radio' ||
                    eventArgs.target.name === 'switch' ||
                    eventArgs.target.name === 'button') {
                    return false;
                }
                if (this.table.isHeader(eventArgs.col, eventArgs.row) &&
                    isCellDisableSelect(this.table, eventArgs.col, eventArgs.row)) {
                    if (!isSelectMoving) {
                        this.table.stateManager.updateSelectPos(-1, -1);
                    }
                    return false;
                }
                else if (!this.table.isHeader(eventArgs.col, eventArgs.row) &&
                    isCellDisableSelect(this.table, eventArgs.col, eventArgs.row)) {
                    if (!isSelectMoving) {
                        const isHasSelected = !!this.table.stateManager.select.ranges?.length;
                        this.table.stateManager.updateSelectPos(-1, -1);
                        if (isHasSelected) {
                            this.table.stateManager.endSelectCells(true, isHasSelected);
                        }
                    }
                    return false;
                }
                if (this.table.isPivotChart() &&
                    (eventArgsSet?.eventArgs?.target.name === 'axis-label' || eventArgsSet?.eventArgs?.target.type === 'chart')) {
                    this.table.stateManager.updateSelectPos(-1, -1);
                    return false;
                }
                this.table.stateManager.updateSelectPos(eventArgs.col, eventArgs.row, eventArgs.event.shiftKey, eventArgs.event.ctrlKey || eventArgs.event.metaKey, false, isSelectMoving ? false : this.table.options.select?.makeSelectCellVisible ?? true);
                return true;
            }
            return false;
        }
        dealFillSelect(eventArgsSet, isSelectMoving) {
            const { eventArgs } = eventArgsSet;
            if (eventArgs) {
                if (this.table.stateManager.select?.ranges?.length && this.table.stateManager.isFillHandle()) {
                    let updateRow;
                    let updateCol;
                    const currentRange = this.table.stateManager.select.ranges[this.table.stateManager.select.ranges.length - 1];
                    if (isSelectMoving) {
                        if (!isValid$3(this.table.stateManager.fillHandle.directionRow)) {
                            if (Math.abs(this.table.stateManager.fillHandle.startY - eventArgsSet.abstractPos.y) >=
                                Math.abs(this.table.stateManager.fillHandle.startX - eventArgsSet.abstractPos.x)) {
                                this.table.stateManager.fillHandle.directionRow = true;
                            }
                            else {
                                this.table.stateManager.fillHandle.directionRow = false;
                            }
                        }
                        if (Math.abs(this.table.stateManager.fillHandle.startY - eventArgsSet.abstractPos.y) >=
                            Math.abs(this.table.stateManager.fillHandle.startX - eventArgsSet.abstractPos.x)) {
                            if (this.table.stateManager.fillHandle.startY - eventArgsSet.abstractPos.y > 0) {
                                this.table.stateManager.fillHandle.direction = 'top';
                            }
                            else {
                                this.table.stateManager.fillHandle.direction = 'bottom';
                            }
                        }
                        else {
                            if (this.table.stateManager.fillHandle.startX - eventArgsSet.abstractPos.x > 0) {
                                this.table.stateManager.fillHandle.direction = 'left';
                            }
                            else {
                                this.table.stateManager.fillHandle.direction = 'right';
                            }
                        }
                        if (this.table.stateManager.fillHandle.directionRow) {
                            updateRow = eventArgs.row;
                            updateCol = currentRange.end.col;
                        }
                        else {
                            updateRow = currentRange.end.row;
                            updateCol = eventArgs.col;
                        }
                    }
                    this.table.stateManager.updateSelectPos(isSelectMoving ? updateCol : currentRange.end.col, isSelectMoving ? updateRow : currentRange.end.row, true, eventArgs.event.ctrlKey || eventArgs.event.metaKey, false, !isSelectMoving);
                }
                else {
                    this.table.stateManager.updateSelectPos(eventArgs.col, eventArgs.row, eventArgs.event.shiftKey, eventArgs.event.ctrlKey || eventArgs.event.metaKey, false, !isSelectMoving);
                }
                return true;
            }
            return false;
        }
        deelTableSelectAll() {
            this.table.stateManager.updateSelectPos(-1, -1, false, false, true);
            this.table.fireListeners(TABLE_EVENT_TYPE.SELECTED_CELL, {
                ranges: this.table.stateManager.select.ranges,
                col: 0,
                row: 0
            });
        }
        dealMenuSelect(eventArgsSet) {
        }
        checkColumnResize(eventArgsSet, update) {
            const { eventArgs } = eventArgsSet;
            if (this.table.options.enableTreeStickCell && !eventArgs) {
                return false;
            }
            const resizeCol = this.table.scenegraph.getResizeColAt(eventArgsSet.abstractPos.x, eventArgsSet.abstractPos.y, eventArgs?.targetCell);
            if (this.table._canResizeColumn(resizeCol.col, resizeCol.row) && resizeCol.col >= 0) {
                if (update) {
                    this.table.stateManager.startResizeCol(resizeCol.col, eventArgsSet.abstractPos.x, eventArgsSet.abstractPos.y, resizeCol.rightFrozen);
                }
                return true;
            }
            if (this.table.stateManager.isResizeCol()) {
                this.table.stateManager.endResizeCol();
            }
            return false;
        }
        checkRowResize(eventArgsSet, update) {
            const { eventArgs } = eventArgsSet;
            if (eventArgs) {
                const resizeRow = this.table.scenegraph.getResizeRowAt(eventArgsSet.abstractPos.x, eventArgsSet.abstractPos.y, eventArgs.targetCell);
                if (this.table._canResizeRow(resizeRow.col, resizeRow.row) && resizeRow.row >= 0) {
                    if (update) {
                        this.table.stateManager.startResizeRow(resizeRow.row, eventArgsSet.abstractPos.x, eventArgsSet.abstractPos.y, resizeRow.bottomFrozen);
                    }
                    return true;
                }
            }
            return false;
        }
        cellIsHeaderCheck(eventArgsSet, update) {
            const { eventArgs } = eventArgsSet;
            const { col, row, target } = eventArgs;
            if (!this.table.isHeader(col, row)) {
                return false;
            }
            const cellType = this.table.getCellType(eventArgs.col, eventArgs.row);
            if (cellType === 'checkbox' && target.name === 'checkbox') {
                return true;
            }
            return false;
        }
        checkCellFillhandle(eventArgsSet, update) {
            let isFillHandle = false;
            if (typeof this.table.options.excelOptions?.fillHandle === 'function') {
                isFillHandle = this.table.options.excelOptions.fillHandle({
                    selectRanges: this.table.stateManager.select.ranges,
                    table: this.table
                });
            }
            else {
                isFillHandle = this.table.options.excelOptions?.fillHandle;
            }
            if (isFillHandle) {
                const { eventArgs } = eventArgsSet;
                if (eventArgs) {
                    if (this.table.stateManager.select?.ranges?.length) {
                        const lastCol = Math.max(this.table.stateManager.select.ranges[this.table.stateManager.select.ranges.length - 1].start.col, this.table.stateManager.select.ranges[this.table.stateManager.select.ranges.length - 1].end.col);
                        const lastRow = Math.max(this.table.stateManager.select.ranges[this.table.stateManager.select.ranges.length - 1].start.row, this.table.stateManager.select.ranges[this.table.stateManager.select.ranges.length - 1].end.row);
                        const startCol = Math.min(this.table.stateManager.select.ranges[this.table.stateManager.select.ranges.length - 1].start.col, this.table.stateManager.select.ranges[this.table.stateManager.select.ranges.length - 1].end.col);
                        const startRow = Math.min(this.table.stateManager.select.ranges[this.table.stateManager.select.ranges.length - 1].start.row, this.table.stateManager.select.ranges[this.table.stateManager.select.ranges.length - 1].end.row);
                        let lastCellBound;
                        if (lastCol < this.table.colCount - 1) {
                            lastCellBound = this.table.scenegraph.highPerformanceGetCell(lastCol, lastRow).globalAABBBounds;
                        }
                        else {
                            lastCellBound = this.table.scenegraph.highPerformanceGetCell(startCol - 1, lastRow).globalAABBBounds;
                        }
                        const distanceX = Math.abs(eventArgsSet.abstractPos.x - lastCellBound.x2);
                        if (lastRow < this.table.rowCount - 1) {
                            lastCellBound = this.table.scenegraph.highPerformanceGetCell(lastCol, lastRow).globalAABBBounds;
                        }
                        else {
                            lastCellBound = this.table.scenegraph.highPerformanceGetCell(lastCol, startRow - 1).globalAABBBounds;
                        }
                        const distanceY = Math.abs(eventArgsSet.abstractPos.y - lastCellBound.y2);
                        const squareSize = 6 * 3;
                        if (this.table.stateManager.fillHandle?.isFilling ||
                            (distanceX <= squareSize / 2 && distanceY <= squareSize / 2)) {
                            if (update) {
                                this.table.stateManager.startFillSelect(eventArgsSet.abstractPos.x, eventArgsSet.abstractPos.y);
                            }
                            return true;
                        }
                    }
                }
            }
            return false;
        }
        dealColumnResize(xInTable, yInTable) {
            this.table.stateManager.updateResizeCol(xInTable, yInTable);
        }
        dealRowResize(xInTable, yInTable) {
            this.table.stateManager.updateResizeRow(xInTable, yInTable);
        }
        checkColumnMover(eventArgsSet) {
            const { eventArgs } = eventArgsSet;
            if (eventArgs &&
                this.table._canDragHeaderPosition(eventArgs.col, eventArgs.row)) {
                this.table.stateManager.startMoveCol(eventArgs.col, eventArgs.row, eventArgsSet.abstractPos.x, eventArgsSet.abstractPos.y, eventArgs?.event?.nativeEvent);
                return true;
            }
            return false;
        }
        dealColumnMover(eventArgsSet) {
            const { eventArgs } = eventArgsSet;
            if (isValid$3(eventArgs.col) && isValid$3(eventArgs.row)) {
                this.table.stateManager.updateMoveCol(eventArgs.col, eventArgs.row, eventArgsSet.abstractPos.x, eventArgsSet.abstractPos.y, eventArgs?.event?.nativeEvent);
            }
        }
        startColumnResize(eventArgsSet) {
        }
        dealIconClick(e, eventArgsSet) {
            const { eventArgs } = eventArgsSet;
            const { target, event, col, row } = eventArgs || {
                target: e.target,
                event: e,
                col: -1,
                row: -1
            };
            const icon = target;
            if (icon.role && icon.role.startsWith('icon-')) {
                this.table.fireListeners(TABLE_EVENT_TYPE.ICON_CLICK, {
                    name: icon.name,
                    x: (icon.globalAABBBounds.x1 + icon.globalAABBBounds.x2) / 2,
                    y: icon.globalAABBBounds.y2,
                    col,
                    row,
                    funcType: icon.attribute.funcType,
                    icon,
                    event
                });
                return true;
            }
            else if (target instanceof RichText) {
                const icon = target.pickIcon(event.global);
                if (icon) {
                    this.table.fireListeners(TABLE_EVENT_TYPE.ICON_CLICK, {
                        name: icon.attribute.id,
                        x: icon.globalX + icon.globalAABBBounds.width() / 2,
                        y: icon.globalY + icon.AABBBounds.height(),
                        col,
                        row,
                        funcType: icon.attribute.funcType,
                        icon: icon,
                        event
                    });
                    return true;
                }
            }
            return false;
        }
        release() {
            this.gesture.release();
            this.globalEventListeners.forEach(item => {
                if (item.env === 'document') {
                    document.removeEventListener(item.name, item.callback);
                }
                else if (item.env === 'body') {
                    document.body.removeEventListener(item.name, item.callback);
                }
                else if (item.env === 'window') {
                    window.removeEventListener(item.name, item.callback);
                }
                else if (item.env === 'vglobal') {
                    vglobal.removeEventListener(item.name, item.callback);
                }
            });
            this.globalEventListeners = [];
        }
        enableScroll() {
            this._enableTableScroll = true;
        }
        disableScroll() {
            this._enableTableScroll = false;
        }
    }

    let defaultStyle$4;
    const DEFAULT_BAR_COLOR = (args) => {
        const num = args.value;
        if (Number(num) > 80) {
            return '#20a8d8';
        }
        if (Number(num) > 50) {
            return '#4dbd74';
        }
        if (Number(num) > 20) {
            return '#ffc107';
        }
        return '#f86c6b';
    };
    class ProgressBarStyle extends Style$1 {
        _showBar;
        _barColor;
        _barBgColor;
        _barPositiveColor;
        _barNegativeColor;
        _barAxisColor;
        _barHeight;
        _barBottom;
        _barPadding;
        _showBarMark;
        _barMarkPositiveColor;
        _barMarkNegativeColor;
        _barMarkWidth;
        _barMarkPosition;
        _barRightToLeft;
        _barMarkInBar;
        static get DEFAULT() {
            return defaultStyle$4 ? defaultStyle$4 : (defaultStyle$4 = new ProgressBarStyle());
        }
        constructor(style = {}, bodyStyle = {}) {
            super(style, bodyStyle);
            this._showBar = style.showBar ?? true;
            this._barColor = style.barColor ?? DEFAULT_BAR_COLOR;
            this._barPositiveColor = style.barPositiveColor ?? '#4dbd74';
            this._barNegativeColor = style.barNegativeColor ?? '#f86c6b';
            this._barAxisColor = style.barAxisColor ?? 'black';
            this._barBgColor = style.barBgColor;
            this._barHeight = style.barHeight ?? 3;
            this._barHeight = style.barHeight ?? 3;
            this._barBottom = style.barBottom ?? 0;
            this._barPadding = style.barPadding ?? [0, 0, 0, 0];
            this._showBarMark = style.showBarMark ?? false;
            this._barMarkPositiveColor = style.barMarkPositiveColor ?? '#4dbd74';
            this._barMarkNegativeColor = style.barMarkNegativeColor ?? '#f86c6b';
            this._barMarkWidth = style.barMarkWidth ?? 2;
            this._barMarkPosition = style.barMarkPosition ?? 'right';
            this._barRightToLeft = style.barRightToLeft ?? false;
            this._barMarkInBar = style.barMarkInBar ?? true;
        }
        get showBar() {
            return this._showBar;
        }
        set showBar(value) {
            this._showBar = value;
        }
        get barColor() {
            return this._barColor;
        }
        set barColor(barColor) {
            this._barColor = barColor;
        }
        get barBgColor() {
            return this._barBgColor;
        }
        set barBgColor(barBgColor) {
            this._barBgColor = barBgColor;
        }
        get barHeight() {
            return this._barHeight;
        }
        set barHeight(barHeight) {
            this._barHeight = barHeight;
        }
        get barBottom() {
            return this._barBottom;
        }
        set barBottom(barBottom) {
            this._barBottom = barBottom;
        }
        get barPositiveColor() {
            return this._barPositiveColor;
        }
        set barPositiveColor(barPositiveColor) {
            this._barPositiveColor = barPositiveColor;
        }
        get barNegativeColor() {
            return this._barNegativeColor;
        }
        set barNegativeColor(barNegativeColor) {
            this._barNegativeColor = barNegativeColor;
        }
        get barAxisColor() {
            return this._barAxisColor;
        }
        set barAxisColor(barAxisColor) {
            this._barAxisColor = barAxisColor;
        }
        get barPadding() {
            return this._barPadding;
        }
        set barPadding(barPadding) {
            this._barPadding = barPadding;
        }
        get showBarMark() {
            return this._showBarMark;
        }
        set showBarMark(value) {
            this._showBarMark = value;
        }
        get barMarkPositiveColor() {
            return this._barMarkPositiveColor;
        }
        set barMarkPositiveColor(value) {
            this._barMarkPositiveColor = value;
        }
        get barMarkNegativeColor() {
            return this._barMarkNegativeColor;
        }
        set barMarkNegativeColor(value) {
            this._barMarkNegativeColor = value;
        }
        get barMarkWidth() {
            return this._barMarkWidth;
        }
        set barMarkWidth(value) {
            this._barMarkWidth = value;
        }
        get barMarkPosition() {
            return this._barMarkPosition;
        }
        set barMarkPosition(value) {
            this._barMarkPosition = value;
        }
        get barRightToLeft() {
            return this._barRightToLeft;
        }
        set barRightToLeft(value) {
            this._barRightToLeft = value;
        }
        get barMarkInBar() {
            return this._barMarkInBar;
        }
        set barMarkInBar(value) {
            this._barMarkInBar = value;
        }
        clone() {
            return new ProgressBarStyle(this, null);
        }
    }

    const ICON_PROP_KEYS = [
        'type',
        'content',
        'style',
        'color',
        'width',
        'height',
        'marginRight',
        'marginLeft',
        'src',
        'svg',
        'name',
        'path',
        'positionType',
        'tooltip',
        'hover',
        'cursor',
        'shape',
        'interactive',
        'isGif'
    ];
    const iconPropKeys = ICON_PROP_KEYS;

    class BodyHelper {
        expandIcon;
        collapseIcon;
        _table;
        constructor(_table) {
            this._table = _table;
            const regedIcons = get$2();
            this.expandIcon = regedIcons[InternalIconName.expandIconName];
            this.collapseIcon = regedIcons[InternalIconName.collapseIconName];
        }
        getIcons(col, row, cellValue, dataValue, context) {
            const iconArr = [];
            const hierarchyIcon = this.getHierarchyIcon(col, row);
            if (hierarchyIcon) {
                iconArr.push(hierarchyIcon);
            }
            const { icon: iconDefine } = this._table.getBodyColumnDefine(col, row);
            if (iconDefine) {
                let iconResults;
                if (typeof iconDefine === 'function') {
                    const arg = {
                        col,
                        row,
                        value: cellValue,
                        dataValue,
                        table: this._table
                    };
                    iconResults = iconDefine(arg);
                }
                else {
                    iconResults = iconDefine;
                }
                const regedIcons = get$2();
                const addIcon = (columnIcon) => {
                    let icon;
                    if (typeof columnIcon === 'string') {
                        icon = regedIcons[columnIcon];
                    }
                    else {
                        icon = columnIcon;
                    }
                    if (icon) {
                        iconArr.push(icon);
                    }
                };
                if (Array.isArray(iconResults)) {
                    iconResults.forEach((columnIcon, index) => {
                        addIcon(columnIcon);
                    });
                }
                else {
                    addIcon(iconResults);
                }
            }
            context &&
                iconArr.forEach((i, index) => {
                    if (i.content || i.src) {
                        iconArr[index] = this.getCellIconFromRecordValue(i, col, row);
                    }
                });
            return iconArr;
        }
        getStyleClass(cellType) {
            switch (cellType) {
                case 'text':
                    return TextStyle;
                case 'image':
                    return ImageStyle$1;
                case 'video':
                    return ImageStyle$1;
                case 'link':
                    return TextStyle;
                case 'chart':
                    return Style$1;
                case 'sparkline':
                    return Style$1;
                case 'progressbar':
                    return ProgressBarStyle;
                case 'checkbox':
                    return CheckboxStyle$1;
                case 'radio':
                    return RadioStyle;
                case 'switch':
                    return SwitchStyle;
                case 'button':
                    return ButtonStyle;
            }
            return TextStyle;
        }
        getCellIconFromRecordValue(icon, col, row) {
            if (Array.isArray(icon)) {
                return icon.map(i => this.getCellIconFromRecordValue(i, col, row));
            }
            if (!obj.isObject(icon) || typeof icon === 'function') {
                return this._table.getFieldData(icon, col, row);
            }
            const retIcon = {};
            const iconOpt = icon;
            iconPropKeys.forEach(k => {
                if (typeof iconOpt[k] !== 'undefined') {
                    const f = this._table.getFieldData(iconOpt[k], col, row);
                    if (isValid$3(f)) {
                        retIcon[k] = f;
                    }
                    else if (!this._table._hasField?.(iconOpt[k], col, row)) {
                        retIcon[k] = iconOpt[k];
                    }
                }
            });
            return retIcon;
        }
        getHierarchyIcon(col, row) {
            const hierarchyState = this._table.getHierarchyState(col, row);
            if (hierarchyState === HierarchyState.expand) {
                return this.expandIcon;
            }
            else if (hierarchyState === HierarchyState.collapse) {
                return this.collapseIcon;
            }
            return undefined;
        }
        getHierarchyIconWidth() {
            return this.expandIcon.width + (this.expandIcon.marginLeft ?? 0) + (this.expandIcon.marginRight ?? 0);
        }
    }

    function createElement(tagName, classNames) {
        const element = document.createElement(tagName);
        if (classNames) {
            element.classList.add(...classNames);
        }
        return element;
    }

    function importStyle$1() {
        if (Env.mode === 'node') {
            return;
        }
        const styleElement = document.createElement('style');
        styleElement.id = 'vtable-menu-styleSheet';
        styleElement.textContent = `
@keyframes vtable__menu-element--shown-animation {
	0% {
		opacity: 0;
	}
	100% {
		opacity: 1;
	}
}
.vtable__menu-element {
	position: absolute;
	box-sizing: border-box;
	border-radius: 4px;
	background-color: #fff;
	padding: 6px 0;
	/* pointer-events: none; */
	user-select: none;
	color: #000;
	max-width: 300px;
	z-index: 99999;
	border: #CCC 0.5px solid;
	cursor: default;
	width: max-content;
	box-shadow: 0px 8px 16px rgba(27, 31, 35, 0.12);
  max-height: 100%;
  overflow-y: auto;
}
.vtable__menu-element--hidden {
	opacity: 0;
	/* transform: translate(-50%, -50%); */
	transition: opacity 75ms linear;
	z-index: -9999;
}
.vtable__menu-element--shown {
	opacity: 1;
	/* transform: translate(-50%, -50%); */
	animation: vtable__menu-element--shown-animation 150ms ease-out;
}
.vtable__menu-element__content {
	font-family: Roboto;
	font-size: 12px;
	overflow: hidden;
	display: inline-block;
	/* height: 100%; */
	line-height: 30px;
}
.vtable__menu-element__item {
	height: 32px;
	padding: 0px 12px;
	cursor: pointer;
	position: relative;
	display: flex;
	align-items: center;
	justify-content: flex-start;
}
.vtable__menu-element__item:hover {
	background-color: rgba(27, 31, 35, 0.06);
}
.vtable__menu-element__icon{
	/* vertical-align: top; */
	display: flex;
	/* line-height: 30px; */
	margin-right: 6px;
}
.vtable__menu-element__no-event {
	pointer-events: none;
}
.vtable__menu-element--select {
	color: #2E68CF;
}
.vtable__menu-element--normal {
	color: rgba(20, 20, 20, 0.9);;
}
.vtable__menu-element__item-disabled {
    color: rgba(0, 0, 0, 0.25);
    cursor: not-allowed;
	  background-color: #fff;
}
.vtable__menu-element__item-disabled:hover {
	  background-color: #fff;
}
.vtable__menu-element__split {
	height: 0px;
	border: 1px solid rgb(209, 213, 218);
	margin: 5px 0;
}
.vtable__menu-element__title {
	color: rgb(149, 149, 149);
}
.vtable__menu-element__arrow {
	position: absolute;
	right: 3px;
	font-weight: bold;
	margin-top: 1px;
}
.vtable__menu-element__item-text {
	margin-right: 15px;
}
`;
        document.head.appendChild(styleElement);
    }

    importStyle$1();
    const CLASSNAME$1 = 'vtable__menu-element';
    const ITEM_CLASSNAME = `${CLASSNAME$1}__item`;
    const CONTENT_CLASSNAME = `${CLASSNAME$1}__content`;
    const HIDDEN_CLASSNAME$1 = `${CLASSNAME$1}--hidden`;
    const SHOWN_CLASSNAME$1 = `${CLASSNAME$1}--shown`;
    const NORAML_CLASSNAME = `${CLASSNAME$1}--normal`;
    const SELECT_CLASSNAME = `${CLASSNAME$1}--select`;
    const ICOM_CLASSNAME = `${CLASSNAME$1}__icon`;
    const SPLIT_CLASSNAME = `${CLASSNAME$1}__split`;
    const TITLE_CLASSNAME = `${CLASSNAME$1}__title`;
    const ARROW_CLASSNAME = `${CLASSNAME$1}__arrow`;
    const NOEVENT_CLASSNAME = `${CLASSNAME$1}__no-event`;
    const ITEMTEXT_CLASSNAME = `${CLASSNAME$1}__item-text`;
    const ITEM_DISABLED_CLASSNAME = `${CLASSNAME$1}__item-disabled`;
    function createMenuDomElement$1() {
        const rootElement = createElement('div', [CLASSNAME$1, HIDDEN_CLASSNAME$1]);
        return rootElement;
    }
    function isMenuHighlight(_table, cells, menuKeyCurrent, colCurrent, rowCurrent, index) {
        const cellRange = _table.getCellRange(colCurrent, rowCurrent);
        for (let i = 0; i < cells.length; i++) {
            const highlight = cells[i];
            let { col, row } = highlight;
            const { field, menuKey } = highlight;
            if (typeof col !== 'number' || typeof row !== 'number') {
                if (_table.isPivotTable() && typeof Array.isArray(field)) {
                    const cellAddress = _table.internalProps.layoutMap.getPivotCellAdress(field);
                    if (!cellAddress) {
                        continue;
                    }
                    col = cellAddress.col;
                    row = cellAddress.row;
                }
                else {
                    const cellAddress = _table.internalProps.layoutMap.getHeaderCellAddressByField(field);
                    if (!cellAddress) {
                        continue;
                    }
                    col = cellAddress.col;
                    row = cellAddress.row;
                }
            }
            if (isValid$3(col) && isValid$3(row) && cellInRange(cellRange, col, row)) {
                if (menuKeyCurrent === menuKey) {
                    return true;
                }
            }
        }
        return false;
    }
    class MenuElement {
        _handler;
        _rootElement;
        _secondElement;
        _menuInstanceInfo;
        _showChildrenIndex;
        _mouseEnterSecondElement;
        constructor(table) {
            this._handler = new EventHandler();
            this._rootElement = createMenuDomElement$1();
            this._secondElement = createMenuDomElement$1();
            this._secondElement.sub = true;
            this._showChildrenIndex = -1;
            this._rootElement.addEventListener('wheel', e => {
                e.stopPropagation();
            });
            this._rootElement?.addEventListener('mousedown', e => {
                e.stopPropagation();
                e.preventDefault();
            });
            this._rootElement?.addEventListener('contextmenu', e => {
                e.stopPropagation();
                e.preventDefault();
            });
            this._rootElement?.addEventListener('touchend', e => {
                e.stopPropagation();
                e.preventDefault();
                if (e.target.classList.contains(ITEM_DISABLED_CLASSNAME)) {
                    return;
                }
                if (this._rootElement.classList.contains(HIDDEN_CLASSNAME$1)) {
                    return;
                }
                const { col, row, dropDownIndex, menuKey, text, hasChildren } = e.target;
                if (typeof dropDownIndex !== 'number' || hasChildren) {
                    e.stopPropagation();
                    return;
                }
                const field = table.isPivotTable()
                    ? table.internalProps.layoutMap.getPivotDimensionInfo(col, row)
                    : table.getHeaderField(col, row);
                const highlight = table._dropDownMenuIsHighlight(col, row, dropDownIndex);
                table.fireListeners(TABLE_EVENT_TYPE.DROPDOWN_MENU_CLICK, {
                    col,
                    row,
                    field: field,
                    menuKey,
                    text,
                    highlight,
                    cellLocation: table.getCellLocation(col, row),
                    event: e
                });
                table.fireListeners(TABLE_EVENT_TYPE.DROPDOWN_MENU_CLEAR, null);
                table.fireListeners(TABLE_EVENT_TYPE.HIDE_MENU, null);
                e.stopPropagation();
            });
            this._rootElement?.addEventListener('click', e => {
                e.stopPropagation();
                e.preventDefault();
                if (e.target.classList.contains(ITEM_DISABLED_CLASSNAME)) {
                    return;
                }
                if (this._rootElement.classList.contains(HIDDEN_CLASSNAME$1)) {
                    return;
                }
                const { col, row, dropDownIndex, menuKey, text, hasChildren } = e.target;
                if (typeof dropDownIndex !== 'number' || hasChildren) {
                    e.stopPropagation();
                    return;
                }
                const field = table.isPivotTable()
                    ? table.internalProps.layoutMap.getPivotDimensionInfo(col, row)
                    : table.getHeaderField(col, row);
                const highlight = table._dropDownMenuIsHighlight(col, row, dropDownIndex);
                table.fireListeners(TABLE_EVENT_TYPE.DROPDOWN_MENU_CLICK, {
                    col,
                    row,
                    field: field,
                    menuKey,
                    text,
                    highlight,
                    cellLocation: table.getCellLocation(col, row),
                    event: e
                });
                table.fireListeners(TABLE_EVENT_TYPE.DROPDOWN_MENU_CLEAR, null);
                table.fireListeners(TABLE_EVENT_TYPE.HIDE_MENU, null);
                e.stopPropagation();
            });
            this._rootElement?.addEventListener('mousemove', e => {
                if (this._rootElement.classList.contains(HIDDEN_CLASSNAME$1)) {
                    return;
                }
                e.stopPropagation();
                const { hasChildren, dropDownIndex, col, row, sub } = e.target;
                if (hasChildren) {
                    this._showChildrenIndex = dropDownIndex;
                    const secondElement = this._secondElement;
                    secondElement?.classList.remove(HIDDEN_CLASSNAME$1);
                    secondElement?.classList.add(SHOWN_CLASSNAME$1);
                    secondElement.innerHTML = '';
                    const children = this._menuInstanceInfo.content[dropDownIndex]?.children;
                    for (let i = 0; i < children.length; i++) {
                        const menuItem = children[i];
                        const isHighlight = table.stateManager.menu.dropDownMenuHighlight
                            ? isMenuHighlight(table, table.stateManager.menu.dropDownMenuHighlight, typeof menuItem === 'object' ? menuItem?.menuKey || menuItem?.text : menuItem, col, row)
                            : false;
                        const item = createItem(menuItem, isHighlight);
                        item.col = col;
                        item.row = row;
                        item.dropDownIndex = i;
                        if (typeof menuItem === 'string') {
                            item.text = menuItem;
                            item.menuKey = menuItem;
                        }
                        else if (typeof menuItem === 'object') {
                            item.text = menuItem.text;
                            item.menuKey = menuItem.menuKey || menuItem.text;
                        }
                        item.sub = true;
                        item.sub = true;
                        secondElement.appendChild(item);
                    }
                    const rect = e.target.getBoundingClientRect();
                    this._bindSecondElement(table, col, row, rect.right, rect.top);
                }
                else if (hasChildren && this._showChildrenIndex === dropDownIndex) {
                    const secondElement = this._secondElement;
                    secondElement?.classList.remove(HIDDEN_CLASSNAME$1);
                    secondElement?.classList.add(SHOWN_CLASSNAME$1);
                }
                else if (!sub && this._secondElement?.classList.contains(SHOWN_CLASSNAME$1)) {
                    setTimeout(() => {
                        if (this._mouseEnterSecondElement !== true) {
                            this._showChildrenIndex = -1;
                            const secondElement = this._secondElement;
                            secondElement?.classList.remove(SHOWN_CLASSNAME$1);
                            secondElement?.classList.add(HIDDEN_CLASSNAME$1);
                        }
                    }, 300);
                }
            });
            this._secondElement?.addEventListener('wheel', e => {
                e.stopPropagation();
            });
            this._secondElement?.addEventListener('mousemove', e => {
                if (this._rootElement.classList.contains(HIDDEN_CLASSNAME$1)) {
                    return;
                }
                e.stopPropagation();
            });
            this._secondElement?.addEventListener('mouseenter', e => {
                this._mouseEnterSecondElement = true;
            });
            this._secondElement?.addEventListener('mouseleave', e => {
                this._mouseEnterSecondElement = false;
            });
            this._secondElement?.addEventListener('mousedown', e => {
                e.stopPropagation();
                e.preventDefault();
            });
            this._secondElement?.addEventListener('click', e => {
                e.stopPropagation();
                e.preventDefault();
                if (e.target.classList.contains(ITEM_DISABLED_CLASSNAME)) {
                    return;
                }
                if (this._secondElement.classList.contains(HIDDEN_CLASSNAME$1)) {
                    return;
                }
                const { col, row, dropDownIndex, menuKey, text, hasChildren } = e.target;
                if (typeof dropDownIndex !== 'number' || hasChildren) {
                    e.stopPropagation();
                    return;
                }
                const field = table.isPivotTable()
                    ? table.internalProps.layoutMap.getPivotDimensionInfo(col, row)
                    : table.getHeaderField(col, row);
                let highlight = false;
                const menus = this._menuInstanceInfo.content;
                menus.forEach((menu, i) => {
                    if (typeof menu === 'object' && menu.children && menu.children.length) {
                        for (let j = 0; j < menu.children.length; j++) {
                            const childItem = menu.children[j];
                            if (isMenuHighlight(table, table.stateManager.menu.dropDownMenuHighlight, typeof childItem === 'object' ? childItem?.menuKey : childItem, col, row) &&
                                menuKey === (typeof childItem === 'object' ? childItem?.menuKey : childItem)) {
                                highlight = true;
                                return;
                            }
                        }
                    }
                });
                table.fireListeners(TABLE_EVENT_TYPE.DROPDOWN_MENU_CLICK, {
                    col,
                    row,
                    field: field,
                    cellHeaderPaths: table.isPivotTable() ? table.getCellHeaderPaths(col, row) : undefined,
                    menuKey,
                    text,
                    highlight,
                    cellLocation: table.getCellLocation(col, row),
                    event: e
                });
                table.fireListeners(TABLE_EVENT_TYPE.DROPDOWN_MENU_CLEAR, null);
                table.fireListeners(TABLE_EVENT_TYPE.HIDE_MENU, null);
                e.stopPropagation();
            });
        }
        get rootElement() {
            return this._rootElement;
        }
        release() {
            this.unbindFromCell();
            const rootElement = this._rootElement;
            if (rootElement?.parentElement) {
                rootElement.parentElement.removeChild(rootElement);
            }
            this._handler.release();
            delete this._rootElement;
        }
        bindToCell(table, col, row, menuInstanceInfo) {
            const rootElement = this._rootElement;
            const secondElement = this._secondElement;
            this._menuInstanceInfo = menuInstanceInfo;
            rootElement?.classList.remove(SHOWN_CLASSNAME$1);
            rootElement?.classList.add(HIDDEN_CLASSNAME$1);
            secondElement?.classList.remove(SHOWN_CLASSNAME$1);
            secondElement?.classList.add(HIDDEN_CLASSNAME$1);
            if (this._canBindToCell(table, col, row)) {
                rootElement.innerHTML = '';
                if (Array.isArray(menuInstanceInfo.content)) {
                    const menuListItem = menuInstanceInfo.content;
                    for (let i = 0; i < menuListItem?.length ?? 0; i++) {
                        const menuItem = menuListItem[i];
                        let isHighlight = table.stateManager.menu.dropDownMenuHighlight
                            ? isMenuHighlight(table, table.stateManager.menu.dropDownMenuHighlight, typeof menuItem === 'object' ? menuItem?.menuKey || menuItem?.text : menuItem, col, row)
                            : false;
                        if (table.stateManager.menu.dropDownMenuHighlight &&
                            typeof menuItem === 'object' &&
                            Array.isArray(menuItem.children) &&
                            menuItem.children.length) {
                            for (let i = 0; i < menuItem.children.length; i++) {
                                const childItem = menuItem.children[i];
                                if (isMenuHighlight(table, table.stateManager.menu.dropDownMenuHighlight, typeof childItem === 'object' ? childItem?.menuKey || childItem?.text : childItem, col, row)) {
                                    isHighlight = true;
                                    break;
                                }
                            }
                        }
                        const item = createItem(menuItem, isHighlight);
                        item.col = col;
                        item.row = row;
                        item.dropDownIndex = i;
                        if (typeof menuItem === 'string') {
                            item.text = menuItem;
                            item.menuKey = menuItem;
                        }
                        else if (typeof menuItem === 'object') {
                            item.text = menuItem.text;
                            item.menuKey = menuItem.menuKey || menuItem.text;
                            if (menuItem.children?.length) {
                                item.hasChildren = true;
                            }
                        }
                        rootElement.appendChild(item);
                    }
                }
                const binded = this._bindToCell(table, col, row, menuInstanceInfo.position, menuInstanceInfo.referencePosition);
                if (binded) {
                    rootElement?.classList.add(SHOWN_CLASSNAME$1);
                    rootElement?.classList.remove(HIDDEN_CLASSNAME$1);
                    return true;
                }
            }
            else {
                this.unbindFromCell();
            }
            return false;
        }
        unbindFromCell() {
            const rootElement = this._rootElement;
            const secondElement = this._secondElement;
            this._menuInstanceInfo = undefined;
            if (rootElement?.parentElement) {
                rootElement.classList.remove(SHOWN_CLASSNAME$1);
                rootElement.classList.add(HIDDEN_CLASSNAME$1);
            }
            if (secondElement?.parentElement) {
                secondElement.classList.remove(SHOWN_CLASSNAME$1);
                secondElement.classList.add(HIDDEN_CLASSNAME$1);
            }
        }
        _canBindToCell(table, col, row) {
            const rect = table.getCellRangeRelativeRect({ col, row });
            const element = table.internalProps.menu.parentElement ?? table.getElement();
            const { top, bottom, left, right } = rect;
            if (table.isFrozenCell(col, row)) {
                return true;
            }
            else if (bottom < table.getFrozenRowsHeight() ||
                right < table.getFrozenColsWidth() ||
                left > table.tableNoFrameWidth - table.getRightFrozenColsWidth() ||
                top > table.tableNoFrameHeight - table.getBottomFrozenRowsHeight()) {
                return false;
            }
            const { offsetHeight, offsetWidth } = element;
            if (offsetHeight < top) {
                return false;
            }
            if (offsetWidth < left) {
                return false;
            }
            return true;
        }
        _bindToCell(table, col, row, position, referencePosition) {
            const rootElement = this._rootElement;
            const element = table.internalProps.menu.parentElement ?? table.getElement();
            const { width: containerWidth, height: containerHeight, left: containerLeft, top: containerTop } = element.getBoundingClientRect();
            if (rootElement) {
                if (rootElement.parentElement !== element) {
                    element.appendChild(rootElement);
                }
                rootElement.style.left = `0px`;
                const maxWidth = containerWidth * 0.8;
                rootElement.style.maxWidth = `${maxWidth}px`;
                const rootElementWidth = rootElement.offsetWidth;
                const rootElementHeight = rootElement.offsetHeight;
                let rootElementLeft;
                let rootElementTop;
                if (position) {
                    rootElementLeft = position.x;
                    rootElementTop = position.y;
                }
                else if (referencePosition) {
                    rootElementLeft = referencePosition.rect.right - rootElementWidth;
                    rootElementTop = referencePosition.rect.bottom;
                }
                const rect = element.getBoundingClientRect();
                const scaleX = rect.width / element.offsetWidth;
                const scaleY = rect.height / element.offsetHeight;
                if (rootElementTop * scaleY + rootElementHeight > containerHeight) {
                    rootElementTop = (containerHeight - rootElementHeight) / scaleY;
                }
                if (rootElementTop < 0) {
                    rootElementTop = rootElementTop / 2;
                }
                let deltaTop = 0;
                let deltaLeft = 0;
                if (table.getElement() !== element) {
                    const { left, top } = table.getElement().getBoundingClientRect();
                    deltaTop = top - containerTop;
                    deltaLeft = left - containerLeft;
                }
                rootElement.style.top = `${rootElementTop + deltaTop}px`;
                if (rootElementLeft < 0) {
                    rootElementLeft = 0;
                }
                else if (rootElementLeft * scaleX + rootElementWidth > containerWidth) {
                    rootElementLeft = (containerWidth - rootElementWidth) / scaleX;
                }
                rootElement.style.left = `${rootElementLeft + deltaLeft}px`;
                return true;
            }
            return false;
        }
        _bindSecondElement(table, col, row, x, y) {
            const secondElement = this._secondElement;
            const rootElement = this._rootElement;
            const element = table.internalProps.menu.parentElement ?? table.getElement();
            const { width: containerWidth, left: containerLeft, top: containerTop } = element.getBoundingClientRect();
            const { x: rootLeft, y: rootTop, width: rootWidth } = rootElement.getBoundingClientRect();
            if (secondElement) {
                if (secondElement.parentElement !== element) {
                    element.appendChild(secondElement);
                }
                secondElement.style.left = `0px`;
                const maxWidth = containerWidth * 0.8;
                secondElement.style.maxWidth = `${maxWidth}px`;
                const secondElementWidth = secondElement.clientWidth;
                const secondElementTop = y - 4 - containerTop;
                const secondElementLeft = x - containerLeft;
                secondElement.style.top = `${secondElementTop}px`;
                let leftStyle = secondElementLeft;
                if (leftStyle + secondElementWidth > containerWidth) {
                    leftStyle = leftStyle - secondElementWidth - rootWidth;
                }
                else {
                    leftStyle += 4;
                }
                secondElement.style.left = `${leftStyle}px`;
                return true;
            }
            return false;
        }
        pointInMenuElement(x, y) {
            const rootElement = this._rootElement;
            const { x: rootLeft, y: rootTop, width: rootWidth, height: rootHeight } = rootElement.getBoundingClientRect();
            if (x > rootLeft - 5 && x < rootLeft + rootWidth + 5 && y > rootTop - 5 && y < rootTop + rootHeight + 5) {
                return true;
            }
            const secondElement = this._secondElement;
            if (secondElement) {
                const { x: secondLeft, y: secondTop, width: secondWidth, height: secondHeight } = secondElement.getBoundingClientRect();
                if (x > secondLeft - 5 &&
                    x < secondLeft + secondWidth + 5 &&
                    y > secondTop - 5 &&
                    y < secondTop + secondHeight + 5) {
                    return true;
                }
            }
            return false;
        }
    }
    function createItem(info, isHighlight) {
        const itemContainer = createElement('div', [
            ITEM_CLASSNAME,
            isHighlight ? SELECT_CLASSNAME : NORAML_CLASSNAME
        ]);
        if (typeof info === 'object' && info.disabled) {
            itemContainer.classList.add(ITEM_DISABLED_CLASSNAME);
        }
        if (typeof info === 'string') {
            const item = createElement('span', [CONTENT_CLASSNAME, NOEVENT_CLASSNAME, ITEMTEXT_CLASSNAME]);
            item.innerHTML = info;
            itemContainer.appendChild(item);
        }
        else if (typeof info === 'object') {
            const type = info.type ?? 'item';
            if (type === 'split') {
                itemContainer?.classList.add(SPLIT_CLASSNAME);
                return itemContainer;
            }
            if (info?.icon?.svg) {
                if (regUrl.test(info.icon.svg)) {
                    const image = new Image();
                    if (info.icon.width) {
                        image.style.width = info.icon.width.toString() + 'px';
                    }
                    else {
                        image.style.width = '16px';
                    }
                    if (info.icon.height) {
                        image.style.height = info.icon.height.toString() + 'px';
                    }
                    else {
                        image.style.height = '16px';
                    }
                    image.src = info.icon.svg;
                    itemContainer.appendChild(image);
                }
                else {
                    const svg = createElement('span', [ICOM_CLASSNAME, NOEVENT_CLASSNAME]);
                    svg.innerHTML =
                        isHighlight && info.selectedIcon && info.selectedIcon.svg ? info.selectedIcon.svg : info.icon.svg;
                    info.icon.width && svg.children[0].setAttribute('width', info.icon.width.toString());
                    info.icon.height && svg.children[0].setAttribute('height', info.icon.height.toString());
                    itemContainer.appendChild(svg);
                }
            }
            const item = createElement('span', [CONTENT_CLASSNAME, NOEVENT_CLASSNAME, ITEMTEXT_CLASSNAME]);
            item.innerHTML = info.text;
            itemContainer.appendChild(item);
            if (type === 'title') {
                itemContainer?.classList.add(NOEVENT_CLASSNAME, TITLE_CLASSNAME);
            }
            else if (info?.children?.length) {
                const arrow = createElement('span', [CONTENT_CLASSNAME, NOEVENT_CLASSNAME, ARROW_CLASSNAME]);
                arrow.innerHTML = isHighlight
                    ? '<svg width="8" height="12" viewBox="0 0 10 17" fill="none" xmlns="http://www.w3.org/2000/svg" style="vertical-align: baseline"><path d="M1.78186 16.7729L0.300378 15.2915L6.8189 8.77295L0.300377 2.25443L1.78186 0.77295L9.78186 8.77295L1.78186 16.7729Z" fill="#2E68CF" fill-opacity="0.65"></path></svg>'
                    : '<svg width="8" height="12" viewBox="0 0 10 17" fill="none" xmlns="http://www.w3.org/2000/svg" style="vertical-align: baseline"><path d="M1.78186 16.7729L0.300378 15.2915L6.8189 8.77295L0.300377 2.25443L1.78186 0.77295L9.78186 8.77295L1.78186 16.7729Z" fill="#141414" fill-opacity="0.65"></path></svg>';
                itemContainer.appendChild(arrow);
            }
        }
        return itemContainer;
    }

    let defaultStyle$3;
    const EVENT_TYPE = {
        CHANGE_STYLE: 'change_style'
    };
    class Style extends EventTarget$1 {
        _color;
        _strokeColor;
        _fontSize;
        _fontFamily;
        _fontWeight;
        _fontVariant;
        _fontStyle;
        _textOverflow;
        _padding;
        _defaultPadding = [10, 16, 10, 16];
        _textStick;
        _textStickBaseOnAlign;
        _marked;
        _textAlign;
        _textBaseline;
        _bgColor;
        _borderColor;
        _lineHeight;
        _underline;
        _underlineColor;
        _underlineDash;
        _underlineOffset;
        _lineThrough;
        _lineThroughColor;
        _lineThroughDash;
        _linkColor;
        _cursor;
        _borderLineWidth;
        _borderLineDash;
        static get EVENT_TYPE() {
            return EVENT_TYPE;
        }
        static get DEFAULT() {
            return defaultStyle$3 ? defaultStyle$3 : (defaultStyle$3 = new Style());
        }
        constructor(style = {}, headerStyle = {}) {
            super();
            this._color = style.color ?? headerStyle?.color;
            this._strokeColor = style?.strokeColor ?? headerStyle?.strokeColor;
            this._fontSize = style.fontSize ?? headerStyle?.fontSize;
            this._fontFamily = style.fontFamily ?? headerStyle?.fontFamily;
            this._fontWeight = style.fontWeight ?? headerStyle?.fontWeight;
            this._fontVariant = style.fontVariant ?? headerStyle?.fontVariant;
            this._fontStyle = style.fontStyle ?? headerStyle?.fontStyle;
            this._textOverflow = (style.textOverflow ?? headerStyle?.textOverflow) || 'ellipsis';
            this._textStick = style.textStick ?? headerStyle?.textStick ?? false;
            this._textStickBaseOnAlign = style.textStickBaseOnAlign ?? headerStyle?.textStickBaseOnAlign ?? false;
            this._marked = style.marked ?? headerStyle?.marked ?? false;
            this._textAlign = (style.textAlign ?? headerStyle?.textAlign) || 'left';
            this._textBaseline = (style.textBaseline ?? headerStyle?.textBaseline) || 'middle';
            this._bgColor = style.bgColor ?? headerStyle?.bgColor;
            this._padding = style.padding ?? headerStyle?.padding ?? this._defaultPadding;
            this._borderColor = style.borderColor ?? headerStyle?.borderColor;
            this._lineHeight = style.lineHeight ?? headerStyle?.lineHeight;
            this._underline = style.underline ?? headerStyle?.underline;
            this._underlineColor = style.underlineColor ?? headerStyle?.underlineColor;
            this._underlineDash = style.underlineDash ?? headerStyle?.underlineDash;
            this._underlineOffset = style.underlineOffset ?? headerStyle?.underlineOffset;
            this._lineThrough = style.lineThrough ?? headerStyle?.lineThrough;
            this._lineThroughColor = style.lineThroughColor ?? headerStyle?.lineThroughColor;
            this._lineThroughDash = style.lineThroughDash ?? headerStyle?.lineThroughDash;
            this._linkColor = style.linkColor ?? headerStyle?.linkColor;
            this._cursor = style.cursor ?? headerStyle?.cursor;
            this._borderLineWidth = style.borderLineWidth ?? headerStyle?.borderLineWidth;
            this._borderLineDash = style.borderLineDash ?? headerStyle?.borderLineDash;
        }
        get bgColor() {
            return this._bgColor;
        }
        set bgColor(bgColor) {
            this._bgColor = bgColor;
        }
        get color() {
            return this._color;
        }
        set color(color) {
            this._color = color;
        }
        get strokeColor() {
            return this._strokeColor;
        }
        set strokeColor(strokeColor) {
            this._strokeColor = strokeColor;
        }
        get fontSize() {
            return this._fontSize;
        }
        set fontSize(fontSize) {
            this._fontSize = fontSize;
        }
        get fontFamily() {
            return this._fontFamily;
        }
        set fontFamily(fontFamily) {
            this._fontFamily = fontFamily;
        }
        get fontWeight() {
            return this._fontWeight;
        }
        set fontWeight(fontWeight) {
            this._fontWeight = fontWeight;
        }
        get fontVariant() {
            return this._fontVariant;
        }
        set fontVariant(fontVariant) {
            this._fontVariant = fontVariant;
        }
        get fontStyle() {
            return this._fontStyle;
        }
        set fontStyle(fontStyle) {
            this._fontStyle = fontStyle;
        }
        get textOverflow() {
            return this._textOverflow;
        }
        set textOverflow(textOverflow) {
            this._textOverflow = textOverflow;
        }
        get padding() {
            return this._padding ?? this._defaultPadding;
        }
        set padding(padding) {
            this._padding = padding;
        }
        get borderColor() {
            return this._borderColor;
        }
        set borderColor(borderColor) {
            this._borderColor = borderColor;
        }
        get textStick() {
            return this._textStick;
        }
        set textStick(textStick) {
            this._textStick = textStick;
        }
        get textStickBaseOnAlign() {
            return this._textStickBaseOnAlign;
        }
        set textStickBaseOnAlign(textStickBaseOnAlign) {
            this._textStickBaseOnAlign = textStickBaseOnAlign;
        }
        get marked() {
            return this._marked;
        }
        set marked(marked) {
            this._marked = marked;
        }
        get textAlign() {
            return this._textAlign;
        }
        set textAlign(textAlign) {
            this._textAlign = textAlign;
        }
        get textBaseline() {
            return this._textBaseline;
        }
        set textBaseline(textBaseline) {
            this._textBaseline = textBaseline;
        }
        get lineHeight() {
            return this._lineHeight;
        }
        set lineHeight(lineHeight) {
            this._lineHeight = lineHeight;
        }
        get underline() {
            return this._underline;
        }
        set underline(underline) {
            this._underline = underline;
        }
        get underlineColor() {
            return this._underlineColor;
        }
        set underlineColor(underlineColor) {
            this._underlineColor = underlineColor;
        }
        get underlineDash() {
            return this._underlineDash;
        }
        set underlineDash(underlineDash) {
            this._underlineDash = underlineDash;
        }
        get underlineOffset() {
            return this._underlineOffset;
        }
        set underlineOffset(underlineOffset) {
            this._underlineOffset = underlineOffset;
        }
        get lineThrough() {
            return this._lineThrough;
        }
        set lineThrough(lineThrough) {
            this._lineThrough = lineThrough;
        }
        get lineThroughColor() {
            return this._lineThroughColor;
        }
        set lineThroughColor(lineThroughColor) {
            this._lineThroughColor = lineThroughColor;
        }
        get lineThroughDash() {
            return this._lineThroughDash;
        }
        set lineThroughDash(lineThroughDash) {
            this._lineThroughDash = lineThroughDash;
        }
        get linkColor() {
            return this._linkColor;
        }
        set linkColor(linkColor) {
            this._linkColor = linkColor;
        }
        get cursor() {
            return this._cursor;
        }
        set cursor(cursor) {
            this._cursor = cursor;
        }
        get borderLineWidth() {
            return this._borderLineWidth;
        }
        set borderLineWidth(borderLineWidth) {
            this._borderLineWidth = borderLineWidth;
        }
        get borderLineDash() {
            return this._borderLineDash;
        }
        set borderLineDash(borderLineDash) {
            this._borderLineDash = borderLineDash;
        }
        clone() {
            return new Style(this);
        }
    }

    let defaultStyle$2;
    class ImageStyle extends Style {
        static get DEFAULT() {
            return defaultStyle$2 ? defaultStyle$2 : (defaultStyle$2 = new ImageStyle());
        }
        constructor(style = {}, headerStyle = {}) {
            super(style, headerStyle);
            this.textAlign = (style.textAlign ?? headerStyle?.textAlign) || 'center';
        }
        clone() {
            return new ImageStyle(this);
        }
    }

    let defaultStyle$1;
    class TextHeaderStyle extends Style {
        _autoWrapText;
        _lineClamp;
        static get DEFAULT() {
            return defaultStyle$1 ? defaultStyle$1 : (defaultStyle$1 = new TextHeaderStyle());
        }
        constructor(style = {}, headerStyle = null) {
            super(style, headerStyle);
            this._autoWrapText = style?.autoWrapText ?? headerStyle?.autoWrapText;
            this._lineClamp = style?.lineClamp ?? headerStyle?.lineClamp;
        }
        clone() {
            return new TextHeaderStyle(this, null);
        }
        get lineClamp() {
            return this._lineClamp;
        }
        set lineClamp(lineClamp) {
            this._lineClamp = lineClamp;
        }
        get autoWrapText() {
            return this._autoWrapText;
        }
        set autoWrapText(autoWrapText) {
            this._autoWrapText = autoWrapText;
        }
    }

    let defaultStyle;
    class CheckboxStyle extends Style {
        _size;
        _spaceBetweenTextAndIcon;
        _defaultFill;
        _defaultStroke;
        _disableFill;
        _checkedFill;
        _checkedStroke;
        _disableCheckedFill;
        _disableCheckedStroke;
        _checkIconImage;
        _indeterminateIconImage;
        static get DEFAULT() {
            return defaultStyle ? defaultStyle : (defaultStyle = new CheckboxStyle());
        }
        constructor(style = {}, headerStyle = {}, checkboxThemeStyle = {}) {
            super(style, headerStyle);
            this._size = (style?.size ?? headerStyle?.size ?? checkboxThemeStyle?.size) || 14;
            this._spaceBetweenTextAndIcon =
                (style?.spaceBetweenTextAndIcon ??
                    headerStyle?.spaceBetweenTextAndIcon ??
                    checkboxThemeStyle?.spaceBetweenTextAndIcon) ||
                    8;
            this._defaultFill = style?.checkboxStyle?.defaultFill ?? checkboxThemeStyle?.defaultFill;
            this._defaultStroke = style?.checkboxStyle?.defaultStroke ?? checkboxThemeStyle?.defaultStroke;
            this._disableFill = style?.checkboxStyle?.disableFill ?? checkboxThemeStyle?.disableFill;
            this._checkedFill = style?.checkboxStyle?.checkedFill ?? checkboxThemeStyle?.checkedFill;
            this._checkedStroke = style?.checkboxStyle?.checkedStroke ?? checkboxThemeStyle?.checkedStroke;
            this._disableCheckedFill = style?.checkboxStyle?.disableCheckedFill ?? checkboxThemeStyle?.disableCheckedFill;
            this._disableCheckedStroke = style?.checkboxStyle?.disableCheckedStroke ?? checkboxThemeStyle?.disableCheckedStroke;
            this._checkIconImage = style?.checkboxStyle?.checkIconImage ?? checkboxThemeStyle?.checkIconImage;
            this._indeterminateIconImage =
                style?.checkboxStyle?.indeterminateIconImage ?? checkboxThemeStyle?.indeterminateIconImage;
        }
        get size() {
            return this._size;
        }
        set size(size) {
            this._size = size;
        }
        get spaceBetweenTextAndIcon() {
            return this._spaceBetweenTextAndIcon;
        }
        set spaceBetweenTextAndIcon(spaceBetweenTextAndIcon) {
            this._spaceBetweenTextAndIcon = spaceBetweenTextAndIcon;
        }
        get defaultFill() {
            return this._defaultFill;
        }
        set defaultFill(defaultFill) {
            this._defaultFill = defaultFill;
        }
        get defaultStroke() {
            return this._defaultStroke;
        }
        set defaultStroke(defaultStroke) {
            this._defaultStroke = defaultStroke;
        }
        get disableFill() {
            return this._disableFill;
        }
        set disableFill(disableFill) {
            this._disableFill = disableFill;
        }
        get checkedFill() {
            return this._checkedFill;
        }
        set checkedFill(checkedFill) {
            this._checkedFill = checkedFill;
        }
        get checkedStroke() {
            return this._checkedStroke;
        }
        set checkedStroke(checkedStroke) {
            this._checkedStroke = checkedStroke;
        }
        get disableCheckedFill() {
            return this._disableCheckedFill;
        }
        set disableCheckedFill(disableCheckedFill) {
            this._disableCheckedFill = disableCheckedFill;
        }
        get disableCheckedStroke() {
            return this._disableCheckedStroke;
        }
        set disableCheckedStroke(disableCheckedStroke) {
            this._disableCheckedStroke = disableCheckedStroke;
        }
        get checkIconImage() {
            return this._checkIconImage;
        }
        set checkIconImage(checkIconImage) {
            this._checkIconImage = checkIconImage;
        }
        get indeterminateIconImage() {
            return this._indeterminateIconImage;
        }
        set indeterminateIconImage(indeterminateIconImage) {
            this._indeterminateIconImage = indeterminateIconImage;
        }
        getStyle(style) {
            return new CheckboxStyle(style, this);
        }
        clone() {
            return new CheckboxStyle(this);
        }
    }

    function of(headerStyle, defaultHeaderStyle, styleArg, StyleClass, globalAutoWrapText, theme) {
        if (headerStyle || defaultHeaderStyle) {
            if (headerStyle instanceof Style) {
                return headerStyle;
            }
            else if (typeof headerStyle === 'function') {
                return of(headerStyle(styleArg), defaultHeaderStyle, styleArg, StyleClass, globalAutoWrapText, theme);
            }
            if (!headerStyle) {
                headerStyle = {};
            }
            if (globalAutoWrapText && !isValid$3(headerStyle.autoWrapText)) {
                headerStyle.autoWrapText = true;
            }
            if (StyleClass === CheckboxStyle) {
                return new CheckboxStyle(headerStyle ?? {}, (defaultHeaderStyle ?? {}), (theme.checkboxStyle ?? {}));
            }
            return new StyleClass(headerStyle ?? {}, (defaultHeaderStyle ?? {}));
        }
        return StyleClass.DEFAULT;
    }

    class HeaderHelper {
        normalIcon;
        upIcon;
        downIcon;
        freezeIcon;
        frozenIcon;
        frozenCurrentIcon;
        dropDownAbsoluteIcon;
        expandIcon;
        collapseIcon;
        _table;
        constructor(_table) {
            this._table = _table;
            const regedIcons = get$2();
            this.freezeIcon = regedIcons[InternalIconName.freezeIconName];
            this.frozenIcon = regedIcons[InternalIconName.frozenIconName];
            this.frozenCurrentIcon = regedIcons[InternalIconName.frozenCurrentIconName];
            this.normalIcon = regedIcons[InternalIconName.normalIconName];
            this.upIcon = regedIcons[InternalIconName.upwardIconName];
            this.downIcon = regedIcons[InternalIconName.downwardIconName];
            this.dropDownAbsoluteIcon = regedIcons[InternalIconName.dropdownIconName];
            this.expandIcon = regedIcons[InternalIconName.expandIconName];
            this.collapseIcon = regedIcons[InternalIconName.collapseIconName];
        }
        getIcons(col, row) {
            const icons = [];
            if (this._table.isPivotTable()) {
                const { showSort, sort } = this._table.internalProps.layoutMap.getHeader(col, row);
                let _showSort;
                if (typeof showSort === 'function') {
                    _showSort = showSort({ col, row, table: this._table });
                }
                else {
                    _showSort = showSort;
                }
                if (_showSort) {
                    let order = this._table.getPivotSortState(col, row);
                    if (order) {
                        order = order.toUpperCase();
                    }
                    const sortIcon = order === 'ASC' ? this.upIcon : order === 'DESC' ? this.downIcon : this.normalIcon;
                    if (sortIcon) {
                        icons.push(sortIcon);
                    }
                }
                else if (sort) {
                    const sortIcon = this.getSortIconForPivotTable(this._table.getPivotSortState(col, row), this._table, col, row);
                    if (sortIcon) {
                        icons.push(sortIcon);
                    }
                }
            }
            else {
                const states = this._table.sortState;
                let order;
                order = undefined;
                const range = this._table.getCellRange(col, row);
                if (states) {
                    if (Array.isArray(states)) {
                        for (let i = 0; i < states.length; i++) {
                            const state = states[i];
                            const stateRange = this._table._getHeaderCellBySortState(state);
                            if (stateRange && cellInRange(range, stateRange.col, stateRange.row)) {
                                ({ order } = state);
                                break;
                            }
                        }
                    }
                    else {
                        const stateRange = this._table._getHeaderCellBySortState(states);
                        if (stateRange && cellInRange(range, stateRange.col, stateRange.row)) {
                            ({ order } = states);
                        }
                    }
                }
                const sortIcon = this.getSortIcon(order, this._table, col, row);
                if (sortIcon) {
                    icons.push(sortIcon);
                }
            }
            if (this._table.showFrozenIcon && col < this._table.allowFrozenColCount) {
                const pinInline = this.getFrozenIcon(col, row);
                if (pinInline) {
                    icons.push(pinInline);
                }
            }
            if (this.checkDropDownIcon(this._table, col, row)) {
                const dropDownMenuIcon = this.dropDownAbsoluteIcon;
                icons.push(dropDownMenuIcon);
            }
            const dropDownStateIcons = this.getDropDownStateIcons(this._table, col, row);
            if (dropDownStateIcons.length) {
                icons.push(...dropDownStateIcons);
            }
            const { headerIcon } = this._table._getHeaderLayoutMap(col, row);
            const hierarchyIcon = this.getHierarchyIcon(col, row);
            if (hierarchyIcon) {
                icons.push(hierarchyIcon);
            }
            if (headerIcon) {
                let headerIconStrs;
                if (typeof headerIcon === 'function') {
                    const arg = {
                        col,
                        row,
                        value: this._table.getCellValue(col, row),
                        dataValue: this._table.getCellOriginValue(col, row),
                        table: this._table
                    };
                    headerIconStrs = headerIcon(arg);
                }
                else {
                    headerIconStrs = headerIcon;
                }
                const regedIcons = get$2();
                const addIcon = (headerIcon) => {
                    let icon;
                    if (typeof headerIcon === 'string') {
                        icon = regedIcons[headerIcon];
                    }
                    else {
                        icon = headerIcon;
                    }
                    if (icon) {
                        icons.push(icon);
                    }
                };
                if (Array.isArray(headerIconStrs)) {
                    headerIconStrs.forEach((columnIcon, index) => {
                        addIcon(columnIcon);
                    });
                }
                else {
                    addIcon(headerIconStrs);
                }
            }
            return icons;
        }
        getFrozenIcon(col, row) {
            if (this._table.isPivotTable() || this._table.transpose) {
                return null;
            }
            if (this._table.rightFrozenColCount && col >= this._table.colCount - this._table.rightFrozenColCount) {
                return null;
            }
            const headerC = this._table.getHeaderDefine(col, row);
            if (headerC.columns && headerC.columns.length > 0) {
                return null;
            }
            let frozen = this.freezeIcon;
            if (this._table.options.frozenColCount - 1 > col) {
                frozen = this.frozenIcon;
            }
            else if (this._table.options.frozenColCount - 1 === col) {
                frozen = this.frozenCurrentIcon;
            }
            return frozen;
        }
        getSortIcon(order, _table, col, row) {
            const icon = order === 'asc' ? this.upIcon : order === 'desc' ? this.downIcon : this.normalIcon;
            const headerC = _table.getHeaderDefine(col, row);
            let _showSort;
            if (headerC) {
                if (typeof headerC.showSort === 'function') {
                    _showSort = headerC.showSort({ col, row, table: this._table });
                }
                else {
                    _showSort = headerC.showSort;
                }
            }
            if (!headerC ||
                _showSort === false ||
                (!isValid$3(_showSort) && !headerC.sort) ||
                (headerC.columns && headerC.columns.length > 0)) {
                return null;
            }
            return icon;
        }
        getSortIconForPivotTable(order, _table, col, row) {
            const headerC = _table.getHeaderDefine(col, row);
            let _showSort;
            if (headerC) {
                if (typeof headerC.showSort === 'function') {
                    _showSort = headerC.showSort({ col, row, table: this._table });
                }
                else {
                    _showSort = headerC.showSort;
                }
            }
            if (!headerC ||
                _showSort === false ||
                (!isValid$3(_showSort) && !headerC.sort) ||
                (headerC.columns && headerC.columns.length > 0)) {
                return null;
            }
            const icon = order?.toUpperCase() === 'ASC' ? this.upIcon : order?.toUpperCase() === 'DESC' ? this.downIcon : this.normalIcon;
            return icon;
        }
        getDropDownStateIcons(_table, col, row) {
            const headerC = _table.getHeaderDefine(col, row);
            const headerL = _table._getHeaderLayoutMap(col, row);
            let { dropDownMenu } = headerL;
            if (typeof dropDownMenu === 'function') {
                dropDownMenu = dropDownMenu({ row, col, table: _table });
            }
            let globalDropDownMenu = _table.globalDropDownMenu;
            if (typeof globalDropDownMenu === 'function') {
                globalDropDownMenu = globalDropDownMenu({ row, col, table: _table });
            }
            const results = [];
            if ((Array.isArray(dropDownMenu) && dropDownMenu.length) ||
                (Array.isArray(globalDropDownMenu) && globalDropDownMenu.length && !headerC?.columns?.length)) {
                const menus = dropDownMenu || globalDropDownMenu;
                let highlightIndex = -1;
                let subHighlightIndex = -1;
                for (let i = 0; i < menus.length; i++) {
                    const menu = menus[i];
                    if (typeof menu === 'object' && menu.children && menu.children.length) {
                        for (let j = 0; j < menu.children.length; j++) {
                            const childItem = menu.children[j];
                            if (_table.stateManager.menu?.dropDownMenuHighlight &&
                                isMenuHighlight(_table, _table.stateManager.menu?.dropDownMenuHighlight, typeof childItem === 'object' ? childItem?.menuKey : childItem, col, row)) {
                                highlightIndex = i;
                                subHighlightIndex = j;
                                break;
                            }
                        }
                    }
                    if (_table._dropDownMenuIsHighlight(col, row, i)) {
                        highlightIndex = i;
                        break;
                    }
                }
                if (highlightIndex !== -1) {
                    let menu;
                    if (subHighlightIndex !== -1) {
                        menu = menus[highlightIndex].children[subHighlightIndex];
                    }
                    else {
                        menu = menus[highlightIndex];
                    }
                    if (menu.stateIcon) {
                        if (menu.stateIcon.svg) {
                            results.push({
                                type: 'svg',
                                name: menu.stateIcon.src || menu.stateIcon.svg,
                                width: menu.stateIcon.width || 22,
                                height: menu.stateIcon.height || 22,
                                svg: menu.stateIcon.svg,
                                positionType: IconPosition.right,
                                marginRight: 0,
                                funcType: IconFuncTypeEnum.dropDownState,
                                interactive: false
                            });
                        }
                        else if (menu.stateIcon.src) {
                            results.push({
                                type: 'image',
                                name: menu.stateIcon.src || menu.stateIcon.svg,
                                width: menu.stateIcon.width || 22,
                                height: menu.stateIcon.height || 22,
                                src: menu.stateIcon.src,
                                positionType: IconPosition.right,
                                marginRight: 0,
                                funcType: IconFuncTypeEnum.dropDownState,
                                interactive: false
                            });
                        }
                    }
                }
            }
            return results;
        }
        getDropDownIconRect(cellRect, marginTop, baseline) {
            const iconW = this.downIcon.hover?.width ?? this.downIcon?.width ?? 0;
            const iconH = this.downIcon.hover?.height ?? this.downIcon?.height ?? 0;
            const left = cellRect.right - 2 - iconW;
            const right = cellRect.right - 2;
            let top;
            if (baseline === 'middle') {
                top = cellRect.top + cellRect.height / 2 - iconW / 2;
            }
            else if (baseline === 'top') {
                top = cellRect.top + marginTop / 2;
            }
            else if (baseline === 'bottom') {
                top = cellRect.bottom - marginTop * 2;
            }
            else {
                top = cellRect.top;
            }
            const bottom = iconH + top;
            return {
                left,
                right,
                top,
                bottom,
                width: iconW,
                height: iconH
            };
        }
        getHierarchyIcon(col, row) {
            const { hierarchyState } = this._table._getHeaderLayoutMap(col, row);
            if (hierarchyState) {
                if (hierarchyState === HierarchyState.expand) {
                    return this.expandIcon;
                }
                else if (hierarchyState === HierarchyState.collapse) {
                    return this.collapseIcon;
                }
            }
            return undefined;
        }
        getHierarchyIconWidth() {
            return this.expandIcon.width + (this.expandIcon.marginLeft ?? 0) + (this.expandIcon.marginRight ?? 0);
        }
        checkDropDownIcon(_table, col, row) {
            if (_table.isPivotTable()) {
                const headerC = _table._getHeaderLayoutMap(col, row);
                let dropDownMenu = headerC.dropDownMenu;
                if (typeof dropDownMenu === 'function') {
                    dropDownMenu = dropDownMenu({ row, col, table: _table });
                }
                if (Array.isArray(dropDownMenu) &&
                    dropDownMenu.length) {
                    return true;
                }
            }
            else {
                const headerC = _table.getHeaderDefine(col, row);
                const dropDownMenu = headerC.dropDownMenu;
                let globalDropDownMenu = _table.globalDropDownMenu;
                if (typeof globalDropDownMenu === 'function') {
                    globalDropDownMenu = globalDropDownMenu({ row, col, table: _table });
                }
                if ((Array.isArray(dropDownMenu) && dropDownMenu.length) ||
                    ((!Array.isArray(headerC.dropDownMenu) || headerC.dropDownMenu.length !== 0) &&
                        Array.isArray(globalDropDownMenu) &&
                        globalDropDownMenu.length &&
                        !headerC?.columns?.length)) {
                    return true;
                }
            }
            return false;
        }
        getStyleClass(headerType) {
            switch (headerType) {
                case 'text':
                    return TextHeaderStyle;
                case 'image':
                    return ImageStyle;
                case 'video':
                    return ImageStyle;
                case 'link':
                    return TextHeaderStyle;
                case 'checkbox':
                    return CheckboxStyle;
            }
        }
        setTableColumnsEditor() {
            const setEditor = (colDefines, setColumns) => {
                colDefines?.forEach((colDefine, index) => {
                    if (colDefine.editor) {
                        setColumns[index].editor = colDefine.editor;
                    }
                    if (colDefine.columns) {
                        setEditor(colDefine.columns, setColumns[index].columns);
                    }
                });
            };
            setEditor(this._table.options.columns, this._table.internalProps.columns);
        }
    }

    class FocusInput extends EventTarget {
        _container;
        _table;
        _input;
        constructor(table, parentElement) {
            super();
            this._table = table;
            if (Env.mode === 'node') {
                return;
            }
            const div = document.createElement('div');
            div.style.opacity = '0';
            div.dataset.vtable = 'vtable';
            div.style.pointerEvents = 'none';
            div.classList.add('input-container');
            const input = (this._input = document.createElement('input'));
            div.appendChild(input);
            input.classList.add('table-focus-control');
            input.dataset.vtable = 'vtable';
            input.readOnly = true;
            parentElement.appendChild(div);
            this._container = div;
        }
        focus() {
            this._input.focus({ preventScroll: true });
        }
        setFocusRect(rect, value) {
            const input = this._input;
            input.value = value;
            input.select();
            const top = rect.top - this._table.scrollTop;
            const left = rect.left - this._table.scrollLeft;
            input.style.top = `${top.toFixed()}px`;
            input.style.left = `${left.toFixed()}px`;
            input.style.width = `${rect.width.toFixed()}px`;
            input.style.height = `${rect.height.toFixed()}px`;
        }
        get input() {
            return this._input;
        }
        release() {
            this._container.parentElement?.removeChild(this._container);
        }
    }

    class NumberRangeMap {
        data;
        cumulativeSum;
        difference;
        totalSum;
        table;
        isUpdate = false;
        _keys = [];
        _sorted = false;
        constructor(table) {
            this.data = new Map();
            this._keys.length = 0;
            this.cumulativeSum = new Map();
            this.difference = new Map();
            this.totalSum = 0;
            this.table = table;
        }
        get length() {
            return this.data.size;
        }
        clear() {
            this._keys = [];
            this.data.clear();
            this.cumulativeSum.clear();
            this.difference.clear();
            this.totalSum = 0;
        }
        clearRange() {
            this.cumulativeSum.clear();
            this.difference.clear();
        }
        add(position, value) {
            if (!isValid$3(value)) {
                return;
            }
            const defaultValue = this.table.getRowHeight(position);
            if (!this.data.has(position)) {
                this._keys.push(position);
                this._sorted = false;
            }
            this.data.set(position, value);
            this.totalSum += value;
            this.updateDifference(position, value - defaultValue);
        }
        remove(position) {
            if (this.data.has(position)) {
                const value = this.data.get(position);
                this.data.delete(position);
                const index = this._keys.indexOf(position);
                if (index !== -1) {
                    this._keys.splice(index, 1);
                }
                this.totalSum -= value;
                const defaultValue = this.table.getRowHeight(position);
                this.updateDifference(position, defaultValue - value);
            }
        }
        put(position, newValue) {
            if (!isValid$3(newValue)) {
                return;
            }
            if (this.data.has(position)) {
                const oldValue = this.data.get(position);
                if (oldValue === newValue) {
                    return;
                }
                this.data.set(position, newValue);
                const difference = newValue - oldValue;
                this.totalSum += difference;
                this.updateDifference(position, difference);
            }
            else {
                this.add(position, newValue);
            }
        }
        get(position) {
            return this.data.get(position);
        }
        has(position) {
            return this.data.has(position);
        }
        _sort() {
            const { _keys: keys } = this;
            if (!this._sorted) {
                keys.sort((a, b) => {
                    if (a < b) {
                        return -1;
                    }
                    if (a > b) {
                        return 1;
                    }
                    return 0;
                });
                this._sorted = true;
            }
        }
        updateDifference(position, difference) {
            const oldDifference = this.difference.get(position) ?? 0;
            this.difference.set(position, oldDifference + difference);
            this.update();
        }
        getSumInRange(start, end) {
            return this.calculatePrefixSum(end) - this.calculatePrefixSum(start - 1);
        }
        updateCumulativeSum(position, difference) {
            for (const [pos, sum] of this.cumulativeSum) {
                if (pos >= position) {
                    this.cumulativeSum.set(pos, sum + difference);
                }
            }
        }
        calculatePrefixSum(position) {
            if (position < 0) {
                return 0;
            }
            if (this.cumulativeSum.has(position)) {
                let cache = this.cumulativeSum.get(position);
                for (const [pos, difference] of this.difference) {
                    if (pos <= position) {
                        cache += difference;
                    }
                }
                return cache;
            }
            this.dealDiffenence();
            return this.getCumulativeSum(position);
        }
        getCumulativeSum(position) {
            let sum = 0;
            for (let i = position; i >= 0; i--) {
                if (this.cumulativeSum.has(i)) {
                    sum += this.cumulativeSum.get(i);
                    break;
                }
                else {
                    sum += this.data.get(i) ?? this.table.getRowHeight(i);
                }
            }
            this.cumulativeSum.set(position, sum);
            return sum;
        }
        update() {
            if (this.isUpdate) {
                return;
            }
            this.isUpdate = true;
            setTimeout(() => {
                this.dealDiffenence();
                this.isUpdate = false;
            }, 0);
        }
        dealDiffenence() {
            for (const [sumPos] of this.cumulativeSum) {
                for (const [difPos, difference] of this.difference) {
                    if (sumPos >= difPos) {
                        const oldSum = this.cumulativeSum.get(sumPos);
                        this.cumulativeSum.set(sumPos, oldSum + difference);
                    }
                }
            }
            this.difference.clear();
        }
        insert(position, value) {
            for (let i = position; i <= this.getLastIndex(); i++) {
                this.cumulativeSum.delete(i);
            }
            const lastIndex = this.getLastIndex() + 1;
            this.adjustOrder(position, position + 1, lastIndex - position);
            if (isValid$3(value)) {
                this.put(position, value);
            }
        }
        getLastIndex() {
            this._sort();
            return this._keys[this._keys.length - 1];
        }
        delLast() {
            const lastIndex = this.getLastIndex();
            this.remove(lastIndex);
        }
        delete(position) {
            if (!this.has(position)) {
                return;
            }
            for (let i = position; i <= this.getLastIndex(); i++) {
                this.cumulativeSum.delete(i);
            }
            const lastIndex = this.getLastIndex();
            this.adjustOrder(position + 1, position, lastIndex - position);
            this.delLast();
        }
        adjustOrder(sourceIndex, targetIndex, moveCount) {
            this.clearRange();
            this._sort();
            const { _keys: keys } = this;
            if (sourceIndex > targetIndex) {
                const sourceVals = [];
                for (let i = indexFirst(keys, sourceIndex + moveCount - 1); i >= 0; i--) {
                    const key = keys[i];
                    if (key >= sourceIndex) {
                        sourceVals.push(this.get(key));
                    }
                    else if (targetIndex <= key && key < sourceIndex) {
                        this.put(key + moveCount, this.get(key));
                    }
                    else if (key < targetIndex) {
                        break;
                    }
                }
                for (let i = 0; i < moveCount; i++) {
                    this.put(targetIndex + i, sourceVals[moveCount - 1 - i]);
                }
            }
            const { length } = keys;
            if (sourceIndex < targetIndex) {
                const sourceVals = [];
                for (let i = indexFirst(keys, sourceIndex); i < length; i++) {
                    const key = keys[i];
                    if (key >= sourceIndex && key < sourceIndex + moveCount) {
                        sourceVals.push(this.get(key));
                    }
                    else if (sourceIndex + moveCount <= key && key <= targetIndex) {
                        this.put(key - moveCount, this.get(key));
                    }
                    else if (key > targetIndex) {
                        break;
                    }
                }
                for (let i = 0; i < moveCount; i++) {
                    this.put(targetIndex + i, sourceVals[i]);
                }
            }
        }
        exchangeOrder(sourceIndex, sourceCount, targetIndex, targetCount, insertIndex) {
            const { _keys: keys } = this;
            if (!this._sorted) {
                keys.sort((a, b) => {
                    if (a < b) {
                        return -1;
                    }
                    if (a > b) {
                        return 1;
                    }
                    return 0;
                });
                this._sorted = true;
            }
            if (sourceIndex > targetIndex) {
                const targetVals = [];
                const sourceVals = [];
                for (let i = indexFirst(keys, targetIndex); i < indexFirst(keys, sourceIndex) + sourceCount; i++) {
                    const key = keys[i];
                    if (key >= sourceIndex && key < sourceIndex + sourceCount) {
                        sourceVals.push(this.get(key));
                    }
                    else {
                        targetVals.push(this.get(key));
                    }
                }
                for (let i = 0; i < sourceCount; i++) {
                    this.put(insertIndex + i, sourceVals[i]);
                }
                for (let i = 0; i < targetVals.length; i++) {
                    this.put(insertIndex + sourceCount + i, targetVals[i]);
                }
            }
            else {
                const targetVals = [];
                const sourceVals = [];
                for (let i = indexFirst(keys, sourceIndex); i < indexFirst(keys, targetIndex) + targetCount; i++) {
                    const key = keys[i];
                    if (key >= sourceIndex && key < sourceIndex + sourceCount) {
                        sourceVals.push(this.get(key));
                    }
                    else {
                        targetVals.push(this.get(key));
                    }
                }
                for (let i = 0; i < sourceCount; i++) {
                    this.put(insertIndex + i, sourceVals[i]);
                }
                for (let i = 0; i < targetVals.length; i++) {
                    this.put(sourceIndex + i, targetVals[i]);
                }
            }
        }
    }
    function indexFirst(arr, elm) {
        let low = 0;
        let high = arr.length - 1;
        while (low <= high) {
            const i = Math.floor((low + high) / 2);
            if (arr[i] === elm) {
                return i;
            }
            else if (arr[i] > elm) {
                high = i - 1;
            }
            else {
                low = i + 1;
            }
        }
        return high < 0 ? 0 : high;
    }

    class RowSeriesNumberHelper {
        dragReorderIconName;
        _table;
        constructor(_table) {
            this._table = _table;
            const regedIcons = get$2();
            this.dragReorderIconName = regedIcons[InternalIconName.dragReorderIconName];
        }
        getIcons(col, row) {
            return [this.dragReorderIconName];
        }
    }

    class DimensionTree {
        sharedVar;
        hasHideNode = false;
        sizeIncludeParent = false;
        setExpandLevel;
        hierarchyType;
        tree = {
            id: 0,
            dimensionKey: '',
            value: '',
            children: [],
            level: -1,
            afterSpanLevel: -1,
            levelSpan: 1,
            startIndex: 0,
            size: 0,
            startInTotal: 0,
            hierarchyState: undefined
        };
        totalLevel = 0;
        expandedMaxLevel = 0;
        dimensionKeys = new NumberMap();
        dimensionKeysIncludeVirtual = new NumberMap();
        cache = new Map();
        constructor(tree, sharedVar, hierarchyType = 'grid', rowExpandLevel = undefined) {
            this.sizeIncludeParent = rowExpandLevel !== null && rowExpandLevel !== undefined;
            this.setExpandLevel = rowExpandLevel;
            this.hierarchyType = hierarchyType;
            this.sharedVar = sharedVar;
            this.reset(tree);
        }
        reset(tree) {
            this.totalLevel = 0;
            this.expandedMaxLevel = 0;
            this.hasHideNode = false;
            this.cache.clear();
            this.dimensionKeys = new NumberMap();
            this.dimensionKeysIncludeVirtual = new NumberMap();
            this.tree.children = tree;
            this.setTreeNode(this.tree, 0, this.tree);
        }
        setTreeNode(node, startIndex, parent) {
            node.startIndex = startIndex;
            node.startInTotal = (parent.startInTotal ?? 0) + node.startIndex;
            if (node.hide) {
                this.hasHideNode = true;
            }
            if (node.dimensionKey ?? node.indicatorKey) {
                if (!node.virtual &&
                    !this.dimensionKeys.contain(node.indicatorKey ? IndicatorDimensionKeyPlaceholder : node.dimensionKey)) {
                    this.dimensionKeys.put(node.level, node.indicatorKey ? IndicatorDimensionKeyPlaceholder : node.dimensionKey);
                }
                if (!this.dimensionKeysIncludeVirtual.contain(node.indicatorKey ? IndicatorDimensionKeyPlaceholder : node.dimensionKey)) {
                    this.dimensionKeysIncludeVirtual.put(node.level, node.indicatorKey ? IndicatorDimensionKeyPlaceholder : node.dimensionKey);
                }
                if (!node.id) {
                    node.id = ++this.sharedVar.seqId;
                }
            }
            let size = node.dimensionKey ? (this.sizeIncludeParent ? 1 : 0) : 0;
            const children = node.children || node.columns;
            if (this.hierarchyType === 'grid' || this.hierarchyType === null) {
                if (children?.length >= 1) {
                    children.forEach((n) => {
                        n.level = (node.level ?? 0) + 1;
                        this.hierarchyType === 'grid' && (n.afterSpanLevel = (node.afterSpanLevel ?? 0) + (node.levelSpan ?? 1));
                        this.totalLevel = Math.max(this.totalLevel, n.level + 1);
                        size += this.setTreeNode(n, size, node);
                    });
                }
                else {
                    node.level === -1 ? (size = 0) : (size = 1);
                }
            }
            else if (node.hierarchyState === HierarchyState.expand && children?.length >= 1) {
                children.forEach((n) => {
                    n.level = (node.level ?? 0) + 1;
                    this.totalLevel = Math.max(this.totalLevel, n.level + 1);
                    this.expandedMaxLevel = Math.max(this.expandedMaxLevel, n.level + 1);
                    size += this.setTreeNode(n, size, node);
                });
            }
            else if (node.hierarchyState === HierarchyState.collapse && children?.length >= 1) {
                children.forEach((n) => {
                    n.level = (node.level ?? 0) + 1;
                    this.totalLevel = Math.max(this.totalLevel, n.level + 1);
                    this.setTreeNode(n, size, node);
                });
            }
            else if (!node.hierarchyState &&
                node.level + 1 < this.setExpandLevel &&
                (children?.length >= 1 || children === true)) {
                if (!(children[0]?.indicatorKey && this.hierarchyType === 'grid-tree')) {
                    node.hierarchyState = HierarchyState.expand;
                }
                children?.length >= 1 &&
                    children.forEach((n) => {
                        n.level = (node.level ?? 0) + 1;
                        this.totalLevel = Math.max(this.totalLevel, n.level + 1);
                        this.expandedMaxLevel = Math.max(this.expandedMaxLevel, n.level + 1);
                        size += this.setTreeNode(n, size, node);
                    });
            }
            else if (children?.length >= 1 || children === true) {
                if (!(children[0]?.indicatorKey && this.hierarchyType === 'grid-tree')) {
                    node.hierarchyState = HierarchyState.collapse;
                }
                children?.length >= 1 &&
                    children.forEach((n) => {
                        n.level = (node.level ?? 0) + 1;
                        this.totalLevel = Math.max(this.totalLevel, n.level + 1);
                        this.setTreeNode(n, size, node);
                    });
            }
            else {
                node.hierarchyState = HierarchyState.none;
                node.level === -1 ? (size = 0) : (size = 1);
            }
            node.size = size;
            return size;
        }
        getTreePath(index, maxDeep = 30) {
            const path = [];
            this.searchPath(index, this.tree, path, maxDeep);
            path.shift();
            return path;
        }
        findNodeById(nodes, id) {
            return nodes.find(node => {
                return node.id === id;
            });
        }
        searchPath(index, node, path, maxDeep) {
            if (!node) {
                return;
            }
            if (index < node.startIndex || index >= node.startIndex + node.size) {
                return;
            }
            path.push(node);
            if (!node.children || node.children.length === 0 || node.level >= maxDeep) {
                return;
            }
            const cIndex = index - node.startIndex;
            if (this.cache.has(node.level + 1)) {
                const cacheNode = this.cache.get(node.level + 1);
                if (cIndex >= cacheNode.startIndex && cIndex < cacheNode.startIndex + cacheNode.size) {
                    this.searchPath(cIndex, cacheNode, path, maxDeep);
                    return;
                }
            }
            let left = 0;
            let right = node.children.length - 1;
            while (left <= right) {
                const middle = Math.floor((left + right) / 2);
                const element = node.children[middle];
                if (cIndex >= element.startIndex && cIndex < element.startIndex + element.size) {
                    this.cache.set(element.level, element);
                    const deleteLevels = [];
                    this.cache.forEach((node, key) => {
                        if (key > element.level) {
                            deleteLevels.push(key);
                        }
                    });
                    deleteLevels.forEach(key => {
                        this.cache.delete(key);
                    });
                    this.searchPath(cIndex, element, path, maxDeep);
                    break;
                }
                else if (cIndex < element.startIndex) {
                    right = middle - 1;
                }
                else {
                    left = middle + 1;
                }
            }
            return;
        }
        movePosition(level, sourceIndex, targetIndex) {
            let parNode;
            let sourceSubIndex;
            let targetSubIndex;
            const findTargetNode = (node, subIndex) => {
                if (sourceSubIndex !== undefined && targetSubIndex !== undefined) {
                    return;
                }
                if (node.level === level) {
                    if (node.startInTotal === sourceIndex) {
                        sourceSubIndex = subIndex;
                    }
                    if (node.startInTotal <= targetIndex && targetIndex <= node.startInTotal + node.size - 1) {
                        targetSubIndex = subIndex;
                    }
                }
                const children = node.children || node.columns;
                if (children && node.level < level) {
                    parNode = node;
                    for (let i = 0; i < children.length; i++) {
                        if ((sourceIndex >= children[i].startInTotal && sourceIndex <= children[i].startInTotal + children[i].size) ||
                            (targetIndex >= children[i].startInTotal && targetIndex <= children[i].startInTotal + children[i].size)) {
                            findTargetNode(children[i], i);
                        }
                    }
                }
            };
            findTargetNode(this.tree, 0);
            const children = parNode.children || parNode.columns;
            const sourceColumns = children.splice(sourceSubIndex, 1);
            sourceColumns.unshift(targetSubIndex, 0);
            Array.prototype.splice.apply(children, sourceColumns);
        }
        getCopiedTree() {
            const children = cloneDeep$1(this.tree.children);
            clearNode(children);
            return children;
        }
    }
    function generateLayoutTree(tree, children) {
        children?.forEach((node) => {
            const diemnsonNode = {
                dimensionKey: node.dimensionKey,
                indicatorKey: node.indicatorKey,
                value: node.value,
                hierarchyState: node.hierarchyState,
                children: undefined,
                virtual: node.virtual ?? false,
                levelSpan: node.levelSpan ?? 1
            };
            tree.push(diemnsonNode);
            if (node.children) {
                diemnsonNode.children = [];
                generateLayoutTree(diemnsonNode.children, node.children);
            }
        });
    }
    function countLayoutTree(children, countParentNode) {
        let count = 0;
        children?.forEach((node) => {
            if (countParentNode) {
                count++;
            }
            else {
                if (!node.children || node.children.length === 0) {
                    count++;
                }
            }
            if (node.children) {
                count += countLayoutTree(node.children, countParentNode);
            }
        });
        return count;
    }
    function dealHeader(hd, _headerCellIds, results, roots, row, layoutMap) {
        const id = hd.id;
        const dimensionInfo = layoutMap.rowsDefine?.find(dimension => typeof dimension === 'string' ? false : dimension.dimensionKey === hd.dimensionKey) ??
            layoutMap.columnsDefine?.find(dimension => typeof dimension === 'string' ? false : dimension.dimensionKey === hd.dimensionKey);
        const indicatorInfo = layoutMap.indicatorsDefine?.find(indicator => {
            if (typeof indicator === 'string') {
                return false;
            }
            if (hd.indicatorKey) {
                return indicator.indicatorKey === hd.indicatorKey;
            }
            return indicator.title === hd.value && !hd.dimensionKey;
        });
        const cell = {
            id,
            title: hd.value ?? indicatorInfo?.title,
            field: hd.dimensionKey,
            style: typeof (indicatorInfo ?? dimensionInfo)?.headerStyle === 'function'
                ? (indicatorInfo ?? dimensionInfo)?.headerStyle
                : Object.assign({}, (indicatorInfo ?? dimensionInfo)?.headerStyle),
            headerType: indicatorInfo?.headerType ?? dimensionInfo?.headerType ?? 'text',
            headerIcon: indicatorInfo?.headerIcon ?? dimensionInfo?.headerIcon,
            define: Object.assign({}, hd, indicatorInfo ?? Object.assign({}, dimensionInfo, { sort: undefined })),
            fieldFormat: indicatorInfo?.headerFormat ?? dimensionInfo?.headerFormat,
            dropDownMenu: indicatorInfo?.dropDownMenu ?? dimensionInfo?.dropDownMenu,
            pivotInfo: {
                value: hd.value,
                dimensionKey: hd.dimensionKey,
                isPivotCorner: false
            },
            width: dimensionInfo?.width,
            minWidth: dimensionInfo?.minWidth,
            maxWidth: dimensionInfo?.maxWidth,
            showSort: indicatorInfo?.showSort ?? dimensionInfo?.showSort,
            sort: indicatorInfo?.sort,
            description: dimensionInfo?.description
        };
        if (indicatorInfo) {
            if (indicatorInfo.customRender) {
                hd.customRender = indicatorInfo.customRender;
            }
            if (!isValid$3(layoutMap._indicators?.find(indicator => indicator.indicatorKey === indicatorInfo.indicatorKey))) {
                layoutMap._indicators?.push({
                    id: ++layoutMap.sharedVar.seqId,
                    indicatorKey: indicatorInfo.indicatorKey,
                    field: indicatorInfo.indicatorKey,
                    fieldFormat: indicatorInfo?.format,
                    cellType: indicatorInfo?.cellType ?? indicatorInfo?.columnType ?? 'text',
                    chartModule: 'chartModule' in indicatorInfo ? indicatorInfo.chartModule : null,
                    chartSpec: 'chartSpec' in indicatorInfo ? indicatorInfo.chartSpec : null,
                    noDataRenderNothing: 'noDataRenderNothing' in indicatorInfo ? indicatorInfo.noDataRenderNothing : false,
                    sparklineSpec: 'sparklineSpec' in indicatorInfo ? indicatorInfo.sparklineSpec : null,
                    style: indicatorInfo?.style,
                    icon: indicatorInfo?.icon,
                    define: Object.assign({}, hd, indicatorInfo, {
                        dragHeader: dimensionInfo?.dragHeader
                    }),
                    width: indicatorInfo?.width,
                    minWidth: indicatorInfo?.minWidth,
                    maxWidth: indicatorInfo?.maxWidth,
                    disableColumnResize: indicatorInfo?.disableColumnResize
                });
            }
        }
        else if (hd.indicatorKey) {
            if (!isValid$3(layoutMap._indicators?.find(indicator => indicator.indicatorKey === hd.indicatorKey))) {
                layoutMap._indicators?.push({
                    id: ++layoutMap.sharedVar.seqId,
                    indicatorKey: hd.indicatorKey,
                    field: hd.indicatorKey,
                    cellType: 'text',
                    define: Object.assign({}, hd)
                });
            }
        }
        results[id] = cell;
        layoutMap._headerObjects[id] = cell;
        for (let r = row - 1; r >= 0; r--) {
            _headerCellIds[r][layoutMap.colIndex] = roots[r];
        }
        _headerCellIds[row][layoutMap.colIndex] = id;
        if (hd.levelSpan > 1) {
            for (let i = 1; i < hd.levelSpan; i++) {
                if (!_headerCellIds[row + i]) {
                    _headerCellIds[row + i] = [];
                    for (let col = 0; col < layoutMap.colIndex; col++) {
                        _headerCellIds[row + i][col] = _headerCellIds[row][col];
                    }
                }
                _headerCellIds[row + i][layoutMap.colIndex] = id;
            }
        }
        if (hd.children?.length >= 1) {
            layoutMap._addHeaders(_headerCellIds, row + (hd.levelSpan ?? 1), hd.children ?? [], [...roots, ...Array(hd.levelSpan ?? 1).fill(id)], results);
        }
        else {
            for (let r = row + 1; r < _headerCellIds.length; r++) {
                _headerCellIds[r][layoutMap.colIndex] = id;
            }
            layoutMap.colIndex++;
        }
    }
    function dealHeaderForGridTreeMode(hd, _headerCellIds, results, roots, row, totalLevel, expandedMaxLevel, show, dimensions, isRowTree, indicatorsAsCol, layoutMap) {
        const id = hd.id;
        const dimensionInfo = layoutMap.rowsDefine?.find(dimension => typeof dimension === 'string' ? false : dimension.dimensionKey === hd.dimensionKey) ??
            layoutMap.columnsDefine?.find(dimension => typeof dimension === 'string' ? false : dimension.dimensionKey === hd.dimensionKey);
        const indicatorInfo = layoutMap.indicatorsDefine?.find(indicator => {
            if (typeof indicator === 'string') {
                return false;
            }
            if (hd.indicatorKey) {
                return indicator.indicatorKey === hd.indicatorKey;
            }
            return indicator.title === hd.value && !hd.dimensionKey;
        });
        const cell = {
            id,
            title: hd.value ?? indicatorInfo?.title,
            field: hd.dimensionKey,
            style: typeof (indicatorInfo ?? dimensionInfo)?.headerStyle === 'function'
                ? (indicatorInfo ?? dimensionInfo)?.headerStyle
                : Object.assign({}, (indicatorInfo ?? dimensionInfo)?.headerStyle),
            headerType: indicatorInfo?.headerType ?? dimensionInfo?.headerType ?? 'text',
            headerIcon: indicatorInfo?.headerIcon ?? dimensionInfo?.headerIcon,
            define: Object.assign(hd, {
                linkJump: (indicatorInfo ?? dimensionInfo)?.linkJump,
                linkDetect: (indicatorInfo ?? dimensionInfo)?.linkDetect,
                templateLink: (indicatorInfo ?? dimensionInfo)?.templateLink,
                keepAspectRatio: (indicatorInfo ?? dimensionInfo)?.keepAspectRatio ?? false,
                imageAutoSizing: (indicatorInfo ?? dimensionInfo)?.imageAutoSizing,
                headerCustomRender: (indicatorInfo ?? dimensionInfo)?.headerCustomRender,
                headerCustomLayout: (indicatorInfo ?? dimensionInfo)?.headerCustomLayout,
                dragHeader: dimensionInfo?.dragHeader,
                disableHeaderHover: !!(indicatorInfo ?? dimensionInfo)?.disableHeaderHover,
                disableHeaderSelect: !!(indicatorInfo ?? dimensionInfo)?.disableHeaderSelect,
                showSort: indicatorInfo?.showSort ?? dimensionInfo?.showSort,
                hide: indicatorInfo?.hide
            }),
            fieldFormat: indicatorInfo?.headerFormat ?? dimensionInfo?.headerFormat,
            dropDownMenu: indicatorInfo?.dropDownMenu ?? dimensionInfo?.dropDownMenu,
            pivotInfo: {
                value: hd.value,
                dimensionKey: hd.dimensionKey,
                isPivotCorner: false
            },
            hierarchyLevel: hd.level,
            dimensionTotalLevel: totalLevel,
            hierarchyState: hd.hierarchyState,
            width: dimensionInfo?.width,
            minWidth: dimensionInfo?.minWidth,
            maxWidth: dimensionInfo?.maxWidth,
            showSort: indicatorInfo?.showSort ?? dimensionInfo?.showSort,
            sort: indicatorInfo?.sort,
            description: dimensionInfo?.description,
            parentCellId: roots[roots.length - 1]
        };
        if (indicatorInfo) {
            if (indicatorInfo.customRender) {
                hd.customRender = indicatorInfo.customRender;
            }
            if (!isValid$3(layoutMap._indicators?.find(indicator => indicator.indicatorKey === indicatorInfo.indicatorKey))) {
                layoutMap._indicators?.push({
                    id: ++layoutMap.sharedVar.seqId,
                    indicatorKey: indicatorInfo.indicatorKey,
                    field: indicatorInfo.indicatorKey,
                    fieldFormat: indicatorInfo?.format,
                    cellType: indicatorInfo?.cellType ?? indicatorInfo?.columnType ?? 'text',
                    chartModule: 'chartModule' in indicatorInfo ? indicatorInfo.chartModule : null,
                    chartSpec: 'chartSpec' in indicatorInfo ? indicatorInfo.chartSpec : null,
                    noDataRenderNothing: 'noDataRenderNothing' in indicatorInfo ? indicatorInfo.noDataRenderNothing : false,
                    sparklineSpec: 'sparklineSpec' in indicatorInfo ? indicatorInfo.sparklineSpec : null,
                    style: indicatorInfo?.style,
                    icon: indicatorInfo?.icon,
                    define: Object.assign({}, hd, indicatorInfo, {
                        dragHeader: dimensionInfo?.dragHeader
                    }),
                    width: indicatorInfo?.width,
                    minWidth: indicatorInfo?.minWidth,
                    maxWidth: indicatorInfo?.maxWidth,
                    disableColumnResize: indicatorInfo?.disableColumnResize
                });
            }
        }
        else if (hd.indicatorKey) {
            if (!isValid$3(layoutMap._indicators?.find(indicator => indicator.indicatorKey === hd.indicatorKey))) {
                layoutMap._indicators?.push({
                    id: ++layoutMap.sharedVar.seqId,
                    indicatorKey: hd.indicatorKey,
                    field: hd.indicatorKey,
                    cellType: 'text',
                    define: Object.assign({}, hd)
                });
            }
        }
        results[id] = cell;
        layoutMap._headerObjects[id] = cell;
        for (let r = row - 1; r >= 0; r--) {
            _headerCellIds[r][layoutMap.colIndex] = roots[r];
        }
        _headerCellIds[row][layoutMap.colIndex] = id;
        const span = Math.min((isRowTree ? indicatorsAsCol : !indicatorsAsCol) ? expandedMaxLevel : expandedMaxLevel - 1, hd.levelSpan ?? 1000);
        if (span > 0) {
            for (let r = row + 1; r < span; r++) {
                if (!_headerCellIds[r]) {
                    _headerCellIds[r] = [];
                    for (let col = 0; col < layoutMap.colIndex; col++) {
                        _headerCellIds[r][col] = _headerCellIds[row][col];
                    }
                }
                _headerCellIds[r][layoutMap.colIndex] = id;
            }
        }
        if ((hd.hierarchyState === HierarchyState.expand && hd).children?.length >= 1) {
            layoutMap._addHeadersForGridTreeMode(_headerCellIds, row + (hd.levelSpan ?? 1), hd.children ?? [], [...roots, ...Array(hd.levelSpan ?? 1).fill(id)], totalLevel, expandedMaxLevel, show && hd.hierarchyState === HierarchyState.expand, dimensions, results, isRowTree);
        }
        else {
            const needSupplementLength = (isRowTree ? indicatorsAsCol : !indicatorsAsCol)
                ? expandedMaxLevel
                : expandedMaxLevel - 1;
            for (let r = row + 1; r < needSupplementLength; r++) {
                if (!_headerCellIds[r]) {
                    _headerCellIds[r] = [];
                }
                _headerCellIds[r][layoutMap.colIndex] = id;
            }
            if (row <= needSupplementLength - 1 &&
                ((isRowTree && indicatorsAsCol === false) || (!isRowTree && indicatorsAsCol === true))) {
                let lastIndidcatorChildren = hd;
                const levelSpan = needSupplementLength - row;
                while (lastIndidcatorChildren) {
                    if (lastIndidcatorChildren.children?.[0].indicatorKey) {
                        break;
                    }
                    lastIndidcatorChildren = lastIndidcatorChildren.children[0];
                }
                layoutMap._addHeadersForGridTreeMode(_headerCellIds, expandedMaxLevel - 1, lastIndidcatorChildren.children ?? [], [...roots, ...Array(Math.max(levelSpan, hd.levelSpan ?? 1)).fill(id)], totalLevel, expandedMaxLevel, true, dimensions, results, isRowTree);
            }
            else {
                layoutMap.colIndex++;
            }
        }
    }
    function dealHeaderForTreeMode(hd, _headerCellIds, results, roots, row, totalLevel, show, dimensions, layoutMap) {
        const id = hd.id;
        const dimensionInfo = dimensions.find(dimension => typeof dimension === 'string' ? false : dimension.dimensionKey === hd.dimensionKey);
        const indicatorInfo = layoutMap.indicatorsDefine?.find(indicator => {
            if (typeof indicator === 'string') {
                return false;
            }
            if (hd.indicatorKey) {
                return indicator.indicatorKey === hd.indicatorKey;
            }
            return indicator.title === hd.value;
        });
        const cell = {
            id,
            title: hd.value ?? indicatorInfo.title,
            field: hd.dimensionKey,
            style: hd.level + 1 === totalLevel || typeof (indicatorInfo ?? dimensionInfo)?.headerStyle === 'function'
                ? (indicatorInfo ?? dimensionInfo)?.headerStyle
                : Object.assign({}, (indicatorInfo ?? dimensionInfo)?.headerStyle, { textAlign: 'left' }),
            headerType: indicatorInfo?.headerType ?? dimensionInfo?.headerType ?? 'text',
            headerIcon: indicatorInfo?.headerIcon ?? dimensionInfo?.headerIcon,
            define: Object.assign(hd, {
                linkJump: (indicatorInfo ?? dimensionInfo)?.linkJump,
                linkDetect: (indicatorInfo ?? dimensionInfo)?.linkDetect,
                templateLink: (indicatorInfo ?? dimensionInfo)?.templateLink,
                keepAspectRatio: (indicatorInfo ?? dimensionInfo)?.keepAspectRatio ?? false,
                imageAutoSizing: (indicatorInfo ?? dimensionInfo)?.imageAutoSizing,
                headerCustomRender: (indicatorInfo ?? dimensionInfo)?.headerCustomRender,
                headerCustomLayout: (indicatorInfo ?? dimensionInfo)?.headerCustomLayout,
                dragHeader: dimensionInfo?.dragHeader,
                disableHeaderHover: !!(indicatorInfo ?? dimensionInfo)?.disableHeaderHover,
                disableHeaderSelect: !!(indicatorInfo ?? dimensionInfo)?.disableHeaderSelect,
                showSort: indicatorInfo?.showSort ?? dimensionInfo?.showSort,
                hide: indicatorInfo?.hide
            }),
            fieldFormat: indicatorInfo?.headerFormat ?? dimensionInfo?.headerFormat,
            dropDownMenu: indicatorInfo?.dropDownMenu ?? dimensionInfo?.dropDownMenu,
            pivotInfo: {
                value: hd.value,
                dimensionKey: hd.dimensionKey,
                isPivotCorner: false
            },
            hierarchyLevel: hd.level,
            dimensionTotalLevel: totalLevel,
            hierarchyState: hd.hierarchyState,
            width: dimensionInfo?.width,
            minWidth: dimensionInfo?.minWidth,
            maxWidth: dimensionInfo?.maxWidth,
            parentCellId: roots[roots.length - 1]
        };
        if (indicatorInfo) {
            if (indicatorInfo.customRender) {
                hd.customRender = indicatorInfo.customRender;
            }
            if (!isValid$3(layoutMap._indicators?.find(indicator => indicator.indicatorKey === indicatorInfo.indicatorKey))) {
                layoutMap._indicators?.push({
                    id: ++layoutMap.sharedVar.seqId,
                    indicatorKey: indicatorInfo.indicatorKey,
                    field: indicatorInfo.indicatorKey,
                    fieldFormat: indicatorInfo?.format,
                    cellType: indicatorInfo?.cellType ?? indicatorInfo?.columnType ?? 'text',
                    chartModule: 'chartModule' in indicatorInfo ? indicatorInfo.chartModule : null,
                    chartSpec: 'chartSpec' in indicatorInfo ? indicatorInfo.chartSpec : null,
                    noDataRenderNothing: 'noDataRenderNothing' in indicatorInfo ? indicatorInfo.noDataRenderNothing : false,
                    sparklineSpec: 'sparklineSpec' in indicatorInfo ? indicatorInfo.sparklineSpec : null,
                    style: indicatorInfo?.style,
                    icon: indicatorInfo?.icon,
                    define: Object.assign({}, hd, indicatorInfo, {
                        dragHeader: dimensionInfo?.dragHeader
                    }),
                    width: indicatorInfo?.width,
                    minWidth: indicatorInfo?.minWidth,
                    maxWidth: indicatorInfo?.maxWidth,
                    disableColumnResize: indicatorInfo?.disableColumnResize
                });
            }
        }
        else if (hd.indicatorKey) {
            if (!isValid$3(layoutMap._indicators?.find(indicator => indicator.indicatorKey === hd.indicatorKey))) {
                layoutMap._indicators?.push({
                    id: ++layoutMap.sharedVar.seqId,
                    indicatorKey: hd.indicatorKey,
                    field: hd.indicatorKey,
                    cellType: 'text',
                    define: Object.assign({}, hd)
                });
            }
        }
        results[id] = cell;
        layoutMap._headerObjects[id] = cell;
        _headerCellIds[row][layoutMap.colIndex] = id;
        for (let r = row - 1; r >= 0; r--) {
            _headerCellIds[r][layoutMap.colIndex] = roots[r];
        }
        if (hd.hierarchyState === HierarchyState.expand && hd.children?.length >= 1) {
            show && layoutMap.colIndex++;
            layoutMap._addHeadersForTreeMode(_headerCellIds, row, hd.children ?? [], [...roots, id], totalLevel, show && hd.hierarchyState === HierarchyState.expand, dimensions, results);
        }
        else {
            show && layoutMap.colIndex++;
            for (let r = row + 1; r < _headerCellIds.length; r++) {
                _headerCellIds[r][layoutMap.colIndex] = id;
            }
        }
    }
    function clearNode(children) {
        for (let i = 0; i < children.length; i++) {
            const node = children[i];
            delete node.level;
            delete node.startIndex;
            delete node.id;
            delete node.levelSpan;
            delete node.size;
            delete node.startInTotal;
            const childrenNew = node.children || node.columns;
            if (childrenNew) {
                clearNode(childrenNew);
            }
        }
    }
    function deleteTreeHideNode(tree_children, dimensionPath, indicators, hasHideNode, table) {
        for (let i = tree_children.length - 1; i >= 0; i--) {
            const node = tree_children[i];
            dimensionPath.push(node);
            if (hasHideNode && node.hide) {
                tree_children.splice(i, 1);
            }
            else if (node.indicatorKey) {
                const hide = indicators?.find(indicator => indicator.indicatorKey === node.indicatorKey)?.hide;
                if (typeof hide === 'function') {
                    if (hide({ dimensionPaths: dimensionPath, table })) {
                        tree_children.splice(i, 1);
                    }
                }
                else if (hide) {
                    tree_children.splice(i, 1);
                }
            }
            else if (node.children && node.children.length > 0) {
                deleteTreeHideNode(node.children, dimensionPath, indicators, hasHideNode, table);
            }
            dimensionPath.pop();
        }
    }

    function checkHasAggregation(layoutMap) {
        const columnObjects = layoutMap.columnObjects;
        for (let i = 0; i < columnObjects.length; i++) {
            const column = columnObjects[i];
            if (column?.aggregation) {
                return true;
            }
        }
        return false;
    }
    function checkHasAggregationOnTop(layoutMap) {
        const columnObjects = layoutMap.columnObjects;
        let count = 0;
        for (let i = 0; i < columnObjects.length; i++) {
            const column = columnObjects[i];
            if (column?.aggregation) {
                if (Array.isArray(column?.aggregation)) {
                    count = Math.max(count, column.aggregation.filter(item => item.showOnTop).length);
                }
                else if (column.aggregation.showOnTop) {
                    count = Math.max(count, 1);
                }
            }
        }
        return count;
    }
    function checkHasAggregationOnBottom(layoutMap) {
        const columnObjects = layoutMap.columnObjects;
        let count = 0;
        for (let i = 0; i < columnObjects.length; i++) {
            const column = columnObjects[i];
            if (column?.aggregation) {
                if (Array.isArray(column?.aggregation)) {
                    count = Math.max(count, column.aggregation.filter(item => !item.showOnTop).length);
                }
                else if (!column.aggregation.showOnTop) {
                    count = Math.max(count, 1);
                }
            }
        }
        return count;
    }
    function checkHasTreeDefine(layoutMap) {
        if (layoutMap._table.options.groupBy) {
            return true;
        }
        const { columns } = layoutMap._table.options;
        if (isArray$7(columns) && columns.length > 0) {
            for (let i = 0; i < columns.length; i++) {
                const column = columns[i];
                if (isString$4(column)) {
                    continue;
                }
                if (column.tree) {
                    return true;
                }
            }
        }
        return false;
    }
    function hasAutoImageColumn(table) {
        const { columns, rows, indicators } = table.options;
        if (table.isPivotTable()) {
            if (isArray$7(columns) && columns.length > 0) {
                for (let i = 0; i < columns.length; i++) {
                    const column = columns[i];
                    if (isString$4(column)) {
                        continue;
                    }
                    if ((column.headerType === 'image' || column.headerType === 'video' || typeof column.headerType === 'function') &&
                        column.imageAutoSizing) {
                        return true;
                    }
                }
            }
            if (isArray$7(rows) && rows.length > 0) {
                for (let i = 0; i < rows.length; i++) {
                    const row = rows[i];
                    if (isString$4(row)) {
                        continue;
                    }
                    if ((row.headerType === 'image' || row.headerType === 'video' || typeof row.headerType === 'function') &&
                        row.imageAutoSizing) {
                        return true;
                    }
                }
            }
            if (isArray$7(indicators) && indicators.length > 0) {
                for (let i = 0; i < indicators.length; i++) {
                    const indicator = indicators[i];
                    if (isString$4(indicator)) {
                        continue;
                    }
                    if (((indicator.cellType === 'image' ||
                        indicator.cellType === 'video' ||
                        typeof indicator.cellType === 'function') &&
                        indicator.imageAutoSizing) ||
                        ((indicator.headerType === 'image' ||
                            indicator.headerType === 'video' ||
                            typeof indicator.headerType === 'function') &&
                            indicator.imageAutoSizing)) {
                        return true;
                    }
                }
            }
        }
        else {
            if (isArray$7(columns) && columns.length > 0) {
                for (let i = 0; i < columns.length; i++) {
                    const column = columns[i];
                    if (((column.cellType === 'image' || column.cellType === 'video' || typeof column.cellType === 'function') &&
                        column.imageAutoSizing) ||
                        ((column.headerType === 'image' ||
                            column.headerType === 'video' ||
                            typeof column.headerType === 'function') &&
                            column.imageAutoSizing)) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
    function parseColKeyRowKeyForPivotTable(table, options) {
        let columnDimensionTree;
        let rowDimensionTree;
        if (options.columnTree) {
            if (table.options.indicatorsAsCol !== false && table.options.supplementIndicatorNodes !== false) {
                table.internalProps.columnTree = supplementIndicatorNodesForCustomTree(table.internalProps.columnTree, options.indicators);
            }
            columnDimensionTree = new DimensionTree(table.internalProps.columnTree ?? [], table.layoutNodeId, table.options.columnHierarchyType, table.options.columnHierarchyType !== 'grid' ? table.options.columnExpandLevel ?? 1 : undefined);
        }
        if (options.rowTree) {
            if (table.options.indicatorsAsCol === false && table.options.supplementIndicatorNodes !== false) {
                table.internalProps.rowTree = supplementIndicatorNodesForCustomTree(table.internalProps.rowTree, options.indicators);
            }
            rowDimensionTree = new DimensionTree(table.internalProps.rowTree ?? [], table.layoutNodeId, table.options.rowHierarchyType, table.options.rowHierarchyType !== 'grid' ? table.options.rowExpandLevel ?? 1 : undefined);
        }
        const rowKeys = rowDimensionTree?.dimensionKeys?.count
            ? rowDimensionTree.dimensionKeys.valueArr()
            : options.rows?.reduce((keys, rowObj) => {
                if (typeof rowObj === 'string') {
                    keys.push(rowObj);
                }
                else {
                    keys.push(rowObj.dimensionKey);
                }
                return keys;
            }, []) ?? [];
        const columnKeys = columnDimensionTree?.dimensionKeys?.count
            ? columnDimensionTree.dimensionKeys.valueArr()
            : options.columns?.reduce((keys, columnObj) => {
                if (typeof columnObj === 'string') {
                    keys.push(columnObj);
                }
                else {
                    keys.push(columnObj.dimensionKey);
                }
                return keys;
            }, []) ?? [];
        const indicatorKeys = options.indicators?.reduce((keys, indicatorObj) => {
            if (typeof indicatorObj === 'string') {
                keys.push(indicatorObj);
            }
            else {
                keys.push(indicatorObj.indicatorKey);
                if (indicatorObj.chartSpec ||
                    indicatorObj.sparklineSpec) {
                    if (table.internalProps.dataConfig?.aggregationRules) {
                        if (!table.internalProps.dataConfig.aggregationRules.find(aggregation => {
                            return aggregation.indicatorKey === indicatorObj.indicatorKey;
                        })) {
                            table.internalProps.dataConfig.aggregationRules.push({
                                field: indicatorObj.indicatorKey,
                                indicatorKey: indicatorObj.indicatorKey,
                                aggregationType: AggregationType.NONE
                            });
                        }
                    }
                    else if (table.internalProps.dataConfig) {
                        table.internalProps.dataConfig.aggregationRules = [
                            {
                                field: indicatorObj.indicatorKey,
                                indicatorKey: indicatorObj.indicatorKey,
                                aggregationType: AggregationType.NONE
                            }
                        ];
                    }
                    else {
                        table.internalProps.dataConfig = {
                            aggregationRules: [
                                {
                                    field: indicatorObj.indicatorKey,
                                    indicatorKey: indicatorObj.indicatorKey,
                                    aggregationType: AggregationType.NONE
                                }
                            ]
                        };
                    }
                }
            }
            return keys;
        }, []) ?? [];
        if (options.rowHierarchyType !== 'grid' && (options.extensionRows?.length ?? 0) >= 1) {
            options.extensionRows?.forEach(extensionRow => {
                const extension_rowKeys = [];
                extensionRow.rows.forEach(row => {
                    if (typeof row === 'string') {
                        extension_rowKeys.push(row);
                    }
                    else {
                        extension_rowKeys.push(row.dimensionKey);
                    }
                });
                rowKeys.push(...extension_rowKeys);
            });
        }
        return {
            rowKeys,
            columnKeys,
            indicatorKeys,
            columnDimensionTree,
            rowDimensionTree
        };
    }
    function supplementIndicatorNodesForCustomTree(customTree, indicators) {
        const checkNode = (nodes, isHasIndicator) => {
            nodes.forEach((node) => {
                if (!node.indicatorKey &&
                    !isHasIndicator &&
                    (!node.children?.length || !node.children)) {
                    node.children = indicators?.map((indicator) => {
                        if (typeof indicator === 'string') {
                            return { indicatorKey: indicator, value: indicator };
                        }
                        return { indicatorKey: indicator.indicatorKey, value: indicator.title ?? indicator.indicatorKey };
                    });
                }
                else if (node.children && Array.isArray(node.children)) {
                    checkNode(node.children, isHasIndicator || !!node.indicatorKey);
                }
            });
        };
        if (customTree?.length) {
            checkNode(customTree, false);
        }
        else {
            customTree = indicators?.map((indicator) => {
                if (typeof indicator === 'string') {
                    return { indicatorKey: indicator, value: indicator };
                }
                return { indicatorKey: indicator.indicatorKey, value: indicator.title ?? indicator.indicatorKey };
            });
        }
        return customTree;
    }
    function deleteHideIndicatorNode(treeNodeChildren, indicators, hasHideNode, table) {
        const hasHideSettingIndicators = [];
        for (let i = 0; i < indicators?.length; i++) {
            const indicator = indicators[i];
            if (indicator?.hide) {
                hasHideSettingIndicators.push(indicator);
            }
        }
        if (hasHideSettingIndicators.length || hasHideNode) {
            deleteTreeHideNode(treeNodeChildren, [], hasHideSettingIndicators, hasHideNode, table);
        }
    }

    function getRowAt(absoluteY, _this) {
        const frozen = _getTargetFrozenRowAt(_this, absoluteY);
        if (frozen) {
            return frozen;
        }
        return getTargetRowAt(absoluteY, _this) ?? { top: -1, row: -1, bottom: -1, height: -1 };
    }
    function getColAt(absoluteX, _this) {
        const frozen = _getTargetFrozenColAt(_this, absoluteX);
        if (frozen) {
            return frozen;
        }
        return getTargetColAt(absoluteX, _this) ?? { left: -1, col: -1, right: -1, width: 1 };
    }
    function getCellAt(absoluteX, absoluteY, _this) {
        const rowInfo = getRowAt(absoluteY, _this);
        const { row, top, bottom, height } = rowInfo;
        const colInfo = getColAt(absoluteX, _this);
        const { col, left, right, width } = colInfo;
        const rect = {
            left,
            right,
            top,
            bottom,
            width,
            height
        };
        return {
            row,
            col,
            rect
        };
    }
    function getTargetColAt(absoluteX, _this) {
        if (absoluteX === 0) {
            return { left: 0, col: 0, right: 0, width: 0 };
        }
        const findBefore = (startCol, startRight) => {
            let right = startRight;
            for (let col = startCol; col >= 0; col--) {
                const width = _this.getColWidth(col);
                const left = right - width;
                if (Math.round(left) <= Math.round(absoluteX) && Math.round(absoluteX) < Math.round(right)) {
                    return {
                        left,
                        col,
                        right,
                        width
                    };
                }
                right = left;
            }
            return null;
        };
        const findAfter = (startCol, startRight) => {
            let left = startRight - _this.getColWidth(startCol);
            const { colCount } = _this.internalProps;
            for (let col = startCol; col < colCount; col++) {
                const width = _this.getColWidth(col);
                const right = left + width;
                if (Math.round(left) <= Math.round(absoluteX) && Math.round(absoluteX) < Math.round(right)) {
                    return {
                        left,
                        col,
                        right,
                        width
                    };
                }
                left = right;
            }
            return null;
        };
        const candCol = computeTargetColByX(absoluteX, _this);
        const right = _this.getColsWidth(0, candCol);
        if (absoluteX >= right) {
            return findAfter(candCol, right);
        }
        return findBefore(candCol, right);
    }
    function getTargetRowAt(absoluteY, _this) {
        if (absoluteY === 0) {
            return { top: 0, row: 0, bottom: 0, height: 0 };
        }
        const floorOrRound = _this.options.customConfig?._disableColumnAndRowSizeRound === true ? Math.floor : Math.round;
        const findBefore = (startRow, startBottom) => {
            let bottom = startBottom;
            for (let row = startRow; row >= 0; row--) {
                const height = _this.getRowHeight(row);
                const top = bottom - height;
                if (floorOrRound(top) <= floorOrRound(absoluteY) && floorOrRound(absoluteY) < floorOrRound(bottom)) {
                    return {
                        top,
                        row,
                        bottom,
                        height
                    };
                }
                bottom = top;
            }
            return null;
        };
        const findAfter = (startRow, startBottom) => {
            let top = startBottom - _this.getRowHeight(startRow);
            const { rowCount } = _this.internalProps;
            for (let row = startRow; row < rowCount; row++) {
                const height = _this.getRowHeight(row);
                const bottom = top + height;
                if (floorOrRound(top) <= floorOrRound(absoluteY) && floorOrRound(absoluteY) < floorOrRound(bottom)) {
                    return {
                        top,
                        row,
                        bottom,
                        height
                    };
                }
                top = bottom;
            }
            return null;
        };
        const candRow = computeTargetRowByY(absoluteY, _this);
        const bottom = _this.getRowsHeight(0, candRow);
        if (absoluteY >= bottom) {
            return findAfter(candRow, bottom);
        }
        return findBefore(candRow, bottom);
    }
    function getTargetColAtConsiderRightFrozen(absoluteX, isConsider, _this) {
        if (absoluteX === 0) {
            return { left: 0, col: 0, right: 0, width: 0 };
        }
        absoluteX = absoluteX - _this.tableX;
        if (isConsider &&
            absoluteX > _this.tableNoFrameWidth - _this.getRightFrozenColsWidth() &&
            absoluteX < _this.tableNoFrameWidth &&
            absoluteX <= _this.getAllColsWidth()) {
            for (let i = 0; i < _this.rightFrozenColCount; i++) {
                if (absoluteX > _this.tableNoFrameWidth - _this.getColsWidth(_this.colCount - i - 1, _this.colCount - 1)) {
                    return {
                        col: _this.colCount - i - 1,
                        left: undefined,
                        right: undefined,
                        width: undefined
                    };
                }
            }
        }
        return getTargetColAt(absoluteX, _this);
    }
    function getTargetRowAtConsiderBottomFrozen(absoluteY, isConsider, _this) {
        if (absoluteY === 0) {
            return { top: 0, row: 0, bottom: 0, height: 0 };
        }
        absoluteY = absoluteY - _this.tableY;
        if (isConsider &&
            absoluteY > _this.tableNoFrameHeight - _this.getBottomFrozenRowsHeight() &&
            absoluteY < _this.tableNoFrameHeight) {
            for (let i = 0; i < _this.rightFrozenColCount; i++) {
                if (absoluteY > _this.tableNoFrameHeight - _this.getRowsHeight(_this.rowCount - i - 1, _this.rowCount - 1)) {
                    return {
                        row: _this.rowCount - i - 1,
                        top: undefined,
                        bottom: undefined,
                        height: undefined
                    };
                }
            }
        }
        return getTargetRowAt(absoluteY, _this);
    }
    function computeTargetRowByY(absoluteY, _this) {
        let defaultRowHeight = _this.defaultRowHeight;
        if (_this._rowRangeHeightsMap.get(`$0$${_this.rowCount - 1}`)) {
            defaultRowHeight = _this._rowRangeHeightsMap.get(`$0$${_this.rowCount - 1}`) / _this.rowCount;
        }
        return Math.min(Math.ceil(absoluteY / defaultRowHeight), _this.rowCount - 1);
    }
    function computeTargetColByX(absoluteX, _this) {
        if (_this._colRangeWidthsMap.get(`$0$${_this.colCount - 1}`)) {
            let startCol = 0;
            let endCol = _this.colCount - 1;
            while (endCol - startCol > 1) {
                const midCol = Math.floor((startCol + endCol) / 2);
                if (absoluteX < _this._colRangeWidthsMap.get(`$0$${midCol}`)) {
                    endCol = midCol;
                }
                else if (absoluteX > _this._colRangeWidthsMap.get(`$0$${midCol}`)) {
                    startCol = midCol;
                }
                else {
                    return midCol;
                }
            }
            return endCol;
        }
        return Math.min(Math.ceil(absoluteX / _this.internalProps.defaultColWidth), _this.colCount - 1);
    }
    function getCellAtRelativePosition(x, y, _this) {
        x -= _this.tableX;
        y -= _this.tableY;
        let topFrozen = false;
        if (y > 0 && y < _this.getFrozenRowsHeight()) {
            topFrozen = true;
        }
        let leftFrozen = false;
        if (x > 0 && x < _this.getFrozenColsWidth()) {
            leftFrozen = true;
        }
        let bottomFrozen = false;
        if (y > _this.tableNoFrameHeight - _this.getBottomFrozenRowsHeight() &&
            y < _this.tableNoFrameHeight &&
            y <= _this.getAllRowsHeight()) {
            bottomFrozen = true;
        }
        let rightFrozen = false;
        if (x > _this.tableNoFrameWidth - _this.getRightFrozenColsWidth() &&
            x < _this.tableNoFrameWidth &&
            x <= _this.getAllColsWidth()) {
            rightFrozen = true;
        }
        const colInfo = getTargetColAtConsiderRightFrozen((leftFrozen || rightFrozen ? x : x + _this.scrollLeft) + _this.tableX, rightFrozen, _this);
        const rowInfo = getTargetRowAtConsiderBottomFrozen((topFrozen || bottomFrozen ? y : y + _this.scrollTop) + _this.tableY, bottomFrozen, _this);
        if (colInfo && rowInfo) {
            const { row, top, bottom, height } = rowInfo;
            const { col, left, right, width } = colInfo;
            const rect = {
                left,
                right,
                top,
                bottom,
                width,
                height
            };
            return {
                row,
                col,
                rect
            };
        }
        return { col: -1, row: -1 };
    }

    function isValidAlignDomain(domain) {
        return domain.length === 2 && isValidNumber$1(domain[0]) && isValidNumber$1(domain[1]) && domain[1] >= domain[0];
    }
    function getScaleInfo(domain) {
        const total = domain[1] - domain[0];
        const includeZero = domain[1] * domain[0] < 0;
        let negative = domain[0] <= 0 ? 0 - domain[0] : 0;
        let positive = domain[1] > 0 ? domain[1] - 0 : 0;
        if (total === 0) {
            if (domain[0] < 0) {
                negative = 1;
                positive = 0;
            }
            else if (domain[0] > 0) {
                negative = 0;
                positive = 1;
            }
        }
        else {
            negative = negative / total;
            positive = positive / total;
        }
        return {
            total,
            negative,
            positive,
            includeZero,
            domain,
            extendable_min: true,
            extendable_max: true
        };
    }
    function inDifferentCrossZero(info1, info2) {
        const { positive: positive1, negative: negative1, extendable_min: s1Extendable_min, extendable_max: s1Extendable_max, domain: domain1 } = info1;
        const { positive: positive2, negative: negative2, extendable_min: s2Extendable_min, extendable_max: s2Extendable_max, domain: domain2 } = info2;
        if (positive2 > 0) {
            if (!s2Extendable_min) {
                return false;
            }
            let comp = negative1 / positive1;
            if (s1Extendable_max) {
                comp = negative1 / Math.max(positive1, positive2);
                domain1[1] = -domain1[0] / comp;
            }
            domain2[0] = -domain2[1] * comp;
        }
        else if (negative2 > 0) {
            if (!s2Extendable_max) {
                return false;
            }
            let comp = positive1 / negative1;
            if (s1Extendable_min) {
                comp = positive1 / Math.max(negative1, negative1);
                domain1[0] = -domain1[1] / comp;
            }
            domain2[1] = -domain2[0] * comp;
        }
        return true;
    }
    function inOnlyZeroDomain(info1, info2) {
        const { extendable_min: s1Extendable_min, extendable_max: s1Extendable_max, domain: domain1 } = info1;
        const { positive: positive2, negative: negative2, domain: domain2 } = info2;
        if (positive2 === 0 && negative2 === 0) {
            return false;
        }
        if (positive2 > 0 && !s1Extendable_max) {
            return false;
        }
        if (negative2 > 0 && !s1Extendable_min) {
            return false;
        }
        domain1[0] = domain2[0];
        domain1[1] = domain2[1];
        return true;
    }
    function inAllCrossZero(info1, info2) {
        const { positive: positive1, negative: negative1, extendable_max: s1Extendable_max, domain: domain1 } = info1;
        const { positive: positive2, negative: negative2, extendable_min: s2Extendable_min, domain: domain2 } = info2;
        if (s1Extendable_max && s2Extendable_min) {
            const comp = Math.max(negative1, negative2) / Math.max(positive1, positive2);
            domain1[1] = -domain1[0] / comp;
            domain2[0] = -domain2[1] * comp;
        }
        else if (s2Extendable_min) {
            const comp = negative1 / positive1;
            domain2[0] = -domain2[1] * comp;
        }
        else if (s1Extendable_max) {
            const comp = negative2 / positive2;
            domain1[1] = -domain1[0] / comp;
        }
        else {
            return false;
        }
        return true;
    }
    function inNoCrossDifferentSide(info1, info2) {
        const { extendable_min: s1Extendable_min, domain: domain1 } = info1;
        const { extendable_max: s2Extendable_max, domain: domain2 } = info2;
        if (!s1Extendable_min || !s2Extendable_max) {
            return false;
        }
        domain1[0] = -domain1[1];
        domain2[1] = -domain2[0];
        return true;
    }
    function getNewRangeToAlign(range1, range2) {
        const domain1 = [range1.min, range1.max];
        const domain2 = [range2.min, range2.max];
        if (!isValidAlignDomain(domain1) || !isValidAlignDomain(domain2)) {
            return undefined;
        }
        const info1 = getScaleInfo(domain1);
        const info2 = getScaleInfo(domain2);
        const { positive: positive1, negative: negative1, extendable_min: s1Extendable_min, extendable_max: s1Extendable_max, includeZero: includeZero1 } = info1;
        const { positive: positive2, negative: negative2, extendable_min: s2Extendable_min, extendable_max: s2Extendable_max, includeZero: includeZero2 } = info2;
        if (positive1 === 0 && negative1 === 0) {
            if (!inOnlyZeroDomain(info1, info2)) {
                return undefined;
            }
        }
        else if (positive2 === 0 && negative2 === 0) {
            if (!inOnlyZeroDomain(info2, info1)) {
                return undefined;
            }
        }
        else if (!includeZero1 && !includeZero2) {
            if (negative1 === 0 && positive2 === 0) {
                if (!inNoCrossDifferentSide(info1, info2)) {
                    return undefined;
                }
            }
            else if (negative2 === 0 && positive1 === 0) {
                if (!inNoCrossDifferentSide(info2, info1)) {
                    return undefined;
                }
            }
            if (negative1 === 0 && negative2 === 0) {
                if (domain1[0] === 0 && domain2[0] > 0) {
                    if (!s2Extendable_min) {
                        return undefined;
                    }
                    domain2[0] = 0;
                }
                else if (domain2[0] === 0 && domain1[0] > 0) {
                    if (!s1Extendable_min) {
                        return undefined;
                    }
                    domain1[0] = 0;
                }
                else {
                    return undefined;
                }
            }
            if (positive1 === 0 && positive2 === 0) {
                if (domain1[1] === 0 && domain2[1] > 0) {
                    if (!s2Extendable_max) {
                        return undefined;
                    }
                    domain2[1] = 0;
                }
                else if (domain2[1] === 0 && domain1[1] > 0) {
                    if (!s1Extendable_max) {
                        return undefined;
                    }
                    domain1[1] = 0;
                }
                else {
                    return undefined;
                }
            }
        }
        else if (includeZero1 && !includeZero2) {
            if (!inDifferentCrossZero(info1, info2)) {
                return undefined;
            }
        }
        else if (includeZero2 && !includeZero1) {
            if (!inDifferentCrossZero(info2, info1)) {
                return undefined;
            }
        }
        else {
            if (negative1 === negative2) {
                return undefined;
            }
            else if (negative1 > negative2) {
                if (!inAllCrossZero(info1, info2)) {
                    return undefined;
                }
            }
            else {
                if (!inAllCrossZero(info2, info1)) {
                    return undefined;
                }
            }
        }
        return { range1: domain1, range2: domain2 };
    }

    function getZeroAlignTickAlignTicks(targetRange, col, row, index, position, layout) {
        const getAxisDomainRangeAndLabels = Factory.getFunction('getAxisDomainRangeAndLabels');
        const { axisOption, isZeroAlign } = getAxisOption(col, row, index === 0 ? 'right' : 'left', layout);
        const { ticks } = getAxisDomainRangeAndLabels(targetRange.min, targetRange.max, axisOption, isZeroAlign, position === 'bottom' || position === 'top'
            ? layout._table.getColWidth(col) || layout._table.tableNoFrameWidth
            : layout._table.getRowHeight(row) || layout._table.tableNoFrameHeight);
        return ticks;
    }
    function getTickModeFunction(targetTicks, targetRange, range, indicatorIndex) {
        return indicatorIndex !== 0 && targetTicks
            ? () => {
                const newTicks = targetTicks.map((value) => {
                    const percent = (value - targetRange.min) / (targetRange.max - targetRange.min);
                    const tick = (range.max - range.min) * percent + range.min;
                    return Math.round(tick * 100) / 100;
                });
                return newTicks;
            }
            : undefined;
    }

    function getAxisConfigInPivotChart(col, row, layout) {
        if (!layout._table.isPivotChart()) {
            return undefined;
        }
        if (layout.indicatorsAsCol) {
            if (layout.hasTwoIndicatorAxes &&
                row === layout.columnHeaderLevelCount - 1 &&
                col >= layout.rowHeaderLevelCount &&
                col < layout.colCount - layout.rightFrozenColCount) {
                const axisRange = getRange('top', col, row + 1, col, layout.columnHeaderLevelCount - 1, col, row, 1, layout);
                if (!axisRange) {
                    return;
                }
                const chartCellStyle = layout._table._getCellStyle(col, row + 1);
                const padding = getQuadProps(getProp('padding', chartCellStyle, col, row + 1, layout._table));
                const { range, ticks, axisOption, targetTicks, targetRange, index, theme } = axisRange;
                if (isNumber$4(axisOption?.min)) {
                    range.min = axisOption.min;
                    if (range.min > 0) {
                        axisOption.zero = false;
                    }
                }
                if (isNumber$4(axisOption?.max)) {
                    range.max = axisOption.max;
                    if (range.max < 0) {
                        axisOption.zero = false;
                    }
                }
                return merge$1({
                    range: range
                }, axisOption, {
                    orient: 'top',
                    type: axisOption?.type || 'linear',
                    label: {
                        flush: true
                    },
                    tick: {
                        tickMode: getTickModeFunction(targetTicks, targetRange, range, index)
                    },
                    __ticksForVTable: ticks,
                    __vtableChartTheme: theme,
                    __vtablePadding: padding
                });
            }
            else if (row === layout.rowCount - layout.bottomFrozenRowCount &&
                col >= layout.rowHeaderLevelCount &&
                col < layout.colCount - layout.rightFrozenColCount) {
                const indicatorKeys = layout.getIndicatorKeyInChartSpec(col, row);
                let indicatorInfo = null;
                indicatorKeys?.forEach(key => {
                    const info = layout.getIndicatorInfo(key);
                    if (info) {
                        indicatorInfo = info;
                    }
                });
                const axisRange = getRange('bottom', col, row - 1, col, row, col, row, 0, layout);
                if (!axisRange) {
                    return;
                }
                const chartCellStyle = layout._table._getCellStyle(col, row - 1);
                const padding = getQuadProps(getProp('padding', chartCellStyle, col, row - 1, layout._table));
                const { range, ticks, axisOption, index, targetTicks, targetRange, theme } = axisRange;
                if (isNumber$4(axisOption?.min)) {
                    range.min = axisOption.min;
                    if (range.min > 0) {
                        axisOption.zero = false;
                    }
                }
                if (isNumber$4(axisOption?.max)) {
                    range.max = axisOption.max;
                    if (range.max < 0) {
                        axisOption.zero = false;
                    }
                }
                return merge$1({
                    title: {
                        visible: true,
                        text: indicatorInfo?.title
                    },
                    range
                }, axisOption, {
                    orient: 'bottom',
                    type: axisOption?.type || 'linear',
                    label: {
                        flush: true
                    },
                    tick: {
                        tickMode: getTickModeFunction(targetTicks, targetRange, range, index)
                    },
                    __ticksForVTable: ticks,
                    __vtableChartTheme: theme,
                    __vtablePadding: padding
                });
            }
            else if (col === layout.rowHeaderLevelCount - 1 &&
                row >= layout.columnHeaderLevelCount &&
                row < layout.rowCount - layout.bottomFrozenRowCount) {
                let rowDimensionKey = layout.getDimensionKeyInChartSpec(layout.rowHeaderLevelCount, row);
                if (isArray$7(rowDimensionKey)) {
                    rowDimensionKey = rowDimensionKey[0];
                }
                const data = layout.dataset.collectedValues[rowDimensionKey] ?? [];
                const rowPath = layout.getRowKeysPath(col, row);
                const domain = data[rowPath ?? ''] ?? [];
                const { axisOption, theme, chartType } = getAxisOption(col + 1, row, 'left', layout);
                if (axisOption?.visible === false) {
                    return;
                }
                const chartCellStyle = layout._table._getCellStyle(col + 1, row);
                const padding = getQuadProps(getProp('padding', chartCellStyle, col + 1, row, layout._table));
                const spec = layout.getRawChartSpec(col + 1, row);
                return merge$1({
                    domain: axisOption?.type === 'linear' ? undefined : Array.from(domain),
                    range: axisOption?.type === 'linear' ? domain : undefined,
                    title: {
                        autoRotate: true
                    }
                }, axisOption, {
                    orient: 'left',
                    type: axisOption?.type ?? 'band',
                    __vtableChartTheme: theme,
                    inverse: transformInverse(axisOption, (spec?.direction ?? (chartType === 'scatter' ? 'vertical' : 'horizontal')) === "horizontal"),
                    __vtablePadding: padding
                });
            }
        }
        else {
            if (col === layout.rowHeaderLevelCount - 1 &&
                row >= layout.columnHeaderLevelCount &&
                row < layout.rowCount - layout.bottomFrozenRowCount) {
                const indicatorKeys = layout.getIndicatorKeyInChartSpec(col, row);
                let indicatorInfo = null;
                indicatorKeys?.forEach(key => {
                    const info = layout.getIndicatorInfo(key);
                    if (info) {
                        indicatorInfo = info;
                    }
                });
                const axisRange = getRange('left', col + 1, row, col, row, col, row, 0, layout);
                if (!axisRange) {
                    return;
                }
                const chartCellStyle = layout._table._getCellStyle(col + 1, row);
                const padding = getQuadProps(getProp('padding', chartCellStyle, col + 1, row, layout._table));
                const { range, ticks, axisOption, index, targetTicks, targetRange, theme } = axisRange;
                if (isNumber$4(axisOption?.min)) {
                    range.min = axisOption.min;
                    if (range.min > 0) {
                        axisOption.zero = false;
                    }
                }
                if (isNumber$4(axisOption?.max)) {
                    range.max = axisOption.max;
                    if (range.max < 0) {
                        axisOption.zero = false;
                    }
                }
                return merge$1({
                    title: {
                        visible: true,
                        text: indicatorInfo?.title,
                        autoRotate: true
                    },
                    range: range
                }, axisOption, {
                    orient: 'left',
                    type: axisOption?.type || 'linear',
                    label: {
                        flush: true
                    },
                    tick: {
                        tickMode: getTickModeFunction(targetTicks, targetRange, range, index)
                    },
                    __ticksForVTable: ticks,
                    __vtableChartTheme: theme,
                    __vtablePadding: padding
                });
            }
            else if (col === layout.colCount - layout.rightFrozenColCount &&
                row >= layout.columnHeaderLevelCount &&
                row < layout.rowCount - layout.bottomFrozenRowCount) {
                const axisRange = getRange('right', col - 1, row, layout.rowHeaderLevelCount - 1, row, col, row, 1, layout);
                if (!axisRange) {
                    return;
                }
                const chartCellStyle = layout._table._getCellStyle(col - 1, row);
                const padding = getQuadProps(getProp('padding', chartCellStyle, col - 1, row, layout._table));
                const { range, ticks, axisOption, index, targetTicks, targetRange, theme } = axisRange;
                if (isNumber$4(axisOption?.min)) {
                    range.min = axisOption.min;
                    if (range.min > 0) {
                        axisOption.zero = false;
                    }
                }
                if (isNumber$4(axisOption?.max)) {
                    range.max = axisOption.max;
                    if (range.max < 0) {
                        axisOption.zero = false;
                    }
                }
                return merge$1({
                    range: range,
                    title: {
                        autoRotate: true
                    }
                }, axisOption, {
                    orient: 'right',
                    type: axisOption?.type || 'linear',
                    label: {
                        flush: true
                    },
                    tick: {
                        tickMode: getTickModeFunction(targetTicks, targetRange, range, index)
                    },
                    __ticksForVTable: ticks,
                    __vtableChartTheme: theme,
                    __vtablePadding: padding
                });
            }
            else if (row === layout.rowCount - layout.bottomFrozenRowCount &&
                col >= layout.rowHeaderLevelCount &&
                col < layout.colCount - layout.rightFrozenColCount) {
                let columnDimensionKey = layout.getDimensionKeyInChartSpec(col, layout.columnHeaderLevelCount);
                if (isArray$7(columnDimensionKey)) {
                    columnDimensionKey = columnDimensionKey[0];
                }
                const data = layout.dataset.collectedValues[columnDimensionKey] ?? [];
                const colPath = layout.getColKeysPath(col, row);
                const domain = data?.[colPath ?? ''] ?? [];
                const { axisOption, isPercent, theme, chartType } = getAxisOption(col, row - 1, 'bottom', layout);
                if (axisOption?.visible === false) {
                    return;
                }
                const chartCellStyle = layout._table._getCellStyle(col, row - 1);
                const padding = getQuadProps(getProp('padding', chartCellStyle, col, row - 1, layout._table));
                return merge$1({
                    domain: axisOption?.type === 'linear' ? undefined : Array.from(domain),
                    range: axisOption?.type === 'linear' ? domain : undefined
                }, axisOption, {
                    orient: 'bottom',
                    type: axisOption?.type ?? 'band',
                    __vtableChartTheme: theme,
                    __vtablePadding: padding
                });
            }
        }
        return undefined;
    }
    function getAxisOption(col, row, orient, layout) {
        const spec = layout.getRawChartSpec(col, row);
        const axes = spec.axes ?? [];
        layout._table.pivotChartAxes.forEach(axis => {
            const index = axes.findIndex((a) => {
                return axis.orient === a.orient;
            });
            if (index === -1) {
                axes.push(axis);
            }
        });
        if (spec && isArray$7(axes)) {
            const axisOption = axes.find((axis) => {
                return axis.orient === orient;
            });
            if (axisOption) {
                const { seriesIndex, seriesId } = axisOption;
                let seriesIndice;
                let seriesSpec;
                if (isValid$3(seriesId) && isArray$7(spec.series)) {
                    seriesIndice = (isArray$7(seriesId) ? seriesId : [seriesId]).map(id => {
                        const index = spec.series.findIndex((s) => s.id === id);
                        if (index >= 0) {
                            seriesSpec = spec.series[index];
                        }
                        return index;
                    });
                }
                else if (isValid$3(seriesIndex) && isArray$7(spec.series)) {
                    seriesIndice = seriesIndex;
                }
                const { isZeroAlign, isTickAlign } = checkZeroAlign(spec, orient, layout);
                return {
                    axisOption,
                    isPercent: spec.percent,
                    isZeroAlign,
                    isTickAlign,
                    seriesIndice,
                    theme: spec.theme,
                    chartType: seriesSpec?.type ?? spec.type
                };
            }
        }
        const axisOption = layout._table.pivotChartAxes.find(axisOption => {
            return axisOption.orient === orient;
        });
        const { isZeroAlign, isTickAlign } = checkZeroAlign(spec, orient, layout);
        return {
            axisOption,
            isPercent: false,
            isZeroAlign,
            isTickAlign,
            theme: spec.theme,
            chartType: spec.type
        };
    }
    function checkZeroAlign(spec, orient, layout) {
        const orients = [];
        if (orient === 'left' || orient === 'right') {
            orients.push('left', 'right');
        }
        else if (orient === 'top' || orient === 'bottom') {
            orients.push('top', 'bottom');
        }
        let axesSpec;
        if (spec && isArray$7(spec.axes)) {
            axesSpec = spec.axes;
        }
        else {
            axesSpec = layout._table.pivotChartAxes;
        }
        let isZeroAlign = false;
        let isTickAlign = false;
        if (isArray$7(axesSpec)) {
            const axes = [];
            axesSpec.forEach((axis) => {
                if (orients.includes(axis.orient)) {
                    axes.push(axis);
                }
            });
            for (let i = 0; i < axes.length; i++) {
                const axis = axes[i];
                if (axis.sync &&
                    axis.sync.axisId &&
                    axes.find(axisSync => {
                        return axisSync.id === axis.sync.axisId;
                    })) {
                    isZeroAlign = isZeroAlign || axis.sync.zeroAlign;
                    isTickAlign = isTickAlign || axis.sync.tickAlign;
                }
            }
        }
        return {
            isZeroAlign,
            isTickAlign
        };
    }
    function getAxisRange(collectedValues, indicatorKeys, isZeroAlign, colPath, seriesId) {
        if (isArray$7(seriesId)) {
            const range = { min: Infinity, max: -Infinity };
            for (let i = 0; i < seriesId.length; i++) {
                const singleRange = getAxisRange(collectedValues, indicatorKeys, isZeroAlign, colPath, seriesId[i]);
                if (singleRange) {
                    range.min = Math.min(range.min, singleRange.min);
                    range.max = Math.max(range.max, singleRange.max);
                }
            }
            if (isFinite(range.min) && isFinite(range.max)) {
                return range;
            }
            return null;
        }
        let defaultKey = indicatorKeys?.[seriesId];
        if (isArray$7(defaultKey)) {
            defaultKey = defaultKey[0];
        }
        if (!defaultKey) {
            return null;
        }
        const data = collectedValues[defaultKey];
        const range = merge$1({}, data?.[colPath ?? ''] ?? { min: 0, max: 1 });
        if (range.positiveMax && range.positiveMax > range.max) {
            range.max = range.positiveMax;
        }
        if (range.negativeMin && range.negativeMin < range.min) {
            range.min = range.negativeMin;
        }
        if (range.min === range.max) {
            if (range.min > 0) {
                range.min = 0;
            }
            else {
                range.max = 0;
            }
        }
        return range;
    }
    function isTopOrBottomAxis(col, row, layout) {
        if (!layout._table.isPivotChart()) {
            return false;
        }
        if (layout.indicatorsAsCol) {
            if (layout.hasTwoIndicatorAxes &&
                row === layout.columnHeaderLevelCount - 1 &&
                col >= layout.rowHeaderLevelCount &&
                col < layout.colCount - layout.rightFrozenColCount) {
                return true;
            }
            else if (row === layout.rowCount - layout.bottomFrozenRowCount &&
                col >= layout.rowHeaderLevelCount &&
                col < layout.colCount - layout.rightFrozenColCount) {
                return true;
            }
        }
        else {
            if (row === layout.rowCount - layout.bottomFrozenRowCount &&
                col >= layout.rowHeaderLevelCount &&
                col < layout.colCount - layout.rightFrozenColCount) {
                return true;
            }
        }
        return false;
    }
    function isLeftOrRightAxis(col, row, layout) {
        if (!layout._table.isPivotChart()) {
            return false;
        }
        if (layout.indicatorsAsCol) {
            if (col === layout.rowHeaderLevelCount - 1 &&
                row >= layout.columnHeaderLevelCount &&
                row < layout.rowCount - layout.bottomFrozenRowCount) {
                return true;
            }
        }
        else {
            if (col === layout.rowHeaderLevelCount - 1 &&
                row >= layout.columnHeaderLevelCount &&
                row < layout.rowCount - layout.bottomFrozenRowCount) {
                return true;
            }
            else if (col === layout.colCount - layout.rightFrozenColCount &&
                row >= layout.columnHeaderLevelCount &&
                row < layout.rowCount - layout.bottomFrozenRowCount) {
                return true;
            }
        }
        return false;
    }
    var Direction;
    (function (Direction) {
        Direction["vertical"] = "vertical";
        Direction["horizontal"] = "horizontal";
    })(Direction || (Direction = {}));
    function transformInverse(spec, isHorizontal) {
        let inverse = spec?.inverse;
        if (isHorizontal && !isXAxis$1(spec?.orient)) {
            inverse = isValid$3(spec?.inverse) ? !spec?.inverse : true;
        }
        return inverse;
    }
    function isXAxis$1(orient) {
        return orient === 'bottom' || orient === 'top';
    }
    function hasLinearAxis(spec, tableAxesConfig, isHorizontal, isThisXAxis) {
        if (!isArray$7(spec.axes) || spec.axes.length === 0) {
            return (isHorizontal && isThisXAxis) || (!isHorizontal && !isThisXAxis);
        }
        for (let i = 0; i < spec.axes.length; i++) {
            const axisSpec = spec.axes[i];
            if (!isHorizontal && isThisXAxis && axisSpec.orient === 'bottom' && axisSpec.type === 'linear') {
                return true;
            }
            if (isHorizontal && isThisXAxis && axisSpec.orient === 'bottom' && axisSpec.type !== 'linear') {
                return true;
            }
            if (!isHorizontal && !isThisXAxis && axisSpec.orient === 'left' && axisSpec.type !== 'linear') {
                return true;
            }
            if (isHorizontal && !isThisXAxis && axisSpec.orient === 'left' && axisSpec.type === 'linear') {
                return true;
            }
        }
        if (isArray$7(tableAxesConfig) && tableAxesConfig.length > 0) {
            for (let i = 0; i < tableAxesConfig.length; i++) {
                const axisSpec = tableAxesConfig[i];
                if (!isHorizontal && isThisXAxis && axisSpec.orient === 'bottom' && axisSpec.type === 'linear') {
                    return true;
                }
                if (isHorizontal && isThisXAxis && axisSpec.orient === 'bottom' && axisSpec.type !== 'linear') {
                    return true;
                }
                if (!isHorizontal && !isThisXAxis && axisSpec.orient === 'left' && axisSpec.type !== 'linear') {
                    return true;
                }
                if (isHorizontal && !isThisXAxis && axisSpec.orient === 'left' && axisSpec.type === 'linear') {
                    return true;
                }
            }
        }
        return (isHorizontal && isThisXAxis) || (!isHorizontal && !isThisXAxis);
    }
    function getRange(position, colForAxisOption, rowForAxisOption, colForIndicatorKey, rowForIndicatorKey, col, row, defaultSeriesIndice, layout) {
        const indicatorKeys = layout.getIndicatorKeyInChartSpec(colForIndicatorKey, rowForIndicatorKey);
        let path;
        if (position === 'top' || position === 'bottom') {
            path = layout.getColKeysPath(col, row);
        }
        else {
            path = layout.getRowKeysPath(col, row);
        }
        const rangeConfig = getChartAxisRange(colForAxisOption, rowForAxisOption, defaultSeriesIndice, position, indicatorKeys, path, layout);
        if (!rangeConfig) {
            return undefined;
        }
        const subAxisPosition = position === 'bottom' ? 'top' : position === 'top' ? 'bottom' : position === 'left' ? 'right' : 'left';
        const { targetRange, targetTicks } = getTargetRangeAndTicks(colForAxisOption, rowForAxisOption, rangeConfig.index, rangeConfig.isZeroAlign, rangeConfig.isTickAlign, rangeConfig.range, indicatorKeys, subAxisPosition, path, layout);
        if (rangeConfig.index !== 0 && targetTicks) {
            const getAxisDomainRangeAndLabels = Factory.getFunction('getAxisDomainRangeAndLabels');
            const { range: newRange, ticks: newTicks } = getAxisDomainRangeAndLabels(rangeConfig.range.min, rangeConfig.range.max, rangeConfig.axisOption, rangeConfig.isZeroAlign, position === 'bottom' || position === 'top'
                ? layout._table.getColWidth(col) || layout._table.tableNoFrameWidth
                : layout._table.getRowHeight(row) || layout._table.tableNoFrameHeight, {
                targetTicks,
                targetRange
            });
            rangeConfig.range.min = newRange[0];
            rangeConfig.range.max = newRange[1];
            rangeConfig.ticks = newTicks;
        }
        rangeConfig.targetRange = targetRange;
        rangeConfig.targetTicks = targetTicks;
        return rangeConfig;
    }
    function getChartAxisRange(col, row, index, position, indicatorKeys, path, layout) {
        const { axisOption, isPercent, isZeroAlign, isTickAlign, seriesIndice, theme, chartType } = getAxisOption(col, row, position, layout);
        const range = getAxisRange(layout.dataset.collectedValues, indicatorKeys, isZeroAlign, path, seriesIndice ?? index);
        if (!range) {
            return undefined;
        }
        if (isPercent) {
            range.min = range.min < 0 ? -1 : 0;
            range.max = range.max > 0 ? 1 : 0;
        }
        if (axisOption?.zero || range.min === range.max) {
            range.min = Math.min(range.min, 0);
            range.max = Math.max(range.max, 0);
        }
        const getAxisDomainRangeAndLabels = Factory.getFunction('getAxisDomainRangeAndLabels');
        const { range: axisRange, ticks: selfTicks } = getAxisDomainRangeAndLabels(range.min, range.max, axisOption, isZeroAlign, position === 'bottom' || position === 'top'
            ? layout._table.getColWidth(col) || layout._table.tableNoFrameWidth
            : layout._table.getRowHeight(row) || layout._table.tableNoFrameHeight);
        if (axisOption?.nice) {
            range.min = axisRange[0];
            range.max = axisRange[1];
        }
        const ticks = selfTicks;
        if (isNumber$4(axisOption?.min)) {
            range.min = axisOption.min;
        }
        if (isNumber$4(axisOption?.max)) {
            range.max = axisOption.max;
        }
        return {
            index: seriesIndice ?? index,
            range,
            ticks,
            isZeroAlign,
            isTickAlign,
            axisOption,
            theme,
            chartType
        };
    }
    function getAxisRangeAndTicks(col, row, index, position, subAxisPosition, indicatorKeys, path, layout) {
        const { range, isZeroAlign, isTickAlign, axisOption } = getChartAxisRange(col, row, index, position, indicatorKeys, path, layout);
        const { targetRange, targetTicks } = getTargetRangeAndTicks(col, row, index, isZeroAlign, isTickAlign, range, indicatorKeys, subAxisPosition, path, layout);
        if (index !== 0 && targetTicks) {
            const getAxisDomainRangeAndLabels = Factory.getFunction('getAxisDomainRangeAndLabels');
            const { range: newRange, ticks: newTicks } = getAxisDomainRangeAndLabels(range.min, range.max, merge$1({}, axisOption, { nice: true, tick: { forceTickCount: targetTicks.length } }), isZeroAlign, position === 'bottom' || position === 'top'
                ? layout._table.getColWidth(col) || layout._table.tableNoFrameWidth
                : layout._table.getRowHeight(row) || layout._table.tableNoFrameHeight, {
                targetTicks,
                targetRange
            });
            range.min = newRange[0];
            range.max = newRange[1];
        }
        return {
            axisOption,
            range,
            targetTicks,
            targetRange
        };
    }
    function getTargetRangeAndTicks(col, row, index, isZeroAlign, isTickAlign, range, indicatorKeys, subAxisPosition, path, layout) {
        let targetTicks;
        let targetRange;
        if (!isZeroAlign && !isTickAlign) {
            return {
                targetTicks,
                targetRange
            };
        }
        const subAxisRange = getChartAxisRange(col, row, indicatorKeys.length - 1 - index, subAxisPosition, indicatorKeys, path, layout);
        if (subAxisRange) {
            const { range: subRange, ticks: subTicks } = subAxisRange;
            targetRange = subRange;
            if (isZeroAlign) {
                const align = getNewRangeToAlign(range, subRange);
                if (align) {
                    range.min = align.range1[0];
                    range.max = align.range1[1];
                    targetRange.min = align.range2[0];
                    targetRange.max = align.range2[1];
                }
            }
            if (isTickAlign) {
                if (!isZeroAlign) {
                    targetTicks = subTicks;
                }
                else {
                    targetTicks = getZeroAlignTickAlignTicks(targetRange, col, row, index, subAxisPosition, layout);
                }
            }
        }
        return {
            targetTicks,
            targetRange
        };
    }

    class CustomCellStylePlugin {
        table;
        customCellStyle;
        customCellStyleArrangement;
        constructor(table, customCellStyle, customCellStyleArrangement) {
            this.table = table;
            this.customCellStyle = customCellStyle;
            this.customCellStyleArrangement = customCellStyleArrangement;
        }
        getCustomCellStyle(col, row) {
            const customStyleIds = this.getCustomCellStyleIds(col, row);
            if (customStyleIds.length) {
                const styles = [];
                customStyleIds.forEach(customStyleId => {
                    const styleOption = this.getCustomCellStyleOption(customStyleId);
                    if (isFunction$5(styleOption?.style)) {
                        const style = styleOption.style({
                            col,
                            row,
                            table: this.table,
                            value: this.table.getCellValue(col, row),
                            dataValue: this.table.getCellOriginValue(col, row),
                            cellHeaderPaths: this.table.getCellHeaderPaths(col, row)
                        });
                        styles.push(style);
                    }
                    else if (styleOption?.style) {
                        styles.push(styleOption.style);
                    }
                });
                return merge$1({}, ...styles);
            }
            return undefined;
        }
        getCustomCellStyleIds(col, row) {
            const customStyleIds = [];
            const range = this.table.getCellRange(col, row);
            for (let c = range.start.col; c <= range.end.col; c++) {
                for (let r = range.start.row; r <= range.end.row; r++) {
                    this.customCellStyleArrangement.forEach(style => {
                        if (style.cellPosition.range) {
                            if (style.cellPosition.range.start.col <= c &&
                                style.cellPosition.range.end.col >= c &&
                                style.cellPosition.range.start.row <= r &&
                                style.cellPosition.range.end.row >= r) {
                                customStyleIds.push(style.customStyleId);
                            }
                        }
                        else if (style.cellPosition.col === c && style.cellPosition.row === r) {
                            customStyleIds.push(style.customStyleId);
                        }
                    });
                }
            }
            return customStyleIds;
        }
        getCustomCellStyleOption(customStyleId) {
            return this.customCellStyle.find(style => style.id === customStyleId);
        }
        registerCustomCellStyle(customStyleId, customStyle) {
            const index = this.customCellStyle.findIndex(style => style.id === customStyleId);
            if (index === -1) {
                this.customCellStyle.push({
                    id: customStyleId,
                    style: customStyle
                });
            }
            else {
                this.customCellStyle[index] = {
                    id: customStyleId,
                    style: customStyle
                };
            }
            this.customCellStyleArrangement.forEach(cellStyle => {
                const cellPos = cellStyle.cellPosition;
                if (cellStyle.customStyleId === customStyleId) {
                    if (cellPos.range) {
                        for (let col = Math.max(0, cellPos.range.start.col); col <= Math.min(this.table.colCount - 1, cellPos.range.end.col); col++) {
                            for (let row = Math.max(0, cellPos.range.start.row); row <= Math.min(this.table.rowCount - 1, cellPos.range.end.row); row++) {
                                this.table.scenegraph.updateCellContent(col, row);
                            }
                        }
                    }
                    else {
                        this.table.scenegraph.updateCellContent(cellPos.col, cellPos.row);
                    }
                }
            });
            this.table.scenegraph.updateNextFrame();
        }
        arrangeCustomCellStyle(cellPos, customStyleId, forceFastUpdate) {
            const index = this.customCellStyleArrangement.findIndex(style => {
                if (style.cellPosition.range && cellPos.range) {
                    return (style.cellPosition.range.start.col === cellPos.range.start.col &&
                        style.cellPosition.range.start.row === cellPos.range.start.row &&
                        style.cellPosition.range.end.col === cellPos.range.end.col &&
                        style.cellPosition.range.end.row === cellPos.range.end.row);
                }
                return style.cellPosition.col === cellPos.col && style.cellPosition.row === cellPos.row;
            });
            if (index === -1 && !customStyleId) {
                return;
            }
            else if (index === -1 && customStyleId) {
                this.customCellStyleArrangement.push({
                    cellPosition: {
                        col: cellPos.col,
                        row: cellPos.row,
                        range: cellPos.range
                    },
                    customStyleId: customStyleId
                });
            }
            else if (this.customCellStyleArrangement[index].customStyleId === customStyleId) {
                return;
            }
            else if (customStyleId) {
                this.customCellStyleArrangement[index].customStyleId = customStyleId;
            }
            else {
                this.customCellStyleArrangement.splice(index, 1);
            }
            const style = this.getCustomCellStyleOption(customStyleId)?.style;
            if (style) {
                forceFastUpdate = true;
                for (const key in style) {
                    if (cellStyleKeys.indexOf(key) === -1) {
                        forceFastUpdate = false;
                        break;
                    }
                }
            }
            if (cellPos.range) {
                for (let col = Math.max(0, cellPos.range.start.col); col <= Math.min(this.table.colCount - 1, cellPos.range.end.col); col++) {
                    for (let row = Math.max(0, cellPos.range.start.row); row <= Math.min(this.table.rowCount - 1, cellPos.range.end.row); row++) {
                        const range = this.table.getCellRange(col, row);
                        for (let c = range.start.col; c <= range.end.col; c++) {
                            for (let r = range.start.row; r <= range.end.row; r++) {
                                this.table.scenegraph.updateCellContent(c, r, forceFastUpdate);
                            }
                        }
                    }
                }
            }
            else {
                this.table.scenegraph.updateCellContent(cellPos.col, cellPos.row, forceFastUpdate);
            }
            this.table.scenegraph.updateNextFrame();
        }
        updateCustomCell(customCellStyle, customCellStyleArrangement) {
            this.customCellStyle.length = 0;
            this.customCellStyleArrangement.length = 0;
            customCellStyle.forEach((cellStyle) => {
                this.registerCustomCellStyle(cellStyle.id, cellStyle.style);
            });
            customCellStyleArrangement.forEach((cellStyle) => {
                this.arrangeCustomCellStyle(cellStyle.cellPosition, cellStyle.customStyleId);
            });
        }
        hasCustomCellStyle(customStyleId) {
            return this.customCellStyle.some(style => style.id === customStyleId);
        }
    }
    function mergeStyle(cacheStyle, customCellStyle) {
        cacheStyle = cacheStyle.clone();
        for (const key in customCellStyle) {
            const value = customCellStyle[key];
            if (isValid$3(value)) {
                cacheStyle[`_${key}`] = value;
            }
        }
        return cacheStyle;
    }
    const registerCustomCellStylePlugin = () => {
        Factory.registerComponent('customCellStylePlugin', CustomCellStylePlugin);
    };

    const EMPTY_STYLE = {};
    function getCellStyle(col, row, table) {
        const customCellStyle = table.customCellStylePlugin?.getCustomCellStyle(col, row);
        const { layoutMap } = table.internalProps;
        const isHeader = layoutMap.isHeader(col, row);
        if (isHeader) {
            let cacheKey;
            if (table.isPivotTable() && !table.isBottomFrozenRow(row) && !table.isRightFrozenColumn(col)) {
                const define = table.getHeaderDefine(col, row);
                const isCorner = table.isCornerHeader(col, row);
                cacheKey = define?.dimensionKey
                    ? isCorner
                        ? `dim-cor-${define.dimensionKey}`
                        : `dim-${define.dimensionKey}`
                    : define?.indicatorKey
                        ? `ind-${define.indicatorKey}`
                        : `${col}-${row}`;
            }
            else {
                cacheKey = `${col}-${row}`;
            }
            let cacheStyle = table.headerStyleCache.get(cacheKey);
            if (cacheStyle) {
                if (customCellStyle) {
                    return mergeStyle(cacheStyle, customCellStyle);
                }
                return cacheStyle;
            }
            const hd = layoutMap.getHeader(col, row);
            let paddingForAxis;
            if (table.isPivotChart() &&
                isTopOrBottomAxis(col, row, layoutMap) &&
                layoutMap.isAxisCell(col, row)) {
                const chartColumn = layoutMap.getBody(col, table.rowHeaderLevelCount);
                const padding = chartColumn.style?.padding ?? table.theme.bodyStyle.padding;
                paddingForAxis = padding;
            }
            else if (table.isPivotChart() &&
                isLeftOrRightAxis(col, row, layoutMap) &&
                layoutMap.isAxisCell(col, row)) {
                const chartColumn = layoutMap.getBody(table.columnHeaderLevelCount, row);
                const padding = chartColumn.style?.padding ?? table.theme.bodyStyle.padding;
                paddingForAxis = padding;
            }
            if ((!hd || hd.isEmpty) &&
                (layoutMap.isLeftBottomCorner(col, row) ||
                    layoutMap.isRightBottomCorner(col, row) ||
                    layoutMap.isCornerHeader(col, row) ||
                    layoutMap.isRightTopCorner(col, row))) {
                return EMPTY_STYLE;
            }
            const styleClass = table.internalProps.headerHelper.getStyleClass(hd?.headerType || 'text');
            if (layoutMap.isBottomFrozenRow(col, row) && table.theme.bottomFrozenStyle) {
                cacheStyle = of(paddingForAxis ? { padding: paddingForAxis } : {}, table.theme.bottomFrozenStyle, {
                    col,
                    row,
                    table: table,
                    value: table.getCellValue(col, row),
                    dataValue: table.getCellOriginValue(col, row),
                    cellHeaderPaths: table.getCellHeaderPaths(col, row)
                }, styleClass, table.options.autoWrapText, table.theme);
            }
            else if (layoutMap.isRightFrozenColumn(col, row) && table.theme.rightFrozenStyle) {
                cacheStyle = of(paddingForAxis ? { padding: paddingForAxis } : {}, table.theme.rightFrozenStyle, {
                    col,
                    row,
                    table: table,
                    value: table.getCellValue(col, row),
                    dataValue: table.getCellOriginValue(col, row),
                    cellHeaderPaths: table.getCellHeaderPaths(col, row)
                }, styleClass, table.options.autoWrapText, table.theme);
            }
            else {
                const style = hd?.style || {};
                if (paddingForAxis) {
                    style.padding = paddingForAxis;
                }
                cacheStyle = of(style, layoutMap.isColumnHeader(col, row) || layoutMap.isBottomFrozenRow(col, row)
                    ? table.theme.headerStyle
                    : layoutMap.isRowHeader(col, row) || layoutMap.isRightFrozenColumn(col, row)
                        ? table.theme.rowHeaderStyle
                        : table.theme.cornerHeaderStyle, {
                    col,
                    row,
                    table: table,
                    value: table.getCellValue(col, row),
                    dataValue: table.getCellOriginValue(col, row),
                    cellHeaderPaths: table.getCellHeaderPaths(col, row)
                }, styleClass, table.options.autoWrapText, table.theme);
            }
            table.headerStyleCache.set(cacheKey, cacheStyle);
            if (customCellStyle) {
                return mergeStyle(cacheStyle, customCellStyle);
            }
            return cacheStyle;
        }
        let bgColorFunc;
        if (table.internalProps?.dataConfig?.mappingRules && !table.isHeader(col, row)) {
            table.internalProps?.dataConfig?.mappingRules?.forEach((mappingRule, i) => {
                if (mappingRule.bgColor &&
                    table.internalProps.layoutMap.getIndicatorKey(col, row) ===
                        mappingRule.bgColor.indicatorKey) {
                    bgColorFunc = mappingRule.bgColor.mapping;
                }
            });
        }
        let cacheKey;
        const cellType = table.getCellType(col, row);
        const rawRecord = table.getCellOriginRecord(col, row);
        if (rawRecord?.vtableMerge) {
            cacheKey = 'merge-title';
        }
        else if (table.isSeriesNumberInBody(col, row)) {
            cacheKey = `${col}-series-` + cellType;
        }
        else if ((table.isListTable() && !table.transpose) ||
            (table.isPivotTable() && table.internalProps.layoutMap.indicatorsAsCol)) {
            cacheKey = col + cellType;
        }
        else {
            cacheKey = row + cellType;
        }
        let cacheStyle;
        if (rawRecord?.vtableMerge) {
            cacheStyle = table.bodyMergeTitleCache.get(cacheKey);
        }
        else if (layoutMap.isBottomFrozenRow(row)) {
            cacheStyle = table.bodyBottomStyleCache.get(cacheKey);
        }
        else {
            cacheStyle = table.bodyStyleCache.get(cacheKey);
        }
        if (cacheStyle) {
            if (customCellStyle) {
                return mergeStyle(cacheStyle, customCellStyle);
            }
            return cacheStyle;
        }
        const column = layoutMap.getBody(col, row);
        const styleClass = table.internalProps.bodyHelper.getStyleClass(table.getCellType(col, row));
        const style = column?.style;
        cacheStyle = of$2(style, rawRecord?.vtableMerge && table.theme.groupTitleStyle
            ? table.theme.groupTitleStyle
            : layoutMap.isBottomFrozenRow(row) && table.theme.bottomFrozenStyle
                ? table.theme.bottomFrozenStyle
                : layoutMap.isRightFrozenColumn(col) && table.theme.rightFrozenStyle
                    ? table.theme.rightFrozenStyle
                    : table.theme.bodyStyle, {
            col,
            row,
            table: table,
            value: table.getCellValue(col, row),
            dataValue: table.getCellOriginValue(col, row),
            cellHeaderPaths: table.getCellHeaderPaths(col, row)
        }, styleClass, table.options.autoWrapText, table.theme);
        if (bgColorFunc) {
            cacheStyle = mergeStyle(cacheStyle, { bgColor: bgColorFunc });
        }
        if (!isFunction$5(style)) {
            if (layoutMap.isBottomFrozenRow(row)) {
                table.bodyBottomStyleCache.set(cacheKey, cacheStyle);
            }
            else {
                table.bodyStyleCache.set(cacheKey, cacheStyle);
            }
        }
        if (customCellStyle) {
            return mergeStyle(cacheStyle, customCellStyle);
        }
        return cacheStyle;
    }

    function isInteger(value) {
        return Math.floor(value) === value;
    }
    class Animateaaa extends ACustomAnimate {
        onUpdate(end, ratio, out) {
            if (this.from.x !== this.to.x) {
                const x = end ? this.to.x : this.from.x + Math.floor((this.to.x - this.from.x) * ratio);
                this.params.table.scrollLeft = x;
            }
            if (this.from.y !== this.to.y) {
                const y = end ? this.to.y : this.from.y + Math.floor((this.to.y - this.from.y) * ratio);
                this.params.table.scrollTop = y;
            }
        }
    }
    class TableAnimationManager {
        table;
        timeline;
        ticker;
        animation;
        tempGraphic;
        constructor(table) {
            this.table = table;
            this.timeline = new DefaultTimeline();
            this.ticker = new DefaultTicker();
            this.ticker.addTimeline(this.timeline);
            const TICKER_FPS = 60;
            this.ticker.setFPS(TICKER_FPS);
            this.tempGraphic = createRect({});
        }
        scrollTo(position, animationOption) {
            const from = {
                x: this.table.scrollLeft,
                y: this.table.scrollTop
            };
            const { col, row } = position;
            let colInt = col;
            let rowInt = row;
            let colDecimal;
            let rowDecimal;
            if (isNumber$4(col) && !isInteger(col)) {
                colInt = Math.floor(col);
                colDecimal = col - colInt;
            }
            if (isNumber$4(row) && !isInteger(row)) {
                rowInt = Math.floor(row);
                rowDecimal = row - rowInt;
            }
            const cellRect = this.table.getCellRect(colInt ?? 0, rowInt ?? 0);
            let { left, top } = cellRect;
            if (colDecimal) {
                left += colDecimal * cellRect.width;
            }
            if (rowDecimal) {
                top += rowDecimal * cellRect.height;
            }
            const to = {
                x: isNumber$4(col) ? left - this.table.getFrozenColsWidth() : this.table.scrollLeft,
                y: isNumber$4(row) ? top - this.table.getFrozenRowsHeight() : this.table.scrollTop
            };
            const duration = !isBoolean$4(animationOption) ? animationOption?.duration ?? 3000 : animationOption ? 3000 : 0;
            const easing = !isBoolean$4(animationOption) ? animationOption?.easing ?? 'linear' : animationOption ? 'linear' : '';
            new Animate(Generator.GenAutoIncrementId(), this.timeline).bind(this.tempGraphic).play(new Animateaaa(from, to, duration, easing, {
                graphic: this.tempGraphic,
                table: this.table
            }));
            this.ticker.start();
        }
        clear() {
            this.timeline.clear();
            this.ticker.stop();
        }
    }

    function getCustomMergeCellFunc(customMergeCell) {
        if (isFunction$5(customMergeCell)) {
            return customMergeCell;
        }
        if (isArray$7(customMergeCell)) {
            return (col, row) => {
                return customMergeCell.find(item => {
                    return (item.range.start.col <= col &&
                        item.range.end.col >= col &&
                        item.range.start.row <= row &&
                        item.range.end.row >= row);
                });
            };
        }
        return undefined;
    }

    class PluginManager {
        plugins = new Map();
        table;
        constructor(table, options) {
            this.table = table;
            options.plugins?.map(plugin => {
                this.register(plugin);
                this._bindTableEventForPlugin(plugin);
            });
        }
        register(plugin) {
            this.plugins.set(plugin.id, plugin);
        }
        registerAll(plugins) {
            plugins.forEach(plugin => this.register(plugin));
        }
        getPlugin(id) {
            return this.plugins.get(id);
        }
        getPluginByName(name) {
            return Array.from(this.plugins.values()).find(plugin => plugin.name === name);
        }
        _bindTableEventForPlugin(plugin) {
            plugin.runTime?.forEach(runTime => {
                this.table.on(runTime, (...args) => {
                    plugin.run?.(...args, runTime, this.table);
                });
            });
        }
        updatePlugins(plugins) {
            const removedPlugins = Array.from(this.plugins.values()).filter(plugin => !plugins?.some(p => p.id === plugin.id));
            removedPlugins.forEach(plugin => {
                this.release();
                this.plugins.delete(plugin.id);
            });
            this.plugins.forEach(plugin => {
                if (plugin.update) {
                    plugin.update();
                }
            });
            const addedPlugins = plugins?.filter(plugin => !this.plugins.has(plugin.id));
            addedPlugins?.forEach(plugin => {
                this.register(plugin);
                this._bindTableEventForPlugin(plugin);
            });
        }
        release() {
            this.plugins.forEach(plugin => {
                plugin.release?.(this.table);
            });
        }
    }

    const { toBoxArray } = style;
    const { isTouchEvent } = event;
    const rangeReg = /^\$(\d+)\$(\d+)$/;
    importStyle$2();
    class BaseTable extends EventTarget$1 {
        internalProps;
        showFrozenIcon = true;
        padding;
        globalDropDownMenu;
        tableNoFrameWidth;
        tableNoFrameHeight;
        tableX;
        tableY;
        _widthMode;
        _heightMode;
        _autoFillWidth;
        _autoFillHeight;
        _widthAdaptiveMode;
        _heightAdaptiveMode;
        customRender;
        canvasWidth;
        canvasHeight;
        _vDataSet;
        scenegraph;
        stateManager;
        eventManager;
        editorManager;
        animationManager;
        _pixelRatio;
        canvasSizeSeted;
        static get EVENT_TYPE() {
            return TABLE_EVENT_TYPE;
        }
        options;
        version = "1.18.3";
        pagination;
        id = `VTable${Date.now()}`;
        headerStyleCache;
        bodyStyleCache;
        bodyMergeTitleCache;
        bodyBottomStyleCache;
        container;
        isReleased = false;
        _chartEventMap = {};
        customCellStylePlugin;
        columnWidthComputeMode;
        reactCustomLayout;
        _hasAutoImageColumn;
        pluginManager;
        rotateDegree;
        constructor(container, options = {}) {
            super();
            if (Env.mode === 'node') {
                options = container;
                container = null;
            }
            else if (!(container instanceof HTMLElement)) {
                options = container;
                if (container.container) {
                    container = container.container;
                }
                else {
                    container = null;
                }
            }
            if (!container && options.mode !== 'node' && !options.canvas) {
                throw new Error("vtable's container is undefined");
            }
            this.pluginManager = new PluginManager(this, options);
            this.fireListeners(TABLE_EVENT_TYPE.BEFORE_INIT, { options, container });
            container = options.container && options.container instanceof HTMLElement ? options.container : container;
            if (options.customConfig?.imageAnonymous === false) {
                vglobal.isImageAnonymous = false;
            }
            const { frozenColCount = 0, unfreezeAllOnExceedsMaxWidth, frozenRowCount, defaultRowHeight = 40, defaultHeaderRowHeight, defaultColWidth = 80, defaultHeaderColWidth, widthMode = 'standard', heightMode = 'standard', autoFillWidth = false, autoFillHeight = false, widthAdaptiveMode = 'only-body', heightAdaptiveMode = 'only-body', keyboardOptions, eventOptions, rowSeriesNumber, columnResizeMode, rowResizeMode = 'none', resize, dragHeaderMode, dragOrder, showFrozenIcon, allowFrozenColCount, padding, hover, menu, select: click, customRender, pixelRatio = defaultPixelRatio, renderChartAsync, renderChartAsyncBatchCount, mode, modeParams, canvasWidth, canvasHeight, overscrollBehavior, limitMinWidth, limitMinHeight, clearDOM = true } = options;
            this.container = container;
            this.options = options;
            this._widthMode = widthMode;
            this._heightMode = heightMode;
            this._widthAdaptiveMode = widthAdaptiveMode;
            this._heightAdaptiveMode = heightAdaptiveMode;
            this._autoFillWidth = autoFillWidth;
            this._autoFillHeight = autoFillHeight;
            this.customRender = customRender;
            this.padding = { top: 0, right: 0, left: 0, bottom: 0 };
            if (padding) {
                if (typeof padding === 'number') {
                    this.padding.top = padding;
                    this.padding.left = padding;
                    this.padding.bottom = padding;
                    this.padding.right = padding;
                }
                else {
                    padding.top && (this.padding.top = padding.top);
                    padding.bottom && (this.padding.bottom = padding.bottom);
                    padding.left && (this.padding.left = padding.left);
                    padding.right && (this.padding.right = padding.right);
                }
            }
            if (isValid$3(canvasHeight) || isValid$3(canvasWidth)) {
                this.canvasSizeSeted = true;
            }
            this.tableNoFrameWidth = 0;
            this.tableNoFrameHeight = 0;
            this.canvasWidth = isNumber$4(canvasWidth) ? canvasWidth : undefined;
            this.canvasHeight = isNumber$4(canvasHeight) ? canvasHeight : undefined;
            this.columnWidthComputeMode = options.columnWidthComputeMode ?? 'normal';
            const internalProps = (this.internalProps = {});
            showFrozenIcon !== undefined && (this.showFrozenIcon = showFrozenIcon);
            if (typeof allowFrozenColCount === 'number' && allowFrozenColCount <= 0) {
                this.showFrozenIcon = false;
            }
            if (this.options.canvas) {
                if (Env.mode !== 'node') {
                    internalProps.element = this.options.canvas.parentElement;
                    internalProps.element.style.position = 'relative';
                }
                internalProps.focusControl = new FocusInput(this, internalProps.element);
                internalProps.canvas = this.options.canvas;
                internalProps.context = internalProps.canvas.getContext('2d');
            }
            else if (Env.mode !== 'node') {
                internalProps.element = createRootElement(this.padding);
                internalProps.focusControl = new FocusInput(this, internalProps.element);
                internalProps.canvas = document.createElement('canvas');
                internalProps.element.appendChild(internalProps.canvas);
                internalProps.context = internalProps.canvas.getContext('2d');
                if (options.customConfig?.createReactContainer) {
                    createReactContainer(this);
                }
            }
            internalProps.handler = new EventHandler();
            if (isNumber$4(this.options.resizeTime)) {
                internalProps.handler.resizeTime = this.options.resizeTime;
            }
            internalProps.pixelRatio = pixelRatio;
            internalProps.frozenColCount = frozenColCount;
            internalProps.frozenRowCount = frozenRowCount;
            internalProps.unfreezeAllOnExceedsMaxWidth = unfreezeAllOnExceedsMaxWidth ?? true;
            internalProps.defaultRowHeight = defaultRowHeight;
            internalProps.defaultHeaderRowHeight = defaultHeaderRowHeight ?? defaultRowHeight;
            internalProps.defaultColWidth = defaultColWidth;
            internalProps.defaultHeaderColWidth = defaultHeaderColWidth ?? defaultColWidth;
            internalProps.keyboardOptions = keyboardOptions;
            internalProps.eventOptions = eventOptions;
            internalProps.rowSeriesNumber = rowSeriesNumber;
            internalProps.columnResizeMode = resize?.columnResizeMode ?? columnResizeMode;
            internalProps.rowResizeMode = resize?.rowResizeMode ?? rowResizeMode;
            internalProps.dragHeaderMode = dragOrder?.dragHeaderMode ?? dragHeaderMode ?? 'none';
            internalProps.renderChartAsync = renderChartAsync;
            setBatchRenderChartCount(renderChartAsyncBatchCount);
            internalProps.overscrollBehavior = overscrollBehavior ?? 'auto';
            internalProps._rowHeightsMap = new NumberRangeMap(this);
            internalProps._rowRangeHeightsMap = new Map();
            internalProps._colRangeWidthsMap = new Map();
            internalProps._widthResizedColMap = new Set();
            internalProps._heightResizedRowMap = new Set();
            this.colWidthsMap = new NumberMap();
            this.colContentWidthsMap = new NumberMap();
            this.colWidthsLimit = {};
            const that = this;
            internalProps.calcWidthContext = {
                _: internalProps,
                get full() {
                    if (Env.mode === 'node') {
                        return that.canvasWidth / (pixelRatio ?? 1);
                    }
                    return this._.canvas.width / (this._.context.pixelRatio ?? window.devicePixelRatio);
                }
            };
            internalProps.cellTextOverflows = {};
            internalProps.focusedTable = false;
            internalProps.theme = themes.of(options.theme ?? themes.DEFAULT);
            internalProps.theme.isPivot = this.isPivotTable();
            setIconColor(internalProps.theme.functionalIconsStyle);
            if (container) {
                if (clearDOM) {
                    container.innerHTML = '';
                }
                container.appendChild(internalProps.element);
                this._updateSize();
            }
            else {
                this._updateSize();
            }
            internalProps.bodyHelper = new BodyHelper(this);
            internalProps.headerHelper = new HeaderHelper(this);
            internalProps.rowSeriesNumberHelper = new RowSeriesNumberHelper(this);
            internalProps.autoWrapText = options.autoWrapText;
            internalProps.enableLineBreak = options.enableLineBreak;
            internalProps.allowFrozenColCount = options.allowFrozenColCount ?? 0;
            internalProps.limitMaxAutoWidth = options.limitMaxAutoWidth ?? 450;
            internalProps.limitMinWidth =
                limitMinWidth !== null && limitMinWidth !== undefined
                    ? typeof limitMinWidth === 'number'
                        ? limitMinWidth
                        : limitMinWidth
                            ? 10
                            : 0
                    : 10;
            internalProps.limitMinHeight =
                limitMinHeight !== null && limitMinHeight !== undefined
                    ? typeof limitMinHeight === 'number'
                        ? limitMinHeight
                        : limitMinHeight
                            ? 10
                            : 0
                    : 10;
            this.scenegraph = new Scenegraph(this);
            this.stateManager = new StateManager(this);
            this.eventManager = new EventManager(this);
            this.animationManager = new TableAnimationManager(this);
            if (options.legends) {
                internalProps.legends = [];
                const createLegend = Factory.getFunction('createLegend');
                if (Array.isArray(options.legends)) {
                    for (let i = 0; i < options.legends.length; i++) {
                        internalProps.legends.push(createLegend(options.legends[i], this));
                    }
                    this.scenegraph.tableGroup.setAttributes({
                        x: this.tableX,
                        y: this.tableY
                    });
                }
                else {
                    internalProps.legends.push(createLegend(options.legends, this));
                    this.scenegraph.tableGroup.setAttributes({
                        x: this.tableX,
                        y: this.tableY
                    });
                }
            }
            internalProps.tooltip = Object.assign({
                parentElement: this.getElement(),
                renderMode: 'html',
                isShowOverflowTextTooltip: false,
                confine: true,
                position: Placement.bottom
            }, options.tooltip);
            if (internalProps.tooltip.renderMode === 'html') {
                const TooltipHandler = Factory.getComponent('tooltipHandler');
                TooltipHandler && (internalProps.tooltipHandler = new TooltipHandler(this, internalProps.tooltip.confine));
            }
            internalProps.menu = Object.assign({
                renderMode: 'html'
            }, options.menu);
            Array.isArray(options.menu?.dropDownMenuHighlight) &&
                this.setDropDownMenuHighlight(options.menu?.dropDownMenuHighlight);
            (Array.isArray(options.menu?.defaultHeaderMenuItems) ||
                typeof options.menu?.defaultHeaderMenuItems === 'function') &&
                (this.globalDropDownMenu = options.menu.defaultHeaderMenuItems);
            if (internalProps.menu.renderMode === 'html') {
                const MenuHandler = Factory.getComponent('menuHandler');
                internalProps.menuHandler = new MenuHandler(this);
            }
            this.headerStyleCache = new Map();
            this.bodyStyleCache = new Map();
            this.bodyMergeTitleCache = new Map();
            this.bodyBottomStyleCache = new Map();
            internalProps.stick = { changedCells: new Map() };
            internalProps.customMergeCell = getCustomMergeCellFunc(options.customMergeCell);
            const CustomCellStylePlugin = Factory.getComponent('customCellStylePlugin');
            if (CustomCellStylePlugin) {
                this.customCellStylePlugin = new CustomCellStylePlugin(this, options.customCellStyle ?? [], options.customCellStyleArrangement ?? []);
            }
            this._adjustCanvasSizeByOption();
        }
        _adjustCanvasSizeByOption() {
            if (this.options.canvasHeight === 'auto' || this.options.canvasWidth === 'auto') {
                setTimeout(() => {
                    let canvasWidth;
                    let canvasHeight;
                    if (this.options.canvasHeight === 'auto') {
                        let borderWidth = 0;
                        if (this.theme.frameStyle?.innerBorder) {
                            const shadowWidths = toBoxArray(this.internalProps.theme.frameStyle?.shadowBlur ?? [0]);
                            borderWidth += shadowWidths[1] ?? 0;
                        }
                        else if (this.theme.frameStyle) {
                            const lineWidths = toBoxArray(this.internalProps.theme.frameStyle?.borderLineWidth ?? [null]);
                            const shadowWidths = toBoxArray(this.internalProps.theme.frameStyle?.shadowBlur ?? [0]);
                            borderWidth +=
                                (lineWidths[0] ?? 0) + (shadowWidths[0] ?? 0) + ((lineWidths[2] ?? 0) + (shadowWidths[2] ?? 0));
                        }
                        canvasHeight =
                            Math.min(this.options.maxCanvasHeight ? this.options.maxCanvasHeight - borderWidth : 20000, this.getAllRowsHeight()) + borderWidth;
                    }
                    else {
                        canvasHeight = this.canvasHeight;
                    }
                    if (this.options.canvasWidth === 'auto') {
                        let borderWidth = 0;
                        if (this.theme.frameStyle?.innerBorder) {
                            const shadowWidths = toBoxArray(this.internalProps.theme.frameStyle?.shadowBlur ?? [0]);
                            borderWidth += shadowWidths[2] ?? 0;
                        }
                        else if (this.theme.frameStyle) {
                            const lineWidths = toBoxArray(this.internalProps.theme.frameStyle?.borderLineWidth ?? [null]);
                            const shadowWidths = toBoxArray(this.internalProps.theme.frameStyle?.shadowBlur ?? [0]);
                            borderWidth +=
                                (lineWidths[1] ?? 0) + (shadowWidths[1] ?? 0) + ((lineWidths[3] ?? 0) + (shadowWidths[3] ?? 0));
                        }
                        canvasWidth =
                            Math.min(this.options.maxCanvasWidth ? this.options.maxCanvasWidth - borderWidth : 20000, this.getAllColsWidth()) + borderWidth;
                    }
                    else {
                        canvasWidth = this.canvasWidth;
                    }
                    this.setCanvasSize(canvasWidth, canvasHeight);
                }, 0);
            }
        }
        throttleInvalidate = throttle2(this.render.bind(this), 200);
        getContainer() {
            return this.container;
        }
        getElement() {
            return this.internalProps.element;
        }
        get canvas() {
            return this.internalProps.canvas;
        }
        setCanvasSize(canvasWidth, canvasHeight) {
            this.canvasWidth = canvasWidth;
            this.canvasHeight = canvasHeight;
            this.options.canvasHeight = canvasHeight;
            this.options.canvasWidth = canvasWidth;
            this.resize();
        }
        resize() {
            this._updateSize();
            this.internalProps.legends?.forEach(legend => {
                legend?.resize();
            });
            if (this.internalProps.title) {
                this.internalProps.title.resize();
            }
            if (this.internalProps.emptyTip) {
                this.internalProps.emptyTip.resize();
            }
            this.scenegraph.resize();
        }
        get rowCount() {
            return this.internalProps.rowCount;
        }
        set rowCount(rowCount) {
            this.internalProps.rowCount = rowCount;
        }
        get colCount() {
            return this.internalProps.colCount ?? 0;
        }
        set colCount(colCount) {
            this.internalProps.colCount = colCount;
        }
        get frozenColCount() {
            return this.internalProps?.layoutMap?.frozenColCount ?? this.internalProps?.frozenColCount ?? 0;
        }
        set frozenColCount(frozenColCount) {
            if (frozenColCount >= this.colCount) {
                frozenColCount = 0;
            }
            this.internalProps.frozenColCount = frozenColCount;
            this.options.frozenColCount = frozenColCount;
            const maxFrozenWidth = this._getMaxFrozenWidth();
            if (this.getColsWidth(0, frozenColCount - 1) > maxFrozenWidth) {
                if (this.internalProps.unfreezeAllOnExceedsMaxWidth) {
                    this.internalProps.frozenColCount = 0;
                }
                else {
                    const computedFrozenColCount = this._getComputedFrozenColCount(frozenColCount);
                    this.internalProps.frozenColCount = computedFrozenColCount;
                }
            }
            this.stateManager.setFrozenCol(this.internalProps.frozenColCount);
        }
        setFrozenColCount(frozenColCount) {
            if (frozenColCount >= this.colCount) {
                frozenColCount = 0;
            }
            this.internalProps.frozenColCount = frozenColCount;
            this.options.frozenColCount = frozenColCount;
            const maxFrozenWidth = this._getMaxFrozenWidth();
            if (this.getColsWidth(0, frozenColCount - 1) > maxFrozenWidth) {
                if (this.internalProps.unfreezeAllOnExceedsMaxWidth) {
                    this.internalProps.frozenColCount = 0;
                }
                else {
                    const computedFrozenColCount = this._getComputedFrozenColCount(frozenColCount);
                    this.internalProps.frozenColCount = computedFrozenColCount;
                }
            }
            this.stateManager.setFrozenCol(this.internalProps.frozenColCount);
        }
        _setFrozenColCount(frozenColCount) {
            if (frozenColCount >= this.colCount) {
                frozenColCount = 0;
            }
            this.internalProps.frozenColCount = frozenColCount;
        }
        _resetFrozenColCount() {
            if (this.options.frozenColCount) {
                if (this.tableNoFrameWidth - this.getColsWidth(0, this.options.frozenColCount - 1) <= 120) {
                    this._setFrozenColCount(0);
                }
                else if (this.frozenColCount !== this.options.frozenColCount) {
                    this._setFrozenColCount(this.options.frozenColCount);
                }
            }
        }
        get frozenRowCount() {
            return this.internalProps?.layoutMap?.frozenRowCount ?? this.internalProps?.frozenRowCount ?? 0;
        }
        set frozenRowCount(frozenRowCount) {
            this.internalProps.frozenRowCount = frozenRowCount;
            this.stateManager.setFrozenRow(this.internalProps.frozenRowCount);
        }
        get rightFrozenColCount() {
            return this.internalProps?.layoutMap?.rightFrozenColCount ?? this.internalProps?.rightFrozenColCount ?? 0;
        }
        set rightFrozenColCount(rightFrozenColCount) {
            this.scenegraph.dealWidthRightFrozen(rightFrozenColCount);
        }
        get bottomFrozenRowCount() {
            return this.internalProps?.layoutMap?.bottomFrozenRowCount ?? this.internalProps?.bottomFrozenRowCount ?? 0;
        }
        set bottomFrozenRowCount(bottomFrozenRowCount) {
            this.scenegraph.dealWidthBottomFrozen(bottomFrozenRowCount);
        }
        get defaultRowHeight() {
            if (isNumber$4(this.internalProps.defaultRowHeight)) {
                return this.internalProps.defaultRowHeight;
            }
            return 40;
        }
        set defaultRowHeight(defaultRowHeight) {
            this.internalProps.defaultRowHeight = defaultRowHeight;
            this.options.defaultRowHeight = defaultRowHeight;
        }
        get defaultHeaderRowHeight() {
            return this.internalProps.defaultHeaderRowHeight;
        }
        set defaultHeaderRowHeight(defaultHeaderRowHeight) {
            this.internalProps.defaultHeaderRowHeight = defaultHeaderRowHeight;
            this.options.defaultHeaderRowHeight = defaultHeaderRowHeight;
        }
        get defaultColWidth() {
            return this.internalProps.defaultColWidth;
        }
        set defaultColWidth(defaultColWidth) {
            this.internalProps.defaultColWidth = defaultColWidth;
            this.options.defaultColWidth = defaultColWidth;
        }
        get defaultHeaderColWidth() {
            return this.internalProps.defaultHeaderColWidth;
        }
        set defaultHeaderColWidth(defaultHeaderColWidth) {
            this.internalProps.defaultHeaderColWidth = defaultHeaderColWidth;
            this.options.defaultHeaderColWidth = defaultHeaderColWidth;
        }
        get colWidthsMap() {
            return this.internalProps._colWidthsMap;
        }
        set colWidthsMap(colWidthsMap) {
            this.internalProps._colWidthsMap = colWidthsMap;
        }
        get colContentWidthsMap() {
            return this.internalProps._colContentWidthsMap;
        }
        set colContentWidthsMap(colContentWidthsMap) {
            this.internalProps._colContentWidthsMap = colContentWidthsMap;
        }
        get _colRangeWidthsMap() {
            return this.internalProps._colRangeWidthsMap;
        }
        set _colRangeWidthsMap(_colRangeWidthsMap) {
            this.internalProps._colRangeWidthsMap = _colRangeWidthsMap;
        }
        get _rowRangeHeightsMap() {
            return this.internalProps._rowRangeHeightsMap;
        }
        set _rowRangeHeightsMap(_rowRangeHeightsMap) {
            this.internalProps._rowRangeHeightsMap = _rowRangeHeightsMap;
        }
        get rowHeightsMap() {
            return this.internalProps._rowHeightsMap;
        }
        set rowHeightsMap(rowHeightsMap) {
            this.internalProps._rowHeightsMap = rowHeightsMap;
        }
        get colWidthsLimit() {
            return this.internalProps._colWidthsLimit;
        }
        set colWidthsLimit(colWidthsLimit) {
            this.internalProps._colWidthsLimit = colWidthsLimit;
        }
        get keyboardOptions() {
            return this.internalProps.keyboardOptions ?? null;
        }
        set keyboardOptions(keyboardOptions) {
            this.internalProps.keyboardOptions = keyboardOptions ?? undefined;
        }
        get eventOptions() {
            return this.internalProps.eventOptions ?? null;
        }
        set eventOptions(eventOptions) {
            this.internalProps.eventOptions = eventOptions ?? undefined;
        }
        get widthMode() {
            return this._widthMode;
        }
        set widthMode(widthMode) {
            if (widthMode !== this._widthMode) {
                this._widthMode = widthMode;
                this.options.widthMode = widthMode;
            }
        }
        get heightMode() {
            return this._heightMode;
        }
        set heightMode(heightMode) {
            if (heightMode !== this._heightMode) {
                this._heightMode = heightMode;
                this.options.heightMode = heightMode;
            }
        }
        get autoFillWidth() {
            return this._autoFillWidth;
        }
        set autoFillWidth(autoFillWidth) {
            if (autoFillWidth !== this._autoFillWidth) {
                this._autoFillWidth = autoFillWidth;
            }
        }
        get autoFillHeight() {
            return this._autoFillHeight;
        }
        set autoFillHeight(autoFillHeight) {
            if (autoFillHeight !== this._autoFillHeight) {
                this._autoFillHeight = autoFillHeight;
            }
        }
        get widthAdaptiveMode() {
            return this._widthAdaptiveMode;
        }
        set widthAdaptiveMode(widthAdaptiveMode) {
            if (widthAdaptiveMode !== this._widthAdaptiveMode) {
                this._widthAdaptiveMode = widthAdaptiveMode;
            }
        }
        get heightAdaptiveMode() {
            return this._heightAdaptiveMode;
        }
        set heightAdaptiveMode(heightAdaptiveMode) {
            if (heightAdaptiveMode !== this._heightAdaptiveMode) {
                this._heightAdaptiveMode = heightAdaptiveMode;
            }
        }
        _colWidthDefineToPxWidth(width) {
            if (width === 'auto') {
                return 0;
            }
            return _toPxWidth(this, width);
        }
        _getMaxFrozenWidth() {
            const maxFrozenWidth = this.options.maxFrozenWidth ?? '80%';
            return _toPxWidth(this, maxFrozenWidth);
        }
        _getComputedFrozenColCount(frozenColCount) {
            const maxFrozenWidth = this._getMaxFrozenWidth();
            let computedfrozenColCount = frozenColCount;
            while (this.getColsWidth(0, computedfrozenColCount - 1) > maxFrozenWidth) {
                computedfrozenColCount--;
                if (computedfrozenColCount <= 0) {
                    break;
                }
            }
            return computedfrozenColCount;
        }
        _getColWidthLimits(col) {
            const limit = this.colWidthsLimit[col];
            if (!limit) {
                return null;
            }
            const result = {};
            if (limit.min) {
                result.min = _toPxWidth(this, limit.min);
                result.minDef = limit.min;
            }
            if (limit.max) {
                result.max = _toPxWidth(this, limit.max);
                result.maxDef = limit.max;
            }
            return result;
        }
        _adjustColWidth(col, orgWidth) {
            const limits = this._getColWidthLimits(col);
            return Math.max(_applyColWidthLimits(limits, orgWidth), 0);
        }
        get pixelRatio() {
            return this.internalProps.pixelRatio;
        }
        setPixelRatio(pixelRatio) {
            if (pixelRatio !== this.internalProps?.pixelRatio) {
                this.internalProps.pixelRatio = pixelRatio;
                const canvasWidth = this.canvasWidth;
                this.internalProps.calcWidthContext = {
                    _: this.internalProps,
                    get full() {
                        if (Env.mode === 'node') {
                            return canvasWidth / (pixelRatio ?? 1);
                        }
                        return this._.canvas.width / (this._.context.pixelRatio ?? window.devicePixelRatio);
                    }
                };
                this.scenegraph.setPixelRatio(pixelRatio);
            }
        }
        _updateSize() {
            const { padding } = this;
            let widthP = 0;
            let heightP = 0;
            this.tableX = 0;
            this.tableY = 0;
            if (this.options.canvas && this.options.viewBox) {
                widthP = this.options.viewBox.x2 - this.options.viewBox.x1;
                heightP = this.options.viewBox.y2 - this.options.viewBox.y1;
                if (this?.scenegraph?.stage) {
                    if (this.options.viewBox) {
                        this.scenegraph.stage.setViewBox(this.options.viewBox, false);
                    }
                    else {
                        this.scenegraph.stage.resize(widthP, heightP);
                    }
                }
            }
            else if (Env.mode === 'browser') {
                const element = this.getElement();
                let widthWithoutPadding = 0;
                let heightWithoutPadding = 0;
                const isDefWidth = isValid$3(this.canvasWidth);
                const isDefHeight = isValid$3(this.canvasHeight);
                if (this.canvasSizeSeted) {
                    if (isDefWidth) {
                        widthWithoutPadding = this.canvasWidth;
                    }
                    if (isDefHeight) {
                        heightWithoutPadding = this.canvasHeight;
                    }
                }
                const unDefSize = (!isDefWidth || !isDefHeight) && element.parentElement;
                if (unDefSize) {
                    const computedStyle = element.parentElement.style || window.getComputedStyle(element.parentElement);
                    if (!isDefWidth) {
                        widthWithoutPadding =
                            element.parentElement.offsetWidth -
                                (parseInt(computedStyle.paddingLeft, 10) || 0) -
                                (parseInt(computedStyle.paddingRight, 10) || 0);
                    }
                    if (!isDefHeight) {
                        heightWithoutPadding =
                            element.parentElement.offsetHeight -
                                parseInt(computedStyle.paddingTop || '0px', 10) -
                                parseInt(computedStyle.paddingBottom || '0px', 20);
                    }
                    widthWithoutPadding = (widthWithoutPadding ?? 1) - (this.options.tableSizeAntiJitter ? 1 : 0);
                    heightWithoutPadding = (heightWithoutPadding ?? 1) - (this.options.tableSizeAntiJitter ? 1 : 0);
                }
                element.style.width = (widthWithoutPadding && `${widthWithoutPadding - padding.left - padding.right}px`) || '0px';
                element.style.height =
                    (heightWithoutPadding && `${heightWithoutPadding - padding.top - padding.bottom}px`) || '0px';
                const { canvas } = this.internalProps;
                widthP = (canvas.parentElement?.offsetWidth ?? 1) - (this.options.tableSizeAntiJitter ? 1 : 0);
                heightP = (canvas.parentElement?.offsetHeight ?? 1) - (this.options.tableSizeAntiJitter ? 1 : 0);
                if (!this?.scenegraph?.stage) {
                    canvas.style.width = '';
                    canvas.style.height = '';
                    canvas.width = widthP;
                    canvas.height = heightP;
                    canvas.style.width = `${widthP}px`;
                    canvas.style.height = `${heightP}px`;
                }
                else if (this.options?.viewBox && !this.options?.canvas) {
                    this.scenegraph.stage.resize(widthP, heightP);
                }
                if (this.options?.viewBox) {
                    widthP = this.options.viewBox.x2 - this.options.viewBox.x1;
                    heightP = this.options.viewBox.y2 - this.options.viewBox.y1;
                }
                if (this?.scenegraph?.stage) {
                    if (this.options.viewBox) {
                        this.scenegraph.stage.setViewBox(this.options.viewBox, false);
                    }
                    else {
                        this.scenegraph.stage.resize(widthP, heightP);
                    }
                }
            }
            else if (Env.mode === 'node') {
                widthP = this.canvasWidth - 1;
                heightP = this.canvasHeight - 1;
            }
            const width = Math.floor(widthP - getVerticalScrollBarSize(this.getTheme().scrollStyle));
            const height = Math.floor(heightP - getHorizontalScrollBarSize(this.getTheme().scrollStyle));
            if (this.internalProps.theme?.frameStyle) {
                const lineWidths = toBoxArray(this.internalProps.theme.frameStyle?.borderLineWidth ?? [null]);
                const shadowWidths = toBoxArray(this.internalProps.theme.frameStyle?.shadowBlur ?? [0]);
                if (this.theme.frameStyle?.innerBorder) {
                    this.tableX = 0;
                    this.tableY = 0;
                    this.tableNoFrameWidth = width - (shadowWidths[1] ?? 0);
                    this.tableNoFrameHeight = height - (shadowWidths[2] ?? 0);
                }
                else {
                    this.tableX = (lineWidths[3] ?? 0) + (shadowWidths[3] ?? 0);
                    this.tableY = (lineWidths[0] ?? 0) + (shadowWidths[0] ?? 0);
                    this.tableNoFrameWidth =
                        width - ((lineWidths[1] ?? 0) + (shadowWidths[1] ?? 0)) - ((lineWidths[3] ?? 0) + (shadowWidths[3] ?? 0));
                    this.tableNoFrameHeight =
                        height - ((lineWidths[0] ?? 0) + (shadowWidths[0] ?? 0)) - ((lineWidths[2] ?? 0) + (shadowWidths[2] ?? 0));
                }
            }
            this._clearColRangeWidthsMap();
            this._clearRowRangeHeightsMap();
        }
        updateViewBox(newViewBox) {
            const oldWidth = (this.options?.viewBox?.x2 ?? 0) - (this.options?.viewBox?.x1 ?? 0);
            const oldHeight = (this.options?.viewBox?.y2 ?? 0) - (this.options?.viewBox?.y1 ?? 0);
            const newWidth = newViewBox.x2 - newViewBox.x1;
            const newHeight = newViewBox.y2 - newViewBox.y1;
            this.options.viewBox = newViewBox;
            if (oldWidth !== newWidth || oldHeight !== newHeight) {
                this.resize();
            }
            else {
                this.scenegraph.stage.setViewBox(this.options.viewBox, true);
            }
        }
        setViewBoxTransform(a, b, c, d, e, f) {
            this.internalProps.modifiedViewBoxTransform = true;
            this.scenegraph.stage.window.setViewBoxTransform(a, b, c, d, e, f);
        }
        get rowHierarchyType() {
            return this.dataSource.rowHierarchyType;
        }
        getColsWidth(startCol, endCol) {
            if (startCol > endCol) {
                return 0;
            }
            startCol = Math.max(startCol, 0);
            endCol = Math.min(endCol, (this.colCount ?? Infinity) - 1);
            const cachedColWidth = this._colRangeWidthsMap.get(`$${startCol}$${endCol}`);
            if (cachedColWidth !== null && cachedColWidth !== undefined) {
                return cachedColWidth;
            }
            const cachedLowerColWidth = this._colRangeWidthsMap.get(`$${startCol}$${endCol - 1}`);
            if (cachedLowerColWidth !== null && cachedLowerColWidth !== undefined) {
                const adjustW = this.getColWidth(endCol);
                const addWidth = cachedLowerColWidth + adjustW;
                if (startCol >= 0 && endCol >= 0 && !Number.isNaN(addWidth)) {
                    this._colRangeWidthsMap.set(`$${startCol}$${endCol}`, Math.round(addWidth));
                }
                return Math.round(addWidth);
            }
            let w = 0;
            for (let col = startCol; col <= endCol; col++) {
                w += this.getColWidth(col);
            }
            if (startCol >= 0 && endCol >= 0) {
                this._colRangeWidthsMap.set(`$${startCol}$${endCol}`, Math.round(w));
            }
            return Math.round(w);
        }
        getRowHeight(row) {
            if (isValid$3(this.rowHeightsMap.get(row))) {
                if (this.options.customConfig?._disableColumnAndRowSizeRound) {
                    const height = this.rowHeightsMap.get(row);
                    let heightRange;
                    if (row < this.frozenRowCount) {
                        heightRange = this.rowHeightsMap.getSumInRange(0, row);
                    }
                    else if (row >= this.rowCount - this.bottomFrozenRowCount) {
                        heightRange = this.rowHeightsMap.getSumInRange(row, this.rowCount - 1);
                    }
                    else {
                        heightRange = this.rowHeightsMap.getSumInRange(this.frozenRowCount, row);
                    }
                    heightRange = Number(heightRange.toFixed(2));
                    if (Number.isInteger(heightRange)) {
                        return Math.ceil(height);
                    }
                    return Math.floor(height);
                }
                return this.rowHeightsMap.get(row);
            }
            const defaultHeight = this.getDefaultRowHeight(row);
            if (isNumber$4(defaultHeight)) {
                return defaultHeight;
            }
            return this.defaultRowHeight;
        }
        getDefaultColumnWidth(col) {
            if (this.isRowHeader(col, 0) || this.isCornerHeader(col, 0)) {
                return Array.isArray(this.defaultHeaderColWidth)
                    ? this.defaultHeaderColWidth[col] ?? this.defaultColWidth
                    : this.defaultHeaderColWidth;
            }
            else if (this.isRightFrozenColumn(col, this.columnHeaderLevelCount)) {
                if (this.isPivotTable()) {
                    return Array.isArray(this.defaultHeaderColWidth)
                        ? this.defaultHeaderColWidth[this.rowHeaderLevelCount - this.rightFrozenColCount] ?? this.defaultColWidth
                        : this.defaultHeaderColWidth;
                }
                return this.defaultColWidth;
            }
            return this.defaultColWidth;
        }
        getDefaultRowHeight(row) {
            if (this.isColumnHeader(0, row) || this.isCornerHeader(0, row) || this.isSeriesNumberInHeader(0, row)) {
                return Array.isArray(this.defaultHeaderRowHeight)
                    ? this.defaultHeaderRowHeight[row] ?? this.internalProps.defaultRowHeight
                    : this.defaultHeaderRowHeight;
            }
            if (this.isBottomFrozenRow(row)) {
                return Array.isArray(this.defaultHeaderRowHeight)
                    ? this.defaultHeaderRowHeight[this.columnHeaderLevelCount > 0 ? this.columnHeaderLevelCount - this.bottomFrozenRowCount : 0] ?? this.internalProps.defaultRowHeight
                    : this.defaultHeaderRowHeight;
            }
            return this.internalProps.defaultRowHeight;
        }
        _setRowHeight(row, height, clearCache) {
            this.rowHeightsMap.put(row, this.options.customConfig?._disableColumnAndRowSizeRound ? height : Math.round(height));
            if (clearCache) {
                this._clearRowRangeHeightsMap(row);
            }
        }
        setRowHeight(row, height) {
            this.scenegraph.setRowHeight(row, height);
            this.scenegraph.updateChartSizeForResizeRowHeight(row);
            this.internalProps._heightResizedRowMap.add(row);
        }
        getRowsHeight(startRow, endRow) {
            if (startRow > endRow || this.rowCount === 0) {
                return 0;
            }
            startRow = Math.max(startRow, 0);
            endRow = Math.min(endRow, (this.rowCount ?? Infinity) - 1);
            let h = 0;
            const isDefaultRowHeightIsAuto = this.options.defaultRowHeight === 'auto';
            if (this.heightMode === 'standard' &&
                !this.options.customComputeRowHeight &&
                !this.autoFillHeight &&
                this.internalProps.layoutMap &&
                !this.hasAutoImageColumn() &&
                !isDefaultRowHeightIsAuto &&
                this.internalProps._heightResizedRowMap.size === 0) {
                for (let i = startRow; i < Math.min(endRow + 1, this.columnHeaderLevelCount); i++) {
                    h += this.getRowHeight(i);
                }
                if (endRow >= this.columnHeaderLevelCount) {
                    h +=
                        this.defaultRowHeight *
                            (Math.min(endRow, this.rowCount - this.bottomFrozenRowCount - 1) -
                                Math.max(this.columnHeaderLevelCount, startRow) +
                                1);
                }
                for (let i = this.rowCount - this.bottomFrozenRowCount; i < endRow + 1; i++) {
                    h += this.getRowHeight(i);
                }
            }
            else {
                if (this.options.customConfig?._disableColumnAndRowSizeRound) {
                    const tempH = this.rowHeightsMap.getSumInRange(startRow, endRow);
                    let heightRange;
                    if (endRow < this.frozenRowCount) {
                        heightRange = this.rowHeightsMap.getSumInRange(0, endRow);
                    }
                    else if (endRow >= this.rowCount - this.bottomFrozenRowCount) {
                        heightRange = this.rowHeightsMap.getSumInRange(endRow, this.rowCount - 1);
                    }
                    else {
                        heightRange = this.rowHeightsMap.getSumInRange(this.frozenRowCount, endRow);
                    }
                    heightRange = Number(heightRange.toFixed(2));
                    if (Number.isInteger(heightRange)) {
                        return Math.ceil(tempH);
                    }
                    return Math.floor(tempH);
                }
                h = this.rowHeightsMap.getSumInRange(startRow, endRow);
            }
            return Math.round(h);
        }
        getColWidthDefined(col) {
            const { layoutMap } = this.internalProps;
            if (this.widthMode === 'autoWidth') {
                return 'auto';
            }
            const { width } = layoutMap?.getColumnWidthDefined(col) ?? {};
            if (typeof width === 'number' && width <= 0) {
                return 0;
            }
            else if (width) {
                return width;
            }
            return this.getDefaultColumnWidth(col);
        }
        getColWidthDefinedNumber(col) {
            const width = this.getColWidthDefined(col);
            return this._adjustColWidth(col, this._colWidthDefineToPxWidth(width));
        }
        isAutoRowHeight(row) {
            if (this.heightMode === 'autoHeight') {
                return true;
            }
            else if (this.options.customComputeRowHeight) {
                return true;
            }
            else if (row >= 0 && row < this.columnHeaderLevelCount) {
                return this.getDefaultRowHeight(row) === 'auto';
            }
            return this.internalProps.defaultRowHeight === 'auto';
        }
        getColWidth(col) {
            const width = this.colWidthsMap.get(col) ?? this.getDefaultColumnWidth(col);
            if ((this.widthMode === 'adaptive' && typeof width === 'number') ||
                (this.transpose && typeof width === 'number')) {
                return this._colWidthDefineToPxWidth(width);
            }
            return this._adjustColWidth(col, this._colWidthDefineToPxWidth(width));
        }
        _setColWidth(col, width, clearCache, skipCheckFrozen) {
            this.colWidthsMap.put(col, typeof width === 'number' ? Math.round(width) : width);
            if (clearCache) {
                this._clearColRangeWidthsMap(col);
            }
            if (!skipCheckFrozen) {
                this.stateManager.checkFrozen();
            }
        }
        setColWidth(col, width) {
            this.scenegraph.setColWidth(col, width);
            this.scenegraph.updateChartSizeForResizeColWidth(col);
            this.internalProps._widthResizedColMap.add(col);
        }
        _clearColRangeWidthsMap(col) {
            if (typeof col !== 'number') {
                this._colRangeWidthsMap.clear();
            }
            else {
                const keys = this._colRangeWidthsMap.keys();
                for (const key of keys) {
                    const reg = rangeReg.exec(key);
                    if (reg) {
                        const start = Number(reg[1]);
                        const end = Number(reg[2]);
                        if (col >= start && col <= end) {
                            this._colRangeWidthsMap.delete(key);
                        }
                    }
                }
            }
        }
        _clearRowRangeHeightsMap(row) {
            this.rowHeightsMap.clearRange();
        }
        _getColContentWidth(col) {
            return Number(this.colContentWidthsMap.get(col));
        }
        _setColContentWidth(col, width) {
            this.colContentWidthsMap.put(col, width);
        }
        getAllRowsHeight() {
            if (this.internalProps.rowCount <= 0) {
                return 0;
            }
            const h = this.getRowsHeight(0, this.internalProps.rowCount - 1);
            return h;
        }
        getAllColsWidth() {
            if (this.internalProps.colCount <= 0) {
                return 0;
            }
            const w = this.getColsWidth(0, this.internalProps.colCount - 1);
            return w;
        }
        getColsWidths() {
            const maxCount = this.colCount;
            const widths = [];
            for (let col = 0; col < maxCount; col++) {
                widths.push(this.getColWidth(col));
            }
            return widths;
        }
        getMaxColWidth(col) {
            const obj = this.colWidthsLimit[col];
            let max = (obj && obj.max) ?? Infinity;
            if (typeof max === 'string') {
                max = _toPxWidth(this, max);
            }
            return max;
        }
        setMaxColWidth(col, maxwidth) {
            const obj = this.colWidthsLimit[col] || (this.colWidthsLimit[col] = {});
            obj.max = maxwidth;
        }
        getMinColWidth(col) {
            const obj = this.colWidthsLimit[col];
            let min = (obj && obj.min) ?? 0;
            if (typeof min === 'string') {
                min = _toPxWidth(this, min);
            }
            return min;
        }
        setMinColWidth(col, minwidth) {
            const obj = this.colWidthsLimit[col] || (this.colWidthsLimit[col] = {});
            obj.min = minwidth;
        }
        getCellRect(col, row) {
            const isFrozenCell = this.isFrozenCell(col, row);
            let absoluteLeft;
            const width = this.getColWidth(col);
            if (isFrozenCell && isFrozenCell.col) {
                if (this.isRightFrozenColumn(col, row)) {
                    if (this.getAllColsWidth() <= this.tableNoFrameWidth) {
                        absoluteLeft = this.getColsWidth(0, col - 1) || 0;
                    }
                    else {
                        absoluteLeft = this.tableNoFrameWidth - (this.getColsWidth(col, this.colCount - 1) ?? 0);
                    }
                }
                else {
                    absoluteLeft = this.getColsWidth(0, col - 1) || 0;
                }
            }
            else {
                absoluteLeft = this.getColsWidth(0, col - 1) || 0;
            }
            let absoluteTop;
            const height = this.getRowHeight(row);
            if (isFrozenCell && isFrozenCell.row) {
                if (this.isBottomFrozenRow(col, row)) {
                    if (this.getAllRowsHeight() <= this.tableNoFrameHeight) {
                        absoluteTop = this.getRowsHeight(0, row - 1);
                    }
                    else {
                        absoluteTop = this.tableNoFrameHeight - (this.getRowsHeight(row, this.rowCount - 1) ?? 0);
                    }
                }
                else {
                    absoluteTop = this.getRowsHeight(0, row - 1);
                }
            }
            else {
                absoluteTop = this.getRowsHeight(0, row - 1);
            }
            return new Rect$1(Math.round(absoluteLeft), Math.round(absoluteTop), Math.round(width), Math.round(height));
        }
        getMergeCellRect(col, row) {
            const cellRange = this.getCellRange(col, row);
            const absoluteLeft = this.getColsWidth(0, cellRange.start.col - 1) || 0;
            const width = this.getColsWidth(cellRange.start.col, cellRange.end.col);
            const absoluteTop = this.getRowsHeight(0, cellRange.start.row - 1) || 0;
            const height = this.getRowsHeight(cellRange.start.row, cellRange.end.row);
            return new Rect$1(Math.round(absoluteLeft), Math.round(absoluteTop), Math.round(width), Math.round(height));
        }
        getCellRelativeRect(col, row) {
            const isFrozenCell = this.isFrozenCell(col, row);
            let relativeX = true;
            let relativeY = true;
            if (isFrozenCell?.col && isFrozenCell?.row) {
                relativeX = false;
                relativeY = false;
            }
            else if (isFrozenCell?.col) {
                relativeX = false;
            }
            else if (isFrozenCell?.row) {
                relativeY = false;
            }
            const cellRect = this.getCellRect(col, row);
            return this._toRelativeRect(cellRect, relativeX, relativeY);
        }
        getCellRangeRelativeRect(range) {
            if (range.start) {
                const isFrozenCell = this.isFrozenCell(range.start.col, range.start.row);
                let relativeX = true;
                let relativeY = true;
                if (isFrozenCell?.col && isFrozenCell?.row) {
                    relativeX = false;
                    relativeY = false;
                }
                else if (isFrozenCell?.col) {
                    relativeX = false;
                }
                else if (isFrozenCell?.row) {
                    relativeY = false;
                }
                return this._toRelativeRect(this.getCellsRect(range.start.col, range.start.row, range.end.col, range.end.row), relativeX, relativeY);
            }
            const cellRange = this.getCellRange(range.col, range.row);
            const isFrozenCell = this.isFrozenCell(range.col, range.row);
            let relativeX = true;
            let relativeY = true;
            if (isFrozenCell?.col && isFrozenCell?.row) {
                relativeX = false;
                relativeY = false;
            }
            else if (isFrozenCell?.col) {
                relativeX = false;
            }
            else if (isFrozenCell?.row) {
                relativeY = false;
            }
            return this._toRelativeRect(this.getCellsRect(cellRange.start.col, cellRange.start.row, cellRange.end.col, cellRange.end.row), relativeX, relativeY);
        }
        getVisibleCellRangeRelativeRect(range) {
            let cellRange;
            if (range.start) {
                cellRange = range;
            }
            else {
                cellRange = this.getCellRange(range.col, range.row);
            }
            return this._getVisiableRect(this.getCellRangeRelativeRect(range), cellRange);
        }
        _getVisiableRect(relativeRectObj, cellRange) {
            const targetLeft = cellRange.start.col >= this.frozenColCount
                ? Math.max(relativeRectObj.left, this.frozenColCount >= 1 ? this.getColsWidth(0, this.frozenColCount - 1) : 0)
                : relativeRectObj.left;
            const targetRight = Math.min(relativeRectObj.right, this.tableNoFrameWidth);
            const rect = relativeRectObj.copy();
            rect.left = targetLeft;
            rect.right = targetRight;
            const targetTop = cellRange.start.row >= this.frozenRowCount
                ? Math.max(relativeRectObj.top, this.frozenRowCount >= 1 ? this.getRowsHeight(0, this.frozenRowCount - 1) : 0)
                : relativeRectObj.top;
            const targetBottom = Math.min(relativeRectObj.bottom, this.tableNoFrameHeight);
            rect.top = targetTop;
            rect.bottom = targetBottom;
            return rect;
        }
        getCellsRect(startCol, startRow, endCol, endRow) {
            let absoluteLeft = this.getColsWidth(0, startCol - 1) || 0;
            let width = this.getColsWidth(startCol, endCol);
            const scrollLeft = this.scrollLeft;
            const tableWidth = Math.min(this.tableNoFrameWidth, this.getAllColsWidth());
            const tableHeight = Math.min(this.tableNoFrameHeight, this.getAllRowsHeight());
            if (this.isLeftFrozenColumn(startCol) && this.isRightFrozenColumn(endCol)) {
                width = this.tableNoFrameWidth - (this.getColsWidth(startCol + 1, this.colCount - 1) ?? 0) - absoluteLeft;
            }
            else if (this.isLeftFrozenColumn(startCol) && !this.isLeftFrozenColumn(endCol)) {
                width = Math.max(width - scrollLeft, this.getColsWidth(startCol, this.frozenColCount - 1));
            }
            else if (!this.isRightFrozenColumn(startCol) && this.isRightFrozenColumn(endCol)) {
                absoluteLeft = Math.min(absoluteLeft - scrollLeft, tableWidth - this.getRightFrozenColsWidth());
                width = tableWidth - (this.getColsWidth(startCol + 1, this.colCount - 1) ?? 0) - absoluteLeft;
            }
            else if (this.isRightFrozenColumn(startCol)) {
                absoluteLeft = tableWidth - (this.getColsWidth(startCol, this.colCount - 1) ?? 0);
            }
            else ;
            let absoluteTop = this.getRowsHeight(0, startRow - 1);
            let height = this.getRowsHeight(startRow, endRow);
            const scrollTop = this.scrollTop;
            if (this.isTopFrozenRow(startRow) && this.isBottomFrozenRow(endRow)) {
                height = this.tableNoFrameHeight - (this.getRowsHeight(startRow + 1, this.rowCount - 1) ?? 0) - absoluteTop;
            }
            else if (this.isTopFrozenRow(startRow) && !this.isTopFrozenRow(endRow)) {
                height = Math.max(height - scrollTop, this.getRowsHeight(startRow, this.frozenRowCount - 1));
            }
            else if (!this.isBottomFrozenRow(startRow) && this.isBottomFrozenRow(endRow)) {
                absoluteTop = Math.min(absoluteTop - scrollTop, tableHeight - this.getBottomFrozenRowsHeight());
                height = tableHeight - (this.getRowsHeight(startRow + 1, this.rowCount - 1) ?? 0) - absoluteTop;
            }
            else if (this.isBottomFrozenRow(startRow)) {
                absoluteTop = tableHeight - (this.getRowsHeight(startRow, this.rowCount - 1) ?? 0);
            }
            else ;
            return new Rect$1(Math.round(absoluteLeft), Math.round(absoluteTop), Math.round(width), Math.round(height));
        }
        getCellsRectWidth(startCol, startRow, endCol, endRow) {
            const isFrozenStartCell = this.isFrozenCell(startCol, startRow);
            const isFrozenEndCell = this.isFrozenCell(endCol, endRow);
            let width = this.getColsWidth(startCol, endCol);
            if (isFrozenStartCell && isFrozenStartCell.col) {
                const scrollLeft = this.scrollLeft;
                if (!isFrozenEndCell || !isFrozenEndCell.col) {
                    width -= scrollLeft;
                    width = Math.max(width, this.getColsWidth(startCol, this.frozenColCount - 1));
                }
            }
            return width;
        }
        getCellRangeRect(range) {
            if (range.start) {
                return this.getCellsRect(range.start.col, range.start.row, range.end.col, range.end.row);
            }
            const cellRange = this.getCellRange(range.col, range.row);
            return this.getCellsRect(cellRange.start.col, cellRange.start.row, cellRange.end.col, cellRange.end.row);
        }
        getCellRangeRectWidth(range) {
            if (range.start) {
                return this.getCellsRectWidth(range.start.col, range.start.row, range.end.col, range.end.row);
            }
            const cellRange = this.getCellRange(range.col, range.row);
            return this.getCellsRectWidth(cellRange.start.col, cellRange.start.row, cellRange.end.col, cellRange.end.row);
        }
        isFrozenCell(col, row) {
            const isFrozenRow = this.isFrozenRow(row);
            const isFrozenCol = this.isFrozenColumn(col);
            if (isFrozenRow || isFrozenCol) {
                return {
                    row: isFrozenRow,
                    col: isFrozenCol
                };
            }
            return null;
        }
        getRowAt(absoluteY) {
            return getRowAt(absoluteY, this);
        }
        getColAt(absoluteX) {
            return getColAt(absoluteX, this);
        }
        getCellAt(absoluteX, absoluteY) {
            return getCellAt(absoluteX, absoluteY, this);
        }
        getCellAtRelativePosition(relativeX, relativeY) {
            return getCellAtRelativePosition(relativeX, relativeY, this);
        }
        _checkRowCol(col, row) {
            if (col >= 0 && col < this.colCount && row >= 0 && row < this.rowCount) {
                return true;
            }
            return false;
        }
        _makeVisibleCell(col, row) {
            if (this._checkRowCol(col, row)) {
                const isFrozenCell = this.isFrozenCell(col, row);
                if (isFrozenCell && isFrozenCell.col && isFrozenCell.row) {
                    return;
                }
                const rect = this.getCellRect(col, row);
                const visibleRect = _getScrollableVisibleRect(this);
                if (visibleRect.contains(rect)) {
                    return;
                }
                if (!isFrozenCell || !isFrozenCell.col) {
                    if (this.getColsWidth(0, this.frozenColCount - 1) + rect.width > this.canvas.width) ;
                    else if (rect.left < visibleRect.left) {
                        this.scrollLeft -= visibleRect.left - rect.left;
                    }
                    else if (visibleRect.right < rect.right) {
                        this.scrollLeft -= visibleRect.right - rect.right;
                    }
                }
                if (!isFrozenCell || !isFrozenCell.row) {
                    if (this.getRowsHeight(0, this.frozenRowCount - 1) + rect.height > this.canvas.height) ;
                    else if (rect.top < visibleRect.top) {
                        this.scrollTop -= visibleRect.top - rect.top;
                    }
                    else if (visibleRect.bottom < rect.bottom) {
                        this.scrollTop -= visibleRect.bottom - rect.bottom;
                    }
                }
            }
        }
        render() {
            this.scenegraph.renderSceneGraph();
        }
        renderAsync() {
            this.scenegraph.updateNextFrame();
            return new Promise((resolve, reject) => {
                setTimeout(() => {
                    resolve();
                }, 0);
            });
        }
        _toRelativeRect(absoluteRect, relativeX = true, relativeY = true) {
            const rect = absoluteRect.copy();
            const visibleRect = this.getVisibleRect();
            rect.offsetLeft(this.tableX - (relativeX ? visibleRect.left : 0));
            rect.offsetTop(this.tableY - (relativeY ? visibleRect.top : 0));
            rect.offsetLeft(this.options.viewBox?.x1 ?? 0);
            rect.offsetTop(this.options.viewBox?.y1 ?? 0);
            return rect;
        }
        getVisibleRect() {
            const { scrollTop, scrollLeft } = this;
            const width = this.tableNoFrameWidth;
            const height = this.tableNoFrameHeight;
            return new Rect$1(scrollLeft, scrollTop, width, height);
        }
        get visibleRowCount() {
            const { frozenRowCount } = this;
            const visibleRect = this.getVisibleRect();
            const visibleTop = frozenRowCount > 0 ? visibleRect.top + this.getRowsHeight(0, frozenRowCount - 1) : visibleRect.top;
            const initRow = this.getTargetRowAt(visibleTop);
            if (!initRow) {
                return 0;
            }
            const startRow = Math.max(initRow.top >= visibleTop ? initRow.row : initRow.row + 1, frozenRowCount);
            let absoluteTop = this.getRowsHeight(0, startRow - 1);
            let count = 0;
            const { rowCount } = this;
            for (let row = startRow; row < rowCount; row++) {
                const height = this.getRowHeight(row);
                const bottom = absoluteTop + height;
                if (visibleRect.bottom < bottom) {
                    break;
                }
                count++;
                absoluteTop = bottom;
            }
            return count;
        }
        getBodyVisibleCellRange() {
            const { scrollTop, scrollLeft } = this;
            const frozenRowsHeight = this.getFrozenRowsHeight();
            const frozenColsWidth = this.getFrozenColsWidth();
            const bottomFrozenRowsHeight = this.getBottomFrozenRowsHeight();
            const rightFrozenColsWidth = this.getRightFrozenColsWidth();
            const { row: rowStart } = this.getRowAt(scrollTop + frozenRowsHeight + 1);
            const { col: colStart } = this.getColAt(scrollLeft + frozenColsWidth + 1);
            const rowEnd = this.getAllRowsHeight() > this.tableNoFrameHeight
                ? this.getRowAt(scrollTop + this.tableNoFrameHeight - 1 - bottomFrozenRowsHeight).row
                : this.rowCount - 1;
            const colEnd = this.getAllColsWidth() > this.tableNoFrameWidth
                ? this.getColAt(scrollLeft + this.tableNoFrameWidth - 1 - rightFrozenColsWidth).col
                : this.colCount - 1;
            if (colEnd < 0 || rowEnd < 0) {
                return null;
            }
            return { rowStart, colStart, rowEnd, colEnd };
        }
        getBodyVisibleRowRange() {
            const { scrollTop } = this;
            const frozenRowsHeight = this.getFrozenRowsHeight();
            const bottomFrozenRowsHeight = this.getBottomFrozenRowsHeight();
            const { row: rowStart } = this.getRowAt(scrollTop + frozenRowsHeight + 1);
            const rowEnd = this.getAllRowsHeight() > this.tableNoFrameHeight
                ? this.getRowAt(scrollTop + this.tableNoFrameHeight - 1 - bottomFrozenRowsHeight).row
                : this.rowCount - 1;
            if (rowEnd < 0) {
                return null;
            }
            return { rowStart, rowEnd };
        }
        getBodyVisibleColRange() {
            const { scrollLeft } = this;
            const frozenColsWidth = this.getFrozenColsWidth();
            const rightFrozenColsWidth = this.getRightFrozenColsWidth();
            const { col: colStart } = this.getColAt(scrollLeft + frozenColsWidth + 1);
            const colEnd = this.getAllColsWidth() > this.tableNoFrameWidth
                ? this.getColAt(scrollLeft + this.tableNoFrameWidth - 1 - rightFrozenColsWidth).col
                : this.colCount - 1;
            if (colEnd < 0) {
                return null;
            }
            return { colStart, colEnd };
        }
        get visibleColCount() {
            const { frozenColCount } = this;
            const visibleRect = this.getVisibleRect();
            const visibleLeft = frozenColCount > 0 ? visibleRect.left + this.getColsWidth(0, frozenColCount - 1) : visibleRect.left;
            const initCol = this.getTargetColAt(visibleLeft);
            if (!initCol) {
                return 0;
            }
            const startCol = Math.max(initCol.left >= visibleLeft ? initCol.col : initCol.col + 1, frozenColCount);
            let absoluteLeft = this.getColsWidth(0, startCol - 1);
            let count = 0;
            const { colCount } = this;
            for (let col = startCol; col < colCount; col++) {
                const width = this.getColWidth(col);
                const right = absoluteLeft + width;
                if (visibleRect.right < right) {
                    break;
                }
                count++;
                absoluteLeft = right;
            }
            return count;
        }
        get scrollTop() {
            return this.stateManager.scroll.verticalBarPos;
        }
        set scrollTop(scrollTop) {
            this.stateManager.setScrollTop(scrollTop);
        }
        get scrollLeft() {
            return this.stateManager.scroll.horizontalBarPos;
        }
        set scrollLeft(scrollLeft) {
            this.stateManager.setScrollLeft(scrollLeft);
        }
        getScrollLeft() {
            return this.scrollLeft;
        }
        getScrollTop() {
            return this.scrollTop;
        }
        setScrollLeft(num) {
            this.scrollLeft = Math.ceil(num);
        }
        setScrollTop(num) {
            this.scrollTop = Math.ceil(num);
        }
        getCellOverflowText(col, row) {
            return this.scenegraph.getCellOverflowText(col, row);
        }
        addReleaseObj(releaseObj) {
            if (!releaseObj || !releaseObj.release || typeof releaseObj.release !== 'function') {
                throw new Error('not releaseObj!');
            }
            const releaseList = (this.internalProps.releaseList = this.internalProps.releaseList || []);
            releaseList.push(releaseObj);
        }
        dispose() {
            this.release();
        }
        release() {
            const internalProps = this.internalProps;
            if (this.isReleased) {
                return;
            }
            internalProps.tooltipHandler?.release?.();
            internalProps.menuHandler?.release?.();
            super.release?.();
            internalProps.handler?.release?.();
            this.eventManager.release();
            internalProps.focusControl?.release?.();
            internalProps.legends?.forEach(legend => {
                legend?.release();
            });
            internalProps.title?.release();
            internalProps.title = null;
            internalProps.emptyTip?.release();
            internalProps.emptyTip = null;
            internalProps.layoutMap.release();
            if (internalProps.releaseList) {
                internalProps.releaseList.forEach(releaseObj => releaseObj?.release?.());
                internalProps.releaseList = null;
            }
            this.scenegraph.stage.release();
            this.scenegraph.proxy.release();
            internalProps.focusControl.release();
            const { parentElement } = internalProps.element;
            if (parentElement && !this.options.canvas) {
                parentElement.removeChild(internalProps.element);
            }
            this.editorManager?.editingEditor?.onEnd?.();
            this.isReleased = true;
            this.scenegraph = null;
            this.internalProps = null;
            this.reactCustomLayout?.clearCache();
            this.pluginManager.release();
            clearChartRenderQueue();
        }
        fireListeners(type, event) {
            return super.fireListeners(type, event);
        }
        updateOption(options) {
            this.editorManager?.cancelEdit();
            this.options = options;
            this._hasAutoImageColumn = undefined;
            const { frozenColCount = 0, unfreezeAllOnExceedsMaxWidth, defaultRowHeight = 40, defaultHeaderRowHeight, defaultColWidth = 80, defaultHeaderColWidth = 80, keyboardOptions, eventOptions, rowSeriesNumber, columnResizeMode, rowResizeMode = 'none', resize, dragHeaderMode, dragOrder, showFrozenIcon, allowFrozenColCount, padding, hover, menu, select: click, pixelRatio, widthMode, heightMode, autoFillWidth, autoFillHeight, widthAdaptiveMode, heightAdaptiveMode, customRender, renderChartAsync, renderChartAsyncBatchCount, canvasWidth, canvasHeight, overscrollBehavior, limitMinWidth, limitMinHeight } = options;
            if (pixelRatio && pixelRatio !== this.internalProps.pixelRatio) {
                this.internalProps.pixelRatio = pixelRatio;
            }
            if (padding) {
                if (typeof padding === 'number') {
                    this.padding.top = padding;
                    this.padding.left = padding;
                    this.padding.bottom = padding;
                    this.padding.right = padding;
                }
                else {
                    padding.top && (this.padding.top = padding.top);
                    padding.bottom && (this.padding.bottom = padding.bottom);
                    padding.left && (this.padding.left = padding.left);
                    padding.right && (this.padding.right = padding.right);
                }
            }
            this.showFrozenIcon = typeof showFrozenIcon === 'boolean' ? showFrozenIcon : true;
            if (typeof allowFrozenColCount === 'number' && allowFrozenColCount <= 0) {
                this.showFrozenIcon = false;
            }
            this.widthMode = widthMode ?? 'standard';
            this.heightMode = heightMode ?? 'standard';
            this._widthAdaptiveMode = widthAdaptiveMode ?? 'only-body';
            this._heightAdaptiveMode = heightAdaptiveMode ?? 'only-body';
            this.autoFillWidth = autoFillWidth ?? false;
            this.autoFillHeight = autoFillHeight ?? false;
            this.customRender = customRender;
            this.canvasWidth = isNumber$4(canvasWidth) ? canvasWidth : undefined;
            this.canvasHeight = isNumber$4(canvasHeight) ? canvasHeight : undefined;
            const internalProps = this.internalProps;
            if (Env.mode !== 'node' && !options.canvas) {
                updateRootElementPadding(internalProps.element, this.padding);
            }
            this.columnWidthComputeMode = options.columnWidthComputeMode ?? 'normal';
            internalProps.frozenColCount = frozenColCount;
            internalProps.unfreezeAllOnExceedsMaxWidth = unfreezeAllOnExceedsMaxWidth ?? true;
            internalProps.defaultRowHeight = defaultRowHeight;
            internalProps.defaultHeaderRowHeight = defaultHeaderRowHeight ?? defaultRowHeight;
            internalProps.defaultColWidth = defaultColWidth;
            internalProps.defaultHeaderColWidth = defaultHeaderColWidth ?? defaultColWidth;
            internalProps.keyboardOptions = keyboardOptions;
            internalProps.eventOptions = eventOptions;
            internalProps.rowSeriesNumber = rowSeriesNumber;
            internalProps.columnResizeMode = resize?.columnResizeMode ?? columnResizeMode;
            internalProps.rowResizeMode = resize?.rowResizeMode ?? rowResizeMode;
            internalProps.dragHeaderMode = dragOrder?.dragHeaderMode ?? dragHeaderMode ?? 'none';
            internalProps.renderChartAsync = renderChartAsync;
            setBatchRenderChartCount(renderChartAsyncBatchCount);
            internalProps.overscrollBehavior = overscrollBehavior ?? 'auto';
            internalProps.cellTextOverflows = {};
            internalProps._rowHeightsMap = new NumberRangeMap(this);
            internalProps._rowRangeHeightsMap = new Map();
            internalProps._colRangeWidthsMap = new Map();
            internalProps._widthResizedColMap = new Set();
            internalProps._heightResizedRowMap = new Set();
            this.colWidthsMap = new NumberMap();
            this.colContentWidthsMap = new NumberMap();
            this.colWidthsLimit = {};
            internalProps.stick.changedCells.clear();
            internalProps.theme = themes.of(options.theme ?? themes.DEFAULT);
            internalProps.theme.isPivot = this.isPivotTable();
            setIconColor(internalProps.theme.functionalIconsStyle);
            this.scenegraph.updateStageBackground();
            internalProps.autoWrapText = options.autoWrapText;
            internalProps.enableLineBreak = options.enableLineBreak;
            internalProps.allowFrozenColCount = options.allowFrozenColCount ?? 0;
            internalProps.limitMaxAutoWidth = options.limitMaxAutoWidth ?? 450;
            internalProps.limitMinWidth =
                limitMinWidth !== null && limitMinWidth !== undefined
                    ? typeof limitMinWidth === 'number'
                        ? limitMinWidth
                        : limitMinWidth
                            ? 10
                            : 0
                    : 10;
            internalProps.limitMinHeight =
                limitMinHeight !== null && limitMinHeight !== undefined
                    ? typeof limitMinHeight === 'number'
                        ? limitMinHeight
                        : limitMinHeight
                            ? 10
                            : 0
                    : 10;
            internalProps.legends?.forEach(legend => {
                legend?.release();
            });
            internalProps.title?.release();
            internalProps.title = null;
            internalProps.emptyTip?.release();
            internalProps.emptyTip = null;
            internalProps.layoutMap.release();
            clearChartRenderQueue();
            this.scenegraph.clearCells();
            this.scenegraph.updateComponent();
            this.stateManager.updateOptionSetState();
            this._updateSize();
            this.eventManager.updateEventBinder();
            if (options.legends) {
                internalProps.legends = [];
                const createLegend = Factory.getFunction('createLegend');
                if (Array.isArray(options.legends)) {
                    for (let i = 0; i < options.legends.length; i++) {
                        internalProps.legends.push(createLegend(options.legends[i], this));
                    }
                    this.scenegraph.tableGroup.setAttributes({
                        x: this.tableX,
                        y: this.tableY
                    });
                }
                else {
                    internalProps.legends.push(createLegend(options.legends, this));
                    this.scenegraph.tableGroup.setAttributes({
                        x: this.tableX,
                        y: this.tableY
                    });
                }
            }
            internalProps.tooltip = Object.assign({
                parentElement: this.getElement(),
                renderMode: 'html',
                isShowOverflowTextTooltip: false,
                confine: true,
                position: Placement.bottom
            }, options.tooltip);
            if (internalProps.tooltip.renderMode === 'html' && !internalProps.tooltipHandler) {
                const TooltipHandler = Factory.getComponent('tooltipHandler');
                internalProps.tooltipHandler = new TooltipHandler(this, internalProps.tooltip.confine);
            }
            internalProps.menu = Object.assign({
                renderMode: 'html'
            }, options.menu);
            Array.isArray(options.menu?.dropDownMenuHighlight) &&
                this.setDropDownMenuHighlight(options.menu?.dropDownMenuHighlight);
            (Array.isArray(options.menu?.defaultHeaderMenuItems) ||
                typeof options.menu?.defaultHeaderMenuItems === 'function') &&
                (this.globalDropDownMenu = options.menu.defaultHeaderMenuItems);
            if (internalProps.menu.renderMode === 'html' && !internalProps.menuHandler) {
                const MenuHandler = Factory.getComponent('menuHandler');
                internalProps.menuHandler = new MenuHandler(this);
            }
            this.clearCellStyleCache();
            this.clearColWidthCache();
            this.clearRowHeightCache();
            internalProps.customMergeCell = getCustomMergeCellFunc(options.customMergeCell);
            this.customCellStylePlugin?.updateCustomCell(options.customCellStyle ?? [], options.customCellStyleArrangement ?? []);
            this._adjustCanvasSizeByOption();
        }
        renderWithRecreateCells() {
            this.internalProps.stick.changedCells.clear();
            const oldHoverState = { col: this.stateManager.hover.cellPos.col, row: this.stateManager.hover.cellPos.row };
            this.refreshHeader();
            this.internalProps.useOneRowHeightFillAll = false;
            this.scenegraph.clearCells();
            this.clearCellStyleCache();
            this.scenegraph.createSceneGraph();
            this.stateManager.updateHoverPos(oldHoverState.col, oldHoverState.row);
            this.render();
        }
        getFrozenRowsHeight() {
            const height = this.getRowsHeight(0, this.frozenRowCount - 1);
            return height;
        }
        getFrozenColsWidth() {
            const w = this.getColsWidth(0, this.frozenColCount - 1);
            return w;
        }
        getBottomFrozenRowsHeight() {
            if (this.bottomFrozenRowCount > 0) {
                let height = 0;
                for (let row = this.rowCount - this.bottomFrozenRowCount; row <= this.rowCount - 1; row++) {
                    height += this.getRowHeight(row);
                }
                return height;
            }
            return 0;
        }
        getRightFrozenColsWidth() {
            if (this.rightFrozenColCount > 0) {
                let width = 0;
                for (let col = this.colCount - this.rightFrozenColCount; col <= this.colCount - 1; col++) {
                    width += this.getColWidth(col);
                }
                return width;
            }
            return 0;
        }
        getDrawRange() {
            const width = Math.min(this.tableNoFrameWidth, this.getAllColsWidth());
            const height = Math.min(this.tableNoFrameHeight, this.getAllRowsHeight());
            return new Rect$1(this.tableX, this.tableY, width, height);
        }
        _getMouseAbstractPoint(evt) {
            const table = this;
            let e;
            if (!evt) {
                return { inTable: false, x: undefined, y: undefined };
            }
            if (isTouchEvent(evt)) {
                e = evt.changedTouches[0];
            }
            else {
                e = evt;
            }
            const clientX = e.clientX || e.pageX + window.scrollX;
            const clientY = e.clientY || e.pageY + window.scrollY;
            const rect = table.internalProps.canvas.getBoundingClientRect();
            let inTable = true;
            if (rect.right <= clientX) {
                inTable = false;
            }
            if (rect.bottom <= clientY) {
                inTable = false;
            }
            const currentWidth = rect.width;
            const originWidth = (this.rotateDegree === 90 ? this.canvas.offsetHeight : this.canvas.offsetWidth) || currentWidth;
            const widthRatio = currentWidth / originWidth;
            const currentHeight = rect.height;
            const originHeight = (this.rotateDegree === 90 ? this.canvas.offsetWidth : this.canvas.offsetHeight) || currentHeight;
            const heightRatio = currentHeight / originHeight;
            const rotateTablePlugin = this.pluginManager.getPluginByName('Rotate Table');
            if (rotateTablePlugin && this.rotateDegree === 90) {
                const x = clientX / widthRatio - (this.options.viewBox?.x1 ?? 0);
                const y = clientY / heightRatio - (this.options.viewBox?.y1 ?? 0);
                const point = { x, y, inTable };
                const matrix = rotateTablePlugin.matrix;
                matrix.transformPoint(point, point);
                return point;
            }
            const x = (clientX - rect.left) / widthRatio - (this.options.viewBox?.x1 ?? 0);
            const y = (clientY - rect.top) / heightRatio - (this.options.viewBox?.y1 ?? 0);
            const point = { x, y, inTable };
            if (this.internalProps.modifiedViewBoxTransform && this.scenegraph.stage.window.getViewBoxTransform()) {
                const transform = this.scenegraph.stage.window.getViewBoxTransform();
                transform.transformPoint(point, point);
                return point;
            }
            return point;
        }
        getTheme() {
            return this.internalProps.theme;
        }
        getTargetColAt(absoluteX) {
            return getTargetColAt(absoluteX, this);
        }
        getTargetRowAt(absoluteY) {
            const targetRow = getTargetRowAt(absoluteY, this);
            if (targetRow) {
                targetRow.row = Math.min(targetRow.row, this.rowCount - 1);
            }
            return targetRow;
        }
        getTargetColAtConsiderRightFrozen(absoluteX, isConsider) {
            return getTargetColAtConsiderRightFrozen(absoluteX, isConsider, this);
        }
        getTargetRowAtConsiderBottomFrozen(absoluteY, isConsider) {
            return getTargetRowAtConsiderBottomFrozen(absoluteY, isConsider, this);
        }
        clearSelected() {
            this.stateManager.updateSelectPos(-1, -1);
        }
        selectCell(col, row, isShift, isCtrl, makeSelectCellVisible, skipBodyMerge = false) {
            const isHasSelected = !!this.stateManager.select.ranges?.length;
            this.stateManager.updateSelectPos(col, row, isShift, isCtrl, false, makeSelectCellVisible ?? this.options.select?.makeSelectCellVisible ?? true, skipBodyMerge);
            this.stateManager.endSelectCells(true, isHasSelected);
        }
        selectCells(cellRanges) {
            const { scrollLeft, scrollTop } = this;
            cellRanges.forEach((cellRange, index) => {
                if (cellRange.start.col === cellRange.end.col && cellRange.start.row === cellRange.end.row) {
                    this.stateManager.updateSelectPos(cellRange.start.col, cellRange.start.row, false, index >= 1, false, this.options.select?.makeSelectCellVisible ?? true, true);
                }
                else {
                    this.stateManager.updateSelectPos(cellRange.start.col, cellRange.start.row, false, index >= 1, false, this.options.select?.makeSelectCellVisible ?? true, true);
                    this.stateManager.updateInteractionState(InteractionState.grabing);
                    this.stateManager.updateSelectPos(cellRange.end.col, cellRange.end.row, false, index >= 1, false, this.options.select?.makeSelectCellVisible ?? true, true);
                }
                this.stateManager.endSelectCells(false, false);
                this.stateManager.updateInteractionState(InteractionState.default);
            });
            this.setScrollTop(scrollTop);
            this.setScrollLeft(scrollLeft);
        }
        get recordsCount() {
            return this.records?.length;
        }
        get allowFrozenColCount() {
            return this.internalProps.allowFrozenColCount;
        }
        get rowHeaderLevelCount() {
            return this.internalProps.layoutMap.rowHeaderLevelCount;
        }
        get columnHeaderLevelCount() {
            return this.internalProps.layoutMap.columnHeaderLevelCount;
        }
        get records() {
            return this.internalProps.records;
        }
        get dataSource() {
            return this.internalProps.dataSource;
        }
        set dataSource(dataSource) {
            this.scenegraph.clearCells();
            _setDataSource(this, dataSource);
            this.refreshRowColCount();
            this.scenegraph.createSceneGraph();
            this.render();
        }
        get autoWrapText() {
            return this.internalProps.autoWrapText;
        }
        set autoWrapText(autoWrapText) {
            this.internalProps.autoWrapText = autoWrapText;
            this.options.autoWrapText = autoWrapText;
        }
        get enableLineBreak() {
            return this.internalProps.enableLineBreak;
        }
        set enableLineBreak(enableLineBreak) {
            this.internalProps.enableLineBreak = enableLineBreak;
            this.options.enableLineBreak = enableLineBreak;
        }
        updateAutoWrapText(autoWrapText) {
            if (this.internalProps.autoWrapText === autoWrapText) {
                return;
            }
            this.internalProps.autoWrapText = autoWrapText;
            this.options.autoWrapText = autoWrapText;
            this.scenegraph.clearCells();
            this.clearCellStyleCache();
            this.scenegraph.createSceneGraph();
            this.render();
        }
        get theme() {
            return this.internalProps.theme;
        }
        set theme(theme) {
            this.internalProps.theme = themes.of(theme ?? themes.DEFAULT);
            this.internalProps.theme.isPivot = this.isPivotTable();
            this.options.theme = theme;
            setIconColor(this.internalProps.theme.functionalIconsStyle);
        }
        updateTheme(theme) {
            const oldHoverState = { col: this.stateManager.hover.cellPos.col, row: this.stateManager.hover.cellPos.row };
            this.internalProps.theme = themes.of(theme ?? themes.DEFAULT);
            this.internalProps.theme.isPivot = this.isPivotTable();
            setIconColor(this.internalProps.theme.functionalIconsStyle);
            this.options.theme = theme;
            this.scenegraph.updateComponent();
            this.scenegraph.updateStageBackground();
            this.scenegraph.clearCells();
            this.clearCellStyleCache();
            this.scenegraph.createSceneGraph();
            this.stateManager.updateHoverPos(oldHoverState.col, oldHoverState.row);
            this.render();
        }
        getBodyField(col, row) {
            return this.internalProps.layoutMap.getBody(col, row).field;
        }
        getBodyColumnDefine(col, row) {
            const body = this.internalProps.layoutMap.getBody(col, row);
            return body?.define;
        }
        getBodyColumnType(col, row) {
            const cellType = this.internalProps.layoutMap.getBody(col, row)?.cellType ?? 'text';
            return getProp('cellType', { cellType }, col, row, this);
        }
        getCellType(col, row) {
            let cellType;
            if (this.isSeriesNumberInHeader(col, row)) {
                return this.internalProps.layoutMap.getSeriesNumberHeader(col, row).cellType;
            }
            else if (this.isHeader(col, row)) {
                cellType = this.internalProps.layoutMap.getHeader(col, row).headerType;
            }
            else {
                cellType = this.internalProps.layoutMap.getBody(col, row).cellType;
            }
            return getProp('cellType', { cellType }, col, row, this);
        }
        getHeaderField(col, row) {
            return this.internalProps.layoutMap.getHeaderField(col, row);
        }
        getHeaderDefine(col, row) {
            const hd = this.internalProps.layoutMap.getHeader(col, row);
            return hd?.define;
        }
        getCellLocation(col, row) {
            const hdType = this.internalProps.layoutMap.getCellLocation(col, row);
            return hdType;
        }
        getCellHeaderPaths(col, row) {
            const cellHeaderPaths = this.internalProps.layoutMap.getCellHeaderPaths(col, row);
            return cellHeaderPaths;
        }
        getHeadersDefine(col, row) {
            const headers = [];
            while (true) {
                const header = this.getHeaderDefine(col, row);
                if (header && (header.field || header.columns)) {
                    headers.push(header);
                }
                else {
                    break;
                }
                row++;
            }
            return headers;
        }
        _getHeaderLayoutMap(col, row) {
            return this.internalProps.layoutMap.getHeader(col, row);
        }
        _getBodyLayoutMap(col, row) {
            return this.internalProps.layoutMap.getBody(col, row);
        }
        getContext() {
            return this.internalProps.context;
        }
        getRecordByCell(col, row) {
            if (this.internalProps.layoutMap.isHeader(col, row)) {
                return undefined;
            }
            return this.getCellOriginRecord(col, row);
        }
        getRecordByRowCol(col, row) {
            return this.getRecordByCell(col, row);
        }
        getRecordStartRowByRecordIndex(index) {
            return this.internalProps.layoutMap.getRecordStartRowByRecordIndex(index);
        }
        _getHeaderCellBySortState(sortState) {
            const { layoutMap } = this.internalProps;
            const hd = layoutMap.headerObjects.find((col) => col && col.field === sortState.field);
            if (hd) {
                const headercell = layoutMap.getHeaderCellAdressById(hd.id);
                return headercell;
            }
            return undefined;
        }
        getCellRange(col, row) {
            if (this.internalProps.customMergeCell) {
                const customMerge = this.internalProps.customMergeCell(col, row, this);
                if (customMerge &&
                    customMerge.range &&
                    (isValid$3(customMerge.text) || customMerge.customLayout || customMerge.customRender)) {
                    const range = {
                        start: {
                            col: Math.max(customMerge.range.start.col, 0),
                            row: Math.max(customMerge.range.start.row, 0)
                        },
                        end: {
                            col: Math.min(customMerge.range.end.col, this.colCount - 1),
                            row: Math.min(customMerge.range.end.row, this.rowCount - 1)
                        },
                        isCustom: true
                    };
                    return range;
                }
            }
            return this.internalProps.layoutMap?.getCellRange(col, row);
        }
        hasCustomMerge() {
            return !!this.internalProps.customMergeCell;
        }
        getCustomMerge(col, row) {
            if (this.internalProps.customMergeCell) {
                const customMerge = this.internalProps.customMergeCell(col, row, this);
                if (customMerge &&
                    customMerge.range &&
                    (isValid$3(customMerge.text) || customMerge.customLayout || this.customRender)) {
                    if (customMerge.style) {
                        const styleClass = this.internalProps.bodyHelper.getStyleClass('text');
                        const style = customMerge.style;
                        const fullStyle = of$2(style, this.theme.bodyStyle, {
                            col,
                            row,
                            table: this,
                            value: customMerge.text,
                            dataValue: this.getCellOriginValue(col, row),
                            cellHeaderPaths: this.getCellHeaderPaths(col, row)
                        }, styleClass, this.options.autoWrapText, this.theme);
                        customMerge.style = fullStyle;
                    }
                    customMerge.range = {
                        start: {
                            col: Math.max(customMerge.range.start.col, 0),
                            row: Math.max(customMerge.range.start.row, 0)
                        },
                        end: {
                            col: Math.min(customMerge.range.end.col, this.colCount - 1),
                            row: Math.min(customMerge.range.end.row, this.rowCount - 1)
                        },
                        isCustom: true
                    };
                    return customMerge;
                }
            }
            return undefined;
        }
        isCellRangeEqual(col, row, targetCol, targetRow) {
            return this.internalProps.layoutMap.isCellRangeEqual(col, row, targetCol, targetRow);
        }
        _getLayoutCellId(col, row) {
            return this.internalProps.layoutMap.getCellId(col, row);
        }
        getHeaderDescription(col, row) {
            const field = this._getHeaderLayoutMap(col, row);
            const fieldDef = field?.define;
            const description = fieldDef?.description ?? field?.description;
            if (typeof description === 'function') {
                const arg = {
                    col,
                    row,
                    value: this.getCellValue(col, row),
                    dataValue: this.getCellOriginValue(col, row)
                };
                return description(arg);
            }
            return description;
        }
        setDropDownMenuHighlight(cells) {
            this.stateManager.setDropDownMenuHighlight(cells);
        }
        _dropDownMenuIsHighlight(colNow, rowNow, index) {
            return this.stateManager.dropDownMenuIsHighlight(colNow, rowNow, index);
        }
        isSeriesNumberInBody(col, row) {
            return (this.internalProps.layoutMap &&
                this.internalProps.layoutMap.isSeriesNumberInBody(col, row));
        }
        isSeriesNumberInHeader(col, row) {
            return (this.internalProps.layoutMap &&
                this.internalProps.layoutMap.isSeriesNumberInHeader(col, row));
        }
        isHeader(col, row) {
            return this.internalProps.layoutMap && this.internalProps.layoutMap.isHeader(col, row);
        }
        isColumnHeader(col, row) {
            return this.internalProps.layoutMap?.isColumnHeader(col, row);
        }
        isRowHeader(col, row) {
            return this.internalProps.layoutMap?.isRowHeader(col, row);
        }
        isCornerHeader(col, row) {
            return this.internalProps.layoutMap?.isCornerHeader(col, row);
        }
        isFrozenColumn(col, row) {
            return this.isLeftFrozenColumn(col, row) || this.isRightFrozenColumn(col, row);
        }
        isLeftFrozenColumn(col, row) {
            return this.internalProps.layoutMap?.isFrozenColumn(col, row);
        }
        isRightFrozenColumn(col, row) {
            return this.internalProps.layoutMap?.isRightFrozenColumn(col, row);
        }
        isFrozenRow(col, row) {
            return this.isTopFrozenRow(col, row) || this.isBottomFrozenRow(col, row);
        }
        isTopFrozenRow(col, row) {
            return this.internalProps.layoutMap?.isFrozenRow(col, row);
        }
        isBottomFrozenRow(col, row) {
            return this.internalProps.layoutMap?.isBottomFrozenRow(col, row);
        }
        getCellInfo(col, row) {
            if (col >= 0 && row >= 0) {
                const colDef = this.isHeader(col, row) ? this.getHeaderDefine(col, row) : this.getBodyColumnDefine(col, row);
                return {
                    col,
                    row,
                    field: this.getHeaderField(col, row),
                    cellHeaderPaths: this.internalProps.layoutMap.getCellHeaderPaths(col, row),
                    title: colDef?.title,
                    cellType: this.getCellType(col, row),
                    originData: this.getCellOriginRecord(col, row),
                    cellRange: this.getCellRangeRelativeRect({ col, row }),
                    value: this.getCellValue(col, row),
                    dataValue: this.getCellOriginValue(col, row),
                    cellLocation: this.getCellLocation(col, row),
                    scaleRatio: this.canvas.getBoundingClientRect().width / this.canvas.offsetWidth
                };
            }
            return undefined;
        }
        _hasField(field, col, row) {
            if (field === null) {
                return false;
            }
            const table = this;
            if (table.internalProps.layoutMap.isHeader(col, row)) {
                return false;
            }
            const index = table.getRecordShowIndexByCell(col, row);
            return table.internalProps.dataSource?.hasField(index, field);
        }
        _getCellStyle(col, row) {
            return getCellStyle(col, row, this);
        }
        clearCellStyleCache() {
            this.headerStyleCache.clear();
            this.bodyStyleCache.clear();
            this.bodyMergeTitleCache.clear();
            this.bodyBottomStyleCache.clear();
        }
        clearRowHeightCache() {
            this.internalProps._rowHeightsMap.clear();
            this._clearRowRangeHeightsMap();
        }
        clearColWidthCache() {
            this.internalProps._colWidthsMap.clear();
            this._clearColRangeWidthsMap();
        }
        _canResizeColumn(col, row) {
            if (!(col >= 0 && row >= 0)) {
                return false;
            }
            if (this.isCellRangeEqual(col, row, col + 1, row)) {
                return false;
            }
            if (this.internalProps.columnResizeMode === 'none') {
                return false;
            }
            else if (this.internalProps.columnResizeMode === 'header') {
                if (!this.isHeader(col, row)) {
                    return false;
                }
            }
            else if (this.internalProps.columnResizeMode === 'body') {
                if (this.isHeader(col, row)) {
                    return false;
                }
            }
            const limit = this.colWidthsLimit[col];
            if (!limit || !limit.min || !limit.max) {
                return true;
            }
            return limit.max !== limit.min;
        }
        _canResizeRow(col, row) {
            if (!(col >= 0 && row >= 0)) {
                return false;
            }
            if (this.isCellRangeEqual(col, row, col, row + 1)) {
                return false;
            }
            if (this.internalProps.rowResizeMode === 'none') {
                return false;
            }
            else if (this.internalProps.rowResizeMode === 'header') {
                if (!this.isHeader(col, row)) {
                    return false;
                }
            }
            else if (this.internalProps.rowResizeMode === 'body') {
                if (this.isHeader(col, row)) {
                    return false;
                }
            }
            return true;
        }
        _canDragHeaderPosition(col, row) {
            if (this.isHeader(col, row) &&
                (this.stateManager.isSelected(col, row) ||
                    (this.options.select?.headerSelectMode === 'body' &&
                        checkCellInSelect(col, row, [
                            this.getCellRange(this.stateManager.select.cellPos.col, this.stateManager.select.cellPos.row)
                        ])) ||
                    isCellDisableSelect(this, col, row))) {
                if (this.internalProps.frozenColDragHeaderMode === 'disabled' && this.isFrozenColumn(col)) {
                    return false;
                }
                if (this.stateManager.isSelected(col, row)) {
                    const selectRange = this.stateManager.select.ranges[0];
                    if (this.isColumnHeader(col, row)) {
                        if (selectRange.end.row !== this.rowCount - 1) {
                            return false;
                        }
                    }
                    else if (this.isRowHeader(col, row)) {
                        if (selectRange.end.col !== this.colCount - 1) {
                            return false;
                        }
                    }
                    else {
                        return false;
                    }
                }
                const define = this.getHeaderDefine(col, row);
                if (!define) {
                    return false;
                }
                if (define.dragHeader === undefined) {
                    if (this.internalProps.dragHeaderMode === 'all') {
                        return true;
                    }
                    else if (this.internalProps.dragHeaderMode === 'column') {
                        if (this.isColumnHeader(col, row)) {
                            return true;
                        }
                    }
                    else if (this.internalProps.dragHeaderMode === 'row') {
                        if (this.isRowHeader(col, row)) {
                            return true;
                        }
                    }
                    return false;
                }
                return define.dragHeader;
            }
            return false;
        }
        getCellIcons(col, row) {
            let icons;
            if (this.isHeader(col, row)) {
                icons = this.internalProps.headerHelper.getIcons(col, row);
            }
            else if (this.internalProps.layoutMap.isSeriesNumber(col, row)) {
                if (!this.options.groupBy || !this.getCellRawRecord(col, row)?.vtableMerge) {
                    const dragOrder = this.internalProps.layoutMap.getSeriesNumberBody(col, row)?.define
                        ?.dragOrder;
                    if (dragOrder) {
                        icons = this.internalProps.rowSeriesNumberHelper.getIcons(col, row);
                    }
                }
                const cellValue = this.getCellValue(col, row);
                const dataValue = this.getCellOriginValue(col, row);
                const ctx = this.internalProps.context;
                const cellIcon = this.internalProps.bodyHelper.getIcons(col, row, cellValue, dataValue, ctx);
                if (icons?.length > 0) {
                    icons = icons.concat(cellIcon);
                }
                else if (cellIcon?.length > 0) {
                    icons = cellIcon;
                }
            }
            else {
                const cellValue = this.getCellValue(col, row);
                const dataValue = this.getCellOriginValue(col, row);
                const ctx = this.internalProps.context;
                icons = this.internalProps.bodyHelper.getIcons(col, row, cellValue, dataValue, ctx);
            }
            return icons;
        }
        showDropDownMenu(col, row, dropDownMenuOptions) {
            let menuType = 'dropdown-menu';
            if (dropDownMenuOptions) {
                menuType = Array.isArray(dropDownMenuOptions.content) ? 'dropdown-menu' : 'container';
            }
            if (this.internalProps.menu.renderMode === 'html') {
                this.stateManager.menu.isShow = true;
                this.internalProps.menuHandler._bindToCell(col, row, menuType, dropDownMenuOptions);
            }
        }
        showTooltip(col, row, tooltipOptions) {
            if (this.internalProps.tooltip.renderMode === 'html') {
                this.internalProps.tooltipHandler._bindToCell(col, row, tooltipOptions);
            }
        }
        getCellStyle(col, row) {
            const actStyle = this._getCellStyle(col, row);
            const theme = getStyleTheme(actStyle, this, col, row, getProp).theme;
            const { autoWrapText, lineClamp, textOverflow } = actStyle;
            return {
                textAlign: theme.text.textAlign,
                textBaseline: theme.text.textBaseline,
                bgColor: isBoolean$4(theme.group.fill)
                    ? getProp('bgColor', actStyle, col, row, this)
                    : theme.group.fill,
                color: isBoolean$4(theme.text.fill) ? getProp('color', actStyle, col, row, this) : theme.text.fill,
                strokeColor: isBoolean$4(theme.text.stroke)
                    ? getProp('strokeColor', actStyle, col, row, this)
                    : theme.text.stroke,
                fontFamily: theme.text.fontFamily,
                fontSize: theme.text.fontSize,
                fontWeight: theme.text.fontWeight,
                fontVariant: theme.text.fontVariant,
                fontStyle: theme.text.fontStyle,
                lineHeight: theme.text.lineHeight,
                autoWrapText: autoWrapText ?? false,
                lineClamp: lineClamp ?? 'auto',
                textOverflow,
                borderColor: isBoolean$4(theme.group.stroke)
                    ? getProp('borderColor', actStyle, col, row, this)
                    : theme.group.stroke,
                borderLineWidth: theme.group.lineWidth,
                borderLineDash: theme.group.lineDash,
                underline: !!theme.text.underline,
                underlineDash: theme.text.underlineDash,
                underlineOffset: theme.text.underlineOffset,
                lineThrough: !!theme.text.lineThrough,
                padding: theme._vtable.padding,
                underlineWidth: theme.text.underline,
                lineThroughLineWidth: theme.text.lineThrough,
                _strokeArrayWidth: theme.group.strokeArrayWidth,
                _strokeArrayColor: theme.group.strokeArrayColor,
                _linkColor: getProp('linkColor', actStyle, col, row, this)
            };
        }
        getAllBodyCells(colMaxCount, rowMaxCount) {
            const start = { col: this.rowHeaderLevelCount, row: this.columnHeaderLevelCount };
            const end = { col: this.colCount - 1, row: this.rowCount - 1 };
            return Array(Math.min(rowMaxCount ?? 2000, end.row - start.row + 1, this.rowCount))
                .fill(0)
                .map((_, i) => Array(Math.min(colMaxCount ?? 2000, end.col - start.col + 1, this.colCount))
                .fill(0)
                .map((_, j) => this.getCellInfo(j + start.col, i + start.row)));
        }
        getAllCells(colMaxCount, rowMaxCount) {
            const start = { col: 0, row: 0 };
            const end = { col: this.colCount - 1, row: this.rowCount - 1 };
            return Array(Math.min(rowMaxCount ?? 2000, end.row - start.row + 1, this.rowCount))
                .fill(0)
                .map((_, i) => Array(Math.min(colMaxCount ?? 2000, end.col - start.col + 1, this.colCount))
                .fill(0)
                .map((_, j) => this.getCellInfo(j + start.col, i + start.row)));
        }
        getAllColumnHeaderCells() {
            const start = { col: this.rowHeaderLevelCount, row: 0 };
            const end = { col: this.colCount - 1, row: this.columnHeaderLevelCount - 1 };
            return Array(end.row - start.row + 1)
                .fill(0)
                .map((_, i) => Array(end.col - start.col + 1)
                .fill(0)
                .map((_, j) => this.getCellInfo(j + start.col, i + start.row)));
        }
        getAllRowHeaderCells() {
            const start = { col: 0, row: this.columnHeaderLevelCount };
            const end = { col: this.rowHeaderLevelCount - 1, row: this.rowCount - 1 };
            return Array(end.row - start.row + 1)
                .fill(0)
                .map((_, i) => Array(end.col - start.col + 1)
                .fill(0)
                .map((_, j) => this.getCellInfo(j + start.col, i + start.row)));
        }
        getCopyValue() {
            if (this.stateManager.select?.ranges?.length > 0) {
                const ranges = this.stateManager.select.ranges;
                let minCol = Math.min(ranges[0].start.col, ranges[0].end.col);
                let maxCol = Math.max(ranges[0].start.col, ranges[0].end.col);
                let minRow = Math.min(ranges[0].start.row, ranges[0].end.row);
                let maxRow = Math.max(ranges[0].start.row, ranges[0].end.row);
                ranges.forEach((a) => {
                    minCol = Math.min(minCol, a.start.col, a.end.col);
                    maxCol = Math.max(maxCol, a.start.col, a.end.col);
                    minRow = Math.min(minRow, a.start.row, a.end.row);
                    maxRow = Math.max(maxRow, a.start.row, a.end.row);
                });
                const isExistDataInRow = (r) => {
                    let isExist = false;
                    ranges.forEach((range) => {
                        const minRow = Math.min(range.start.row, range.end.row);
                        const maxRow = Math.max(range.start.row, range.end.row);
                        if (minRow <= r && maxRow >= r) {
                            isExist = true;
                        }
                    });
                    return isExist;
                };
                const isExistDataInCol = (c) => {
                    let isExist = false;
                    ranges.forEach((range) => {
                        const minCol = Math.min(range.start.col, range.end.col);
                        const maxCol = Math.max(range.start.col, range.end.col);
                        if (minCol <= c && maxCol >= c) {
                            isExist = true;
                        }
                    });
                    return isExist;
                };
                const getRangeExistDataInCell = (c, r) => {
                    let isExistRange;
                    ranges.forEach((range) => {
                        const minRow = Math.min(range.start.row, range.end.row);
                        const maxRow = Math.max(range.start.row, range.end.row);
                        const minCol = Math.min(range.start.col, range.end.col);
                        const maxCol = Math.max(range.start.col, range.end.col);
                        if (minCol <= c && maxCol >= c && minRow <= r && maxRow >= r) {
                            isExistRange = range;
                        }
                    });
                    return isExistRange;
                };
                const getCopyCellValue = (col, row, range) => {
                    const cellRange = this.getCellRange(col, row);
                    let copyStartCol = cellRange.start.col;
                    let copyStartRow = cellRange.start.row;
                    if (range) {
                        const rangeMinCol = Math.min(range.start.col, range.end.col);
                        const rangeMinRow = Math.min(range.start.row, range.end.row);
                        copyStartCol = Math.max(rangeMinCol, cellRange.start.col);
                        copyStartRow = Math.max(rangeMinRow, cellRange.start.row);
                    }
                    if (copyStartCol !== col || copyStartRow !== row) {
                        return '';
                    }
                    const value = this.getCellValue(col, row);
                    return value;
                };
                let copyValue = '';
                for (let r = minRow; r <= maxRow; r++) {
                    const isExistData = isExistDataInRow(r);
                    if (isExistData) {
                        for (let c = minCol; c <= maxCol; c++) {
                            const isExistDataCol = isExistDataInCol(c);
                            if (isExistDataCol) {
                                const range = getRangeExistDataInCell(c, r);
                                if (range) {
                                    const copyCellValue = getCopyCellValue(c, r, range);
                                    if (typeof Promise !== 'undefined' && copyCellValue instanceof Promise) ;
                                    else {
                                        const strCellValue = isValid$3(copyCellValue) ? `${copyCellValue}` : '';
                                        if (/^\[object .*\]$/.exec(strCellValue)) ;
                                        else {
                                            copyValue += strCellValue;
                                        }
                                    }
                                    if (c < range.end.col || c < maxCol) {
                                        copyValue += '\t';
                                    }
                                }
                                else {
                                    copyValue += '\t';
                                }
                            }
                        }
                        if (r < maxRow) {
                            copyValue += '\r\n';
                        }
                    }
                }
                if (this.options?.formatCopyValue) {
                    copyValue = this.options.formatCopyValue(copyValue);
                }
                return copyValue;
            }
            return '';
        }
        getSelectedCellInfos() {
            if (!this.stateManager.select?.ranges) {
                return null;
            }
            const ranges = this.stateManager.select.ranges;
            if (!ranges.length) {
                return [];
            }
            let minCol = Math.min(ranges[0].start.col, ranges[0].end.col);
            let maxCol = Math.max(ranges[0].start.col, ranges[0].end.col);
            let minRow = Math.min(ranges[0].start.row, ranges[0].end.row);
            let maxRow = Math.max(ranges[0].start.row, ranges[0].end.row);
            ranges.forEach((a) => {
                minCol = Math.min(minCol, a.start.col, a.end.col);
                maxCol = Math.max(maxCol, a.start.col, a.end.col);
                minRow = Math.min(minRow, a.start.row, a.end.row);
                maxRow = Math.max(maxRow, a.start.row, a.end.row);
            });
            const isExistDataInRow = (r) => {
                let isExist = false;
                ranges.forEach((range) => {
                    const minRow = Math.min(range.start.row, range.end.row);
                    const maxRow = Math.max(range.start.row, range.end.row);
                    if (minRow <= r && maxRow >= r) {
                        isExist = true;
                    }
                });
                return isExist;
            };
            const isExistDataInCol = (c) => {
                let isExist = false;
                ranges.forEach((range) => {
                    const minCol = Math.min(range.start.col, range.end.col);
                    const maxCol = Math.max(range.start.col, range.end.col);
                    if (minCol <= c && maxCol >= c) {
                        isExist = true;
                    }
                });
                return isExist;
            };
            const getRangeExistDataInCell = (c, r) => {
                let isExistRange;
                ranges.forEach((range) => {
                    const minRow = Math.min(range.start.row, range.end.row);
                    const maxRow = Math.max(range.start.row, range.end.row);
                    const minCol = Math.min(range.start.col, range.end.col);
                    const maxCol = Math.max(range.start.col, range.end.col);
                    if (minCol <= c && maxCol >= c && minRow <= r && maxRow >= r) {
                        isExistRange = range;
                    }
                });
                return isExistRange;
            };
            const cellInfoArray = [];
            for (let r = minRow; r <= maxRow; r++) {
                const isExistData = isExistDataInRow(r);
                if (isExistData) {
                    const cellInfoRow = [];
                    for (let c = minCol; c <= maxCol; c++) {
                        const isExistDataCol = isExistDataInCol(c);
                        if (isExistDataCol) {
                            const range = getRangeExistDataInCell(c, r);
                            if (range) {
                                const cellInfo = this.getCellInfo(c, r);
                                cellInfoRow.push(cellInfo);
                            }
                        }
                    }
                    cellInfoArray.push(cellInfoRow);
                }
            }
            return cellInfoArray;
        }
        getSelectedCellRanges() {
            const ranges = this.stateManager.select.ranges;
            if (!ranges.length) {
                return [];
            }
            return cloneDeep$1(ranges);
        }
        measureText(text, font) {
            return textMeasure.measureText(text, font);
        }
        measureTextBounds(attribute) {
            return measureTextBounds(attribute);
        }
        getCustomRender(col, row) {
            let customRender;
            if (this.getCellLocation(col, row) !== 'body') {
                const define = this.getHeaderDefine(col, row);
                customRender = define?.headerCustomRender;
            }
            else {
                const define = this.getBodyColumnDefine(col, row);
                customRender = define?.customRender || this.customRender;
            }
            return customRender;
        }
        getCustomLayout(col, row) {
            let customLayout;
            if (this.getCellLocation(col, row) !== 'body') {
                const define = this.getHeaderDefine(col, row);
                customLayout = define?.headerCustomLayout;
            }
            else {
                const define = this.getBodyColumnDefine(col, row);
                customLayout = define?.customLayout;
            }
            return customLayout;
        }
        hasAutoImageColumn() {
            if (this._hasAutoImageColumn === undefined) {
                this._hasAutoImageColumn = hasAutoImageColumn(this);
            }
            return this._hasAutoImageColumn;
        }
        _getActiveChartInstance() {
            const cellGroup = this.scenegraph.getCell(this.stateManager.hover?.cellPos?.col, this.stateManager.hover?.cellPos?.row);
            return cellGroup?.getChildren()?.[0]?.type === 'chart'
                ? cellGroup.getChildren()[0].activeChartInstance
                : null;
        }
        cellIsInVisualView(col, row) {
            const drawRange = this.getDrawRange();
            const rect = this.getCellRelativeRect(col, row);
            if (col < this.frozenColCount && row < this.frozenRowCount) {
                return true;
            }
            let colHeaderRangeRect;
            if (this.frozenRowCount >= 1) {
                colHeaderRangeRect = this.getCellRangeRelativeRect({
                    start: {
                        col: 0,
                        row: 0
                    },
                    end: {
                        col: this.colCount - 1,
                        row: this.frozenRowCount - 1
                    }
                });
            }
            let rowHeaderRangeRect;
            if (this.frozenColCount >= 1) {
                rowHeaderRangeRect = this.getCellRangeRelativeRect({
                    start: {
                        col: 0,
                        row: 0
                    },
                    end: {
                        col: this.frozenColCount - 1,
                        row: this.rowCount - 1
                    }
                });
            }
            let bottomFrozenRangeRect;
            if (this.bottomFrozenRowCount >= 1) {
                bottomFrozenRangeRect = this.getCellRangeRelativeRect({
                    start: {
                        col: 0,
                        row: this.rowCount - this.bottomFrozenRowCount
                    },
                    end: {
                        col: this.colCount - 1,
                        row: this.rowCount - 1
                    }
                });
            }
            let rightFrozenRangeRect;
            if (this.rightFrozenColCount >= 1) {
                rightFrozenRangeRect = this.getCellRangeRelativeRect({
                    start: {
                        col: this.colCount - this.rightFrozenColCount,
                        row: 0
                    },
                    end: {
                        col: this.colCount - 1,
                        row: this.rowCount - 1
                    }
                });
            }
            if (rect.top >= drawRange.top &&
                rect.bottom <= drawRange.bottom &&
                rect.left >= drawRange.left &&
                rect.right <= drawRange.right) {
                if (this.isFrozenCell(col, row)) {
                    return true;
                }
                else if (rect.top >= (colHeaderRangeRect?.bottom ?? rect.top) &&
                    rect.left >= (rowHeaderRangeRect?.right ?? rect.left) &&
                    rect.bottom <= (bottomFrozenRangeRect?.top ?? rect.bottom) &&
                    rect.right <= (rightFrozenRangeRect?.left ?? rect.right)) {
                    return true;
                }
            }
            return false;
        }
        getCustomMergeValue(col, row) {
            if (this.internalProps.customMergeCell) {
                const customMerge = this.getCustomMerge(col, row);
                if (customMerge) {
                    const { text } = customMerge;
                    return text;
                }
            }
            return undefined;
        }
        exportImg() {
            const c = this.scenegraph.stage.toCanvas();
            return c.toDataURL();
        }
        exportCellImg(col, row, options) {
            const isInView = this.cellIsInVisualView(col, row);
            const { scrollTop, scrollLeft } = this;
            if (!isInView) {
                this.scrollToCell({ col, row });
            }
            const cellRect = this.getCellRelativeRect(col, row);
            if (this.stateManager.select?.ranges?.length > 0) {
                hideCellSelectBorder(this.scenegraph);
            }
            const { col: hoverCol, row: hoverRow } = this.stateManager.hover.cellPos;
            this.stateManager.updateHoverPos(-1, -1);
            this.scenegraph.component.hideVerticalScrollBar();
            this.scenegraph.component.hideHorizontalScrollBar();
            this.scenegraph.tableGroup.border.setAttribute('visible', false);
            let oldFill;
            if (options?.disableBackground) {
                const cellGroup = this.scenegraph.getCell(col, row);
                oldFill = cellGroup.attribute.fill;
                cellGroup.setAttribute('fill', 'transparent');
            }
            let oldStroke;
            if (options?.disableBorder) {
                const cellGroup = this.scenegraph.getCell(col, row);
                oldStroke = cellGroup.attribute.stroke;
                cellGroup.setAttribute('stroke', false);
            }
            this.scenegraph.renderSceneGraph();
            let sizeOffset = 0;
            if (this.theme.cellBorderClipDirection === 'bottom-right') {
                sizeOffset = 1;
            }
            const c = this.scenegraph.stage.toCanvas(false, new AABBBounds().set(cellRect.left + this.tableX + 1, cellRect.top + this.tableY + 1, cellRect.right + this.tableX - sizeOffset, cellRect.bottom + this.tableY - sizeOffset));
            if (!isInView) {
                this.setScrollTop(scrollTop);
                this.setScrollLeft(scrollLeft);
            }
            this.scenegraph.tableGroup.border.setAttribute('visible', true);
            if (oldFill) {
                const cellGroup = this.scenegraph.getCell(col, row);
                cellGroup.setAttribute('fill', oldFill);
            }
            if (oldStroke) {
                const cellGroup = this.scenegraph.getCell(col, row);
                cellGroup.setAttribute('stroke', oldStroke);
            }
            if (this.stateManager.select?.ranges?.length > 0) {
                restoreCellSelectBorder(this.scenegraph);
            }
            this.stateManager.updateHoverPos(hoverCol, hoverRow);
            this.scenegraph.updateNextFrame();
            return c.toDataURL();
        }
        exportCellRangeImg(cellRange) {
            const { scrollTop, scrollLeft } = this;
            const minCol = Math.min(cellRange.start.col, cellRange.end.col);
            const minRow = Math.min(cellRange.start.row, cellRange.end.row);
            const maxCol = Math.max(cellRange.start.col, cellRange.end.col);
            const maxRow = Math.max(cellRange.start.row, cellRange.end.row);
            const isInView = this.cellIsInVisualView(minCol, minRow);
            const isMaxCellInView = this.cellIsInVisualView(maxCol, maxRow);
            if (!isInView || !isMaxCellInView) {
                this.scrollToCell({ col: minCol, row: minRow });
            }
            const cellRect = this.getCellRangeRelativeRect({
                start: { col: minCol, row: minRow },
                end: { col: maxCol, row: maxRow }
            });
            if (this.stateManager.select?.ranges?.length > 0) {
                hideCellSelectBorder(this.scenegraph);
            }
            const { col: hoverCol, row: hoverRow } = this.stateManager.hover.cellPos;
            this.stateManager.updateHoverPos(-1, -1);
            this.scenegraph.component.hideVerticalScrollBar();
            this.scenegraph.component.hideHorizontalScrollBar();
            this.scenegraph.renderSceneGraph();
            const c = this.scenegraph.stage.toCanvas(false, new AABBBounds().set(cellRect.left + this.tableX + 1, cellRect.top + this.tableY + 1, cellRect.right + this.tableX, cellRect.bottom + this.tableY));
            const base64Image = c.toDataURL();
            if (!isInView || !isMaxCellInView) {
                this.setScrollTop(scrollTop);
                this.setScrollLeft(scrollLeft);
            }
            if (this.stateManager.select?.ranges?.length > 0) {
                restoreCellSelectBorder(this.scenegraph);
            }
            this.stateManager.updateHoverPos(hoverCol, hoverRow);
            return base64Image;
        }
        exportCanvas() {
            const c = this.scenegraph.stage.toCanvas();
            return c;
        }
        getImageBuffer(type = 'image/png') {
            if (this.options.mode !== 'node') {
                return;
            }
            this.render();
            const stage = this.scenegraph.stage;
            if (stage) {
                const contentWidth = this.tableX + this.getAllColsWidth();
                const contentHeight = this.tableY + this.getAllRowsHeight();
                if (contentWidth >= this.canvasWidth && contentHeight >= this.canvasHeight) {
                    stage.render();
                    const buffer = stage.window.getImageBuffer(type);
                    return buffer;
                }
                const newCanvas = this.scenegraph.stage.toCanvas(false, new AABBBounds().set(0, 0, Math.min(this.canvasWidth, contentWidth), Math.min(this.canvasHeight, contentHeight)));
                const buffer = newCanvas.toBuffer(type);
                return buffer;
            }
            return null;
        }
        getBodyIndexByTableIndex(col, row) {
            return {
                col: col - this.rowHeaderLevelCount - this.leftRowSeriesNumberCount,
                row: row - this.columnHeaderLevelCount
            };
        }
        getTableIndexByBodyIndex(col, row) {
            return {
                col: col + this.rowHeaderLevelCount + this.leftRowSeriesNumberCount,
                row: row + this.columnHeaderLevelCount
            };
        }
        onVChartEvent(type, query, callback) {
            if (!this._chartEventMap[type]) {
                this._chartEventMap[type] = [];
            }
            if (typeof query === 'function') {
                this._chartEventMap[type].push({ callback: query });
            }
            else {
                this._chartEventMap[type].push({ callback, query });
            }
        }
        offVChartEvent(type, callback) {
            if (!this._chartEventMap[type]) {
                return;
            }
            if (callback) {
                this._chartEventMap[type] = this._chartEventMap[type].filter(e => e.callback !== callback);
            }
            else {
                this._chartEventMap[type] = [];
            }
        }
        _bindChartEvent(activeChartInstance) {
            if (activeChartInstance) {
                for (const key in this._chartEventMap) {
                    (this._chartEventMap[key] || []).forEach(e => {
                        if (e.query) {
                            activeChartInstance.on(key, e.query, e.callback);
                        }
                        else {
                            activeChartInstance.on(key, e.callback);
                        }
                    });
                }
            }
        }
        changeRecordOrder(source, target) {
        }
        hasCustomCellStyle(customStyleId) {
            return this.customCellStylePlugin?.hasCustomCellStyle(customStyleId);
        }
        registerCustomCellStyle(customStyleId, customStyle) {
            this.customCellStylePlugin?.registerCustomCellStyle(customStyleId, customStyle);
        }
        arrangeCustomCellStyle(cellPos, customStyleId, forceFastUpdate) {
            this.customCellStylePlugin?.arrangeCustomCellStyle(cellPos, customStyleId, forceFastUpdate);
        }
        isSeriesNumber(col, row) {
            return this.internalProps.layoutMap.isSeriesNumber(col, row);
        }
        isHasSeriesNumber() {
            return this.internalProps.layoutMap?.leftRowSeriesNumberColumnCount > 0;
        }
        get leftRowSeriesNumberCount() {
            return this.internalProps.layoutMap?.leftRowSeriesNumberColumnCount ?? 0;
        }
        setMinMaxLimitWidth(setWidth = false) {
            const internalProps = this.internalProps;
            for (let col = 0; col < internalProps.layoutMap.columnWidths.length; col++) {
                if (this.internalProps._widthResizedColMap.has(col)) {
                    continue;
                }
                const { width, minWidth, maxWidth } = internalProps.layoutMap.columnWidths?.[col] ?? {};
                if (setWidth &&
                    width &&
                    ((typeof width === 'string' && width !== 'auto') || (typeof width === 'number' && width > 0))) {
                    this._setColWidth(col, width);
                }
                if (minWidth && ((typeof minWidth === 'number' && minWidth > 0) || typeof minWidth === 'string')) {
                    this.setMinColWidth(col, minWidth);
                }
                if (maxWidth && ((typeof maxWidth === 'number' && maxWidth > 0) || typeof maxWidth === 'string')) {
                    this.setMaxColWidth(col, maxWidth);
                }
            }
        }
        setSortedIndexMap(field, filedMap) {
            this.dataSource?.setSortedIndexMap(field, filedMap);
        }
        checkReactCustomLayout() {
            if (!this.reactCustomLayout) {
                this.reactCustomLayout = new ReactCustomLayout(this);
            }
        }
        get bodyDomContainer() {
            return this.internalProps.bodyDomContainer;
        }
        get headerDomContainer() {
            return this.internalProps.headerDomContainer;
        }
        get frozenBodyDomContainer() {
            return this.internalProps.frozenBodyDomContainer;
        }
        get frozenHeaderDomContainer() {
            return this.internalProps.frozenHeaderDomContainer;
        }
        get rightFrozenBodyDomContainer() {
            return this.internalProps.rightFrozenBodyDomContainer;
        }
        get rightFrozenHeaderDomContainer() {
            return this.internalProps.rightFrozenHeaderDomContainer;
        }
        get frozenBottomDomContainer() {
            return this.internalProps.frozenBottomDomContainer;
        }
        get bottomDomContainer() {
            return this.internalProps.bottomDomContainer;
        }
        get rightFrozenBottomDomContainer() {
            return this.internalProps.rightFrozenBottomDomContainer;
        }
        showMoverLine(col, row) {
            this.scenegraph.component.showMoveCol(col, row, 0);
            this.scenegraph.renderSceneGraph();
        }
        hideMoverLine(col, row) {
            this.scenegraph.component.hideMoveCol();
            this.scenegraph.renderSceneGraph();
        }
        disableScroll() {
            this.eventManager.disableScroll();
        }
        enableScroll() {
            this.eventManager.enableScroll();
        }
        getGroupTitleLevel(col, row) {
            return undefined;
        }
        scrollToRow(row, animationOption) {
            if (!animationOption) {
                this.scrollToCell({ row });
                return;
            }
            this.animationManager.scrollTo({ row }, animationOption);
        }
        scrollToCol(col, animationOption) {
            if (!animationOption) {
                this.scrollToCell({ col });
                return;
            }
            this.animationManager.scrollTo({ col }, animationOption);
        }
        scrollToCell(cellAddr, animationOption) {
            if (animationOption) {
                this.animationManager.scrollTo(cellAddr, animationOption);
                return;
            }
            const drawRange = this.getDrawRange();
            if (isValid$3(cellAddr.col) && cellAddr.col >= this.frozenColCount) {
                const frozenWidth = this.getFrozenColsWidth();
                const left = this.getColsWidth(0, cellAddr.col - 1);
                this.scrollLeft = Math.min(left - frozenWidth, this.getAllColsWidth() - drawRange.width);
            }
            if (isValid$3(cellAddr.row) && cellAddr.row >= this.frozenRowCount) {
                const frozenHeight = this.getFrozenRowsHeight();
                const top = this.getRowsHeight(0, cellAddr.row - 1);
                this.scrollTop = Math.min(top - frozenHeight, this.getAllRowsHeight() - drawRange.height);
            }
            this.render();
        }
        checkHasColumnAutoWidth() {
            return checkHasColumnAutoWidth(this);
        }
    }

    var core = /*#__PURE__*/Object.freeze({
        __proto__: null,
        BaseTable: BaseTable
    });

    const chartTypes = {};
    const builtin = {};
    function get$1() {
        return extend(builtin, chartTypes);
    }

    const editors = {};
    function get(editorName) {
        const editor = editors[editorName];
        if (!editor) {
            return undefined;
        }
        return editors[editorName];
    }

    function register(obj, name, value) {
        const old = obj[name];
        obj[name] = value;
        return old;
    }
    function theme(name, theme) {
        if (theme !== null && theme !== undefined) {
            return register(themes$2, name, theme);
        }
        return themes$2[name];
    }
    function icon(name, icon) {
        if (icon !== null && icon !== undefined) {
            return register(icons, name, icon);
        }
        return icons[name];
    }
    function chartModule(name, chartModule) {
        if (chartModule !== null && chartModule !== undefined) {
            return register(chartTypes, name, chartModule);
        }
        return chartTypes[name];
    }
    function editor(name, editor) {
        if (editor !== null && editor !== undefined) {
            return register(editors, name, editor);
        }
        return editors[name];
    }
    function aggregator(aggregationType, aggregation) {
        if (aggregation !== null && aggregation !== undefined) {
            register(registeredAggregators, aggregationType, aggregation);
        }
    }
    function clear(obj) {
        for (const key in obj) {
            delete obj[key];
        }
    }
    function clearAll() {
        clear(themes$2);
        clear(icons);
        clear(chartTypes);
        clear(editors);
        clear(registeredAggregators);
    }

    var register$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        aggregator: aggregator,
        chartModule: chartModule,
        clearAll: clearAll,
        editor: editor,
        icon: icon,
        theme: theme
    });

    function numberAddSeparators(str, thousandsSep, decimalSep) {
        str += '';
        const strArr = str.split('.');
        let str1 = strArr[0];
        const str2 = strArr.length > 1 ? decimalSep + strArr[1] : '';
        str1 = numFormat(str1, thousandsSep);
        return str1 + str2;
    }
    function numFormat(num, thousandsSep) {
        const res = num.replace(/\d+/, function (n) {
            return n.replace(/(\d)(?=(\d{3})+$)/g, function ($1) {
                return `${$1}${thousandsSep}`;
            });
        });
        return res;
    }
    function numberFormat(option) {
        const defaults = {
            digitsAfterDecimal: 2,
            scaler: 1,
            thousandsSep: ',',
            decimalSep: '.',
            prefix: '',
            suffix: ''
        };
        option = Object.assign({}, defaults, option);
        return function (num) {
            if (isNaN(num) || !isFinite(num)) {
                return '';
            }
            const result = numberAddSeparators((option.scaler * num).toFixed(option.digitsAfterDecimal), option.thousandsSep, option.decimalSep);
            return `${option.prefix}${result}${option.suffix}`;
        };
    }
    function dateFormat(baseField, formatString, utcOutput, mthNames, dayNames) {
        const mthNamesEn = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        const dayNamesEn = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
        if (utcOutput === null || utcOutput === undefined) {
            utcOutput = false;
        }
        if (mthNames === null || mthNames === undefined) {
            mthNames = mthNamesEn;
        }
        if (dayNames === null || dayNames === undefined) {
            dayNames = dayNamesEn;
        }
        const utc = utcOutput ? 'UTC' : '';
        const zeroPad = function (number) {
            return `0${number}`.substring(0, 2);
        };
        return function (record) {
            const date = new Date(Date.parse(record[baseField]));
            return formatString.replace(/%(.)/g, function (m, p) {
                switch (p) {
                    case 'y':
                        return date[`get${utc}FullYear`]();
                    case 'm':
                        return zeroPad(date[`get${utc}Month`]() + 1);
                    case 'n':
                        return mthNames[date[`get${utc}Month`]()];
                    case 'd':
                        return zeroPad(date[`get${utc}Date`]());
                    case 'w':
                        return dayNames[date[`get${utc}Day`]()];
                    case 'x':
                        return date[`get${utc}Day`]();
                    case 'H':
                        return zeroPad(date[`get${utc}Hours`]());
                    case 'M':
                        return zeroPad(date[`get${utc}Minutes`]());
                    case 'S':
                        return zeroPad(date[`get${utc}Seconds`]());
                    default:
                        return `%${p}`;
                }
            });
        };
    }

    var DataStatistics = /*#__PURE__*/Object.freeze({
        __proto__: null,
        dateFormat: dateFormat,
        numberFormat: numberFormat
    });

    var index$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        CustomCellStylePlugin: CustomCellStylePlugin,
        PluginManager: PluginManager
    });

    const isType = (value, type) => Object.prototype.toString.call(value) === `[object ${type}]`;
    var isType$1 = isType;

    const isBoolean = function (value) {
      let fuzzy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
      return fuzzy ? "boolean" == typeof value : !0 === value || !1 === value || isType$1(value, "Boolean");
    };
    var isBoolean$1 = isBoolean;

    const isFunction = value => "function" == typeof value;
    var isFunction$1 = isFunction;

    const isNil = value => null == value;
    var isNil$1 = isNil;

    const isValid = value => null != value;
    var isValid$1 = isValid;

    const isObjectLike = value => "object" == typeof value && null !== value;
    var isObjectLike$1 = isObjectLike;

    const isPlainObject = function (value) {
      if (!isObjectLike$1(value) || !isType$1(value, "Object")) return !1;
      if (null === Object.getPrototypeOf(value)) return !0;
      let proto = value;
      for (; null !== Object.getPrototypeOf(proto);) proto = Object.getPrototypeOf(proto);
      return Object.getPrototypeOf(value) === proto;
    };
    var isPlainObject$1 = isPlainObject;

    const isString = function (value) {
      let fuzzy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
      const type = typeof value;
      return fuzzy ? "string" === type : "string" === type || isType$1(value, "String");
    };
    var isString$1 = isString;

    const isArray = value => Array.isArray ? Array.isArray(value) : isType$1(value, "Array");
    var isArray$1 = isArray;

    const isArrayLike = function (value) {
      return null !== value && "function" != typeof value && Number.isFinite(value.length);
    };
    var isArrayLike$1 = isArrayLike;

    const isDate = value => isType$1(value, "Date");
    var isDate$1 = isDate;

    const isNumber = function (value) {
      let fuzzy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
      const type = typeof value;
      return fuzzy ? "number" === type : "number" === type || isType$1(value, "Number");
    };
    var isNumber$1 = isNumber;

    function cloneDeep(value, ignoreWhen, excludeKeys) {
      let result;
      if (!isValid$1(value) || "object" != typeof value || ignoreWhen && ignoreWhen(value)) return value;
      const isArr = isArray$1(value),
        length = value.length;
      result = isArr ? new Array(length) : "object" == typeof value ? {} : isBoolean$1(value) || isNumber$1(value) || isString$1(value) ? value : isDate$1(value) ? new Date(+value) : void 0;
      const props = isArr ? void 0 : Object.keys(Object(value));
      let index = -1;
      if (result) for (; ++index < (props || value).length;) {
        const key = props ? props[index] : index,
          subValue = value[key];
        excludeKeys && excludeKeys.includes(key.toString()) ? result[key] = subValue : result[key] = cloneDeep(subValue, ignoreWhen, excludeKeys);
      }
      return result;
    }

    function baseMerge(target, source) {
      let shallowArray = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
      let skipTargetArray = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
      if (source) {
        if (target === source) return;
        if (isValid$1(source) && "object" == typeof source) {
          const iterable = Object(source),
            props = [];
          for (const key in iterable) props.push(key);
          let {
              length: length
            } = props,
            propIndex = -1;
          for (; length--;) {
            const key = props[++propIndex];
            !isValid$1(iterable[key]) || "object" != typeof iterable[key] || skipTargetArray && isArray$1(target[key]) ? assignMergeValue(target, key, iterable[key]) : baseMergeDeep(target, source, key, shallowArray, skipTargetArray);
          }
        }
      }
    }
    function baseMergeDeep(target, source, key) {
      let shallowArray = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
      let skipTargetArray = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !1;
      const objValue = target[key],
        srcValue = source[key];
      let newValue = source[key],
        isCommon = !0;
      if (isArray$1(srcValue)) {
        if (shallowArray) newValue = [];else if (isArray$1(objValue)) newValue = objValue;else if (isArrayLike$1(objValue)) {
          newValue = new Array(objValue.length);
          let index = -1;
          const length = objValue.length;
          for (; ++index < length;) newValue[index] = objValue[index];
        }
      } else isPlainObject$1(srcValue) ? (newValue = null != objValue ? objValue : {}, "function" != typeof objValue && "object" == typeof objValue || (newValue = {})) : isCommon = !1;
      isCommon && baseMerge(newValue, srcValue, shallowArray, skipTargetArray), assignMergeValue(target, key, newValue);
    }
    function assignMergeValue(target, key, value) {
      (void 0 !== value && !eq(target[key], value) || void 0 === value && !(key in target)) && (target[key] = value);
    }
    function eq(value, other) {
      return value === other || Number.isNaN(value) && Number.isNaN(other);
    }
    function merge(target) {
      let sourceIndex = -1;
      const length = arguments.length <= 1 ? 0 : arguments.length - 1;
      for (; ++sourceIndex < length;) {
        baseMerge(target, sourceIndex + 1 < 1 || arguments.length <= sourceIndex + 1 ? undefined : arguments[sourceIndex + 1], !0);
      }
      return target;
    }

    function keys(obj) {
      if (!obj) return [];
      if (Object.keys) return Object.keys(obj);
      const keyList = [];
      for (const key in obj) obj.hasOwnProperty(key) && keyList.push(key);
      return keyList;
    }
    function defaults(target, source, overlay) {
      const keysArr = keys(source);
      for (let i = 0; i < keysArr.length; i++) {
        const key = keysArr[i];
        (overlay ? null != source[key] : null == target[key]) && (target[key] = source[key]);
      }
      return target;
    }
    function mixin(target, source) {
      let override = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !0;
      if (target = "prototype" in target ? target.prototype : target, source = "prototype" in source ? source.prototype : source, Object.getOwnPropertyNames) {
        const keyList = Object.getOwnPropertyNames(source);
        for (let i = 0; i < keyList.length; i++) {
          const key = keyList[i];
          "constructor" !== key && (override ? null != source[key] : null == target[key]) && (target[key] = source[key]);
        }
      } else defaults(target, source, override);
    }

    function range(start, stop, step) {
      isValid$1(stop) || (stop = start, start = 0), isValid$1(step) || (step = 1);
      let i = -1;
      const n = 0 | Math.max(0, Math.ceil((stop - start) / step)),
        range = new Array(n);
      for (; ++i < n;) range[i] = start + i * step;
      return range;
    }

    function ascending(a, b) {
      return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    }

    function toNumber(a) {
      return Number(a);
    }

    const hasConsole = "undefined" != typeof console;
    function log(method, level, input) {
      const args = [level].concat([].slice.call(input));
      hasConsole && console[method].apply(console, args);
    }
    var LoggerLevel;
    !function (LoggerLevel) {
      LoggerLevel[LoggerLevel.None = 0] = "None", LoggerLevel[LoggerLevel.Error = 1] = "Error", LoggerLevel[LoggerLevel.Warn = 2] = "Warn", LoggerLevel[LoggerLevel.Info = 3] = "Info", LoggerLevel[LoggerLevel.Debug = 4] = "Debug";
    }(LoggerLevel || (LoggerLevel = {}));
    class Logger {
      static getInstance(level, method) {
        return Logger._instance && isNumber$1(level) ? Logger._instance.level(level) : Logger._instance || (Logger._instance = new Logger(level, method)), Logger._instance;
      }
      static setInstance(logger) {
        return Logger._instance = logger;
      }
      static setInstanceLevel(level) {
        Logger._instance ? Logger._instance.level(level) : Logger._instance = new Logger(level);
      }
      static clearInstance() {
        Logger._instance = null;
      }
      constructor() {
        let level = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : LoggerLevel.None;
        let method = arguments.length > 1 ? arguments[1] : undefined;
        this._onErrorHandler = [], this._level = level, this._method = method;
      }
      addErrorHandler(handler) {
        this._onErrorHandler.find(h => h === handler) || this._onErrorHandler.push(handler);
      }
      removeErrorHandler(handler) {
        const index = this._onErrorHandler.findIndex(h => h === handler);
        index < 0 || this._onErrorHandler.splice(index, 1);
      }
      callErrorHandler() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        this._onErrorHandler.forEach(h => h(...args));
      }
      canLogInfo() {
        return this._level >= LoggerLevel.Info;
      }
      canLogDebug() {
        return this._level >= LoggerLevel.Debug;
      }
      canLogError() {
        return this._level >= LoggerLevel.Error;
      }
      canLogWarn() {
        return this._level >= LoggerLevel.Warn;
      }
      level(levelValue) {
        return arguments.length ? (this._level = +levelValue, this) : this._level;
      }
      error() {
        var _a;
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        return this._level >= LoggerLevel.Error && (this._onErrorHandler.length ? this.callErrorHandler(...args) : log(null !== (_a = this._method) && void 0 !== _a ? _a : "error", "ERROR", args)), this;
      }
      warn() {
        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }
        return this._level >= LoggerLevel.Warn && log(this._method || "warn", "WARN", args), this;
      }
      info() {
        for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          args[_key4] = arguments[_key4];
        }
        return this._level >= LoggerLevel.Info && log(this._method || "log", "INFO", args), this;
      }
      debug() {
        for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
          args[_key5] = arguments[_key5];
        }
        return this._level >= LoggerLevel.Debug && log(this._method || "log", "DEBUG", args), this;
      }
    }
    Logger._instance = null;

    function bisect(a, x) {
      let lo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      let hi = arguments.length > 3 ? arguments[3] : undefined;
      for (isNil$1(hi) && (hi = a.length); lo < hi;) {
        const mid = lo + hi >>> 1;
        ascending(a[mid], x) > 0 ? hi = mid : lo = mid + 1;
      }
      return lo;
    }

    const DEFAULT_ABSOLUTE_TOLERATE = 1e-10,
      DEFAULT_RELATIVE_TOLERATE = 1e-10;
    function isNumberClose(a, b) {
      let relTol = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_RELATIVE_TOLERATE;
      let absTol = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_ABSOLUTE_TOLERATE;
      const abs = absTol,
        rel = relTol * Math.max(a, b);
      return Math.abs(a - b) <= Math.max(abs, rel);
    }
    function isGreater(a, b, relTol, absTol) {
      return a > b && !isNumberClose(a, b, relTol, absTol);
    }
    function isLess(a, b, relTol, absTol) {
      return a < b && !isNumberClose(a, b, relTol, absTol);
    }

    const memoize = func => {
      let lastArgs = null,
        lastResult = null;
      return function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return lastArgs && args.every((val, i) => val === lastArgs[i]) || (lastArgs = args, lastResult = func(...args)), lastResult;
      };
    };

    const clamp = function (input, min, max) {
      return input < min ? min : input > max ? max : input;
    };
    var clamp$1 = clamp;

    function clamper(a, b) {
      let t;
      return a > b && (t = a, a = b, b = t), x => Math.max(a, Math.min(b, x));
    }

    function interpolateNumber(a, b) {
      return t => a * (1 - t) + b * t;
    }
    function interpolateNumberRound(a, b) {
      return function (t) {
        return Math.round(a * (1 - t) + b * t);
      };
    }
    function interpolateDate(a, b) {
      const aVal = a.valueOf(),
        bVal = b.valueOf(),
        d = new Date();
      return t => (d.setTime(aVal * (1 - t) + bVal * t), d);
    }

    function hslToRgb(h, s, l) {
      s /= 100, l /= 100;
      const c = (1 - Math.abs(2 * l - 1)) * s,
        x = c * (1 - Math.abs(h / 60 % 2 - 1)),
        m = l - c / 2;
      let r = 0,
        g = 0,
        b = 0;
      return 0 <= h && h < 60 ? (r = c, g = x, b = 0) : 60 <= h && h < 120 ? (r = x, g = c, b = 0) : 120 <= h && h < 180 ? (r = 0, g = c, b = x) : 180 <= h && h < 240 ? (r = 0, g = x, b = c) : 240 <= h && h < 300 ? (r = x, g = 0, b = c) : 300 <= h && h < 360 && (r = c, g = 0, b = x), r = Math.round(255 * (r + m)), g = Math.round(255 * (g + m)), b = Math.round(255 * (b + m)), {
        r: r,
        g: g,
        b: b
      };
    }

    function rgbToHsl(r, g, b) {
      r /= 255, g /= 255, b /= 255;
      const cMin = Math.min(r, g, b),
        cMax = Math.max(r, g, b),
        delta = cMax - cMin;
      let h = 0,
        s = 0,
        l = 0;
      return h = 0 === delta ? 0 : cMax === r ? (g - b) / delta % 6 : cMax === g ? (b - r) / delta + 2 : (r - g) / delta + 4, h = Math.round(60 * h), h < 0 && (h += 360), l = (cMax + cMin) / 2, s = 0 === delta ? 0 : delta / (1 - Math.abs(2 * l - 1)), s = +(100 * s).toFixed(1), l = +(100 * l).toFixed(1), {
        h: h,
        s: s,
        l: l
      };
    }

    const REG_HEX = /^#([0-9a-f]{3,8})$/,
      DEFAULT_COLORS_OPACITY = {
        transparent: 4294967040
      };
    const DEFAULT_COLORS = {
      aliceblue: 15792383,
      antiquewhite: 16444375,
      aqua: 65535,
      aquamarine: 8388564,
      azure: 15794175,
      beige: 16119260,
      bisque: 16770244,
      black: 0,
      blanchedalmond: 16772045,
      blue: 255,
      blueviolet: 9055202,
      brown: 10824234,
      burlywood: 14596231,
      cadetblue: 6266528,
      chartreuse: 8388352,
      chocolate: 13789470,
      coral: 16744272,
      cornflowerblue: 6591981,
      cornsilk: 16775388,
      crimson: 14423100,
      cyan: 65535,
      darkblue: 139,
      darkcyan: 35723,
      darkgoldenrod: 12092939,
      darkgray: 11119017,
      darkgreen: 25600,
      darkgrey: 11119017,
      darkkhaki: 12433259,
      darkmagenta: 9109643,
      darkolivegreen: 5597999,
      darkorange: 16747520,
      darkorchid: 10040012,
      darkred: 9109504,
      darksalmon: 15308410,
      darkseagreen: 9419919,
      darkslateblue: 4734347,
      darkslategray: 3100495,
      darkslategrey: 3100495,
      darkturquoise: 52945,
      darkviolet: 9699539,
      deeppink: 16716947,
      deepskyblue: 49151,
      dimgray: 6908265,
      dimgrey: 6908265,
      dodgerblue: 2003199,
      firebrick: 11674146,
      floralwhite: 16775920,
      forestgreen: 2263842,
      fuchsia: 16711935,
      gainsboro: 14474460,
      ghostwhite: 16316671,
      gold: 16766720,
      goldenrod: 14329120,
      gray: 8421504,
      green: 32768,
      greenyellow: 11403055,
      grey: 8421504,
      honeydew: 15794160,
      hotpink: 16738740,
      indianred: 13458524,
      indigo: 4915330,
      ivory: 16777200,
      khaki: 15787660,
      lavender: 15132410,
      lavenderblush: 16773365,
      lawngreen: 8190976,
      lemonchiffon: 16775885,
      lightblue: 11393254,
      lightcoral: 15761536,
      lightcyan: 14745599,
      lightgoldenrodyellow: 16448210,
      lightgray: 13882323,
      lightgreen: 9498256,
      lightgrey: 13882323,
      lightpink: 16758465,
      lightsalmon: 16752762,
      lightseagreen: 2142890,
      lightskyblue: 8900346,
      lightslategray: 7833753,
      lightslategrey: 7833753,
      lightsteelblue: 11584734,
      lightyellow: 16777184,
      lime: 65280,
      limegreen: 3329330,
      linen: 16445670,
      magenta: 16711935,
      maroon: 8388608,
      mediumaquamarine: 6737322,
      mediumblue: 205,
      mediumorchid: 12211667,
      mediumpurple: 9662683,
      mediumseagreen: 3978097,
      mediumslateblue: 8087790,
      mediumspringgreen: 64154,
      mediumturquoise: 4772300,
      mediumvioletred: 13047173,
      midnightblue: 1644912,
      mintcream: 16121850,
      mistyrose: 16770273,
      moccasin: 16770229,
      navajowhite: 16768685,
      navy: 128,
      oldlace: 16643558,
      olive: 8421376,
      olivedrab: 7048739,
      orange: 16753920,
      orangered: 16729344,
      orchid: 14315734,
      palegoldenrod: 15657130,
      palegreen: 10025880,
      paleturquoise: 11529966,
      palevioletred: 14381203,
      papayawhip: 16773077,
      peachpuff: 16767673,
      peru: 13468991,
      pink: 16761035,
      plum: 14524637,
      powderblue: 11591910,
      purple: 8388736,
      rebeccapurple: 6697881,
      red: 16711680,
      rosybrown: 12357519,
      royalblue: 4286945,
      saddlebrown: 9127187,
      salmon: 16416882,
      sandybrown: 16032864,
      seagreen: 3050327,
      seashell: 16774638,
      sienna: 10506797,
      silver: 12632256,
      skyblue: 8900331,
      slateblue: 6970061,
      slategray: 7372944,
      slategrey: 7372944,
      snow: 16775930,
      springgreen: 65407,
      steelblue: 4620980,
      tan: 13808780,
      teal: 32896,
      thistle: 14204888,
      tomato: 16737095,
      turquoise: 4251856,
      violet: 15631086,
      wheat: 16113331,
      white: 16777215,
      whitesmoke: 16119285,
      yellow: 16776960,
      yellowgreen: 10145074
    };
    function hex(value) {
      return ((value = Math.max(0, Math.min(255, Math.round(value) || 0))) < 16 ? "0" : "") + value.toString(16);
    }
    function rgb(value) {
      return isNumber$1(value) ? new RGB(value >> 16, value >> 8 & 255, 255 & value, 1) : isArray$1(value) ? new RGB(value[0], value[1], value[2]) : new RGB(255, 255, 255);
    }
    function rgba(value) {
      return isNumber$1(value) ? new RGB(value >>> 24, value >>> 16 & 255, value >>> 8 & 255, 255 & value) : isArray$1(value) ? new RGB(value[0], value[1], value[2], value[3]) : new RGB(255, 255, 255, 1);
    }
    function SRGBToLinear(c) {
      return c < .04045 ? .0773993808 * c : Math.pow(.9478672986 * c + .0521327014, 2.4);
    }
    function LinearToSRGB(c) {
      return c < .0031308 ? 12.92 * c : 1.055 * Math.pow(c, .41666) - .055;
    }
    const setHex = (formatValue, forceHex) => {
      const isHex = REG_HEX.exec(formatValue);
      if (forceHex || isHex) {
        const hex = parseInt(isHex[1], 16),
          hexLength = isHex[1].length;
        return 3 === hexLength ? new RGB((hex >> 8 & 15) + ((hex >> 8 & 15) << 4), (hex >> 4 & 15) + ((hex >> 4 & 15) << 4), (15 & hex) + ((15 & hex) << 4), 1) : 6 === hexLength ? rgb(hex) : 8 === hexLength ? new RGB(hex >> 24 & 255, hex >> 16 & 255, hex >> 8 & 255, (255 & hex) / 255) : null;
      }
    };
    class Color {
      static Brighter(source) {
        let b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
        return 1 === b ? source : new Color(source).brighter(b).toRGBA();
      }
      static SetOpacity(source) {
        let o = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
        return 1 === o ? source : new Color(source).setOpacity(o).toRGBA();
      }
      static getColorBrightness(source) {
        let model = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "hsl";
        const color = source instanceof Color ? source : new Color(source);
        switch (model) {
          case "hsv":
          default:
            return color.getHSVBrightness();
          case "hsl":
            return color.getHSLBrightness();
          case "lum":
            return color.getLuminance();
          case "lum2":
            return color.getLuminance2();
          case "lum3":
            return color.getLuminance3();
        }
      }
      static parseColorString(value) {
        if (isValid$1(DEFAULT_COLORS_OPACITY[value])) return rgba(DEFAULT_COLORS_OPACITY[value]);
        if (isValid$1(DEFAULT_COLORS[value])) return rgb(DEFAULT_COLORS[value]);
        const formatValue = `${value}`.trim().toLowerCase(),
          hexRes = setHex(formatValue);
        if (void 0 !== hexRes) return hexRes;
        if (/^(rgb|RGB|rgba|RGBA)/.test(formatValue)) {
          const aColor = formatValue.replace(/(?:\(|\)|rgba|RGBA|rgb|RGB)*/g, "").split(",");
          return new RGB(parseInt(aColor[0], 10), parseInt(aColor[1], 10), parseInt(aColor[2], 10), parseFloat(aColor[3]));
        }
        if (/^(hsl|HSL|hsla|HSLA)/.test(formatValue)) {
          const aColor = formatValue.replace(/(?:\(|\)|hsla|HSLA|hsl|HSL)*/g, "").split(","),
            rgb = hslToRgb(parseInt(aColor[0], 10), parseInt(aColor[1], 10), parseInt(aColor[2], 10));
          return new RGB(rgb.r, rgb.g, rgb.b, parseFloat(aColor[3]));
        }
      }
      constructor(value) {
        const color = Color.parseColorString(value);
        color ? this.color = color : (this.color = new RGB(255, 255, 255));
      }
      toRGBA() {
        return this.color.formatRgb();
      }
      toString() {
        return this.color.formatRgb();
      }
      toHex() {
        return this.color.formatHex();
      }
      toHsl() {
        return this.color.formatHsl();
      }
      brighter(k) {
        const {
          r: r,
          g: g,
          b: b
        } = this.color;
        return this.color.r = Math.max(0, Math.min(255, Math.floor(r * k))), this.color.g = Math.max(0, Math.min(255, Math.floor(g * k))), this.color.b = Math.max(0, Math.min(255, Math.floor(b * k))), this;
      }
      add(color) {
        const {
          r: r,
          g: g,
          b: b
        } = this.color;
        return this.color.r += Math.min(255, r + color.color.r), this.color.g += Math.min(255, g + color.color.g), this.color.b += Math.min(255, b + color.color.b), this;
      }
      sub(color) {
        return this.color.r = Math.max(0, this.color.r - color.color.r), this.color.g = Math.max(0, this.color.g - color.color.g), this.color.b = Math.max(0, this.color.b - color.color.b), this;
      }
      multiply(color) {
        const {
          r: r,
          g: g,
          b: b
        } = this.color;
        return this.color.r = Math.max(0, Math.min(255, Math.floor(r * color.color.r))), this.color.g = Math.max(0, Math.min(255, Math.floor(g * color.color.g))), this.color.b = Math.max(0, Math.min(255, Math.floor(b * color.color.b))), this;
      }
      getHSVBrightness() {
        return Math.max(this.color.r, this.color.g, this.color.b) / 255;
      }
      getHSLBrightness() {
        return .5 * (Math.max(this.color.r, this.color.g, this.color.b) / 255 + Math.min(this.color.r, this.color.g, this.color.b) / 255);
      }
      setHsl(h, s, l) {
        const opacity = this.color.opacity,
          hsl = rgbToHsl(this.color.r, this.color.g, this.color.b),
          rgb = hslToRgb(isNil$1(h) ? hsl.h : clamp$1(h, 0, 360), isNil$1(s) ? hsl.s : s >= 0 && s <= 1 ? 100 * s : s, isNil$1(l) ? hsl.l : l <= 1 && l >= 0 ? 100 * l : l);
        return this.color = new RGB(rgb.r, rgb.g, rgb.b, opacity), this;
      }
      setRGB(r, g, b) {
        return !isNil$1(r) && (this.color.r = r), !isNil$1(g) && (this.color.g = g), !isNil$1(b) && (this.color.b = b), this;
      }
      setHex(value) {
        const formatValue = `${value}`.trim().toLowerCase(),
          res = setHex(formatValue, !0);
        return null != res ? res : this;
      }
      setColorName(name) {
        const hex = DEFAULT_COLORS[name.toLowerCase()];
        return void 0 !== hex ? this.setHex(hex) : (void 0), this;
      }
      setScalar(scalar) {
        return this.color.r = scalar, this.color.g = scalar, this.color.b = scalar, this;
      }
      setOpacity() {
        let o = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
        return this.color.opacity = o, this;
      }
      getLuminance() {
        return (.2126 * this.color.r + .7152 * this.color.g + .0722 * this.color.b) / 255;
      }
      getLuminance2() {
        return (.2627 * this.color.r + .678 * this.color.g + .0593 * this.color.b) / 255;
      }
      getLuminance3() {
        return (.299 * this.color.r + .587 * this.color.g + .114 * this.color.b) / 255;
      }
      clone() {
        return new Color(this.color.toString());
      }
      copyGammaToLinear(color) {
        let gammaFactor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
        return this.color.r = Math.pow(color.color.r, gammaFactor), this.color.g = Math.pow(color.color.g, gammaFactor), this.color.b = Math.pow(color.color.b, gammaFactor), this;
      }
      copyLinearToGamma(color) {
        let gammaFactor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
        const safeInverse = gammaFactor > 0 ? 1 / gammaFactor : 1;
        return this.color.r = Math.pow(color.color.r, safeInverse), this.color.g = Math.pow(color.color.g, safeInverse), this.color.b = Math.pow(color.color.b, safeInverse), this;
      }
      convertGammaToLinear(gammaFactor) {
        return this.copyGammaToLinear(this, gammaFactor), this;
      }
      convertLinearToGamma(gammaFactor) {
        return this.copyLinearToGamma(this, gammaFactor), this;
      }
      copySRGBToLinear(color) {
        return this.color.r = SRGBToLinear(color.color.r), this.color.g = SRGBToLinear(color.color.g), this.color.b = SRGBToLinear(color.color.b), this;
      }
      copyLinearToSRGB(color) {
        return this.color.r = LinearToSRGB(color.color.r), this.color.g = LinearToSRGB(color.color.g), this.color.b = LinearToSRGB(color.color.b), this;
      }
      convertSRGBToLinear() {
        return this.copySRGBToLinear(this), this;
      }
      convertLinearToSRGB() {
        return this.copyLinearToSRGB(this), this;
      }
    }
    class RGB {
      constructor(r, g, b, opacity) {
        this.r = isNaN(+r) ? 255 : Math.max(0, Math.min(255, +r)), this.g = isNaN(+g) ? 255 : Math.max(0, Math.min(255, +g)), this.b = isNaN(+b) ? 255 : Math.max(0, Math.min(255, +b)), isValid$1(opacity) ? this.opacity = isNaN(+opacity) ? 1 : Math.max(0, Math.min(1, +opacity)) : this.opacity = 1;
      }
      formatHex() {
        return `#${hex(this.r) + hex(this.g) + hex(this.b) + (1 === this.opacity ? "" : hex(255 * this.opacity))}`;
      }
      formatRgb() {
        const opacity = this.opacity;
        return `${1 === opacity ? "rgb(" : "rgba("}${this.r},${this.g},${this.b}${1 === opacity ? ")" : `,${opacity})`}`;
      }
      formatHsl() {
        const opacity = this.opacity,
          {
            h: h,
            s: s,
            l: l
          } = rgbToHsl(this.r, this.g, this.b);
        return `${1 === opacity ? "hsl(" : "hsla("}${h},${s}%,${l}%${1 === opacity ? ")" : `,${opacity})`}`;
      }
      toString() {
        return this.formatHex();
      }
    }

    function hexToRgb(str) {
      let r = "",
        g = "",
        b = "";
      const strtIndex = "#" === str[0] ? 1 : 0;
      for (let i = strtIndex; i < str.length; i++) "#" !== str[i] && (i < strtIndex + 2 ? r += str[i] : i < strtIndex + 4 ? g += str[i] : i < strtIndex + 6 && (b += str[i]));
      return [parseInt(r, 16), parseInt(g, 16), parseInt(b, 16)];
    }

    function rgbToHex(r, g, b) {
      return Number((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    }

    function interpolateRgb$1(colorA, colorB) {
      const redA = colorA.r,
        redB = colorB.r,
        greenA = colorA.g,
        greenB = colorB.g,
        blueA = colorA.b,
        blueB = colorB.b,
        opacityA = colorA.opacity,
        opacityB = colorB.opacity;
      return t => {
        const r = Math.round(redA * (1 - t) + redB * t),
          g = Math.round(greenA * (1 - t) + greenB * t),
          b = Math.round(blueA * (1 - t) + blueB * t);
        return new RGB(r, g, b, opacityA * (1 - t) + opacityB * t);
      };
    }

    var ColorUtil = /*#__PURE__*/Object.freeze({
        __proto__: null,
        Color: Color,
        DEFAULT_COLORS: DEFAULT_COLORS,
        RGB: RGB,
        hexToRgb: hexToRgb,
        hslToRgb: hslToRgb,
        interpolateRgb: interpolateRgb$1,
        rgbToHex: rgbToHex,
        rgbToHsl: rgbToHsl
    });

    function isHTMLElement(obj) {
      try {
        return obj instanceof Element;
      } catch (_a) {
        const htmlElementKeys = ["children", "innerHTML", "classList", "setAttribute", "tagName", "getBoundingClientRect"],
          keys = Object.keys(obj);
        return htmlElementKeys.every(key => keys.includes(key));
      }
    }

    const fields = (data, options) => {
      var _a, _b;
      if (!(null == options ? void 0 : options.fields)) return data;
      if (0 === data.length) return data;
      const fields = options.fields,
        dataTemp = data[0],
        filterFields = {},
        sortFields = [];
      for (const key in fields) if (Object.prototype.hasOwnProperty.call(fields, key)) {
        const fieldInfo = fields[key];
        if (!fieldInfo.type) {
          let dataCheck = dataTemp;
          key in dataTemp || (dataCheck = null !== (_a = data.find(d => key in d)) && void 0 !== _a ? _a : dataTemp), fieldInfo.type = "number" == typeof dataCheck[key] ? "linear" : "ordinal";
        }
        let sortInfo;
        if ("number" == typeof fieldInfo.sortIndex && (sortInfo = {
          key: key,
          type: fieldInfo.type,
          index: fieldInfo.sortIndex,
          sortIndex: {},
          sortIndexCount: 0,
          sortReverse: !0 === fieldInfo.sortReverse
        }, sortFields.push(sortInfo)), (null === (_b = fieldInfo.domain) || void 0 === _b ? void 0 : _b.length) > 0) if ("ordinal" === fieldInfo.type) {
          fieldInfo._domainCache = {}, filterFields[key] = fieldInfo;
          const _domainCache = {};
          fieldInfo.domain.forEach((d, i) => {
            _domainCache[d] = i, fieldInfo._domainCache[d] = i;
          }), sortInfo && (sortInfo.sortIndex = _domainCache, sortInfo.sortIndexCount = fieldInfo.domain.length);
        } else fieldInfo.domain.length >= 2 && (filterFields[key] = fieldInfo);
      }
      return Object.keys(filterFields).length > 0 && (data = data.filter(d => {
        for (const key in filterFields) {
          const fieldInfo = filterFields[key];
          if ("ordinal" === fieldInfo.type) {
            if (!(d[key] in fieldInfo._domainCache)) return !1;
          } else if (fieldInfo.domain[0] > d[key] || fieldInfo.domain[1] < d[key]) return !1;
        }
        return !0;
      })), sortFields.sort((a, b) => a.index - b.index), data.sort((a, b) => sortData(a, b, sortFields)), data;
    };
    function sortData(a, b, sortFields) {
      for (let i = 0; i < sortFields.length; i++) {
        const sortInfo = sortFields[i];
        let v = 0;
        if ("ordinal" === sortInfo.type ? (void 0 === sortInfo.sortIndex[b[sortInfo.key]] && (sortInfo.sortIndex[b[sortInfo.key]] = sortInfo.sortIndexCount++), void 0 === sortInfo.sortIndex[a[sortInfo.key]] && (sortInfo.sortIndex[a[sortInfo.key]] = sortInfo.sortIndexCount++), v = sortInfo.sortIndex[a[sortInfo.key]] - sortInfo.sortIndex[b[sortInfo.key]]) : "linear" === sortInfo.type && (v = a[sortInfo.key] - b[sortInfo.key]), sortInfo.sortReverse && (v = -v), 0 !== v) return v;
      }
      return 0;
    }

    let idIndex = 0;
    const maxId = 1e8;
    function getUUID() {
      let prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "dataset";
      return idIndex > maxId && (idIndex = 0), prefix + "_" + idIndex++;
    }

    class DataSet {
      constructor(options) {
        var _a;
        let name;
        this.options = options, this.isDataSet = !0, this.transformMap = {}, this.parserMap = {}, this.dataViewMap = {}, this.target = new EventEmitter(), name = (null == options ? void 0 : options.name) ? options.name : getUUID("dataset"), this.name = name, this._logger = null !== (_a = null == options ? void 0 : options.logger) && void 0 !== _a ? _a : Logger.getInstance();
      }
      setLogger(logger) {
        this._logger = logger;
      }
      getDataView(name) {
        return this.dataViewMap[name];
      }
      setDataView(name, dataView) {
        var _a;
        this.dataViewMap[name] && (null === (_a = this._logger) || void 0 === _a || _a.error(`Error: dataView ${name} 之前已存在，请重新命名`)), this.dataViewMap[name] = dataView;
      }
      removeDataView(name) {
        this.dataViewMap[name] = null, delete this.dataViewMap[name];
      }
      registerParser(name, parser) {
        var _a;
        this.parserMap[name] && (null === (_a = this._logger) || void 0 === _a || _a.warn(`Warn: transform ${name} 之前已注册，执行覆盖逻辑`)), this.parserMap[name] = parser;
      }
      removeParser(name) {
        this.parserMap[name] = null, delete this.parserMap[name];
      }
      getParser(name) {
        return this.parserMap[name] || this.parserMap.default;
      }
      registerTransform(name, transform) {
        var _a;
        this.transformMap[name] && (null === (_a = this._logger) || void 0 === _a || _a.warn(`Warn: transform ${name} 之前已注册，执行覆盖逻辑`)), this.transformMap[name] = transform;
      }
      removeTransform(name) {
        this.transformMap[name] = null, delete this.transformMap[name];
      }
      getTransform(name) {
        return this.transformMap[name];
      }
      multipleDataViewAddListener(list, event, call) {
        this._callMap || (this._callMap = new Map());
        let callAd = this._callMap.get(call);
        callAd || (callAd = () => {
          list.some(l => l.isRunning) || call();
        }), list.forEach(l => {
          l.target.addListener(event, callAd);
        }), this._callMap.set(call, callAd);
      }
      allDataViewAddListener(event, call) {
        this.multipleDataViewAddListener(Object.values(this.dataViewMap), event, call);
      }
      multipleDataViewRemoveListener(list, event, call) {
        if (this._callMap) {
          const callAd = this._callMap.get(call);
          callAd && list.forEach(l => {
            l.target.removeListener(event, callAd);
          }), this._callMap.delete(call);
        }
      }
      multipleDataViewUpdateInParse(newData) {
        newData.forEach(d => {
          var _a;
          return null === (_a = this.getDataView(d.name)) || void 0 === _a ? void 0 : _a.markRunning();
        }), newData.forEach(d => {
          var _a;
          return null === (_a = this.getDataView(d.name)) || void 0 === _a ? void 0 : _a.parseNewData(d.data, d.options);
        });
      }
      multipleDataViewUpdateInRawData(newData) {
        newData.forEach(d => {
          var _a;
          return null === (_a = this.getDataView(d.name)) || void 0 === _a ? void 0 : _a.markRunning();
        }), newData.forEach(d => {
          var _a;
          return null === (_a = this.getDataView(d.name)) || void 0 === _a ? void 0 : _a.updateRawData(d.data, d.options);
        });
      }
      destroy() {
        this.transformMap = null, this.parserMap = null, this.dataViewMap = null, this._callMap = null, this.target.removeAllListeners();
      }
    }

    const DataViewDiffRank = "_data-view-diff-rank";
    class DataView {
      constructor(dataSet, options) {
        var _this = this;
        let name;
        this.dataSet = dataSet, this.options = options, this.isDataView = !0, this.target = new EventEmitter(), this.parseOption = null, this.transformsArr = [], this.isRunning = !1, this.rawData = {}, this.history = !1, this.parserData = {}, this.latestData = {}, this._fields = null, this.reRunAllTransform = function () {
          let opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
            pushHistory: !0,
            emitMessage: !0
          };
          return _this.isRunning = !0, _this.resetTransformData(), _this.transformsArr.forEach(t => {
            _this.executeTransform(t, {
              pushHistory: opt.pushHistory,
              emitMessage: !1
            }), _this.isLastTransform(t) && _this.diffLastData();
          }), _this.isRunning = !1, !1 !== opt.emitMessage && _this.target.emit("change", []), _this;
        }, this.markRunning = () => {
          this.isRunning = !0, this.target.emit("markRunning", []);
        }, name = (null == options ? void 0 : options.name) ? options.name : getUUID("dataview"), this.name = name, (null == options ? void 0 : options.history) && (this.history = options.history, this.historyData = []), this.dataSet.setDataView(name, this), this.setFields(null == options ? void 0 : options.fields);
      }
      parse(data, options) {
        let emit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
        var _a;
        this.isRunning = !0, emit && this.target.emit("beforeParse", []), options && (this.parseOption = options);
        const cloneData = this.cloneParseData(data, options);
        if (null == options ? void 0 : options.type) {
          const parserData = (null !== (_a = this.dataSet.getParser(options.type)) && void 0 !== _a ? _a : this.dataSet.getParser("bytejson"))(cloneData, options.options, this);
          this.rawData = cloneData, this.parserData = parserData, this.history && this.historyData.push(cloneData, parserData), this.latestData = parserData;
        } else this.parserData = cloneData, this.rawData = cloneData, this.history && this.historyData.push(cloneData), this.latestData = cloneData;
        return this.isRunning = !1, emit && this.target.emit("afterParse", []), this;
      }
      transform(options) {
        let execute = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
        if (this.isRunning = !0, options && options.type) {
          let pushOption = !0;
          if ("fields" === options.type) {
            this._fields = options.options.fields;
            const index = this.transformsArr.findIndex(_op => _op.type === options.type);
            index >= 0 && (pushOption = !1, this.transformsArr[index].options.fields = this._fields);
          }
          if (pushOption && this.transformsArr.push(options), execute) {
            const lastTag = this.isLastTransform(options);
            this.executeTransform(options), lastTag && this.diffLastData();
          }
        }
        return this.sortTransform(), this.isRunning = !1, this;
      }
      isLastTransform(options) {
        return this.transformsArr[this.transformsArr.length - 1] === options;
      }
      sortTransform() {
        this.transformsArr.length >= 2 && this.transformsArr.sort((a, b) => {
          var _a, _b;
          return (null !== (_a = a.level) && void 0 !== _a ? _a : 0) - (null !== (_b = b.level) && void 0 !== _b ? _b : 0);
        });
      }
      executeTransform(options) {
        let opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
          pushHistory: !0,
          emitMessage: !0
        };
        const {
            pushHistory: pushHistory,
            emitMessage: emitMessage
          } = opt,
          transformData = this.dataSet.getTransform(options.type)(this.latestData, options.options);
        this.history && !1 !== pushHistory && this.historyData.push(transformData), this.latestData = transformData, !1 !== emitMessage && this.target.emit("change", []);
      }
      resetTransformData() {
        this.latestData = this.parserData, this.history && (this.historyData.length = 0, this.historyData.push(this.rawData, this.parserData));
      }
      enableDiff(keys) {
        this._diffData = !0, this._diffKeys = keys, this._diffMap = new Map(), this._diffRank = 0;
      }
      disableDiff() {
        this._diffData = !1, this._diffMap = null, this._diffRank = null;
      }
      resetDiff() {
        this._diffMap = new Map(), this._diffRank = 0;
      }
      diffLastData() {
        var _a;
        if (!this._diffData) return;
        if (!this.latestData.forEach) return;
        if (!(null === (_a = this._diffKeys) || void 0 === _a ? void 0 : _a.length)) return;
        const next = this._diffRank + 1;
        if (0 === this._diffRank) this.latestData.forEach(d => {
          d[DataViewDiffRank] = next, this._diffMap.set(this._diffKeys.reduce((pre, k) => pre + d[k], ""), d);
        }), this.latestDataAUD = {
          add: Array.from(this.latestData),
          del: [],
          update: []
        };else {
          let tempKey;
          this.latestDataAUD = {
            add: [],
            del: [],
            update: []
          }, this.latestData.forEach(d => {
            d[DataViewDiffRank] = next, tempKey = this._diffKeys.reduce((pre, k) => pre + d[k], ""), this._diffMap.get(tempKey) ? this.latestDataAUD.update.push(d) : this.latestDataAUD.add.push(d), this._diffMap.set(tempKey, d);
          }), this._diffMap.forEach((v, k) => {
            v[DataViewDiffRank] < next && (this.latestDataAUD.del.push(v), this._diffMap.delete(k));
          });
        }
        this._diffRank = next;
      }
      cloneParseData(data, options) {
        let clone = !1;
        return data instanceof DataView || !0 !== (null == options ? void 0 : options.clone) || (clone = !0), clone ? cloneDeep(data) : data;
      }
      parseNewData(data, options) {
        this.parse(data, options || this.parseOption), this.reRunAllTransform();
      }
      updateRawData(data, options) {
        const cloneData = this.cloneParseData(data, options);
        this.rawData = cloneData, this.parserData = cloneData, this.latestData = cloneData, this.reRunAllTransform();
      }
      getFields() {
        var _a;
        return this._fields ? this._fields : "dataview" === (null === (_a = this.parseOption) || void 0 === _a ? void 0 : _a.type) && 1 === this.rawData.length && this.rawData[0].getFields ? this.rawData[0].getFields() : null;
      }
      setFields(f) {
        let foreMerge = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
        this._fields = f && foreMerge ? merge({}, this._fields, f) : f;
        const fieldsOption = this.transformsArr.find(_op => "fields" === _op.type);
        !isNil$1(this._fields) && isNil$1(fieldsOption) ? (this.dataSet.registerTransform("fields", fields), this.transform({
          type: "fields",
          options: {
            fields: this._fields
          }
        }, !1)) : fieldsOption && (fieldsOption.options.fields = this._fields);
      }
      destroy() {
        this.dataSet.removeDataView(this.name), this._diffMap = null, this._diffRank = null, this.latestData = null, this.rawData = null, this.parserData = null, this.transformsArr = null, this.target = null;
      }
    }
    function isDataView(obj) {
      return obj instanceof DataView;
    }

    function cloneDeepSpec(spec) {
      let excludeKeys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ["data"];
      const value = spec;
      let result;
      if (!isValid$1(value) || "object" != typeof value) return value;
      if (isDataView(value) || isHTMLElement(value)) return value;
      const isArr = isArray$1(value),
        length = value.length;
      result = isArr ? new Array(length) : "object" == typeof value ? {} : isBoolean$1(value) || isNumber$1(value) || isString$1(value) ? value : isDate$1(value) ? new Date(+value) : void 0;
      const props = isArr ? void 0 : Object.keys(Object(value));
      let index = -1;
      if (result) for (; ++index < (props || value).length;) {
        const key = props ? props[index] : index,
          subValue = value[key];
        (null == excludeKeys ? void 0 : excludeKeys.includes(key.toString())) ? result[key] = subValue : result[key] = cloneDeepSpec(subValue, excludeKeys);
      }
      return result;
    }

    function transformLegendTitleAttributes(title) {
        const transformedTitle = {
            ...title
        };
        if (!isEmpty(title.style)) {
            transformedTitle.textStyle = transformToGraphic(title.style);
        }
        if (!isEmpty(title.textStyle)) {
            merge$1(transformedTitle.textStyle, transformToGraphic(title.textStyle));
        }
        if (title.shape?.style) {
            transformToGraphic(transformedTitle.shape.style);
        }
        if (title.background?.style) {
            transformToGraphic(transformedTitle.background.style);
        }
        return transformedTitle;
    }
    function transformToGraphic(style) {
        if (isEmpty(style)) {
            return style;
        }
        if (style.angle) {
            style.angle = degreeToRadian(style.angle);
        }
        return style;
    }
    function transformComponentStyle(cfg = {}) {
        if (!isEmpty(cfg.style)) {
            cfg.style = transformToGraphic(cfg.style);
        }
        if (!isEmpty(cfg.state)) {
            Object.keys(cfg.state).forEach(key => {
                if (!isEmpty(cfg.state[key])) {
                    cfg.state[key] = transformToGraphic(cfg.state[key]);
                }
            });
        }
        return cfg;
    }
    function transformStateStyle(stateStyle) {
        if (isEmpty(stateStyle)) {
            return null;
        }
        Object.keys(stateStyle).forEach(key => {
            if (!isEmpty(stateStyle[key])) {
                stateStyle[key] = transformToGraphic(stateStyle[key]);
            }
        });
        return stateStyle;
    }
    function transformAxisLineStyle(lineCfg) {
        transformComponentStyle(lineCfg);
        transformComponentStyle(lineCfg.startSymbol);
        transformComponentStyle(lineCfg.endSymbol);
        return lineCfg;
    }

    const DEFAULT_TITLE_STYLE = {
        left: {
            textAlign: 'center',
            textBaseline: 'bottom'
        },
        right: {
            textAlign: 'center',
            textBaseline: 'bottom'
        },
        radius: {},
        angle: {}
    };
    const DEFAULT_TEXT_FONT_FAMILY = 'PingFang SC,Microsoft Yahei,system-ui,-apple-system,segoe ui,Roboto,Helvetica,Arial,sans-serif, apple color emoji,segoe ui emoji,segoe ui symbol';
    const DEFAULT_TEXT_FONT_SIZE = 14;
    const THEME_CONSTANTS = {
        FONT_FAMILY: DEFAULT_TEXT_FONT_FAMILY,
        LABEL_FONT_SIZE: DEFAULT_TEXT_FONT_SIZE,
        MAP_LABEL_FONT_SIZE: 10,
        TITLE_FONT_SIZE: 18,
        AXIS_TICK_SIZE: 4
    };
    const commonAxis = {
        domainLine: {
            visible: true,
            style: {
                lineWidth: 1,
                stroke: '#D9DDE4',
                strokeOpacity: 1
            }
        },
        grid: {
            visible: true,
            style: {
                lineWidth: 1,
                stroke: '#EBEDF2',
                strokeOpacity: 1,
                lineDash: []
            }
        },
        subGrid: {
            visible: false,
            style: {
                lineWidth: 1,
                stroke: '#EBEDF2',
                strokeOpacity: 1,
                lineDash: [4, 4]
            }
        },
        tick: {
            visible: true,
            tickSize: THEME_CONSTANTS.AXIS_TICK_SIZE,
            style: {
                lineWidth: 1,
                stroke: '#D9DDE4',
                strokeOpacity: 1
            }
        },
        subTick: {
            visible: false,
            tickSize: THEME_CONSTANTS.AXIS_TICK_SIZE / 2,
            style: {
                lineWidth: 1,
                stroke: '#D9DDE4',
                strokeOpacity: 1
            }
        },
        label: {
            visible: true,
            space: 1,
            style: {
                fontSize: THEME_CONSTANTS.LABEL_FONT_SIZE,
                fill: '#89909D',
                fontWeight: 'normal',
                fillOpacity: 1
            },
            autoLimit: true
        },
        title: {
            space: 10,
            style: {
                fontSize: THEME_CONSTANTS.LABEL_FONT_SIZE,
                fill: '#333333',
                fontWeight: 'normal',
                fillOpacity: 1
            }
        }
    };
    function getCommonAxis(theme) {
        if (!theme?.colorScheme?.default?.palette) {
            return commonAxis;
        }
        return merge$1({}, commonAxis, {
            tick: {
                style: {
                    stroke: theme.colorScheme.default.palette.axisDomainColor || '#D9DDE4'
                }
            },
            subTick: {
                style: {
                    stroke: theme.colorScheme.default.palette.axisDomainColor || '#D9DDE4'
                }
            },
            label: {
                style: {
                    fill: theme.colorScheme.default.palette.axisLabelFontColor || '#89909D'
                }
            },
            title: {
                style: {
                    fill: theme.colorScheme.default.palette.secondaryFontColor || '#333333'
                }
            }
        });
    }
    function getAxisAttributes(option) {
        const spec = merge$1({}, option);
        let titleAngle = spec.title?.angle ?? 0;
        let titleTextStyle;
        if (spec.orient === 'left' || spec.orient === 'right') {
            if (spec.title?.autoRotate && isNil$3(spec.title.angle)) {
                titleAngle = spec.orient === 'left' ? -90 : 90;
                titleTextStyle = DEFAULT_TITLE_STYLE[spec.orient];
            }
        }
        const labelSpec = pickWithout(spec.label, ['style', 'formatMethod', 'state']);
        return {
            orient: spec.orient,
            select: spec.select,
            hover: spec.hover,
            line: transformAxisLineStyle(spec.domainLine),
            label: {
                style: transformToGraphic(spec.label.style),
                formatMethod: spec.label.formatMethod
                    ? (value, datum, index) => {
                        return spec.label.formatMethod(datum.rawValue, datum);
                    }
                    : null,
                state: transformStateStyle(spec.label.state),
                ...labelSpec
            },
            tick: {
                visible: spec.tick.visible,
                length: spec.tick.tickSize,
                inside: spec.tick.inside,
                alignWithLabel: spec.tick.alignWithLabel,
                style: transformToGraphic(spec.tick.style),
                state: transformStateStyle(spec.tick.state),
                dataFilter: spec.tick.dataFilter
            },
            subTick: {
                visible: spec.subTick.visible,
                length: spec.subTick.tickSize,
                inside: spec.subTick.inside,
                count: spec.subTick.tickCount,
                style: transformToGraphic(spec.subTick.style),
                state: transformStateStyle(spec.subTick.state)
            },
            grid: {
                type: 'line',
                visible: spec.grid.visible,
                alternateColor: spec.grid.alternateColor,
                alignWithLabel: spec.grid.alignWithLabel,
                style: transformToGraphic(spec.grid.style)
            },
            subGrid: {
                type: 'line',
                visible: spec.subGrid.visible,
                alternateColor: spec.subGrid.alternateColor,
                style: transformToGraphic(spec.subGrid.style)
            },
            title: {
                visible: spec.title.visible,
                position: spec.title.position,
                space: spec.title.space,
                autoRotate: false,
                angle: titleAngle ? degreeToRadian(titleAngle) : null,
                textStyle: merge$1({}, titleTextStyle, transformToGraphic(spec.title.style)),
                padding: spec.title.padding,
                shape: {
                    visible: spec.title.shape?.visible,
                    space: spec.title.shape?.space,
                    style: transformToGraphic(spec.title.shape?.style)
                },
                background: {
                    visible: spec.title.background?.visible,
                    style: transformToGraphic(spec.title.background?.style)
                },
                state: {
                    text: transformStateStyle(spec.title.state),
                    shape: transformStateStyle(spec.title.shape?.state),
                    background: transformStateStyle(spec.title.background?.state)
                }
            },
            panel: {
                visible: spec.background?.visible,
                style: transformToGraphic(spec.background?.style),
                state: transformStateStyle(spec.background?.state)
            }
        };
    }

    const NO_AXISID_FRO_VTABLE = 'NO_AXISID_FRO_VTABLE';
    function getRawChartSpec(col, row, layout) {
        const paths = layout.getCellHeaderPaths(col, row);
        let indicatorObj;
        if (layout.indicatorsAsCol) {
            const indicatorKey = paths.colHeaderPaths.find(colPath => colPath.indicatorKey)?.indicatorKey;
            indicatorObj = layout.columnObjects.find(indicator => indicator.indicatorKey === indicatorKey);
        }
        else {
            const indicatorKey = paths.rowHeaderPaths.find(rowPath => rowPath.indicatorKey)?.indicatorKey;
            indicatorObj = layout.columnObjects.find(indicator => indicator.indicatorKey === indicatorKey);
        }
        const chartSpec = indicatorObj?.chartSpec;
        if (typeof chartSpec === 'function') {
            const arg = {
                col,
                row,
                dataValue: layout._table.getCellOriginValue(col, row) || '',
                value: layout._table.getCellValue(col, row) || '',
                rect: layout._table.getCellRangeRelativeRect(layout._table.getCellRange(col, row)),
                table: layout._table
            };
            return chartSpec(arg);
        }
        return chartSpec;
    }
    function isShareChartSpec(col, row, layout) {
        const paths = layout.getCellHeaderPaths(col, row);
        let indicatorObj;
        if (layout.indicatorsAsCol) {
            const indicatorKey = paths.colHeaderPaths.find(colPath => colPath.indicatorKey)?.indicatorKey;
            indicatorObj = layout.columnObjects.find(indicator => indicator.indicatorKey === indicatorKey);
        }
        else {
            const indicatorKey = paths.rowHeaderPaths.find(rowPath => rowPath.indicatorKey)?.indicatorKey;
            indicatorObj = layout.columnObjects.find(indicator => indicator.indicatorKey === indicatorKey);
        }
        const chartSpec = indicatorObj?.chartSpec;
        if (typeof chartSpec === 'function') {
            return false;
        }
        return true;
    }
    function isNoChartDataRenderNothing(col, row, layout) {
        const paths = layout.getCellHeaderPaths(col, row);
        let indicatorObj;
        if (layout.indicatorsAsCol) {
            const indicatorKey = paths.colHeaderPaths.find(colPath => colPath.indicatorKey)?.indicatorKey;
            indicatorObj = layout.columnObjects.find(indicator => indicator.indicatorKey === indicatorKey);
        }
        else {
            const indicatorKey = paths.rowHeaderPaths.find(rowPath => rowPath.indicatorKey)?.indicatorKey;
            indicatorObj = layout.columnObjects.find(indicator => indicator.indicatorKey === indicatorKey);
        }
        const noDataRenderNothing = indicatorObj?.noDataRenderNothing;
        return noDataRenderNothing;
    }
    function checkHasCartesianChart(indicatorsDefine) {
        let isHasCartesianChart = false;
        for (let i = 0; i < indicatorsDefine.length; i++) {
            const columnObj = indicatorsDefine[i];
            if (columnObj.chartSpec) {
                if (columnObj.chartSpec.type !== 'wordCloud' &&
                    columnObj.chartSpec.type !== 'radar' &&
                    columnObj.chartSpec.type !== 'gauge' &&
                    columnObj.chartSpec.type !== 'pie' &&
                    columnObj.chartSpec.type !== 'funnel' &&
                    columnObj.chartSpec.type !== 'rose') {
                    isHasCartesianChart = true;
                    break;
                }
            }
        }
        return isHasCartesianChart;
    }
    function isCartesianChart(col, row, layout) {
        let isHasCartesianChart = true;
        const chartSpec = layout.getRawChartSpec(col, row);
        if (chartSpec) {
            if (chartSpec.type === 'pie' ||
                chartSpec.type === 'radar' ||
                chartSpec.type === 'gauge' ||
                chartSpec.type === 'wordCloud' ||
                chartSpec.type === 'funnel' ||
                chartSpec.type === 'rose') {
                isHasCartesianChart = false;
            }
        }
        else {
            isHasCartesianChart = false;
        }
        return isHasCartesianChart;
    }
    function isHasCartesianChartInline(col, row, checkDirection, layout) {
        let isHasCartesianChart = false;
        if ((layout.indicatorsAsCol && checkDirection === 'row') || (!layout.indicatorsAsCol && checkDirection === 'col')) {
            for (let i = 0; i < layout.indicatorsDefine.length; i++) {
                const columnObj = layout.indicatorsDefine[i];
                if (columnObj.chartSpec) {
                    if (columnObj.chartSpec.type !== 'pie' &&
                        columnObj.chartSpec.type !== 'wordCloud' &&
                        columnObj.chartSpec.type !== 'radar' &&
                        columnObj.chartSpec.type !== 'gauge' &&
                        columnObj.chartSpec.type !== 'funnel' &&
                        columnObj.chartSpec.type !== 'rose') {
                        isHasCartesianChart = true;
                        break;
                    }
                }
            }
        }
        else {
            const chartSpec = layout.getRawChartSpec(col, row);
            if (chartSpec) {
                if (chartSpec.type !== 'pie' &&
                    chartSpec.type !== 'radar' &&
                    chartSpec.type !== 'gauge' &&
                    chartSpec.type !== 'wordCloud' &&
                    chartSpec.type !== 'funnel' &&
                    chartSpec.type !== 'rose') {
                    isHasCartesianChart = true;
                }
            }
            else {
                isHasCartesianChart = false;
            }
        }
        return isHasCartesianChart;
    }
    function getChartSpec(col, row, layout) {
        let chartSpec = layout.getRawChartSpec(col, row);
        if (chartSpec) {
            if (layout._table.isPivotChart()) {
                chartSpec = cloneDeepSpec(chartSpec);
                chartSpec.sortDataByAxis = true;
                if (isArray$7(chartSpec.series)) {
                    chartSpec.series.forEach((serie) => {
                        serie.sortDataByAxis = true;
                    });
                }
                if (chartSpec.type !== 'gauge' && chartSpec.type !== 'rose' && chartSpec.type !== 'radar') {
                    chartSpec.axes = layout.getChartAxes(col, row);
                }
                chartSpec.padding = 0;
                chartSpec.dataZoom = [];
                return chartSpec;
            }
            return chartSpec;
        }
        return null;
    }
    function getChartAxes(col, row, layout) {
        const axes = [];
        if (layout.indicatorsAsCol) {
            const indicatorKeys = layout.getIndicatorKeyInChartSpec(col, row);
            const colPath = layout.getColKeysPath(col, row);
            indicatorKeys.forEach((key, index) => {
                const { range, targetTicks, targetRange, axisOption } = getAxisRangeAndTicks(col, row, index, index === 0 ? 'bottom' : 'top', index === 0 ? 'top' : 'bottom', indicatorKeys, colPath, layout);
                if (isNumber$4(axisOption?.min)) {
                    range.min = axisOption.min;
                }
                if (isNumber$4(axisOption?.max)) {
                    range.max = axisOption.max;
                }
                if (hasSameAxis(axisOption, axes)) {
                    return;
                }
                axes.push(merge$1({
                    range,
                    label: { style: { fontSize: DEFAULT_TEXT_FONT_SIZE } }
                }, axisOption, {
                    type: axisOption?.type || 'linear',
                    orient: index === 0 ? 'bottom' : 'top',
                    label: { visible: false, flush: true },
                    title: { visible: false },
                    domainLine: { visible: false },
                    seriesIndex: axisOption?.seriesId ? undefined : index,
                    tick: {
                        tickMode: getTickModeFunction(targetTicks, targetRange, range, index)
                    },
                    sync: { axisId: NO_AXISID_FRO_VTABLE }
                }));
            });
            let rowDimensionKey = layout.getDimensionKeyInChartSpec(layout.rowHeaderLevelCount, row);
            if (isArray$7(rowDimensionKey)) {
                rowDimensionKey = rowDimensionKey[0];
            }
            const data = layout.dataset.cacheCollectedValues[rowDimensionKey] ||
                layout.dataset.collectedValues[rowDimensionKey] ||
                [];
            const rowPath = layout.getRowKeysPath(col, row);
            const domain = data[rowPath ?? ''];
            const { axisOption, isPercent, chartType } = getAxisOption(col, row, 'left', layout);
            axes.push(merge$1({
                domain: axisOption?.type === 'linear' && !Array.isArray(domain) ? undefined : Array.from(domain ?? []),
                range: axisOption?.type === 'linear' && !Array.isArray(domain) ? domain : undefined,
                label: { style: { fontSize: DEFAULT_TEXT_FONT_SIZE } }
            }, axisOption, {
                type: axisOption?.type ?? 'band',
                orient: 'left',
                label: { visible: false },
                domainLine: { visible: false },
                tick: { visible: false },
                subTick: { visible: false },
                title: { visible: false }
            }));
        }
        else {
            const indicatorKeys = layout.getIndicatorKeyInChartSpec(col, row);
            const rowPath = layout.getRowKeysPath(col, row);
            indicatorKeys.forEach((key, index) => {
                const { range, targetTicks, targetRange, axisOption } = getAxisRangeAndTicks(col, row, index, index === 0 ? 'left' : 'right', index === 0 ? 'right' : 'left', indicatorKeys, rowPath, layout);
                if (isNumber$4(axisOption?.min)) {
                    range.min = axisOption.min;
                }
                if (isNumber$4(axisOption?.max)) {
                    range.max = axisOption.max;
                }
                if (hasSameAxis(axisOption, axes)) {
                    return;
                }
                axes.push(merge$1({
                    range,
                    label: { style: { fontSize: DEFAULT_TEXT_FONT_SIZE } }
                }, axisOption, {
                    type: axisOption?.type || 'linear',
                    orient: index === 0 ? 'left' : 'right',
                    label: { visible: false, flush: true },
                    title: { visible: false },
                    domainLine: { visible: false },
                    seriesIndex: axisOption?.seriesId ? undefined : index,
                    tick: {
                        tickMode: getTickModeFunction(targetTicks, targetRange, range, index)
                    },
                    sync: { axisId: NO_AXISID_FRO_VTABLE }
                }));
            });
            let columnDimensionKey = layout.getDimensionKeyInChartSpec(col, layout.columnHeaderLevelCount);
            if (isArray$7(columnDimensionKey)) {
                columnDimensionKey = columnDimensionKey[0];
            }
            const data = layout.dataset.cacheCollectedValues[columnDimensionKey] ||
                layout.dataset.collectedValues[columnDimensionKey] ||
                [];
            const colPath = layout.getColKeysPath(col, row);
            const domain = data?.[colPath ?? ''] ?? [];
            const { axisOption, isPercent, chartType } = getAxisOption(col, row, 'bottom', layout);
            axes.push(merge$1({
                domain: axisOption?.type === 'linear' && !Array.isArray(domain) ? undefined : Array.from(domain ?? []),
                range: axisOption?.type === 'linear' && !Array.isArray(domain) ? domain : undefined,
                label: { style: { fontSize: DEFAULT_TEXT_FONT_SIZE } }
            }, axisOption, {
                type: axisOption?.type ?? 'band',
                orient: 'bottom',
                visible: true,
                label: { visible: false },
                domainLine: { visible: false },
                tick: { visible: false },
                subTick: { visible: false },
                title: { visible: false }
            }));
        }
        return axes;
    }
    function getChartDataId(col, row, layout) {
        const chartSpec = layout.getRawChartSpec(col, row);
        if (chartSpec?.series) {
            const dataIdfield = {};
            if (chartSpec.data?.id) {
                dataIdfield[chartSpec.data.id] = undefined;
            }
            chartSpec?.series.forEach((seriesSpec) => {
                if (!seriesSpec.data?.fromDataId) {
                    if (!seriesSpec.data?.transforms) {
                        const seriesField = seriesSpec.direction === 'horizontal' ? seriesSpec.xField : seriesSpec.yField;
                        dataIdfield[seriesSpec.data?.id ?? chartSpec.data?.id ?? 'data'] = seriesSpec.data?.id
                            ? seriesField
                            : undefined;
                    }
                    else {
                        dataIdfield[seriesSpec.data?.id ?? chartSpec.data?.id ?? 'data'] = undefined;
                    }
                }
            });
            return dataIdfield;
        }
        return chartSpec.data.id;
    }
    function checkHasChart(layout) {
        let isHasChart = false;
        for (let i = 0; i < layout.columnObjects.length; i++) {
            const columnObj = layout.columnObjects[i];
            if (columnObj.chartSpec) {
                isHasChart = true;
                break;
            }
        }
        return isHasChart;
    }
    function hasSameAxis(axisOption, axes) {
        if (axisOption && isArray$7(axisOption.seriesId) && axisOption.seriesId.length > 0) {
            const sameSeriesIdAxes = axes.filter(axis => {
                if (axis.orient === axisOption.orient &&
                    axis.seriesId &&
                    axis.seriesId.length === axisOption.seriesId.length &&
                    axis.seriesId.every((id, index) => id === axisOption.seriesId[index])) {
                    return true;
                }
                return false;
            });
            if (sameSeriesIdAxes.length > 0) {
                return true;
            }
        }
        return false;
    }

    function getCellRange(col, row, layout) {
        if (col === -1 || row === -1) {
            return {
                start: { col, row },
                end: { col, row }
            };
        }
        if (layout._cellRangeMap.has(`$${col}$${row}`)) {
            return layout._cellRangeMap.get(`$${col}$${row}`);
        }
        let cellRange = { start: { col, row }, end: { col, row } };
        if (layout.transpose) {
            cellRange = getCellRangeTranspose(col, row, layout);
        }
        else {
            if (layout.headerLevelCount <= row) {
                if (layout.headerLevelCount <= row &&
                    layout.columnObjects[col - layout.leftRowSeriesNumberColumnCount]?.define?.mergeCell) {
                    const value = layout._table.getCellValue(col, row);
                    for (let r = row - 1; r >= layout.headerLevelCount; r--) {
                        const last_Value = layout._table.getCellValue(col, r);
                        if (typeof layout.columnObjects[col - layout.leftRowSeriesNumberColumnCount].define.mergeCell === 'boolean') {
                            if (value !== last_Value) {
                                break;
                            }
                        }
                        else {
                            if (!layout.columnObjects[col - layout.leftRowSeriesNumberColumnCount].define.mergeCell(value, last_Value, {
                                source: {
                                    col,
                                    row
                                },
                                target: {
                                    col,
                                    row: r
                                },
                                table: layout._table
                            })) {
                                break;
                            }
                        }
                        cellRange.start.row = r;
                    }
                    for (let r = row + 1; r < layout.rowCount; r++) {
                        const next_Value = layout._table.getCellValue(col, r);
                        if (typeof layout.columnObjects[col - layout.leftRowSeriesNumberColumnCount].define.mergeCell === 'boolean') {
                            if (value !== next_Value) {
                                break;
                            }
                        }
                        else {
                            if (!layout.columnObjects[col - layout.leftRowSeriesNumberColumnCount].define.mergeCell(value, next_Value, {
                                source: {
                                    col,
                                    row
                                },
                                target: {
                                    col,
                                    row: r
                                },
                                table: layout._table
                            })) {
                                break;
                            }
                        }
                        cellRange.end.row = r;
                    }
                }
                getTreeTitleMerge(col, row, cellRange, layout);
            }
            else {
                const id = layout.getCellId(col, row);
                for (let c = col - 1; c >= 0; c--) {
                    if (id !== layout.getCellId(c, row)) {
                        break;
                    }
                    cellRange.start.col = c;
                }
                for (let c = col + 1; c < (layout.colCount ?? 0); c++) {
                    if (id !== layout.getCellId(c, row)) {
                        break;
                    }
                    cellRange.end.col = c;
                }
                for (let r = row - 1; r >= 0; r--) {
                    if (id !== layout.getCellId(col, r)) {
                        break;
                    }
                    cellRange.start.row = r;
                }
                for (let r = row + 1; r < layout.headerLevelCount; r++) {
                    if (id !== layout.getCellId(col, r)) {
                        break;
                    }
                    cellRange.end.row = r;
                }
            }
        }
        layout._cellRangeMap.set(`$${col}$${row}`, cellRange);
        return cellRange;
    }
    function getTreeTitleMerge(col, row, cellRange, layout) {
        if (layout.rowHierarchyType !== 'tree') {
            return;
        }
        const cellRecord = layout._table.getCellRawRecord(col, row);
        if (layout._table.internalProps.rowSeriesNumber?.enableTreeCheckbox) {
            if (cellRecord?.vtableMerge && col >= layout.leftRowSeriesNumberColumnCount) {
                cellRange.start.col = layout.rowHeaderLevelCount + layout.leftRowSeriesNumberColumnCount;
                cellRange.end.col = layout.colCount - 1;
                cellRange.start.row = cellRange.end.row = row;
            }
        }
        else {
            if (cellRecord?.vtableMerge) {
                cellRange.start.col = layout.rowHeaderLevelCount;
                cellRange.end.col = layout.colCount - 1;
                cellRange.start.row = cellRange.end.row = row;
            }
        }
    }
    function getCellRangeTranspose(col, row, layout) {
        const result = { start: { col, row }, end: { col, row } };
        if (layout.headerLevelCount + layout.leftRowSeriesNumberColumnCount <= col || (col === -1 && row === -1)) {
            if (layout.headerLevelCount + layout.leftRowSeriesNumberColumnCount <= col &&
                layout.columnObjects[row]?.define?.mergeCell) {
                const value = layout._table.getCellValue(col, row);
                for (let c = col - 1; c >= layout.headerLevelCount + layout.leftRowSeriesNumberColumnCount; c--) {
                    const last_Value = layout._table.getCellValue(c, row);
                    if (typeof layout.columnObjects[row].define.mergeCell === 'boolean') {
                        if (value !== last_Value) {
                            break;
                        }
                    }
                    else {
                        if (!layout.columnObjects[row].define.mergeCell(value, last_Value, {
                            source: {
                                col,
                                row
                            },
                            target: {
                                col: c,
                                row
                            },
                            table: layout._table
                        })) {
                            break;
                        }
                    }
                    result.start.col = c;
                }
                for (let c = col + 1; c < (layout.colCount ?? 0); c++) {
                    const next_Value = layout._table.getCellValue(c, row);
                    if (typeof layout.columnObjects[row].define.mergeCell === 'boolean') {
                        if (value !== next_Value) {
                            break;
                        }
                    }
                    else {
                        if (!layout.columnObjects[row].define.mergeCell(value, next_Value, {
                            source: {
                                col,
                                row
                            },
                            target: {
                                col: c,
                                row
                            },
                            table: layout._table
                        })) {
                            break;
                        }
                    }
                    result.end.col = c;
                }
            }
            return result;
        }
        const id = layout.getCellId(col, row);
        for (let r = row - 1; r >= 0; r--) {
            if (id !== layout.getCellId(col, r)) {
                break;
            }
            result.start.row = r;
        }
        for (let r = row + 1; r < (layout.rowCount ?? 0); r++) {
            if (id !== layout.getCellId(col, r)) {
                break;
            }
            result.end.row = r;
        }
        for (let c = col - 1; c >= 0; c--) {
            if (id !== layout.getCellId(c, row)) {
                break;
            }
            result.start.col = c;
        }
        for (let c = col + 1; c < layout.headerLevelCount + layout.leftRowSeriesNumberColumnCount; c++) {
            if (id !== layout.getCellId(c, row)) {
                break;
            }
            result.end.col = c;
        }
        return result;
    }

    class SimpleHeaderLayoutMap {
        seqId = 0;
        _headerObjects;
        _headerObjectMap;
        _headerObjectsIncludeHided;
        _headerCellIds;
        _columns;
        _columnsIncludeHided;
        rowSeriesNumberColumn;
        leftRowSeriesNumberColumn;
        rightRowSeriesNumberColumn;
        leftRowSeriesNumberColumnCount = 0;
        rightRowSeriesNumberColumnCount = 0;
        columnTree;
        bodyRowSpanCount = 1;
        hierarchyIndent;
        hierarchyTextStartAlignment;
        _transpose = false;
        _showHeader = true;
        _recordsCount = 0;
        _table;
        _hasAggregation = false;
        _hasAggregationOnTopCount = 0;
        _hasAggregationOnBottomCount = 0;
        rowHierarchyType;
        columnHierarchyType;
        columnExpandLevel;
        _cellRangeMap;
        constructor(table, columns, showHeader, hierarchyIndent) {
            this._cellRangeMap = new Map();
            this._showHeader = showHeader;
            this._table = table;
            this._columns = [];
            this._columnsIncludeHided = [];
            this._headerCellIds = [];
            this.hierarchyIndent = hierarchyIndent ?? 20;
            this.hierarchyTextStartAlignment = table.options.hierarchyTextStartAlignment;
            this.columnHierarchyType = table.options.headerHierarchyType;
            this.columnExpandLevel = table.options.headerExpandLevel ?? 1;
            this.columnTree = new DimensionTree(columns, { seqId: 0 }, this.columnHierarchyType ?? null, this.columnHierarchyType === 'grid-tree' ? this.columnExpandLevel : undefined);
            this._headerObjectsIncludeHided = this._addHeaders(0, columns, []);
            this._headerObjects = this._headerObjectsIncludeHided.filter(col => {
                return col.define.hide !== true;
            });
            this._headerObjectMap = this._headerObjects.reduce((o, e) => {
                o[e.id] = e;
                return o;
            }, {});
            this.rowHierarchyType = checkHasTreeDefine(this) ? 'tree' : 'grid';
            this._hasAggregation = checkHasAggregation(this);
            this._hasAggregationOnBottomCount = checkHasAggregationOnBottom(this);
            this._hasAggregationOnTopCount = checkHasAggregationOnTop(this);
            this.handleRowSeriesNumber(table.internalProps.rowSeriesNumber);
        }
        handleRowSeriesNumber(rowSeriesNumber) {
            if (rowSeriesNumber) {
                if (Array.isArray(rowSeriesNumber)) {
                    this.rowSeriesNumberColumn = rowSeriesNumber.map((seriesNumber, index) => {
                        return {
                            id: this.seqId++,
                            title: seriesNumber.title,
                            define: merge$1({ field: '_vtable_rowSeries_number_' + index }, seriesNumber),
                            cellType: seriesNumber.cellType ?? 'text',
                            headerType: seriesNumber.cellType === 'checkbox' ? 'checkbox' : 'text',
                            style: seriesNumber.style,
                            width: seriesNumber.width,
                            format: seriesNumber.format,
                            field: seriesNumber.field ?? '_vtable_rowSeries_number_' + index,
                            icon: seriesNumber.icon,
                            headerIcon: seriesNumber.headerIcon,
                            isChildNode: false
                        };
                    });
                }
                else {
                    this.rowSeriesNumberColumn = [
                        {
                            id: this.seqId++,
                            title: rowSeriesNumber.title,
                            define: merge$1({ field: '_vtable_rowSeries_number' }, rowSeriesNumber),
                            cellType: rowSeriesNumber.cellType ?? 'text',
                            headerType: rowSeriesNumber.cellType === 'checkbox' ? 'checkbox' : 'text',
                            style: rowSeriesNumber.style,
                            width: rowSeriesNumber.width,
                            format: rowSeriesNumber.format,
                            field: '_vtable_rowSeries_number',
                            icon: rowSeriesNumber.icon,
                            headerIcon: rowSeriesNumber.headerIcon,
                            isChildNode: false
                        }
                    ];
                }
                this.leftRowSeriesNumberColumn = this.rowSeriesNumberColumn.filter(rowSeriesNumberItem => {
                    return true;
                });
                this.rightRowSeriesNumberColumn = this.rowSeriesNumberColumn.filter(rowSeriesNumberItem => {
                    return false;
                });
                this.leftRowSeriesNumberColumnCount = this.leftRowSeriesNumberColumn.length;
                this.rightRowSeriesNumberColumnCount = this.rightRowSeriesNumberColumn.length;
            }
        }
        get transpose() {
            return this._transpose;
        }
        set transpose(_transpose) {
            this._transpose = _transpose;
        }
        get showHeader() {
            return this._showHeader;
        }
        set showHeader(_showHeader) {
            this._showHeader = _showHeader;
        }
        isSeriesNumberInHeader(col, row) {
            if (this.leftRowSeriesNumberColumnCount > 0 && col >= 0 && row >= 0 && col < this.leftRowSeriesNumberColumnCount) {
                if (this.transpose) {
                    return false;
                }
                else if (row < this.headerLevelCount) {
                    return true;
                }
            }
            if (this.rightRowSeriesNumberColumnCount > 0 &&
                row >= 0 &&
                col >= this.colCount - this.rightRowSeriesNumberColumnCount) {
                if (this.transpose) {
                    return false;
                }
                else if (row < this.headerLevelCount) {
                    return true;
                }
            }
            return false;
        }
        isSeriesNumberInBody(col, row) {
            if (this.leftRowSeriesNumberColumnCount > 0 && col >= 0 && col < this.leftRowSeriesNumberColumnCount) {
                if (this.transpose) {
                    return true;
                }
                if (row >= this.headerLevelCount) {
                    return true;
                }
            }
            if (this.rightRowSeriesNumberColumnCount > 0 && col >= this.colCount - this.rightRowSeriesNumberColumnCount) {
                if (this.transpose) {
                    return true;
                }
                if (row >= this.headerLevelCount) {
                    return true;
                }
            }
            return false;
        }
        isSeriesNumber(col, row) {
            if (isValid$3(col) && isValid$3(row)) {
                if (this.leftRowSeriesNumberColumnCount > 0 &&
                    col >= 0 &&
                    row >= 0 &&
                    col < this.leftRowSeriesNumberColumnCount) {
                    return true;
                }
                if (this.rightRowSeriesNumberColumnCount > 0 &&
                    row >= 0 &&
                    col >= this.colCount - this.rightRowSeriesNumberColumnCount) {
                    return true;
                }
            }
            return false;
        }
        getSeriesNumberHeader(col, row) {
            if (this.leftRowSeriesNumberColumnCount > 0 && col >= 0 && col < this.leftRowSeriesNumberColumnCount) {
                if (this.transpose) {
                    return undefined;
                }
                if (row < this.headerLevelCount) {
                    return Object.assign({}, this.leftRowSeriesNumberColumn[col], {
                        style: Object.assign({}, this._table.transpose
                            ? this._table.internalProps.theme.rowHeaderStyle
                            : this._table.internalProps.theme.headerStyle, this._table.internalProps.rowSeriesNumber.headerStyle)
                    });
                }
            }
            if (this.rightRowSeriesNumberColumnCount > 0 &&
                col >= this.colCount - this.rightRowSeriesNumberColumnCount &&
                row < this.headerLevelCount) {
                if (this.transpose) {
                    return undefined;
                }
                if (row < this.headerLevelCount) {
                    return this.rightRowSeriesNumberColumn[col - (this.colCount - this.rightRowSeriesNumberColumnCount)];
                }
            }
            return undefined;
        }
        getSeriesNumberBody(col, row) {
            if (this.leftRowSeriesNumberColumnCount > 0 && col >= 0 && col < this.leftRowSeriesNumberColumnCount) {
                if (this.transpose) {
                    return this.leftRowSeriesNumberColumn[col];
                }
                if (row >= this.headerLevelCount) {
                    return this.leftRowSeriesNumberColumn[col];
                }
            }
            if (this.rightRowSeriesNumberColumnCount > 0 && col >= this.colCount - this.rightRowSeriesNumberColumnCount) {
                if (this.transpose) {
                    return this.rightRowSeriesNumberColumn[col - (this.colCount - this.rightRowSeriesNumberColumnCount)];
                }
                if (row >= this.headerLevelCount) {
                    return this.rightRowSeriesNumberColumn[col - (this.colCount - this.rightRowSeriesNumberColumnCount)];
                }
            }
            return undefined;
        }
        isHeader(col, row) {
            if (this.transpose &&
                col >= this.leftRowSeriesNumberColumnCount &&
                col < this.headerLevelCount + this.leftRowSeriesNumberColumnCount) {
                return true;
            }
            if (!this.transpose && row >= 0 && row < this.headerLevelCount) {
                return true;
            }
            return false;
        }
        isAggregation(col, row) {
            if (this.hasAggregation) {
                if (this.hasAggregationOnBottomCount) {
                    if (this.transpose) {
                        if (col >= this.colCount - this.hasAggregationOnBottomCount) {
                            return true;
                        }
                    }
                    else {
                        if (row >= this.rowCount - this.hasAggregationOnBottomCount) {
                            return true;
                        }
                    }
                }
                if (this.hasAggregationOnTopCount) {
                    if (this.transpose) {
                        if (col >= this.rowHeaderLevelCount && col < this.rowHeaderLevelCount + this.hasAggregationOnTopCount) {
                            return true;
                        }
                    }
                    else {
                        if (row >= this.columnHeaderLevelCount && row < this.columnHeaderLevelCount + this.hasAggregationOnTopCount) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }
        isTopAggregation(col, row) {
            if (this.hasAggregationOnTopCount) {
                if (this.transpose) {
                    if (col >= this.rowHeaderLevelCount && col < this.rowHeaderLevelCount + this.hasAggregationOnTopCount) {
                        return true;
                    }
                }
                else {
                    if (row >= this.columnHeaderLevelCount && row < this.columnHeaderLevelCount + this.hasAggregationOnTopCount) {
                        return true;
                    }
                }
            }
            return false;
        }
        isBottomAggregation(col, row) {
            if (this.hasAggregationOnBottomCount) {
                if (this.transpose) {
                    if (col >= this.colCount - this.hasAggregationOnBottomCount) {
                        return true;
                    }
                }
                else {
                    if (row >= this.rowCount - this.hasAggregationOnBottomCount) {
                        return true;
                    }
                }
            }
            return false;
        }
        get hasAggregation() {
            return this._hasAggregation;
        }
        get hasAggregationOnTopCount() {
            return this._hasAggregationOnTopCount;
        }
        get hasAggregationOnBottomCount() {
            return this._hasAggregationOnBottomCount;
        }
        getAggregatorsByCell(col, row) {
            const column = this.getColumnDefine(col, row);
            const aggregators = column.vtable_aggregator;
            return aggregators;
        }
        getAggregatorsByCellRange(startCol, startRow, endCol, endRow) {
            let aggregators = [];
            if (this.transpose) {
                for (let i = startRow; i <= endRow; i++) {
                    const column = this.getColumnDefine(startCol, i);
                    if (column.vtable_aggregator) {
                        aggregators = aggregators.concat(Array.isArray(column.vtable_aggregator) ? column.vtable_aggregator : [column.vtable_aggregator]);
                    }
                }
            }
            else {
                for (let i = startCol; i <= endCol; i++) {
                    const column = this.getColumnDefine(i, startRow);
                    if (column.vtable_aggregator) {
                        aggregators = aggregators.concat(Array.isArray(column.vtable_aggregator) ? column.vtable_aggregator : [column.vtable_aggregator]);
                    }
                }
                return aggregators;
            }
            return [];
        }
        getAggregatorOnTop(col, row) {
            const column = this.getColumnDefine(col, row);
            const aggregators = column.vtable_aggregator;
            const aggregation = column.aggregation;
            if (Array.isArray(aggregation)) {
                const topAggregationIndexs = aggregation.reduce((indexs, agg, index) => {
                    if (agg.showOnTop) {
                        indexs.push(index);
                    }
                    return indexs;
                }, []);
                const topAggregators = topAggregationIndexs.map(index => aggregators[index]);
                if (this.transpose) {
                    return topAggregators[col - this.rowHeaderLevelCount];
                }
                return topAggregators[row - this.columnHeaderLevelCount];
            }
            if (this.transpose && col - this.rowHeaderLevelCount === 0) {
                return aggregation?.showOnTop ? aggregators : null;
            }
            else if (!this.transpose && row - this.columnHeaderLevelCount === 0) {
                return aggregation?.showOnTop ? aggregators : null;
            }
            return null;
        }
        getAggregatorOnBottom(col, row) {
            const column = this.getColumnDefine(col, row);
            const aggregators = column.vtable_aggregator;
            const aggregation = column.aggregation;
            if (Array.isArray(aggregation)) {
                const bottomAggregationIndexs = aggregation.reduce((indexs, agg, index) => {
                    if (!agg.showOnTop) {
                        indexs.push(index);
                    }
                    return indexs;
                }, []);
                const bottomAggregators = bottomAggregationIndexs.map(index => aggregators[index]);
                if (this.transpose) {
                    return bottomAggregators[col - (this.colCount - this.hasAggregationOnBottomCount)];
                }
                return bottomAggregators[row - (this.rowCount - this.hasAggregationOnBottomCount)];
            }
            if (this.transpose && col - (this.colCount - this.hasAggregationOnBottomCount) === 0) {
                return !aggregation?.showOnTop ? aggregators : null;
            }
            else if (!this.transpose && row - (this.rowCount - this.hasAggregationOnBottomCount) === 0) {
                return !aggregation?.showOnTop ? aggregators : null;
            }
            return null;
        }
        getAggregatorCellAddress(startCol, startRow, endCol, endRow) {
            const cellAddrs = [];
            const topCount = this.hasAggregationOnTopCount;
            const bottomCount = this.hasAggregationOnBottomCount;
            if (this.transpose) {
                for (let row = startRow; row <= endRow; row++) {
                    const column = this.getColumnDefine(startCol, row);
                    if (column.vtable_aggregator) {
                        for (let i = 0; i < topCount; i++) {
                            cellAddrs.push({ col: this.headerLevelCount + i, row });
                        }
                        for (let i = 0; i < bottomCount; i++) {
                            cellAddrs.push({ col: this.rowCount - bottomCount + i, row });
                        }
                    }
                }
            }
            else {
                for (let col = startCol; col <= endCol; col++) {
                    const column = this.getColumnDefine(col, startRow);
                    if (column.vtable_aggregator) {
                        for (let i = 0; i < topCount; i++) {
                            cellAddrs.push({ col, row: this.headerLevelCount + i });
                        }
                        for (let i = 0; i < bottomCount; i++) {
                            cellAddrs.push({ col, row: this.rowCount - bottomCount + i });
                        }
                    }
                }
            }
            return cellAddrs;
        }
        getCellLocation(col, row) {
            if (this.isHeader(col, row)) {
                if (this.transpose) {
                    return 'rowHeader';
                }
                return 'columnHeader';
            }
            return 'body';
        }
        isRowHeader(col, row) {
            if (this.transpose &&
                col >= this.leftRowSeriesNumberColumnCount &&
                col < this.headerLevelCount + this.leftRowSeriesNumberColumnCount) {
                return true;
            }
            return false;
        }
        isColumnHeader(col, row) {
            if (!this.transpose &&
                row >= 0 &&
                row <= this.headerLevelCount - 1 &&
                col >= this.leftRowSeriesNumberColumnCount &&
                col < this.colCount - this.rightRowSeriesNumberColumnCount) {
                return true;
            }
            return false;
        }
        isFrozenColumn(col, row) {
            if (isValid$3(row)) {
                if (col >= 0 &&
                    col < this.frozenColCount &&
                    row >= this.frozenRowCount &&
                    row < this.rowCount - this.bottomFrozenRowCount) {
                    return true;
                }
            }
            else {
                if (this.frozenColCount > 0 && col >= 0 && col < this.frozenColCount) {
                    return true;
                }
            }
            return false;
        }
        isRightFrozenColumn(col, row) {
            if (isValid$3(row)) {
                if (col >= this.colCount - this.rightFrozenColCount &&
                    row >= this.frozenRowCount &&
                    row < this.rowCount - this.bottomFrozenRowCount) {
                    return true;
                }
            }
            else {
                if (this.rightFrozenColCount > 0 && col >= this.colCount - this.rightFrozenColCount) {
                    return true;
                }
            }
            return false;
        }
        isFrozenRow(col, row) {
            if (isValid$3(row)) {
                if (row >= 0 &&
                    row < this.frozenRowCount &&
                    col >= this.frozenColCount &&
                    col < this.colCount - this.rightFrozenColCount) {
                    return true;
                }
            }
            else {
                row = col;
                if (this.frozenRowCount > 0 && row >= 0 && row < this.frozenRowCount) {
                    return true;
                }
            }
            return false;
        }
        isBottomFrozenRow(col, row) {
            if (isValid$3(row)) {
                if (row >= this.rowCount - this.bottomFrozenRowCount &&
                    col >= this.frozenColCount &&
                    col < this.colCount - this.rightFrozenColCount) {
                    return true;
                }
            }
            else {
                row = col;
                if (this.bottomFrozenRowCount > 0 && row >= this.rowCount - this.bottomFrozenRowCount) {
                    return true;
                }
            }
            return false;
        }
        isLeftTopCorner(col, row) {
            if (col >= 0 && col < this.frozenColCount && row >= 0 && row < this.frozenRowCount) {
                return true;
            }
            return false;
        }
        isLeftBottomCorner(col, row) {
            if (col >= 0 && col < this.frozenColCount && row >= this.rowCount - this.bottomFrozenRowCount) {
                return true;
            }
            return false;
        }
        isRightTopCorner(col, row) {
            if (col >= this.colCount - this.rightFrozenColCount && row >= 0 && row < this.frozenRowCount) {
                return true;
            }
            return false;
        }
        isRightBottomCorner(col, row) {
            if (col >= this.colCount - this.rightFrozenColCount && row >= this.rowCount - this.bottomFrozenRowCount) {
                return true;
            }
            return false;
        }
        isCornerHeader(col, row) {
            return false;
        }
        getColumnHeaderRange() {
            if (this.transpose) {
                return {
                    start: { col: 0, row: 0 },
                    end: { col: this._headerCellIds.length - 1, row: (this.rowCount ?? 0) - 1 }
                };
            }
            return {
                start: { col: 0, row: 0 },
                end: { col: (this.colCount ?? 0) - 1, row: this._headerCellIds.length - 1 }
            };
        }
        getRowHeaderRange() {
            if (this.transpose) {
                return {
                    start: { col: 0, row: 0 },
                    end: { col: this._headerCellIds.length - 1, row: (this.rowCount ?? 0) - 1 }
                };
            }
            return {
                start: { col: 0, row: 0 },
                end: { col: (this.colCount ?? 0) - 1, row: this._headerCellIds.length - 1 }
            };
        }
        getCornerHeaderRange() {
            return undefined;
        }
        getBodyRange() {
            if (this.transpose) {
                return {
                    start: { col: this.headerLevelCount, row: 0 },
                    end: { col: (this.colCount ?? 0) - 1, row: (this.rowCount ?? 0) - 1 }
                };
            }
            return {
                start: { col: 0, row: this.headerLevelCount },
                end: { col: (this.colCount ?? 0) - 1, row: (this.rowCount ?? 0) - 1 }
            };
        }
        get headerLevelCount() {
            return this.showHeader ? this._headerCellIds.length : 0;
        }
        get columnHeaderLevelCount() {
            return this.transpose ? 0 : this.headerLevelCount;
        }
        get rowHeaderLevelCount() {
            return this.transpose ? this.headerLevelCount : 0;
        }
        get frozenColCount() {
            if (this._table.internalProps.frozenColCount) {
                if (this.colCount > this._table.internalProps.frozenColCount) {
                    return this._table.internalProps.frozenColCount;
                }
                return this.colCount;
            }
            return 0;
        }
        get frozenRowCount() {
            if (this._table.internalProps.frozenRowCount) {
                if (this.rowCount >= this._table.internalProps.frozenRowCount) {
                    return this._table.internalProps.frozenRowCount;
                }
                return this.rowCount;
            }
            return 0;
        }
        get bottomFrozenRowCount() {
            if (this._table.internalProps.bottomFrozenRowCount) {
                if (this.rowCount - this.headerLevelCount >= this._table.internalProps.bottomFrozenRowCount) {
                    return this._table.internalProps.bottomFrozenRowCount;
                }
                return this.rowCount - this.headerLevelCount;
            }
            return 0;
        }
        get rightFrozenColCount() {
            if (this._table.internalProps.rightFrozenColCount) {
                if (this.colCount - this.frozenColCount >= this._table.internalProps.rightFrozenColCount) {
                    return this._table.internalProps.rightFrozenColCount;
                }
                return Math.max(0, this.colCount - this.frozenColCount);
            }
            return 0;
        }
        get colCount() {
            return this.transpose
                ? this.headerLevelCount +
                    this.recordsCount +
                    this.leftRowSeriesNumberColumnCount +
                    this.rightRowSeriesNumberColumnCount
                : this._columns.length + this.leftRowSeriesNumberColumnCount + this.rightRowSeriesNumberColumnCount;
        }
        get rowCount() {
            return this.transpose ? this._columns.length : this.headerLevelCount + this.recordsCount;
        }
        get bodyRowCount() {
            return this.transpose ? this._columns.length : this.rowCount - this.bottomFrozenRowCount - this.headerLevelCount;
        }
        get bodyColCount() {
            return this.transpose ? this.colCount - this.rightFrozenColCount - this.rowHeaderLevelCount : this._columns.length;
        }
        get recordsCount() {
            return this._recordsCount;
        }
        set recordsCount(recordsCount) {
            this._recordsCount = recordsCount;
        }
        get headerObjects() {
            return this._headerObjects;
        }
        get columnObjects() {
            return this._columns;
        }
        get headerObjectsIncludeHided() {
            return this._headerObjectsIncludeHided;
        }
        get columnWidths() {
            if (this.leftRowSeriesNumberColumnCount) {
                const widths = this.leftRowSeriesNumberColumn.map(item => {
                    return {
                        width: item.width,
                        minWidth: item.minWidth,
                        maxWidth: item.maxWidth
                    };
                });
                widths.push(...this._columns.map(item => {
                    return {
                        width: item.width,
                        minWidth: item.minWidth,
                        maxWidth: item.maxWidth
                    };
                }));
                return widths;
            }
            return this._columns.map(item => {
                return {
                    width: item.width,
                    minWidth: item.minWidth,
                    maxWidth: item.maxWidth
                };
            });
        }
        getColumnWidthDefined(col) {
            if (col >= 0) {
                if (col < this.leftRowSeriesNumberColumnCount) {
                    return this.leftRowSeriesNumberColumn[col];
                }
                if (this.transpose) {
                    let width = 0;
                    let maxWidth;
                    let minWidth;
                    if (col >= this.rowHeaderLevelCount + this.leftRowSeriesNumberColumnCount) {
                        let isAuto;
                        this.columnObjects.forEach((obj, index) => {
                            if (typeof obj.width === 'number') {
                                width = Math.max(obj.width, width);
                            }
                            else if (obj.width === 'auto') {
                                isAuto = true;
                            }
                            if (typeof obj.minWidth === 'number') {
                                minWidth = Math.max(obj.minWidth, minWidth);
                            }
                            if (typeof obj.maxWidth === 'number') {
                                maxWidth = Math.max(obj.maxWidth, maxWidth);
                            }
                        });
                        width = width > 0 ? width : isAuto ? 'auto' : undefined;
                        return { width, minWidth, maxWidth };
                    }
                    if (this.isRowHeader(col, 0)) {
                        const defaultWidth = Array.isArray(this._table.defaultHeaderColWidth)
                            ? this._table.defaultHeaderColWidth[col] ?? this._table.defaultColWidth
                            : this._table.defaultHeaderColWidth;
                        if (defaultWidth === 'auto') {
                            return { width: 'auto' };
                        }
                        return { width: defaultWidth };
                    }
                }
                return this._columns[col - this.leftRowSeriesNumberColumnCount];
            }
            return undefined;
        }
        getCellId(col, row) {
            if (this.transpose) {
                if (col >= this.headerLevelCount + this.leftRowSeriesNumberColumnCount) {
                    return this._columns[row]?.id;
                }
                if (this.isSeriesNumber(col, row)) {
                    return row + '_series_number';
                }
                return this._headerCellIds[col - this.leftRowSeriesNumberColumnCount]?.[row];
            }
            if (this.isSeriesNumber(col, row)) {
                return this.rowSeriesNumberColumn[col].id;
            }
            if (this.headerLevelCount <= row) {
                return this._columns[col - this.leftRowSeriesNumberColumnCount]?.id;
            }
            return this._headerCellIds[row]?.[col - this.leftRowSeriesNumberColumnCount];
        }
        getHeader(col, row) {
            if (this.isSeriesNumberInHeader(col, row)) {
                return this.getSeriesNumberHeader(col, row);
            }
            const id = this.getCellId(col, row);
            return this._headerObjectMap[id];
        }
        getHeaderField(col, row) {
            if (this.isSeriesNumberInHeader(col, row)) {
                return this.getSeriesNumberHeader(col, row)?.field;
            }
            else if (this.isSeriesNumberInBody(col, row)) {
                return this.getSeriesNumberBody(col, row)?.field;
            }
            const id = this.getCellId(col, row);
            return (this._headerObjectMap[id]?.field ||
                (this.transpose
                    ? this._columns[row] && this._columns[row].field
                    : this._columns[col - this.leftRowSeriesNumberColumnCount] &&
                        this._columns[col - this.leftRowSeriesNumberColumnCount].field));
        }
        getHeaderCellAdressById(id) {
            for (let i = 0; i < this._headerCellIds.length; i++) {
                const row = this._headerCellIds[i];
                for (let j = 0; j < row.length; j++) {
                    if (row[j] === id) {
                        if (this.transpose) {
                            return { col: i, row: j };
                        }
                        return { col: j + this.leftRowSeriesNumberColumnCount, row: i };
                    }
                }
            }
            return undefined;
        }
        getHeaderCellAddressByField(field) {
            const hd = this.headerObjects.find((col) => col && col.field === field);
            return hd && this.getHeaderCellAdressById(hd.id);
        }
        getBody(col, _row) {
            if (this.isSeriesNumber(col, _row)) {
                return this.getSeriesNumberBody(col, _row);
            }
            return this.transpose ? this._columns[_row] : this._columns[col - this.leftRowSeriesNumberColumnCount];
        }
        getBodyLayoutRangeById(id) {
            if (this.transpose) {
                for (let row = 0; row < (this.rowCount ?? 0); row++) {
                    if (id === this._columns[row].id) {
                        return {
                            start: { col: 0, row },
                            end: { col: 0, row }
                        };
                    }
                }
            }
            else {
                for (let col = this.leftRowSeriesNumberColumnCount; col < (this.colCount ?? 0); col++) {
                    if (id === this._columns[col - this.leftRowSeriesNumberColumnCount].id) {
                        return {
                            start: { col, row: 0 },
                            end: { col, row: 0 }
                        };
                    }
                }
            }
            return {
                start: { col: -1, row: -1 },
                end: { col: -1, row: -1 }
            };
        }
        getCellRange(col, row) {
            return getCellRange(col, row, this);
        }
        isCellRangeEqual(col, row, targetCol, targetRow) {
            const range1 = this.getCellRange(col, row);
            const range2 = this.getCellRange(targetCol, targetRow);
            return (range1.start.col === range2.start.col &&
                range1.end.col === range2.end.col &&
                range1.start.row === range2.start.row &&
                range1.end.row === range2.end.row);
        }
        getRecordShowIndexByCell(col, row) {
            const skipRowCount = this.hasAggregationOnTopCount ? this.headerLevelCount + 1 : this.headerLevelCount;
            if (this.transpose) {
                if (col < skipRowCount) {
                    return -1;
                }
                return col - skipRowCount;
            }
            if (row < skipRowCount) {
                return -1;
            }
            return row - skipRowCount;
        }
        getRecordStartRowByRecordIndex(index) {
            const skipRowCount = this.hasAggregationOnTopCount ? this.headerLevelCount + 1 : this.headerLevelCount;
            return skipRowCount + index;
        }
        _addHeaders(row, column, roots, hideColumnsSubHeader) {
            const results = [];
            const rowCells = this._newRow(row, hideColumnsSubHeader);
            column.forEach((hd) => {
                const col = this._columns.length;
                const id = this.seqId++;
                const cell = {
                    id,
                    title: hd.title ?? hd.caption,
                    headerIcon: hd.headerIcon,
                    field: hd.field,
                    style: hd.headerStyle,
                    headerType: hd.headerType ?? 'text',
                    dropDownMenu: hd.dropDownMenu,
                    define: hd,
                    hierarchyState: hd.hierarchyState,
                    columnWidthComputeMode: hd.columnWidthComputeMode
                };
                results[id] = cell;
                for (let r = row - 1; r >= 0; r--) {
                    this._headerCellIds[r] && (this._headerCellIds[r][col] = roots[r]);
                }
                if (!hideColumnsSubHeader) {
                    rowCells[col] = id;
                }
                else if (this._headerCellIds[row - 1]) {
                    rowCells[col] = this._headerCellIds[row - 1][col];
                }
                const expand = !hd.hierarchyState || hd.hierarchyState === HierarchyState.expand;
                if (!!hd.columns && !!expand) {
                    const isAllHided = hd.columns.every((c) => c.hide);
                    !isAllHided &&
                        this._addHeaders(row + 1, hd.columns, [...roots, id], hd.hideColumnsSubHeader || hideColumnsSubHeader).forEach(c => results.push(c));
                }
                else {
                    const colDef = {
                        id: this.seqId++,
                        field: hd.field,
                        fieldFormat: hd.fieldFormat,
                        width: hd.width,
                        minWidth: hd.minWidth,
                        maxWidth: hd.maxWidth,
                        icon: hd.icon,
                        cellType: hd.cellType ?? hd.columnType ?? 'text',
                        chartModule: 'chartModule' in hd ? hd.chartModule : null,
                        chartSpec: 'chartSpec' in hd ? hd.chartSpec : null,
                        sparklineSpec: 'sparklineSpec' in hd ? hd.sparklineSpec : DefaultSparklineSpec,
                        style: hd.style,
                        define: hd,
                        columnWidthComputeMode: hd.columnWidthComputeMode,
                        disableColumnResize: hd?.disableColumnResize,
                        aggregation: hd.aggregation,
                        isChildNode: row >= 1
                    };
                    this._columnsIncludeHided.push(colDef);
                    if (hd.hide !== true) {
                        this._columns.push(colDef);
                        for (let r = row + 1; r < this._headerCellIds.length; r++) {
                            this._headerCellIds[r][col] = id;
                        }
                    }
                }
            });
            return results;
        }
        _newRow(row, hideColumnsSubHeader = false) {
            if (this._headerCellIds[row]) {
                const prev = this._headerCellIds[row - 1];
                if (prev.length > this._headerCellIds[row].length) {
                    for (let col = this._headerCellIds[row].length; col < prev.length; col++) {
                        this._headerCellIds[row][col] = prev[col];
                    }
                }
                return this._headerCellIds[row];
            }
            if (hideColumnsSubHeader) {
                return [];
            }
            const newRow = (this._headerCellIds[row] = []);
            if (!this._columns.length) {
                return newRow;
            }
            const prev = this._headerCellIds[row - 1];
            for (let col = 0; col < prev.length; col++) {
                newRow[col] = prev[col];
            }
            return newRow;
        }
        getCellHeaderPaths(col, row) {
            if (this.isSeriesNumber(col, row)) {
                return undefined;
            }
            let colPath = [];
            let rowPath = [];
            if (!this.transpose) {
                colPath = [
                    {
                        field: this._columns[col - this.leftRowSeriesNumberColumnCount].field
                    }
                ];
            }
            else {
                rowPath = [
                    {
                        field: this._columns[row].field
                    }
                ];
            }
            return {
                colHeaderPaths: colPath,
                rowHeaderPaths: rowPath,
                cellLocation: this.getCellLocation(col, row)
            };
        }
        getParentCellId(col, row) {
            if (row === 0) {
                return undefined;
            }
            if (this.isColumnHeader(col, row)) {
                return this.getCellId(col, row - 1);
            }
            else if (this.isRowHeader(col, row)) {
                if (this.isSeriesNumberInBody(col - 1, row)) {
                    return undefined;
                }
                return this.getCellId(col - 1, row);
            }
            return undefined;
        }
        canMoveHeaderPosition(source, target) {
            if (this.isSeriesNumberInHeader(target.col, target.row) || this.isSeriesNumberInHeader(source.col, source.row)) {
                return false;
            }
            else if (!this.transpose &&
                this.isSeriesNumberInBody(target.col, target.row) &&
                this.isSeriesNumberInBody(source.col, source.row)) {
                const sourceIndex = this.getRecordShowIndexByCell(0, source.row);
                const targetIndex = this.getRecordShowIndexByCell(0, target.row);
                const canMove = this._table.dataSource.canChangeOrder(sourceIndex, targetIndex);
                return canMove;
            }
            else if (this.transpose &&
                this.isSeriesNumberInBody(target.col, target.row) &&
                this.isSeriesNumberInBody(source.col, source.row)) {
                if (this.getBody(source.col + this.leftRowSeriesNumberColumnCount, source.row).isChildNode &&
                    this.getBody(target.col + this.leftRowSeriesNumberColumnCount, target.row).isChildNode) {
                    source.col = source.col + this.leftRowSeriesNumberColumnCount + this.rowHeaderLevelCount - 1;
                    target.col = target.col + this.leftRowSeriesNumberColumnCount + this.rowHeaderLevelCount - 1;
                }
                else {
                    source.col = source.col + this.leftRowSeriesNumberColumnCount;
                    target.col = target.col + this.leftRowSeriesNumberColumnCount;
                }
            }
            if (source.col < 0 || source.row < 0 || target.col < 0 || target.row < 0) {
                return false;
            }
            if (this._table.internalProps.frozenColDragHeaderMode === 'disabled') {
                if (this._table.isFrozenColumn(target.col)) {
                    return false;
                }
            }
            const sourceCellRange = this.getCellRange(source.col, source.row);
            if (this.isColumnHeader(source.col, source.row)) {
                const sourceTopId = this.getParentCellId(source.col, sourceCellRange.start.row);
                const targetTopId = this.getParentCellId(target.col, sourceCellRange.start.row);
                return sourceTopId === targetTopId;
            }
            else if (this.isRowHeader(source.col, source.row)) {
                const sourceTopId = this.getParentCellId(sourceCellRange.start.col, source.row);
                const targetTopId = this.getParentCellId(sourceCellRange.start.col, target.row);
                return sourceTopId === targetTopId;
            }
            return false;
        }
        moveHeaderPosition(source, target) {
            if ((!this._table.options.dragOrder?.validateDragOrderOnEnd ||
                this._table.options.dragOrder?.validateDragOrderOnEnd(source, target)) &&
                this.canMoveHeaderPosition(source, target)) {
                let sourceCellRange = this.getCellRange(source.col, source.row);
                if (this.isColumnHeader(source.col, source.row)) {
                    const sourceSize = sourceCellRange.end.col - sourceCellRange.start.col + 1;
                    let targetIndex;
                    const targetCellRange = this.getCellRange(target.col, sourceCellRange.start.row);
                    if (target.col >= source.col) {
                        targetIndex = targetCellRange.end.col - sourceSize + 1;
                    }
                    else {
                        targetIndex = targetCellRange.start.col;
                    }
                    if (targetIndex === sourceCellRange.start.col) {
                        return null;
                    }
                    for (let row = 0; row < this._headerCellIds.length; row++) {
                        const sourceIds = this._headerCellIds[row].splice(sourceCellRange.start.col - this.leftRowSeriesNumberColumnCount, sourceSize);
                        sourceIds.unshift(targetIndex - this.leftRowSeriesNumberColumnCount, 0);
                        Array.prototype.splice.apply(this._headerCellIds[row], sourceIds);
                    }
                    const sourceColumns = this._columns.splice(sourceCellRange.start.col - this.leftRowSeriesNumberColumnCount, sourceSize);
                    sourceColumns.unshift((targetIndex - this.leftRowSeriesNumberColumnCount), 0);
                    Array.prototype.splice.apply(this._columns, sourceColumns);
                    this.columnTree.movePosition(sourceCellRange.start.row, sourceCellRange.start.col - this.leftRowSeriesNumberColumnCount, targetIndex - this.leftRowSeriesNumberColumnCount);
                    this.columnTree.reset(this.columnTree.tree.children);
                    this._cellRangeMap = new Map();
                    return {
                        sourceIndex: sourceCellRange.start.col,
                        targetIndex,
                        sourceSize,
                        targetSize: targetCellRange.end.col - targetCellRange.start.col + 1,
                        moveType: 'column'
                    };
                }
                else if (this.isRowHeader(source.col, source.row) ||
                    (this.isSeriesNumberInBody(source.col, source.row) && this.transpose)) {
                    if (this.isSeriesNumberInBody(source.col, source.row)) {
                        sourceCellRange = this.getCellRange(source.col + this.leftRowSeriesNumberColumnCount, source.row);
                    }
                    const sourceSize = sourceCellRange.end.row - sourceCellRange.start.row + 1;
                    let targetIndex;
                    const targetCellRange = this.getCellRange(sourceCellRange.start.col, target.row);
                    if (target.row >= source.row) {
                        targetIndex = targetCellRange.end.row - sourceSize + 1;
                    }
                    else {
                        targetIndex = targetCellRange.start.row;
                    }
                    if (targetIndex === sourceCellRange.start.row) {
                        return null;
                    }
                    for (let row = 0; row < this._headerCellIds.length; row++) {
                        const sourceIds = this._headerCellIds[row].splice(sourceCellRange.start.row, sourceSize);
                        sourceIds.unshift(targetIndex, 0);
                        Array.prototype.splice.apply(this._headerCellIds[row], sourceIds);
                    }
                    const sourceColumns = this._columns.splice(sourceCellRange.start.row, sourceSize);
                    sourceColumns.unshift(targetIndex, 0);
                    Array.prototype.splice.apply(this._columns, sourceColumns);
                    this.columnTree.movePosition(sourceCellRange.start.col - this.leftRowSeriesNumberColumnCount, sourceCellRange.start.row, targetIndex + (target.row > source.row ? sourceCellRange.end.row - sourceCellRange.start.row : 0));
                    this.columnTree.reset(this.columnTree.tree.children);
                    this._cellRangeMap = new Map();
                    return {
                        sourceIndex: sourceCellRange.start.row,
                        targetIndex,
                        sourceSize,
                        targetSize: targetCellRange.end.row - targetCellRange.start.row + 1,
                        moveType: 'row'
                    };
                }
                else if (this.isSeriesNumberInBody(source.col, source.row)) {
                    return {
                        sourceIndex: source.row,
                        targetIndex: target.row,
                        sourceSize: 1,
                        targetSize: 1,
                        moveType: 'row'
                    };
                }
            }
            return null;
        }
        toggleHierarchyState(diffDataIndices) {
            const addCellPositions = diffDataIndices.add.map(index => {
                return { col: 0, row: this._table.columnHeaderLevelCount + index };
            });
            const removeCellPositions = diffDataIndices.remove.map(index => {
                return { col: 0, row: this._table.columnHeaderLevelCount + index };
            });
            return {
                addCellPositions,
                removeCellPositions
            };
        }
        setChartInstance(_col, _row, chartInstance) {
            const columnObj = this.transpose ? this._columns[_row] : this._columns[_col - this.leftRowSeriesNumberColumnCount];
            if (typeof columnObj.chartSpec === 'function') {
                return;
            }
            columnObj.chartInstance = chartInstance;
        }
        getChartInstance(_col, _row) {
            const columnObj = this.transpose ? this._columns[_row] : this._columns[_col - this.leftRowSeriesNumberColumnCount];
            return columnObj.chartInstance;
        }
        checkHasChart() {
            return checkHasChart(this);
        }
        getAxisConfigInPivotChart(col, row) {
            return undefined;
        }
        isEmpty(col, row) {
            return false;
        }
        isAxisCell(col, row) {
            return false;
        }
        getChartAxes(col, row) {
            return [];
        }
        isShareChartSpec(col, row) {
            const body = this.getBody(col, row);
            const chartSpec = body?.chartSpec;
            if (typeof chartSpec === 'function') {
                return false;
            }
            return true;
        }
        isNoChartDataRenderNothing(col, row) {
            const body = this.getBody(col, row);
            const noDataRenderNothing = (body?.define).noDataRenderNothing;
            return noDataRenderNothing;
        }
        getChartSpec(col, row) {
            return this.getRawChartSpec(col, row);
        }
        getRawChartSpec(col, row) {
            const body = this.getBody(col, row);
            const chartSpec = body?.chartSpec;
            if (typeof chartSpec === 'function') {
                const arg = {
                    col,
                    row,
                    dataValue: this._table.getCellOriginValue(col, row) || '',
                    value: this._table.getCellValue(col, row) || '',
                    rect: this._table.getCellRangeRelativeRect(this._table.getCellRange(col, row)),
                    table: this._table
                };
                return chartSpec(arg);
            }
            return chartSpec;
        }
        getChartDataId(col, row) {
            return getChartDataId(col, row, this);
        }
        release() {
            const activeChartInstance = this._table._getActiveChartInstance();
            activeChartInstance?.release();
            this.columnObjects.forEach(indicatorObject => {
                indicatorObject.chartInstance?.release();
            });
        }
        clearCellRangeMap() {
            this._cellRangeMap.clear();
        }
        updateColumnTitle(col, row, title) {
            const define = this._table.internalProps.layoutMap.getHeader(col, row);
            define.title = title;
            define.define.title = title;
        }
        getColumnByField(field) {
            const result = this.columnObjects?.reduce((pre, cur, index) => {
                if (cur.field === field) {
                    pre.push({ col: index, columnDefine: cur });
                }
                return pre;
            }, []);
            return result;
        }
        getColumnByKey(key) {
            let col;
            const result = this.columnObjects?.find((columnData, index) => {
                if (columnData.define?.key === key) {
                    col = index + this.leftRowSeriesNumberColumnCount;
                    return true;
                }
                return false;
            });
            return {
                columnDefine: result,
                col
            };
        }
        getColumnDefine(col, row) {
            if (col >= 0) {
                if (col < this.leftRowSeriesNumberColumnCount) {
                    return this.leftRowSeriesNumberColumn[col].define;
                }
                if (this.transpose) {
                    return this._columns[row].define;
                }
                return this._columns[col - this.leftRowSeriesNumberColumnCount].define;
            }
            return undefined;
        }
    }

    class EditManager {
        table;
        editingEditor;
        isValidatingValue = false;
        editCell;
        listenersId = [];
        beginTriggerEditCellMode;
        constructor(table) {
            this.table = table;
            this.bindEvent();
        }
        bindEvent() {
            const table = this.table;
            const doubleClickEventId = table.on(TABLE_EVENT_TYPE.DBLCLICK_CELL, e => {
                const { editCellTrigger = 'doubleclick' } = table.options;
                if (!editCellTrigger.includes('doubleclick')) {
                    return;
                }
                const { col, row } = e;
                const eventArgsSet = getCellEventArgsSet(e.federatedEvent);
                const resizeCol = table.scenegraph.getResizeColAt(eventArgsSet.abstractPos.x, eventArgsSet.abstractPos.y, eventArgsSet.eventArgs?.targetCell);
                if (table._canResizeColumn(resizeCol.col, resizeCol.row) && resizeCol.col >= 0) {
                    return;
                }
                if (e.target?.attribute?.funcType) {
                    return;
                }
                this.beginTriggerEditCellMode = 'doubleclick';
                this.startEditCell(col, row);
            });
            const clickEventId = table.on(TABLE_EVENT_TYPE.CLICK_CELL, e => {
                const { editCellTrigger = 'doubleclick' } = table.options;
                if (editCellTrigger === 'click' || (Array.isArray(editCellTrigger) && editCellTrigger.includes('click'))) {
                    if (e.target?.attribute?.funcType) {
                        return;
                    }
                    this.beginTriggerEditCellMode = 'click';
                    const { col, row } = e;
                    this.startEditCell(col, row);
                }
            });
            this.listenersId.push(doubleClickEventId, clickEventId);
        }
        startEditCell(col, row, value) {
            if (this.editingEditor) {
                return;
            }
            const editor = this.table.getEditor(col, row);
            if (editor) {
                if (this.table.internalProps.layoutMap?.isAggregation?.(col, row)) {
                    return;
                }
                const record = this.table.getCellRawRecord(col, row);
                if (record?.vtableMerge) {
                    return;
                }
                if (!this.editingEditor) {
                    this.editCell = { col, row };
                }
                this.table._makeVisibleCell(col, row);
                this.editingEditor = editor;
                const dataValue = isValid$3(value) ? value : this.table.getCellOriginValue(col, row);
                const rect = this.table.getCellRangeRelativeRect(this.table.getCellRange(col, row));
                const referencePosition = { rect: { left: rect.left, top: rect.top, width: rect.width, height: rect.height } };
                if (col === this.table.colCount - 1) {
                    referencePosition.rect.width = rect.width - 1;
                }
                else {
                    referencePosition.rect.width = rect.width + 1;
                }
                if (row === this.table.rowCount - 1) {
                    referencePosition.rect.height = rect.height - 1;
                }
                else {
                    referencePosition.rect.height = rect.height + 1;
                }
                editor.beginEditing && (void 0);
                editor.beginEditing?.(this.table.getElement(), referencePosition, dataValue);
                if (editor.bindSuccessCallback) ;
                editor.bindSuccessCallback?.(() => {
                    this.completeEdit();
                });
                editor.onStart?.({
                    value: dataValue,
                    endEdit: () => {
                        this.completeEdit();
                    },
                    referencePosition,
                    container: this.table.getElement(),
                    col,
                    row,
                    table: this.table
                });
            }
        }
        completeEdit(e) {
            if (!this.editingEditor) {
                return true;
            }
            if (this.isValidatingValue) {
                return false;
            }
            const target = e?.target;
            const { editingEditor: editor } = this;
            if (target) {
                if (editor.targetIsOnEditor) {
                    if (editor.targetIsOnEditor(target)) {
                        return false;
                    }
                }
                else if (!editor.isEditorElement || editor.isEditorElement(target)) {
                    return false;
                }
            }
            if (!this.editingEditor.getValue) ;
            if (this.editingEditor.validateValue) {
                this.isValidatingValue = true;
                const newValue = this.editingEditor.getValue();
                const oldValue = this.table.getCellOriginValue(this.editCell.col, this.editCell.row);
                const maybePromiseOrValue = this.editingEditor.validateValue?.(newValue, oldValue, this.editCell, this.table);
                if (isPromise(maybePromiseOrValue)) {
                    this.isValidatingValue = true;
                    return new Promise((resolve, reject) => {
                        maybePromiseOrValue
                            .then(result => {
                            dealWithValidateValue(result, this, oldValue, resolve);
                        })
                            .catch((err) => {
                            this.isValidatingValue = false;
                            reject(err);
                        });
                    });
                }
                return dealWithValidateValue(maybePromiseOrValue, this, oldValue);
            }
            this.doExit();
            return true;
        }
        doExit() {
            const changedValue = this.editingEditor.getValue?.();
            const range = this.table.getCellRange(this.editCell.col, this.editCell.row);
            const changedValues = [];
            for (let row = range.start.row; row <= range.end.row; row++) {
                const rowChangedValues = [];
                for (let col = range.start.col; col <= range.end.col; col++) {
                    rowChangedValues.push(changedValue);
                }
                changedValues.push(rowChangedValues);
            }
            this.table.changeCellValues(range.start.col, range.start.row, changedValues);
            this.editingEditor.exit && (void 0);
            this.editingEditor.exit?.();
            this.editingEditor.onEnd?.();
            this.editingEditor = null;
            this.isValidatingValue = false;
            this.beginTriggerEditCellMode = null;
        }
        cancelEdit() {
            if (this.editingEditor) {
                this.editingEditor.exit?.();
                this.editingEditor.onEnd?.();
                this.editingEditor = null;
            }
        }
        release() {
            this.listenersId.forEach(id => {
                this.table.off(id);
            });
        }
    }
    function dealWithValidateValue(validateValue, editManager, oldValue, resolve) {
        editManager.isValidatingValue = false;
        if (validateValue === 'validate-exit') {
            editManager.doExit();
            resolve?.(true);
            return true;
        }
        else if (validateValue === 'invalidate-exit') {
            editManager.editingEditor.setValue(oldValue);
            editManager.doExit();
            resolve?.(true);
            return true;
        }
        else if (validateValue === 'validate-not-exit') {
            resolve?.(false);
            return false;
        }
        else if (validateValue === 'invalidate-not-exit') {
            resolve?.(false);
            return false;
        }
        else if (validateValue === true) {
            editManager.doExit();
            resolve?.(true);
            return true;
        }
        resolve?.(false);
        return false;
    }

    function getGroupByDataConfig(groupByOption) {
        if (isString$4(groupByOption)) {
            return { groupByRules: [groupByOption] };
        }
        if (isArray$7(groupByOption)) {
            const groupByRules = groupByOption.map(item => {
                if (isString$4(item)) {
                    return item;
                }
                return item.key;
            });
            return { groupByRules };
        }
        return {};
    }

    function listTableChangeCellValue(col, row, value, workOnEditableCell, triggerEvent, table) {
        if ((workOnEditableCell && table.isHasEditorDefine(col, row)) || workOnEditableCell === false) {
            const recordIndex = table.getRecordShowIndexByCell(col, row);
            const { field } = table.internalProps.layoutMap.getBody(col, row);
            const beforeChangeValue = table.getCellRawValue(col, row);
            const oldValue = table.getCellOriginValue(col, row);
            if (table.isHeader(col, row)) {
                table.internalProps.layoutMap.updateColumnTitle(col, row, value);
            }
            else {
                table.dataSource.changeFieldValue(value, recordIndex, field, col, row, table);
            }
            const range = table.getCellRange(col, row);
            const aggregators = table.internalProps.layoutMap.getAggregatorsByCell(col, row);
            if (aggregators) {
                if (Array.isArray(aggregators)) {
                    for (let i = 0; i < aggregators?.length; i++) {
                        aggregators[i].recalculate();
                    }
                }
                else {
                    aggregators.recalculate();
                }
                const aggregatorCells = table.internalProps.layoutMap.getAggregatorCellAddress(range.start.col, range.start.row, range.end.col, range.end.row);
                for (let i = 0; i < aggregatorCells.length; i++) {
                    const range = table.getCellRange(aggregatorCells[i].col, aggregatorCells[i].row);
                    for (let sCol = range.start.col; sCol <= range.end.col; sCol++) {
                        for (let sRow = range.start.row; sRow <= range.end.row; sRow++) {
                            table.scenegraph.updateCellContent(sCol, sRow);
                        }
                    }
                }
            }
            for (let sCol = range.start.col; sCol <= range.end.col; sCol++) {
                for (let sRow = range.start.row; sRow <= range.end.row; sRow++) {
                    table.scenegraph.updateCellContent(sCol, sRow);
                }
            }
            if (table.widthMode === 'adaptive' || (table.autoFillWidth && table.getAllColsWidth() <= table.tableNoFrameWidth)) {
                if (table.internalProps._widthResizedColMap.size === 0) {
                    table.scenegraph.recalculateColWidths();
                }
            }
            else if (!table.internalProps._widthResizedColMap.has(col)) {
                const oldWidth = table.getColWidth(col);
                const newWidth = computeColWidth(col, 0, table.rowCount - 1, table, false);
                if (newWidth !== oldWidth) {
                    table.scenegraph.updateColWidth(col, newWidth - oldWidth);
                }
            }
            if (table.heightMode === 'adaptive' ||
                (table.autoFillHeight && table.getAllRowsHeight() <= table.tableNoFrameHeight)) {
                if (table.internalProps._heightResizedRowMap.size === 0) {
                    table.scenegraph.recalculateRowHeights();
                }
            }
            else if (table.isAutoRowHeight(row) && !table.internalProps._heightResizedRowMap.has(row)) {
                const oldHeight = table.getRowHeight(row);
                const newHeight = computeRowHeight(row, 0, table.colCount - 1, table);
                table.scenegraph.updateRowHeight(row, newHeight - oldHeight);
            }
            const changedValue = table.getCellOriginValue(col, row);
            if (oldValue !== changedValue && triggerEvent) {
                table.fireListeners(TABLE_EVENT_TYPE.CHANGE_CELL_VALUE, {
                    col,
                    row,
                    rawValue: beforeChangeValue,
                    currentValue: oldValue,
                    changedValue
                });
            }
            table.scenegraph.updateNextFrame();
        }
    }
    function listTableChangeCellValues(startCol, startRow, values, workOnEditableCell, triggerEvent, table) {
        let pasteColEnd = startCol;
        let pasteRowEnd = startRow;
        const beforeChangeValues = [];
        const oldValues = [];
        let cellUpdateType;
        for (let i = 0; i < values.length; i++) {
            if (startRow + i > table.rowCount - 1) {
                break;
            }
            const rowValues = values[i];
            const rawRowValues = [];
            const oldRowValues = [];
            beforeChangeValues.push(rawRowValues);
            oldValues.push(oldRowValues);
            for (let j = 0; j < rowValues.length; j++) {
                if (startCol + j > table.colCount - 1) {
                    break;
                }
                cellUpdateType = getCellUpdateType(startCol + j, startRow + i, table, cellUpdateType);
                const beforeChangeValue = table.getCellRawValue(startCol + j, startRow + i);
                rawRowValues.push(beforeChangeValue);
                const oldValue = table.getCellOriginValue(startCol + j, startRow + i);
                oldRowValues.push(oldValue);
            }
        }
        for (let i = 0; i < values.length; i++) {
            if (startRow + i > table.rowCount - 1) {
                break;
            }
            pasteRowEnd = startRow + i;
            const rowValues = values[i];
            let thisRowPasteColEnd = startCol;
            for (let j = 0; j < rowValues.length; j++) {
                if (startCol + j > table.colCount - 1) {
                    break;
                }
                thisRowPasteColEnd = startCol + j;
                let isCanChange = false;
                if (workOnEditableCell === false) {
                    isCanChange = true;
                }
                else {
                    if (table.isHasEditorDefine(startCol + j, startRow + i)) {
                        const editor = table.getEditor(startCol + j, startRow + i);
                        const oldValue = oldValues[i][j];
                        const value = rowValues[j];
                        const maybePromiseOrValue = editor?.validateValue?.(value, oldValue) ?? true;
                        if (isPromise(maybePromiseOrValue)) {
                            isCanChange = true;
                        }
                        else {
                            isCanChange =
                                maybePromiseOrValue === true ||
                                    maybePromiseOrValue === 'validate-exit' ||
                                    maybePromiseOrValue === 'invalidate-exit';
                        }
                    }
                }
                if (isCanChange) {
                    const value = rowValues[j];
                    const recordIndex = table.getRecordShowIndexByCell(startCol + j, startRow + i);
                    const { field } = table.internalProps.layoutMap.getBody(startCol + j, startRow + i);
                    const beforeChangeValue = beforeChangeValues[i][j];
                    const oldValue = oldValues[i][j];
                    if (table.isHeader(startCol + j, startRow + i)) {
                        table.internalProps.layoutMap.updateColumnTitle(startCol + j, startRow + i, value);
                    }
                    else {
                        table.dataSource.changeFieldValue(value, recordIndex, field, startCol + j, startRow + i, table);
                    }
                    const changedValue = table.getCellOriginValue(startCol + j, startRow + i);
                    if (oldValue !== changedValue && triggerEvent) {
                        table.fireListeners(TABLE_EVENT_TYPE.CHANGE_CELL_VALUE, {
                            col: startCol + j,
                            row: startRow + i,
                            rawValue: beforeChangeValue,
                            currentValue: oldValue,
                            changedValue
                        });
                    }
                }
            }
            pasteColEnd = Math.max(pasteColEnd, thisRowPasteColEnd);
        }
        const startRange = table.getCellRange(startCol, startRow);
        const range = table.getCellRange(pasteColEnd, pasteRowEnd);
        const aggregators = table.internalProps.layoutMap.getAggregatorsByCellRange(startRange.start.col, startRange.start.row, range.end.col, range.end.row);
        if (aggregators) {
            for (let i = 0; i < aggregators?.length; i++) {
                aggregators[i].recalculate();
            }
            if (cellUpdateType === 'normal') {
                const aggregatorCells = table.internalProps.layoutMap.getAggregatorCellAddress(startRange.start.col, startRange.start.row, range.end.col, range.end.row);
                for (let i = 0; i < aggregatorCells.length; i++) {
                    const range = table.getCellRange(aggregatorCells[i].col, aggregatorCells[i].row);
                    for (let sCol = range.start.col; sCol <= range.end.col; sCol++) {
                        for (let sRow = range.start.row; sRow <= range.end.row; sRow++) {
                            table.scenegraph.updateCellContent(sCol, sRow);
                        }
                    }
                }
            }
        }
        if (cellUpdateType === 'group') {
            table.dataSource.updateRecordsForGroup([], []);
        }
        if (cellUpdateType === 'sort' || cellUpdateType === 'group') {
            table.dataSource.sortedIndexMap.clear();
            sortRecords(table);
            table.refreshRowColCount();
            table.internalProps.layoutMap.clearCellRangeMap();
            table.scenegraph.clearCells();
            table.scenegraph.createSceneGraph();
            return;
        }
        for (let sCol = startRange.start.col; sCol <= range.end.col; sCol++) {
            for (let sRow = startRange.start.row; sRow <= range.end.row; sRow++) {
                table.scenegraph.updateCellContent(sCol, sRow);
            }
        }
        if (table.widthMode === 'adaptive' || (table.autoFillWidth && table.getAllColsWidth() <= table.tableNoFrameWidth)) {
            if (table.internalProps._widthResizedColMap.size === 0) {
                table.scenegraph.recalculateColWidths();
            }
        }
        else {
            for (let sCol = startCol; sCol <= range.end.col; sCol++) {
                if (!table.internalProps._widthResizedColMap.has(sCol)) {
                    const oldWidth = table.getColWidth(sCol);
                    const newWidth = computeColWidth(sCol, 0, table.rowCount - 1, table, false);
                    if (newWidth !== oldWidth) {
                        table.scenegraph.updateColWidth(sCol, newWidth - oldWidth);
                    }
                }
            }
        }
        if (table.heightMode === 'adaptive' ||
            (table.autoFillHeight && table.getAllRowsHeight() <= table.tableNoFrameHeight)) {
            table.scenegraph.recalculateRowHeights();
        }
        else if (table.isAutoRowHeight(startRow)) {
            const rows = [];
            const deltaYs = [];
            for (let sRow = startRow; sRow <= range.end.row; sRow++) {
                if (table.rowHeightsMap.get(sRow)) {
                    const oldHeight = table.getRowHeight(sRow);
                    const newHeight = computeRowHeight(sRow, 0, table.colCount - 1, table);
                    rows.push(sRow);
                    deltaYs.push(newHeight - oldHeight);
                }
            }
            table.scenegraph.updateRowsHeight(rows, deltaYs);
        }
        table.scenegraph.updateNextFrame();
    }
    function getCellUpdateType(col, row, table, oldCellUpdateType) {
        if (oldCellUpdateType === 'group') {
            return oldCellUpdateType;
        }
        if (oldCellUpdateType === 'sort' && !table.options.groupBy) {
            return oldCellUpdateType;
        }
        let cellUpdateType = 'normal';
        if (table.options.groupBy) {
            cellUpdateType = 'group';
        }
        else if (!table.isHeader(col, row) && table.dataSource.lastOrderField) {
            const field = table.getBodyField(col, row);
            if (field === table.dataSource.lastOrderField) {
                cellUpdateType = 'sort';
            }
        }
        return cellUpdateType;
    }
    function sortRecords(table) {
        let sortState = table.sortState;
        sortState = !sortState || Array.isArray(sortState) ? sortState : [sortState];
        if (sortState) {
            sortState = sortState.map(item => {
                item.orderFn = table._getSortFuncFromHeaderOption(undefined, item.field) ?? defaultOrderFn;
                return item;
            });
            table.dataSource.sort(sortState);
        }
    }
    function listTableAddRecord(record, recordIndex, table) {
        if (table.options.groupBy) {
            table.dataSource.addRecordsForGroup?.([record], recordIndex);
            table.refreshRowColCount();
            table.internalProps.layoutMap.clearCellRangeMap();
            table.sortState && sortRecords(table);
            table.scenegraph.clearCells();
            table.scenegraph.createSceneGraph();
        }
        else if (table.dataSource.rowHierarchyType === 'tree') {
            table.dataSource.addRecordsForTree?.([record], recordIndex);
            table.refreshRowColCount();
            table.internalProps.layoutMap.clearCellRangeMap();
            table.sortState && sortRecords(table);
            table.scenegraph.clearCells();
            table.scenegraph.createSceneGraph();
        }
        else if (table.sortState) {
            table.dataSource.addRecordForSorted(record);
            sortRecords(table);
            table.refreshRowColCount();
            table.scenegraph.clearCells();
            table.scenegraph.createSceneGraph();
        }
        else {
            recordIndex = recordIndex;
            if (recordIndex === undefined || recordIndex > table.dataSource.sourceLength) {
                recordIndex = table.dataSource.sourceLength;
            }
            const headerCount = table.transpose ? table.rowHeaderLevelCount : table.columnHeaderLevelCount;
            table.dataSource.addRecord(record, recordIndex);
            const oldRowCount = table.rowCount;
            table.refreshRowColCount();
            if (table.scenegraph.proxy.totalActualBodyRowCount === 0) {
                table.scenegraph.clearCells();
                table.scenegraph.createSceneGraph();
                return;
            }
            const newRowCount = table.transpose ? table.colCount : table.rowCount;
            if (table.pagination) {
                const { perPageCount, currentPage } = table.pagination;
                const startIndex = perPageCount * (currentPage || 0);
                const endIndex = startIndex + perPageCount;
                if (recordIndex < endIndex) {
                    if (recordIndex < endIndex - perPageCount) {
                        table.scenegraph.clearCells();
                        table.scenegraph.createSceneGraph();
                    }
                    else {
                        const rowNum = recordIndex - (endIndex - perPageCount) + headerCount;
                        if (oldRowCount - headerCount === table.pagination.perPageCount) {
                            const updateRows = [];
                            for (let row = rowNum; row < newRowCount; row++) {
                                if (table.transpose) {
                                    updateRows.push({ col: row, row: 0 });
                                }
                                else {
                                    updateRows.push({ col: 0, row });
                                }
                            }
                            table.transpose
                                ? table.scenegraph.updateCol([], [], updateRows)
                                : table.scenegraph.updateRow([], [], updateRows);
                        }
                        else {
                            const addRows = [];
                            for (let row = rowNum; row < Math.min(newRowCount, rowNum + 1); row++) {
                                if (table.transpose) {
                                    addRows.push({ col: row, row: 0 });
                                }
                                else {
                                    addRows.push({ col: 0, row });
                                }
                            }
                            table.transpose ? table.scenegraph.updateCol([], addRows, []) : table.scenegraph.updateRow([], addRows, []);
                        }
                    }
                }
            }
            else {
                const addRows = [];
                for (let row = recordIndex + headerCount; row < recordIndex + headerCount + 1; row++) {
                    if (table.transpose) {
                        addRows.push({ col: row, row: 0 });
                    }
                    else {
                        addRows.push({ col: 0, row });
                    }
                }
                const topAggregationCount = table.internalProps.layoutMap.hasAggregationOnTopCount;
                const bottomAggregationCount = table.internalProps.layoutMap.hasAggregationOnBottomCount;
                for (let row = headerCount; row < headerCount + topAggregationCount; row++) {
                    if (table.transpose) ;
                }
                for (let row = (table.transpose ? table.colCount : table.rowCount) - bottomAggregationCount; row < (table.transpose ? table.colCount : table.rowCount); row++) {
                    if (table.transpose) ;
                }
                table.transpose ? table.scenegraph.updateCol([], addRows, []) : table.scenegraph.updateRow([], addRows, []);
            }
        }
    }
    function listTableAddRecords(records, recordIndex, table) {
        if (table.options.groupBy) {
            table.dataSource.addRecordsForGroup?.(records, recordIndex);
            table.refreshRowColCount();
            table.internalProps.layoutMap.clearCellRangeMap();
            table.sortState && sortRecords(table);
            table.scenegraph.clearCells();
            table.scenegraph.createSceneGraph();
        }
        else if (table.dataSource.rowHierarchyType === 'tree') {
            table.dataSource.addRecordsForTree?.(records, recordIndex);
            table.refreshRowColCount();
            table.internalProps.layoutMap.clearCellRangeMap();
            table.sortState && sortRecords(table);
            table.scenegraph.clearCells();
            table.scenegraph.createSceneGraph();
        }
        else if (table.sortState) {
            table.dataSource.addRecordsForSorted(records);
            sortRecords(table);
            table.refreshRowColCount();
            table.scenegraph.clearCells();
            table.scenegraph.createSceneGraph();
        }
        else {
            recordIndex = recordIndex;
            if (recordIndex === undefined || recordIndex > table.dataSource.sourceLength) {
                recordIndex = table.dataSource.sourceLength;
            }
            else if (recordIndex < 0) {
                recordIndex = 0;
            }
            const headerCount = table.transpose ? table.rowHeaderLevelCount : table.columnHeaderLevelCount;
            table.dataSource.addRecords(records, recordIndex);
            const oldRowCount = table.transpose ? table.colCount : table.rowCount;
            table.refreshRowColCount();
            if (table.scenegraph.proxy.totalActualBodyRowCount === 0) {
                table.scenegraph.clearCells();
                table.scenegraph.createSceneGraph();
                return;
            }
            const newRowCount = table.transpose ? table.colCount : table.rowCount;
            if (table.pagination) {
                const { perPageCount, currentPage } = table.pagination;
                const startIndex = perPageCount * (currentPage || 0);
                const endIndex = startIndex + perPageCount;
                if (recordIndex < endIndex) {
                    if (recordIndex < endIndex - perPageCount) {
                        table.scenegraph.clearCells();
                        table.scenegraph.createSceneGraph();
                    }
                    else {
                        const rowNum = recordIndex - (endIndex - perPageCount) + headerCount;
                        if (oldRowCount - headerCount === table.pagination.perPageCount) {
                            const updateRows = [];
                            for (let row = rowNum; row < newRowCount; row++) {
                                if (table.transpose) {
                                    updateRows.push({ col: row, row: 0 });
                                }
                                else {
                                    updateRows.push({ col: 0, row });
                                }
                            }
                            table.transpose
                                ? table.scenegraph.updateCol([], [], updateRows)
                                : table.scenegraph.updateRow([], [], updateRows);
                        }
                        else {
                            const addRows = [];
                            for (let row = rowNum; row < Math.min(newRowCount, rowNum + (Array.isArray(records) ? records.length : 1)); row++) {
                                if (table.transpose) {
                                    addRows.push({ col: row, row: 0 });
                                }
                                else {
                                    addRows.push({ col: 0, row });
                                }
                            }
                            table.transpose ? table.scenegraph.updateCol([], addRows, []) : table.scenegraph.updateRow([], addRows, []);
                        }
                    }
                }
            }
            else {
                const addRows = [];
                for (let row = recordIndex + headerCount; row < recordIndex + headerCount + (Array.isArray(records) ? records.length : 1); row++) {
                    if (table.transpose) {
                        addRows.push({ col: row, row: 0 });
                    }
                    else {
                        addRows.push({ col: 0, row });
                    }
                }
                const topAggregationCount = table.internalProps.layoutMap.hasAggregationOnTopCount;
                const bottomAggregationCount = table.internalProps.layoutMap.hasAggregationOnBottomCount;
                const updateRows = [];
                for (let row = headerCount; row < headerCount + topAggregationCount; row++) {
                    if (table.transpose) {
                        updateRows.push({ col: row, row: 0 });
                    }
                    else {
                        updateRows.push({ col: 0, row });
                    }
                }
                for (let row = (table.transpose ? table.colCount : table.rowCount) - bottomAggregationCount; row < (table.transpose ? table.colCount : table.rowCount); row++) {
                    if (table.transpose) {
                        updateRows.push({ col: row, row: 0 });
                    }
                    else {
                        updateRows.push({ col: 0, row });
                    }
                }
                table.transpose
                    ? table.scenegraph.updateCol([], addRows, updateRows)
                    : table.scenegraph.updateRow([], addRows, updateRows);
            }
        }
    }
    function listTableDeleteRecords(recordIndexs, table) {
        if (recordIndexs?.length > 0) {
            if (table.options.groupBy) {
                table.dataSource.deleteRecordsForGroup?.(recordIndexs);
                table.refreshRowColCount();
                table.internalProps.layoutMap.clearCellRangeMap();
                table.sortState && sortRecords(table);
                table.scenegraph.clearCells();
                table.scenegraph.createSceneGraph();
            }
            else if (table.dataSource.rowHierarchyType === 'tree') {
                table.dataSource.deleteRecordsForTree?.(recordIndexs);
                table.refreshRowColCount();
                table.internalProps.layoutMap.clearCellRangeMap();
                table.sortState && sortRecords(table);
                table.scenegraph.clearCells();
                table.scenegraph.createSceneGraph();
            }
            else if (table.sortState) {
                table.dataSource.deleteRecordsForSorted(recordIndexs);
                sortRecords(table);
                table.refreshRowColCount();
                table.scenegraph.clearCells();
                table.scenegraph.createSceneGraph();
            }
            else {
                const deletedRecordIndexs = table.dataSource.deleteRecords(recordIndexs);
                if (deletedRecordIndexs.length === 0) {
                    return;
                }
                const oldRowCount = table.transpose ? table.colCount : table.rowCount;
                table.refreshRowColCount();
                const newRowCount = table.transpose ? table.colCount : table.rowCount;
                const recordIndexsMinToMax = deletedRecordIndexs.sort((a, b) => a - b);
                const minRecordIndex = recordIndexsMinToMax[0];
                if (table.pagination) {
                    const { perPageCount, currentPage } = table.pagination;
                    const startIndex = perPageCount * (currentPage || 0);
                    const endIndex = startIndex + perPageCount;
                    if (minRecordIndex < endIndex) {
                        if (minRecordIndex < endIndex - perPageCount) {
                            table.scenegraph.clearCells();
                            table.scenegraph.createSceneGraph();
                        }
                        else {
                            const headerCount = table.transpose ? table.rowHeaderLevelCount : table.columnHeaderLevelCount;
                            const topAggregationCount = table.internalProps.layoutMap.hasAggregationOnTopCount;
                            const minRowNum = minRecordIndex -
                                (endIndex - perPageCount) +
                                (table.transpose ? table.rowHeaderLevelCount : table.columnHeaderLevelCount) +
                                topAggregationCount;
                            const updateRows = [];
                            const delRows = [];
                            for (let row = minRowNum; row < newRowCount; row++) {
                                if (table.transpose) {
                                    updateRows.push({ col: row, row: 0 });
                                }
                                else {
                                    updateRows.push({ col: 0, row });
                                }
                            }
                            for (let row = headerCount; row < headerCount + topAggregationCount; row++) {
                                if (table.transpose) {
                                    updateRows.push({ col: row, row: 0 });
                                }
                                else {
                                    updateRows.push({ col: 0, row });
                                }
                            }
                            if (newRowCount < oldRowCount) {
                                for (let row = newRowCount; row < oldRowCount; row++) {
                                    if (table.transpose) {
                                        delRows.push({ col: row, row: 0 });
                                    }
                                    else {
                                        delRows.push({ col: 0, row });
                                    }
                                }
                            }
                            table.reactCustomLayout?.clearCache();
                            table.transpose
                                ? table.scenegraph.updateCol(delRows, [], updateRows)
                                : table.scenegraph.updateRow(delRows, [], updateRows);
                            table.reactCustomLayout?.updateAllCustomCell();
                        }
                    }
                }
                else {
                    const delRows = [];
                    const headerCount = table.transpose ? table.rowHeaderLevelCount : table.columnHeaderLevelCount;
                    const topAggregationCount = table.internalProps.layoutMap.hasAggregationOnTopCount;
                    const bottomAggregationCount = table.internalProps.layoutMap.hasAggregationOnBottomCount;
                    for (let index = 0; index < recordIndexsMinToMax.length; index++) {
                        const recordIndex = recordIndexsMinToMax[index];
                        const rowNum = recordIndex + headerCount + topAggregationCount;
                        if (table.transpose) {
                            delRows.push({ col: rowNum, row: 0 });
                        }
                        else {
                            delRows.push({ col: 0, row: rowNum });
                        }
                    }
                    const updateRows = [];
                    for (let row = headerCount; row < headerCount + topAggregationCount; row++) {
                        if (table.transpose) {
                            updateRows.push({ col: row, row: 0 });
                        }
                        else {
                            updateRows.push({ col: 0, row });
                        }
                    }
                    for (let row = (table.transpose ? table.colCount : table.rowCount) - bottomAggregationCount; row < (table.transpose ? table.colCount : table.rowCount); row++) {
                        if (table.transpose) {
                            updateRows.push({ col: row, row: 0 });
                        }
                        else {
                            updateRows.push({ col: 0, row });
                        }
                    }
                    table.reactCustomLayout?.clearCache();
                    table.transpose
                        ? table.scenegraph.updateCol(delRows, [], updateRows)
                        : table.scenegraph.updateRow(delRows, [], updateRows);
                    table.reactCustomLayout?.updateAllCustomCell();
                }
            }
        }
    }
    function listTableUpdateRecords(records, recordIndexs, table) {
        if (recordIndexs?.length > 0) {
            if (table.options.groupBy) {
                table.dataSource.updateRecordsForGroup?.(records, recordIndexs);
                table.refreshRowColCount();
                table.internalProps.layoutMap.clearCellRangeMap();
                table.sortState && sortRecords(table);
                table.scenegraph.clearCells();
                table.scenegraph.createSceneGraph();
            }
            else if (table.dataSource.rowHierarchyType === 'tree') {
                table.dataSource.updateRecordsForTree?.(records, recordIndexs);
                table.refreshRowColCount();
                table.internalProps.layoutMap.clearCellRangeMap();
                table.sortState && sortRecords(table);
                table.scenegraph.clearCells();
                table.scenegraph.createSceneGraph();
            }
            else if (table.sortState) {
                table.dataSource.updateRecordsForSorted(records, recordIndexs);
                sortRecords(table);
                table.refreshRowColCount();
                table.scenegraph.clearCells();
                table.scenegraph.createSceneGraph();
            }
            else {
                const updateRecordIndexs = table.dataSource.updateRecords(records, recordIndexs);
                if (updateRecordIndexs.length === 0) {
                    return;
                }
                const bodyRowIndex = updateRecordIndexs.map(index => table.getBodyRowIndexByRecordIndex(index));
                const recordIndexsMinToMax = bodyRowIndex.sort((a, b) => a - b);
                if (table.pagination) {
                    const { perPageCount, currentPage } = table.pagination;
                    const headerCount = table.transpose ? table.rowHeaderLevelCount : table.columnHeaderLevelCount;
                    const topAggregationCount = table.internalProps.layoutMap.hasAggregationOnTopCount;
                    const startIndex = perPageCount * (currentPage || 0);
                    const endIndex = startIndex + perPageCount;
                    const updateRows = [];
                    for (let index = 0; index < recordIndexsMinToMax.length; index++) {
                        const recordIndex = recordIndexsMinToMax[index];
                        if (recordIndex < endIndex && recordIndex >= endIndex - perPageCount) {
                            const rowNum = recordIndex -
                                (endIndex - perPageCount) +
                                (table.transpose ? table.rowHeaderLevelCount : table.columnHeaderLevelCount) +
                                topAggregationCount;
                            updateRows.push(rowNum);
                        }
                    }
                    if (updateRows.length >= 1) {
                        const updateRowCells = [];
                        for (let index = 0; index < updateRows.length; index++) {
                            const updateRow = updateRows[index];
                            if (table.transpose) {
                                updateRowCells.push({ col: updateRow, row: 0 });
                            }
                            else {
                                updateRowCells.push({ col: 0, row: updateRow });
                            }
                        }
                        for (let row = headerCount; row < headerCount + topAggregationCount; row++) {
                            if (table.transpose) {
                                updateRowCells.push({ col: row, row: 0 });
                            }
                            else {
                                updateRowCells.push({ col: 0, row });
                            }
                        }
                        table.transpose
                            ? table.scenegraph.updateCol([], [], updateRowCells)
                            : table.scenegraph.updateRow([], [], updateRowCells);
                    }
                }
                else {
                    const updateRows = [];
                    const headerCount = table.transpose ? table.rowHeaderLevelCount : table.columnHeaderLevelCount;
                    const topAggregationCount = table.internalProps.layoutMap.hasAggregationOnTopCount;
                    const bottomAggregationCount = table.internalProps.layoutMap.hasAggregationOnBottomCount;
                    for (let index = 0; index < recordIndexsMinToMax.length; index++) {
                        const recordIndex = recordIndexsMinToMax[index];
                        const rowNum = recordIndex + headerCount + topAggregationCount;
                        if (table.transpose) {
                            updateRows.push({ col: rowNum, row: 0 });
                        }
                        else {
                            updateRows.push({ col: 0, row: rowNum });
                        }
                    }
                    for (let row = headerCount; row < headerCount + topAggregationCount; row++) {
                        if (table.transpose) {
                            updateRows.push({ col: row, row: 0 });
                        }
                        else {
                            updateRows.push({ col: 0, row });
                        }
                    }
                    for (let row = (table.transpose ? table.colCount : table.rowCount) - bottomAggregationCount; row < (table.transpose ? table.colCount : table.rowCount); row++) {
                        if (table.transpose) {
                            updateRows.push({ col: row, row: 0 });
                        }
                        else {
                            updateRows.push({ col: 0, row });
                        }
                    }
                    table.transpose
                        ? table.scenegraph.updateCol([], [], updateRows)
                        : table.scenegraph.updateRow([], [], updateRows);
                }
            }
        }
    }

    function fixUpdateRowRange(diffPositions, col, row, table) {
        const updateCells = [{ col, row }];
        const addCells = [];
        const removeCells = [];
        const { addCellPositions, removeCellPositions } = diffPositions;
        const proxy = table.scenegraph.proxy;
        const { rowStart, rowLimit } = proxy;
        let { rowEnd } = proxy;
        let updateRow = Infinity;
        for (let i = 0; i < addCellPositions.length; i++) {
            const { row: cellRow } = addCellPositions[i];
            if (rowEnd - rowStart + 1 === rowLimit) {
                if (cellRow >= rowStart && cellRow <= rowEnd) {
                    updateRow = Math.min(updateRow, cellRow);
                }
            }
            else {
                addCells.push({
                    col,
                    row: cellRow
                });
                rowEnd++;
            }
        }
        const newRowEnd = Math.min(rowStart + rowLimit, table.rowCount - 1 - table.bottomFrozenRowCount);
        const notFullRow = newRowEnd < rowStart + rowLimit;
        for (let i = 0; i < removeCellPositions.length; i++) {
            const { row: cellRow } = removeCellPositions[removeCellPositions.length - i - 1];
            if (cellRow < rowStart || cellRow > rowEnd) {
                continue;
            }
            else if (cellRow > newRowEnd) {
                removeCells.push({
                    col,
                    row: cellRow
                });
                updateRow--;
            }
            else if (notFullRow) {
                removeCells.push({
                    col,
                    row: cellRow
                });
                updateRow--;
            }
            else {
                updateRow = Math.min(updateRow, cellRow);
            }
        }
        if (updateRow !== Infinity) {
            for (let i = updateRow; i <= rowEnd; i++) {
                updateCells.push({
                    col,
                    row: i
                });
            }
        }
        table.scenegraph.proxy.refreshRowCount();
        return {
            updateCells,
            addCells,
            removeCells
        };
    }

    class ListTable extends BaseTable {
        showHeader = true;
        listTreeStickCellPlugin;
        constructor(container, options) {
            super(container, options);
            options = this.options;
            const internalProps = this.internalProps;
            internalProps.frozenColDragHeaderMode =
                options.dragOrder?.frozenColDragHeaderMode ?? options.frozenColDragHeaderMode;
            this.pagination = options.pagination;
            internalProps.sortState = options.sortState;
            internalProps.multipleSort = !!options.multipleSort;
            internalProps.dataConfig = options.groupBy ? getGroupByDataConfig(options.groupBy) : {};
            internalProps.columns = options.columns
                ? cloneDeepSpec(options.columns, ['children'])
                : options.header
                    ? cloneDeepSpec(options.header, ['children'])
                    : [];
            generateAggregationForColumn(this);
            internalProps.enableTreeNodeMerge = options.enableTreeNodeMerge ?? isValid$3(options.groupBy) ?? false;
            this.internalProps.headerHelper.setTableColumnsEditor();
            this.showHeader = options.showHeader ?? true;
            this.internalProps.columnWidthConfig = options.columnWidthConfig;
            this.transpose = options.transpose ?? false;
            if (Env.mode !== 'node') {
                this.editorManager = new EditManager(this);
            }
            this.refreshHeader();
            this.internalProps.useOneRowHeightFillAll = false;
            if (options.dataSource) {
                this.dataSource = options.dataSource;
            }
            else if (options.records) {
                this.setRecords(options.records, { sortState: internalProps.sortState });
            }
            else {
                this.setRecords([]);
            }
            if (options.title) {
                const Title = Factory.getComponent('title');
                internalProps.title = new Title(options.title, this);
                this.scenegraph.resize();
            }
            if (this.options.emptyTip) {
                if (this.internalProps.emptyTip) {
                    this.internalProps.emptyTip?.resetVisible();
                }
                else {
                    const EmptyTip = Factory.getComponent('emptyTip');
                    this.internalProps.emptyTip = new EmptyTip(this.options.emptyTip, this);
                    this.internalProps.emptyTip?.resetVisible();
                }
            }
            if (options.enableTreeStickCell) {
                const ListTreeStickCellPlugin = Factory.getComponent('listTreeStickCellPlugin');
                this.listTreeStickCellPlugin = new ListTreeStickCellPlugin(this);
            }
            setTimeout(() => {
                this.fireListeners(TABLE_EVENT_TYPE.INITIALIZED, null);
            }, 0);
        }
        isListTable() {
            return true;
        }
        isPivotTable() {
            return false;
        }
        isPivotChart() {
            return false;
        }
        get sortState() {
            return this.internalProps.sortState;
        }
        get records() {
            return this.dataSource?.records;
        }
        get recordsCount() {
            return this.dataSource.records.length;
        }
        updateColumns(columns) {
            this.scenegraph.clearCells();
            const oldHoverState = { col: this.stateManager.hover.cellPos.col, row: this.stateManager.hover.cellPos.row };
            this.internalProps.columns = cloneDeepSpec(columns, ['children']);
            generateAggregationForColumn(this);
            this.options.columns = columns;
            this.internalProps.headerHelper.setTableColumnsEditor();
            this._hasAutoImageColumn = undefined;
            this.refreshHeader();
            this.dataSource.updateColumns?.(this.internalProps.columns);
            if (this.records && checkHasAggregationOnColumnDefine(columns)) {
                this.dataSource.processRecords(this.dataSource.dataSourceObj?.records ?? this.dataSource.dataSourceObj);
            }
            this.internalProps.useOneRowHeightFillAll = false;
            this.headerStyleCache = new Map();
            this.bodyStyleCache = new Map();
            this.bodyBottomStyleCache = new Map();
            this.scenegraph.createSceneGraph();
            this.stateManager.updateHoverPos(oldHoverState.col, oldHoverState.row);
            this.renderAsync();
            this.eventManager.updateEventBinder();
        }
        addColumn(column) {
            const columns = this.options.columns;
            columns.push(column);
            this.updateColumns(columns);
        }
        get columns() {
            return this.internalProps.layoutMap.columnTree.getCopiedTree();
        }
        get header() {
            return this.internalProps.columns;
        }
        set header(header) {
            this.internalProps.columns = header;
            generateAggregationForColumn(this);
            this.options.header = header;
            this.refreshHeader();
            this.internalProps.useOneRowHeightFillAll = false;
            this.renderAsync();
        }
        get transpose() {
            return this.internalProps.transpose ?? false;
        }
        set transpose(transpose) {
            if (this.internalProps.transpose === transpose) {
                return;
            }
            this.internalProps.transpose = transpose;
            if (this.internalProps.layoutMap) {
                this.internalProps.layoutMap.transpose = transpose;
                this.refreshRowColCount();
                this._resetFrozenColCount();
                this.renderAsync();
            }
        }
        getCellValue(col, row, skipCustomMerge) {
            if (col === -1 || row === -1) {
                return null;
            }
            if (!skipCustomMerge) {
                const customMergeText = this.getCustomMergeValue(col, row);
                if (customMergeText) {
                    return customMergeText;
                }
            }
            const table = this;
            if (table.internalProps.layoutMap.isSeriesNumber(col, row)) {
                if (table.internalProps.layoutMap.isSeriesNumberInHeader(col, row)) {
                    const { title } = table.internalProps.layoutMap.getSeriesNumberHeader(col, row);
                    return title;
                }
                let value;
                if (this.options.groupBy) {
                    const record = table.getCellRawRecord(col, row);
                    if (record?.vtableMerge) {
                        return '';
                    }
                    if (!table.internalProps.layoutMap.isAggregation(col, row)) {
                        value = this.dataSource.getGroupSeriesNumber(row - this.columnHeaderLevelCount);
                    }
                }
                else {
                    value = row - this.columnHeaderLevelCount + 1;
                }
                const { format } = table.internalProps.layoutMap.getSeriesNumberBody(col, row);
                return typeof format === 'function' ? format(col, row, this, value) : value;
            }
            else if (table.internalProps.layoutMap.isHeader(col, row)) {
                const { title } = table.internalProps.layoutMap.getHeader(col, row);
                return typeof title === 'function' ? title() : title;
            }
            else if (table.internalProps.layoutMap.isAggregation(col, row)) {
                if (table.internalProps.layoutMap.isTopAggregation(col, row)) {
                    const aggregator = table.internalProps.layoutMap.getAggregatorOnTop(col, row);
                    return aggregator?.formatValue ? aggregator.formatValue(col, row, this) : '';
                }
                else if (table.internalProps.layoutMap.isBottomAggregation(col, row)) {
                    const aggregator = table.internalProps.layoutMap.getAggregatorOnBottom(col, row);
                    return aggregator?.formatValue ? aggregator.formatValue(col, row, this) : '';
                }
            }
            const { field, fieldFormat } = table.internalProps.layoutMap.getBody(col, row);
            return table.getFieldData(fieldFormat || field, col, row);
        }
        getCellOriginValue(col, row) {
            if (col === -1 || row === -1) {
                return null;
            }
            const table = this;
            if (table.internalProps.layoutMap.isSeriesNumber(col, row)) {
                if (table.internalProps.layoutMap.isSeriesNumberInHeader(col, row)) {
                    const { title } = table.internalProps.layoutMap.getSeriesNumberHeader(col, row);
                    return title;
                }
                const { format } = table.internalProps.layoutMap.getSeriesNumberBody(col, row);
                return typeof format === 'function' ? format(col, row, this) : row - this.columnHeaderLevelCount;
            }
            else if (table.internalProps.layoutMap.isHeader(col, row)) {
                const { title } = table.internalProps.layoutMap.getHeader(col, row);
                return typeof title === 'function' ? title() : title;
            }
            else if (table.internalProps.layoutMap.isAggregation(col, row)) {
                if (table.internalProps.layoutMap.isTopAggregation(col, row)) {
                    const aggregator = table.internalProps.layoutMap.getAggregatorOnTop(col, row);
                    return aggregator?.value();
                }
                else if (table.internalProps.layoutMap.isBottomAggregation(col, row)) {
                    const aggregator = table.internalProps.layoutMap.getAggregatorOnBottom(col, row);
                    return aggregator?.value();
                }
            }
            const { field } = table.internalProps.layoutMap.getBody(col, row);
            return table.getFieldData(field, col, row);
        }
        getCellRawValue(col, row) {
            if (col === -1 || row === -1) {
                return null;
            }
            const table = this;
            if (table.internalProps.layoutMap.isHeader(col, row)) {
                const { title } = table.internalProps.layoutMap.getHeader(col, row);
                return typeof title === 'function' ? title() : title;
            }
            const { field } = table.internalProps.layoutMap.getBody(col, row);
            return table.getRawFieldData(field, col, row);
        }
        getRecordShowIndexByCell(col, row) {
            const { layoutMap } = this.internalProps;
            return layoutMap.getRecordShowIndexByCell(col, row);
        }
        getRecordIndexByCell(col, row) {
            const { layoutMap } = this.internalProps;
            const recordShowIndex = layoutMap.getRecordShowIndexByCell(col, row);
            return this.dataSource.getRecordIndexPaths(recordShowIndex);
        }
        getTableIndexByRecordIndex(recordIndex) {
            if (this.transpose) {
                return this.dataSource.getTableIndex(recordIndex) + this.rowHeaderLevelCount;
            }
            return this.dataSource.getTableIndex(recordIndex) + this.columnHeaderLevelCount;
        }
        getTableIndexByField(field) {
            const colObj = this.internalProps.layoutMap.columnObjects.find((col) => col.field === field);
            if (!colObj) {
                return -1;
            }
            const layoutRange = this.internalProps.layoutMap.getBodyLayoutRangeById(colObj.id);
            if (this.transpose) {
                return layoutRange.start.row;
            }
            return layoutRange.start.col;
        }
        getCellAddrByFieldRecord(field, recordIndex) {
            if (this.transpose) {
                return { col: this.getTableIndexByRecordIndex(recordIndex), row: this.getTableIndexByField(field) };
            }
            return { col: this.getTableIndexByField(field), row: this.getTableIndexByRecordIndex(recordIndex) };
        }
        getCellOriginRecord(col, row) {
            const table = this;
            const index = table.getRecordShowIndexByCell(col, row);
            if (index > -1) {
                return table.dataSource.get(index);
            }
            return undefined;
        }
        getCellRawRecord(col, row) {
            const table = this;
            const index = table.getRecordShowIndexByCell(col, row);
            if (index > -1) {
                return table.dataSource.getRaw(index);
            }
            return undefined;
        }
        _canResizeColumn(col, row) {
            const ifCan = super._canResizeColumn(col, row);
            if (ifCan) {
                if (!this.transpose) {
                    const cellDefine = this.internalProps.layoutMap.getBody(col, this.columnHeaderLevelCount);
                    const isSeriesNumber = this.internalProps.layoutMap.isSeriesNumber(col, row);
                    if (cellDefine?.disableColumnResize) {
                        return false;
                    }
                    else if (isSeriesNumber && this.internalProps.rowSeriesNumber.disableColumnResize === true) {
                        return false;
                    }
                }
            }
            return ifCan;
        }
        updateOption(options) {
            const internalProps = this.internalProps;
            super.updateOption(options);
            internalProps.frozenColDragHeaderMode =
                options.dragOrder?.frozenColDragHeaderMode ?? options.frozenColDragHeaderMode;
            this.pagination = options.pagination;
            internalProps.sortState = options.sortState;
            internalProps.dataConfig = options.groupBy ? getGroupByDataConfig(options.groupBy) : {};
            this.showHeader = options.showHeader ?? true;
            internalProps.columns = options.columns
                ? cloneDeepSpec(options.columns, ['children'])
                : options.header
                    ? cloneDeepSpec(options.header, ['children'])
                    : [];
            generateAggregationForColumn(this);
            internalProps.enableTreeNodeMerge = options.enableTreeNodeMerge ?? isValid$3(options.groupBy) ?? false;
            this.internalProps.headerHelper.setTableColumnsEditor();
            this.transpose = options.transpose ?? false;
            this.refreshHeader();
            this.internalProps.useOneRowHeightFillAll = false;
            this.internalProps.columnWidthConfig = options.columnWidthConfig;
            if (internalProps.releaseList) {
                for (let i = internalProps.releaseList.length - 1; i >= 0; i--) {
                    const releaseObj = internalProps.releaseList[i];
                    if (releaseObj instanceof DataSource) {
                        releaseObj.updateColumns(this.internalProps.columns);
                    }
                    else {
                        releaseObj?.release?.();
                        internalProps.releaseList.splice(i, 1);
                    }
                }
            }
            if (options.dataSource && this.dataSource !== options.dataSource) {
                this.dataSource = options.dataSource;
            }
            else if (options.records) {
                this.setRecords(options.records, {
                    sortState: options.sortState
                });
            }
            else {
                this.refreshRowColCount();
                this._resetFrozenColCount();
                this.scenegraph.createSceneGraph();
                this.render();
            }
            if (options.title) {
                const Title = Factory.getComponent('title');
                internalProps.title = new Title(options.title, this);
                this.scenegraph.resize();
            }
            if (this.options.emptyTip) {
                if (this.internalProps.emptyTip) {
                    this.internalProps.emptyTip?.resetVisible();
                }
                else {
                    const EmptyTip = Factory.getComponent('emptyTip');
                    this.internalProps.emptyTip = new EmptyTip(this.options.emptyTip, this);
                    this.internalProps.emptyTip?.resetVisible();
                }
            }
            this.pluginManager.updatePlugins(options.plugins);
            return new Promise(resolve => {
                setTimeout(resolve, 0);
            });
        }
        updatePagination(pagination) {
            if (this.pagination) {
                typeof pagination.currentPage === 'number' &&
                    pagination.currentPage >= 0 &&
                    (this.pagination.currentPage = pagination.currentPage);
                pagination.perPageCount &&
                    (this.pagination.perPageCount = pagination.perPageCount || this.pagination.perPageCount);
                this.internalProps.layoutMap.clearCellRangeMap();
                this.internalProps.useOneRowHeightFillAll = false;
                this.scenegraph.clearCells();
                this.dataSource.updatePagination(this.pagination);
                this.refreshRowColCount();
                this.stateManager.initCheckedState(this.records);
                this.scenegraph.createSceneGraph();
                this.renderAsync();
            }
        }
        refreshHeader() {
            const table = this;
            const internalProps = table.internalProps;
            const transpose = table.transpose;
            const showHeader = table.showHeader;
            const layoutMap = (internalProps.layoutMap = new SimpleHeaderLayoutMap(this, internalProps.columns ?? [], showHeader, table.options.hierarchyIndent));
            layoutMap.transpose = transpose;
            if (!transpose) {
                this.setMinMaxLimitWidth(true);
            }
            this.refreshRowColCount();
        }
        refreshRowColCount() {
            const table = this;
            const { layoutMap } = table.internalProps;
            if (!layoutMap) {
                return;
            }
            const dataCount = table.internalProps.dataSource?.length ?? 0;
            layoutMap.recordsCount =
                dataCount +
                    (dataCount > 0 || !!this.options.showAggregationWhenEmpty
                        ? layoutMap.hasAggregationOnTopCount + layoutMap.hasAggregationOnBottomCount
                        : 0);
            if (table.transpose) {
                table.rowCount = layoutMap.rowCount ?? 0;
                table.colCount = layoutMap.colCount ?? 0;
                this.internalProps.frozenColCount = Math.max((layoutMap.headerLevelCount ?? 0) + layoutMap.leftRowSeriesNumberColumnCount, this.options.frozenColCount ?? 0);
                this.internalProps.frozenRowCount = this.options.frozenRowCount ?? 0;
                if (table.bottomFrozenRowCount !== (this.options.bottomFrozenRowCount ?? 0)) {
                    table.bottomFrozenRowCount = this.options.bottomFrozenRowCount ?? 0;
                }
                if (table.rightFrozenColCount !== (this.options.rightFrozenColCount ?? 0)) {
                    table.rightFrozenColCount = this.options.rightFrozenColCount ?? 0;
                }
            }
            else {
                table.colCount = layoutMap.colCount ?? 0;
                table.rowCount = layoutMap.recordsCount * layoutMap.bodyRowSpanCount + layoutMap.headerLevelCount;
                this.internalProps.frozenColCount = this.options.frozenColCount ?? 0;
                table.frozenRowCount = Math.max(layoutMap.headerLevelCount, this.options.frozenRowCount ?? 0);
                if (table.bottomFrozenRowCount !== (this.options.bottomFrozenRowCount ?? 0)) {
                    table.bottomFrozenRowCount = this.options.bottomFrozenRowCount ?? 0;
                }
                if (table.rightFrozenColCount !== (this.options.rightFrozenColCount ?? 0)) {
                    table.rightFrozenColCount = this.options.rightFrozenColCount ?? 0;
                }
            }
            this.stateManager.setFrozenCol(this.internalProps.frozenColCount);
        }
        getFieldData(field, col, row) {
            if (field === null) {
                return null;
            }
            const table = this;
            if (table.internalProps.layoutMap.isHeader(col, row)) {
                return null;
            }
            const index = table.getRecordShowIndexByCell(table.transpose ? col - table.internalProps.layoutMap.leftRowSeriesNumberColumnCount : col, row);
            return table.internalProps.dataSource.getField(index, field, col, row, this);
        }
        getRawFieldData(field, col, row) {
            if (field === null) {
                return null;
            }
            const table = this;
            if (table.internalProps.layoutMap.isHeader(col, row)) {
                return null;
            }
            const index = table.getRecordShowIndexByCell(col, row);
            return table.internalProps.dataSource.getRawField(index, field, col, row, this);
        }
        _moveHeaderPosition(source, target) {
            const sourceCellRange = this.getCellRange(source.col, source.row);
            const targetCellRange = this.getCellRange(target.col, target.row);
            const moveContext = this.internalProps.layoutMap.moveHeaderPosition(source, target);
            if (moveContext) {
                if (moveContext.moveType === 'column') {
                    this.colWidthsMap.exchangeOrder(sourceCellRange.start.col, sourceCellRange.end.col - sourceCellRange.start.col + 1, targetCellRange.start.col, targetCellRange.end.col - targetCellRange.start.col + 1, moveContext.targetIndex);
                    if (!this.transpose) {
                        this.colWidthsLimit = {};
                        this.setMinMaxLimitWidth();
                    }
                }
                else {
                    if (moveContext.targetIndex > moveContext.sourceIndex) {
                        this.rowHeightsMap.exchangeOrder(moveContext.sourceIndex, moveContext.sourceSize, moveContext.targetIndex + moveContext.sourceSize - moveContext.targetSize, moveContext.targetSize, moveContext.targetIndex);
                    }
                    else {
                        this.rowHeightsMap.exchangeOrder(moveContext.sourceIndex, moveContext.sourceSize, moveContext.targetIndex, moveContext.targetSize, moveContext.targetIndex);
                    }
                }
                return moveContext;
            }
            return null;
        }
        changeRecordOrder(sourceIndex, targetIndex) {
            if (this.transpose) {
                sourceIndex = this.getRecordShowIndexByCell(sourceIndex, 0);
                targetIndex = this.getRecordShowIndexByCell(targetIndex, 0);
            }
            else {
                sourceIndex = this.getRecordShowIndexByCell(0, sourceIndex);
                targetIndex = this.getRecordShowIndexByCell(0, targetIndex);
            }
            this.dataSource.changeOrder(sourceIndex, targetIndex);
        }
        getCellAddress(findTargetRecord, field) {
            let targetRecordIndex;
            for (let i = 0; i < this.internalProps.records.length; i++) {
                const record = this.internalProps.records[i];
                if (typeof findTargetRecord === 'function') {
                    if (findTargetRecord(record)) {
                        targetRecordIndex = i;
                    }
                }
                else {
                    let isAllRight = true;
                    for (const prop in findTargetRecord) {
                        if (record[prop] !== findTargetRecord[prop]) {
                            isAllRight = false;
                            break;
                        }
                    }
                    if (isAllRight) {
                        targetRecordIndex = i;
                    }
                }
                if (isValid$3(targetRecordIndex)) {
                    break;
                }
            }
            const cellRange = this.getCellRangeByField(field, targetRecordIndex);
            if (cellRange) {
                return { row: cellRange.start.row, col: cellRange.start.col };
            }
            return undefined;
        }
        getCellRangeByField(field, index) {
            const { layoutMap } = this.internalProps;
            const colObj = layoutMap.columnObjects.find((col) => col.field === field);
            if (colObj) {
                const layoutRange = layoutMap.getBodyLayoutRangeById(colObj.id);
                let startRow;
                if (isValid$3(index)) {
                    startRow = layoutMap.getRecordStartRowByRecordIndex(index);
                }
                if (this.transpose) {
                    return {
                        start: {
                            row: layoutRange.start.row,
                            col: isValid$3(startRow) ? startRow + layoutRange.start.col : undefined
                        },
                        end: {
                            row: layoutRange.end.row,
                            col: isValid$3(startRow) ? startRow + layoutRange.end.col : undefined
                        }
                    };
                }
                return {
                    start: {
                        col: layoutRange.start.col,
                        row: isValid$3(startRow) ? startRow + layoutRange.start.row : undefined
                    },
                    end: {
                        col: layoutRange.end.col,
                        row: isValid$3(startRow) ? startRow + layoutRange.end.row : undefined
                    }
                };
            }
            return null;
        }
        getHierarchyState(col, row) {
            if (this.isHeader(col, row)) {
                return this._getHeaderLayoutMap(col, row)?.hierarchyState;
            }
            if (!this.options.groupBy || (isArray$7(this.options.groupBy) && this.options.groupBy.length === 0)) {
                const define = this.getBodyColumnDefine(col, row);
                if (!define.tree) {
                    return HierarchyState.none;
                }
            }
            const index = this.getRecordShowIndexByCell(col, row);
            return this.dataSource.getHierarchyState(index);
        }
        toggleHierarchyState(col, row, recalculateColWidths = true) {
            this.stateManager.updateHoverIcon(col, row, undefined, undefined);
            const hierarchyState = this.getHierarchyState(col, row);
            if (this.isHeader(col, row)) {
                const headerTreeNode = this.internalProps.layoutMap.getHeader(col, row);
                const { hierarchyState: rawHierarchyState, define: columnDefine } = headerTreeNode;
                if (![HierarchyState.collapse, HierarchyState.expand].includes(rawHierarchyState) || !columnDefine) {
                    return;
                }
                const children = columnDefine.columns;
                if (!!Array.isArray(children) && children.length > 0) {
                    const hierarchyState = rawHierarchyState === HierarchyState.expand ? HierarchyState.collapse : HierarchyState.expand;
                    headerTreeNode.hierarchyState = hierarchyState;
                    headerTreeNode.define.hierarchyState = hierarchyState;
                    this.updateColumns(this.internalProps.columns);
                }
                this.fireListeners(TABLE_EVENT_TYPE.TREE_HIERARCHY_STATE_CHANGE, {
                    col,
                    row,
                    hierarchyState,
                    originData: headerTreeNode,
                    cellLocation: this.getCellLocation(col, row)
                });
                return;
            }
            if (hierarchyState === HierarchyState.expand) {
                this._refreshHierarchyState(col, row, recalculateColWidths);
                this.fireListeners(TABLE_EVENT_TYPE.TREE_HIERARCHY_STATE_CHANGE, {
                    col: col,
                    row: row,
                    hierarchyState: HierarchyState.collapse
                });
            }
            else if (hierarchyState === HierarchyState.collapse) {
                const record = this.getCellOriginRecord(col, row);
                if (Array.isArray(record.children)) {
                    this._refreshHierarchyState(col, row, recalculateColWidths);
                }
                this.fireListeners(TABLE_EVENT_TYPE.TREE_HIERARCHY_STATE_CHANGE, {
                    col: col,
                    row: row,
                    hierarchyState: HierarchyState.expand,
                    originData: record
                });
            }
        }
        setLoadingHierarchyState(col, row) {
            this.scenegraph.setLoadingHierarchyState(col, row);
        }
        _refreshHierarchyState(col, row, recalculateColWidths = true) {
            let notFillWidth = false;
            let notFillHeight = false;
            const checkHasChart = this.internalProps.layoutMap.checkHasChart();
            if (checkHasChart) {
                if (this.autoFillWidth) {
                    notFillWidth = this.getAllColsWidth() <= this.tableNoFrameWidth;
                }
                if (this.autoFillHeight) {
                    notFillHeight = this.getAllRowsHeight() <= this.tableNoFrameHeight;
                }
            }
            const index = this.getRecordShowIndexByCell(col, row);
            const diffDataIndices = this.dataSource.toggleHierarchyState(index, this.scenegraph.proxy.rowStart - this.columnHeaderLevelCount, Math.max(this.scenegraph.proxy.rowEnd - this.columnHeaderLevelCount, this.scenegraph.proxy.rowStart - this.columnHeaderLevelCount + this.scenegraph.proxy.rowLimit - 1));
            const diffPositions = this.internalProps.layoutMap.toggleHierarchyState(diffDataIndices);
            this.refreshRowColCount();
            for (let row = this.rowCount - this.bottomFrozenRowCount; row < this.rowCount; row++) {
                const newHeight = computeRowHeight(row, 0, this.colCount - 1, this);
                this._setRowHeight(row, newHeight);
            }
            this.clearCellStyleCache();
            this.internalProps.layoutMap.clearCellRangeMap();
            this.internalProps.useOneRowHeightFillAll = false;
            const { updateCells, addCells, removeCells } = fixUpdateRowRange(diffPositions, col, row, this);
            this.reactCustomLayout?.clearCache();
            this.scenegraph.updateRow(removeCells, addCells, updateCells, recalculateColWidths, true);
            this.reactCustomLayout?.updateAllCustomCell();
            if (checkHasChart) {
                if (this.autoFillWidth && !notFillWidth) {
                    notFillWidth = this.getAllColsWidth() <= this.tableNoFrameWidth;
                }
                if (this.autoFillHeight && !notFillHeight) {
                    notFillHeight = this.getAllRowsHeight() <= this.tableNoFrameHeight;
                }
                if (this.widthMode === 'adaptive' || notFillWidth || this.heightMode === 'adaptive' || notFillHeight) {
                    this.scenegraph.updateChartSizeForResizeColWidth(-1);
                }
            }
        }
        _hasHierarchyTreeHeader() {
            return (this.options.columns ?? this.options.header)?.some((column, i) => column.tree);
        }
        getMenuInfo(col, row, type) {
            const result = {
                field: this.getHeaderField(col, row),
                value: this.getCellValue(col, row),
                cellLocation: this.getCellLocation(col, row),
                event: undefined
            };
            return result;
        }
        _getSortFuncFromHeaderOption(columns, field, fieldKey) {
            if (!columns) {
                columns = this.internalProps.columns;
            }
            if (field && columns && columns.length > 0) {
                for (let i = 0; i < columns.length; i++) {
                    const header = columns[i];
                    if (((fieldKey && fieldKey === header.fieldKey) || (!fieldKey && header.field === field)) &&
                        header.sort &&
                        typeof header.sort === 'function') {
                        return header.sort;
                    }
                    else if (header.columns) {
                        const sort = this._getSortFuncFromHeaderOption(header.columns, field, fieldKey);
                        if (sort) {
                            return sort;
                        }
                    }
                }
            }
            return undefined;
        }
        updateSortState(sortState, executeSort = true) {
            if (!sortState) {
                if (this.internalProps.sortState) {
                    if (Array.isArray(this.internalProps.sortState)) {
                        for (let i = 0; i < this.internalProps.sortState.length; i++) {
                            sortState = this.internalProps.sortState?.[i];
                            sortState && (sortState.order = 'normal');
                        }
                    }
                    else {
                        this.internalProps.sortState.order = 'normal';
                        sortState = this.internalProps.sortState;
                    }
                }
            }
            else {
                this.internalProps.sortState = sortState;
            }
            sortState = Array.isArray(sortState) ? sortState : [sortState];
            if (sortState.some((item) => item.field) && executeSort) {
                if (this.internalProps.layoutMap.headerObjects.some(item => item.define.sort !== false)) {
                    this.dataSource.sort(sortState.map((item) => {
                        const sortFunc = this._getSortFuncFromHeaderOption(this.internalProps.columns, item.field);
                        this.internalProps.layoutMap.headerObjects.find((col) => col && col.field === item.field);
                        return {
                            field: item.field,
                            order: item.order,
                            orderFn: sortFunc ?? defaultOrderFn
                        };
                    }));
                    this.internalProps.layoutMap.clearCellRangeMap();
                    this.internalProps.useOneRowHeightFillAll = false;
                    this.scenegraph.sortCell();
                }
            }
            if (sortState.length) {
                this.stateManager.updateSortState(sortState);
            }
        }
        updateFilterRules(filterRules) {
            this.scenegraph.clearCells();
            if (this.sortState) {
                this.dataSource.updateFilterRulesForSorted(filterRules);
                sortRecords(this);
            }
            else {
                this.dataSource.updateFilterRules(filterRules);
            }
            this.refreshRowColCount();
            this.stateManager.initCheckedState(this.records);
            this.scenegraph.createSceneGraph();
        }
        getCheckboxState(field) {
            if (this.stateManager.checkedState.size < this.rowCount - this.columnHeaderLevelCount) {
                this.stateManager.initLeftRecordsCheckState(this.records);
            }
            if (isValid$3(field)) {
                const keys = Array.from(this.stateManager.checkedState.keys()).sort((a, b) => {
                    const aArr = a.split(',');
                    const bArr = b.split(',');
                    const maxLength = Math.max(aArr.length, bArr.length);
                    for (let i = 0; i < maxLength; i++) {
                        const a = Number(aArr[i]) ?? 0;
                        const b = Number(bArr[i]) ?? 0;
                        if (a !== b) {
                            return a - b;
                        }
                    }
                    return 0;
                });
                let stateArr = keys.map(key => this.stateManager.checkedState.get(key));
                if (this.options.groupBy) {
                    stateArr = getGroupCheckboxState(this);
                }
                return Array.from(stateArr, (state) => {
                    return state && state[field];
                });
            }
            return new Array(...this.stateManager.checkedState.values());
        }
        getCellCheckboxState(col, row) {
            const define = this.getBodyColumnDefine(col, row);
            const field = define?.field;
            const cellType = this.getCellType(col, row);
            if (isValid$3(field) && (cellType === 'checkbox' || cellType === 'switch')) {
                const dataIndex = this.dataSource.getIndexKey(this.getRecordShowIndexByCell(col, row)).toString();
                return this.stateManager.checkedState.get(dataIndex)?.[field];
            }
            return undefined;
        }
        getRadioState(field) {
            if (isValid$3(field)) {
                return this.stateManager.radioState[field];
            }
            return this.stateManager.radioState;
        }
        getCellRadioState(col, row) {
            return getCellRadioState(col, row, this);
        }
        setCellCheckboxState(col, row, checked) {
            setCellCheckboxState(col, row, checked, this);
        }
        setCellRadioState(col, row, index) {
            setCellRadioState(col, row, index, this);
        }
        getSwitchState(field) {
            return this.getCheckboxState(field);
        }
        getCellSwitchState(col, row) {
            return this.getCellCheckboxState(col, row);
        }
        setCellSwitchState(col, row, checked) {
            this.setCellCheckboxState(col, row, checked);
        }
        setRecords(records, option) {
            clearChartRenderQueue();
            this.internalProps.dataSource?.release();
            this.internalProps.releaseList = this.internalProps.releaseList?.filter((item) => !item.dataSourceObj);
            this.internalProps.dataSource = null;
            let sort;
            if (Array.isArray(option) || option?.order) {
                sort = option;
            }
            else if (option) {
                sort = option.sortState;
            }
            else if (option === null) {
                sort = null;
            }
            typeof window !== 'undefined' ? window.performance.now() : 0;
            const oldHoverState = { col: this.stateManager.hover.cellPos.col, row: this.stateManager.hover.cellPos.row };
            this.scenegraph.clearCells();
            if (sort !== undefined) {
                if (sort === null || (!Array.isArray(sort) && isValid$3(sort.field)) || Array.isArray(sort)) {
                    this.internalProps.sortState = this.internalProps.multipleSort ? (Array.isArray(sort) ? sort : [sort]) : sort;
                    this.stateManager.setSortState(this.sortState);
                }
            }
            if (records) {
                _setRecords(this, records);
                if (this.sortState) {
                    const sortState = Array.isArray(this.sortState) ? this.sortState : [this.sortState];
                    if (sortState.some((item) => item.order && item.field && item.order !== 'normal')) {
                        if (this.internalProps.layoutMap.headerObjectsIncludeHided.some(item => item.define.sort !== false)) {
                            this.dataSource.sort(sortState.map((item) => {
                                const sortFunc = this._getSortFuncFromHeaderOption(undefined, item.field);
                                this.internalProps.layoutMap.headerObjectsIncludeHided.find((col) => col && col.field === item.field);
                                return {
                                    field: item.field,
                                    order: item.order || 'asc',
                                    orderFn: sortFunc ?? defaultOrderFn
                                };
                            }));
                        }
                    }
                }
                this.refreshRowColCount();
            }
            else {
                _setRecords(this, records);
            }
            this.stateManager.initCheckedState(records);
            this.clearCellStyleCache();
            this.scenegraph.createSceneGraph();
            this.stateManager.updateHoverPos(oldHoverState.col, oldHoverState.row);
            if (this.internalProps.title && !this.internalProps.title.isReleased) {
                this._updateSize();
                this.internalProps.title.resize();
                this.scenegraph.resize();
            }
            if (this.options.emptyTip) {
                if (this.internalProps.emptyTip) {
                    this.internalProps.emptyTip?.resetVisible();
                }
                else {
                    const EmptyTip = Factory.getComponent('emptyTip');
                    this.internalProps.emptyTip = new EmptyTip(this.options.emptyTip, this);
                    this.internalProps.emptyTip?.resetVisible();
                }
            }
            this.render();
            if (isValid$3(oldHoverState.col) && isValid$3(oldHoverState.row) && oldHoverState.col >= 0 && oldHoverState.row >= 0) {
                setTimeout(() => {
                    this.internalProps?.tooltipHandler.showTooltip(oldHoverState.col, oldHoverState.row);
                }, 0);
            }
        }
        setRecordChildren(records, col, row, recalculateColWidths = true) {
            const record = this.getCellOriginRecord(col, row);
            record.children = records;
            const index = this.getRecordShowIndexByCell(col, row);
            this.dataSource.setRecord(record, index);
            this._refreshHierarchyState(col, row, recalculateColWidths);
        }
        startEditCell(col, row, value) {
            if (isValid$3(col) && isValid$3(row)) {
                this.eventManager.isDraging = false;
                this.selectCell(col, row);
                this.editorManager.startEditCell(col, row, value);
            }
            else if (this.stateManager.select?.cellPos) {
                const { col, row } = this.stateManager.select.cellPos;
                if (isValid$3(col) && isValid$3(row)) {
                    this.editorManager.startEditCell(col, row, value);
                }
            }
        }
        completeEditCell() {
            this.editorManager.completeEdit();
        }
        getEditor(col, row) {
            const define = this.getBodyColumnDefine(col, row);
            let editorDefine = this.isHeader(col, row)
                ? define?.headerEditor ?? this.options.headerEditor
                : define?.editor ?? this.options.editor;
            if (typeof editorDefine === 'function') {
                const arg = {
                    col,
                    row,
                    dataValue: this.getCellOriginValue(col, row),
                    value: this.getCellValue(col, row) || '',
                    table: this
                };
                editorDefine = editorDefine(arg);
            }
            if (typeof editorDefine === 'string') {
                return get(editorDefine);
            }
            return editorDefine;
        }
        isHasEditorDefine(col, row) {
            const define = this.getBodyColumnDefine(col, row);
            let editorDefine = this.isHeader(col, row)
                ? define?.headerEditor ?? this.options.headerEditor
                : define?.editor ?? this.options.editor;
            if (typeof editorDefine === 'function') {
                const arg = {
                    col,
                    row,
                    dataValue: this.getCellOriginValue(col, row),
                    value: this.getCellValue(col, row) || '',
                    table: this
                };
                editorDefine = editorDefine(arg);
            }
            return isValid$3(editorDefine);
        }
        changeCellValue(col, row, value, workOnEditableCell = false, triggerEvent = true) {
            return listTableChangeCellValue(col, row, value, workOnEditableCell, triggerEvent, this);
        }
        changeCellValues(startCol, startRow, values, workOnEditableCell = false, triggerEvent = true) {
            return listTableChangeCellValues(startCol, startRow, values, workOnEditableCell, triggerEvent, this);
        }
        addRecord(record, recordIndex) {
            listTableAddRecord(record, recordIndex, this);
            this.internalProps.emptyTip?.resetVisible();
        }
        addRecords(records, recordIndex) {
            listTableAddRecords(records, recordIndex, this);
            this.internalProps.emptyTip?.resetVisible();
        }
        deleteRecords(recordIndexs) {
            listTableDeleteRecords(recordIndexs, this);
            this.internalProps.emptyTip?.resetVisible();
        }
        updateRecords(records, recordIndexs) {
            listTableUpdateRecords(records, recordIndexs, this);
        }
        _hasCustomRenderOrLayout() {
            const { headerObjects } = this.internalProps.layoutMap;
            if (this.options.customRender) {
                return true;
            }
            for (let i = 0; i < headerObjects.length; i++) {
                const headerObject = headerObjects[i];
                if (headerObject?.define?.customLayout ||
                    headerObject?.define?.headerCustomLayout ||
                    headerObject?.define?.customRender ||
                    headerObject?.define?.headerCustomRender) {
                    return true;
                }
            }
            return false;
        }
        getAggregateValuesByField(field) {
            const columns = this.internalProps.layoutMap.getColumnByField(field);
            const results = [];
            for (let i = 0; i < columns.length; i++) {
                const aggregator = columns[i].columnDefine.aggregator;
                delete columns[i].columnDefine;
                if (aggregator) {
                    const columnAggregateValue = {
                        col: columns[i].col,
                        aggregateValue: null
                    };
                    columnAggregateValue.aggregateValue = [];
                    if (Array.isArray(aggregator)) {
                        for (let j = 0; j < aggregator.length; j++) {
                            columnAggregateValue.aggregateValue.push({
                                aggregationType: aggregator[j].type,
                                value: aggregator[j].value()
                            });
                        }
                    }
                    else {
                        columnAggregateValue.aggregateValue.push({
                            aggregationType: aggregator.type,
                            value: aggregator.value()
                        });
                    }
                    results.push(columnAggregateValue);
                }
            }
            return results;
        }
        isAggregation(col, row) {
            return this.internalProps.layoutMap.isAggregation(col, row);
        }
        getGroupTitleLevel(col, row) {
            if (!this.options.groupBy) {
                return undefined;
            }
            const indexArr = this.dataSource.getIndexKey(this.getRecordShowIndexByCell(col, row));
            const groupLength = this.dataSource.getGroupLength() ?? 0;
            let indexArrLngth = isArray$7(indexArr) ? indexArr.length - 1 : 0;
            if (groupLength > 0 && indexArrLngth === groupLength) {
                indexArrLngth = undefined;
            }
            return indexArrLngth;
        }
        getBodyRowIndexByRecordIndex(index) {
            if (Array.isArray(index) && index.length === 1) {
                index = index[0];
            }
            return this.dataSource.getTableIndex(index);
        }
        _parseColumnWidthConfig(columnWidthConfig) {
            for (let i = 0; i < columnWidthConfig?.length; i++) {
                const item = columnWidthConfig[i];
                const key = item.key;
                const width = item.width;
                const columnData = this.internalProps.layoutMap.getColumnByKey(key);
                if (columnData.columnDefine) {
                    const { col } = columnData;
                    if (!this.internalProps._widthResizedColMap.has(col)) {
                        this._setColWidth(col, width);
                        this.internalProps._widthResizedColMap.add(col);
                    }
                }
            }
        }
        release() {
            this.editorManager.release();
            super.release();
        }
    }

    function isXAxis(orient) {
        return orient === 'bottom' || orient === 'top';
    }
    function isYAxis(orient) {
        return orient === 'left' || orient === 'right';
    }

    var ScaleEnum;
    !function (ScaleEnum) {
      ScaleEnum.Identity = "identity", ScaleEnum.Linear = "linear", ScaleEnum.Log = "log", ScaleEnum.Pow = "pow", ScaleEnum.Sqrt = "sqrt", ScaleEnum.Symlog = "symlog", ScaleEnum.Time = "time", ScaleEnum.Quantile = "quantile", ScaleEnum.Quantize = "quantize", ScaleEnum.Threshold = "threshold", ScaleEnum.Ordinal = "ordinal", ScaleEnum.Point = "point", ScaleEnum.Band = "band";
    }(ScaleEnum || (ScaleEnum = {}));
    Object.values(ScaleEnum).forEach(v => {
    });

    function identity(x) {
      return x;
    }
    const logNegative = x => -Math.log(-x);
    const expNegative = x => -Math.exp(-x);
    const pow10 = x => isFinite(x) ? Math.pow(10, x) : x < 0 ? 0 : x;
    const powp = base => 10 === base ? pow10 : base === Math.E ? Math.exp : x => Math.pow(base, x);
    const logp = base => base === Math.E ? Math.log : 10 === base ? Math.log10 : 2 === base ? Math.log2 : (base = Math.log(base), x => Math.log(x) / base);
    const symlog = c => x => Math.sign(x) * Math.log1p(Math.abs(x / c));
    const symexp = c => x => Math.sign(x) * Math.expm1(Math.abs(x)) * c;
    function normalize(a, b) {
      if (a = Number(a), b = Number(b), b -= a) return x => (x - a) / b;
      const result = Number.isNaN(b) ? NaN : .5;
      return () => result;
    }
    function bimap(domain, range, interpolate) {
      const d0 = domain[0],
        d1 = domain[1],
        r0 = range[0],
        r1 = range[1];
      let d0Fuc, r0Fuc;
      return d1 < d0 ? (d0Fuc = normalize(d1, d0), r0Fuc = interpolate(r1, r0)) : (d0Fuc = normalize(d0, d1), r0Fuc = interpolate(r0, r1)), x => r0Fuc(d0Fuc(x));
    }
    function bandSpace$1(count, paddingInner, paddingOuter) {
      let space;
      return space = 1 === count ? count + 2 * paddingOuter : count - paddingInner + 2 * paddingOuter, count ? space > 0 ? space : 1 : 0;
    }
    function scaleWholeRangeSize$1(count, bandwidth, paddingInner, paddingOuter) {
      1 === paddingInner && (paddingInner = 0);
      return bandSpace$1(count, paddingInner, paddingOuter) * (bandwidth / (1 - paddingInner));
    }
    function calculateBandwidthFromWholeRangeSize(count, wholeSize, paddingInner, paddingOuter, round) {
      const space = bandSpace$1(count, paddingInner, paddingOuter);
      let step = wholeSize / Math.max(1, space || 1);
      round && (step = Math.floor(step));
      let bandwidth = step * (1 - paddingInner);
      return round && (bandwidth = Math.round(bandwidth)), bandwidth;
    }
    function calculateWholeRangeFromRangeFactor(range, rangeFactor) {
      const k = (range[1] - range[0]) / (rangeFactor[1] - rangeFactor[0]),
        b = range[0] - k * rangeFactor[0];
      return [b, k + b];
    }
    function polymap(domain, range, interpolate) {
      const j = Math.min(domain.length, range.length) - 1,
        d = new Array(j),
        r = new Array(j);
      let i = -1;
      for (domain[j] < domain[0] && (domain = domain.slice().reverse(), range = range.slice().reverse()); ++i < j;) d[i] = normalize(domain[i], domain[i + 1]), r[i] = interpolate(range[i], range[i + 1]);
      return function (x) {
        const i = bisect(domain, x, 1, j) - 1;
        return r[i](d[i](x));
      };
    }
    const nice = (domain, options) => {
      const newDomain = domain.slice();
      let startIndex = 0,
        endIndex = newDomain.length - 1,
        x0 = newDomain[startIndex],
        x1 = newDomain[endIndex];
      return x1 < x0 && ([startIndex, endIndex] = [endIndex, startIndex], [x0, x1] = [x1, x0]), newDomain[startIndex] = options.floor(x0), newDomain[endIndex] = options.ceil(x1), newDomain;
    };
    const niceNumber = function (value) {
      let round = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
      const exponent = Math.floor(Math.log10(value)),
        fraction = value / Math.pow(10, exponent);
      let niceFraction;
      return niceFraction = round ? fraction < 1.5 ? 1 : fraction < 3 ? 2 : fraction < 7 ? 5 : 10 : fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10, niceFraction * Math.pow(10, exponent);
    };
    const restrictNumber = (value, domain) => {
      let min, max;
      return domain[0] < domain[1] ? (min = domain[0], max = domain[1]) : (min = domain[1], max = domain[0]), Math.min(Math.max(value, min), max);
    };

    class BaseScale {
      constructor() {
        this._rangeFactorStart = null, this._rangeFactorEnd = null;
      }
      _calculateWholeRange(range) {
        return this._wholeRange ? this._wholeRange : isValid$1(this._rangeFactorStart) && isValid$1(this._rangeFactorEnd) && 2 === range.length ? (this._wholeRange = calculateWholeRangeFromRangeFactor(range, [this._rangeFactorStart, this._rangeFactorEnd]), this._wholeRange) : range;
      }
      rangeFactor(_, slience, clear) {
        return _ ? (2 === _.length && _.every(r => r >= 0 && r <= 1) && (this._wholeRange = null, 0 === _[0] && 1 === _[1] ? (this._rangeFactorStart = null, this._rangeFactorEnd = null) : (this._rangeFactorStart = _[0], this._rangeFactorEnd = _[1])), this) : clear ? (this._wholeRange = null, this._rangeFactorStart = null, this._rangeFactorEnd = null, this) : isValid$1(this._rangeFactorStart) && isValid$1(this._rangeFactorEnd) ? [this._rangeFactorStart, this._rangeFactorEnd] : null;
      }
      rangeFactorStart(_, slience) {
        var _a;
        return isNil$1(_) ? this._rangeFactorStart : (_ >= 0 && _ <= 1 && (this._wholeRange = null, 0 !== _ || !isNil$1(this._rangeFactorEnd) && 1 !== this._rangeFactorEnd ? (this._rangeFactorStart = _, this._rangeFactorEnd = null !== (_a = this._rangeFactorEnd) && void 0 !== _a ? _a : 1) : (this._rangeFactorStart = null, this._rangeFactorEnd = null)), this);
      }
      rangeFactorEnd(_, slience) {
        var _a;
        return isNil$1(_) ? this._rangeFactorEnd : (_ >= 0 && _ <= 1 && (this._wholeRange = null, 0 !== _ || !isNil$1(this._rangeFactorStart) && 0 !== this._rangeFactorStart ? (this._rangeFactorEnd = _, this._rangeFactorStart = null !== (_a = this._rangeFactorStart) && void 0 !== _a ? _a : 0) : (this._rangeFactorStart = null, this._rangeFactorEnd = null)), this);
      }
      generateFishEyeTransform() {
        var _a;
        if (!this._fishEyeOptions) return void (this._fishEyeTransform = null);
        const {
            distortion = 2,
            radiusRatio = .1,
            radius: radius
          } = this._fishEyeOptions,
          range = this.range(),
          first = range[0],
          last = range[range.length - 1],
          min = Math.min(first, last),
          max = Math.max(first, last),
          focus = clamp$1(null !== (_a = this._fishEyeOptions.focus) && void 0 !== _a ? _a : 0, min, max),
          rangeRadius = isNil$1(radius) ? (max - min) * radiusRatio : radius;
        let k0 = Math.exp(distortion);
        k0 = k0 / (k0 - 1) * rangeRadius;
        const k1 = distortion / rangeRadius;
        this._fishEyeTransform = output => {
          const delta = Math.abs(output - focus);
          if (delta >= rangeRadius) return output;
          if (delta <= 1e-6) return focus;
          const k = k0 * (1 - Math.exp(-delta * k1)) / delta * .75 + .25;
          return focus + (output - focus) * k;
        };
      }
      unknown(_) {
        return arguments.length ? (this._unknown = _, this) : this._unknown;
      }
      get(key, defaultValue) {
        var _a;
        return null !== (_a = null == this ? void 0 : this[key]) && void 0 !== _a ? _a : defaultValue;
      }
    }

    const implicit = Symbol("implicit");
    class OrdinalScale extends BaseScale {
      specified(_) {
        var _a;
        return _ ? (this._specified = Object.assign(null !== (_a = this._specified) && void 0 !== _a ? _a : {}, _), this) : Object.assign({}, this._specified);
      }
      _getSpecifiedValue(input) {
        if (this._specified) return this._specified[input];
      }
      constructor() {
        super(), this.type = ScaleEnum.Ordinal, this._index = new Map(), this._domain = [], this._ordinalRange = [], this._unknown = implicit;
      }
      clone() {
        const s = new OrdinalScale().domain(this._domain).range(this._ordinalRange).unknown(this._unknown);
        return this._specified && s.specified(this._specified), s;
      }
      calculateVisibleDomain(range) {
        if (isValid$1(this._rangeFactorStart) && isValid$1(this._rangeFactorEnd) && 2 === range.length) {
          return [this.invert(range[0]), this.invert(range[1])];
        }
        return this._domain;
      }
      scale(d) {
        const key = `${d}`,
          special = this._getSpecifiedValue(key);
        if (void 0 !== special) return special;
        let i = this._index.get(key);
        if (!i) {
          if (this._unknown !== implicit) return this._unknown;
          i = this._domain.push(d), this._index.set(key, i);
        }
        const output = this._ordinalRange[(i - 1) % this._ordinalRange.length];
        return this._fishEyeTransform ? this._fishEyeTransform(output) : output;
      }
      invert(d) {
        let i = 0;
        for (; i < this._ordinalRange.length && this._ordinalRange[i] !== d;) i++;
        return this._domain[(i - 1) % this._domain.length];
      }
      domain(_) {
        if (!_) return this._domain.slice();
        this._domain = [], this._index = new Map();
        for (const value of _) {
          const key = `${value}`;
          this._index.has(key) || this._index.set(key, this._domain.push(value));
        }
        return this;
      }
      range(_) {
        if (!_) return this._ordinalRange.slice();
        const nextRange = Array.from(_);
        return this._ordinalRange = nextRange, this;
      }
      index(x) {
        var _a;
        return this._index && null !== (_a = this._index.get(`${x}`)) && void 0 !== _a ? _a : -1;
      }
    }

    function generateTicks(start, stop, step, reverse) {
      const ticks = [];
      let ptr = start;
      for (; ptr <= stop;) ticks.push(ptr), ptr += step;
      return reverse && ticks.reverse(), ticks;
    }
    function ticks$1(start, stop, count, allowExcessive) {
      let reverse, step;
      if (stop = Math.floor(+stop), start = Math.floor(+start), !(count = Math.floor(+count))) return [];
      if (start === stop) return [start];
      if (reverse = stop < start) {
        const n = start;
        start = stop, stop = n;
      }
      let expectedCount = clamper(1, stop - start + 1)(count);
      if (step = Math.floor((stop - start + 1) / expectedCount), !allowExcessive) for (; Math.ceil((stop - start + 1) / step) > count && expectedCount > 1;) expectedCount -= 1, step = Math.floor((stop - start) / expectedCount);
      return generateTicks(start, stop, step, reverse);
    }
    function stepTicks$1(start, stop, step) {
      let reverse;
      if (stop = Math.floor(+stop), start = Math.floor(+start), step = clamper(1, stop - start + 1)(Math.floor(+step)), reverse = stop < start) {
        const n = start;
        start = stop, stop = n;
      }
      return generateTicks(start, stop, step, reverse);
    }

    class BandScale extends OrdinalScale {
      constructor(slience) {
        super(), this.type = ScaleEnum.Band, this._range = [0, 1], this._step = void 0, this._bandwidth = void 0, this._isFixed = !1, this._round = !1, this._paddingInner = 0, this._paddingOuter = 0, this._align = .5, this._unknown = void 0, delete this.unknown, this.rescale(slience);
      }
      rescale(slience, changeProperty) {
        if (slience) return this;
        this._wholeRange = null;
        const wholeRange = this._calculateWholeRange(this._range, changeProperty),
          n = super.domain().length,
          reverse = wholeRange[1] < wholeRange[0];
        let start = wholeRange[Number(reverse) - 0];
        const stop = wholeRange[1 - Number(reverse)],
          space = bandSpace$1(n, this._paddingInner, this._paddingOuter);
        return this._step = (stop - start) / Math.max(1, space || 1), this._round && (this._step = Math.floor(this._step)), start += (stop - start - this._step * (n - this._paddingInner)) * this._align, this.isBandwidthFixed() || (this._bandwidth = this._step * (1 - this._paddingInner)), this._round && (start = Math.round(start), this.isBandwidthFixed() || (this._bandwidth = Math.round(this._bandwidth))), this._bandRangeState = {
          reverse: reverse,
          start: reverse ? start + this._step * (n - 1) : start,
          count: n
        }, this.generateFishEyeTransform(), this;
      }
      scale(d) {
        if (!this._bandRangeState) return;
        const key = `${d}`,
          special = this._getSpecifiedValue(key);
        if (void 0 !== special) return special;
        let i = this._index.get(key);
        if (!i) {
          if (this._unknown !== implicit) return this._unknown;
          i = this._domain.push(d), this._index.set(key, i);
        }
        const {
            count: count,
            start: start,
            reverse: reverse
          } = this._bandRangeState,
          output = start + (reverse ? -1 : 1) * ((i - 1) % count) * this._step;
        return this._fishEyeTransform ? this._fishEyeTransform(output) : output;
      }
      _calculateWholeRange(range, changeProperty) {
        if (this._wholeRange) return this._wholeRange;
        if ((this._minBandwidth || this._maxBandwidth) && !this._isBandwidthFixedByUser()) {
          let wholeSize;
          if (isValid$1(this._rangeFactorStart) && isValid$1(this._rangeFactorEnd) && 2 === range.length) {
            const wholeRange = calculateWholeRangeFromRangeFactor(range, [this._rangeFactorStart, this._rangeFactorEnd]);
            wholeSize = Math.abs(wholeRange[1] - wholeRange[0]);
          } else wholeSize = Math.abs(range[1] - range[0]);
          const autoBandwidth = calculateBandwidthFromWholeRangeSize(super.domain().length, wholeSize, this._paddingInner, this._paddingOuter, this._round);
          autoBandwidth < this._minBandwidth ? (this._bandwidth = this._minBandwidth, this._isFixed = !0) : autoBandwidth > this._maxBandwidth ? (this._bandwidth = this._maxBandwidth, this._isFixed = !0) : (this._bandwidth = autoBandwidth, this._isFixed = !1);
        }
        if (this.isBandwidthFixed()) {
          const wholeLength = scaleWholeRangeSize$1(super.domain().length, this._bandwidth, this._paddingInner, this._paddingOuter) * Math.sign(range[1] - range[0]),
            rangeFactorSize = Math.min((range[1] - range[0]) / wholeLength, 1);
          if (isValid$1(this._rangeFactorStart) && isValid$1(this._rangeFactorEnd)) {
            if (wholeLength > 0) {
              const r0 = range[0] - wholeLength * this._rangeFactorStart,
                r1 = r0 + wholeLength;
              this._wholeRange = [r0, r1];
            } else {
              const r1 = range[1] + wholeLength * (1 - this._rangeFactorEnd),
                r0 = r1 - wholeLength;
              this._wholeRange = [r0, r1];
            }
            const canAlignStart = this._rangeFactorStart + rangeFactorSize <= 1,
              canAlignEnd = this._rangeFactorEnd - rangeFactorSize >= 0;
            "rangeFactorStart" === changeProperty && canAlignStart ? this._rangeFactorEnd = this._rangeFactorStart + rangeFactorSize : "rangeFactorEnd" === changeProperty && canAlignEnd ? this._rangeFactorStart = this._rangeFactorEnd - rangeFactorSize : range[0] <= range[1] ? canAlignStart ? this._rangeFactorEnd = this._rangeFactorStart + rangeFactorSize : canAlignEnd ? this._rangeFactorStart = this._rangeFactorEnd - rangeFactorSize : (this._rangeFactorStart = 0, this._rangeFactorEnd = rangeFactorSize) : canAlignEnd ? this._rangeFactorStart = this._rangeFactorEnd - rangeFactorSize : canAlignStart ? this._rangeFactorEnd = this._rangeFactorStart + rangeFactorSize : (this._rangeFactorStart = 1 - rangeFactorSize, this._rangeFactorEnd = 1);
          } else this._rangeFactorStart = 0, this._rangeFactorEnd = rangeFactorSize, this._wholeRange = [range[0], range[0] + wholeLength];
          return this._wholeRange;
        }
        return super._calculateWholeRange(range);
      }
      calculateWholeRangeSize() {
        const wholeRange = this._calculateWholeRange(this._range);
        return Math.abs(wholeRange[1] - wholeRange[0]);
      }
      calculateVisibleDomain(range) {
        const domain = this._domain;
        if (isValid$1(this._rangeFactorStart) && isValid$1(this._rangeFactorEnd) && domain.length) {
          const d0 = this._getInvertIndex(range[0]),
            d1 = this._getInvertIndex(range[1]);
          return domain.slice(Math.min(d0, d1), Math.max(d0, d1) + 1);
        }
        return domain;
      }
      domain(_, slience) {
        return _ ? (super.domain(_), this.rescale(slience)) : super.domain();
      }
      range(_, slience) {
        return _ ? (this._range = [toNumber(_[0]), toNumber(_[1])], this.rescale(slience)) : this._range;
      }
      rangeRound(_, slience) {
        return this._range = [toNumber(_[0]), toNumber(_[1])], this._round = !0, this.rescale(slience);
      }
      ticks() {
        let count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;
        const d = this.calculateVisibleDomain(this._range);
        if (-1 === count) return d;
        return ticks$1(0, d.length - 1, count, !1).map(i => d[i]);
      }
      tickData() {
        let count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;
        return this.ticks(count).map((tick, index) => ({
          index: index,
          tick: tick,
          value: (this.scale(tick) - this._range[0] + this._bandwidth / 2) / (this._range[1] - this._range[0])
        }));
      }
      forceTicks() {
        let count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;
        const d = this.calculateVisibleDomain(this._range);
        return ticks$1(0, d.length - 1, count, !0).filter(i => i < d.length).map(i => d[i]);
      }
      stepTicks(step) {
        const d = this.calculateVisibleDomain(this._range);
        return stepTicks$1(0, d.length - 1, step).map(i => d[i]);
      }
      _getInvertIndex(d) {
        let i = 0;
        const halfStep = this.step() / 2,
          halfBandwidth = this.bandwidth() / 2,
          len = this._domain.length,
          range = this.range(),
          reverse = range[0] > range[range.length - 1];
        for (i = 0; i < len; i++) {
          const r = this.scale(this._domain[i]) + halfBandwidth;
          if (0 === i && (!reverse && !isGreater(d, r + halfStep) || reverse && !isLess(d, r - halfStep))) break;
          if (i === len - 1) break;
          if (!isLess(d, r - halfStep) && !isGreater(d, r + halfStep)) break;
        }
        return i >= 0 && i <= len - 1 ? i : len - 1;
      }
      invert(d) {
        return this._domain[this._getInvertIndex(d)];
      }
      padding(p, slience) {
        return void 0 !== p ? (this._paddingOuter = Math.max(0, Math.min(Array.isArray(p) ? Math.min.apply(null, p) : p)), this._paddingInner = this._paddingOuter, this.rescale(slience)) : this._paddingInner;
      }
      paddingInner(_, slience) {
        return void 0 !== _ ? (this._paddingInner = Math.max(0, Math.min(1, _)), this.rescale(slience)) : this._paddingInner;
      }
      paddingOuter(_, slience) {
        return void 0 !== _ ? (this._paddingOuter = Math.max(0, Math.min(1, _)), this.rescale(slience)) : this._paddingOuter;
      }
      step() {
        return this._step;
      }
      round(_, slience) {
        return void 0 !== _ ? (this._round = _, this.rescale(slience)) : this._round;
      }
      align(_, slience) {
        return void 0 !== _ ? (this._align = Math.max(0, Math.min(1, _)), this.rescale(slience)) : this._align;
      }
      rangeFactor(_, slience) {
        return _ ? (super.rangeFactor(_), this.rescale(slience)) : super.rangeFactor();
      }
      rangeFactorStart(_, slience) {
        return isNil$1(_) ? super.rangeFactorStart() : (super.rangeFactorStart(_), this.rescale(slience, "rangeFactorStart"));
      }
      rangeFactorEnd(_, slience) {
        return isNil$1(_) ? super.rangeFactorEnd() : (super.rangeFactorEnd(_), this.rescale(slience, "rangeFactorEnd"));
      }
      bandwidth(_, slience) {
        return _ ? ("auto" === _ ? (this._bandwidth = void 0, this._isFixed = !1) : (this._bandwidth = _, this._isFixed = !0), this._userBandwidth = _, this.rescale(slience)) : this._bandwidth;
      }
      maxBandwidth(_, slience) {
        return _ ? (this._maxBandwidth = "auto" === _ ? void 0 : _, this.rescale(slience)) : this._maxBandwidth;
      }
      minBandwidth(_, slience) {
        return _ ? (this._minBandwidth = "auto" === _ ? void 0 : _, this.rescale(slience)) : this._minBandwidth;
      }
      fishEye(options, slience, clear) {
        return options || clear ? (this._fishEyeOptions = options, this._fishEyeTransform = null, this.rescale(slience)) : this._fishEyeOptions;
      }
      isBandwidthFixed() {
        return this._isFixed && !!this._bandwidth;
      }
      _isBandwidthFixedByUser() {
        return this._isFixed && this._userBandwidth && isNumber$1(this._userBandwidth);
      }
      clone() {
        var _a, _b, _c;
        return new BandScale(!0).domain(this._domain, !0).range(this._range, !0).round(this._round, !0).paddingInner(this._paddingInner, !0).paddingOuter(this._paddingOuter, !0).align(this._align, !0).bandwidth(null !== (_a = this._userBandwidth) && void 0 !== _a ? _a : "auto", !0).maxBandwidth(null !== (_b = this._maxBandwidth) && void 0 !== _b ? _b : "auto", !0).minBandwidth(null !== (_c = this._maxBandwidth) && void 0 !== _c ? _c : "auto");
      }
    }

    const {
      interpolateRgb: interpolateRgb
    } = ColorUtil;
    function interpolate(a, b) {
      const t = typeof b;
      let c;
      if (isNil$1(b) || "boolean" === t) return () => b;
      if ("number" === t) return interpolateNumber(a, b);
      if ("string" === t) {
        if (c = Color.parseColorString(b)) {
          const rgb = interpolateRgb(Color.parseColorString(a), c);
          return t => rgb(t).formatRgb();
        }
        return interpolateNumber(Number(a), Number(b));
      }
      return b instanceof RGB ? interpolateRgb(a, b) : b instanceof Color ? interpolateRgb(a.color, b.color) : b instanceof Date ? interpolateDate(a, b) : interpolateNumber(Number(a), Number(b));
    }

    class ContinuousScale extends BaseScale {
      constructor() {
        let transformer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : identity;
        let untransformer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity;
        super(), this._unknown = void 0, this.transformer = transformer, this.untransformer = untransformer, this._forceAlign = !0, this._domain = [0, 1], this._range = [0, 1], this._clamp = identity, this._piecewise = bimap, this._interpolate = interpolate;
      }
      calculateVisibleDomain(range) {
        var _a;
        if (isValid$1(this._rangeFactorStart) && isValid$1(this._rangeFactorEnd) && 2 === range.length) {
          return [this.invert(range[0]), this.invert(range[1])];
        }
        return null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain;
      }
      fishEye(options, slience, clear) {
        return options || clear ? (this._fishEyeOptions = options, this._fishEyeTransform = null, this.rescale(slience)) : this._fishEyeOptions;
      }
      scale(x) {
        var _a;
        if (x = Number(x), Number.isNaN(x) || this._domainValidator && !this._domainValidator(x)) return this._unknown;
        this._output || (this._output = this._piecewise((null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain).map(this.transformer), this._calculateWholeRange(this._range), this._interpolate));
        const output = this._output(this.transformer(this._clamp(x)));
        return this._fishEyeTransform ? this._fishEyeTransform(output) : output;
      }
      invert(y) {
        var _a;
        return this._input || (this._input = this._piecewise(this._calculateWholeRange(this._range), (null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain).map(this.transformer), interpolateNumber)), this._clamp(this.untransformer(this._input(y)));
      }
      domain(_, slience) {
        var _a;
        if (!_) return (null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain).slice();
        this._domainValidator = null, this._niceType = null, this._niceDomain = null;
        const nextDomain = Array.from(_, toNumber);
        return this._domain = nextDomain, this.rescale(slience);
      }
      range(_, slience) {
        if (!_) return this._range.slice();
        const nextRange = Array.from(_);
        return this._range = nextRange, this.rescale(slience);
      }
      rangeRound(_, slience) {
        const nextRange = Array.from(_);
        return this._range = nextRange, this._interpolate = interpolateNumberRound, this.rescale(slience);
      }
      rescale(slience) {
        var _a;
        if (slience) return this;
        const domain = null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain,
          domainLength = domain.length,
          rangeLength = this._range.length;
        let n = Math.min(domainLength, rangeLength);
        if (domainLength && domainLength < rangeLength && this._forceAlign) {
          const deltaStep = rangeLength - domainLength + 1,
            last = domain[domainLength - 1],
            delta = domainLength >= 2 ? (last - domain[domainLength - 2]) / deltaStep : 0;
          for (let i = 1; i <= deltaStep; i++) domain[domainLength - 2 + i] = last - delta * (deltaStep - i);
          n = rangeLength;
        }
        return this._autoClamp && (this._clamp = clamper(domain[0], domain[n - 1])), this._piecewise = n > 2 ? polymap : bimap, this._output = this._input = null, this._wholeRange = null, this.generateFishEyeTransform(), this;
      }
      clamp(_, f, slience) {
        return arguments.length ? (f ? (this._autoClamp = !1, this._clamp = f) : (this._autoClamp = !!_, this._clamp = _ ? void 0 : identity), this.rescale(slience)) : this._clamp !== identity;
      }
      interpolate(_, slience) {
        return arguments.length ? (this._interpolate = _, this.rescale(slience)) : this._interpolate;
      }
      ticks() {
        return [];
      }
      tickData() {
        let count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;
        const ticks = this.ticks(count);
        return (null != ticks ? ticks : []).map((tick, index) => ({
          index: index,
          tick: tick,
          value: (this.scale(tick) - this._range[0]) / (this._range[1] - this._range[0])
        }));
      }
      rangeFactor(_, slience) {
        return _ ? (super.rangeFactor(_), this._output = this._input = null, this) : super.rangeFactor();
      }
      rangeFactorStart(_, slience) {
        return isNil$1(_) ? super.rangeFactorStart() : (super.rangeFactorStart(_), this._output = this._input = null, this);
      }
      rangeFactorEnd(_, slience) {
        return isNil$1(_) ? super.rangeFactorEnd() : (super.rangeFactorEnd(_), this._output = this._input = null, this);
      }
      forceAlignDomainRange(forceAlign) {
        return arguments.length ? (this._forceAlign = forceAlign, this) : this._forceAlign;
      }
    }

    const e10$1 = Math.sqrt(50),
      e5$1 = Math.sqrt(10),
      e2$1 = Math.sqrt(2),
      niceNumbers = [1, 2, 5, 10];
    const calculateTicksOfSingleValue = (value, tickCount, noDecimals) => {
      let step = 1,
        start = value;
      const middleIndex = Math.floor((tickCount - 1) / 2),
        absVal = Math.abs(value);
      return value >= 0 && value <= Number.MIN_VALUE ? start = 0 : value < 0 && value >= -Number.MIN_VALUE ? start = -(tickCount - 1) : !noDecimals && absVal < 1 ? step = getNickStep(absVal).step : (noDecimals || absVal > 1) && (start = Math.floor(value) - middleIndex * step), step > 0 ? (value > 0 ? start = Math.max(start, 0) : value < 0 && (start = Math.min(start, -(tickCount - 1) * step)), range(0, tickCount).map(index => start + index * step)) : value > 0 ? calculateTicksByStep(0, -(tickCount - 1) / step, step) : calculateTicksByStep((tickCount - 1) / step, 0, step);
    };
    const d3Ticks = memoize((start, stop, count, options) => {
      let reverse,
        n,
        ticks,
        step,
        i = -1;
      if (count = +count, (start = +start) === (stop = +stop)) return [start];
      if (Math.abs(start - stop) <= Number.MIN_VALUE && count > 0) return [start];
      if ((reverse = stop < start) && (n = start, start = stop, stop = n), step = tickIncrement(start, stop, count).step, !isFinite(step)) return [];
      if (step > 0) {
        let r0 = Math.round(start / step),
          r1 = Math.round(stop / step);
        for (r0 * step < start && ++r0, r1 * step > stop && --r1, ticks = new Array(n = r1 - r0 + 1); ++i < n;) ticks[i] = (r0 + i) * step;
      } else if (step < 0 && (null == options ? void 0 : options.noDecimals)) {
        step = 1;
        const r0 = Math.ceil(start),
          r1 = Math.floor(stop);
        if (!(r0 <= r1)) return [];
        for (ticks = new Array(n = r1 - r0 + 1); ++i < n;) ticks[i] = r0 + i;
      } else {
        step = -step;
        let r0 = Math.round(start * step),
          r1 = Math.round(stop * step);
        for (r0 / step < start && ++r0, r1 / step > stop && --r1, ticks = new Array(n = r1 - r0 + 1); ++i < n;) ticks[i] = (r0 + i) / step;
      }
      return reverse && ticks.reverse(), ticks;
    });
    const calculateTicksByStep = (start, stop, step) => {
      let n,
        ticks,
        i = -1;
      if (step > 0) {
        let r0 = Math.floor(start / step),
          r1 = Math.ceil(stop / step);
        for ((r0 + 1) * step < start && ++r0, (r1 - 1) * step > stop && --r1, ticks = new Array(n = r1 - r0 + 1); ++i < n;) ticks[i] = (r0 + i) * step;
      } else {
        step = -step;
        let r0 = Math.floor(start * step),
          r1 = Math.ceil(stop * step);
        for ((r0 + 1) / step < start && ++r0, (r1 - 1) / step > stop && --r1, ticks = new Array(n = r1 - r0 + 1); ++i < n;) ticks[i] = (r0 + i) / step;
      }
      return ticks;
    };
    const appendTicksToCount = (ticks, count, step) => {
      let n;
      const firstTick = ticks[0],
        lastTick = ticks[ticks.length - 1],
        appendCount = count - ticks.length;
      if (lastTick <= 0) {
        const headTicks = [];
        for (n = appendCount; n >= 1; n--) headTicks.push(firstTick - n * step);
        return headTicks.concat(ticks);
      }
      if (firstTick >= 0) {
        for (n = 1; n <= appendCount; n++) ticks.push(lastTick + n * step);
        return ticks;
      }
      let headTicks = [];
      const tailTicks = [];
      for (n = 1; n <= appendCount; n++) n % 2 == 0 ? headTicks = [firstTick - Math.floor(n / 2) * step].concat(headTicks) : tailTicks.push(lastTick + Math.ceil(n / 2) * step);
      return headTicks.concat(ticks).concat(tailTicks);
    };
    const ticks = memoize((start, stop, count, options) => {
      let reverse, ticks, n;
      if (count = +count, (start = +start) === (stop = +stop)) return calculateTicksOfSingleValue(start, count, null == options ? void 0 : options.noDecimals);
      if (Math.abs(start - stop) <= Number.MIN_VALUE && count > 0) return calculateTicksOfSingleValue(start, count, null == options ? void 0 : options.noDecimals);
      (reverse = stop < start) && (n = start, start = stop, stop = n);
      const stepRes = tickIncrement(start, stop, count);
      let step = stepRes.step;
      if (!isFinite(step)) return [];
      if (step > 0) {
        let cur = 1;
        const {
            power: power,
            gap: gap
          } = stepRes,
          delatStep = 10 === gap ? 2 * 10 ** power : 1 * 10 ** power;
        for (; cur <= 5 && (ticks = calculateTicksByStep(start, stop, step), ticks.length > count + 1) && count > 2;) step += delatStep, cur += 1;
        count > 2 && ticks.length < count - 1 && (ticks = appendTicksToCount(ticks, count, step));
      } else (null == options ? void 0 : options.noDecimals) && step < 0 && (step = 1), ticks = calculateTicksByStep(start, stop, step);
      return reverse && ticks.reverse(), ticks;
    });
    const getNickStep = step => {
      const power = Math.floor(Math.log(step) / Math.LN10),
        error = step / 10 ** power;
      let gap = niceNumbers[0];
      return error >= e10$1 ? gap = niceNumbers[3] : error >= e5$1 ? gap = niceNumbers[2] : error >= e2$1 && (gap = niceNumbers[1]), power >= 0 ? {
        step: gap * 10 ** power,
        gap: gap,
        power: power
      } : {
        step: -(10 ** -power) / gap,
        gap: gap,
        power: power
      };
    };
    function tickIncrement(start, stop, count) {
      const step = (stop - start) / Math.max(0, count);
      return getNickStep(step);
    }
    function forceTicks(start, stop, count) {
      let step;
      if (count = +count, (start = +start) === (stop = +stop) && count > 0) return [start];
      if (count <= 0 || 0 === (step = forceTickIncrement(start, stop, count)) || !isFinite(step)) return [];
      const ticks = new Array(count);
      for (let i = 0; i < count; i++) ticks[i] = start + i * step;
      return ticks;
    }
    function forceTickIncrement(start, stop, count) {
      return (stop - start) / Math.max(1, count - 1);
    }
    function stepTicks(start, stop, step) {
      let n,
        reverse,
        i = -1;
      if (step = +step, (reverse = (stop = +stop) < (start = +start)) && (n = start, start = stop, stop = n), !isFinite(step) || stop - start <= step) return [start];
      const count = Math.floor((stop - start) / step + 1),
        ticks = new Array(count);
      for (; ++i < count;) ticks[i] = start + i * step;
      return reverse && ticks.reverse(), ticks;
    }
    function niceLinear(d) {
      let count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;
      let prestep,
        step,
        i0 = 0,
        i1 = d.length - 1,
        start = d[i0],
        stop = d[i1],
        maxIter = 10;
      for (stop < start && (step = start, start = stop, stop = step, step = i0, i0 = i1, i1 = step); maxIter-- > 0;) {
        if (step = tickIncrement(start, stop, count).step, step === prestep) return d[i0] = start, d[i1] = stop, d;
        if (step > 0) start = Math.floor(start / step) * step, stop = Math.ceil(stop / step) * step;else {
          if (!(step < 0)) break;
          start = Math.ceil(start * step) / step, stop = Math.floor(stop * step) / step;
        }
        prestep = step;
      }
    }
    function parseNiceOptions(originalDomain, option) {
      const hasForceMin = isNumber$1(option.forceMin),
        hasForceMax = isNumber$1(option.forceMax);
      let niceType = null;
      const niceMinMax = [];
      let niceDomain = null;
      const domainValidator = hasForceMin && hasForceMax ? x => x >= option.forceMin && x <= option.forceMax : hasForceMin ? x => x >= option.forceMin : hasForceMax ? x => x <= option.forceMax : null;
      return hasForceMin ? niceMinMax[0] = option.forceMin : isNumber$1(option.min) && option.min <= Math.min(originalDomain[0], originalDomain[originalDomain.length - 1]) && (niceMinMax[0] = option.min), hasForceMax ? niceMinMax[1] = option.forceMax : isNumber$1(option.max) && option.max >= Math.max(originalDomain[0], originalDomain[originalDomain.length - 1]) && (niceMinMax[1] = option.max), isNumber$1(niceMinMax[0]) && isNumber$1(niceMinMax[1]) ? (niceDomain = originalDomain.slice(), niceDomain[0] = niceMinMax[0], niceDomain[niceDomain.length - 1] = niceMinMax[1]) : niceType = isNumber$1(niceMinMax[0]) || isNumber$1(niceMinMax[1]) ? isNumber$1(niceMinMax[0]) ? "max" : "min" : "all", {
        niceType: niceType,
        niceDomain: niceDomain,
        niceMinMax: niceMinMax,
        domainValidator: domainValidator
      };
    }
    const fixPrecision = (start, stop, value) => Math.abs(stop - start) < 1 ? +value.toFixed(1) : Math.round(+value);
    const d3TicksForLog = memoize((start, stop, count, base, transformer, untransformer, options) => {
      let u = start,
        v = stop;
      const r = v < u;
      r && ([u, v] = [v, u]);
      let k,
        t,
        i = transformer(u),
        j = transformer(v),
        z = [];
      if (!(base % 1) && j - i < count) {
        if (i = Math.floor(i), j = Math.ceil(j), u > 0) {
          for (; i <= j; ++i) for (k = 1; k < base; ++k) if (t = i < 0 ? k / untransformer(-i) : k * untransformer(i), !(t < u)) {
            if (t > v) break;
            z.push(t);
          }
        } else for (; i <= j; ++i) for (k = base - 1; k >= 1; --k) if (t = i > 0 ? k / untransformer(-i) : k * untransformer(i), !(t < u)) {
          if (t > v) break;
          z.push(t);
        }
        2 * z.length < count && (z = ticks(u, v, count));
      } else z = ticks(i, j, Math.min(j - i, count)).map(untransformer);
      return z = z.filter(t => 0 !== t), (null == options ? void 0 : options.noDecimals) && (z = Array.from(new Set(z.map(t => Math.floor(t))))), r ? z.reverse() : z;
    });
    const ticksBaseTransform = memoize((start, stop, count, base, transformer, untransformer) => {
      const ticksResult = [],
        ticksMap = {},
        startExp = transformer(start),
        stopExp = transformer(stop);
      let ticksExp = [];
      if (Number.isInteger(base)) ticksExp = ticks(startExp, stopExp, count);else {
        const stepExp = (stopExp - startExp) / (count - 1);
        for (let i = 0; i < count; i++) ticksExp.push(startExp + i * stepExp);
      }
      return ticksExp.forEach(tl => {
        const power = untransformer(tl),
          nicePower = Number.isInteger(base) ? fixPrecision(start, stop, power) : fixPrecision(start, stop, niceNumber(power)),
          scopePower = fixPrecision(start, stop, restrictNumber(nicePower, [start, stop]));
        !ticksMap[scopePower] && !isNaN(scopePower) && ticksExp.length > 1 && (ticksMap[scopePower] = 1, ticksResult.push(scopePower));
      }), ticksResult;
    });
    const forceTicksBaseTransform = memoize((start, stop, count, transformer, untransformer) => forceTicks(transformer(start), transformer(stop), count).map(te => niceNumber(untransformer(te))));

    class LinearScale extends ContinuousScale {
      constructor() {
        super(...arguments), this.type = ScaleEnum.Linear;
      }
      clone() {
        return new LinearScale().domain(this._domain, !0).range(this._range, !0).unknown(this._unknown).clamp(this.clamp(), null, !0).interpolate(this._interpolate);
      }
      tickFormat() {
        return () => {};
      }
      d3Ticks() {
        let count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;
        let options = arguments.length > 1 ? arguments[1] : undefined;
        const d = this.calculateVisibleDomain(this._range);
        return d3Ticks(d[0], d[d.length - 1], count, options);
      }
      ticks() {
        let count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;
        let options = arguments.length > 1 ? arguments[1] : undefined;
        var _a;
        if (isFunction$1(null == options ? void 0 : options.customTicks)) return options.customTicks(this, count);
        if (isValid$1(this._rangeFactorStart) && isValid$1(this._rangeFactorEnd) && (this._rangeFactorStart > 0 || this._rangeFactorEnd < 1) && 2 === this._range.length || !this._niceType) return this.d3Ticks(count, options);
        const curNiceDomain = null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain,
          originalDomain = this._domain,
          start = curNiceDomain[0],
          stop = curNiceDomain[curNiceDomain.length - 1];
        let ticksResult = ticks(originalDomain[0], originalDomain[originalDomain.length - 1], count, options);
        if (!ticksResult.length) return ticksResult;
        if (this._domainValidator) ticksResult = ticksResult.filter(this._domainValidator);else if ((ticksResult[0] !== start || ticksResult[ticksResult.length - 1] !== stop) && this._niceType) {
          const newNiceDomain = curNiceDomain.slice();
          if ("all" === this._niceType ? (newNiceDomain[0] = ticksResult[0], newNiceDomain[newNiceDomain.length - 1] = ticksResult[ticksResult.length - 1], this._niceDomain = newNiceDomain, this.rescale()) : "min" === this._niceType && ticksResult[0] !== start ? (newNiceDomain[0] = ticksResult[0], this._niceDomain = newNiceDomain, this.rescale()) : "max" === this._niceType && ticksResult[ticksResult.length - 1] !== stop && (newNiceDomain[newNiceDomain.length - 1] = ticksResult[ticksResult.length - 1], this._niceDomain = newNiceDomain, this.rescale()), "all" !== this._niceType) {
            const min = Math.min(newNiceDomain[0], newNiceDomain[newNiceDomain.length - 1]),
              max = Math.max(newNiceDomain[0], newNiceDomain[newNiceDomain.length - 1]);
            ticksResult = ticksResult.filter(entry => entry >= min && entry <= max);
          }
        }
        return ticksResult;
      }
      forceTicks() {
        let count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;
        const d = this.calculateVisibleDomain(this._range);
        return forceTicks(d[0], d[d.length - 1], count);
      }
      stepTicks(step) {
        const d = this.calculateVisibleDomain(this._range);
        return stepTicks(d[0], d[d.length - 1], step);
      }
      nice() {
        let count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;
        let option = arguments.length > 1 ? arguments[1] : undefined;
        var _a, _b;
        const originalDomain = this._domain;
        let niceMinMax = [];
        if (option) {
          const res = parseNiceOptions(originalDomain, option);
          if (niceMinMax = res.niceMinMax, this._domainValidator = res.domainValidator, this._niceType = res.niceType, res.niceDomain) return this._niceDomain = res.niceDomain, this.rescale(), this;
        } else this._niceType = "all";
        if (this._niceType) {
          const niceDomain = niceLinear(originalDomain.slice(), count);
          "min" === this._niceType ? niceDomain[niceDomain.length - 1] = null !== (_a = niceMinMax[1]) && void 0 !== _a ? _a : niceDomain[niceDomain.length - 1] : "max" === this._niceType && (niceDomain[0] = null !== (_b = niceMinMax[0]) && void 0 !== _b ? _b : niceDomain[0]), this._niceDomain = niceDomain, this.rescale();
        }
        return this;
      }
      niceMin() {
        let count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;
        this._niceType = "min";
        const maxD = this._domain[this._domain.length - 1],
          niceDomain = niceLinear(this.domain(), count);
        return niceDomain && (niceDomain[niceDomain.length - 1] = maxD, this._niceDomain = niceDomain, this.rescale()), this;
      }
      niceMax() {
        let count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;
        this._niceType = "max";
        const minD = this._domain[0],
          niceDomain = niceLinear(this._domain.slice(), count);
        return niceDomain && (niceDomain[0] = minD, this._niceDomain = niceDomain, this.rescale()), this;
      }
    }

    class LogNiceMixin {
      nice() {
        let option = arguments.length > 1 ? arguments[1] : undefined;
        var _b, _c, _d, _e;
        const originalDomain = this._domain;
        let niceMinMax = [],
          niceType = null;
        if (option) {
          const res = parseNiceOptions(originalDomain, option);
          if (niceMinMax = res.niceMinMax, this._domainValidator = res.domainValidator, niceType = res.niceType, res.niceDomain) return this._niceDomain = res.niceDomain, this.rescale(), this;
        } else niceType = "all";
        if (niceType) {
          const niceDomain = nice(originalDomain.slice(), null !== (_c = null === (_b = this.getNiceConfig) || void 0 === _b ? void 0 : _b.call(this)) && void 0 !== _c ? _c : {
            floor: x => Math.floor(x),
            ceil: x => Math.ceil(x)
          });
          return "min" === niceType ? niceDomain[niceDomain.length - 1] = null !== (_d = niceMinMax[1]) && void 0 !== _d ? _d : niceDomain[niceDomain.length - 1] : "max" === niceType && (niceDomain[0] = null !== (_e = niceMinMax[0]) && void 0 !== _e ? _e : niceDomain[0]), this._niceDomain = niceDomain, this.rescale(), this;
        }
        return this;
      }
      niceMin() {
        const maxD = this._domain[this._domain.length - 1];
        this.nice();
        const niceDomain = this._domain.slice();
        return this._domain && (niceDomain[niceDomain.length - 1] = maxD, this._niceDomain = niceDomain, this.rescale()), this;
      }
      niceMax() {
        const minD = this._domain[0];
        this.nice();
        const niceDomain = this._domain.slice();
        return this._domain && (niceDomain[0] = minD, this._niceDomain = niceDomain, this.rescale()), this;
      }
    }

    function reflect(f) {
      return x => -f(-x);
    }
    function limitPositiveZero() {
      let min = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Number.EPSILON;
      return x => Math.max(x, min);
    }
    function limitNegativeZero() {
      let min = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Number.EPSILON;
      return x => Math.min(x, -min);
    }
    class LogScale extends ContinuousScale {
      constructor() {
        super(logp(10), powp(10)), this.type = ScaleEnum.Log, this._limit = limitPositiveZero(), this._logs = this.transformer, this._pows = this.untransformer, this._domain = [1, 10], this._base = 10;
      }
      clone() {
        return new LogScale().domain(this._domain, !0).range(this._range, !0).unknown(this._unknown).clamp(this.clamp(), null, !0).interpolate(this._interpolate, !0).base(this._base);
      }
      rescale(slience) {
        var _a;
        if (slience) return this;
        super.rescale();
        const logs = logp(this._base),
          pows = powp(this._base);
        return (null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain)[0] < 0 ? (this._logs = reflect(logs), this._pows = reflect(pows), this._limit = limitNegativeZero(), this.transformer = logNegative, this.untransformer = expNegative) : (this._logs = logs, this._pows = pows, this._limit = limitPositiveZero(), this.transformer = this._logs, this.untransformer = pows), this;
      }
      scale(x) {
        var _a;
        if (x = Number(x), Number.isNaN(x) || this._domainValidator && !this._domainValidator(x)) return this._unknown;
        this._output || (this._output = this._piecewise((null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain).map(this._limit).map(this.transformer), this._calculateWholeRange(this._range), this._interpolate));
        const output = this._output(this.transformer(this._limit(this._clamp(x))));
        return this._fishEyeTransform ? this._fishEyeTransform(output) : output;
      }
      base(_, slience) {
        return arguments.length ? (this._base = _, this.rescale(slience)) : this._base;
      }
      tickFormat() {
        return identity;
      }
      d3Ticks() {
        let count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;
        let options = arguments.length > 1 ? arguments[1] : undefined;
        const d = this.domain(),
          u = this._limit(d[0]),
          v = this._limit(d[d.length - 1]);
        return d3TicksForLog(u, v, count, this._base, this.transformer, this.untransformer, options);
      }
      ticks() {
        let count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;
        const d = this.calculateVisibleDomain(this._range);
        return ticksBaseTransform(this._limit(d[0]), this._limit(d[d.length - 1]), count, this._base, this.transformer, this.untransformer);
      }
      forceTicks() {
        let count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;
        const d = this.calculateVisibleDomain(this._range);
        return forceTicksBaseTransform(d[0], d[d.length - 1], count, this.transformer, this.untransformer);
      }
      stepTicks(step) {
        const d = this.calculateVisibleDomain(this._range);
        return forceTicksBaseTransform(this._limit(d[0]), this._limit(d[d.length - 1]), step, this.transformer, this.untransformer);
      }
      getNiceConfig() {
        return {
          floor: x => this._pows(Math.floor(this._logs(this._limit(x)))),
          ceil: x => Math.abs(x) >= 1 ? Math.ceil(x) : this._pows(Math.ceil(this._logs(this._limit(x))))
        };
      }
    }
    mixin(LogScale, LogNiceMixin);

    class PointScale extends BandScale {
      constructor(slience) {
        super(!1), this.type = ScaleEnum.Point, this._padding = 0, this.paddingInner(1, slience), this.padding = this.paddingOuter, this.paddingInner = void 0, this.paddingOuter = void 0;
      }
    }

    class SymlogScale extends LinearScale {
      constructor() {
        super(symlog(1), symexp(1)), this.type = ScaleEnum.Symlog, this._const = 1;
      }
      clone() {
        return new SymlogScale().domain(this._domain, !0).range(this._range, !0).unknown(this._unknown).clamp(this.clamp(), null, !0).interpolate(this._interpolate, !0).constant(this._const);
      }
      constant(_, slience) {
        return arguments.length ? (this._const = _, this.transformer = symlog(_), this.untransformer = symexp(_), this.rescale(slience)) : this._const;
      }
      d3Ticks() {
        let count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;
        let options = arguments.length > 1 ? arguments[1] : undefined;
        const d = this.domain(),
          u = d[0],
          v = d[d.length - 1];
        return d3TicksForLog(u, v, count, this._const, this.transformer, this.untransformer, options);
      }
      ticks() {
        let count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;
        const d = this.calculateVisibleDomain(this._range);
        return ticksBaseTransform(d[0], d[d.length - 1], count, this._const, this.transformer, this.untransformer);
      }
      forceTicks() {
        let count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;
        const d = this.calculateVisibleDomain(this._range);
        return forceTicksBaseTransform(d[0], d[d.length - 1], count, this.transformer, this.untransformer);
      }
      stepTicks(step) {
        const d = this.calculateVisibleDomain(this._range);
        return forceTicksBaseTransform(d[0], d[d.length - 1], step, this.transformer, this.untransformer);
      }
    }
    mixin(SymlogScale, LogNiceMixin);

    class BandAxisScale {
        _scale;
        _scales;
        bandPadding;
        paddingInner;
        paddingOuter;
        constructor() {
            this._scale = new BandScale();
            this._scales = [this._scale];
        }
        valueToPosition(value) {
            const bandStart = this._scale.scale(value);
            return bandStart;
        }
        getPosition(values) {
            let position = 0;
            let bandScale = this._scale;
            if (this._scales.length === 1 || values.length === 1) {
                position = this.valueToPosition(values[0]);
            }
            else {
                const max = Math.min(values.length, this._scales.length);
                for (let i = 0; i < max; i++) {
                    position += this._scales[i].scale(values[i]);
                }
                bandScale = this._scales[max - 1];
            }
            return { position, bandScale };
        }
        calcScales(defalutBandInnerPadding, defalutBandOuterPadding) {
            const { bandPadding, paddingInner, paddingOuter } = this;
            const isBandPaddingArray = isArray$7(bandPadding);
            const isPaddingInnerArray = isArray$7(paddingInner);
            const isPaddingOuterArray = isArray$7(paddingOuter);
            for (let i = 0; i < this._scales.length; i++) {
                const _padding = isBandPaddingArray ? bandPadding[i] : bandPadding;
                const _paddingInner = isPaddingInnerArray ? paddingInner[i] : paddingInner;
                const _paddingOuter = isPaddingOuterArray ? paddingOuter[i] : paddingOuter;
                this._scales[i]
                    .paddingInner(_paddingInner ?? _padding ?? defalutBandInnerPadding, true)
                    .paddingOuter(_paddingOuter ?? _padding ?? defalutBandOuterPadding);
            }
        }
        dataToPosition(values, cfg = {}) {
            if (values.length === 0 || this._scales.length === 0) {
                return 0;
            }
            const { position, bandScale } = this.getPosition(values);
            return position + bandScale.bandwidth() * (cfg.bandPosition ?? 0.5);
        }
        updateScaleDomain(domain) {
            for (let i = 0; i < this._scales.length; i++) {
                this._scales[i].domain(domain);
            }
        }
        updateRange(newRange) {
            const [start, end] = this._scale.range();
            if (newRange[0] !== start || newRange[1] !== end) {
                this._scale.range(newRange);
            }
        }
    }

    function registerDataSetInstanceTransform(dataSet, name, transform) {
        if (!dataSet.getTransform(name)) {
            dataSet.registerTransform(name, transform);
        }
    }
    function registerDataSetInstanceParser(dataSet, name, parse) {
        if (!dataSet.getParser(name)) {
            dataSet.registerParser(name, parse);
        }
    }

    const e10 = Math.sqrt(50);
    const e5 = Math.sqrt(10);
    const e2 = Math.sqrt(2);
    class LinearAxisScale {
        _extend = {};
        _scale;
        _scales;
        nice;
        zero;
        domain;
        expand;
        forceTickCount;
        tickCount;
        niceType;
        type;
        constructor(type) {
            this.type = type ?? 'linear';
            if (type === 'log') {
                this._scale = new LogScale();
            }
            else if (type === 'symlog') {
                this._scale = new SymlogScale();
            }
            else {
                this._scale = new LinearScale();
            }
            this._scales = [this._scale];
        }
        setExtraAttrFromSpec(nice, zero, range, expand, base, constant) {
            this.nice = false;
            this.zero = zero;
            if (this.zero) {
                range.min = Math.min(range.min, 0);
                range.max = Math.max(range.max, 0);
            }
            this.domain = range;
            this.expand = expand;
            if (this.type === 'log') {
                this._scale.base(base ?? 10);
            }
            else if (this.type === 'symlog') {
                this._scale.constant(constant ?? 10);
            }
        }
        transformScaleDomain() {
            if (this.type === 'symlog' || this.type === 'log') ;
            else {
                this.setScaleNice();
            }
        }
        setScaleNice() {
            if (this.type === 'log') {
                this.setLogScaleNice();
            }
            else {
                this.setLinearScaleNice();
            }
        }
        setLogScaleNice() {
            if (isNil$3(this.domain?.min) && isNil$3(this.domain?.max)) {
                this.nice && this._scale.nice();
            }
            else if (isValid$3(this.domain?.min) && isNil$3(this.domain?.max)) {
                this.nice && this._scale.niceMax();
            }
            else if (isNil$3(this.domain?.min) && isValid$3(this.domain?.max)) {
                this.nice && this._scale.niceMin();
            }
        }
        setLinearScaleNice() {
            let tickCount = this.forceTickCount ?? this.tickCount ?? 10;
            if (this.niceType === 'accurateFirst') {
                tickCount = Math.max(10, tickCount);
            }
            if (isNil$3(this.domain?.min) && isNil$3(this.domain?.max)) {
                this.nice && this._scale.nice(tickCount);
            }
            else if (isValid$3(this.domain?.min) && isNil$3(this.domain?.max)) {
                this.nice && this._scale.niceMax(tickCount);
            }
            else if (isNil$3(this.domain?.min) && isValid$3(this.domain?.max)) {
                this.nice && this._scale.niceMin(tickCount);
            }
            else {
                this.nice && this._scale.nice(tickCount);
            }
        }
        dataToPosition(values) {
            return this.valueToPosition(values[0]);
        }
        valueToPosition(value) {
            return this._scale.scale(value);
        }
        computeLinearDomain(data) {
            const domain = [];
            data.forEach(d => {
                const { min, max } = d;
                domain[0] = domain[0] === undefined ? min : Math.min(domain[0], min);
                domain[1] = domain[1] === undefined ? max : Math.max(domain[1], max);
            });
            this.expandDomain(domain);
            this.includeZero(domain);
            this.setDomainMinMax(domain);
            return domain;
        }
        expandDomain(domain) {
            if (!this.expand) {
                return;
            }
            const domainMin = domain[0];
            const domainMax = domain[domain.length - 1];
            if (isValid$3(this.expand.min)) {
                domain[0] = domainMin - (domainMax - domainMin) * this.expand.min;
            }
            if (isValid$3(this.expand.max)) {
                domain[domain.length - 1] = domainMax + (domainMax - domainMin) * this.expand.max;
            }
        }
        niceDomain(domain) {
            if (isValid$3(domain[0]) || isValid$3(domain[1]) || this.type !== 'linear') {
                return domain;
            }
            if (Math.abs(minInArray(domain) - maxInArray(domain)) <= 1e-12) {
                let num = domain[0];
                const flag = num >= 0 ? 1 : -1;
                num = Math.abs(num);
                if (num < 1) {
                    domain[0] = 0;
                    domain[1] = 1;
                }
                else {
                    let step = num / 5;
                    const power = Math.floor(Math.log(step) / Math.LN10);
                    const err = step / Math.pow(10, power);
                    step = (err >= e10 ? 10 : err >= e5 ? 5 : err >= e2 ? 2 : 1) * Math.pow(10, power);
                    domain[0] = 0;
                    domain[1] = step * 10;
                }
                if (flag < 0) {
                    domain.reverse();
                    domain[0] *= -1;
                    domain[1] *= -1;
                }
            }
            return domain;
        }
        niceMinMax() {
            if (this.nice) {
                let tickCount = this.forceTickCount ?? this.tickCount ?? 10;
                if (this.niceType === 'accurateFirst') {
                    tickCount = Math.max(10, tickCount);
                }
                if (isNil$3(this.domain?.min) && isNil$3(this.domain?.max)) {
                    this._scale.nice(tickCount);
                }
                else if (isValid$3(this.domain?.min) && isNil$3(this.domain?.max)) {
                    this._scale.niceMax(tickCount);
                }
                else if (isNil$3(this.domain?.min) && isValid$3(this.domain?.max)) {
                    this._scale.niceMin(tickCount);
                }
                else {
                    this._scale.nice(tickCount);
                }
            }
        }
        includeZero(domain) {
            if (this.zero) {
                domain[0] = Math.min(domain[0], 0);
                domain[domain.length - 1] = Math.max(domain[domain.length - 1], 0);
            }
        }
        setExtendDomain(key, value) {
            if (value === undefined) {
                delete this._extend[key];
                return;
            }
            this._extend[key] = value;
            const domain = this._scale.domain();
            this.extendDomain(domain);
            this.includeZero(domain);
            this.setDomainMinMax(domain);
            this.niceDomain(domain);
            this._scale.domain(domain, this.nice);
            this.niceMinMax();
        }
        extendDomain(domain) {
            let temp;
            const domainLast = domain.length - 1;
            const reverse = domain[0] - domain[domainLast] > 0;
            const min = reverse ? domainLast : 0;
            const max = reverse ? 0 : domainLast;
            for (const key in this._extend) {
                temp = this._extend[key];
                temp > domain[max] && (domain[max] = temp);
                temp < domain[min] && (domain[min] = temp);
            }
        }
        setDomainMinMax(domain) {
            if (!this.domain) {
                return;
            }
            const { min, max } = this.domain;
            isValid$3(min) && (domain[0] = min);
            isValid$3(max) && (domain[1] = max);
        }
        setZero(zero) {
            if (this.zero !== zero) {
                this.zero = zero;
                this.updateScaleDomain();
            }
        }
        updateScaleDomain() {
            const domain = this.computeDomain([this.domain]);
            this.updateScaleDomainByModel(domain);
        }
        computeDomain(data) {
            return this.computeLinearDomain(data);
        }
        updateScaleDomainByModel(domain) {
            domain = domain ?? this._scale.domain();
            this.extendDomain(domain);
            this.includeZero(domain);
            this.setDomainMinMax(domain);
            this.niceDomain(domain);
            this._scale.domain(domain, this.nice);
            this.niceMinMax();
        }
        updateRange(newRange) {
            const [start, end] = this._scale.range();
            if (newRange[0] !== start || newRange[1] !== end) {
                this._scale.range(newRange);
            }
        }
    }

    function doOverlap(axisComponent, axis) {
        const layer0LabelsContainer = axisComponent.find((node) => node.name === 'axis-label-container-layer-0', true);
        const layer1LabelsContainer = axisComponent.find((node) => node.name === 'axis-label-container-layer-1', true);
        overlap(layer0LabelsContainer ? layer0LabelsContainer.getChildren() : [], axis);
        overlap(layer1LabelsContainer ? layer1LabelsContainer.getChildren() : [], axis);
    }
    function labelFlush(axisLabels, axis) {
        const { width, height } = axis.getLayoutRect();
        const isX = isXAxis(axis.orient);
        const isInverse = axis.option.inverse === true;
        const first = axisLabels[0];
        const last$1 = last(axisLabels);
        if (isX) {
            if (isInverse) {
                const start = width;
                const end = 0;
                const startBound = first.AABBBounds.x2;
                const endBound = last$1.AABBBounds.x1;
                if (startBound > start) {
                    first.setAttributes({
                        x: start,
                        textAlign: 'right'
                    });
                }
                if (endBound < end) {
                    last$1.setAttributes({
                        x: end,
                        textAlign: 'left'
                    });
                }
            }
            else {
                const start = 0;
                const end = width;
                const startBound = first.AABBBounds.x1;
                const endBound = last$1.AABBBounds.x2;
                if (startBound < start) {
                    first.setAttributes({
                        x: start,
                        textAlign: 'left'
                    });
                }
                if (endBound > end) {
                    last$1.setAttributes({
                        x: end,
                        textAlign: 'right'
                    });
                }
            }
        }
        else {
            if (isInverse) {
                const startBound = first.AABBBounds.y1;
                const endBound = last$1.AABBBounds.y2;
                const start = 0;
                const end = height;
                if (startBound < start) {
                    first.setAttributes({
                        y: start,
                        textBaseline: 'top'
                    });
                }
                if (endBound > end) {
                    last$1.setAttributes({
                        y: end,
                        textBaseline: 'bottom'
                    });
                }
            }
            else {
                const start = height;
                const end = 0;
                const startBound = first.AABBBounds.y2;
                const endBound = last$1.AABBBounds.y1;
                if (startBound > start) {
                    first.setAttributes({
                        y: start,
                        textBaseline: 'bottom'
                    });
                }
                if (endBound < end) {
                    last$1.setAttributes({
                        y: end,
                        textBaseline: 'top'
                    });
                }
            }
        }
    }
    function overlap(axisLabels, axis) {
        const spec = axis.option;
        if (!isEmpty(axisLabels)) {
            if (spec?.label?.flush) {
                labelFlush(axisLabels, axis);
            }
        }
    }

    const DEFAULT_BAND_INNER_PADDING = 0.1;
    const DEFAULT_BAND_OUTER_PADDING = 0.3;
    const scaleParser = (scale) => {
        return scale;
    };
    class CartesianAxis {
        width;
        height;
        x = 0;
        y = 0;
        table;
        option;
        orient;
        visible;
        type;
        inverse;
        data;
        tickData;
        scale;
        component;
        padding;
        constructor(option, width, height, padding, table) {
            this.padding = padding;
            this.table = table;
            this.orient = option.orient ?? 'left';
            this.type = option.type ?? 'band';
            this.option = merge$1({}, getCommonAxis(option.__vtableChartTheme), getTableAxisTheme(this.orient, table.theme), getChartSpecAxisTheme(this.orient, this.type, option.__vtableChartTheme), option);
            if (this.orient === 'left' || this.orient === 'right') {
                const innerOffsetTop = 0;
                const innerOffsetBottom = 0;
                this.width = width;
                this.height = height - padding[0] - padding[2] - innerOffsetBottom;
                this.y = padding[0] + innerOffsetTop;
            }
            else if (this.orient === 'top' || this.orient === 'bottom') {
                const innerOffsetLeft = 0;
                const innerOffsetRight = 0;
                this.width = width - padding[1] - padding[3] - innerOffsetRight;
                this.height = height;
                this.x = padding[3] + innerOffsetLeft;
            }
            this.visible = option.visible ?? true;
            this.inverse = 'inverse' in option ? !!option.inverse : false;
            if (option.type === 'band') {
                this.data = option.domain;
            }
            this.initScale();
            this.initData();
            this.createComponent();
            this.initEvent();
        }
        initScale() {
            const option = this.option;
            if (this.type === 'band' || this.type === 'point') {
                this.scale = new BandAxisScale();
                this.scale.bandPadding = option.bandPadding;
                this.scale.paddingInner = option.paddingInner;
                this.scale.paddingOuter = option.paddingOuter;
                this.scale.calcScales(DEFAULT_BAND_INNER_PADDING, DEFAULT_BAND_OUTER_PADDING);
                this.scale.updateScaleDomain(this.data);
                this.updateScaleRange();
            }
            else if (this.type === 'linear' || this.type === 'time' || this.type === 'log' || this.type === 'symlog') {
                this.scale = new LinearAxisScale(this.type);
                this.scale.setExtraAttrFromSpec(option.nice, option.zero, option.range, option.expand, option.base, option.constant);
                this.scale.transformScaleDomain();
                this.scale.updateScaleDomain();
                this.updateScaleRange();
            }
        }
        initData() {
            if (!this.table._vDataSet) {
                this.table._vDataSet = new DataSet();
            }
            registerDataSetInstanceParser(this.table._vDataSet, 'scale', scaleParser);
            registerDataSetInstanceTransform(this.table._vDataSet, 'ticks', ticks$2);
            const label = this.option.label || {};
            const tick = this.option.tick || {};
            const tickData = new DataView(this.table._vDataSet)
                .parse(this.scale._scale, {
                type: 'scale'
            })
                .transform({
                type: 'ticks',
                options: {
                    sampling: this.option.sampling !== false,
                    tickCount: tick.tickCount,
                    forceTickCount: tick.forceTickCount,
                    tickStep: tick.tickStep,
                    tickMode: tick.tickMode,
                    noDecimals: tick.noDecimals,
                    axisOrientType: this.orient,
                    coordinateType: 'cartesian',
                    labelStyle: label.style,
                    labelFormatter: label.formatMethod,
                    labelGap: label.minGap,
                    labelLastVisible: label.lastVisible,
                    labelFlush: label.flush
                }
            }, false);
            this.tickData = tickData;
            this.computeData();
        }
        computeData() {
            this.tickData.reRunAllTransform();
        }
        initEvent() {
        }
        createComponent() {
            const axisStylrAttrs = getAxisAttributes(this.option);
            const attrs = this.getUpdateAttribute();
            attrs.verticalFactor = this.orient === 'top' || this.orient === 'right' ? -1 : 1;
            this.component = new LineAxis(merge$1({
                disableTriggerEvent: this.table.options.disableInteraction
            }, axisStylrAttrs, attrs));
            this.component.setAttributes(this.setLayoutStartPosition({ x: this.x, y: this.y }));
            this.component.originAxis = this;
        }
        resize(width, height) {
            this.width = width - (this.orient === 'top' || this.orient === 'bottom' ? this.padding[1] + this.padding[3] : 0);
            this.height = height - (this.orient === 'left' || this.orient === 'right' ? this.padding[2] + this.padding[0] : 0);
            this.updateScaleRange();
            this.computeData();
            const axisStylrAttrs = getAxisAttributes(this.option);
            const attrs = this.getUpdateAttribute();
            attrs.verticalFactor = this.orient === 'top' || this.orient === 'right' ? -1 : 1;
            this.component.setAttributes(merge$1({}, axisStylrAttrs, attrs));
            this.component.setAttributes(this.setLayoutStartPosition({ x: this.x, y: this.y }));
            this.overlap();
        }
        overlap() {
            doOverlap(this.component, this);
        }
        getLayoutRect() {
            return {
                width: this.width,
                height: this.height
            };
        }
        getUpdateAttribute() {
            this.table.tableNoFrameHeight;
            this.table.tableNoFrameWidth;
            const { width, height } = this.getLayoutRect();
            const isX = isXAxis(this.orient);
            const isY = isYAxis(this.orient);
            let end = { x: 0, y: 0 };
            let axisLength = 0;
            if (isX) {
                end = { x: width, y: 0 };
                axisLength = width;
            }
            else if (isY) {
                end = { x: 0, y: height };
                axisLength = height;
            }
            const size = this.orient === 'top' || this.orient === 'bottom' ? height : width;
            const attrs = {
                start: { x: 0, y: 0 },
                end,
                title: {
                    text: this.option.title.text,
                    maxWidth: this._getTitleLimit(isX)
                },
                items: this.getLabelItems(axisLength),
                verticalLimitSize: size,
                verticalMinSize: size
            };
            return attrs;
        }
        getLabelItems(length) {
            return [
                this.tickData.latestData
                    .map((obj) => {
                    return {
                        id: obj.value,
                        label: obj.value,
                        value: length === 0 ? 0 : this.scale.dataToPosition([obj.value]) / length,
                        rawValue: obj.value
                    };
                })
                    .filter((entry) => entry.value >= 0 && entry.value <= 1)
            ];
        }
        updateScaleRange() {
            const right = this.option.innerOffset?.right ?? 0;
            const left = this.option.innerOffset?.left ?? 0;
            const top = this.option.innerOffset?.top ?? 0;
            const bottom = this.option.innerOffset?.bottom ?? 0;
            const { width, height } = this.getLayoutRect();
            const inverse = this.option.inverse || false;
            let newRange = [0, 0];
            if (isXAxis(this.orient)) {
                if (isValidNumber$1(width)) {
                    newRange = inverse ? [width - right, left] : [left, width - right];
                }
            }
            else {
                if (isValidNumber$1(height)) {
                    newRange = inverse ? [top, height - bottom] : [height - bottom, top];
                }
            }
            this.scale.updateRange(newRange);
        }
        setLayoutStartPosition(pos) {
            let { x, y } = pos;
            if (isValidNumber$1(x)) {
                x += Number(this.orient === 'left') * this.getLayoutRect().width;
            }
            if (isValidNumber$1(y)) {
                y += Number(this.orient === 'top') * this.getLayoutRect().height;
            }
            return { x, y };
        }
        _getTitleLimit(isX) {
            if (this.option.title.visible && isNil$3(this.option.title.style?.maxLineWidth)) {
                let angle = this.option.title.style?.angle || 0;
                if (this.option.title?.autoRotate && isNil$3(this.option.title.angle)) {
                    angle = this.option.orient === 'left' ? -90 : 90;
                }
                if (isX) {
                    const width = this.getLayoutRect().width;
                    const cosValue = Math.abs(Math.cos(degreeToRadian(angle)));
                    return cosValue < 1e-6 ? Infinity : width / cosValue;
                }
                const height = this.getLayoutRect().height;
                const sinValue = Math.abs(Math.sin(degreeToRadian(angle)));
                return sinValue < 1e-6 ? Infinity : height / sinValue;
            }
            return null;
        }
        getScale() {
            return this.scale._scale;
        }
        getDomainSpec() {
            return this.scale.domain;
        }
    }
    function getTableAxisTheme(orient, theme) {
        let directionStyle;
        if (orient === 'left') {
            directionStyle = theme.axisStyle.leftAxisStyle;
        }
        else if (orient === 'right') {
            directionStyle = theme.axisStyle.rightAxisStyle;
        }
        else if (orient === 'top') {
            directionStyle = theme.axisStyle.topAxisStyle;
        }
        else if (orient === 'bottom') {
            directionStyle = theme.axisStyle.bottomAxisStyle;
        }
        return merge$1({}, theme.axisStyle.defaultAxisStyle, directionStyle);
    }
    function getChartSpecAxisTheme(orient, type, chartSpecTheme) {
        if (!chartSpecTheme) {
            return {};
        }
        const axisTheme = chartSpecTheme.axis;
        let axisTypeTheme;
        if (type === 'linear' || type === 'log' || type === 'symlog') {
            axisTypeTheme = chartSpecTheme.axisLinear;
        }
        else if (type === 'band') {
            axisTypeTheme = chartSpecTheme.axisBand;
        }
        let axisOrientTheme;
        if (orient === 'top' || orient === 'bottom') {
            axisOrientTheme = chartSpecTheme.axisX;
        }
        else if (orient === 'left' || orient === 'right') {
            axisOrientTheme = chartSpecTheme.axisY;
        }
        return merge$1({}, axisTheme, axisTypeTheme, axisOrientTheme);
    }

    function computeAxisComponentWidth(config, table) {
        const attribute = merge$1({}, commonAxis, config);
        let tickWidth = 0;
        if (attribute.tick.visible !== false) {
            tickWidth = attribute.tick.width ?? 4;
        }
        let labelWidth = 0;
        if (attribute.label.visible) {
            if (attribute.type === 'band') {
                const domain = attribute.domain;
                domain.forEach((text) => {
                    if (attribute.label.formatMethod) {
                        text = attribute.label.formatMethod(text);
                    }
                    const { width, height } = table.measureText(text, {
                        fontSize: attribute.label?.style?.fontSize ?? DEFAULT_TEXT_FONT_SIZE,
                        fontWeight: attribute.label?.style?.fontWeight ?? 'normal',
                        fontFamily: attribute.label?.style?.fontFamily ?? DEFAULT_TEXT_FONT_FAMILY
                    });
                    const widthLimit = attribute.label?.style?.maxLineWidth || Infinity;
                    const angel = (attribute.label?.style?.angle ?? 0) + (attribute.label?.style?.direction === 'vertical' ? 90 : 0);
                    labelWidth = Math.max(labelWidth, getSizeAfterResize(Math.min(width, widthLimit), height, angel).width);
                });
            }
            else {
                let ticks;
                if (config.sync?.tickAlign && isFunction$5(config.tick?.tickMode)) {
                    ticks = config.tick.tickMode();
                }
                else if (isArray$7(config.__ticksForVTable)) {
                    ticks = config.__ticksForVTable;
                }
                else {
                    const range = attribute.range;
                    const minNumber = Math.abs(range.min) > 1 ? Math.round(range.min) : range.min;
                    const maxNumber = Math.abs(range.max) > 1 ? Math.round(range.max) : range.max;
                    const minString = formatDecimal(minNumber);
                    const maxString = formatDecimal(maxNumber);
                    ticks = [minString, maxString];
                }
                ticks.forEach(text => {
                    if (attribute.label.formatMethod) {
                        text = attribute.label.formatMethod(text);
                    }
                    const { width, height } = table.measureText(text, {
                        fontSize: attribute.label?.style?.fontSize ?? DEFAULT_TEXT_FONT_SIZE,
                        fontWeight: attribute.label?.style?.fontWeight ?? 'normal',
                        fontFamily: attribute.label?.style?.fontFamily ?? DEFAULT_TEXT_FONT_FAMILY
                    });
                    const widthLimit = attribute.label?.style?.maxLineWidth || Infinity;
                    const angle = (attribute.label?.style?.angle ?? 0) + (attribute.label?.style?.direction === 'vertical' ? 90 : 0);
                    labelWidth = Math.max(labelWidth, getSizeAfterResize(Math.min(width, widthLimit), height, angle).width);
                });
            }
            labelWidth += attribute.label.space ?? 4;
        }
        let titleWidth = 0;
        if (attribute.title.visible && isString$4(attribute.title.text)) {
            const { width, height } = table.measureText(attribute.title.text, {
                fontSize: attribute.title?.style?.fontSize ?? DEFAULT_TEXT_FONT_SIZE,
                fontWeight: attribute.title?.style?.fontWeight ?? 'normal',
                fontFamily: attribute.title?.style?.fontFamily ?? DEFAULT_TEXT_FONT_FAMILY
            });
            const widthLimit = attribute.label?.style?.maxLineWidth || Infinity;
            const size = getSizeAfterResize(Math.min(width, widthLimit), height, attribute.title?.style?.angle);
            if ((config.orient === 'left' || config.orient === 'right') && attribute.title.autoRotate) {
                titleWidth = size.height;
            }
            else {
                titleWidth = size.width;
            }
            titleWidth += attribute.title.space ?? 4;
        }
        return Math.ceil(tickWidth + labelWidth + titleWidth + 1);
    }
    function computeAxisComponentHeight(config, table) {
        const attribute = merge$1({}, commonAxis, config);
        let tickHeight = 0;
        if (attribute.tick.visible !== false) {
            tickHeight = attribute.tick.width ?? 4;
        }
        let labelHeight = 0;
        if (attribute.label.visible) {
            if (attribute.type === 'band') {
                const domain = attribute.domain;
                domain.forEach((text) => {
                    if (attribute.label.formatMethod) {
                        text = attribute.label.formatMethod(text);
                    }
                    const { width, height } = table.measureText(text, {
                        fontSize: attribute.label?.style?.fontSize ?? DEFAULT_TEXT_FONT_SIZE,
                        fontWeight: attribute.label?.style?.fontWeight ?? 'normal',
                        fontFamily: attribute.label?.style?.fontFamily ?? DEFAULT_TEXT_FONT_FAMILY
                    });
                    const widthLimit = attribute.label?.style?.maxLineWidth || Infinity;
                    const angle = (attribute.label?.style?.angle ?? 0) + (attribute.label?.style?.direction === 'vertical' ? 90 : 0);
                    labelHeight = Math.max(labelHeight, getSizeAfterResize(Math.min(width, widthLimit), height, angle).height);
                });
            }
            else {
                let ticks;
                if (config.sync?.tickAlign && isFunction$5(config.tick?.tickMode)) {
                    ticks = config.tick.tickMode();
                }
                else if (isArray$7(config.__ticksForVTable)) {
                    ticks = config.__ticksForVTable;
                }
                else {
                    const range = attribute.range;
                    const minNumber = Math.abs(range.min) > 1 ? Math.round(range.min) : range.min;
                    const maxNumber = Math.abs(range.max) > 1 ? Math.round(range.max) : range.max;
                    const minString = formatDecimal(minNumber);
                    const maxString = formatDecimal(maxNumber);
                    ticks = [minString, maxString];
                }
                ticks.forEach(text => {
                    if (attribute.label.formatMethod) {
                        text = attribute.label.formatMethod(text);
                    }
                    const { width, height } = table.measureText(text, {
                        fontSize: attribute.label?.style?.fontSize ?? DEFAULT_TEXT_FONT_SIZE,
                        fontWeight: attribute.label?.style?.fontWeight ?? 'normal',
                        fontFamily: attribute.label?.style?.fontFamily ?? DEFAULT_TEXT_FONT_FAMILY
                    });
                    const widthLimit = attribute.label?.style?.maxLineWidth || Infinity;
                    const angle = (attribute.label?.style?.angle ?? 0) + (attribute.label?.style?.direction === 'vertical' ? 90 : 0);
                    labelHeight = Math.max(labelHeight, getSizeAfterResize(Math.min(width, widthLimit), height, angle).height);
                });
            }
            labelHeight += attribute.label.space ?? 4;
        }
        let titleHeight = 0;
        if (attribute.title.visible && attribute.title.text) {
            const { width, height } = table.measureText(attribute.title.text, {
                fontSize: attribute.title?.style?.fontSize ?? DEFAULT_TEXT_FONT_SIZE,
                fontWeight: attribute.title?.style?.fontWeight ?? 'normal',
                fontFamily: attribute.title?.style?.fontFamily ?? DEFAULT_TEXT_FONT_FAMILY
            });
            const widthLimit = attribute.label?.style?.maxLineWidth || Infinity;
            const size = getSizeAfterResize(Math.min(width, widthLimit), height, attribute.title?.style?.angle);
            if ((config.orient === 'bottom' || config.orient === 'top') && attribute.title.autoRotate) {
                titleHeight = size.width;
            }
            else {
                titleHeight = size.height;
            }
            titleHeight += attribute.title.space ?? 4;
        }
        return tickHeight + labelHeight + titleHeight + 1;
    }
    function formatDecimal(number) {
        if (typeof number !== 'number') {
            number = Number(number);
        }
        return Number(number.toPrecision(1)).toString();
    }
    function getSizeAfterResize(width, height, angle = 0) {
        const theta = (angle * Math.PI) / 180;
        const p1 = { x: -width / 2, y: -height / 2 };
        const p2 = { x: width / 2, y: -height / 2 };
        const p3 = { x: width / 2, y: height / 2 };
        const p4 = { x: -width / 2, y: height / 2 };
        const p1Rotated = {
            x: p1.x * Math.cos(theta) - p1.y * Math.sin(theta),
            y: p1.x * Math.sin(theta) + p1.y * Math.cos(theta)
        };
        const p2Rotated = {
            x: p2.x * Math.cos(theta) - p2.y * Math.sin(theta),
            y: p2.x * Math.sin(theta) + p2.y * Math.cos(theta)
        };
        const p3Rotated = {
            x: p3.x * Math.cos(theta) - p3.y * Math.sin(theta),
            y: p3.x * Math.sin(theta) + p3.y * Math.cos(theta)
        };
        const p4Rotated = {
            x: p4.x * Math.cos(theta) - p4.y * Math.sin(theta),
            y: p4.x * Math.sin(theta) + p4.y * Math.cos(theta)
        };
        const bounds = {
            minX: Math.min(p1Rotated.x, p2Rotated.x, p3Rotated.x, p4Rotated.x),
            maxX: Math.max(p1Rotated.x, p2Rotated.x, p3Rotated.x, p4Rotated.x),
            minY: Math.min(p1Rotated.y, p2Rotated.y, p3Rotated.y, p4Rotated.y),
            maxY: Math.max(p1Rotated.y, p2Rotated.y, p3Rotated.y, p4Rotated.y)
        };
        return {
            width: bounds.maxX - bounds.minX,
            height: bounds.maxY - bounds.minY
        };
    }

    const emptyTipSvg = '<svg t="1716726614852" class="icon" viewBox="0 0 1194 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2621" width="200" height="200"><path d="M1038.694079 367.237067c13.265507 23.342857-16.633865-40.004445-63.05621-40.004446H219.018794c-26.558738 0-46.46393 13.334815-63.05621 40.004446S0.006238 607.277601 0.006238 650.608819V940.647979a82.351494 82.351494 0 0 0 82.961402 83.349526H1111.702885a82.337632 82.337632 0 0 0 82.975264-83.349526V650.608819c0-43.331218-155.970208-283.371753-155.970208-283.371752zM730.066575 667.284269a136.328386 136.328386 0 0 1-132.738243 133.33429 133.417459 133.417459 0 0 1-132.738243-133.33429v-6.681269a40.6698 40.6698 0 0 0-36.497473-26.66963H73.015044l119.458874-220.02445s23.231965-40.004445 53.103614-40.004446h713.481918c26.544876 0 29.871649 10.008042 46.436207 40.004446L1128.33675 633.947231H769.904682c-26.184476 0-39.838107 7.623855-39.838107 33.337038zM338.505391 210.559919l-89.601086-86.69016a22.178487 22.178487 0 0 1 0-33.26773 21.984425 21.984425 0 0 1 33.170699 0l89.601087 86.676299a22.317102 22.317102 0 0 1 0 33.26773 24.950798 24.950798 0 0 1-33.1707 0z m252.197118-40.059891a25.532983 25.532983 0 0 1-6.639685-16.633865l-3.326773-126.694606A28.263709 28.263709 0 0 1 603.995739 0.515788c13.251646-3.326773 23.204242 10.021904 26.544877 23.342858V153.866163a28.249847 28.249847 0 0 1-23.259688 26.66963c-6.611961-3.312911-13.279369-3.312911-16.578419-10.035765z m235.646421 33.337038a22.372548 22.372548 0 0 1 0-33.337038l86.288175-90.030795a22.039871 22.039871 0 0 1 33.170699 0 22.289379 22.289379 0 0 1 0 33.364761l-82.961401 90.003072a25.962691 25.962691 0 0 1-36.483611 0z" fill="#8a8a8a" p-id="2622"></path></svg>';
    class EmptyTip {
        table;
        _emptyTipOption = {
            spaceBetweenTextAndIcon: 20,
            text: 'no data',
            textStyle: {
                fontSize: 14,
                color: '#000'
            },
            icon: {
                image: emptyTipSvg,
                width: 100,
                height: 100
            }
        };
        isReleased = false;
        _emptyTipComponent;
        _cacheAttrs;
        constructor(emptyTipOption, table) {
            this.table = table;
            this._emptyTipOption = Object.assign(this._emptyTipOption, emptyTipOption === true ? {} : emptyTipOption);
            if (!isValid$3(this._emptyTipOption.displayMode)) {
                if (this.table.isListTable()) {
                    this._emptyTipOption.displayMode = 'basedOnTable';
                }
                else {
                    this._emptyTipOption.displayMode = 'basedOnContainer';
                }
            }
            this._emptyTipComponent = this._createOrUpdateEmptyTipComponent(this._getEmptyTipAttrs());
        }
        _createOrUpdateEmptyTipComponent(attrs) {
            if (this._emptyTipComponent) {
                if (!isEqual(attrs, this._cacheAttrs)) {
                    this._emptyTipComponent.setAttributes(attrs);
                }
            }
            else {
                const emptyTip = new EmptyTip$1(attrs);
                emptyTip.name = 'emptyTip';
                this.table.scenegraph.stage.defaultLayer.appendChild(emptyTip);
                this._emptyTipComponent = emptyTip;
                this.bindEvents();
            }
            return this._emptyTipComponent;
        }
        bindEvents() {
            this._emptyTipComponent.on('click', (e) => {
                const bounds = new AABBBounds();
                this._emptyTipComponent.forEachChildren((child) => {
                    bounds.union(child.globalAABBBounds);
                });
                if (bounds.contains(e.x, e.y)) {
                    this.table.fireListeners('empty_tip_click', e);
                    return;
                }
            });
            this._emptyTipComponent.on('dblclick', (e) => {
                const bounds = new AABBBounds();
                this._emptyTipComponent.forEachChildren((child) => {
                    bounds.union(child.globalAABBBounds);
                });
                if (bounds.contains(e.x, e.y)) {
                    this.table.fireListeners('empty_tip_dblclick', e);
                    return;
                }
            });
        }
        resize() {
            if (!this._emptyTipComponent) {
                return;
            }
            const { leftHeaderWidth, topHeaderHeight, width, height } = this.getWidthAndHeight();
            this._emptyTipComponent.setAttributes({
                spaceBetweenTextAndIcon: this._emptyTipOption.spaceBetweenTextAndIcon,
                x: this.table.tableX + leftHeaderWidth,
                y: this.table.tableY + topHeaderHeight,
                width,
                height,
                text: {
                    text: this._emptyTipOption.text,
                    ...this._emptyTipOption.textStyle,
                    fill: this._emptyTipOption.textStyle?.color
                },
                icon: {
                    ...this._emptyTipOption.icon
                }
            });
        }
        release() {
            this._emptyTipComponent && this.table.scenegraph.stage.defaultLayer.removeChild(this._emptyTipComponent);
            this._emptyTipComponent = null;
            this.isReleased = true;
        }
        resetVisible() {
            if (((!this.table.recordsCount || this.table.recordsCount === 0) &&
                this.table.internalProps.layoutMap.rowCount === this.table.internalProps.layoutMap.columnHeaderLevelCount) ||
                this.table.internalProps.layoutMap.colCount === this.table.internalProps.layoutMap.rowHeaderLevelCount) {
                if (!this.table.scenegraph.stage.defaultLayer.children.includes(this._emptyTipComponent)) {
                    this.table.scenegraph.stage.defaultLayer.appendChild(this._emptyTipComponent);
                }
            }
            else {
                if (this.table.scenegraph.stage.defaultLayer.children.includes(this._emptyTipComponent)) {
                    this.table.scenegraph.stage.defaultLayer.removeChild(this._emptyTipComponent);
                }
            }
        }
        getWidthAndHeight() {
            const leftHeaderWidth = this.table.transpose || this.table.options.indicatorsAsCol === false
                ? this.table.getFrozenColsWidth()
                : 0;
            const topHeaderHeight = !this.table.transpose || this.table.options.indicatorsAsCol
                ? this.table.getFrozenRowsHeight()
                : 0;
            const width = (this._emptyTipOption.displayMode !== 'basedOnContainer' &&
                this.table.columnHeaderLevelCount > 0 &&
                this.table.colCount > this.table.rowHeaderLevelCount
                ? this.table.getDrawRange().width
                : this.table.tableNoFrameWidth) -
                leftHeaderWidth -
                this.table.getTheme().scrollStyle.width;
            const height = (this._emptyTipOption.displayMode !== 'basedOnContainer' &&
                this.table.rowHeaderLevelCount > 0 &&
                this.table.rowCount > this.table.columnHeaderLevelCount
                ? this.table.getDrawRange().height
                : this.table.tableNoFrameHeight) -
                topHeaderHeight -
                this.table.getTheme().scrollStyle.width;
            return {
                leftHeaderWidth,
                topHeaderHeight,
                width,
                height
            };
        }
        _getEmptyTipAttrs() {
            const { leftHeaderWidth, topHeaderHeight, width, height } = this.getWidthAndHeight();
            return {
                spaceBetweenTextAndIcon: this._emptyTipOption.spaceBetweenTextAndIcon,
                x: this.table.tableX + leftHeaderWidth,
                y: this.table.tableY + topHeaderHeight,
                width,
                height,
                text: {
                    text: this._emptyTipOption.text,
                    ...this._emptyTipOption.textStyle,
                    fill: this._emptyTipOption.textStyle?.color
                },
                icon: {
                    ...this._emptyTipOption.icon
                }
            };
        }
    }

    const defaultLegendSpec = {
        orient: 'bottom',
        position: 'middle',
        padding: 30,
        title: {
            visible: false,
            padding: 0,
            textStyle: {
                fontSize: 14,
                fill: '#000000',
                fontWeight: 'normal'
            },
            space: 12
        },
        item: {
            visible: true,
            spaceCol: 10,
            spaceRow: 10,
            padding: 2,
            background: {
                state: {
                    selectedHover: {
                        fill: 'gray',
                        fillOpacity: 0.7
                    },
                    unSelectedHover: {
                        fill: 'gray',
                        fillOpacity: 0.2
                    }
                }
            },
            shape: {
                space: 4,
                state: {
                    unSelected: {
                        fillOpacity: 0.5
                    }
                }
            },
            label: {
                space: 4,
                style: {
                    fill: '#89909D',
                    fontSize: 14
                },
                state: {
                    unSelected: {
                        fillOpacity: 0.5
                    }
                }
            }
        },
        allowAllCanceled: true,
        visible: true
    };
    function getLegendAttributes(spec, rect) {
        const { title = {}, item = {}, pager = {}, background = {}, type, id, visible, orient, position, data, filter, regionId, regionIndex, seriesIndex, seriesId, padding, ...restSpec } = merge$1({}, defaultLegendSpec, spec);
        const attrs = restSpec;
        if (title.visible) {
            attrs.title = transformLegendTitleAttributes(title);
        }
        if (!isEmpty(item.focusIconStyle)) {
            transformToGraphic(item.focusIconStyle);
        }
        transformComponentStyle(item.shape);
        transformComponentStyle(item.label);
        transformComponentStyle(item.value);
        transformComponentStyle(item.background);
        if (isPercent(item.maxWidth)) {
            item.maxWidth = (Number(item.maxWidth.substring(0, item.maxWidth.length - 1)) * rect.width) / 100;
        }
        if (isPercent(item.width)) {
            item.width = (Number(item.width.substring(0, item.width.length - 1)) * rect.width) / 100;
        }
        if (isPercent(item.height)) {
            item.height = (Number(item.height.substring(0, item.height.length - 1)) * rect.width) / 100;
        }
        attrs.item = item;
        if (!isEmpty(pager.textStyle)) {
            transformToGraphic(pager.textStyle);
        }
        transformComponentStyle(pager.handler);
        attrs.pager = pager;
        if (background.visible && !isEmpty(background.style)) {
            merge$1(attrs, background.style);
            if (isValid$3(background.padding)) {
                attrs.padding = background.padding;
            }
        }
        return attrs;
    }

    class DiscreteTableLegend {
        table;
        option;
        orient;
        visible;
        position;
        selectedData;
        legendComponent;
        constructor(option, table) {
            this.table = table;
            this.option = cloneDeep$1(option);
            this.orient = option.orient ?? 'left';
            this.visible = option.visible ?? true;
            this.position = option.position ?? 'middle';
            this.selectedData = option.defaultSelected ?? null;
            this.createComponent();
            this.initEvent();
        }
        createComponent() {
            const attrs = this.getLegendAttributes({
                width: this.table.tableNoFrameWidth,
                height: this.table.tableNoFrameHeight
            });
            const legend = new DiscreteLegend(merge$1({}, attrs, {
                defaultSelected: this.selectedData,
                disableTriggerEvent: this.table.options.disableInteraction
            }));
            legend.name = 'legend';
            this.legendComponent = legend;
            if (this.visible === false) {
                legend.setAttributes({
                    visible: false,
                    visibleAll: false
                });
                legend.hideAll();
            }
            this.table.scenegraph.stage.defaultLayer.appendChild(legend);
            this.adjustTableSize(attrs);
        }
        resize() {
            if (!this.legendComponent || this.visible === false) {
                return;
            }
            this.legendComponent.setAttributes({
                maxWidth: this.table.tableNoFrameWidth,
                maxHeight: this.table.tableNoFrameHeight
            });
            this.adjustTableSize(this.legendComponent.attribute);
        }
        adjustTableSize(attrs) {
            if (!this.legendComponent || this.visible === false) {
                return;
            }
            let width = isFinite(this.legendComponent.AABBBounds.width()) ? this.legendComponent.AABBBounds.width() : 0;
            let height = isFinite(this.legendComponent.AABBBounds.height()) ? this.legendComponent.AABBBounds.height() : 0;
            if (width <= 0 || height <= 0) {
                return;
            }
            const rectWidth = this.table.tableNoFrameWidth;
            const rectHeight = this.table.tableNoFrameHeight;
            const padding = getQuadProps(attrs.padding ?? this.option.padding ?? 10);
            let x = 0;
            let y = 0;
            if (this.orient === 'left') {
                x = padding[3];
                y = 0;
                width += padding[1] + padding[3];
            }
            else if (this.orient === 'top') {
                x = 0;
                y = padding[0];
                height += padding[0] + padding[2];
            }
            else if (this.orient === 'right') {
                x = rectWidth - width - padding[1];
                y = 0;
                width += padding[1] + padding[3];
            }
            else if (this.orient === 'bottom') {
                x = 0;
                y = rectHeight - height - padding[2];
                height += padding[0] + padding[2];
            }
            const layout = this.orient === 'bottom' || this.orient === 'top' ? 'horizontal' : 'vertical';
            const position = this.position;
            let offsetX = 0;
            let offsetY = 0;
            if (layout === 'horizontal') {
                if (position === 'middle') {
                    offsetX = (rectWidth - width) / 2;
                }
                else if (position === 'end') {
                    offsetX = rectWidth - width - padding[1];
                }
                else {
                    offsetX = padding[3];
                }
            }
            else {
                if (position === 'middle') {
                    offsetY = (rectHeight - height) / 2;
                }
                else if (position === 'end') {
                    offsetY = rectHeight - height - padding[2];
                }
                else {
                    offsetY = padding[0];
                }
            }
            this.legendComponent.setAttributes({
                dx: offsetX,
                dy: offsetY,
                x,
                y
            });
            if (this.orient === 'left') {
                this.table.tableNoFrameWidth = this.table.tableNoFrameWidth - Math.ceil(width);
                this.table.tableX += Math.ceil(width);
            }
            else if (this.orient === 'top') {
                this.table.tableNoFrameHeight = this.table.tableNoFrameHeight - Math.ceil(height);
                this.table.tableY += Math.ceil(height);
            }
            else if (this.orient === 'right') {
                this.table.tableNoFrameWidth = this.table.tableNoFrameWidth - Math.ceil(width);
            }
            else if (this.orient === 'bottom') {
                this.table.tableNoFrameHeight = this.table.tableNoFrameHeight - Math.ceil(height);
            }
        }
        getLegendAttributes(rect) {
            const layout = this.orient === 'bottom' || this.orient === 'top' ? 'horizontal' : 'vertical';
            const legendAttrs = getLegendAttributes(this.option, rect);
            const padding = getQuadProps(legendAttrs.padding ?? this.option.padding ?? 10);
            const attrs = {
                layout,
                items: this.getLegendItems(),
                maxWidth: rect.width - padding[1] - padding[3],
                maxHeight: rect.height - padding[0] - padding[2],
                ...legendAttrs
            };
            return attrs;
        }
        getLegendItems() {
            return this.option.data;
        }
        initEvent() {
            if (this.legendComponent) {
                this.legendComponent.addEventListener(LegendEvent.legendItemClick, (e) => {
                    const selectedData = get$7(e, 'detail.currentSelected');
                    this.table.fireListeners(TABLE_EVENT_TYPE.LEGEND_ITEM_CLICK, { model: this, value: selectedData, event: e });
                });
                this.legendComponent.addEventListener(LegendEvent.legendItemHover, (e) => {
                    const detail = get$7(e, 'detail');
                    this.table.fireListeners(TABLE_EVENT_TYPE.LEGEND_ITEM_HOVER, { model: this, value: detail, event: e });
                });
                this.legendComponent.addEventListener(LegendEvent.legendItemUnHover, (e) => {
                    const detail = get$7(e, 'detail');
                    this.table.fireListeners(TABLE_EVENT_TYPE.LEGEND_ITEM_UNHOVER, { model: this, value: detail, event: e });
                });
                this.legendComponent.addEventListener('legendItemAttributeUpdate', (e) => {
                    this.table.scenegraph.updateNextFrame();
                });
            }
        }
        getLegendBounds() {
            const width = isFinite(this.legendComponent.AABBBounds.width()) ? this.legendComponent.AABBBounds.width() : 0;
            const height = isFinite(this.legendComponent.AABBBounds.height()) ? this.legendComponent.AABBBounds.height() : 0;
            return {
                width: width,
                height: height
            };
        }
        release() {
            this.legendComponent && this.table.scenegraph.stage.defaultLayer.removeChild(this.legendComponent);
            this.legendComponent = null;
        }
    }

    const defaultContinueLegendSpec = {
        orient: 'right',
        position: 'middle',
        padding: 30,
        title: {
            visible: false,
            padding: 0,
            textStyle: {
                fontSize: 14,
                fontWeight: 'normal',
                fill: { type: 'palette', key: 'titleFontColor' }
            },
            space: 12
        },
        handler: {
            visible: true
        },
        startText: {
            style: {
                fontSize: 14,
                fontWeight: 'normal',
                fill: { type: 'palette', key: 'labelFontColor' }
            }
        },
        endText: {
            style: {
                fontSize: 14,
                fontWeight: 'normal',
                fill: { type: 'palette', key: 'labelFontColor' }
            }
        },
        handlerText: {
            style: {
                fontSize: 14,
                fontWeight: 'normal',
                fill: { type: 'palette', key: 'labelFontColor' }
            }
        }
    };
    const defaultColorLegendSpec = {
        horizontal: {
            ...defaultContinueLegendSpec,
            rail: {
                width: 200,
                height: 8,
                style: {
                    fill: 'rgba(0,0,0,0.04)'
                }
            }
        },
        vertical: {
            ...defaultContinueLegendSpec,
            rail: {
                width: 8,
                height: 200,
                style: {
                    fill: 'rgba(0,0,0,0.04)'
                }
            }
        }
    };
    const defaultSizeLegendSpec = {
        horizontal: {
            sizeBackground: {
                fill: '#cdcdcd'
            },
            track: {
                style: {
                    fill: 'rgba(20,20,20,0.1)'
                }
            },
            rail: {
                width: 200,
                height: 4,
                style: {
                    fill: 'rgba(0,0,0,0.04)'
                }
            },
            ...defaultContinueLegendSpec
        },
        vertical: {
            sizeBackground: {
                fill: '#cdcdcd'
            },
            track: {
                style: {
                    fill: 'rgba(20,20,20,0.1)'
                }
            },
            rail: {
                width: 4,
                height: 200,
                style: {
                    fill: 'rgba(0,0,0,0.04)'
                }
            },
            ...defaultContinueLegendSpec
        }
    };
    function getContinuousLegendAttributes(spec, rect) {
        const { title = {}, handler = {}, rail = {}, track = {}, startText, endText, handlerText, sizeBackground, background = {}, type, id, visible, orient, position, data, defaultSelected, field, filter, regionId, regionIndex, seriesIndex, seriesId, padding, ...restSpec } = merge$1({}, (spec.type === 'color' ? defaultColorLegendSpec : defaultSizeLegendSpec)[spec.orient === 'bottom' || spec.orient === 'top' ? 'horizontal' : 'vertical'], spec);
        const attrs = restSpec;
        if (title.visible) {
            attrs.title = transformLegendTitleAttributes(title);
        }
        attrs.showHandler = handler.visible !== false;
        if (!isEmpty(handler.style)) {
            attrs.handlerStyle = transformToGraphic(handler.style);
        }
        if (isValid$3(rail.width)) {
            attrs.railWidth = rail.width;
        }
        if (isValid$3(rail.height)) {
            attrs.railHeight = rail.height;
        }
        if (!isEmpty(rail.style)) {
            attrs.railStyle = transformToGraphic(rail.style);
        }
        if (!isEmpty(track.style)) {
            attrs.trackStyle = transformToGraphic(track.style);
        }
        attrs.startText = transformComponentStyle(startText);
        attrs.endText = transformComponentStyle(endText);
        attrs.handlerText = transformComponentStyle(handlerText);
        if (!isEmpty(sizeBackground)) {
            attrs.sizeBackground = transformToGraphic(sizeBackground);
        }
        if (background.visible && !isEmpty(background.style)) {
            merge$1(attrs, background.style);
            if (isValid$3(background.padding)) {
                attrs.padding = background.padding;
            }
        }
        return attrs;
    }

    class ContinueTableLegend {
        table;
        option;
        orient;
        visible;
        position;
        selectedData;
        legendComponent;
        constructor(option, table) {
            this.table = table;
            this.option = cloneDeep$1(option);
            this.orient = option.orient ?? 'left';
            this.visible = option.visible ?? true;
            this.position = option.position ?? 'middle';
            this.selectedData = option.defaultSelected ?? null;
            this.createComponent();
            this.initEvent();
        }
        createComponent() {
            const attrs = this.getLegendAttributes({
                width: this.table.tableNoFrameWidth,
                height: this.table.tableNoFrameHeight
            });
            let legend;
            if (this.option.type === 'color') {
                legend = new ColorContinuousLegend(merge$1({}, attrs, {
                    slidable: true
                }));
            }
            else {
                legend = new SizeContinuousLegend(merge$1({}, attrs, {
                    slidable: true
                }));
            }
            legend.name = 'legend';
            this.legendComponent = legend;
            if (this.visible === false) {
                legend.setAttributes({
                    visible: false,
                    visibleAll: false
                });
                legend.hideAll();
            }
            this.table.scenegraph.stage.defaultLayer.appendChild(legend);
            this.adjustTableSize(attrs);
        }
        resize() {
            if (!this.legendComponent || this.visible === false) {
                return;
            }
            this.legendComponent.setAttributes({
                width: this.table.tableNoFrameWidth,
                height: this.table.tableNoFrameHeight
            });
            this.adjustTableSize(this.legendComponent.attribute);
        }
        adjustTableSize(attrs) {
            if (!this.legendComponent || this.visible === false) {
                return;
            }
            let width = isFinite(this.legendComponent.AABBBounds.width()) ? this.legendComponent.AABBBounds.width() : 0;
            let height = isFinite(this.legendComponent.AABBBounds.height()) ? this.legendComponent.AABBBounds.height() : 0;
            if (width <= 0 || height <= 0) {
                return;
            }
            const rectWidth = this.table.tableNoFrameWidth;
            const rectHeight = this.table.tableNoFrameHeight;
            const padding = getQuadProps(attrs.padding ?? this.option.padding ?? 10);
            let x = 0;
            let y = 0;
            if (this.orient === 'left') {
                x = padding[3];
                y = 0;
                width += padding[1] + padding[3];
            }
            else if (this.orient === 'top') {
                x = 0;
                y = padding[0];
                height += padding[0] + padding[2];
            }
            else if (this.orient === 'right') {
                x = rectWidth - width - padding[1];
                y = 0;
                width += padding[1] + padding[3];
            }
            else if (this.orient === 'bottom') {
                x = 0;
                y = rectHeight - height - padding[2];
                height += padding[0] + padding[2];
            }
            const layout = this.orient === 'bottom' || this.orient === 'top' ? 'horizontal' : 'vertical';
            const position = this.position;
            let offsetX = 0;
            let offsetY = 0;
            if (layout === 'horizontal') {
                if (position === 'middle') {
                    offsetX = (rectWidth - width) / 2;
                }
                else if (position === 'end') {
                    offsetX = rectWidth - width - padding[1];
                }
                else {
                    offsetX = padding[3];
                }
            }
            else {
                if (position === 'middle') {
                    offsetY = (rectHeight - height) / 2;
                }
                else if (position === 'end') {
                    offsetY = rectHeight - height - padding[2];
                }
                else {
                    offsetY = padding[0];
                }
            }
            this.legendComponent.setAttributes({
                dx: offsetX,
                dy: offsetY,
                x,
                y
            });
            if (this.orient === 'left') {
                this.table.tableNoFrameWidth = this.table.tableNoFrameWidth - Math.ceil(width);
                this.table.tableX += Math.ceil(width);
            }
            else if (this.orient === 'top') {
                this.table.tableNoFrameHeight = this.table.tableNoFrameHeight - Math.ceil(height);
                this.table.tableY += Math.ceil(height);
            }
            else if (this.orient === 'right') {
                this.table.tableNoFrameWidth = this.table.tableNoFrameWidth - Math.ceil(width);
            }
            else if (this.orient === 'bottom') {
                this.table.tableNoFrameHeight = this.table.tableNoFrameHeight - Math.ceil(height);
            }
        }
        getLegendAttributes(rect) {
            const layout = this.orient === 'bottom' || this.orient === 'top' ? 'horizontal' : 'vertical';
            const align = layout === 'horizontal' ? 'bottom' : this.orient;
            const attrs = {
                ...getContinuousLegendAttributes(this.option),
                layout,
                align,
                min: this.option.min,
                max: this.option.max,
                value: this.option.value,
                [this.option.type === 'color' ? 'colors' : 'sizeRange']: this.option.type === 'color'
                    ? this.option.colors
                    : this.option.sizeRange
            };
            return attrs;
        }
        initEvent() {
            if (this.legendComponent) {
                this.legendComponent.addEventListener('change', (e) => {
                    const selectedData = get$7(e, 'detail.value');
                    this.table.fireListeners(TABLE_EVENT_TYPE.LEGEND_CHANGE, { model: this, value: selectedData, event: e });
                    this.table.scenegraph.updateNextFrame();
                });
            }
        }
        getLegendBounds() {
            const width = isFinite(this.legendComponent.AABBBounds.width()) ? this.legendComponent.AABBBounds.width() : 0;
            const height = isFinite(this.legendComponent.AABBBounds.height()) ? this.legendComponent.AABBBounds.height() : 0;
            return {
                width: width,
                height: height
            };
        }
        release() {
            this.legendComponent && this.table.scenegraph.stage.defaultLayer.removeChild(this.legendComponent);
            this.legendComponent = null;
        }
    }

    function createLegend(option, table) {
        if (option.type === 'color' || option.type === 'size') {
            return new ContinueTableLegend(option, table);
        }
        return new DiscreteTableLegend(option, table);
    }

    class BaseMenu {
        _table;
        _menuElement;
        constructor(table) {
            this._table = table;
        }
        release() {
            this.unbindMenuElement();
            if (this._menuElement) {
                this._menuElement.release();
            }
            this._menuElement = undefined;
        }
        _getMenuElement() {
            if (this._menuElement) {
                return this._menuElement;
            }
            this._menuElement = this.createMenuElementInternal();
            return this._menuElement;
        }
        bindMenuElement(col, row, menuInstanceInfo) {
            const menuElement = this._getMenuElement();
            return menuElement.bindToCell(this._table, col, row, menuInstanceInfo);
        }
        unbindMenuElement() {
            const menuElement = this._getMenuElement();
            menuElement.unbindFromCell();
        }
        pointInMenuElement(x, y) {
            const menuElement = this._getMenuElement();
            return menuElement.pointInMenuElement(x, y);
        }
        getRootElement() {
            return this._getMenuElement().rootElement;
        }
    }

    const CLASSNAME = 'vtable__menu-element';
    const HIDDEN_CLASSNAME = `${CLASSNAME}--hidden`;
    const SHOWN_CLASSNAME = `${CLASSNAME}--shown`;
    function createMenuDomElement() {
        const rootElement = createElement('div', [CLASSNAME, HIDDEN_CLASSNAME]);
        return rootElement;
    }
    class MenuContainer {
        _handler;
        _rootElement;
        _menuInstanceInfo;
        constructor(table) {
            this._handler = new EventHandler();
            this._rootElement = createMenuDomElement();
            this._rootElement.addEventListener('wheel', e => {
                e.stopPropagation();
            });
            this._rootElement?.addEventListener('mousedown', e => {
                e.stopPropagation();
                e.preventDefault();
            });
            this._rootElement?.addEventListener('click', e => {
                e.stopPropagation();
                e.preventDefault();
                if (this._rootElement.classList.contains(HIDDEN_CLASSNAME)) {
                    return;
                }
                const { col, row, dropDownIndex, menuKey, text, hasChildren } = e.target;
                if (typeof dropDownIndex !== 'number' || hasChildren) {
                    e.stopPropagation();
                    return;
                }
                const field = table.isPivotTable()
                    ? table.internalProps.layoutMap.getPivotDimensionInfo(col, row)
                    : table.getHeaderField(col, row);
                const highlight = table._dropDownMenuIsHighlight(col, row, dropDownIndex);
                table.fireListeners(TABLE_EVENT_TYPE.DROPDOWN_MENU_CLICK, {
                    col,
                    row,
                    field: field,
                    menuKey,
                    text,
                    highlight,
                    cellLocation: table.getCellLocation(col, row),
                    event: e
                });
                table.fireListeners(TABLE_EVENT_TYPE.DROPDOWN_MENU_CLEAR, null);
                table.fireListeners(TABLE_EVENT_TYPE.HIDE_MENU, null);
                e.stopPropagation();
            });
            this._rootElement?.addEventListener('mousemove', e => {
                if (this._rootElement.classList.contains(HIDDEN_CLASSNAME)) {
                    return;
                }
                e.stopPropagation();
            });
        }
        get rootElement() {
            return this._rootElement;
        }
        release() {
            this.unbindFromCell();
            const rootElement = this._rootElement;
            if (rootElement?.parentElement) {
                rootElement.parentElement.removeChild(rootElement);
            }
            this._handler.release();
            delete this._rootElement;
        }
        bindToCell(table, col, row, menuInstanceInfo) {
            const rootElement = this._rootElement;
            this._menuInstanceInfo = menuInstanceInfo;
            rootElement?.classList.remove(SHOWN_CLASSNAME);
            rootElement?.classList.add(HIDDEN_CLASSNAME);
            if (this._canBindToCell(table, col, row)) {
                rootElement.innerHTML = '';
                rootElement.appendChild(menuInstanceInfo.content);
                const binded = this._bindCell(table, col, row, menuInstanceInfo.position, menuInstanceInfo.referencePosition);
                if (binded) {
                    rootElement?.classList.add(SHOWN_CLASSNAME);
                    rootElement?.classList.remove(HIDDEN_CLASSNAME);
                    return true;
                }
            }
            else {
                this.unbindFromCell();
            }
            return false;
        }
        unbindFromCell() {
            const rootElement = this._rootElement;
            this._menuInstanceInfo = undefined;
            if (rootElement?.parentElement) {
                rootElement.classList.remove(SHOWN_CLASSNAME);
                rootElement.classList.add(HIDDEN_CLASSNAME);
            }
        }
        _canBindToCell(table, col, row) {
            const rect = table.getCellRangeRelativeRect({ col, row });
            const element = table.internalProps.menu.parentElement ?? table.getElement();
            const { top, bottom, left, right } = rect;
            if (table.isFrozenCell(col, row)) {
                return true;
            }
            else if (bottom < table.getFrozenRowsHeight() ||
                right < table.getFrozenColsWidth() ||
                left > table.tableNoFrameWidth - table.getRightFrozenColsWidth() ||
                top > table.tableNoFrameHeight - table.getBottomFrozenRowsHeight()) {
                return false;
            }
            const { offsetHeight, offsetWidth } = element;
            if (offsetHeight < top) {
                return false;
            }
            if (offsetWidth < left) {
                return false;
            }
            return true;
        }
        _bindCell(table, col, row, position, referencePosition) {
            const rootElement = this._rootElement;
            const element = table.internalProps.menu.parentElement ?? table.getElement();
            const { width: containerWidth, height: containerHeight, left: containerLeft, top: containerTop } = element.getBoundingClientRect();
            if (rootElement) {
                if (rootElement.parentElement !== element) {
                    element.appendChild(rootElement);
                }
                rootElement.style.left = `0px`;
                const maxWidth = containerWidth * 0.8;
                rootElement.style.maxWidth = `${maxWidth}px`;
                const rootElementWidth = rootElement.clientWidth;
                const rootElementHeight = rootElement.clientHeight;
                let rootElementLeft;
                let rootElementTop;
                if (position) {
                    rootElementLeft = position.x;
                    rootElementTop = position.y;
                }
                if (referencePosition) {
                    rootElementLeft = referencePosition.rect.right - rootElementWidth;
                    rootElementTop = referencePosition.rect.bottom;
                }
                if (rootElementTop + rootElementHeight > containerHeight) {
                    rootElementTop = containerHeight - rootElementHeight;
                    rootElementLeft += rootElementWidth - 2;
                }
                if (rootElementTop < 0) {
                    rootElementTop = rootElementTop / 2;
                }
                let deltaTop = 0;
                let deltaLeft = 0;
                if (table.getElement() !== element) {
                    const { left, top } = table.getElement().getBoundingClientRect();
                    deltaTop = top - containerTop;
                    deltaLeft = left - containerLeft;
                }
                rootElement.style.top = `${rootElementTop + deltaTop}px`;
                if (rootElementLeft < 0) {
                    rootElementLeft = 0;
                }
                else if (rootElementLeft + rootElementWidth > containerWidth) {
                    rootElementLeft = containerWidth - rootElementWidth;
                }
                rootElement.style.left = `${rootElementLeft + deltaLeft}px`;
                return true;
            }
            return false;
        }
        pointInMenuElement(x, y) {
            const rootElement = this._rootElement;
            const { x: rootLeft, y: rootTop, width: rootWidth, height: rootHeight } = rootElement.getBoundingClientRect();
            if (x > rootLeft - 5 && x < rootLeft + rootWidth + 5 && y > rootTop - 5 && y < rootTop + rootHeight + 5) {
                return true;
            }
            return false;
        }
    }

    class Menu extends BaseMenu {
        createMenuElementInternal() {
            return new MenuElement(this._table);
        }
    }
    let Container$1 = class Container extends BaseMenu {
        createMenuElementInternal() {
            return new MenuContainer(this._table);
        }
    };

    const MENU_INSTANCE_FACTORY = {
        'dropdown-menu': function (table) {
            return new Menu(table);
        },
        'context-menu': function (table) {
            return new Menu(table);
        },
        container(table) {
            return new Container$1(table);
        }
    };
    function getMenuInstanceInfo(table, col, row, type, dropDownMenuOptions) {
        const { lineHeight, textBaseline, textStick } = table._getCellStyle(col, row);
        let rect = table.getCellRangeRelativeRect(table.getCellRange(col, row));
        if (textStick) {
            rect = table.getVisibleCellRangeRelativeRect({ col, row });
        }
        let { left, right, bottom, top, width, height } = rect;
        if (table.isHeader(col, row)) {
            ({ left, right, bottom, top, width, height } = table.internalProps.headerHelper.getDropDownIconRect(rect, lineHeight, textBaseline || 'middle'));
        }
        if (dropDownMenuOptions?.content) {
            return {
                type,
                position: dropDownMenuOptions.position,
                referencePosition: dropDownMenuOptions.referencePosition ?? {
                    rect: {
                        left,
                        right,
                        top,
                        bottom,
                        width,
                        height
                    }
                },
                content: dropDownMenuOptions.content
            };
        }
        else if (type === 'dropdown-menu') {
            let dropDownMenu = table.globalDropDownMenu;
            const headerData = table._getHeaderLayoutMap(col, row);
            dropDownMenu = headerData.dropDownMenu ?? dropDownMenu;
            const pivotInfo = headerData.pivotInfo;
            if (typeof dropDownMenu === 'function') {
                dropDownMenu = dropDownMenu({ row, col, table });
            }
            return {
                type,
                referencePosition: {
                    rect: {
                        left,
                        right,
                        top,
                        bottom,
                        width,
                        height
                    }
                },
                content: dropDownMenu,
                pivotInfo
            };
        }
        return null;
    }
    class MenuHandler {
        _table;
        _menuInstances;
        _attachInfo;
        constructor(table) {
            this._table = table;
            this._menuInstances = {};
            this._bindTableEvent(table);
        }
        release() {
            const menuInstances = this._menuInstances;
            for (const k in menuInstances) {
                menuInstances[k].release();
            }
            delete this._menuInstances;
            this._attachInfo = null;
        }
        _bindToCell(col, row, type, dropDownMenuOptions) {
            const info = this._attachInfo;
            const instanceInfo = this._getMenuInstanceInfo(col, row, type, dropDownMenuOptions);
            if (info && (!instanceInfo || info.instance !== instanceInfo.instance)) {
                info.instance?.unbindMenuElement();
                this._attachInfo = null;
            }
            if (!instanceInfo) {
                return;
            }
            const { instance, info: menuInstanceInfo } = instanceInfo;
            const attach = instance && instance.bindMenuElement(col, row, menuInstanceInfo);
            if (attach) {
                const range = this._table.getCellRange(col, row);
                this._attachInfo = { range, instance };
            }
        }
        _unbindFromCell() {
            const info = this._attachInfo;
            if (!info) {
                return;
            }
            const { instance } = info;
            instance?.unbindMenuElement();
            this._attachInfo = null;
        }
        _isBindToCell(col, row) {
            const info = this._attachInfo;
            if (!info) {
                return false;
            }
            return cellInRange(info.range, col, row);
        }
        pointInMenuElement(x, y) {
            if (!this._attachInfo) {
                return false;
            }
            const info = this._attachInfo;
            const { instance } = info;
            return instance.pointInMenuElement(x, y);
        }
        _bindTableEvent(table) {
            table.on(TABLE_EVENT_TYPE.DROPDOWN_ICON_CLICK, e => {
                if (this._attachInfo) {
                    if (this._isBindToCell(e.col, e.row)) {
                        this._unbindFromCell();
                    }
                    else {
                        this._bindToCell(e.col, e.row, 'dropdown-menu');
                    }
                }
                else {
                    this._bindToCell(e.col, e.row, 'dropdown-menu');
                }
            });
            table.on(TABLE_EVENT_TYPE.DROPDOWN_MENU_CLEAR, e => {
                this._unbindFromCell();
            });
            table.on(TABLE_EVENT_TYPE.CONTEXTMENU_CELL, e => {
                if (table.internalProps.menu?.renderMode === 'html') {
                    const abstractPos = table._getMouseAbstractPoint(e.event);
                    let menu = null;
                    if (abstractPos.inTable && typeof table.internalProps.menu?.contextMenuItems === 'function') {
                        menu = table.internalProps.menu.contextMenuItems(table.getHeaderField(e.col, e.row), e.row, e.col, table);
                    }
                    else if (abstractPos.inTable && Array.isArray(table.internalProps.menu?.contextMenuItems)) {
                        menu = table.internalProps.menu?.contextMenuItems;
                    }
                    this._bindToCell(e.col, e.row, 'context-menu', {
                        content: menu,
                        position: { x: abstractPos.x, y: abstractPos.y }
                    });
                }
            });
        }
        _getMenuInstanceInfo(col, row, type, dropDownMenuOptions) {
            const table = this._table;
            const menuInstances = this._menuInstances;
            const info = getMenuInstanceInfo(table, col, row, type, dropDownMenuOptions);
            if (!info) {
                return null;
            }
            const instance = (menuInstances && menuInstances[type]) ||
                (menuInstances && (menuInstances[type] = MENU_INSTANCE_FACTORY[type](table)));
            return {
                instance,
                type,
                info
            };
        }
        containElement(el) {
            for (const k in this._menuInstances) {
                const contain = this._menuInstances[k].getRootElement()?.contains(el);
                if (contain) {
                    return true;
                }
            }
            return false;
        }
    }

    class Title {
        table;
        _titleOption;
        isReleased = false;
        _titleComponent;
        _cacheAttrs;
        constructor(titleOption, table) {
            this.table = table;
            this._titleOption = merge$1({ orient: 'top' }, titleOption);
            if (titleOption.visible !== false) {
                this._titleComponent = this._createOrUpdateTitleComponent(this._getTitleAttrs());
            }
        }
        _createOrUpdateTitleComponent(attrs) {
            if (this._titleComponent) {
                if (!isEqual(attrs, this._cacheAttrs)) {
                    this._titleComponent.setAttributes(attrs);
                }
            }
            else {
                const title = new Title$1(attrs);
                title.name = 'title';
                this.table.scenegraph.stage.defaultLayer.appendChild(title);
                this._titleComponent = title;
            }
            this._adjustTableSize(this._titleComponent.attribute);
            return this._titleComponent;
        }
        resize() {
            if (!this._titleComponent) {
                return;
            }
            const padding = getQuadProps(this._titleOption.padding ?? 10);
            const realWidth = this._titleOption.width ??
                (this.table.widthMode === 'adaptive'
                    ? this.table.tableNoFrameWidth
                    : Math.min(this.table.tableNoFrameWidth, this.table.getDrawRange().width)) -
                    padding[1] -
                    padding[3];
            const realHeight = this._titleOption.height ??
                (this.table.heightMode === 'adaptive'
                    ? this.table.tableNoFrameHeight
                    : Math.min(this.table.tableNoFrameHeight, this.table.getDrawRange().height)) -
                    padding[0] -
                    padding[2];
            this._titleComponent.setAttributes({
                x: this._titleOption.x ?? this._titleOption.orient === 'right'
                    ? this.table.tableX + Math.min(this.table.tableNoFrameWidth, this.table.getDrawRange().width)
                    : this.table.tableX,
                y: this._titleOption.y ?? this._titleOption.orient === 'bottom'
                    ? this.table.tableY + this.table.tableNoFrameHeight
                    : this.table.tableY,
                width: this._titleOption.orient === 'top' || this._titleOption.orient === 'bottom'
                    ? realWidth
                    : this._titleOption.width,
                height: this._titleOption.orient === 'left' || this._titleOption.orient === 'right'
                    ? realHeight
                    : this._titleOption.height,
                textStyle: {
                    width: realWidth,
                    ...this._titleOption.textStyle
                },
                subtextStyle: {
                    width: realWidth,
                    ...this._titleOption.subtextStyle
                }
            });
            this._adjustTableSize(this._titleComponent.attribute);
        }
        _adjustTableSize(attrs) {
            const width = isFinite(this._titleComponent?.AABBBounds.width()) ? this._titleComponent.AABBBounds.width() : 0;
            const height = isFinite(this._titleComponent?.AABBBounds.height()) ? this._titleComponent.AABBBounds.height() : 0;
            if (this._titleOption.orient === 'left') {
                this.table.tableNoFrameWidth = this.table.tableNoFrameWidth - Math.ceil(width);
                this.table.tableX += Math.ceil(width);
            }
            else if (this._titleOption.orient === 'top') {
                this.table.tableNoFrameHeight = this.table.tableNoFrameHeight - Math.ceil(height);
                this.table.tableY += Math.ceil(height);
            }
            else if (this._titleOption.orient === 'right') {
                this.table.tableNoFrameWidth = this.table.tableNoFrameWidth - Math.ceil(width);
            }
            else if (this._titleOption.orient === 'bottom') {
                this.table.tableNoFrameHeight = this.table.tableNoFrameHeight - Math.ceil(height);
            }
            this._cacheAttrs = attrs;
            if (this._titleOption.orient === 'right' || this._titleOption.orient === 'bottom') {
                this._titleComponent.setAttributes({
                    x: this._titleOption.x ?? this._titleOption.orient === 'right'
                        ? this.table.tableX + this.table.tableNoFrameWidth
                        : this.table.tableX,
                    y: this._titleOption.y ?? this._titleOption.orient === 'bottom'
                        ? this.table.tableY + this.table.tableNoFrameHeight
                        : this.table.tableY
                });
            }
        }
        release() {
            this._titleComponent && this.table.scenegraph.stage.defaultLayer.removeChild(this._titleComponent);
            this._titleComponent = null;
            this.isReleased = true;
        }
        _getTitleAttrs() {
            const defaultPadding = this._titleOption.text || this._titleOption.subtext ? 10 : 0;
            const padding = getQuadProps(this._titleOption.padding ?? defaultPadding);
            const realWidth = this._titleOption.width ??
                Math.min(this.table.tableNoFrameWidth, this.table.getDrawRange().width) - padding[1] - padding[3];
            const realHeight = this._titleOption.height ??
                Math.min(this.table.tableNoFrameHeight, this.table.getDrawRange().height) - padding[0] - padding[2];
            return {
                text: this._titleOption.text ?? '',
                subtext: this._titleOption.subtext ?? '',
                x: this._titleOption.x ?? this._titleOption.orient === 'right'
                    ? this.table.tableX + Math.min(this.table.tableNoFrameWidth, this.table.getDrawRange().width)
                    : this.table.tableX,
                y: this._titleOption.y ?? this._titleOption.orient === 'bottom'
                    ? this.table.tableY + this.table.tableNoFrameHeight
                    : this.table.tableY,
                width: this._titleOption.orient === 'top' || this._titleOption.orient === 'bottom'
                    ? realWidth
                    : this._titleOption.width,
                height: this._titleOption.orient === 'left' || this._titleOption.orient === 'right'
                    ? realHeight
                    : this._titleOption.height,
                minWidth: this._titleOption.minWidth,
                maxWidth: this._titleOption.maxWidth,
                minHeight: this._titleOption.minHeight,
                maxHeight: this._titleOption.maxHeight,
                padding: this._titleOption.padding,
                align: this._titleOption.align ?? 'left',
                verticalAlign: this._titleOption.verticalAlign ?? 'top',
                textStyle: {
                    width: realWidth,
                    ...this._titleOption.textStyle
                },
                subtextStyle: {
                    width: realWidth,
                    ...this._titleOption.subtextStyle
                },
                dx: this._titleOption.dx ?? 0,
                dy: this._titleOption.dy ?? 0
            };
        }
        getComponentGraphic() {
            return this._titleComponent;
        }
    }

    class BaseTooltip {
        _table;
        _tooltipElement;
        constructor(table) {
            this._table = table;
        }
        release() {
            this.unbindTooltipElement();
            if (this._tooltipElement) {
                this._tooltipElement.release?.();
            }
            this._tooltipElement = undefined;
        }
        _getTooltipElement() {
            if (this._tooltipElement) {
                return this._tooltipElement;
            }
            this._tooltipElement = this.createTooltipElementInternal();
            return this._tooltipElement;
        }
        bindTooltipElement(col, row, tooltipInstanceInfo, confine) {
            const tooltipElement = this._getTooltipElement();
            return tooltipElement.bindToCell(this._table, col, row, tooltipInstanceInfo, confine);
        }
        moveTooltipElement(col, row, tooltipOptions, confine) {
            const tooltipElement = this._getTooltipElement();
            tooltipElement.move(this._table, col, row, tooltipOptions, confine);
        }
        unbindTooltipElement() {
            const tooltipElement = this._getTooltipElement();
            tooltipElement.unbindFromCell();
        }
        locateTooltipElement(col, row, position, referencePosition, confine) {
            const tooltipElement = this._getTooltipElement();
            tooltipElement._locate(this._table, col, row, position, referencePosition, confine);
        }
    }

    function importStyle() {
        if (Env.mode === 'node') {
            return;
        }
        const styleElement = document.createElement('style');
        styleElement.id = 'vtable-tooltip-styleSheet';
        styleElement.textContent = `
@keyframes vtable__bubble-tooltip-element--shown-animation {
	0% {
		opacity: 0;
	}
	100% {
		opacity: 1;
	}
}
.vtable__bubble-tooltip-element {
	position: absolute;
	
	// pointer-events: none;
	//user-select: none;
	max-width: 300px;
	z-index: 99999;

	background: #FFFFFF;
    border: 1px solid #E6E8ED;
    box-sizing: border-box;
    border-radius: 4px;
    box-shadow: 0px 2px 4px rgb(27 31 35 / 8%);
    color: #141414;
    font-size: 13px;
}
.vtable__bubble-tooltip-element--hidden {
	opacity: 0;
  pointer-events: none;
	user-select: none;
	/* transform: translate(-50%, -50%); */
	transition: opacity 75ms linear;
}
.vtable__bubble-tooltip-element--shown {
	opacity: 1;
	/* transform: translate(-50%, -50%); */
	animation: vtable__bubble-tooltip-element--shown-animation 150ms ease-out;
}
.vtable__bubble-tooltip-element__content {
	/* font-size: .75rem; */
	padding: 6px 8px;
	min-height: 1em;
	line-height: 1.5;
	width: 100%;
	display: block;
	white-space: pre-wrap;
	margin: 0;
	box-sizing: border-box;
	overflow: auto;
	word-wrap: break-word;
	position: relative;
	background-color: #FFF;
	z-index: 2;
	border-radius: 4px;
}
/*  WebKit Microsoft Edge（新版）： */
.vtable__bubble-tooltip-element__content::-webkit-scrollbar {
  width: 0;
  height: 0;
  background-color: transparent;
}
/*  Opera Firefox  */
.vtable__bubble-tooltip-element__content > scrollbar-track {
  width: 0;
  height: 0;
  background-color: transparent;
}
/* Internet Explorer 11 和 Microsoft Edge（旧版） */
.vtable__bubble-tooltip-element__content > scrollbar {
  width: 0;
  height: 0;
  background-color: transparent;
}
.vtable__bubble-tooltip-element__triangle {
	/* font-size: .75rem; */
	position: absolute;
	width: 10px;
	height: 10px;
	display: block;
	transform: rotate(45deg);
    transform-origin: 50% 50% 0;
	z-index: 1;
	background-color: #FFF;
	border: 1px solid #E6E8ED;
}
`;
        document.head.appendChild(styleElement);
    }

    importStyle();
    const TOOLTIP_CLASS = 'vtable__bubble-tooltip-element';
    const CONTENT_CLASS = `${TOOLTIP_CLASS}__content`;
    const TRIANGLE_CLASS = `${TOOLTIP_CLASS}__triangle`;
    const HIDDEN_CLASS = `${TOOLTIP_CLASS}--hidden`;
    const SHOWN_CLASS = `${TOOLTIP_CLASS}--shown`;
    class BubbleTooltipElement {
        _handler;
        _rootElement;
        _messageElement;
        _triangleElement;
        _disappearDelay;
        _disappearDelayId;
        constructor() {
            this._handler = new EventHandler();
            const rootElement = (this._rootElement = createElement('div', [TOOLTIP_CLASS, HIDDEN_CLASS]));
            const messageElement = createElement('div', [CONTENT_CLASS]);
            const triangle = createElement('span', [TRIANGLE_CLASS]);
            rootElement.appendChild(triangle);
            rootElement.appendChild(messageElement);
            this._messageElement = rootElement.querySelector(`.${CONTENT_CLASS}`) || undefined;
            this._triangleElement = rootElement.querySelector(`.${TRIANGLE_CLASS}`) || undefined;
            rootElement.addEventListener('mousemove', () => {
                this._disappearDelayId && clearTimeout(this._disappearDelayId);
            });
            rootElement.addEventListener('mouseleave', () => {
                this._disappearDelay = undefined;
                this.unbindFromCell();
            });
            messageElement.addEventListener('wheel', e => {
                e.stopPropagation();
            });
            messageElement.addEventListener('copy', e => {
                const isSelected = isDivSelected(messageElement);
                if (isSelected) {
                    e.stopPropagation();
                }
            });
        }
        bindToCell(table, col, row, tooltipInstanceInfo, confine) {
            this._disappearDelay = tooltipInstanceInfo?.disappearDelay;
            this._disappearDelayId && clearTimeout(this._disappearDelayId);
            const rootElement = this._rootElement;
            const messageElement = this._messageElement;
            const triangle = this._triangleElement;
            rootElement?.classList.remove(SHOWN_CLASS);
            rootElement?.classList.add(HIDDEN_CLASS);
            if (this._canBindToCell(table, col, row)) {
                messageElement.setAttribute('style', '');
                triangle.setAttribute('style', '');
                tooltipInstanceInfo?.className && rootElement.classList.add(tooltipInstanceInfo.className);
                tooltipInstanceInfo?.style?.bgColor &&
                    (messageElement.style.backgroundColor = tooltipInstanceInfo?.style?.bgColor);
                tooltipInstanceInfo?.style?.bgColor && (triangle.style.backgroundColor = tooltipInstanceInfo?.style?.bgColor);
                triangle.style.display = tooltipInstanceInfo?.style?.arrowMark === true ? 'block' : 'none';
                tooltipInstanceInfo?.style?.fontSize &&
                    (messageElement.style.fontSize = (tooltipInstanceInfo?.style?.fontSize ?? 12) + 'px');
                tooltipInstanceInfo?.style?.fontFamily &&
                    (messageElement.style.fontFamily = tooltipInstanceInfo?.style?.fontFamily);
                tooltipInstanceInfo?.style?.color && (messageElement.style.color = tooltipInstanceInfo?.style?.color);
                tooltipInstanceInfo?.style?.padding &&
                    (messageElement.style.padding = `${tooltipInstanceInfo?.style?.padding.join('px ')}px`);
                tooltipInstanceInfo?.style?.maxHeight &&
                    (messageElement.style.maxHeight = `${tooltipInstanceInfo?.style?.maxHeight}px`);
                tooltipInstanceInfo?.style?.maxWidth &&
                    (messageElement.style.maxWidth = `${tooltipInstanceInfo?.style?.maxWidth}px`);
                messageElement && (messageElement.textContent = tooltipInstanceInfo?.content);
                const binded = this._bindToCell(table, col, row, tooltipInstanceInfo?.position, tooltipInstanceInfo?.referencePosition, confine, tooltipInstanceInfo?.style?.arrowMark);
                if (binded) {
                    rootElement?.classList.add(SHOWN_CLASS);
                    rootElement?.classList.remove(HIDDEN_CLASS);
                    return true;
                }
            }
            else {
                this.unbindFromCell();
            }
            return false;
        }
        release() {
            this.unbindFromCell();
            const rootElement = this._rootElement;
            if (rootElement?.parentElement) {
                rootElement.parentElement.removeChild(rootElement);
            }
            this._handler?.release?.();
            delete this._rootElement;
            delete this._messageElement;
        }
        move(table, col, row, tooltipOptions, confine) {
            const rootElement = this._rootElement;
            if (this._canBindToCell(table, col, row)) {
                this._bindToCell(table, col, row, tooltipOptions?.position, tooltipOptions?.referencePosition, confine);
                rootElement?.classList.add(SHOWN_CLASS);
                rootElement?.classList.remove(HIDDEN_CLASS);
            }
            else {
                this.unbindFromCell();
            }
        }
        unbindFromCell() {
            if (this._disappearDelay) {
                this._disappearDelayId = setTimeout(() => {
                    const rootElement = this._rootElement;
                    if (rootElement?.parentElement) {
                        rootElement.classList.remove(SHOWN_CLASS);
                        rootElement.classList.add(HIDDEN_CLASS);
                    }
                }, this._disappearDelay ?? 0);
            }
            else {
                const rootElement = this._rootElement;
                if (rootElement?.parentElement) {
                    rootElement.classList.remove(SHOWN_CLASS);
                    rootElement.classList.add(HIDDEN_CLASS);
                }
            }
        }
        _canBindToCell(table, col, row) {
            const rect = table.getCellRangeRelativeRect({ col, row });
            const element = table.getElement();
            const { bottom, left, right, top } = rect;
            if (table.isFrozenCell(col, row)) {
                return true;
            }
            else if (bottom < table.getFrozenRowsHeight() ||
                right < table.getFrozenColsWidth() ||
                left > table.tableNoFrameWidth - table.getRightFrozenColsWidth() ||
                top > table.tableNoFrameHeight - table.getBottomFrozenRowsHeight()) {
                return false;
            }
            const { offsetHeight, offsetWidth } = element;
            if (top > offsetHeight) {
                return false;
            }
            if (left > offsetWidth) {
                return false;
            }
            return true;
        }
        _bindToCell(table, col, row, position, referencePosition, confine, arrowMark) {
            const rootElement = this._rootElement;
            const rect = table.getCellRangeRelativeRect({ col, row });
            const element = table.internalProps.tooltip.parentElement;
            const containerWidth = table.internalProps.element.offsetWidth;
            const { width } = rect;
            if (rootElement) {
                if (rootElement.parentElement !== element) {
                    element.appendChild(rootElement);
                }
                rootElement.style.left = `0px`;
                let tooltipY;
                let tooltipX;
                const maxWidth = Math.min(containerWidth * 0.8, width * 4);
                rootElement.style.maxWidth = `${maxWidth}px`;
                const rootElementWidth = rootElement.clientWidth;
                const rootElementHeight = rootElement.clientHeight;
                if (position || referencePosition) {
                    const tooltipPosition = this.getComputedPosition(table, col, row, position, referencePosition, confine, arrowMark);
                    tooltipX = tooltipPosition.x;
                    tooltipY = tooltipPosition.y;
                }
                else {
                    return false;
                }
                rootElement.style.left = `${tooltipX}px`;
                rootElement.style.top = `${tooltipY}px`;
                if (isMobile()) {
                    rootElement.style.fontSize = '11px';
                }
                const { x1: menuLeft, x2: menuRight, y1: menuTop, y2: menuBottom } = table.stateManager.menu.bounds;
                const tooltipLeft = tooltipX;
                const tooltipRight = tooltipLeft + rootElementWidth;
                const tooltipTop = tooltipY;
                const tooltipBottom = tooltipLeft + rootElementHeight;
                if (table.stateManager.menu.isShow &&
                    menuLeft < tooltipRight &&
                    menuRight > tooltipLeft &&
                    menuBottom > tooltipTop &&
                    menuTop < tooltipBottom) {
                    return false;
                }
                return true;
            }
            return false;
        }
        getComputedPosition(table, col, row, position, referencePosition, confine, arrowMark) {
            const rootElement = this._rootElement;
            const rect = table.getCellRangeRelativeRect({ col, row });
            const { x: parentX, y: parentY } = table.internalProps.tooltip.parentElement.getBoundingClientRect();
            const { width: containerWidth, height: containerHeight, x, y } = table.internalProps.element.getBoundingClientRect();
            const { width } = rect;
            let tooltipY;
            let tooltipX;
            const maxWidth = Math.min(containerWidth * 0.8, width * 4);
            rootElement.style.maxWidth = `${maxWidth}px`;
            const rootElementWidth = rootElement.clientWidth;
            const rootElementHeight = rootElement.clientHeight;
            const triangleHeight = arrowMark ? 6 : 0;
            if (position) {
                tooltipX = position.x;
                tooltipY = position.y + triangleHeight;
                this._triangleElement.style.left = '50%';
                this._triangleElement.style.marginLeft = '-5px';
                this._triangleElement.style.top = '-5px';
            }
            else if (referencePosition) {
                let placement = referencePosition.placement ?? Placement.bottom;
                const referenceXMiddle = referencePosition.rect.left + referencePosition.rect.width / 2;
                const referenceYMiddle = referencePosition.rect.top + referencePosition.rect.height / 2;
                const referenceTop = referencePosition.rect.top;
                const referenceBottom = referencePosition.rect.bottom;
                const referenceLeft = referencePosition.rect.left;
                const referenceRight = referencePosition.rect.right;
                let callCount = 0;
                const adjustPosition = () => {
                    callCount++;
                    if (callCount >= 4) {
                        return;
                    }
                    this.removeStyleFromTriangle();
                    if (placement === Placement.top) {
                        tooltipX = referenceXMiddle - rootElementWidth / 2;
                        tooltipY = referenceTop - rootElementHeight - triangleHeight;
                        this._triangleElement.style.left = '50%';
                        this._triangleElement.style.marginLeft = '-5px';
                        this._triangleElement.style.bottom = '-5px';
                        if (confine && tooltipY < 0) {
                            placement = Placement.right;
                            adjustPosition();
                        }
                    }
                    else if (placement === Placement.bottom) {
                        tooltipX = referenceXMiddle - rootElementWidth / 2;
                        tooltipY = referenceBottom + triangleHeight;
                        this._triangleElement.style.left = '50%';
                        this._triangleElement.style.marginLeft = '-5px';
                        this._triangleElement.style.top = '-5px';
                        if (confine && tooltipY + rootElementHeight > containerHeight) {
                            placement = Placement.left;
                            adjustPosition();
                        }
                    }
                    else if (placement === Placement.left) {
                        tooltipY = referenceYMiddle - rootElementHeight / 2;
                        tooltipX = referenceLeft - rootElementWidth - triangleHeight;
                        this._triangleElement.style.top = '50%';
                        this._triangleElement.style.marginTop = '-5px';
                        this._triangleElement.style.right = '-5px';
                        if (confine && tooltipX < 0) {
                            placement = Placement.top;
                            adjustPosition();
                        }
                    }
                    else if (placement === Placement.right) {
                        tooltipY = referenceYMiddle - rootElementHeight / 2;
                        tooltipX = referenceRight + triangleHeight;
                        this._triangleElement.style.top = '50%';
                        this._triangleElement.style.marginTop = '-5px';
                        this._triangleElement.style.left = '-5px';
                        if (confine && tooltipX + rootElementWidth > containerWidth) {
                            placement = Placement.bottom;
                            adjustPosition();
                        }
                    }
                };
                adjustPosition();
            }
            if (confine) {
                if (tooltipX < 0) {
                    tooltipX = 0;
                }
                else if (tooltipX + rootElement.offsetWidth > containerWidth) {
                    tooltipX = containerWidth - rootElement.offsetWidth;
                }
            }
            return {
                x: tooltipX + x - parentX,
                y: tooltipY + y - parentY
            };
        }
        removeStyleFromTriangle() {
            this._triangleElement.style.left = '';
            this._triangleElement.style.right = '';
            this._triangleElement.style.top = '';
            this._triangleElement.style.bottom = '';
            this._triangleElement.style.marginLeft = '';
            this._triangleElement.style.marginTop = '';
        }
        _locate(table, col, row, position, referencePosition, confine) {
            const tooltipPosition = this.getComputedPosition(table, col, row, position, referencePosition, confine);
            const tooltipX = tooltipPosition.x;
            const tooltipY = tooltipPosition.y;
            this._rootElement.style.left = `${tooltipX}px`;
            this._rootElement.style.top = `${tooltipY}px`;
        }
    }

    class BubbleTooltip extends BaseTooltip {
        createTooltipElementInternal() {
            return new BubbleTooltipElement();
        }
    }

    const TOOLTIP_INSTANCE_FACTORY = {
        'bubble-tooltip': function (table) {
            return new BubbleTooltip(table);
        }
    };
    class TooltipHandler {
        _table;
        _tooltipInstances;
        _attachInfo;
        confine;
        constructor(table, confine) {
            this._table = table;
            this._tooltipInstances = {};
            this._bindTableEvent(table);
            this.confine = confine;
        }
        release() {
            const tooltipInstances = this._tooltipInstances;
            for (const k in tooltipInstances) {
                tooltipInstances[k]?.release?.();
            }
            delete this._tooltipInstances;
            this._attachInfo = null;
        }
        _bindToCell(col, row, tooltipOptions) {
            const info = this._attachInfo;
            const instance = this._getTooltipInstanceInfo(col, row);
            if (info && (!instance || info.instance !== instance)) {
                info.instance?.unbindTooltipElement();
                this._attachInfo = null;
            }
            if (!instance) {
                return;
            }
            const attach = instance && instance.bindTooltipElement(col, row, tooltipOptions, this.confine);
            if (attach) {
                const range = this._table.getCellRange(col, row);
                this._attachInfo = { range, instance, tooltipOptions };
            }
        }
        _move(col, row, tooltipOptions) {
            const info = this._attachInfo;
            if (!info || !cellInRange(info.range, col, row)) {
                return;
            }
            const { instance } = info;
            instance?.moveTooltipElement(col, row, tooltipOptions, this.confine);
        }
        moveToPosition(col, row, position, referencePosition) {
            const info = this._attachInfo;
            if (!info || !cellInRange(info.range, col, row)) {
                return;
            }
            const { instance } = info;
            this._attachInfo.tooltipOptions.position = position;
            this._attachInfo.tooltipOptions.referencePosition = referencePosition;
            instance?.locateTooltipElement(col, row, position, referencePosition, this.confine);
        }
        _unbindFromCell() {
            const info = this._attachInfo;
            if (!info) {
                return;
            }
            const { instance } = info;
            instance?.unbindTooltipElement();
            this._attachInfo = null;
        }
        _isBindCell(col, row) {
            const info = this._attachInfo;
            if (!info) {
                return false;
            }
            return cellInRange(info.range, col, row);
        }
        _bindTableEvent(table) {
            table.on(TABLE_EVENT_TYPE.MOUSEENTER_CELL, e => {
                if (isMobile()) {
                    return;
                }
                const { x1: left, x2: right, y1: top, y2: bottom } = table.stateManager.menu.bounds;
                if (table.stateManager.menu.isShow &&
                    typeof e.x === 'number' &&
                    typeof e.y === 'number' &&
                    e.x > left &&
                    e.x < right &&
                    e.y > top &&
                    e.y < bottom) {
                    return;
                }
                const { col, row } = e;
                this.showTooltip(col, row);
            });
            table.on(TABLE_EVENT_TYPE.MOUSEMOVE_CELL, e => {
                if (isMobile()) {
                    return;
                }
                if (this._attachInfo?.tooltipOptions?.referencePosition) {
                    const position = this._attachInfo.tooltipOptions.referencePosition;
                    const { event } = e;
                    const { left, right, top, bottom } = position.rect;
                    const abstractPos = table._getMouseAbstractPoint(event);
                    if (!(abstractPos.inTable &&
                        abstractPos.x >= left - 5 &&
                        abstractPos.x <= right + 5 &&
                        abstractPos.y >= top - 5 &&
                        abstractPos.y <= bottom + 5)) {
                        this._unbindFromCell();
                    }
                }
                if (this._attachInfo && table.stateManager.menu.isShow) {
                    this._bindToCell(e.col, e.row);
                }
            });
            table.on(TABLE_EVENT_TYPE.MOUSELEAVE_CELL, e => {
                this._unbindFromCell();
            });
            table.on(TABLE_EVENT_TYPE.SELECTED_CELL, e => {
                if (this._isBindCell(e.col, e.row)) {
                    this._unbindFromCell();
                }
            });
            table.on(TABLE_EVENT_TYPE.MOUSELEAVE_TABLE, e => {
                this._unbindFromCell();
            });
            table.on(TABLE_EVENT_TYPE.SCROLL, e => {
                this._unbindFromCell();
            });
        }
        showTooltip(col, row) {
            let tooltipOption;
            const table = this._table;
            const headerDescription = table.getHeaderDescription(col, row);
            if (headerDescription) {
                const rect = table.getCellRangeRelativeRect({ col, row });
                tooltipOption = {
                    content: headerDescription,
                    referencePosition: {
                        placement: table.internalProps.tooltip.position,
                        rect
                    },
                    disappearDelay: table.internalProps.tooltip.overflowTextTooltipDisappearDelay ?? 0,
                    style: table.theme.tooltipStyle
                };
            }
            else if (isFunction$5(table.internalProps.tooltip?.isShowOverflowTextTooltip)
                ? table.internalProps.tooltip.isShowOverflowTextTooltip(col, row, table)
                : table.internalProps.tooltip.isShowOverflowTextTooltip) {
                const overflowText = table.getCellOverflowText(col, row);
                const rect = table.getCellRangeRelativeRect({ col, row });
                if (overflowText) {
                    tooltipOption = {
                        content: headerDescription
                            ? `${headerDescription}
  ${overflowText}`
                            : overflowText,
                        referencePosition: {
                            placement: table.internalProps.tooltip.position,
                            rect
                        },
                        disappearDelay: table.internalProps.tooltip.overflowTextTooltipDisappearDelay ?? 0,
                        style: table.theme.tooltipStyle
                    };
                }
            }
            if (tooltipOption) {
                this._bindToCell(col, row, tooltipOption);
            }
            else {
                this._unbindFromCell();
            }
        }
        _getTooltipInstanceInfo(col, row) {
            const table = this._table;
            const tooltipInstances = this._tooltipInstances;
            const tooltipType = 'bubble-tooltip';
            const instance = (tooltipInstances && tooltipInstances[tooltipType]) ||
                (tooltipInstances && (tooltipInstances[tooltipType] = TOOLTIP_INSTANCE_FACTORY[tooltipType](table)));
            return instance;
        }
        isBinded(tooltipOptions) {
            if (JSON.stringify(tooltipOptions) === JSON.stringify(this._attachInfo?.tooltipOptions)) {
                return true;
            }
            return false;
        }
    }

    const registerAxis = () => {
        Factory.registerComponent('axis', CartesianAxis);
        Factory.registerFunction('computeAxisComponentWidth', computeAxisComponentWidth);
        Factory.registerFunction('computeAxisComponentHeight', computeAxisComponentHeight);
        Factory.registerFunction('getAxisConfigInPivotChart', getAxisConfigInPivotChart);
    };
    const registerEmptyTip = () => {
        Factory.registerComponent('emptyTip', EmptyTip);
    };
    const registerLegend = () => {
        Factory.registerFunction('createLegend', createLegend);
    };
    const registerMenu = () => {
        Factory.registerComponent('menuHandler', MenuHandler);
    };
    const registerTitle = () => {
        Factory.registerComponent('title', Title);
    };
    const registerTooltip = () => {
        Factory.registerComponent('tooltipHandler', TooltipHandler);
    };

    class ListTreeStickCellPlugin {
        table;
        titleRows = [];
        showedTitleRows = [];
        rowNow = -1;
        skipStartRow = -1;
        skipEndRow = -1;
        constructor(table) {
            this.table = table;
            this.table.on('scroll', e => {
                if (e.scrollDirection !== 'vertical') {
                    return;
                }
                this.updateGroupTitle();
            });
            this.table.on('tree_hierarchy_state_change', e => {
                this.updateGroupTitle();
            });
            this.table.on('resize_column', e => {
                this.updateGroupTitle();
            });
        }
        updateGroupTitle() {
            if (this.table.scrollTop === 0) {
                this.titleRows = [];
                this.showedTitleRows = [];
            }
            else if (this.skipStartRow !== -1 &&
                this.skipEndRow !== -1 &&
                this.skipStartRow !== this.table.scenegraph.proxy.bodyTopRow - 1) {
                if (this.table.scenegraph.proxy.screenTopRow <= this.skipStartRow ||
                    this.table.scenegraph.proxy.screenTopRow >= this.skipEndRow) {
                    this.skipStartRow = -1;
                    this.skipEndRow = -1;
                    this.updateGroupTitleInfo();
                }
            }
            else {
                this.skipStartRow = -1;
                this.skipEndRow = -1;
                this.updateGroupTitleInfo();
            }
            this.updateScenegraph();
        }
        updateGroupTitleInfo() {
            this.rowNow = this.table.scenegraph.proxy.screenTopRow + this.titleRows.length;
            const recordIndex = this.table.getRecordIndexByCell(0, this.rowNow);
            const nextRecordIndex = this.table.getRecordIndexByCell(0, this.rowNow + 1);
            this.getTitleRowsByRecordIndex(recordIndex, nextRecordIndex);
        }
        getTitleRowsByRecordIndex(recordIndex, nextRecordIndex) {
            if (!isArray$7(recordIndex)) {
                recordIndex = [recordIndex];
            }
            if (!isArray$7(nextRecordIndex)) {
                nextRecordIndex = [nextRecordIndex];
            }
            for (let i = 0; i < recordIndex.length; i++) {
                const index = recordIndex.slice(0, i + 1);
                this.table.dataSource.getRaw(index);
            }
            const titleRows = [];
            const isTitle = nextRecordIndex.length === recordIndex.length + 1;
            let titleIndex = recordIndex.slice(0, !isTitle ? recordIndex.length - 1 : recordIndex.length);
            const currentIndexedData = this.table.dataSource.currentIndexedData;
            const startIndex = this.rowNow - this.table.columnHeaderLevelCount;
            for (let i = startIndex; i >= 0; i--) {
                const currentIndex = currentIndexedData[i];
                if (isArray$7(currentIndex) && titleIndex.length === currentIndex.length) {
                    let isMatch = true;
                    for (let j = 0; j < currentIndex.length; j++) {
                        if (currentIndex[j] !== titleIndex[j]) {
                            isMatch = false;
                            break;
                        }
                    }
                    if (isMatch) {
                        titleRows.push(i + this.table.columnHeaderLevelCount);
                        titleIndex = titleIndex.slice(0, titleIndex.length - 1);
                    }
                }
                else if (currentIndex === recordIndex[0]) {
                    titleRows.push(i + this.table.columnHeaderLevelCount);
                    break;
                }
            }
            this.titleRows = titleRows.reverse();
        }
        updateScenegraph() {
            const { table } = this;
            const { shadowGroup, shadowGroupFrozen } = prepareShadowRoot(table);
            this.showedTitleRows.length = 0;
            let skip = 0;
            for (let col = 0; col < table.colCount; col++) {
                let colGroup;
                if (col < table.frozenColCount) {
                    colGroup = new Group$1({
                        x: table.getColsWidth(0, col - 1),
                        y: table.getFrozenRowsHeight()
                    });
                    shadowGroupFrozen.add(colGroup);
                }
                else {
                    colGroup = new Group$1({
                        x: table.getColsWidth(table.frozenColCount, col - 1),
                        y: table.getFrozenRowsHeight()
                    });
                    shadowGroup.add(colGroup);
                }
                colGroup.col = col;
                for (let i = 0; i < this.titleRows.length; i++) {
                    const row = this.titleRows[i];
                    if (isSkipRow(row, this.rowNow, table.scenegraph.proxy.screenTopRow, this.titleRows)) {
                        col === 0 && skip++;
                        continue;
                    }
                    if (col === 0) {
                        this.showedTitleRows.push(row);
                    }
                    const cell = table.scenegraph.getCell(col, row);
                    if (cell.role === 'cell') {
                        const newCell = cloneGraphic(cell);
                        newCell.setAttributes({
                            y: i * 40
                        });
                        colGroup.add(newCell);
                    }
                    else {
                        const newCell = updateCell$1(col, row, table, true, true);
                        newCell.setAttributes({
                            y: i * 40
                        });
                        colGroup.add(newCell);
                    }
                }
            }
            if (skip > 0 && this.skipStartRow === -1 && this.skipEndRow === -1) {
                this.skipStartRow = table.scenegraph.proxy.screenTopRow - 1;
                this.skipEndRow = table.scenegraph.proxy.screenTopRow + 1;
            }
        }
    }
    function isSkipRow(row, topRow, screenTopRow, titleRows) {
        if (row === topRow && row !== screenTopRow + titleRows.length - 1) {
            return true;
        }
        const rowIndex = titleRows.indexOf(row);
        const rowLimit = screenTopRow + rowIndex + 1;
        if (row === rowLimit && row < topRow) {
            return true;
        }
        return false;
    }
    function cloneGraphic(graphic) {
        const newGraphic = graphic.clone();
        newGraphic.role = graphic.role;
        newGraphic.col = graphic.col;
        newGraphic.row = graphic.row;
        newGraphic.mergeStartCol = graphic.mergeStartCol;
        newGraphic.mergeStartRow = graphic.mergeStartRow;
        newGraphic.mergeEndCol = graphic.mergeEndCol;
        newGraphic.mergeEndRow = graphic.mergeEndRow;
        newGraphic.contentWidth = graphic.contentWidth;
        newGraphic.contentHeight = graphic.contentHeight;
        if (newGraphic.role === 'cell') {
            const hackRect = createRect({
                x: 0,
                y: 0,
                width: newGraphic.attribute.width,
                height: newGraphic.attribute.height
            });
            newGraphic.add(hackRect);
        }
        if (graphic.type === 'group') {
            const newGroup = newGraphic;
            graphic.forEachChildren(child => {
                const newChild = cloneGraphic(child);
                newGroup.add(newChild);
            });
        }
        return newGraphic;
    }
    function prepareShadowRoot(table) {
        const colHeaderGroup = table.scenegraph.colHeaderGroup;
        const cornerHeaderGroup = table.scenegraph.cornerHeaderGroup;
        if (!colHeaderGroup.border) {
            const hackBorder = createRect({
                x: 0,
                y: 0,
                width: 0,
                height: 0,
                cursor: 'pointer'
            });
            colHeaderGroup.add(hackBorder);
            colHeaderGroup.border = hackBorder;
            hackBorder.attachShadow(hackBorder.shadowRoot);
            hackBorder.name = 'border-rect';
            hackBorder.addEventListener('click', (e) => {
                const titleRows = table.listTreeStickCellPlugin.titleRows;
                const { shadowTarget } = e.pickParams;
                const cellGroup = getTargetCell(shadowTarget);
                const { col, row } = cellGroup;
                const rowIndex = titleRows.indexOf(row);
                scrollToRow(row - rowIndex, table);
            });
        }
        if (!cornerHeaderGroup.border) {
            const hackBorder = createRect({
                x: 0,
                y: 0,
                width: 0,
                height: 0,
                cursor: 'pointer'
            });
            cornerHeaderGroup.add(hackBorder);
            cornerHeaderGroup.border = hackBorder;
            hackBorder.attachShadow(hackBorder.shadowRoot);
            hackBorder.name = 'border-rect';
            hackBorder.addEventListener('click', (e) => {
                const titleRows = table.listTreeStickCellPlugin.titleRows;
                const { shadowTarget } = e.pickParams;
                const cellGroup = getTargetCell(shadowTarget);
                const { col, row } = cellGroup;
                const rowIndex = titleRows.indexOf(row);
                scrollToRow(row - rowIndex, table);
            });
        }
        const shadowGroup = colHeaderGroup.border.shadowRoot;
        const shadowGroupFrozen = cornerHeaderGroup.border.shadowRoot;
        shadowGroup.removeAllChild();
        shadowGroupFrozen.removeAllChild();
        return { shadowGroup, shadowGroupFrozen };
    }
    function scrollToRow(row, table) {
        const drawRange = table.getDrawRange();
        if (isValid$3(row) && row >= table.frozenRowCount) {
            const frozenHeight = table.getFrozenRowsHeight();
            const top = table.getRowsHeight(0, row - 1);
            table.scrollTop = Math.min(top - frozenHeight, table.getAllRowsHeight() - drawRange.height) - 1;
        }
        table.scenegraph.updateNextFrame();
    }
    const registerListTreeStickCellPlugin = () => {
        Factory.registerComponent('listTreeStickCellPlugin', ListTreeStickCellPlugin);
    };

    function createChartCellGroup(cellGroup, columnGroup, xOrigin, yOrigin, col, row, width, height, padding, dataValue, chartModule, chartSpec, chartInstance, dataId, table, cellTheme, isShareChartSpec, isAsync, isNoChartDataRenderNothing) {
        const registerCharts = get$1();
        const ClassType = registerCharts[chartModule];
        const headerStyle = table._getCellStyle(col, row);
        const functionalPadding = getFunctionalProp('padding', headerStyle, col, row, table);
        if (isValid$3(functionalPadding)) {
            padding = functionalPadding;
        }
        if (!cellGroup) {
            const strokeArrayWidth = getCellBorderStrokeWidth(col, row, cellTheme, table);
            if (isAsync) {
                cellGroup = table.scenegraph.highPerformanceGetCell(col, row, true);
                if (cellGroup && cellGroup.role === 'cell') {
                    cellGroup.setAttributes({
                        x: xOrigin,
                        y: yOrigin,
                        width,
                        height,
                        lineWidth: cellTheme?.group?.lineWidth ?? undefined,
                        fill: cellTheme?.group?.fill ?? undefined,
                        stroke: cellTheme?.group?.stroke ?? undefined,
                        strokeArrayWidth: strokeArrayWidth,
                        strokeArrayColor: cellTheme?.group?.strokeArrayColor ?? undefined,
                        cursor: cellTheme?.group?.cursor ?? undefined,
                        lineDash: cellTheme?.group?.lineDash ?? undefined,
                        lineCap: 'butt',
                        clip: true,
                        cornerRadius: cellTheme.group.cornerRadius
                    });
                }
            }
            if (!cellGroup || cellGroup.role !== 'cell') {
                cellGroup = new Group$1({
                    x: xOrigin,
                    y: yOrigin,
                    width,
                    height,
                    lineWidth: cellTheme?.group?.lineWidth ?? undefined,
                    fill: cellTheme?.group?.fill ?? undefined,
                    stroke: cellTheme?.group?.stroke ?? undefined,
                    strokeArrayWidth: strokeArrayWidth,
                    strokeArrayColor: cellTheme?.group?.strokeArrayColor ?? undefined,
                    cursor: cellTheme?.group?.cursor ?? undefined,
                    lineDash: cellTheme?.group?.lineDash ?? undefined,
                    lineCap: 'butt',
                    clip: true,
                    cornerRadius: cellTheme.group.cornerRadius
                });
                cellGroup.role = 'cell';
                cellGroup.col = col;
                cellGroup.row = row;
                columnGroup?.addCellGroup(cellGroup);
            }
        }
        cellGroup.AABBBounds.width();
        if ((isNoChartDataRenderNothing && Array.isArray(table.getCellValue(col, row))) || !isNoChartDataRenderNothing) {
            const chartGroup = new Chart(isShareChartSpec, {
                stroke: false,
                x: padding[3],
                y: padding[0],
                canvas: table.canvas ?? table.scenegraph.stage.window.getContext().canvas,
                mode: table.options.mode,
                modeParams: table.options.modeParams,
                spec: table.options.specTransformInCell ? table.options.specTransformInCell(chartSpec, col, row) : chartSpec,
                ClassType,
                width: width - padding[3] - padding[1],
                height: height - padding[2] - padding[0],
                chartInstance,
                dataId,
                data: table.getCellValue(col, row) || [],
                cellPadding: padding,
                dpr: table.internalProps.pixelRatio,
                axes: table.isPivotChart() ? table.internalProps.layoutMap.getChartAxes(col, row) : [],
                tableChartOption: table.options.chartOption,
                col,
                row
            });
            cellGroup.appendChild(chartGroup);
            table.internalProps.layoutMap.setChartInstance(col, row, chartGroup.chartInstance);
        }
        return cellGroup;
    }

    function createCheckboxCellGroup(cellGroup, columnGroup, xOrigin, yOrigin, col, row, colWidth, width, height, padding, textAlign, textBaseline, mayHaveIcon, table, cellTheme, define, range, isAsync) {
        if (!cellGroup) {
            const strokeArrayWidth = getCellBorderStrokeWidth(col, row, cellTheme, table);
            if (isAsync) {
                cellGroup = table.scenegraph.highPerformanceGetCell(col, row, true);
                if (cellGroup && cellGroup.role === 'cell') {
                    cellGroup.setAttributes({
                        x: xOrigin,
                        y: yOrigin,
                        width,
                        height,
                        lineWidth: cellTheme?.group?.lineWidth ?? undefined,
                        fill: cellTheme?.group?.fill ?? undefined,
                        stroke: cellTheme?.group?.stroke ?? undefined,
                        strokeArrayWidth: strokeArrayWidth,
                        strokeArrayColor: cellTheme?.group?.strokeArrayColor ?? undefined,
                        cursor: cellTheme?.group?.cursor ?? undefined,
                        lineDash: cellTheme?.group?.lineDash ?? undefined,
                        lineCap: 'butt',
                        clip: true,
                        cornerRadius: cellTheme.group.cornerRadius
                    });
                }
            }
            if (!cellGroup || cellGroup.role !== 'cell') {
                cellGroup = new Group$1({
                    x: xOrigin,
                    y: yOrigin,
                    width,
                    height,
                    lineWidth: cellTheme?.group?.lineWidth ?? undefined,
                    fill: cellTheme?.group?.fill ?? undefined,
                    stroke: cellTheme?.group?.stroke ?? undefined,
                    strokeArrayWidth: strokeArrayWidth,
                    strokeArrayColor: cellTheme?.group?.strokeArrayColor ?? undefined,
                    cursor: cellTheme?.group?.cursor ?? undefined,
                    lineDash: cellTheme?.group?.lineDash ?? undefined,
                    lineCap: 'butt',
                    clip: true,
                    cornerRadius: cellTheme.group.cornerRadius
                });
                cellGroup.role = 'cell';
                cellGroup.col = col;
                cellGroup.row = row;
                columnGroup?.addCellGroup(cellGroup);
            }
        }
        let icons;
        if (mayHaveIcon) {
            let iconCol = col;
            let iconRow = row;
            if (range) {
                iconCol = range.start.col;
                iconRow = range.start.row;
            }
            icons = table.getCellIcons(iconCol, iconRow);
        }
        let iconWidth = 0;
        let cellLeftIconWidth = 0;
        if (Array.isArray(icons) && icons.length !== 0) {
            const { leftIconWidth, rightIconWidth, absoluteLeftIconWidth, absoluteRightIconWidth } = dealWithIconLayout(icons, cellGroup, range, table);
            iconWidth = leftIconWidth + rightIconWidth;
            cellLeftIconWidth = leftIconWidth;
            cellGroup.forEachChildren((child) => {
                if (child.role === 'icon-left') {
                    child.setAttribute('x', child.attribute.x + padding[3]);
                }
                else if (child.role === 'icon-right') {
                    child.setAttribute('x', child.attribute.x + width - rightIconWidth - padding[1]);
                }
                else if (child.role === 'icon-absolute-right') {
                    child.setAttribute('x', child.attribute.x + width - absoluteRightIconWidth - padding[1]);
                }
            });
            cellGroup.forEachChildren((child) => {
                if (textBaseline === 'middle') {
                    child.setAttribute('y', (height - child.AABBBounds.height()) / 2);
                }
                else if (textBaseline === 'bottom') {
                    child.setAttribute('y', height - child.AABBBounds.height() - padding[2]);
                }
                else {
                    child.setAttribute('y', padding[0]);
                }
            });
        }
        const checkboxComponent = createCheckbox(col, row, colWidth - iconWidth, width, height, padding, cellTheme, define, table);
        if (checkboxComponent) {
            cellGroup.appendChild(checkboxComponent);
        }
        checkboxComponent.render();
        width -= padding[1] + padding[3] + iconWidth;
        height -= padding[0] + padding[2];
        if (textAlign === 'center') {
            checkboxComponent.setAttribute('x', padding[3] + cellLeftIconWidth + (width - checkboxComponent.AABBBounds.width()) / 2);
        }
        else if (textAlign === 'right') {
            checkboxComponent.setAttribute('x', padding[3] + cellLeftIconWidth + width - checkboxComponent.AABBBounds.width());
        }
        else {
            checkboxComponent.setAttribute('x', padding[3] + cellLeftIconWidth);
        }
        if (textBaseline === 'middle') {
            checkboxComponent.setAttribute('y', padding[0] + (height - checkboxComponent.AABBBounds.height()) / 2);
        }
        else if (textBaseline === 'bottom') {
            checkboxComponent.setAttribute('y', padding[0] + height - checkboxComponent.AABBBounds.height());
        }
        else {
            checkboxComponent.setAttribute('y', padding[0]);
        }
        return cellGroup;
    }
    function createCheckbox(col, row, colWidth, cellWidth, cellHeight, padding, cellTheme, define, table) {
        const style = table._getCellStyle(col, row);
        const size = getProp('size', style, col, row, table);
        const spaceBetweenTextAndIcon = getProp('spaceBetweenTextAndIcon', style, col, row, table);
        const defaultFill = getProp('defaultFill', style, col, row, table);
        const defaultStroke = getProp('defaultStroke', style, col, row, table);
        const disableFill = getProp('disableFill', style, col, row, table);
        const checkedFill = getProp('checkedFill', style, col, row, table);
        const checkedStroke = getProp('checkedStroke', style, col, row, table);
        const disableCheckedFill = getProp('disableCheckedFill', style, col, row, table);
        const disableCheckedStroke = getProp('disableCheckedStroke', style, col, row, table);
        const checkIconImage = getProp('checkIconImage', style, col, row, table);
        const indeterminateIconImage = getProp('indeterminateIconImage', style, col, row, table);
        const value = table.getCellValue(col, row);
        const dataValue = table.getCellOriginValue(col, row);
        let isChecked;
        let isDisabled;
        let text = value ?? '';
        if (isObject$7(value)) {
            isChecked = value.checked;
            isDisabled = value.disable;
            text = value.text ?? '';
        }
        else if (typeof value === 'boolean') {
            isChecked = value;
            text = '';
        }
        isChecked = table.stateManager.syncCheckedState(col, row, define.field, isChecked);
        const hierarchyOffset = getHierarchyOffset(col, row, table);
        const cellStyle = table._getCellStyle(col, row);
        const autoWrapText = cellStyle.autoWrapText ?? table.internalProps.autoWrapText;
        const { lineClamp } = cellStyle;
        const { checked, disable } = define;
        if (isChecked === undefined || isChecked === null || typeof isChecked === 'function') {
            const globalChecked = getOrApply(checked, {
                col,
                row,
                table,
                context: null,
                value,
                dataValue
            });
            isChecked = table.stateManager.syncCheckedState(col, row, define.field, globalChecked);
        }
        const globalDisable = getOrApply(disable, {
            col,
            row,
            table,
            context: null,
            value,
            dataValue
        });
        const autoColWidth = colWidth === 'auto';
        const autoRowHeight = table.isAutoRowHeight(row);
        const attribute = {
            text: text.length === 1 ? text[0] : text,
            maxLineWidth: autoColWidth
                ? Infinity
                : cellWidth - (padding[1] + padding[3] + hierarchyOffset) - size - spaceBetweenTextAndIcon,
            textAlign: 'left',
            textBaseline: 'top',
            autoWrapText,
            lineClamp,
            wordBreak: 'break-word',
            heightLimit: autoRowHeight ? -1 : cellHeight - Math.floor(padding[0] + padding[2]),
            pickable: false,
            dx: hierarchyOffset,
            whiteSpace: text.length === 1 && !autoWrapText ? 'no-wrap' : 'normal'
        };
        const testAttribute = cellTheme.text ? Object.assign({}, cellTheme.text, attribute) : attribute;
        const checkboxAttributes = {
            x: 0,
            y: 0,
            text: testAttribute,
            icon: {
                width: Math.floor(size / 1.4),
                height: Math.floor(size / 1.4)
            },
            box: {
                width: size,
                height: size
            },
            spaceBetweenTextAndIcon,
            disabled: isDisabled ?? globalDisable ?? false
        };
        if (isChecked === 'indeterminate') {
            checkboxAttributes.checked = undefined;
            checkboxAttributes.indeterminate = true;
        }
        else {
            checkboxAttributes.checked = isChecked;
            checkboxAttributes.indeterminate = undefined;
        }
        defaultFill && (checkboxAttributes.box.fill = defaultFill);
        defaultStroke && (checkboxAttributes.box.stroke = defaultStroke);
        disableFill && (checkboxAttributes.box.disableFill = disableFill);
        checkedFill && (checkboxAttributes.box.checkedFill = checkedFill);
        checkedStroke && (checkboxAttributes.box.checkedStroke = checkedStroke);
        disableCheckedFill && (checkboxAttributes.box.disableCheckedFill = disableCheckedFill);
        disableCheckedStroke && (checkboxAttributes.box.disableCheckedStroke = disableCheckedStroke);
        checkIconImage && (checkboxAttributes.icon.checkIconImage = checkIconImage);
        indeterminateIconImage && (checkboxAttributes.icon.indeterminateIconImage = indeterminateIconImage);
        const checkbox = new CheckBox(checkboxAttributes);
        checkbox.name = 'checkbox';
        return checkbox;
    }

    function createRadioCellGroup(cellGroup, columnGroup, xOrigin, yOrigin, col, row, colWidth, width, height, padding, textAlign, textBaseline, table, cellTheme, define, range) {
        if (!cellGroup) {
            const strokeArrayWidth = getCellBorderStrokeWidth(col, row, cellTheme, table);
            cellGroup = new Group$1({
                x: xOrigin,
                y: yOrigin,
                width,
                height,
                lineWidth: cellTheme?.group?.lineWidth ?? undefined,
                fill: cellTheme?.group?.fill ?? undefined,
                stroke: cellTheme?.group?.stroke ?? undefined,
                strokeArrayWidth: strokeArrayWidth,
                strokeArrayColor: cellTheme?.group?.strokeArrayColor ?? undefined,
                cursor: cellTheme?.group?.cursor ?? undefined,
                lineDash: cellTheme?.group?.lineDash ?? undefined,
                lineCap: 'butt',
                clip: true,
                cornerRadius: cellTheme.group.cornerRadius
            });
            cellGroup.role = 'cell';
            cellGroup.col = col;
            cellGroup.row = row;
            columnGroup?.addCellGroup(cellGroup);
        }
        const { width: radioWidth, height: radioHeight } = createRadio(col, row, colWidth, width, height, padding, cellTheme, define, cellGroup, range, table);
        width -= padding[1] + padding[3];
        height -= padding[0] + padding[2];
        cellGroup.forEachChildren((radioComponent) => {
            if (textAlign === 'center') {
                radioComponent.setAttribute('x', padding[3] + radioComponent.attribute.x + (width - radioWidth) / 2);
            }
            else if (textAlign === 'right') {
                radioComponent.setAttribute('x', padding[3] + radioComponent.attribute.x + width - radioWidth);
            }
            else {
                radioComponent.setAttribute('x', padding[3] + radioComponent.attribute.x);
            }
            if (textBaseline === 'middle') {
                radioComponent.setAttribute('y', padding[0] + radioComponent.attribute.y + (height - radioHeight) / 2);
            }
            else if (textBaseline === 'bottom') {
                radioComponent.setAttribute('y', padding[0] + radioComponent.attribute.y + height - radioHeight);
            }
            else {
                radioComponent.setAttribute('y', padding[0] + radioComponent.attribute.y);
            }
        });
        return cellGroup;
    }
    function createRadio(col, row, colWidth, cellWidth, cellHeight, padding, cellTheme, define, cellGroup, range, table) {
        const style = table._getCellStyle(col, row);
        let size = getProp('size', style, col, row, table);
        let innerRadius = getProp('innerRadius', style, col, row, table);
        let outerRadius = getProp('outerRadius', style, col, row, table);
        const spaceBetweenTextAndIcon = getProp('spaceBetweenTextAndIcon', style, col, row, table);
        const spaceBetweenRadio = getProp('spaceBetweenRadio', style, col, row, table);
        const defaultFill = getProp('defaultFill', style, col, row, table);
        const defaultStroke = getProp('defaultStroke', style, col, row, table);
        const disableFill = getProp('disableFill', style, col, row, table);
        const checkedFill = getProp('checkedFill', style, col, row, table);
        const checkedStroke = getProp('checkedStroke', style, col, row, table);
        const disableCheckedFill = getProp('disableCheckedFill', style, col, row, table);
        const disableCheckedStroke = getProp('disableCheckedStroke', style, col, row, table);
        if (isNumber$4(outerRadius)) {
            size = outerRadius * 2;
        }
        else {
            outerRadius = Math.round(size / 2);
        }
        if (!isNumber$4(innerRadius) || innerRadius < 0) {
            innerRadius = Math.round((outerRadius / 7) * 3);
        }
        const value = table.getCellValue(col, row);
        const dataValue = table.getCellOriginValue(col, row);
        const hierarchyOffset = getHierarchyOffset(col, row, table);
        const cellStyle = table._getCellStyle(col, row);
        const autoWrapText = cellStyle.autoWrapText ?? table.internalProps.autoWrapText;
        const { lineClamp } = cellStyle;
        const autoColWidth = colWidth === 'auto';
        const autoRowHeight = table.isAutoRowHeight(row);
        const attribute = {
            maxLineWidth: autoColWidth
                ? Infinity
                : cellWidth - (padding[1] + padding[3] + hierarchyOffset) - size - spaceBetweenTextAndIcon,
            textAlign: 'left',
            textBaseline: 'top',
            autoWrapText,
            lineClamp,
            wordBreak: 'break-word',
            heightLimit: autoRowHeight ? -1 : cellHeight - Math.floor(padding[0] + padding[2]),
            pickable: false,
            dx: hierarchyOffset
        };
        const testAttribute = cellTheme.text ? Object.assign({}, cellTheme.text, attribute) : attribute;
        const radioAttributes = {
            x: 0,
            y: 0,
            text: testAttribute,
            circle: {
                innerRadius,
                outerRadius
            },
            spaceBetweenTextAndIcon
        };
        defaultFill && (radioAttributes.circle.fill = defaultFill);
        defaultStroke && (radioAttributes.circle.stroke = defaultStroke);
        disableFill && (radioAttributes.circle.disableFill = disableFill);
        checkedFill && (radioAttributes.circle.checkedFill = checkedFill);
        checkedStroke && (radioAttributes.circle.checkedStroke = checkedStroke);
        disableCheckedFill && (radioAttributes.circle.disableCheckedFill = disableCheckedFill);
        disableCheckedStroke && (radioAttributes.circle.disableCheckedStroke = disableCheckedStroke);
        let width = 0;
        let height = 0;
        const direction = define.radioDirectionInCell ?? 'vertical';
        if (isArray$7(value)) {
            value.forEach((item, index) => {
                const radioComponent = createSingleRadio(item, dataValue, index, col, row, define, autoWrapText, radioAttributes, table);
                if (radioComponent) {
                    cellGroup.appendChild(radioComponent);
                }
                radioComponent.id = `radio-${range?.start.col ?? col}-${range?.start.row ?? row}-${index}`;
                radioComponent.render();
                const bounds = radioComponent.AABBBounds;
                if (direction === 'vertical') {
                    radioComponent.setAttribute('y', height);
                    height += bounds.height() + (index !== value.length - 1 ? spaceBetweenRadio : 0);
                    width = Math.max(width, bounds.width());
                }
                else if (direction === 'horizontal') {
                    radioComponent.setAttribute('x', width);
                    width += bounds.width() + (index !== value.length - 1 ? spaceBetweenRadio : 0);
                    height = Math.max(height, bounds.height());
                }
            });
        }
        else {
            const radioComponent = createSingleRadio(value, dataValue, undefined, col, row, define, autoWrapText, radioAttributes, table);
            if (radioComponent) {
                cellGroup.appendChild(radioComponent);
            }
            radioComponent.id = `radio-${range?.start.col ?? col}-${range?.start.row ?? row}`;
            radioComponent.render();
            const bounds = radioComponent.AABBBounds;
            width = bounds.width();
            height = bounds.height();
        }
        return { width, height };
    }
    function createSingleRadio(value, dataValue, indexInCell, col, row, define, autoWrapText, cellRadioAttributes, table) {
        const isChecked = getChecked(value, dataValue, indexInCell, col, row, define, table);
        const isDisabled = getDisable(value, dataValue, col, row, define, table);
        const text = isObject$7(value) ? value.text : isBoolean$4(value) ? '' : value ?? '';
        const radioAttributes = merge$1({}, cellRadioAttributes, {
            checked: isChecked,
            disabled: isDisabled,
            text: {
                text: text.length === 1 ? text[0] : text,
                whiteSpace: text.length === 1 && !autoWrapText ? 'no-wrap' : 'normal'
            },
            boundsPadding: 0
        });
        const radio = new Radio(radioAttributes);
        radio.name = 'radio';
        return radio;
    }
    function getChecked(value, dataValue, indexInCell, col, row, define, table) {
        const radioType = define.radioCheckType ?? 'column';
        let isChecked;
        let globalChecked;
        if (isObject$7(value)) {
            isChecked = value.checked;
        }
        else if (typeof value === 'boolean') {
            isChecked = value;
        }
        isChecked = table.stateManager.syncRadioState(col, row, define.field, radioType, indexInCell, isChecked);
        if (isChecked === undefined || isChecked === null || typeof isChecked === 'function') {
            globalChecked = getOrApply(define.checked, {
                col,
                row,
                table,
                context: null,
                value,
                dataValue
            });
            isChecked = table.stateManager.syncRadioState(col, row, define.field, radioType, indexInCell, globalChecked);
        }
        return isChecked ?? globalChecked ?? false;
    }
    function getDisable(value, dataValue, col, row, define, table) {
        let isDisabled;
        if (isObject$7(value)) {
            isDisabled = value.disable;
        }
        const globalDisable = getOrApply(define.disable, {
            col,
            row,
            table,
            context: null,
            value,
            dataValue
        });
        return isDisabled ?? globalDisable ?? false;
    }

    function createSwitchCellGroup(cellGroup, columnGroup, xOrigin, yOrigin, col, row, colWidth, width, height, padding, textAlign, textBaseline, mayHaveIcon, table, cellTheme, define, range, isAsync) {
        if (!cellGroup) {
            const strokeArrayWidth = getCellBorderStrokeWidth(col, row, cellTheme, table);
            if (isAsync) {
                cellGroup = table.scenegraph.highPerformanceGetCell(col, row, true);
                if (cellGroup && cellGroup.role === 'cell') {
                    cellGroup.setAttributes({
                        x: xOrigin,
                        y: yOrigin,
                        width,
                        height,
                        lineWidth: cellTheme?.group?.lineWidth ?? undefined,
                        fill: cellTheme?.group?.fill ?? undefined,
                        stroke: cellTheme?.group?.stroke ?? undefined,
                        strokeArrayWidth: strokeArrayWidth,
                        strokeArrayColor: cellTheme?.group?.strokeArrayColor ?? undefined,
                        cursor: cellTheme?.group?.cursor ?? undefined,
                        lineDash: cellTheme?.group?.lineDash ?? undefined,
                        lineCap: 'butt',
                        clip: true,
                        cornerRadius: cellTheme.group.cornerRadius
                    });
                }
            }
            if (!cellGroup || cellGroup.role !== 'cell') {
                cellGroup = new Group$1({
                    x: xOrigin,
                    y: yOrigin,
                    width,
                    height,
                    lineWidth: cellTheme?.group?.lineWidth ?? undefined,
                    fill: cellTheme?.group?.fill ?? undefined,
                    stroke: cellTheme?.group?.stroke ?? undefined,
                    strokeArrayWidth: strokeArrayWidth,
                    strokeArrayColor: cellTheme?.group?.strokeArrayColor ?? undefined,
                    cursor: cellTheme?.group?.cursor ?? undefined,
                    lineDash: cellTheme?.group?.lineDash ?? undefined,
                    lineCap: 'butt',
                    clip: true,
                    cornerRadius: cellTheme.group.cornerRadius
                });
                cellGroup.role = 'cell';
                cellGroup.col = col;
                cellGroup.row = row;
                columnGroup?.addCellGroup(cellGroup);
            }
        }
        let icons;
        if (mayHaveIcon) {
            let iconCol = col;
            let iconRow = row;
            if (range) {
                iconCol = range.start.col;
                iconRow = range.start.row;
            }
            icons = table.getCellIcons(iconCol, iconRow);
        }
        let iconWidth = 0;
        let cellLeftIconWidth = 0;
        if (Array.isArray(icons) && icons.length !== 0) {
            const { leftIconWidth, rightIconWidth, absoluteLeftIconWidth, absoluteRightIconWidth } = dealWithIconLayout(icons, cellGroup, range, table);
            iconWidth = leftIconWidth + rightIconWidth;
            cellLeftIconWidth = leftIconWidth;
            cellGroup.forEachChildren((child) => {
                if (child.role === 'icon-left') {
                    child.setAttribute('x', child.attribute.x + padding[3]);
                }
                else if (child.role === 'icon-right') {
                    child.setAttribute('x', child.attribute.x + width - rightIconWidth - padding[1]);
                }
                else if (child.role === 'icon-absolute-right') {
                    child.setAttribute('x', child.attribute.x + width - absoluteRightIconWidth - padding[1]);
                }
            });
            cellGroup.forEachChildren((child) => {
                if (textBaseline === 'middle') {
                    child.setAttribute('y', (height - child.AABBBounds.height()) / 2);
                }
                else if (textBaseline === 'bottom') {
                    child.setAttribute('y', height - child.AABBBounds.height() - padding[2]);
                }
                else {
                    child.setAttribute('y', padding[0]);
                }
            });
        }
        const switchComponent = createSwitch(col, row, colWidth - iconWidth, width, height, padding, cellTheme, define, table);
        if (switchComponent) {
            cellGroup.appendChild(switchComponent);
        }
        switchComponent.render();
        width -= padding[1] + padding[3] + iconWidth;
        height -= padding[0] + padding[2];
        if (textAlign === 'center') {
            switchComponent.setAttribute('x', padding[3] + cellLeftIconWidth + (width - switchComponent.AABBBounds.width()) / 2);
        }
        else if (textAlign === 'right') {
            switchComponent.setAttribute('x', padding[3] + cellLeftIconWidth + width - switchComponent.AABBBounds.width());
        }
        else {
            switchComponent.setAttribute('x', padding[3] + cellLeftIconWidth);
        }
        if (textBaseline === 'middle') {
            switchComponent.setAttribute('y', padding[0] + (height - switchComponent.AABBBounds.height()) / 2);
        }
        else if (textBaseline === 'bottom') {
            switchComponent.setAttribute('y', padding[0] + height - switchComponent.AABBBounds.height());
        }
        else {
            switchComponent.setAttribute('y', padding[0]);
        }
        return cellGroup;
    }
    function createSwitch(col, row, colWidth, cellWidth, cellHeight, padding, cellTheme, define, table) {
        const style = table._getCellStyle(col, row);
        const spaceBetweenTextAndCircle = getProp('spaceBetweenTextAndCircle', style, col, row, table);
        const circleRadius = getProp('circleRadius', style, col, row, table);
        const boxWidth = getProp('boxWidth', style, col, row, table);
        const boxHeight = getProp('boxHeight', style, col, row, table);
        const checkedFill = getProp('checkedFill', style, col, row, table);
        const uncheckedFill = getProp('uncheckedFill', style, col, row, table);
        const disableCheckedFill = getProp('disableCheckedFill', style, col, row, table);
        const disableUncheckedFill = getProp('disableUncheckedFill', style, col, row, table);
        const circleFill = getProp('circleFill', style, col, row, table);
        const value = table.getCellValue(col, row);
        const dataValue = table.getCellOriginValue(col, row);
        let isChecked;
        let isDisabled;
        let text = value ?? '';
        if (isObject$7(value)) {
            isChecked = value.checked;
            isDisabled = value.disable;
            text = value.text ?? '';
        }
        else if (typeof value === 'boolean') {
            isChecked = value;
            text = '';
        }
        isChecked = table.stateManager.syncCheckedState(col, row, define.field, isChecked);
        const hierarchyOffset = getHierarchyOffset(col, row, table);
        const cellStyle = table._getCellStyle(col, row);
        const autoWrapText = cellStyle.autoWrapText ?? table.internalProps.autoWrapText;
        const { lineClamp } = cellStyle;
        const { checked, disable, uncheckedText, checkedText } = define;
        if (isChecked === undefined || isChecked === null || typeof isChecked === 'function') {
            const globalChecked = getOrApply(checked, {
                col,
                row,
                table,
                context: null,
                value,
                dataValue
            });
            isChecked = table.stateManager.syncCheckedState(col, row, define.field, globalChecked);
        }
        const globalDisable = getOrApply(disable, {
            col,
            row,
            table,
            context: null,
            value,
            dataValue
        });
        const checkedTextString = getOrApply(checkedText, {
            col,
            row,
            table,
            context: null,
            value,
            dataValue
        });
        const uncheckedTextString = getOrApply(uncheckedText, {
            col,
            row,
            table,
            context: null,
            value,
            dataValue
        });
        const autoColWidth = colWidth === 'auto';
        const autoRowHeight = table.isAutoRowHeight(row);
        const attribute = {
            text: text.length === 1 ? text[0] : text,
            maxLineWidth: autoColWidth
                ? Infinity
                : cellWidth - (padding[1] + padding[3] + hierarchyOffset) - circleRadius * 2 - spaceBetweenTextAndCircle,
            textAlign: 'left',
            textBaseline: 'top',
            autoWrapText,
            lineClamp,
            wordBreak: 'break-word',
            heightLimit: autoRowHeight ? -1 : cellHeight - Math.floor(padding[0] + padding[2]),
            pickable: false,
            dx: hierarchyOffset,
            whiteSpace: text.length === 1 && !autoWrapText ? 'no-wrap' : 'normal',
            checkedText: checkedTextString,
            uncheckedText: uncheckedTextString
        };
        const testAttribute = cellTheme.text ? Object.assign({}, cellTheme.text, attribute) : attribute;
        const switchAttributes = {
            x: 0,
            y: 0,
            text: testAttribute,
            circle: {
                radius: circleRadius
            },
            box: {
                width: boxWidth,
                height: boxHeight
            },
            spaceBetweenTextAndCircle,
            disabled: isDisabled ?? globalDisable ?? false
        };
        switchAttributes.checked = isChecked;
        uncheckedFill && (switchAttributes.box.uncheckedFill = uncheckedFill);
        disableUncheckedFill && (switchAttributes.box.disableUncheckedFill = disableUncheckedFill);
        checkedFill && (switchAttributes.box.checkedFill = checkedFill);
        disableCheckedFill && (switchAttributes.box.disableCheckedFill = disableCheckedFill);
        circleFill && (switchAttributes.circle.fill = circleFill);
        const switchComponent = new Switch(switchAttributes);
        switchComponent.name = 'switch';
        return switchComponent;
    }

    const xScale = new PointScale();
    const yScale = new LinearScale();
    function createSparkLineCellGroup(cellGroup, columnGroup, xOrigin, yOrigin, col, row, width, height, padding, table, cellTheme, isAsync) {
        if (!cellGroup) {
            const strokeArrayWidth = getCellBorderStrokeWidth(col, row, cellTheme, table);
            if (isAsync) {
                cellGroup = table.scenegraph.highPerformanceGetCell(col, row, true);
                if (cellGroup && cellGroup.role === 'cell') {
                    cellGroup.setAttributes({
                        x: xOrigin,
                        y: yOrigin,
                        width,
                        height,
                        lineWidth: cellTheme?.group?.lineWidth ?? undefined,
                        fill: cellTheme?.group?.fill ?? undefined,
                        stroke: cellTheme?.group?.stroke ?? undefined,
                        strokeArrayWidth: strokeArrayWidth,
                        strokeArrayColor: cellTheme?.group?.strokeArrayColor ?? undefined,
                        cursor: cellTheme?.group?.cursor ?? undefined,
                        lineDash: cellTheme?.group?.lineDash ?? undefined,
                        lineCap: 'butt',
                        clip: true,
                        cornerRadius: cellTheme.group.cornerRadius
                    });
                }
            }
            if (!cellGroup || cellGroup.role !== 'cell') {
                cellGroup = new Group$1({
                    x: xOrigin,
                    y: yOrigin,
                    width,
                    height,
                    lineWidth: cellTheme?.group?.lineWidth ?? undefined,
                    fill: cellTheme?.group?.fill ?? undefined,
                    stroke: cellTheme?.group?.stroke ?? undefined,
                    strokeArrayWidth: strokeArrayWidth,
                    strokeArrayColor: cellTheme?.group?.strokeArrayColor ?? undefined,
                    cursor: cellTheme?.group?.cursor ?? undefined,
                    lineDash: cellTheme?.group?.lineDash ?? undefined,
                    lineCap: 'butt',
                    clip: true,
                    cornerRadius: cellTheme.group.cornerRadius
                });
                cellGroup.role = 'cell';
                cellGroup.col = col;
                cellGroup.row = row;
                columnGroup?.addCellGroup(cellGroup);
            }
        }
        const chartGroup = createSparkLine(col, row, width, height, padding, table);
        if (chartGroup) {
            cellGroup.appendChild(chartGroup);
        }
        return cellGroup;
    }
    function createSparkLine(col, row, width, height, padding, table) {
        let sparklineSpec;
        let chartGroup;
        const chartSpecRaw = table.internalProps.layoutMap.getBody(col, row).sparklineSpec;
        const dataValue = table.getCellValue(col, row);
        if (!Array.isArray(dataValue)) {
            return undefined;
        }
        const x = padding[3];
        const y = padding[0];
        width -= padding[1] + padding[3];
        height -= padding[0] + padding[2];
        const left = 0;
        const bottom = height;
        if (typeof chartSpecRaw === 'function') {
            const arg = {
                col,
                row,
                dataValue: table.getCellOriginValue(col, row) || '',
                value: table.getCellValue(col, row) || '',
                rect: table.getCellRangeRelativeRect(table.getCellRange(col, row)),
                table
            };
            sparklineSpec = chartSpecRaw(arg);
            chartGroup = createChartGroup(sparklineSpec, x, y, width, height);
        }
        else {
            sparklineSpec = chartSpecRaw;
            chartGroup = createChartGroup(chartSpecRaw, x, y, width, height);
        }
        const items = [];
        const dataItems = [];
        let xField;
        let yField;
        if (typeof sparklineSpec.xField === 'object') {
            xScale.domain(sparklineSpec.xField.domain);
            xField = sparklineSpec.xField.field;
        }
        else if (typeof sparklineSpec.xField === 'string') {
            const indexValues = dataValue.map((value) => value[sparklineSpec.xField]);
            xScale.domain(indexValues);
            xField = sparklineSpec.xField;
        }
        else {
            if (Array.isArray(dataValue)) {
                xScale.domain(Array.from({ length: dataValue.length }, (_, i) => i));
                xField = sparklineSpec.xField;
            }
        }
        xScale.range([0, width]);
        if (typeof sparklineSpec.yField === 'object') {
            yScale.domain(sparklineSpec.yField.domain);
            yField = sparklineSpec.yField.field;
        }
        else if (typeof sparklineSpec.yField === 'string') {
            const values = getYNumbers(dataValue, sparklineSpec.yField);
            yScale.domain([Math.min(...values), Math.max(...values)]);
            yField = sparklineSpec.yField;
        }
        else {
            if (Array.isArray(dataValue)) {
                const values = getYNumbers(dataValue);
                yScale.domain([Math.min(...values), Math.max(...values)]);
                yField = sparklineSpec.yField;
            }
        }
        yScale.range([0, height]);
        if (typeof sparklineSpec.xField === 'object' && Array.isArray(sparklineSpec.xField.domain)) {
            const values = dataValue.map((value) => value[sparklineSpec.xField.field]);
            const domain = sparklineSpec.xField.domain;
            for (let i = 0; i < domain.length; i++) {
                let valid = false;
                for (let j = 0; j < values.length; j++) {
                    if (domain[i] === values[j]) {
                        const data = dataValue[j];
                        if (!isValid$3(data[xField]) || !isValid$3(data[yField])) {
                            break;
                        }
                        items.push({
                            x: left + xScale.scale(data[xField]),
                            y: bottom - yScale.scale(data[yField]),
                            defined: isValid$3(data[yField])
                        });
                        dataItems.push(data);
                        valid = true;
                        break;
                    }
                }
                if (!valid) {
                    items.push({
                        x: left + xScale.scale(domain[i]),
                        y: 0,
                        defined: false
                    });
                    dataItems.push({ [xField]: domain[i], [yField]: null });
                }
            }
        }
        else {
            for (let i = 0; i < dataValue.length; i++) {
                const data = dataValue[i];
                items.push({
                    x: left + xScale.scale(xField ? data[xField] : i),
                    y: bottom - yScale.scale(yField ? data[yField] : data),
                    defined: isValid$3(yField ? data[yField] : data),
                    rawData: data
                });
                dataItems.push(data);
            }
        }
        const line = chartGroup.getChildByName('sparkline-line');
        if (line) {
            line.setAttribute('points', items);
        }
        line.bandwidth = xScale.step();
        line.min = yScale.range()[0];
        line.max = yScale.range()[1];
        const symbolGroup = chartGroup.getChildByName('sparkline-symbol-group');
        if (symbolGroup) {
            const isShowIsolatedPoint = sparklineSpec.pointShowRule === 'isolatedPoint';
            if (sparklineSpec.pointShowRule === 'all') {
                for (let i = 0; i < items.length; i++) {
                    const { x, y, defined } = items[i];
                    if (defined) {
                        const symbol = createSymbol({ x, y });
                        symbolGroup.appendChild(symbol);
                    }
                }
            }
            else if (isShowIsolatedPoint) {
                for (let i = 0; i < items.length; i++) {
                    const { x, y, defined } = items[i];
                    if (defined && (!items[i - 1] || !items[i - 1].defined) && (!items[i + 1] || !items[i + 1].defined)) {
                        const symbol = createSymbol({ x, y });
                        symbolGroup.appendChild(symbol);
                    }
                }
            }
        }
        return chartGroup;
    }
    function createChartGroup(spec, x, y, width, height) {
        let specObj;
        if (typeof spec === 'function') {
            specObj = spec(null);
        }
        else {
            specObj = spec;
        }
        const group = new Group$1({
            x,
            y,
            width,
            height,
            stroke: false,
            fill: false
        });
        group.name = 'sparkline';
        if (specObj.type === 'line') {
            const line = createLine({
                x: 0,
                y: 0,
                curveType: specObj.smooth ? 'monotoneX' : 'linear',
                stroke: specObj.line?.style?.stroke ?? 'blue',
                lineWidth: specObj.line?.style?.strokeWidth ?? 2
            });
            line.name = 'sparkline-line';
            group.addChild(line);
            if (specObj.crosshair) {
                line.hover = specObj.crosshair?.style ?? {
                    stroke: '#000',
                    interpolate: 'linear'
                };
            }
            const symbolGroup = new Group$1({
                x: 0,
                y: 0,
                width,
                height,
                stroke: false,
                fill: false
            });
            symbolGroup.name = 'sparkline-symbol-group';
            symbolGroup.setTheme({
                symbol: {
                    stroke: specObj.point?.style?.stroke ?? '#000',
                    lineWidth: specObj.point?.style?.strokeWidth ?? 1,
                    fill: specObj.point?.style?.fill ?? '#000',
                    size: (specObj.point?.style?.size ?? 3) * 2,
                    symbolType: 'circle'
                }
            });
            group.addChild(symbolGroup);
            symbolGroup.hover = specObj.point?.hover ?? false;
        }
        return group;
    }
    function getYNumbers(data, field) {
        const numbers = [];
        for (let i = 0; i < data.length; i++) {
            const item = data[i];
            if (isValid$3(field) && isValid$3(item[field])) {
                numbers.push(item[field]);
            }
            else if (!isValid$3(field) && isValid$3(item)) {
                numbers.push(item);
            }
        }
        return numbers;
    }

    const regedIcons = get$2();
    function createVideoCellGroup(columnGroup, xOrigin, yOrigin, col, row, width, height, keepAspectRatio, imageAutoSizing, padding, textAlign, textBaseline, mayHaveIcon, table, cellTheme, range, isAsync) {
        const headerStyle = table._getCellStyle(col, row);
        const functionalPadding = getFunctionalProp('padding', headerStyle, col, row, table);
        if (table.options.customConfig?.imageMargin) {
            padding = getQuadProps(table.options.customConfig?.imageMargin);
        }
        else if (isValid$3(functionalPadding)) {
            padding = functionalPadding;
        }
        if (cellTheme?.text?.textAlign) {
            textAlign = cellTheme?.text?.textAlign;
        }
        if (cellTheme?.text?.textBaseline) {
            textBaseline = cellTheme?.text?.textBaseline;
        }
        const strokeArrayWidth = getCellBorderStrokeWidth(col, row, cellTheme, table);
        let cellGroup;
        if (isAsync) {
            cellGroup = table.scenegraph.highPerformanceGetCell(col, row, true);
            if (cellGroup && cellGroup.role === 'cell') {
                cellGroup.setAttributes({
                    x: xOrigin,
                    y: yOrigin,
                    width,
                    height,
                    lineWidth: cellTheme?.group?.lineWidth ?? undefined,
                    fill: cellTheme?.group?.fill ?? undefined,
                    stroke: cellTheme?.group?.stroke ?? undefined,
                    strokeArrayWidth: strokeArrayWidth,
                    strokeArrayColor: cellTheme?.group?.strokeArrayColor ?? undefined,
                    cursor: cellTheme?.group?.cursor ?? undefined,
                    lineDash: cellTheme?.group?.lineDash ?? undefined,
                    lineCap: 'butt',
                    clip: true,
                    cornerRadius: cellTheme.group.cornerRadius
                });
            }
        }
        if (!cellGroup || cellGroup.role !== 'cell') {
            cellGroup = new Group$1({
                x: xOrigin,
                y: yOrigin,
                width,
                height,
                lineWidth: cellTheme?.group?.lineWidth ?? undefined,
                fill: cellTheme?.group?.fill ?? undefined,
                stroke: cellTheme?.group?.stroke ?? undefined,
                strokeArrayWidth: strokeArrayWidth,
                strokeArrayColor: cellTheme?.group?.strokeArrayColor ?? undefined,
                cursor: cellTheme?.group?.cursor ?? undefined,
                lineDash: cellTheme?.group?.lineDash ?? undefined,
                lineCap: 'butt',
                clip: true,
                cornerRadius: cellTheme.group.cornerRadius
            });
            cellGroup.role = 'cell';
            cellGroup.col = col;
            cellGroup.row = row;
            columnGroup?.addCellGroup(cellGroup);
        }
        let cellIcons;
        if (mayHaveIcon) {
            let iconCol = col;
            let iconRow = row;
            if (range) {
                iconCol = range.start.col;
                iconRow = range.start.row;
            }
            cellIcons = table.getCellIcons(iconCol, iconRow);
        }
        let cellLeftIconWidth = 0;
        let cellRightIconWidth = 0;
        if (Array.isArray(cellIcons) && cellIcons.length !== 0) {
            const { leftIconWidth, rightIconWidth, absoluteLeftIconWidth, absoluteRightIconWidth } = dealWithIconLayout(cellIcons, cellGroup, range, table);
            cellLeftIconWidth = leftIconWidth;
            cellRightIconWidth = rightIconWidth;
            cellGroup.forEachChildren((child) => {
                if (child.role === 'icon-left') {
                    child.setAttribute('x', child.attribute.x + padding[3]);
                }
                else if (child.role === 'icon-right') {
                    child.setAttribute('x', child.attribute.x + width - rightIconWidth - padding[1]);
                }
                else if (child.role === 'icon-absolute-right') {
                    child.setAttribute('x', child.attribute.x + width - absoluteRightIconWidth - padding[1]);
                }
            });
            cellGroup.forEachChildren((child) => {
                if (textBaseline === 'middle') {
                    child.setAttribute('y', (height - child.AABBBounds.height()) / 2);
                }
                else if (textBaseline === 'bottom') {
                    child.setAttribute('y', height - child.AABBBounds.height() - padding[2]);
                }
                else {
                    child.setAttribute('y', padding[0]);
                }
            });
            cellGroup._cellLeftIconWidth = cellLeftIconWidth;
            cellGroup._cellRightIconWidth = cellRightIconWidth;
        }
        const value = table.getCellValue(col, row);
        const video = document.createElement('video');
        video.addEventListener('loadeddata', () => {
            if (imageAutoSizing) {
                _adjustWidthHeight(col, row, video.videoWidth, video.videoHeight, table.scenegraph, padding, cellGroup);
            }
            const { width: cellWidth, height: cellHeight, isMerge } = getCellRange$1(cellGroup, table);
            if (keepAspectRatio) {
                const { width: videoWidth, height: videoHeight } = calcKeepAspectRatioSize(video.videoWidth, video.videoHeight, cellWidth - padding[1] - padding[3], cellHeight - padding[0] - padding[2]);
                const pos = calcStartPosition(0, 0, cellWidth, cellHeight, videoWidth, videoHeight, textAlign, textBaseline, padding);
                image.setAttributes({
                    width: videoWidth,
                    height: videoHeight,
                    x: pos.x,
                    y: pos.y,
                    dx: 0
                });
            }
            else {
                image.setAttributes({
                    x: padding[3],
                    y: padding[0],
                    width: cellWidth - padding[1] - padding[3],
                    height: cellHeight - padding[2] - padding[0],
                    dy: 0
                });
            }
            if (isMerge) {
                updateImageDxDy(cellGroup.mergeStartCol, cellGroup.mergeEndCol, cellGroup.mergeStartRow, cellGroup.mergeEndRow, table);
            }
            const left = 0;
            const top = 0;
            const { width, height } = getCellRange$1(cellGroup, table);
            const iconSize = Math.floor(Math.min(width - padding[1] - padding[3], height - padding[2] - padding[0]) / 2);
            const anchorX = left + (width > image.attribute.width ? image.attribute.x - left + image.attribute.width / 2 : width / 2);
            const anchorY = top + (height > image.attribute.height ? image.attribute.y - top + image.attribute.height / 2 : height / 2);
            const imageGraphic = cellGroup.getChildByName('image', true);
            const { dx, dy } = imageGraphic.attribute;
            const playIcon = new Icon$1({
                x: anchorX - iconSize / 2,
                y: anchorY - iconSize / 2,
                width: iconSize,
                height: iconSize,
                image: regedIcons.play.svg,
                cursor: regedIcons.play.cursor,
                dx,
                dy
            });
            playIcon.name = 'play-icon';
            cellGroup.appendChild(playIcon);
            table.scenegraph.updateNextFrame();
        });
        video.onerror = () => {
            image.image = regedIcons.damage_pic.svg;
        };
        video.src = value;
        video.setAttribute('preload', 'auto');
        const image = createImage({
            x: padding[3],
            y: padding[0],
            width: width - padding[1] - padding[3],
            height: height - padding[2] - padding[0],
            image: video,
            cursor: 'pointer'
        });
        image.name = 'image';
        image.keepAspectRatio = keepAspectRatio;
        image.textAlign = textAlign;
        image.textBaseline = textBaseline;
        cellGroup.appendChild(image);
        return cellGroup;
    }

    function createMark(marked, cellGroup, table) {
        if (typeof marked === 'boolean') {
            const mark = createArc({
                x: cellGroup.attribute.width,
                y: 0,
                startAngle: Math.PI / 2,
                endAngle: Math.PI,
                outerRadius: 6,
                fill: '#3073F2',
                pickable: false
            });
            mark.name = 'mark';
            cellGroup.appendChild(mark);
        }
        else {
            const { bgColor = '#3073F2', shape = 'sector', position = 'right-top', size = 10, offset = 0 } = marked;
            let x;
            let y;
            let startAngle;
            let endAngle;
            let fill;
            let mark;
            if (shape === 'sector') {
                if (position === 'right-top') {
                    x = cellGroup.attribute.width - offset;
                    y = offset;
                    startAngle = Math.PI / 2;
                    endAngle = Math.PI;
                }
                else if (position === 'left-top') {
                    x = offset;
                    y = offset;
                    startAngle = 0;
                    endAngle = Math.PI / 2;
                }
                else if (position === 'right-bottom') {
                    x = cellGroup.attribute.width - offset;
                    y = cellGroup.attribute.height - offset;
                    startAngle = Math.PI;
                    endAngle = (Math.PI / 2) * 3;
                }
                else if (position === 'left-bottom') {
                    x = offset;
                    y = cellGroup.attribute.height - offset;
                    startAngle = (Math.PI / 2) * 3;
                    endAngle = Math.PI * 2;
                }
                fill = bgColor;
                mark = createArc({
                    x,
                    y,
                    startAngle,
                    endAngle,
                    outerRadius: size,
                    fill: fill,
                    pickable: false
                });
            }
            else if (shape === 'triangle') {
                let x2;
                let y2;
                let x3;
                let y3;
                if (position === 'right-top') {
                    x = cellGroup.attribute.width - offset;
                    y = offset;
                    x2 = x - size;
                    y2 = y;
                    x3 = x;
                    y3 = y + size;
                }
                else if (position === 'left-top') {
                    x = offset;
                    y = offset;
                    x2 = x + size;
                    y2 = y;
                    x3 = x;
                    y3 = y + size;
                }
                else if (position === 'right-bottom') {
                    x = cellGroup.attribute.width - offset;
                    y = cellGroup.attribute.height - offset;
                    x2 = x - size;
                    y2 = y;
                    x3 = x;
                    y3 = y - size;
                }
                else if (position === 'left-bottom') {
                    x = offset;
                    y = cellGroup.attribute.height - offset;
                    x2 = x + size;
                    y2 = y;
                    x3 = x;
                    y3 = y - size;
                }
                fill = bgColor;
                mark = createPolygon({
                    points: [
                        { x: x, y: y },
                        { x: x2, y: y2 },
                        { x: x3, y: y3 }
                    ],
                    fill: fill,
                    pickable: false
                });
            }
            else if (shape === 'rect') {
                if (position === 'right-top') {
                    x = cellGroup.attribute.width - size - offset;
                    y = offset;
                }
                else if (position === 'left-top') {
                    x = offset;
                    y = offset;
                }
                else if (position === 'right-bottom') {
                    x = cellGroup.attribute.width - size - offset;
                    y = cellGroup.attribute.height - size - offset;
                }
                else if (position === 'left-bottom') {
                    x = offset;
                    y = cellGroup.attribute.height - size - offset;
                }
                fill = bgColor;
                mark = createRect({
                    x,
                    y,
                    width: size,
                    height: size,
                    fill: fill,
                    pickable: false
                });
            }
            mark.name = 'mark';
            cellGroup.appendChild(mark);
        }
    }

    function createCellGroup(table, value, columnGroup, xOrigin, yOrigin, col, row, colWidth, cellWidth, cellHeight, padding, textAlign, textBaseline, mayHaveIcon, customElementsGroup, renderDefault, cellTheme, range, isAsync) {
        const headerStyle = table._getCellStyle(col, row);
        const functionalPadding = getFunctionalProp('padding', headerStyle, col, row, table);
        if (isValid$3(functionalPadding)) {
            padding = functionalPadding;
        }
        if (cellTheme?.text?.textAlign) {
            textAlign = cellTheme?.text?.textAlign;
        }
        if (cellTheme?.text?.textBaseline) {
            textBaseline = cellTheme?.text?.textBaseline;
        }
        const autoRowHeight = table.isAutoRowHeight(row);
        const autoColWidth = colWidth === 'auto';
        const autoWrapText = headerStyle.autoWrapText ?? table.internalProps.autoWrapText;
        const lineClamp = headerStyle.lineClamp;
        const strokeArrayWidth = getCellBorderStrokeWidth(col, row, cellTheme, table);
        let cellGroup;
        if (isAsync) {
            cellGroup = table.scenegraph.getCell(col, row, true);
            if (cellGroup && cellGroup.role === 'cell') {
                cellGroup.setAttributes({
                    x: xOrigin,
                    y: yOrigin,
                    width: cellWidth,
                    height: cellHeight,
                    lineWidth: cellTheme?.group?.lineWidth ?? undefined,
                    fill: cellTheme?.group?.fill ?? undefined,
                    stroke: cellTheme?.group?.stroke ?? undefined,
                    strokeArrayWidth: strokeArrayWidth ?? undefined,
                    strokeArrayColor: cellTheme?.group?.strokeArrayColor ?? undefined,
                    cursor: cellTheme?.group?.cursor ?? undefined,
                    lineDash: cellTheme?.group?.lineDash ?? undefined,
                    lineCap: 'butt',
                    clip: true,
                    cornerRadius: cellTheme.group.cornerRadius
                });
            }
        }
        if (!cellGroup || cellGroup.role !== 'cell') {
            cellGroup = new Group$1({
                x: xOrigin,
                y: yOrigin,
                width: cellWidth,
                height: cellHeight,
                lineWidth: cellTheme?.group?.lineWidth ?? undefined,
                fill: cellTheme?.group?.fill ?? undefined,
                stroke: cellTheme?.group?.stroke ?? undefined,
                strokeArrayWidth: strokeArrayWidth ?? undefined,
                strokeArrayColor: cellTheme?.group?.strokeArrayColor ?? undefined,
                cursor: cellTheme?.group?.cursor ?? undefined,
                lineDash: cellTheme?.group?.lineDash ?? undefined,
                lineCap: 'butt',
                clip: true,
                cornerRadius: cellTheme.group.cornerRadius
            });
            cellGroup.role = 'cell';
            cellGroup.col = col;
            cellGroup.row = row;
            columnGroup?.addCellGroup(cellGroup);
        }
        if (customElementsGroup) {
            cellGroup.appendChild(customElementsGroup);
        }
        if (renderDefault) {
            const textStr = value;
            let icons;
            if (mayHaveIcon) {
                let iconCol = col;
                let iconRow = row;
                if (range) {
                    iconCol = range.start.col;
                    iconRow = range.start.row;
                }
                icons = table.getCellIcons(iconCol, iconRow);
            }
            createCellContent(cellGroup, icons, textStr, padding, autoColWidth, autoRowHeight, autoWrapText, typeof lineClamp === 'number' ? lineClamp : undefined, cellGroup.attribute.width, cellGroup.attribute.height, textAlign, textBaseline, table, cellTheme, range);
            if (cellTheme?._vtable?.marked) {
                createMark(cellTheme?._vtable?.marked, cellGroup);
            }
        }
        if (customElementsGroup) {
            cellGroup.setAttributes({
                width: Math.max(cellGroup.attribute.width, customElementsGroup.attribute.width ?? 0),
                height: Math.max(cellGroup.attribute.height, customElementsGroup.attribute.height ?? 0)
            });
        }
        return cellGroup;
    }

    function createProgressBarCell(progressBarDefine, style, width, value, dataValue, col, row, padding, table, range) {
        if (progressBarDefine.dependField) {
            const dependField = getOrApply(progressBarDefine.dependField, {
                col,
                row,
                table,
                value,
                dataValue,
                cellHeaderPaths: undefined
            });
            dataValue = table.getCellOriginRecord(col, row)?.[dependField] ?? dataValue;
        }
        const barType = getOrApply(progressBarDefine.barType, {
            col,
            row,
            table,
            value,
            dataValue,
            cellHeaderPaths: undefined
        }) ?? 'default';
        const min = getOrApply(progressBarDefine.min, {
            col,
            row,
            table,
            value,
            dataValue,
            cellHeaderPaths: undefined
        }) ?? 0;
        const max = getOrApply(progressBarDefine.max, {
            col,
            row,
            table,
            value,
            dataValue,
            cellHeaderPaths: undefined
        }) ?? min + 100;
        let height = 0;
        if (range) {
            height = table.getRowsHeight(range.start.row, range.end.row);
        }
        else {
            height = table.getRowHeight(row);
        }
        let contentWidth = width;
        let contentHeight = height;
        let _contentOffset = 0;
        if (isNumber$4(table.theme._contentOffset)) {
            _contentOffset = table.theme._contentOffset;
        }
        const percentCompleteBarGroup = new Group$1({
            x: -_contentOffset,
            y: -_contentOffset,
            width: contentWidth,
            height: contentHeight
        });
        percentCompleteBarGroup.name = 'progress-bar';
        const { showBar, barColor, barBgColor, barPositiveColor, barNegativeColor, barAxisColor, barRightToLeft, showBarMark, barMarkPositiveColor, barMarkNegativeColor, barMarkWidth, barMarkPosition, barMarkInBar } = style;
        let { barHeight, barBottom, barPadding } = style;
        if (barPadding.length === 1) {
            barPadding = [barPadding[0], barPadding[0], barPadding[0], barPadding[0]];
        }
        else if (barPadding.length === 2) {
            barPadding = [barPadding[0], barPadding[1], barPadding[0], barPadding[1]];
        }
        else if (barPadding.length === 3) {
            barPadding = [barPadding[0], barPadding[1], barPadding[2], barPadding[1]];
        }
        barPadding = barPadding.map((v, i) => {
            if (typeof v === 'string' && str.endsWith(v, '%')) {
                const num = Number(v.substr(0, v.length - 1));
                if (i === 0 || i === 2) {
                    return (height * num) / 100;
                }
                return (width * num) / 100;
            }
            return Number(v);
        });
        const borderWidth = getQuadProps(getProp('borderLineWidth', style, col, row, table));
        const barPaddingTop = Math.max(barPadding[0], Math.ceil(borderWidth[0] / 2));
        let barPaddingRight = Math.max(barPadding[1], Math.floor(borderWidth[1] / 2));
        const barPaddingBottom = Math.max(barPadding[2], Math.floor(borderWidth[2] / 2));
        let barPaddingLeft = Math.max(barPadding[3], Math.ceil(borderWidth[3] / 2));
        if (showBarMark && barMarkWidth > 0 && barMarkPosition === 'right' && barMarkInBar === false) {
            barPaddingRight += barMarkWidth;
            barPaddingLeft += barMarkWidth;
        }
        contentWidth -= barPaddingRight + barPaddingLeft;
        contentHeight -= barPaddingBottom + barPaddingTop;
        if (row === table.rowCount - 1 && [0, '0'].includes(barBottom)) {
            contentHeight -= 1;
        }
        const top = barPaddingTop;
        const left = barPaddingLeft;
        const right = contentWidth;
        if (typeof barHeight === 'string' && str.endsWith(barHeight, '%')) {
            barHeight = Number(barHeight.substr(0, barHeight.length - 1));
            barHeight = (contentHeight * barHeight) / 100;
        }
        else {
            barHeight = Number(barHeight);
        }
        if (typeof barBottom === 'string' && str.endsWith(barBottom, '%')) {
            barBottom = Number(barBottom.substr(0, barBottom.length - 1));
            barBottom = (contentHeight * barBottom) / 100;
        }
        else {
            barBottom = Number(barBottom);
        }
        const show = getOrApply(showBar, {
            col,
            row,
            table,
            context: null,
            value,
            dataValue
        });
        if (show) {
            let svalue = `${dataValue}`;
            if (str.endsWith(svalue, '%')) {
                svalue = svalue.substr(0, svalue.length - 1);
            }
            const num = Number(svalue);
            if (isNaN(num)) {
                return percentCompleteBarGroup;
            }
            if ((barType ?? 'default') === 'default') {
                const percentile = num < min ? 0 : num > max ? 1 : (num - min) / (max - min);
                const barMaxWidth = contentWidth;
                const barTop = top + contentHeight - barHeight - barBottom;
                let barSize = Math.min(barMaxWidth * percentile, barMaxWidth);
                const barLeft = barRightToLeft ? left + right - barSize : left;
                if (col === table.colCount - 1 && percentile === 1 && !barRightToLeft) {
                    barSize -= 1;
                }
                const bgFillColor = getOrApply(barBgColor, {
                    col,
                    row,
                    table,
                    context: null,
                    value,
                    dataValue,
                    percentile
                });
                if (bgFillColor) {
                    const barBack = createRect({
                        x: barLeft,
                        y: barTop,
                        width: barMaxWidth,
                        height: barHeight,
                        fill: bgFillColor
                    });
                    percentCompleteBarGroup.addChild(barBack);
                }
                const fillColor = getOrApply(barColor, {
                    col,
                    row,
                    table,
                    context: null,
                    value,
                    dataValue,
                    percentile
                }) || '#20a8d8';
                const barMain = createRect({
                    x: barLeft,
                    y: barTop,
                    width: barSize,
                    height: barHeight,
                    fill: fillColor
                });
                percentCompleteBarGroup.addChild(barMain);
            }
            else if (barType === 'negative') {
                const negativeRange = min < 0 ? -min : 0;
                const positiveRange = max > 0 ? max : 0;
                const negativeFactor = negativeRange / (negativeRange + positiveRange);
                const positiveFactor = 1 - negativeFactor;
                const positiveRate = num > 0 ? num / positiveRange : 0;
                const negativeRate = num < 0 ? -num / negativeRange : 0;
                const barMaxWidth = contentWidth;
                const barTop = top + contentHeight - barHeight - barBottom;
                const barLeft = left;
                const bgFillColor = getOrApply(barBgColor, {
                    col,
                    row,
                    table,
                    context: null,
                    value,
                    dataValue,
                    percentile: positiveRate
                });
                if (bgFillColor) {
                    const barBack = createRect({
                        x: barLeft,
                        y: barTop,
                        width: barMaxWidth,
                        height: barHeight,
                        fill: bgFillColor
                    });
                    percentCompleteBarGroup.addChild(barBack);
                }
                const positiveLeft = barRightToLeft ? positiveFactor * barMaxWidth : negativeFactor * barMaxWidth;
                const barSizeNega = Math.min(barMaxWidth * negativeFactor * negativeRate, barMaxWidth);
                const barRectNega = barRightToLeft
                    ? {
                        left: barLeft + positiveLeft,
                        top: barTop,
                        width: barSizeNega,
                        height: barHeight
                    }
                    : {
                        left: barLeft + positiveLeft - barSizeNega,
                        top: barTop,
                        width: barSizeNega,
                        height: barHeight
                    };
                const barNagiFillColor = getOrApply(barNegativeColor, {
                    col,
                    row,
                    table,
                    context: null,
                    value,
                    dataValue,
                    percentile: negativeRate
                }) || '#20a8d8';
                const barNega = createRect({
                    x: barRectNega.left,
                    y: barRectNega.top,
                    width: barRectNega.width,
                    height: barRectNega.height,
                    fill: barNagiFillColor
                });
                percentCompleteBarGroup.addChild(barNega);
                let barSizePosi = Math.min(barMaxWidth * positiveFactor * positiveRate, barMaxWidth);
                if (col === table.colCount - 1 && positiveRate === 1 && !barRightToLeft) {
                    barSizePosi -= 1;
                }
                const barRectPosi = barRightToLeft
                    ? {
                        left: barLeft + positiveLeft - barSizePosi,
                        top: barTop,
                        width: barSizePosi,
                        height: barHeight
                    }
                    : {
                        left: barLeft + positiveLeft,
                        top: barTop,
                        width: barSizePosi,
                        height: barHeight
                    };
                const barPosiFillColor = getOrApply(barPositiveColor, {
                    col,
                    row,
                    table,
                    context: null,
                    value,
                    dataValue,
                    percentile: positiveRate
                }) || '#20a8d8';
                const barPosi = createRect({
                    x: barRectPosi.left,
                    y: barRectPosi.top,
                    width: barRectPosi.width,
                    height: barRectPosi.height,
                    fill: barPosiFillColor
                });
                percentCompleteBarGroup.addChild(barPosi);
                const lineLeft = barRightToLeft ? barRectNega.left : barRectPosi.left;
                const lineStrokeColor = getOrApply(barAxisColor, {
                    col,
                    row,
                    table,
                    context: null,
                    value,
                    dataValue,
                    percentile: positiveRate
                });
                const line = createLine({
                    x: 0,
                    y: 0,
                    stroke: lineStrokeColor,
                    lineWidth: 1,
                    lineDash: [2, 2],
                    points: [
                        { x: lineLeft, y: 0 },
                        { x: lineLeft, y: height }
                    ]
                });
                percentCompleteBarGroup.addChild(line);
                if (showBarMark && (positiveRate || negativeRate)) {
                    const lineWidth = barMarkWidth;
                    const points = [];
                    let barMarkStrokeColor;
                    if (positiveRate > 0) {
                        barMarkStrokeColor =
                            getOrApply(barMarkPositiveColor, {
                                col,
                                row,
                                table,
                                context: null,
                                value,
                                dataValue,
                                percentile: positiveRate
                            }) || '#20a8d8';
                        if (barMarkPosition === 'right') {
                            const markLeft = barRightToLeft
                                ? barRectPosi.left + barMarkWidth / 2
                                : barRectPosi.left + barRectPosi.width + (barMarkInBar ? -barMarkWidth / 2 : barMarkWidth / 2);
                            points.push({ x: markLeft, y: barRectPosi.top });
                            points.push({ x: markLeft, y: barRectPosi.top + barRectPosi.height });
                        }
                        else if (barMarkPosition === 'bottom') {
                            points.push({
                                x: barRectPosi.left,
                                y: barRectPosi.top + barRectPosi.height - barMarkWidth / 2
                            });
                            points.push({
                                x: barRectPosi.left + barRectPosi.width,
                                y: barRectPosi.top + barRectPosi.height - barMarkWidth / 2
                            });
                        }
                    }
                    else if (negativeRate > 0) {
                        barMarkStrokeColor =
                            getOrApply(barMarkNegativeColor, {
                                col,
                                row,
                                table,
                                context: null,
                                value,
                                dataValue,
                                percentile: negativeRate
                            }) || '#20a8d8';
                        if (barMarkPosition === 'right') {
                            const markLeft = barRightToLeft
                                ? barRectNega.left + barRectNega.width - barMarkWidth / 2
                                : barRectNega.left + barMarkWidth / 2;
                            points.push({ x: markLeft, y: barRectNega.top });
                            points.push({ x: markLeft, y: barRectNega.top + barRectNega.height });
                        }
                        else if (barMarkPosition === 'bottom') {
                            points.push({
                                x: barRectNega.left,
                                y: barRectNega.top + barRectNega.height - barMarkWidth / 2
                            });
                            points.push({
                                x: barRectNega.left + barRectNega.width,
                                y: barRectNega.top + barRectNega.height - barMarkWidth / 2
                            });
                        }
                    }
                    const barMark = createLine({
                        x: 0,
                        y: 0,
                        stroke: barMarkStrokeColor,
                        lineWidth,
                        points
                    });
                    percentCompleteBarGroup.addChild(barMark);
                }
            }
            else if (barType === 'negative_no_axis') {
                const _negativeRange = min < 0 ? -min : 0;
                const _positiveRange = max > 0 ? max : 0;
                const range = Math.max(_negativeRange, _positiveRange);
                const percentile = range === 0 ? 0 : Math.abs(num) / range;
                const barMaxWidth = contentWidth;
                let barSize = Math.min(barMaxWidth * percentile, barMaxWidth);
                if (col === table.colCount - 1 && percentile === 1 && !barRightToLeft) {
                    barSize -= 1;
                }
                const barTop = top + contentHeight - barHeight - barBottom;
                const barLeft = barRightToLeft ? left + right - barSize : left;
                const bgFillColor = getOrApply(barBgColor, {
                    col,
                    row,
                    table,
                    context: null,
                    value,
                    dataValue,
                    percentile
                });
                if (bgFillColor) {
                    const barBack = createRect({
                        x: barLeft,
                        y: barTop,
                        width: barMaxWidth,
                        height: barHeight,
                        fill: bgFillColor
                    });
                    percentCompleteBarGroup.addChild(barBack);
                }
                const barRect = {
                    left: barLeft,
                    top: barTop,
                    width: barSize,
                    height: barHeight
                };
                let barRectFillColor;
                if (num >= 0) {
                    barRectFillColor =
                        getOrApply(barPositiveColor, {
                            col,
                            row,
                            table,
                            context: null,
                            value,
                            percentile,
                            dataValue
                        }) || '#20a8d8';
                }
                else {
                    barRectFillColor =
                        getOrApply(barNegativeColor, {
                            col,
                            row,
                            table,
                            context: null,
                            value,
                            dataValue,
                            percentile
                        }) || '#20a8d8';
                }
                const bar = createRect({
                    x: barRect.left,
                    y: barRect.top,
                    width: barRect.width,
                    height: barRect.height,
                    fill: barRectFillColor
                });
                percentCompleteBarGroup.addChild(bar);
                if (showBarMark && num) {
                    const lineWidth = barMarkWidth;
                    const points = [];
                    let barMarkStrokeColor;
                    if (num >= 0) {
                        barMarkStrokeColor =
                            getOrApply(barMarkPositiveColor, {
                                col,
                                row,
                                table,
                                context: null,
                                value,
                                dataValue,
                                percentile
                            }) || '#20a8d8';
                    }
                    else {
                        barMarkStrokeColor =
                            getOrApply(barMarkNegativeColor, {
                                col,
                                row,
                                table,
                                context: null,
                                value,
                                dataValue,
                                percentile
                            }) || '#20a8d8';
                    }
                    if (barMarkPosition === 'right') {
                        const markLeft = barRightToLeft
                            ? barRect.left + barMarkWidth / 2
                            : barRect.left + barRect.width - barMarkWidth / 2;
                        points.push({ x: markLeft, y: barRect.top });
                        points.push({ x: markLeft, y: barRect.top + barRect.height });
                    }
                    else if (barMarkPosition === 'bottom') {
                        points.push({
                            x: barRect.left,
                            y: barRect.top + barRect.height - barMarkWidth / 2
                        });
                        points.push({
                            x: barRect.left + barRect.width,
                            y: barRect.top + barRect.height - barMarkWidth / 2
                        });
                    }
                    const barMark = createLine({
                        x: 0,
                        y: 0,
                        stroke: barMarkStrokeColor,
                        lineWidth,
                        points
                    });
                    percentCompleteBarGroup.addChild(barMark);
                }
            }
        }
        return percentCompleteBarGroup;
    }

    const DEFAULT_CONTINUOUS_TICK_COUNT = 5;
    function getAxisDomainRangeAndLabels(min, max, axisOption, isZeroAlign, axisLength, target) {
        if (axisOption?.zero) {
            min = Math.min(min, 0);
            max = Math.max(max, 0);
        }
        if (axisOption?.expand) {
            const domainMin = min;
            const domainMax = max;
            if (isValid$3(axisOption.expand.min)) {
                min = domainMin - (domainMax - domainMin) * axisOption.expand.min;
            }
            if (isValid$3(axisOption.expand.max)) {
                max = domainMax + (domainMax - domainMin) * axisOption.expand.max;
            }
        }
        if (isNumber$4(axisOption?.min)) {
            min = axisOption.min;
        }
        if (isNumber$4(axisOption?.max)) {
            max = axisOption.max;
        }
        let scale;
        if (axisOption?.type === 'log') {
            scale = new LogScale();
            scale.base(axisOption?.base ?? 10);
        }
        else if (axisOption?.type === 'symlog') {
            scale = new SymlogScale();
            scale.constant(axisOption?.constant ?? 10);
        }
        else {
            scale = new LinearScale();
        }
        scale.domain([min, max], !!axisOption?.nice);
        if (target) {
            forceTickCountNice(scale, target);
        }
        else if (axisOption?.nice) {
            let tickCount = axisOption.tick?.forceTickCount ?? axisOption.tick?.tickCount ?? 10;
            if (isFunction$5(tickCount)) {
                tickCount = tickCount({
                    axisLength,
                    labelStyle: axisOption?.label?.style ?? {
                        fontSize: THEME_CONSTANTS.LABEL_FONT_SIZE
                    }
                });
            }
            if (axisOption.niceType === 'accurateFirst') {
                tickCount = Math.max(10, tickCount);
            }
            if (isNil$3(axisOption.min) && isNil$3(axisOption.max)) {
                scale.nice(tickCount);
            }
            else if (isValid$3(axisOption.min) && isNil$3(axisOption.max)) {
                scale.niceMax(tickCount);
            }
            else if (isNil$3(axisOption.min) && isValid$3(axisOption.max)) {
                scale.niceMin(tickCount);
            }
        }
        delete scale._niceType;
        let scaleTicks;
        if (target?.targetTicks?.length ?? axisOption?.tick?.forceTickCount) {
            scaleTicks = scale.forceTicks(target?.targetTicks?.length ?? axisOption?.tick?.forceTickCount);
        }
        else {
            scaleTicks = scale.ticks(isNumber$4(axisOption?.tick?.tickCount) ? axisOption.tick.tickCount : DEFAULT_CONTINUOUS_TICK_COUNT, {
                noDecimals: axisOption?.tick?.noDecimals
            });
        }
        return {
            range: scale.domain(),
            ticks: scaleTicks
        };
    }
    function forceTickCountNice(scale, target) {
        scale.niceMax(target.targetTicks.length);
    }

    function createButtonCellGroup(cellGroup, columnGroup, xOrigin, yOrigin, col, row, colWidth, width, height, padding, textAlign, textBaseline, mayHaveIcon, table, cellTheme, define, range, isAsync) {
        if (!cellGroup) {
            const strokeArrayWidth = getCellBorderStrokeWidth(col, row, cellTheme, table);
            if (isAsync) {
                cellGroup = table.scenegraph.highPerformanceGetCell(col, row, true);
                if (cellGroup && cellGroup.role === 'cell') {
                    cellGroup.setAttributes({
                        x: xOrigin,
                        y: yOrigin,
                        width,
                        height,
                        lineWidth: cellTheme?.group?.lineWidth ?? undefined,
                        fill: cellTheme?.group?.fill ?? undefined,
                        stroke: cellTheme?.group?.stroke ?? undefined,
                        strokeArrayWidth: strokeArrayWidth,
                        strokeArrayColor: cellTheme?.group?.strokeArrayColor ?? undefined,
                        cursor: cellTheme?.group?.cursor ?? undefined,
                        lineDash: cellTheme?.group?.lineDash ?? undefined,
                        lineCap: 'butt',
                        clip: true,
                        cornerRadius: cellTheme.group.cornerRadius
                    });
                }
            }
            if (!cellGroup || cellGroup.role !== 'cell') {
                cellGroup = new Group$1({
                    x: xOrigin,
                    y: yOrigin,
                    width,
                    height,
                    lineWidth: cellTheme?.group?.lineWidth ?? undefined,
                    fill: cellTheme?.group?.fill ?? undefined,
                    stroke: cellTheme?.group?.stroke ?? undefined,
                    strokeArrayWidth: strokeArrayWidth,
                    strokeArrayColor: cellTheme?.group?.strokeArrayColor ?? undefined,
                    cursor: cellTheme?.group?.cursor ?? undefined,
                    lineDash: cellTheme?.group?.lineDash ?? undefined,
                    lineCap: 'butt',
                    clip: true,
                    cornerRadius: cellTheme.group.cornerRadius
                });
                cellGroup.role = 'cell';
                cellGroup.col = col;
                cellGroup.row = row;
                columnGroup?.addCellGroup(cellGroup);
            }
        }
        let icons;
        if (mayHaveIcon) {
            let iconCol = col;
            let iconRow = row;
            if (range) {
                iconCol = range.start.col;
                iconRow = range.start.row;
            }
            icons = table.getCellIcons(iconCol, iconRow);
        }
        let iconWidth = 0;
        let cellLeftIconWidth = 0;
        if (Array.isArray(icons) && icons.length !== 0) {
            const { leftIconWidth, rightIconWidth, absoluteLeftIconWidth, absoluteRightIconWidth } = dealWithIconLayout(icons, cellGroup, range, table);
            iconWidth = leftIconWidth + rightIconWidth;
            cellLeftIconWidth = leftIconWidth;
            cellGroup.forEachChildren((child) => {
                if (child.role === 'icon-left') {
                    child.setAttribute('x', child.attribute.x + padding[3]);
                }
                else if (child.role === 'icon-right') {
                    child.setAttribute('x', child.attribute.x + width - rightIconWidth - padding[1]);
                }
                else if (child.role === 'icon-absolute-right') {
                    child.setAttribute('x', child.attribute.x + width - absoluteRightIconWidth - padding[1]);
                }
            });
            cellGroup.forEachChildren((child) => {
                if (textBaseline === 'middle') {
                    child.setAttribute('y', (height - child.AABBBounds.height()) / 2);
                }
                else if (textBaseline === 'bottom') {
                    child.setAttribute('y', height - child.AABBBounds.height() - padding[2]);
                }
                else {
                    child.setAttribute('y', padding[0]);
                }
            });
        }
        const buttonComponent = createButton(col, row, colWidth - iconWidth, width, height, padding, cellTheme, define, table);
        if (buttonComponent) {
            cellGroup.appendChild(buttonComponent);
        }
        width -= padding[1] + padding[3] + iconWidth;
        height -= padding[0] + padding[2];
        if (textAlign === 'center') {
            buttonComponent.setAttribute('x', padding[3] + cellLeftIconWidth + (width - buttonComponent.AABBBounds.width()) / 2);
        }
        else if (textAlign === 'right') {
            buttonComponent.setAttribute('x', padding[3] + cellLeftIconWidth + width - buttonComponent.AABBBounds.width());
        }
        else {
            buttonComponent.setAttribute('x', padding[3] + cellLeftIconWidth);
        }
        if (textBaseline === 'middle') {
            buttonComponent.setAttribute('y', padding[0] + (height - buttonComponent.AABBBounds.height()) / 2);
        }
        else if (textBaseline === 'bottom') {
            buttonComponent.setAttribute('y', padding[0] + height - buttonComponent.AABBBounds.height());
        }
        else {
            buttonComponent.setAttribute('y', padding[0]);
        }
        return cellGroup;
    }
    function createButton(col, row, colWidth, cellWidth, cellHeight, padding, cellTheme, define, table) {
        const style = table._getCellStyle(col, row);
        const buttonColor = getProp('buttonColor', style, col, row, table);
        const buttonBorderColor = getProp('buttonBorderColor', style, col, row, table);
        const buttonLineWidth = getProp('buttonLineWidth', style, col, row, table);
        const buttonBorderRadius = getProp('buttonBorderRadius', style, col, row, table);
        const buttonHoverColor = getProp('buttonHoverColor', style, col, row, table);
        const buttonHoverBorderColor = getProp('buttonHoverBorderColor', style, col, row, table);
        const buttonPadding = getProp('buttonPadding', style, col, row, table);
        const buttonTextHoverColor = getProp('buttonTextHoverColor', style, col, row, table);
        const buttonDisableColor = getProp('buttonDisableColor', style, col, row, table);
        const buttonDisableBorderColor = getProp('buttonDisableBorderColor', style, col, row, table);
        const buttonTextDisableColor = getProp('buttonTextDisableColor', style, col, row, table);
        const value = table.getCellValue(col, row);
        const dataValue = table.getCellOriginValue(col, row);
        const hierarchyOffset = getHierarchyOffset(col, row, table);
        const cellStyle = table._getCellStyle(col, row);
        const autoWrapText = cellStyle.autoWrapText ?? table.internalProps.autoWrapText;
        const { lineClamp } = cellStyle;
        const autoColWidth = colWidth === 'auto';
        const autoRowHeight = table.isAutoRowHeight(row);
        const { disable, text } = define;
        const isDisable = getOrApply(disable, {
            col,
            row,
            table,
            context: null,
            value,
            dataValue
        });
        const buttonTextValue = getOrApply(text, {
            col,
            row,
            table,
            context: null,
            value,
            dataValue
        });
        const buttonText = buttonTextValue ?? value ?? '';
        const attribute = {
            maxLineWidth: autoColWidth ? Infinity : cellWidth - (padding[1] + padding[3] + hierarchyOffset),
            textAlign: 'left',
            textBaseline: 'top',
            autoWrapText,
            lineClamp,
            wordBreak: 'break-word',
            heightLimit: autoRowHeight ? -1 : cellHeight - Math.floor(padding[0] + padding[2]),
            pickable: false,
            dx: hierarchyOffset,
            whiteSpace: buttonText.length === 1 && !autoWrapText ? 'no-wrap' : 'normal'
        };
        const testAttribute = cellTheme.text ? Object.assign({}, cellTheme.text, attribute) : attribute;
        const buttonAttributes = {
            x: 0,
            y: 0,
            cursor: isDisable ? 'not-allowed' : 'pointer',
            disable: isDisable,
            childrenPickable: false,
            text: buttonText.length === 1 ? buttonText[0] : buttonText,
            textStyle: testAttribute,
            padding: buttonPadding,
            panel: {
                visible: true,
                fill: isDisable ? buttonDisableColor : buttonColor,
                stroke: isDisable ? buttonDisableBorderColor : buttonBorderColor,
                lineWidth: buttonLineWidth,
                cornerRadius: buttonBorderRadius
            },
            state: {
                text: {
                    hover: {}
                },
                panel: {
                    hover: {
                        fill: buttonHoverColor,
                        stroke: buttonHoverBorderColor
                    }
                }
            }
        };
        buttonTextDisableColor && (buttonAttributes.state.text.fill = buttonTextDisableColor);
        buttonTextHoverColor && (buttonAttributes.state.text.hover.fill = buttonTextHoverColor);
        const buttonComponent = new Tag$1(buttonAttributes);
        buttonComponent.name = 'button';
        if (!isDisable) {
            buttonComponent.addEventListener('mouseenter', () => {
                buttonComponent.addState('hover', true, false);
                buttonComponent.stage.renderNextFrame();
            });
            buttonComponent.addEventListener('mouseleave', () => {
                buttonComponent.removeState('hover', false);
                buttonComponent.stage.renderNextFrame();
            });
        }
        return buttonComponent;
    }

    const registerChartCell = () => {
        Factory.registerFunction('createChartCellGroup', createChartCellGroup);
        Factory.registerFunction('getAxisDomainRangeAndLabels', getAxisDomainRangeAndLabels);
    };
    const registerCheckboxCell = () => {
        Factory.registerFunction('createCheckboxCellGroup', createCheckboxCellGroup);
    };
    const registerImageCell = () => {
        Factory.registerFunction('createImageCellGroup', createImageCellGroup);
    };
    const registerProgressBarCell = () => {
        Factory.registerFunction('createProgressBarCell', createProgressBarCell);
    };
    const registerRadioCell = () => {
        Factory.registerFunction('createRadioCellGroup', createRadioCellGroup);
    };
    const registerSwitchCell = () => {
        Factory.registerFunction('createSwitchCellGroup', createSwitchCellGroup);
    };
    const registerButtonCell = () => {
        Factory.registerFunction('createButtonCellGroup', createButtonCellGroup);
    };
    const registerSparkLineCell = () => {
        Factory.registerFunction('createSparkLineCellGroup', createSparkLineCellGroup);
    };
    const registerTextCell = () => {
        Factory.registerFunction('createTextCellGroup', createCellGroup);
    };
    const registerVideoCell = () => {
        Factory.registerFunction('createVideoCellGroup', createVideoCellGroup);
    };

    registerAxis();
    registerEmptyTip();
    registerLegend();
    registerMenu();
    registerTitle();
    registerTooltip();
    registerListTreeStickCellPlugin();
    registerCustomCellStylePlugin();
    registerChartCell();
    registerCheckboxCell();
    registerImageCell();
    registerProgressBarCell();
    registerRadioCell();
    registerSwitchCell();
    registerButtonCell();
    registerSparkLineCell();
    registerTextCell();
    registerVideoCell();
    class ListTableAll extends ListTable {
    }

    registerTextCell();
    class ListTableSimple extends ListTable {
    }

    function diffCellAddress(col, row, oldCellIds, newCellIds, oldRowHeaderCellPositons, layout) {
        const columnHeaderStart = layout.columnHeaderLevelCount;
        const addCellPositionsRowDirection = [];
        const removeCellPositionsRowDirection = [];
        for (let i = 0; i < oldCellIds.length; i++) {
            if (!newCellIds.includes(oldCellIds[i])) {
                removeCellPositionsRowDirection.push(oldRowHeaderCellPositons[i]);
            }
        }
        for (let i = 0; i < newCellIds.length; i++) {
            if (!oldCellIds.includes(newCellIds[i])) {
                const newCellAddr = { col, row: columnHeaderStart + i };
                addCellPositionsRowDirection.push(newCellAddr);
            }
        }
        let parentId = layout.getParentCellId(col, row);
        let parentCellAddress = layout.getRowHeaderCellAddressByCellId(parentId);
        const updateCellPositionsRowDirection = [];
        parentCellAddress && updateCellPositionsRowDirection.push(parentCellAddress);
        while (parentId) {
            parentId = layout.getParentCellId(parentCellAddress.col, parentCellAddress.row);
            if (parentId) {
                parentCellAddress = layout.getRowHeaderCellAddressByCellId(parentId);
                updateCellPositionsRowDirection.push(parentCellAddress);
            }
        }
        return {
            addCellPositionsRowDirection,
            removeCellPositionsRowDirection,
            updateCellPositionsRowDirection
        };
    }
    function diffCellAddressForGridTree(col, row, oldCellIds, newCellIds, oldRowHeaderCellPositons, layout) {
        const columnHeaderStart = layout.columnHeaderLevelCount;
        const addCellPositionsRowDirection = [];
        const removeCellPositionsRowDirection = [];
        for (let i = 0; i < oldCellIds.length; i++) {
            if (!newCellIds.includes(oldCellIds[i])) {
                removeCellPositionsRowDirection.push(oldRowHeaderCellPositons[i]);
            }
        }
        for (let i = 0; i < newCellIds.length; i++) {
            if (!oldCellIds.includes(newCellIds[i])) {
                const newCellAddr = { col, row: columnHeaderStart + i };
                addCellPositionsRowDirection.push(newCellAddr);
            }
        }
        let parentId = layout.getParentCellId(col, row);
        let parentCellAddress = layout.getRowHeaderCellAddressByCellId(parentId);
        const updateCellPositionsRowDirection = [];
        parentCellAddress && updateCellPositionsRowDirection.push(parentCellAddress);
        while (parentId) {
            parentId = layout.getParentCellId(parentCellAddress.col, parentCellAddress.row);
            if (parentId) {
                parentCellAddress = layout.getRowHeaderCellAddressByCellId(parentId);
                updateCellPositionsRowDirection.push(parentCellAddress);
            }
        }
        const addCellPositionsColumnDirection = [];
        const removeCellPositionsColumnDirection = [];
        if (layout.rowHierarchyType === 'grid-tree' &&
            layout.cornerSetting.titleOnDimension === 'column' &&
            layout.rowHeaderLevelCount !== layout._cornerHeaderCellIds[0].length) {
            if (layout.rowHeaderLevelCount > layout._cornerHeaderCellIds[0].length) {
                for (let i = layout._cornerHeaderCellIds[0].length; i < layout.rowHeaderLevelCount; i++) {
                    addCellPositionsColumnDirection.push({ col: i, row });
                }
            }
            else {
                for (let i = layout.rowHeaderLevelCount; i < layout._cornerHeaderCellIds[0].length; i++) {
                    removeCellPositionsColumnDirection.push({ col: i, row });
                }
            }
        }
        return {
            addCellPositionsRowDirection,
            removeCellPositionsRowDirection,
            updateCellPositionsRowDirection,
            addCellPositionsColumnDirection,
            removeCellPositionsColumnDirection
        };
    }
    function diffCellAddressForGridTreeOnColumn(col, row, oldCellIds, newCellIds, oldRowHeaderCellPositons, layout) {
        const rowHeaderStart = layout.rowHeaderLevelCount;
        const addCellPositionsColumnDirection = [];
        const removeCellPositionsColumnDirection = [];
        for (let i = 0; i < oldCellIds.length; i++) {
            if (!newCellIds.includes(oldCellIds[i])) {
                removeCellPositionsColumnDirection.push(oldRowHeaderCellPositons[i]);
            }
        }
        for (let i = 0; i < newCellIds.length; i++) {
            if (!oldCellIds.includes(newCellIds[i])) {
                const newCellAddr = { col: rowHeaderStart + i, row };
                addCellPositionsColumnDirection.push(newCellAddr);
            }
        }
        let parentId = layout.getParentCellId(col, row);
        let parentCellAddress = layout.getRowHeaderCellAddressByCellId(parentId);
        const updateCellPositionsColumnDirection = [];
        parentCellAddress && updateCellPositionsColumnDirection.push(parentCellAddress);
        while (parentCellAddress && parentId) {
            parentId = layout.getParentCellId(parentCellAddress.col, parentCellAddress.row);
            if (parentId) {
                parentCellAddress = layout.getRowHeaderCellAddressByCellId(parentId);
                updateCellPositionsColumnDirection.push(parentCellAddress);
            }
        }
        const addCellPositionsRowDirection = [];
        const removeCellPositionsRowDirection = [];
        if (layout.columnHierarchyType === 'grid-tree' &&
            layout.cornerSetting.titleOnDimension === 'row' &&
            layout.columnHeaderLevelCount !== layout._cornerHeaderCellIds.length) {
            if (layout.columnHeaderLevelCount > layout._cornerHeaderCellIds.length) {
                for (let i = layout._cornerHeaderCellIds.length; i < layout.columnHeaderLevelCount; i++) {
                    addCellPositionsRowDirection.push({ col, row: i });
                }
            }
            else {
                for (let i = layout.columnHeaderLevelCount; i < layout._cornerHeaderCellIds.length; i++) {
                    removeCellPositionsRowDirection.push({ col, row: i });
                }
            }
        }
        return {
            addCellPositionsColumnDirection,
            removeCellPositionsColumnDirection,
            updateCellPositionsColumnDirection,
            addCellPositionsRowDirection,
            removeCellPositionsRowDirection
        };
    }

    const defaultDimension = { startInTotal: 0, afterSpanLevel: 0 };
    class PivotHeaderLayoutMap {
        sharedVar;
        colIndex = 0;
        _showHeader = true;
        rowDimensionTree;
        columnDimensionTree;
        rowTree;
        columnTree;
        cornerHeaderObjs;
        columnHeaderObjs = [];
        rowHeaderObjs = [];
        _cornerHeaderCellFullPathIds = [];
        _columnHeaderCellFullPathIds = [];
        _rowHeaderCellFullPathIds = [];
        _rowHeaderCellFullPathIds_FULL = [];
        _cornerHeaderCellIds = [];
        _columnHeaderCellIds = [];
        _rowHeaderCellIds = [];
        _rowHeaderCellIds_FULL = [];
        _columnWidths = [];
        _columnHeaderLevelCount;
        _rowHeaderLevelCount;
        rowsDefine;
        columnsDefine;
        indicatorsDefine;
        columnPaths = [];
        _headerObjects = [];
        _headerObjectMap = {};
        _indicators = [];
        indicatorTitle;
        indicatorsAsCol = true;
        hideIndicatorName = false;
        _showRowHeader = true;
        _showColumnHeader = true;
        _rowHeaderTitle;
        _columnHeaderTitle;
        cornerSetting;
        _indicatorShowType = 'column';
        rowHierarchyType;
        columnHierarchyType;
        rowExpandLevel;
        columnExpandLevel;
        rowHierarchyIndent;
        rowHierarchyTextStartAlignment = false;
        rowDimensionKeys = [];
        colDimensionKeys = [];
        indicatorKeys = [];
        indicatorDimensionKey = IndicatorDimensionKeyPlaceholder;
        _largeCellRangeCache;
        _CellHeaderPathMap;
        _table;
        extensionRows;
        _rowHeaderExtensionTree = {};
        _extensionRowDimensionKeys = [];
        fullRowDimensionKeys = [];
        dataset;
        pagination;
        currentPageStartIndex;
        currentPageEndIndex;
        hasTwoIndicatorAxes;
        _chartItemSpanSize;
        _chartPaddingInner;
        _chartPaddingOuter;
        _chartItemBandSize;
        _chartPadding;
        rowSeriesNumberColumn;
        leftRowSeriesNumberColumn;
        leftRowSeriesNumberColumnCount = 0;
        rightRowSeriesNumberColumn;
        rightRowSeriesNumberColumnCount = 0;
        _useGetBodyCache = false;
        _getBodyCache = new Map();
        _useHeaderPathCache = false;
        _colHeaderPathCache = new Map();
        _rowHeaderPathCache = new Map();
        constructor(table, dataset, columnDimensionTree, rowDimensionTree) {
            this.sharedVar = table.layoutNodeId;
            this._table = table;
            if (table.options.rowHierarchyType === 'tree') {
                this.extensionRows = table.options.extensionRows;
            }
            this.dataset = dataset;
            this._largeCellRangeCache = [];
            this._CellHeaderPathMap = new Map();
            this.rowTree = table.internalProps.rowTree;
            this.columnTree = table.internalProps.columnTree;
            this.rowsDefine = table.internalProps.rows ?? [];
            this.columnsDefine = table.internalProps.columns ?? [];
            this.indicatorsDefine = table.internalProps.indicators ?? [];
            this.indicatorTitle = table.options.indicatorTitle;
            this.indicatorsAsCol = table.options.indicatorsAsCol ?? true;
            this.hideIndicatorName = table.options.hideIndicatorName ?? false;
            this.showRowHeader = table.options.showRowHeader ?? true;
            this.showColumnHeader = table.options.showColumnHeader ?? true;
            this.rowHeaderTitle = table.options.rowHeaderTitle;
            this.columnHeaderTitle = table.options.columnHeaderTitle;
            this.rowHierarchyType = table.options.rowHierarchyType ?? 'grid';
            this.columnHierarchyType = table.options.columnHierarchyType ?? 'grid';
            this.rowExpandLevel = table.options.rowExpandLevel ?? 1;
            this.columnExpandLevel = table.options.columnExpandLevel ?? 1;
            this.rowHierarchyIndent = table.options.rowHierarchyIndent ?? 20;
            this.rowHierarchyTextStartAlignment = table.options.rowHierarchyTextStartAlignment;
            this.cornerSetting = Object.assign({ titleOnDimension: 'column', forceShowHeader: false }, table.options.corner);
            if (this._table.options?.customConfig?.enablePivotPathCache) {
                this._useHeaderPathCache = true;
                this._colHeaderPathCache.clear();
                this._rowHeaderPathCache.clear();
            }
            if (dataset) {
                this.rowTree = dataset.rowHeaderTree;
                this.columnTree = dataset.colHeaderTree;
            }
            this.indicatorsDefine?.forEach(indicator => {
                if (typeof indicator === 'string') {
                    this.indicatorKeys.push(indicator);
                }
                else {
                    this.indicatorKeys.push(indicator.indicatorKey);
                }
            });
            this.columnDimensionTree = columnDimensionTree;
            this.rowDimensionTree = rowDimensionTree;
            this.colDimensionKeys = this.columnDimensionTree.dimensionKeysIncludeVirtual.valueArr();
            this.rowDimensionKeys = this.rowDimensionTree.dimensionKeysIncludeVirtual.valueArr();
            this.fullRowDimensionKeys = this.fullRowDimensionKeys.concat(this.rowDimensionKeys);
            this.resetRowHeaderLevelCount();
            if (this._table.isPivotChart()) {
                this.hasTwoIndicatorAxes = this.indicatorsDefine.some((indicatorObject) => {
                    if (indicatorObject.chartSpec &&
                        indicatorObject.chartSpec.series &&
                        indicatorObject.chartSpec.series.length > 1) {
                        const axes = indicatorObject.chartSpec.axes ?? this._table.pivotChartAxes ?? [];
                        if (!axes.length ||
                            axes.every((axis) => {
                                if (axis.orient === (this.indicatorsAsCol ? 'top' : 'right') && axis.visible === false) {
                                    return false;
                                }
                                return true;
                            })) {
                            return true;
                        }
                    }
                    return false;
                });
            }
            this.resetColumnHeaderLevelCount();
            this._generateColHeaderIds();
            this.colIndex = 0;
            this._generateRowHeaderIds();
            this._rowHeaderCellFullPathIds_FULL = transpose(this._rowHeaderCellFullPathIds_FULL);
            if (table.options.rowHierarchyType === 'tree' && this.extensionRows?.length >= 1) {
                this.generateExtensionRowTree();
                this.extensionRows.forEach(extensionRow => {
                    const rowKeys = [];
                    extensionRow.rows.forEach(row => {
                        if (typeof row === 'string') {
                            rowKeys.push(row);
                        }
                        else {
                            rowKeys.push(row.dimensionKey);
                        }
                    });
                    this._extensionRowDimensionKeys.push(rowKeys);
                    this.fullRowDimensionKeys = this.fullRowDimensionKeys.concat(rowKeys);
                });
            }
            this.sharedVar.seqId = Math.max(this.sharedVar.seqId, this._headerObjects.length);
            let colDimensionKeys = this.columnDimensionTree.dimensionKeysIncludeVirtual.valueArr();
            if (this.dataset &&
                !this._table.isPivotChart() &&
                (this.dataset.records?.length ?? 0) === 0 &&
                !this.dataset.customColTree) {
                colDimensionKeys = this.columnsDefine.map(define => {
                    if (typeof define === 'string') {
                        return define;
                    }
                    return define.dimensionKey;
                });
                if (this.indicatorsAsCol) {
                    colDimensionKeys.push(this.indicatorDimensionKey);
                }
            }
            colDimensionKeys = this.columnHeaderTitle ? [''].concat(colDimensionKeys) : colDimensionKeys;
            let rowDimensionKeys;
            let extensionRowDimensions = [];
            if (this.rowHierarchyType === 'tree' && this.extensionRows?.length >= 1) {
                const rowTreeFirstKey = [];
                rowTreeFirstKey.push(this.rowDimensionKeys[0]);
                this._extensionRowDimensionKeys.forEach(extensionRowKeys => {
                    rowTreeFirstKey.push(extensionRowKeys[0]);
                });
                extensionRowDimensions = this.extensionRows.reduce((dimensions, cur) => {
                    return dimensions.concat(cur.rows);
                }, []);
                rowDimensionKeys = this.rowHeaderTitle ? [''].concat(rowTreeFirstKey) : rowTreeFirstKey;
            }
            else {
                rowDimensionKeys = this.rowDimensionTree.dimensionKeysIncludeVirtual.valueArr();
                if (this.dataset &&
                    !this._table.isPivotChart() &&
                    (this.dataset.records?.length ?? 0) === 0 &&
                    !this.dataset.customRowTree) {
                    rowDimensionKeys = this.rowsDefine.map(define => {
                        if (typeof define === 'string') {
                            return define;
                        }
                        return define.dimensionKey;
                    });
                    if (!this.indicatorsAsCol) {
                        rowDimensionKeys.push(this.indicatorDimensionKey);
                    }
                }
                rowDimensionKeys = this.rowHeaderTitle ? [''].concat(rowDimensionKeys) : rowDimensionKeys;
            }
            this.cornerHeaderObjs = this._addCornerHeaders(colDimensionKeys, rowDimensionKeys, this.columnsDefine.concat(...this.rowsDefine, ...extensionRowDimensions));
            this.colIndex = 0;
            this._headerObjectMap = this._headerObjects.reduce((o, e) => {
                o[e.id] = e;
                return o;
            }, {});
            if (this.indicatorsAsCol && !this.hideIndicatorName) {
                this._indicatorShowType = 'column';
            }
            else if (!this.indicatorsAsCol && !this.hideIndicatorName) {
                this._indicatorShowType = 'row';
            }
            else {
                this._indicatorShowType = 'none';
            }
            this.generateCellIdsConsiderHideHeader();
            this.setPagination(table.options.pagination);
            if (this._table.isPivotChart()) {
                this._chartItemSpanSize = 0;
                this._chartItemBandSize = 0;
                this._indicators.find(indicatorObject => {
                    if (indicatorObject?.style?.padding) {
                        this._chartPadding = indicatorObject.style.padding;
                    }
                    if (indicatorObject.chartSpec?.barWidth && typeof indicatorObject.chartSpec.barWidth === 'number') {
                        this._chartItemSpanSize = indicatorObject.chartSpec?.barWidth;
                    }
                    const bandAxisConfig = indicatorObject.chartSpec?.axes?.find((axis) => {
                        return axis.type === 'band';
                    });
                    if (bandAxisConfig?.bandSize) {
                        this._chartItemBandSize = bandAxisConfig?.bandSize;
                        this._chartPaddingInner =
                            (isArray$7(bandAxisConfig.paddingInner) ? bandAxisConfig.paddingInner[0] : bandAxisConfig.paddingInner) ?? 0;
                        this._chartPaddingOuter =
                            (isArray$7(bandAxisConfig.paddingOuter) ? bandAxisConfig.paddingOuter[0] : bandAxisConfig.paddingOuter) ?? 0;
                    }
                    if (this._chartItemSpanSize > 0) {
                        return true;
                    }
                    indicatorObject.chartSpec.series?.find((seriesObject) => {
                        if (seriesObject.barWidth && typeof seriesObject.barWidth === 'number') {
                            this._chartItemSpanSize = seriesObject.barWidth;
                        }
                        if (this._chartItemSpanSize > 0) {
                            return true;
                        }
                        return false;
                    });
                    return false;
                });
            }
            this.handleRowSeriesNumber(table.internalProps.rowSeriesNumber);
            this.setColumnWidths();
        }
        handleRowSeriesNumber(rowSeriesNumber) {
            if (rowSeriesNumber) {
                if (Array.isArray(rowSeriesNumber)) {
                    this.rowSeriesNumberColumn = rowSeriesNumber.map((seriesNumber) => {
                        return {
                            id: '',
                            title: seriesNumber.title,
                            define: seriesNumber,
                            cellType: seriesNumber.cellType ?? 'text',
                            headerType: seriesNumber.cellType && seriesNumber.cellType !== 'radio' ? seriesNumber.cellType : 'text',
                            width: seriesNumber.width,
                            style: seriesNumber.style,
                            format: seriesNumber.format,
                            field: seriesNumber.field,
                            icon: seriesNumber.icon,
                            headerIcon: seriesNumber.headerIcon,
                            isChildNode: false
                        };
                    });
                }
                else {
                    this.rowSeriesNumberColumn = [
                        {
                            id: '',
                            title: rowSeriesNumber.title,
                            define: rowSeriesNumber,
                            cellType: rowSeriesNumber.cellType ?? 'text',
                            headerType: rowSeriesNumber.cellType && rowSeriesNumber.cellType !== 'radio' ? rowSeriesNumber.cellType : 'text',
                            style: rowSeriesNumber.style,
                            width: rowSeriesNumber.width,
                            format: rowSeriesNumber.format,
                            field: '',
                            icon: rowSeriesNumber.icon,
                            headerIcon: rowSeriesNumber.headerIcon,
                            isChildNode: false
                        }
                    ];
                }
                this.leftRowSeriesNumberColumn = this.rowSeriesNumberColumn.filter(rowSeriesNumberItem => {
                    return true;
                });
                this.rightRowSeriesNumberColumn = this.rowSeriesNumberColumn.filter(rowSeriesNumberItem => {
                    return false;
                });
                this.leftRowSeriesNumberColumnCount = this.leftRowSeriesNumberColumn.length;
                this.rightRowSeriesNumberColumnCount = this.rightRowSeriesNumberColumn.length;
            }
        }
        _generateColHeaderIds() {
            if (this.columnDimensionTree.tree.children?.length >= 1) {
                if (this.columnHierarchyType === 'grid-tree') {
                    const startCol = 0;
                    this._addHeadersForGridTreeMode(this._columnHeaderCellFullPathIds, startCol, this.columnDimensionTree.tree.children, [], this.columnDimensionTree.totalLevel, this._getColumnHeaderTreeExpandedMaxLevelCount(), true, this.columnsDefine, this.columnHeaderObjs, false);
                }
                else {
                    let startRow = 0;
                    if (this.dataset &&
                        !this._table.isPivotChart() &&
                        (this.dataset.records?.length ?? 0) === 0 &&
                        !this.dataset.customColTree &&
                        !this.dataset.customRowTree &&
                        this.indicatorsAsCol &&
                        this._getColumnHeaderTreeExpandedMaxLevelCount() < this.columnHeaderLevelCount) {
                        startRow = this.columnHeaderLevelCount - this._getColumnHeaderTreeExpandedMaxLevelCount();
                        for (let i = 0; i < startRow; i++) {
                            this._columnHeaderCellFullPathIds.unshift([]);
                        }
                    }
                    this._addHeaders(this._columnHeaderCellFullPathIds, startRow, this.columnDimensionTree.tree.children, [], this.columnHeaderObjs);
                }
            }
            if (this.columnHeaderTitle) {
                this.sharedVar.seqId = Math.max(this.sharedVar.seqId, this._headerObjects.length);
                const id = ++this.sharedVar.seqId;
                const firstRowIds = Array(this.colCount - this.rowHeaderLevelCount - this.rightFrozenColCount).fill(id);
                this._columnHeaderCellFullPathIds.unshift(firstRowIds);
                const cell = {
                    id,
                    title: typeof this.columnHeaderTitle.title === 'string'
                        ? this.columnHeaderTitle.title
                        : this.columnsDefine.reduce((title, value) => {
                            if (typeof value === 'string') {
                                return title;
                            }
                            return title + (title ? `/${value.title}` : `${value.title}`);
                        }, ''),
                    field: undefined,
                    headerType: this.columnHeaderTitle?.headerType ?? 'text',
                    style: this.columnHeaderTitle?.headerStyle,
                    define: {
                        id,
                        disableHeaderHover: !!this.columnHeaderTitle?.disableHeaderHover,
                        disableHeaderSelect: !!this.columnHeaderTitle?.disableHeaderSelect
                    }
                };
                this.columnHeaderObjs.push(cell);
                this._headerObjects[id] = cell;
            }
        }
        _generateRowHeaderIds() {
            if (this.rowDimensionTree.tree.children?.length >= 1) {
                if (this.rowHierarchyType === 'tree') {
                    this._addHeadersForTreeMode(this._rowHeaderCellFullPathIds_FULL, 0, this.rowDimensionTree.tree.children, [], this.rowDimensionTree.totalLevel, true, this.rowsDefine, this.rowHeaderObjs);
                }
                else if (this.rowHierarchyType === 'grid-tree') {
                    const startRow = 0;
                    this._addHeadersForGridTreeMode(this._rowHeaderCellFullPathIds_FULL, startRow, this.rowDimensionTree.tree.children, [], this.rowDimensionTree.totalLevel, this._getRowHeaderTreeExpandedMaxLevelCount(), true, this.rowsDefine, this.rowHeaderObjs, true);
                }
                else {
                    let startRow = 0;
                    if (this.dataset &&
                        !this._table.isPivotChart() &&
                        (this.dataset.records?.length ?? 0) === 0 &&
                        !this.dataset.customColTree &&
                        !this.dataset.customRowTree &&
                        !this.indicatorsAsCol &&
                        this._getRowHeaderTreeExpandedMaxLevelCount() < this.rowHeaderLevelCount) {
                        startRow = this.rowHeaderLevelCount - this._getRowHeaderTreeExpandedMaxLevelCount();
                        for (let i = 0; i < startRow; i++) {
                            this._rowHeaderCellFullPathIds_FULL.unshift([]);
                        }
                    }
                    this._addHeaders(this._rowHeaderCellFullPathIds_FULL, startRow, this.rowDimensionTree.tree.children, [], this.rowHeaderObjs);
                }
            }
            if (this.rowHeaderTitle) {
                this.sharedVar.seqId = Math.max(this.sharedVar.seqId, this._headerObjects.length);
                const id = ++this.sharedVar.seqId;
                const firstColIds = Array(this._rowHeaderCellFullPathIds_FULL[0]?.length ?? this.rowDimensionTree.tree.size).fill(id);
                this._rowHeaderCellFullPathIds_FULL.unshift(firstColIds);
                const cell = {
                    id,
                    title: typeof this.rowHeaderTitle.title === 'string'
                        ? this.rowHeaderTitle.title
                        : this.rowsDefine.reduce((title, value) => {
                            if (typeof value === 'string') {
                                return title;
                            }
                            return title + (title ? `/${value.title}` : `${value.title}`);
                        }, ''),
                    field: undefined,
                    headerType: this.rowHeaderTitle?.headerType ?? 'text',
                    style: this.rowHeaderTitle?.headerStyle,
                    define: {
                        id,
                        disableHeaderHover: !!this.rowHeaderTitle?.disableHeaderHover,
                        disableHeaderSelect: !!this.rowHeaderTitle?.disableHeaderSelect
                    }
                };
                this.rowHeaderObjs.push(cell);
                this._headerObjects[id] = cell;
            }
        }
        _getRowHeaderTreeExpandedMaxLevelCount() {
            if (this.rowHierarchyType === 'tree') {
                return 1;
            }
            else if (this.rowHierarchyType === 'grid-tree') {
                return this.cornerSetting.titleOnDimension === 'row'
                    ? this.rowDimensionTree.totalLevel
                    : this.indicatorsAsCol
                        ? this.rowDimensionTree.expandedMaxLevel
                        : this.rowDimensionTree.expandedMaxLevel + 1;
            }
            return this.rowDimensionTree.totalLevel;
        }
        _getColumnHeaderTreeExpandedMaxLevelCount() {
            if (this.columnHierarchyType === 'grid-tree') {
                return this.cornerSetting.titleOnDimension === 'column'
                    ? this.columnDimensionTree.totalLevel
                    : this.indicatorsAsCol === false
                        ? this.columnDimensionTree.expandedMaxLevel
                        : this.columnDimensionTree.expandedMaxLevel + 1;
            }
            return this.columnDimensionTree.totalLevel;
        }
        _addHeaders(_headerCellIds, row, header, roots, results) {
            const _this = this;
            function _newRow(row) {
                const newRow = (_headerCellIds[row] = []);
                if (_this.colIndex === 0) {
                    return newRow;
                }
                const prev = _headerCellIds[row - 1];
                for (let col = 0; col < prev?.length; col++) {
                    newRow[col] = prev[col];
                }
                return newRow;
            }
            if (!_headerCellIds[row]) {
                _newRow(row);
            }
            for (let i = 0; i < header.length; i++) {
                const hd = header[i];
                dealHeader(hd, _headerCellIds, results, roots, row, this);
            }
        }
        _addHeadersForTreeMode(_headerCellIds, row, header, roots, totalLevel, show, dimensions, results) {
            const _this = this;
            function _newRow(row) {
                const newRow = (_headerCellIds[row] = []);
                if (_this.colIndex === 0) {
                    return newRow;
                }
                const prev = _headerCellIds[row - 1];
                for (let col = 0; col < prev?.length; col++) {
                    newRow[col] = prev[col];
                }
                return newRow;
            }
            if (!_headerCellIds[row]) {
                _newRow(row);
            }
            for (let i = 0; i < header.length; i++) {
                const hd = header[i];
                dealHeaderForTreeMode(hd, _headerCellIds, results, roots, row, totalLevel, show, dimensions, this);
            }
        }
        _addHeadersForGridTreeMode(_headerCellIds, row, header, roots, totalLevel, expandedMaxLevel, show, dimensions, results, isRowTree) {
            const _this = this;
            function _newRow(row) {
                const newRow = (_headerCellIds[row] = []);
                if (_this.colIndex === 0) {
                    return newRow;
                }
                const prev = _headerCellIds[row - 1];
                for (let col = 0; col < prev?.length; col++) {
                    newRow[col] = prev[col];
                }
                return newRow;
            }
            if (!_headerCellIds[row]) {
                _newRow(row);
            }
            for (let i = 0; i < header.length; i++) {
                const hd = header[i];
                dealHeaderForGridTreeMode(hd, _headerCellIds, results, roots, row, totalLevel, expandedMaxLevel, show, dimensions, isRowTree, this.indicatorsAsCol, this);
            }
        }
        _addCornerHeaders(colDimensionKeys, rowDimensionKeys, dimensions) {
            this._cornerHeaderCellFullPathIds = [];
            const results = [];
            const colLevelCount = this.columnHierarchyType === 'grid-tree'
                ? this._getColumnHeaderTreeExpandedMaxLevelCount() || this.columnHeaderLevelCount
                : this.columnHeaderLevelCount;
            const rowLevelCount = this.rowHierarchyType === 'grid-tree'
                ? this._getRowHeaderTreeExpandedMaxLevelCount() || this.rowHeaderLevelCount
                : this.rowHeaderLevelCount;
            if (colLevelCount === 0 || rowLevelCount === 0) {
                return results;
            }
            if (this.cornerSetting.titleOnDimension === 'all') {
                if (this.indicatorsAsCol) {
                    if (colDimensionKeys) {
                        for (let i = 0; i < colLevelCount; i++) {
                            const dimensionKey = colDimensionKeys[i];
                            const id = ++this.sharedVar.seqId;
                            const dimensionInfo = dimensions.find(dimension => typeof dimension === 'string' ? false : dimension.dimensionKey === dimensionKey);
                            const cell = {
                                id,
                                title: dimensionKey === this.indicatorDimensionKey
                                    ? this.indicatorTitle
                                    : dimensionInfo
                                        ? dimensionInfo.title
                                        : dimensionKey === 'axis'
                                            ? ''
                                            : dimensionKey,
                                field: dimensionKey,
                                style: this.cornerSetting.headerStyle,
                                headerType: this.cornerSetting.headerType ?? 'text',
                                showSort: dimensionInfo?.showSortInCorner,
                                sort: dimensionInfo?.sort,
                                define: {
                                    showSort: dimensionInfo?.showSortInCorner,
                                    sort: dimensionInfo?.sort,
                                    dimensionKey: dimensionKey,
                                    id,
                                    value: dimensionKey,
                                    headerEditor: this.cornerSetting.headerEditor,
                                    disableHeaderHover: !!this.cornerSetting.disableHeaderHover,
                                    disableHeaderSelect: !!this.cornerSetting.disableHeaderSelect
                                },
                                dropDownMenu: dimensionInfo?.cornerDropDownMenu,
                                headerIcon: dimensionInfo?.cornerHeaderIcon,
                                pivotInfo: {
                                    value: dimensionInfo?.title ?? '',
                                    dimensionKey,
                                    isPivotCorner: true
                                },
                                description: dimensionInfo?.cornerDescription
                            };
                            results[id] = cell;
                            this._headerObjects[id] = cell;
                            if (!this._cornerHeaderCellFullPathIds[i]) {
                                this._cornerHeaderCellFullPathIds[i] = [];
                            }
                            for (let r = 0; r < rowLevelCount; r++) {
                                this._cornerHeaderCellFullPathIds[i][r] = id;
                            }
                        }
                    }
                    if (rowDimensionKeys) {
                        for (let i = 0; i < rowLevelCount; i++) {
                            const dimensionKey = rowDimensionKeys[i];
                            const id = ++this.sharedVar.seqId;
                            const dimensionInfo = dimensions.find(dimension => typeof dimension === 'string' ? false : dimension.dimensionKey === dimensionKey);
                            const cell = {
                                id,
                                title: dimensionKey === this.indicatorDimensionKey
                                    ? this.indicatorTitle
                                    : dimensionInfo
                                        ? dimensionInfo.title
                                        : dimensionKey === 'axis'
                                            ? ''
                                            : dimensionKey,
                                field: dimensionKey,
                                style: this.cornerSetting.headerStyle,
                                headerType: this.cornerSetting.headerType ?? 'text',
                                showSort: dimensionInfo?.showSortInCorner,
                                sort: dimensionInfo?.sort,
                                define: {
                                    showSort: dimensionInfo?.showSortInCorner,
                                    sort: dimensionInfo?.sort,
                                    dimensionKey: dimensionKey,
                                    id,
                                    value: dimensionKey,
                                    headerEditor: this.cornerSetting.headerEditor,
                                    disableHeaderHover: !!this.cornerSetting.disableHeaderHover,
                                    disableHeaderSelect: !!this.cornerSetting.disableHeaderSelect
                                },
                                dropDownMenu: dimensionInfo?.cornerDropDownMenu,
                                headerIcon: dimensionInfo?.cornerHeaderIcon,
                                pivotInfo: {
                                    value: dimensionInfo?.title ?? '',
                                    dimensionKey,
                                    isPivotCorner: true
                                },
                                description: dimensionInfo?.cornerDescription
                            };
                            results[id] = cell;
                            this._headerObjects[id] = cell;
                            if (!this._cornerHeaderCellFullPathIds[this._cornerHeaderCellFullPathIds.length - 1]) {
                                this._cornerHeaderCellFullPathIds[this._cornerHeaderCellFullPathIds.length - 1] = [];
                            }
                            this._cornerHeaderCellFullPathIds[this._cornerHeaderCellFullPathIds.length - 1][i] = id;
                        }
                    }
                }
                else {
                    if (rowDimensionKeys) {
                        for (let i = 0; i < rowLevelCount; i++) {
                            const dimensionKey = rowDimensionKeys[i];
                            const id = ++this.sharedVar.seqId;
                            const dimensionInfo = dimensions.find(dimension => typeof dimension === 'string' ? false : dimension.dimensionKey === dimensionKey);
                            const cell = {
                                id,
                                title: dimensionKey === this.indicatorDimensionKey
                                    ? this.indicatorTitle
                                    : dimensionInfo
                                        ? dimensionInfo.title
                                        : dimensionKey === 'axis'
                                            ? ''
                                            : dimensionKey,
                                field: dimensionKey,
                                style: this.cornerSetting.headerStyle,
                                headerType: this.cornerSetting.headerType ?? 'text',
                                showSort: dimensionInfo?.showSortInCorner,
                                sort: dimensionInfo?.sort,
                                define: {
                                    showSort: dimensionInfo?.showSortInCorner,
                                    sort: dimensionInfo?.sort,
                                    dimensionKey: dimensionKey,
                                    id,
                                    value: dimensionKey,
                                    headerEditor: this.cornerSetting.headerEditor,
                                    disableHeaderHover: !!this.cornerSetting.disableHeaderHover,
                                    disableHeaderSelect: !!this.cornerSetting.disableHeaderSelect
                                },
                                dropDownMenu: dimensionInfo?.cornerDropDownMenu,
                                headerIcon: dimensionInfo?.cornerHeaderIcon,
                                pivotInfo: {
                                    value: dimensionInfo?.title ?? '',
                                    dimensionKey,
                                    isPivotCorner: true
                                },
                                description: dimensionInfo?.cornerDescription
                            };
                            results[id] = cell;
                            this._headerObjects[id] = cell;
                            for (let r = 0; r < colLevelCount; r++) {
                                if (!this._cornerHeaderCellFullPathIds[r]) {
                                    this._cornerHeaderCellFullPathIds[r] = [];
                                }
                                this._cornerHeaderCellFullPathIds[r][i] = id;
                            }
                        }
                    }
                    if (colDimensionKeys) {
                        for (let c = 0; c < colLevelCount; c++) {
                            const dimensionKey = colDimensionKeys[c];
                            const id = ++this.sharedVar.seqId;
                            const dimensionInfo = dimensions.find(dimension => typeof dimension === 'string' ? false : dimension.dimensionKey === dimensionKey);
                            const cell = {
                                id,
                                title: dimensionKey === this.indicatorDimensionKey
                                    ? this.indicatorTitle
                                    : dimensionInfo
                                        ? dimensionInfo.title
                                        : dimensionKey === 'axis'
                                            ? ''
                                            : dimensionKey,
                                field: dimensionKey,
                                style: this.cornerSetting.headerStyle,
                                headerType: this.cornerSetting.headerType ?? 'text',
                                showSort: dimensionInfo?.showSortInCorner,
                                sort: dimensionInfo?.sort,
                                define: {
                                    showSort: dimensionInfo?.showSortInCorner,
                                    sort: dimensionInfo?.sort,
                                    dimensionKey: dimensionKey,
                                    id,
                                    value: dimensionKey,
                                    headerEditor: this.cornerSetting.headerEditor,
                                    disableHeaderHover: !!this.cornerSetting.disableHeaderHover,
                                    disableHeaderSelect: !!this.cornerSetting.disableHeaderSelect
                                },
                                dropDownMenu: dimensionInfo?.cornerDropDownMenu,
                                headerIcon: dimensionInfo?.cornerHeaderIcon,
                                pivotInfo: {
                                    value: dimensionInfo?.title ?? '',
                                    dimensionKey,
                                    isPivotCorner: true
                                },
                                description: dimensionInfo?.cornerDescription
                            };
                            results[id] = cell;
                            this._headerObjects[id] = cell;
                            this._cornerHeaderCellFullPathIds[c][this._cornerHeaderCellFullPathIds[c].length - 1] = id;
                        }
                    }
                }
            }
            else if (this.cornerSetting.titleOnDimension === 'row' || this.cornerSetting.titleOnDimension === 'column') {
                const dimensionKeys = this.cornerSetting?.titleOnDimension === 'row' ? rowDimensionKeys : colDimensionKeys;
                if (dimensionKeys) {
                    dimensionKeys.forEach((dimensionKey, key) => {
                        const id = ++this.sharedVar.seqId;
                        const dimensionInfo = dimensions.find(dimension => typeof dimension === 'string' ? false : dimension.dimensionKey === dimensionKey);
                        const cell = {
                            id,
                            title: dimensionKey === this.indicatorDimensionKey
                                ? this.indicatorTitle
                                : dimensionInfo
                                    ? dimensionInfo.title
                                    : dimensionKey === 'axis'
                                        ? ''
                                        : dimensionKey,
                            field: dimensionKey,
                            style: this.cornerSetting.headerStyle,
                            headerType: this.cornerSetting.headerType ?? 'text',
                            showSort: dimensionInfo?.showSortInCorner,
                            sort: dimensionInfo?.sort,
                            define: {
                                showSort: dimensionInfo?.showSortInCorner,
                                sort: dimensionInfo?.sort,
                                dimensionKey: dimensionKey,
                                id,
                                value: dimensionKey,
                                headerCustomRender: this.cornerSetting.customRender,
                                headerCustomLayout: this.cornerSetting.customLayout,
                                headerEditor: this.cornerSetting.headerEditor,
                                disableHeaderHover: !!this.cornerSetting.disableHeaderHover,
                                disableHeaderSelect: !!this.cornerSetting.disableHeaderSelect
                            },
                            dropDownMenu: dimensionInfo?.cornerDropDownMenu,
                            headerIcon: dimensionInfo?.cornerHeaderIcon,
                            pivotInfo: {
                                value: dimensionInfo?.title ?? '',
                                dimensionKey,
                                isPivotCorner: true
                            },
                            description: dimensionInfo?.cornerDescription
                        };
                        results[id] = cell;
                        this._headerObjects[id] = cell;
                        if (this.cornerSetting.titleOnDimension === 'column') {
                            if (!this._cornerHeaderCellFullPathIds[key]) {
                                this._cornerHeaderCellFullPathIds[key] = [];
                            }
                            for (let r = 0; r < this.rowHeaderLevelCount; r++) {
                                this._cornerHeaderCellFullPathIds[key][r] = id;
                            }
                        }
                        else if (this.cornerSetting.titleOnDimension === 'row') {
                            for (let r = 0; r < this.columnHeaderLevelCount; r++) {
                                if (!this._cornerHeaderCellFullPathIds[r]) {
                                    this._cornerHeaderCellFullPathIds[r] = [];
                                }
                                this._cornerHeaderCellFullPathIds[r][key] = id;
                            }
                        }
                    });
                }
            }
            else {
                const id = ++this.sharedVar.seqId;
                const cell = {
                    id,
                    title: '',
                    field: '维度名称',
                    style: this.cornerSetting.headerStyle,
                    headerType: this.cornerSetting.headerType ?? 'text',
                    define: {
                        dimensionKey: '维度名称',
                        id,
                        headerCustomRender: this.cornerSetting.customRender,
                        headerCustomLayout: this.cornerSetting.customLayout,
                        disableHeaderHover: !!this.cornerSetting.disableHeaderHover,
                        disableHeaderSelect: !!this.cornerSetting.disableHeaderSelect
                    }
                };
                results[id] = cell;
                this._headerObjects[id] = cell;
                for (let r = 0; r < this.columnHeaderLevelCount; r++) {
                    for (let j = 0; j < this.rowHeaderLevelCount; j++) {
                        if (!this._cornerHeaderCellFullPathIds[r]) {
                            this._cornerHeaderCellFullPathIds[r] = [];
                        }
                        this._cornerHeaderCellFullPathIds[r][j] = id;
                    }
                }
            }
            return results;
        }
        generateExtensionRowTree() {
            this.extensionRows.forEach((extensionRow, indexP) => {
                const old_rowHeaderCellIds = this._rowHeaderCellFullPathIds_FULL;
                this._rowHeaderCellFullPathIds_FULL = [];
                old_rowHeaderCellIds.forEach((row_ids, index) => {
                    const key = row_ids[row_ids.length - 1];
                    this.colIndex = 0;
                    let tree;
                    if (typeof extensionRow.rowTree === 'function') {
                        const fullCellIds = this.findFullCellIds(row_ids);
                        tree = extensionRow.rowTree(fullCellIds.map((id) => {
                            return { dimensionKey: this._headerObjects[id].field, value: this._headerObjects[id].title };
                        }));
                    }
                    else {
                        tree = cloneDeep$1(extensionRow.rowTree);
                    }
                    let rowExtensionDimensionTree;
                    if (this._rowHeaderExtensionTree[key]) {
                        this._rowHeaderExtensionTree[key].reset(this._rowHeaderExtensionTree[key].tree.children);
                        rowExtensionDimensionTree = this._rowHeaderExtensionTree[key];
                    }
                    else {
                        rowExtensionDimensionTree = new DimensionTree(tree ?? [], this.sharedVar, this.rowHierarchyType, undefined);
                        this._rowHeaderExtensionTree[key] = rowExtensionDimensionTree;
                    }
                    const extensionRowTreeHeaderIds = [];
                    this._addHeadersForTreeMode(extensionRowTreeHeaderIds, 0, rowExtensionDimensionTree.tree.children, [], rowExtensionDimensionTree.totalLevel, true, extensionRow.rows, this.rowHeaderObjs);
                    for (let i = 0; i < extensionRowTreeHeaderIds[0].length; i++) {
                        this._rowHeaderCellFullPathIds_FULL.push(row_ids.concat(extensionRowTreeHeaderIds[0][i]));
                    }
                });
            });
        }
        setColumnWidths() {
            const returnWidths = new Array(this.colCount).fill(undefined);
            if (this.leftRowSeriesNumberColumnCount) {
                returnWidths[0] = this.leftRowSeriesNumberColumn[0];
            }
            if (this.showHeader && this.showRowHeader) {
                if (this.rowHeaderTitle) {
                    returnWidths[0 + this.leftRowSeriesNumberColumnCount] = {};
                }
                if (this.rowHierarchyType === 'tree') {
                    const mainDimensionFirstRowKey = this.rowDimensionKeys[0];
                    if (mainDimensionFirstRowKey) {
                        const dimension = this.rowsDefine?.find(dimension => typeof dimension === 'string' ? false : dimension.dimensionKey === mainDimensionFirstRowKey);
                        dimension &&
                            (returnWidths[0 + (this.rowHeaderTitle ? 1 : 0) + this.leftRowSeriesNumberColumnCount] = {
                                width: dimension.width,
                                minWidth: dimension.minWidth,
                                maxWidth: dimension.maxWidth
                            });
                    }
                    this._extensionRowDimensionKeys?.forEach((extensionRowDimensionKeys, index) => {
                        const curDimensionFirstRowKey = extensionRowDimensionKeys[0];
                        if (curDimensionFirstRowKey) {
                            const dimension = this.extensionRows[index].rows?.find((dimension) => typeof dimension === 'string' ? false : dimension.dimensionKey === curDimensionFirstRowKey);
                            dimension &&
                                (returnWidths[index + 1 + (this.rowHeaderTitle ? 1 : 0) + this.leftRowSeriesNumberColumnCount] = {
                                    width: dimension.width,
                                    minWidth: dimension.minWidth,
                                    maxWidth: dimension.maxWidth
                                });
                        }
                    });
                }
                else {
                    const rowDimensionKeys = this.rowDimensionTree.totalLevel > 0
                        ? this.rowDimensionTree.dimensionKeysIncludeVirtual.valueArr()
                        : this.rowsDefine.map(dimension => {
                            if (typeof dimension === 'string') {
                                return dimension;
                            }
                            return dimension.dimensionKey;
                        });
                    rowDimensionKeys.forEach((objKey, index) => {
                        const dimension = this.rowsDefine?.find(dimension => typeof dimension === 'string' ? false : dimension.dimensionKey === objKey);
                        dimension &&
                            (returnWidths[index + (this.rowHeaderTitle ? 1 : 0) + this.leftRowSeriesNumberColumnCount] = {
                                width: dimension.width,
                                minWidth: dimension.minWidth,
                                maxWidth: dimension.maxWidth
                            });
                    });
                }
            }
            if (this.indicatorsAsCol) {
                for (let i = this.rowHeaderLevelCount + this.leftRowSeriesNumberColumnCount; i < this.colCount; i++) {
                    const cellDefine = this.getBody(i, this.columnHeaderLevelCount);
                    returnWidths[i] = {
                        width: cellDefine?.width,
                        minWidth: cellDefine?.minWidth,
                        maxWidth: cellDefine?.maxWidth
                    };
                }
            }
            else {
                let width = 0;
                let maxWidth;
                let minWidth;
                let isAuto;
                this._indicators?.forEach((obj, index) => {
                    if (typeof obj.width === 'number') {
                        width = Math.max(obj.width, width);
                    }
                    else if (obj.width === 'auto') {
                        isAuto = true;
                    }
                    if (typeof obj.minWidth === 'number') {
                        minWidth = Math.max(obj.minWidth, minWidth ?? 0);
                    }
                    if (typeof obj.maxWidth === 'number') {
                        maxWidth = Math.min(obj.maxWidth, maxWidth ?? Number.MAX_VALUE);
                    }
                });
                width = width > 0 ? width : isAuto ? 'auto' : undefined;
                returnWidths.fill({ width, minWidth, maxWidth }, this.rowHeaderLevelCount + this.leftRowSeriesNumberColumnCount, this.colCount - this.rightFrozenColCount);
            }
            this._columnWidths = returnWidths;
        }
        get columnWidths() {
            return this._columnWidths;
        }
        getColumnWidthDefined(col) {
            return this._columnWidths[col];
        }
        get showHeader() {
            return this._showHeader;
        }
        set showHeader(_showHeader) {
            this._showHeader = _showHeader;
        }
        get showColumnHeader() {
            return this._showColumnHeader;
        }
        set showColumnHeader(_showColumnHeader) {
            this._showColumnHeader = _showColumnHeader;
        }
        get showRowHeader() {
            return this._showRowHeader;
        }
        set showRowHeader(_showRowHeader) {
            this._showRowHeader = _showRowHeader;
        }
        get columnHeaderTitle() {
            return this._columnHeaderTitle;
        }
        set columnHeaderTitle(_columnHeaderTitle) {
            this._columnHeaderTitle = _columnHeaderTitle;
        }
        get rowHeaderTitle() {
            return this._rowHeaderTitle;
        }
        set rowHeaderTitle(_rowHeaderTitle) {
            this._rowHeaderTitle = _rowHeaderTitle;
        }
        getHeaderFieldKey(col, row) {
            return undefined;
        }
        getCellLocation(col, row) {
            if (this.isCornerHeader(col, row)) {
                return 'cornerHeader';
            }
            else if (this.isColumnHeader(col, row)) {
                return 'columnHeader';
            }
            else if (this.isRowHeader(col, row)) {
                return 'rowHeader';
            }
            return 'body';
        }
        isHeader(col, row) {
            if (col >= this.leftRowSeriesNumberColumnCount &&
                col < this.rowHeaderLevelCount + this.leftRowSeriesNumberColumnCount) {
                return true;
            }
            if (row >= 0 && row < this.columnHeaderLevelCount) {
                return true;
            }
            if (col >= this.colCount - this.rightHeaderColCount) {
                return true;
            }
            if (row >= this.rowCount - this.bottomHeaderRowCount) {
                return true;
            }
            return false;
        }
        isCornerHeader(col, row) {
            if (col >= 0 &&
                col < this.rowHeaderLevelCount + this.leftRowSeriesNumberColumnCount &&
                row >= 0 &&
                row < this.columnHeaderLevelCount) {
                return true;
            }
            return false;
        }
        isColumnHeader(col, row) {
            if (col >= this.rowHeaderLevelCount + this.leftRowSeriesNumberColumnCount &&
                row >= 0 &&
                row < this.columnHeaderLevelCount) {
                return true;
            }
            return false;
        }
        isRowHeader(col, row) {
            if (col >= this.leftRowSeriesNumberColumnCount &&
                col < this.rowHeaderLevelCount + this.leftRowSeriesNumberColumnCount &&
                row >= this.columnHeaderLevelCount) {
                return true;
            }
            return false;
        }
        isFrozen(col, row) {
            return (this.isFrozenColumn(col) ||
                this.isRightFrozenColumn(col) ||
                this.isBottomFrozenRow(row) ||
                this.isFrozenRow(row) ||
                this.isSeriesNumberInBody(col, row) ||
                this.isSeriesNumberInHeader(col, row));
        }
        isFrozenColumn(col, row) {
            if (isValid$3(row)) {
                if (col >= 0 &&
                    col < this.frozenColCount &&
                    row >= this.frozenRowCount &&
                    row < this.rowCount - this.bottomFrozenRowCount) {
                    return true;
                }
            }
            else {
                if (this.frozenColCount > 0 && col >= 0 && col < this.frozenColCount) {
                    return true;
                }
            }
            return false;
        }
        isRightFrozenColumn(col, row) {
            if (isValid$3(row)) {
                if (col >= this.colCount - this.rightFrozenColCount &&
                    row >= this.frozenRowCount &&
                    row < this.rowCount - this.bottomFrozenRowCount) {
                    return true;
                }
            }
            else {
                if (this.rightFrozenColCount > 0 && col >= this.colCount - this.rightFrozenColCount) {
                    return true;
                }
            }
            return false;
        }
        isFrozenRow(col, row) {
            if (isValid$3(row)) {
                if (row >= 0 &&
                    row < this.frozenRowCount &&
                    col >= this.frozenColCount &&
                    col < this.colCount - this.rightFrozenColCount) {
                    return true;
                }
            }
            else {
                row = col;
                if (this.frozenRowCount > 0 && row >= 0 && row < this.frozenRowCount) {
                    return true;
                }
            }
            return false;
        }
        isBottomFrozenRow(col, row) {
            if (isValid$3(row)) {
                if (row >= this.rowCount - this.bottomFrozenRowCount &&
                    col >= this.frozenColCount &&
                    col < this.colCount - this.rightFrozenColCount) {
                    return true;
                }
            }
            else {
                row = col;
                if (this.bottomFrozenRowCount > 0 && row >= this.rowCount - this.bottomFrozenRowCount) {
                    return true;
                }
            }
            return false;
        }
        isLeftTopCorner(col, row) {
            if (col >= 0 && col < this.frozenColCount && row >= 0 && row < this.frozenRowCount) {
                return true;
            }
            return false;
        }
        isLeftBottomCorner(col, row) {
            if (col >= 0 && col < this.frozenColCount && row >= this.rowCount - this.bottomFrozenRowCount) {
                return true;
            }
            return false;
        }
        isRightTopCorner(col, row) {
            if (col >= this.colCount - this.rightFrozenColCount && row >= 0 && row < this.frozenRowCount) {
                return true;
            }
            return false;
        }
        isRightBottomCorner(col, row) {
            if (col >= this.colCount - this.rightFrozenColCount && row >= this.rowCount - this.bottomFrozenRowCount) {
                return true;
            }
            return false;
        }
        getColumnHeaderRange() {
            return {
                start: { col: this.rowHeaderLevelCount, row: 0 },
                end: { col: this.colCount - 1, row: this.columnHeaderLevelCount - 1 }
            };
        }
        getRowHeaderRange() {
            return {
                start: { col: 0, row: this.columnHeaderLevelCount },
                end: { col: this.rowHeaderLevelCount - 1, row: this.rowCount - 1 }
            };
        }
        getCornerHeaderRange() {
            return {
                start: { col: 0, row: 0 },
                end: { col: this.rowHeaderLevelCount - 1, row: this.columnHeaderLevelCount - 1 }
            };
        }
        getBodyRange() {
            return {
                start: { col: this.rowHeaderLevelCount, row: this.columnHeaderLevelCount },
                end: { col: this.colCount - 1, row: this.rowCount - 1 }
            };
        }
        resetCellIds() {
        }
        get frozenColCount() {
            if (this._table.internalProps.frozenColCount) {
                if (this.colCount > this._table.internalProps.frozenColCount) {
                    return this._table.internalProps.frozenColCount;
                }
                return this.colCount;
            }
            return 0;
        }
        get frozenRowCount() {
            if (this._table.internalProps.frozenRowCount) {
                if (this.rowCount >= this._table.internalProps.frozenRowCount) {
                    return this._table.internalProps.frozenRowCount;
                }
                return this.rowCount;
            }
            return 0;
        }
        get headerLevelCount() {
            return this.columnHeaderLevelCount;
        }
        resetColumnHeaderLevelCount() {
            if (this.showHeader && this.showColumnHeader) {
                if (this._table.isPivotChart() &&
                    this.indicatorsAsCol &&
                    !this.dataset?.colKeys?.length &&
                    this.columnDimensionTree?.tree?.level === 0 &&
                    !this.hasTwoIndicatorAxes) {
                    this.columnHeaderLevelCount = 0;
                    return;
                }
                let count = this._getColumnHeaderTreeExpandedMaxLevelCount();
                if (this.indicatorsAsCol &&
                    this.hideIndicatorName &&
                    this.colDimensionKeys[this.colDimensionKeys.length - 1] === this.indicatorDimensionKey) {
                    count--;
                }
                if (count === 0 &&
                    this.dataset &&
                    !this.dataset.customColTree?.length) {
                    if ((this.cornerSetting.titleOnDimension === 'row' || this.cornerSetting.titleOnDimension === 'all') &&
                        this.cornerSetting.forceShowHeader) {
                        count = 1;
                    }
                    else if (!this._table.isPivotChart() &&
                        (this.dataset.records?.length ?? 0) === 0 &&
                        (this.cornerSetting.titleOnDimension === 'column' || this.cornerSetting.titleOnDimension === 'all')) {
                        count = this.columnsDefine.length ?? 0;
                    }
                }
                else if (this.dataset &&
                    !this._table.isPivotChart() &&
                    (this.dataset.records?.length ?? 0) === 0 &&
                    !this.dataset.customColTree) {
                    if (this.cornerSetting.titleOnDimension === 'column' || this.cornerSetting.titleOnDimension === 'all') {
                        count = this.columnsDefine.length ?? 0;
                        if (!this.hideIndicatorName && this.indicatorsAsCol) {
                            count++;
                        }
                    }
                }
                if (this.columnHeaderTitle) {
                    count += 1;
                }
                if (this._table.isPivotChart() &&
                    this.indicatorsAsCol &&
                    !this.hasTwoIndicatorAxes &&
                    checkHasCartesianChart(this.indicatorsDefine)) {
                    count -= 1;
                }
                this.columnHeaderLevelCount = count;
                return;
            }
            this.columnHeaderLevelCount = !this.indicatorsAsCol ? 0 : this.hideIndicatorName ? 0 : 1;
            return;
        }
        resetRowHeaderLevelCount() {
            if (this.showHeader && this.showRowHeader) {
                if (this.rowHierarchyType === 'tree') {
                    const extensionRowCount = this.extensionRows?.length ?? 0;
                    if (this.rowHeaderTitle) {
                        this.rowHeaderLevelCount = 1 + (this.rowDimensionTree.totalLevel ? 1 : 0) + extensionRowCount;
                        return;
                    }
                    this.rowHeaderLevelCount = (this.rowDimensionTree.totalLevel ? 1 : 0) + extensionRowCount;
                    return;
                }
                const rowLevelCount = this._getRowHeaderTreeExpandedMaxLevelCount();
                let count = rowLevelCount;
                if (count === 0 &&
                    this.dataset &&
                    !this.dataset.customRowTree?.length) {
                    if ((this.cornerSetting.titleOnDimension === 'column' || this.cornerSetting.titleOnDimension === 'all') &&
                        this.cornerSetting.forceShowHeader) {
                        count = 1;
                    }
                    else if (!this._table.isPivotChart() &&
                        (this.dataset.records?.length ?? 0) === 0 &&
                        (this.cornerSetting.titleOnDimension === 'row' || this.cornerSetting.titleOnDimension === 'all')) {
                        count = this.rowsDefine.length ?? 0;
                    }
                }
                else if (this.dataset &&
                    !this._table.isPivotChart() &&
                    (this.dataset.records?.length ?? 0) === 0 &&
                    !this.dataset.customRowTree) {
                    if (this.cornerSetting.titleOnDimension === 'row' || this.cornerSetting.titleOnDimension === 'all') {
                        count = this.rowsDefine.length;
                        if (!this.hideIndicatorName && !this.indicatorsAsCol) {
                            count++;
                        }
                    }
                }
                if (!this.indicatorsAsCol &&
                    this.hideIndicatorName &&
                    this.rowDimensionKeys[this.rowDimensionKeys.length - 1] === this.indicatorDimensionKey) {
                    count = rowLevelCount - 1;
                }
                if (this.rowHeaderTitle) {
                    count += 1;
                }
                this.rowHeaderLevelCount = count;
                return;
            }
            this.rowHeaderLevelCount = this.indicatorsAsCol ? 0 : this.hideIndicatorName ? 0 : 1;
            return;
        }
        get columnHeaderLevelCount() {
            return this._columnHeaderLevelCount;
        }
        set columnHeaderLevelCount(count) {
            this._columnHeaderLevelCount = count;
        }
        get rowHeaderLevelCount() {
            return this._rowHeaderLevelCount;
        }
        set rowHeaderLevelCount(count) {
            this._rowHeaderLevelCount = count;
        }
        get colCount() {
            let bodyColCount;
            if (this._getColumnHeaderTreeExpandedMaxLevelCount() > 0 ||
                this._table.isPivotChart() ||
                this.dataset.records?.length > 0 ||
                (this.dataset.records && !Array.isArray(this.dataset.records))) {
                bodyColCount =
                    (this._columnHeaderCellIds[0]?.length ?? this.columnDimensionTree.tree.size) ||
                        (this._indicators?.length > 0 ? 1 : 0);
            }
            else {
                bodyColCount = 0;
            }
            return bodyColCount + this.rowHeaderLevelCount + this.rightHeaderColCount + this.leftRowSeriesNumberColumnCount;
        }
        get rowCount() {
            return (((this._table.records || this.dataset.records
                ? Array.isArray(this._table.records)
                    ? this._table.records.length > 0
                    : true
                : false) &&
                this._indicators?.length > 0 &&
                !this._rowHeaderCellIds?.length
                ? 1
                : this._rowHeaderCellIds?.length ?? 0) +
                this.columnHeaderLevelCount +
                this.bottomHeaderRowCount);
        }
        get bodyRowSpanCount() {
            return this.rowDimensionTree.tree.size;
        }
        get bottomFrozenRowCount() {
            if (!this._table.isPivotChart()) {
                if (this._table.internalProps.bottomFrozenRowCount) {
                    if (this.rowCount - this.headerLevelCount >= this._table.internalProps.bottomFrozenRowCount) {
                        return this._table.internalProps.bottomFrozenRowCount;
                    }
                    return this.rowCount - this.headerLevelCount;
                }
                return 0;
            }
            if (this.indicatorKeys.length >= 1 && checkHasCartesianChart(this.indicatorsDefine)) {
                const axisOption = this._table.pivotChartAxes.find(axisOption => {
                    return axisOption.orient === 'bottom';
                });
                if (axisOption?.visible === false) {
                    return 0;
                }
                if (this.indicatorsAsCol) {
                    return 1;
                }
                return 1;
            }
            return 0;
        }
        get rightFrozenColCount() {
            if (!this._table.isPivotChart()) {
                if (this._table.internalProps.rightFrozenColCount) {
                    if (this.colCount - this.rowHeaderLevelCount >= this._table.internalProps.rightFrozenColCount) {
                        return this._table.internalProps.rightFrozenColCount;
                    }
                    return this.colCount - this.rowHeaderLevelCount;
                }
                return 0;
            }
            const axisOption = this._table.pivotChartAxes.find(axisOption => {
                return axisOption.orient === 'right';
            });
            if (axisOption?.visible === false) {
                return 0;
            }
            if (this.indicatorsAsCol) {
                return 0;
            }
            else if (this.hasTwoIndicatorAxes) {
                return 1;
            }
            return 0;
        }
        get bodyRowCount() {
            return this.rowCount - this.bottomFrozenRowCount - this.headerLevelCount;
        }
        get bodyColCount() {
            return this.colCount - this.rightFrozenColCount - this.rowHeaderLevelCount;
        }
        get headerObjects() {
            return this._headerObjects;
        }
        get columnObjects() {
            return this._indicators;
        }
        getCellId(col, row) {
            if (row >= 0 && col >= 0) {
                if (this.isSeriesNumber(col, row)) {
                    return '';
                }
                else if (this.isCornerHeader(col, row)) {
                    return this._cornerHeaderCellIds[row]?.[col - this.leftRowSeriesNumberColumnCount];
                }
                else if (this.isColumnHeader(col, row)) {
                    return this._columnHeaderCellIds[row]?.[col - this.rowHeaderLevelCount - this.leftRowSeriesNumberColumnCount];
                }
                else if (this.isRowHeader(col, row)) {
                    return this._rowHeaderCellIds[row - this.columnHeaderLevelCount]?.[col - this.leftRowSeriesNumberColumnCount];
                }
                else if (this.isRightFrozenColumn(col, row)) {
                    return this._rowHeaderCellIds[row - this.columnHeaderLevelCount]?.[this.rowHeaderLevelCount - 1];
                }
                else if (this.isBottomFrozenRow(col, row)) {
                    return this._columnHeaderCellIds[this.columnHeaderLevelCount - 1]?.[col - this.rowHeaderLevelCount - this.leftRowSeriesNumberColumnCount];
                }
            }
            return undefined;
        }
        getHeader(col, row) {
            if (this.isSeriesNumberInHeader(col, row)) {
                return this.getSeriesNumberHeader(col, row);
            }
            const id = this.getCellId(col, row);
            return this._headerObjectMap[id] ?? { id: undefined, field: '', headerType: 'text', define: undefined };
        }
        getHeaderField(col, row) {
            const id = this.getCellId(col, row);
            return this._headerObjectMap[id]?.field || this.getBody(col, row)?.field;
        }
        getHeaderCellAdressById(id) {
            for (let i = 0; i < this._columnHeaderCellIds.length; i++) {
                const row = this._columnHeaderCellIds[i];
                for (let j = 0; j < row.length; j++) {
                    if (row[j] === id) {
                        return { col: j + this._table.frozenColCount, row: i };
                    }
                }
            }
            for (let i = 0; i < this._rowHeaderCellIds.length; i++) {
                const row = this._rowHeaderCellIds[i];
                for (let j = 0; j < row.length; j++) {
                    if (row[j] === id) {
                        return { col: j, row: i + this._table.frozenRowCount };
                    }
                }
            }
            for (let i = 0; i < this._cornerHeaderCellIds.length; i++) {
                const row = this._cornerHeaderCellIds[i];
                for (let j = 0; j < row.length; j++) {
                    if (row[j] === id) {
                        return { col: j, row: i };
                    }
                }
            }
            return undefined;
        }
        getHeaderCellAddressByField(field) {
            const hd = this.headerObjects.find((col) => col && col.field === field);
            return hd && this.getHeaderCellAdressById(hd.id);
        }
        getBody(_col, _row) {
            const cache = this.getBodyWidthCache(_col, _row);
            if (cache) {
                return cache;
            }
            if (this.isSeriesNumber(_col, _row)) {
                const body = this.getSeriesNumberBody(_col, _row);
                this.setBodyWidthCache(_col, _row, body);
                return body;
            }
            const paths = this.getCellHeaderPaths(_col, _row);
            if (this.indicatorsAsCol) {
                const indicatorKey = paths.colHeaderPaths?.find(colPath => colPath.indicatorKey)?.indicatorKey;
                const body = isValid$3(indicatorKey)
                    ? this._indicators?.find(indicator => indicator.indicatorKey === indicatorKey) ??
                        this._indicators[0] ?? {
                        id: '',
                        field: undefined,
                        indicatorKey: undefined,
                        cellType: 'text',
                        define: undefined
                    }
                    : {
                        id: '',
                        field: undefined,
                        indicatorKey: undefined,
                        cellType: 'text',
                        define: undefined
                    };
                this.setBodyWidthCache(_col, _row, body);
                return body;
            }
            const indicatorKey = paths.rowHeaderPaths?.find(rowPath => rowPath.indicatorKey)?.indicatorKey;
            const body = isValid$3(indicatorKey)
                ? this._indicators?.find(indicator => indicator.indicatorKey === indicatorKey) ??
                    this._indicators[0] ?? {
                    id: '',
                    field: undefined,
                    indicatorKey: undefined,
                    cellType: 'text',
                    define: undefined
                }
                : {
                    id: '',
                    field: undefined,
                    indicatorKey: undefined,
                    cellType: 'text',
                    define: undefined
                };
            this.setBodyWidthCache(_col, _row, body);
            return body;
        }
        getCellRange(col, row) {
            const result = { start: { col, row }, end: { col, row } };
            if (!this.isHeader(col, row) || col === -1 || row === -1) {
                return result;
            }
            if (this.isRightFrozenColumn(col, row) || this.isBottomFrozenRow(col, row)) {
                return result;
            }
            if (this._table.isPivotChart()) {
                if (this.isLeftBottomCorner(col, row)) {
                    return {
                        start: {
                            col: 0,
                            row: this.rowCount - this.bottomFrozenRowCount
                        },
                        end: {
                            col: this.frozenColCount - 1,
                            row: this.rowCount - 1
                        }
                    };
                }
                else if (this.isRightTopCorner(col, row)) {
                    return {
                        start: {
                            col: this.colCount - this.rightFrozenColCount,
                            row: 0
                        },
                        end: {
                            col: this.colCount - 1,
                            row: this.frozenRowCount - 1
                        }
                    };
                }
                else if (this.isRightBottomCorner(col, row)) {
                    return {
                        start: {
                            col: this.colCount - this.rightFrozenColCount,
                            row: this.rowCount - this.bottomFrozenRowCount
                        },
                        end: {
                            col: this.colCount - 1,
                            row: this.rowCount - 1
                        }
                    };
                }
            }
            for (let i = 0; i < this._largeCellRangeCache.length; i++) {
                const range = this._largeCellRangeCache[i];
                if (col >= range.start.col && col <= range.end.col && row >= range.start.row && row <= range.end.row) {
                    return range;
                }
            }
            if (this.isHeader(col, row) && col !== -1 && row !== -1) {
                const id = this.getCellId(col, row);
                for (let c = col - 1; c >= 0; c--) {
                    if (id !== this.getCellId(c, row)) {
                        break;
                    }
                    result.start.col = c;
                }
                for (let c = col + 1; c < (this.colCount ?? 0); c++) {
                    if (id !== this.getCellId(c, row)) {
                        break;
                    }
                    result.end.col = c;
                }
                for (let r = row - 1; r >= 0; r--) {
                    if (id !== this.getCellId(col, r)) {
                        break;
                    }
                    result.start.row = r;
                }
                for (let r = row + 1; r < (this.rowCount ?? 0); r++) {
                    if (id !== this.getCellId(col, r) ||
                        (this.isSeriesNumberInHeader(col, row) && r >= this.columnHeaderLevelCount)) {
                        break;
                    }
                    result.end.row = r;
                }
            }
            if (result.end.col - result.start.col > 100 || result.end.row - result.start.row > 100) {
                this._largeCellRangeCache.push(result);
            }
            return result;
        }
        isCellRangeEqual(col, row, targetCol, targetRow) {
            const range1 = this.getCellRange(col, row);
            const range2 = this.getCellRange(targetCol, targetRow);
            return (range1.start.col === range2.start.col &&
                range1.end.col === range2.end.col &&
                range1.start.row === range2.start.row &&
                range1.end.row === range2.end.row);
        }
        getBodyIndexByRow(row) {
            if (row < this.columnHeaderLevelCount) {
                return -1;
            }
            else if (row >= this.rowCount - this.bottomHeaderRowCount) {
                return -1;
            }
            return row - this.columnHeaderLevelCount;
        }
        get bottomHeaderRowCount() {
            if (this._table.isPivotChart()) {
                return this.bottomFrozenRowCount;
            }
            return 0;
        }
        get rightHeaderColCount() {
            if (this._table.isPivotChart()) {
                return this.rightFrozenColCount;
            }
            return 0;
        }
        getBodyIndexByCol(col) {
            if (col < this.rowHeaderLevelCount + this.leftRowSeriesNumberColumnCount) {
                return -1;
            }
            else if (col >= this.colCount - this.rightHeaderColCount) {
                return -1;
            }
            return col - this.rowHeaderLevelCount - this.leftRowSeriesNumberColumnCount;
        }
        getRecordStartRowByRecordIndex(index) {
            return this.columnHeaderLevelCount + index;
        }
        getRecordShowIndexByCell(col, row) {
            return undefined;
        }
        getCellHeaderPathsWithTreeNode(col, row) {
            for (let i = 0; i < this._largeCellRangeCache.length; i++) {
                const range = this._largeCellRangeCache[i];
                if (col >= range.start.col && col <= range.end.col && row >= range.start.row && row <= range.end.row) {
                    break;
                }
            }
            let colPath = this.getColHeaderPathCache(col, row);
            let rowPath = this.getRowHeaderPathCache(col, row);
            const recordCol = this.getBodyIndexByCol(col);
            const recordRow = this.getBodyIndexByRow(row) + this.currentPageStartIndex;
            if (!colPath && row >= 0 && recordCol >= 0) {
                colPath = [];
                if (this.columnHierarchyType === 'grid-tree') {
                    const col_pathIds = [];
                    this._columnHeaderCellFullPathIds.map(arr => {
                        col_pathIds.push(arr[recordCol]);
                    });
                    const findedRowPath = this.getTreePathByCellIds(col_pathIds);
                    colPath.push(...findedRowPath);
                }
                else {
                    colPath = this.columnDimensionTree.getTreePath(recordCol, this.showHeader && this.showColumnHeader
                        ? row - (this.columnHeaderTitle ? 1 : 0)
                        : this.columnDimensionTree.totalLevel);
                }
                this.setColHeaderPathCache(col, row, colPath);
            }
            if (!rowPath && col >= 0 && recordRow >= 0) {
                rowPath = [];
                if (this.rowHierarchyType === 'tree') {
                    const row_pathIds = this._rowHeaderCellFullPathIds[recordRow];
                    let findTree = this.rowDimensionTree;
                    let level = 0;
                    while (findTree && row_pathIds) {
                        const pathIds = [];
                        let cellId = row_pathIds[level];
                        pathIds.push(cellId);
                        while (true) {
                            const hd = this._headerObjectMap[cellId];
                            if (hd?.parentCellId) {
                                pathIds.unshift(hd.parentCellId);
                                cellId = hd.parentCellId;
                            }
                            else {
                                break;
                            }
                        }
                        const findedRowPath = this.getTreePathByCellIds(pathIds);
                        rowPath.push(...findedRowPath);
                        findTree = this._rowHeaderExtensionTree[row_pathIds[level]];
                        level++;
                    }
                }
                else if (this.rowHierarchyType === 'grid-tree') {
                    const row_pathIds = this._rowHeaderCellFullPathIds[recordRow];
                    const findedRowPath = this.getTreePathByCellIds(row_pathIds);
                    rowPath.push(...findedRowPath);
                }
                else {
                    rowPath = this.rowDimensionTree.getTreePath(recordRow, this.showHeader && this.showRowHeader
                        ? col - (this.rowHeaderTitle ? 1 : 0) - this.leftRowSeriesNumberColumnCount
                        : this.rowDimensionTree.totalLevel);
                }
                this.setRowHeaderPathCache(col, row, rowPath);
            }
            const p = { colHeaderPaths: colPath, rowHeaderPaths: rowPath, cellLocation: this.getCellLocation(col, row) };
            return p;
        }
        getTreePathByCellIds(row_pathIds) {
            const paths = [];
            for (let i = 0; i < row_pathIds.length; i++) {
                const id = row_pathIds[i];
                if (i > 0 && id === row_pathIds[i - 1]) {
                    continue;
                }
                const hd = this._headerObjects[id];
                if (hd?.define) {
                    paths.push(hd.define);
                }
            }
            return paths;
        }
        getCellHeaderPaths(col, row) {
            const headerPathsWidthNode = this.getCellHeaderPathsWithTreeNode(col, row);
            const headerPaths = {
                colHeaderPaths: [],
                rowHeaderPaths: [],
                cellLocation: headerPathsWidthNode.cellLocation
            };
            headerPathsWidthNode.colHeaderPaths?.forEach((colHeader) => {
                const colHeaderPath = {};
                colHeaderPath.dimensionKey = colHeader.dimensionKey;
                colHeaderPath.indicatorKey = colHeader.indicatorKey;
                colHeaderPath.value = colHeader.value ?? this.getIndicatorInfoByIndicatorKey(colHeader.indicatorKey)?.title ?? '';
                colHeaderPath.virtual = colHeader.virtual;
                colHeaderPath.role = colHeader.role;
                headerPaths.colHeaderPaths.push(colHeaderPath);
            });
            headerPathsWidthNode.rowHeaderPaths?.forEach((rowHeader) => {
                if (rowHeader.dimensionKey !== 'axis') {
                    const rowHeaderPath = {};
                    rowHeaderPath.dimensionKey = rowHeader.dimensionKey;
                    rowHeaderPath.indicatorKey = rowHeader.indicatorKey;
                    rowHeaderPath.value =
                        rowHeader.value ?? this.getIndicatorInfoByIndicatorKey(rowHeader.indicatorKey)?.title ?? '';
                    rowHeaderPath.virtual = rowHeader.virtual;
                    rowHeaderPath.role = rowHeader.role;
                    headerPaths.rowHeaderPaths.push(rowHeaderPath);
                }
            });
            return headerPaths;
        }
        getIndicatorInfoByIndicatorKey(indicatorKey) {
            const indicatorInfo = this.indicatorsDefine?.find(indicator => {
                if (typeof indicator === 'string') {
                    return false;
                }
                if (indicatorKey) {
                    return indicator.indicatorKey === indicatorKey;
                }
                return false;
            });
            return indicatorInfo;
        }
        findFullCellIds(row_pathIds) {
            const pathIds = [];
            for (let level = 0; level < row_pathIds.length; level++) {
                let cellId = row_pathIds[level];
                pathIds.push(cellId);
                while (true) {
                    const hd = this._headerObjectMap[cellId];
                    if (hd?.parentCellId) {
                        pathIds.unshift(hd.parentCellId);
                        cellId = hd.parentCellId;
                    }
                    else {
                        break;
                    }
                }
            }
            return pathIds;
        }
        getHeaderDimension(col, row) {
            if (this.isHeader(col, row)) {
                const header = this.getHeader(col, row);
                const dimension = this.rowsDefine?.find(dimension => typeof dimension !== 'string' && dimension.dimensionKey === header.field) ??
                    this.columnsDefine?.find(dimension => typeof dimension !== 'string' && dimension.dimensionKey === header.field);
                return dimension;
            }
            return undefined;
        }
        isColumnIndicatorHeader(col, row) {
            if (this._indicatorShowType === 'column' &&
                row === this.columnHeaderLevelCount - 1 &&
                col >= this.rowHeaderLevelCount) {
                return true;
            }
            return false;
        }
        isRowIndicatorHeader(col, row) {
            if (this._indicatorShowType === 'row' &&
                col === this.rowHeaderLevelCount - 1 &&
                row >= this.columnHeaderLevelCount) {
                return true;
            }
            return false;
        }
        isIndicatorHeader(col, row) {
            return this.isColumnIndicatorHeader(col, row) || this.isRowIndicatorHeader(col, row);
        }
        toggleHierarchyState(col, row) {
            this.colIndex = 0;
            const lastLevelIndex = (this.indicatorsAsCol ? this.rowHeaderLevelCount - 1 : this.rowHeaderLevelCount - 2) -
                this.leftRowSeriesNumberColumnCount;
            const oldRowHeaderCellIds = this._rowHeaderCellFullPathIds_FULL.slice(0);
            const oldRowHeaderCellPositons = oldRowHeaderCellIds.map((id, row) => {
                return { col, row: row + this.columnHeaderLevelCount };
            });
            const hd = this.getHeader(col, row);
            hd.define.hierarchyState =
                hd.define.hierarchyState === HierarchyState.collapse ? HierarchyState.expand : HierarchyState.collapse;
            this.rowDimensionTree.reset(this.rowDimensionTree.tree.children);
            this.resetRowHeaderLevelCount();
            this._rowHeaderCellFullPathIds_FULL = [];
            this.rowDimensionKeys = this.rowDimensionTree.dimensionKeysIncludeVirtual.valueArr();
            this.fullRowDimensionKeys = [];
            this.fullRowDimensionKeys = this.fullRowDimensionKeys.concat(this.rowDimensionKeys);
            if (this.rowHierarchyType === 'tree') {
                this._addHeadersForTreeMode(this._rowHeaderCellFullPathIds_FULL, 0, this.rowDimensionTree.tree.children, [], this.rowDimensionTree.totalLevel, true, this.rowsDefine, this.rowHeaderObjs);
            }
            else if (this.rowHierarchyType === 'grid-tree') {
                const startRow = 0;
                this._addHeadersForGridTreeMode(this._rowHeaderCellFullPathIds_FULL, startRow, this.rowDimensionTree.tree.children, [], this.rowDimensionTree.totalLevel, this._getRowHeaderTreeExpandedMaxLevelCount(), true, this.rowsDefine, this.rowHeaderObjs, true);
                this.cornerHeaderObjs = this._addCornerHeaders(this.colDimensionKeys, this.rowDimensionKeys, this.columnsDefine.concat(...this.rowsDefine));
            }
            if (this.rowHeaderTitle) {
                const id = ++this.sharedVar.seqId;
                const firstColIds = Array(this.rowCount - this.columnHeaderLevelCount).fill(id);
                this._rowHeaderCellFullPathIds_FULL.unshift(firstColIds);
                const cell = {
                    id,
                    title: typeof this.rowHeaderTitle.title === 'string'
                        ? this.rowHeaderTitle.title
                        : this.rowsDefine.reduce((title, value) => {
                            if (typeof value === 'string') {
                                return title;
                            }
                            return title + (title ? `/${value.title}` : `${value.title}`);
                        }, ''),
                    field: undefined,
                    headerType: this.rowHeaderTitle?.headerType ?? 'text',
                    style: this.rowHeaderTitle?.headerStyle,
                    define: {
                        field: '',
                        headerType: 'text',
                        cellType: 'text',
                        disableHeaderHover: !!this.rowHeaderTitle?.disableHeaderHover,
                        disableHeaderSelect: !!this.rowHeaderTitle?.disableHeaderSelect
                    }
                };
                this.rowHeaderObjs.push(cell);
                this._headerObjects[id] = cell;
            }
            this._rowHeaderCellFullPathIds_FULL = transpose(this._rowHeaderCellFullPathIds_FULL);
            if (this.rowHierarchyType === 'tree' && this.extensionRows?.length >= 1) {
                this.generateExtensionRowTree();
            }
            this.colIndex = 0;
            this._headerObjectMap = this._headerObjects.reduce((o, e) => {
                o[e.id] = e;
                return o;
            }, {});
            this._CellHeaderPathMap = new Map();
            this._largeCellRangeCache.length = 0;
            let diffCell;
            if (this.rowHierarchyType === 'tree') {
                diffCell = diffCellAddress(col, row, oldRowHeaderCellIds.map(oldCellId => oldCellId[col - this.leftRowSeriesNumberColumnCount]), this._rowHeaderCellFullPathIds_FULL.map(newCellId => newCellId[col - this.leftRowSeriesNumberColumnCount]), oldRowHeaderCellPositons, this);
            }
            else {
                const new_lastLevelIndex = (this.indicatorsAsCol ? this.rowHeaderLevelCount - 1 : this.rowHeaderLevelCount - 2) -
                    this.leftRowSeriesNumberColumnCount;
                diffCell = diffCellAddressForGridTree(col, row, oldRowHeaderCellIds.map(oldCellId => oldCellId[lastLevelIndex]), this._rowHeaderCellFullPathIds_FULL.map(newCellId => newCellId[new_lastLevelIndex]), oldRowHeaderCellPositons, this);
            }
            this.generateCellIdsConsiderHideHeader();
            this.setPagination(this.pagination);
            if (this.rowHierarchyType === 'grid-tree') {
                this.setColumnWidths();
            }
            return diffCell;
        }
        toggleHierarchyStateForColumnTree(col, row) {
            this.colIndex = 0;
            const lastLevelIndex = !this.indicatorsAsCol ? this.columnHeaderLevelCount - 1 : this.columnHeaderLevelCount - 2;
            const oldColumnHeaderCellIds = this._columnHeaderCellFullPathIds.slice(0);
            const oldColumnHeaderCellPositons = oldColumnHeaderCellIds[this.columnHeaderLevelCount - 1].map((id, col) => {
                return { col: col + this.rowHeaderLevelCount, row };
            });
            const hd = this.getHeader(col, row);
            hd.define.hierarchyState =
                hd.define.hierarchyState === HierarchyState.collapse ? HierarchyState.expand : HierarchyState.collapse;
            this.columnDimensionTree.reset(this.columnDimensionTree.tree.children);
            this.resetColumnHeaderLevelCount();
            this._columnHeaderCellFullPathIds = [];
            this.colDimensionKeys = this.columnDimensionTree.dimensionKeysIncludeVirtual.valueArr();
            if (this.columnHierarchyType === 'grid-tree') {
                const startRow = 0;
                this._addHeadersForGridTreeMode(this._columnHeaderCellFullPathIds, startRow, this.columnDimensionTree.tree.children, [], this.columnDimensionTree.totalLevel, this._getColumnHeaderTreeExpandedMaxLevelCount(), true, this.columnsDefine, this.columnHeaderObjs, false);
                this.cornerHeaderObjs = this._addCornerHeaders(this.colDimensionKeys, this.rowDimensionKeys, this.columnsDefine.concat(...this.rowsDefine));
            }
            if (this.columnHeaderTitle) {
                const id = ++this.sharedVar.seqId;
                const firstRowIds = Array(this.colCount - this.rowHeaderLevelCount - this.rightFrozenColCount).fill(id);
                this._columnHeaderCellFullPathIds.unshift(firstRowIds);
                const cell = {
                    id,
                    title: typeof this.columnHeaderTitle.title === 'string'
                        ? this.columnHeaderTitle.title
                        : this.columnsDefine.reduce((title, value) => {
                            if (typeof value === 'string') {
                                return title;
                            }
                            return title + (title ? `/${value.title}` : `${value.title}`);
                        }, ''),
                    field: undefined,
                    headerType: this.columnHeaderTitle?.headerType ?? 'text',
                    style: this.columnHeaderTitle?.headerStyle,
                    define: {
                        id,
                        disableHeaderHover: !!this.columnHeaderTitle?.disableHeaderHover,
                        disableHeaderSelect: !!this.columnHeaderTitle?.disableHeaderSelect
                    }
                };
                this.columnHeaderObjs.push(cell);
                this._headerObjects[id] = cell;
            }
            this.colIndex = 0;
            this._headerObjectMap = this._headerObjects.reduce((o, e) => {
                o[e.id] = e;
                return o;
            }, {});
            this._CellHeaderPathMap = new Map();
            this._largeCellRangeCache.length = 0;
            const new_lastLevelIndex = !this.indicatorsAsCol
                ? this.columnHeaderLevelCount - 1
                : this.columnHeaderLevelCount - 2;
            const diffCell = diffCellAddressForGridTreeOnColumn(col, row, oldColumnHeaderCellIds[lastLevelIndex], this._columnHeaderCellFullPathIds[new_lastLevelIndex], oldColumnHeaderCellPositons, this);
            this.generateCellIdsConsiderHideHeader();
            if (this.columnHierarchyType === 'grid-tree') {
                this.setColumnWidths();
            }
            return diffCell;
        }
        isHeaderForColWidth(col, row) {
            return this.isHeader(col, row);
        }
        getHeaderForColWidth(col, row) {
            return this.getHeader(col, row);
        }
        getPivotCellAdress(dimensions) {
            if (!Array.isArray(dimensions)) {
                return undefined;
            }
            let rowArr = this.rowTree;
            let rowDimension;
            let colArr = this.columnTree;
            let colDimension;
            for (let i = 0; i < dimensions.length; i++) {
                const highlightDimension = dimensions[i];
                if ((highlightDimension.isPivotCorner || !isValid$3(highlightDimension.value)) &&
                    i === dimensions.length - 1) {
                    if (this?.cornerSetting?.titleOnDimension === 'row') {
                        let col = 0;
                        if (this.rowHierarchyType === 'grid') {
                            col = this.rowDimensionKeys.indexOf(highlightDimension.dimensionKey);
                        }
                        return col === -1
                            ? undefined
                            : { col: (this.rowHeaderTitle ? col + 1 : col) + this.leftRowSeriesNumberColumnCount, row: 0 };
                    }
                    const row = this.colDimensionKeys.indexOf(highlightDimension.dimensionKey);
                    return row === -1
                        ? undefined
                        : { col: 0 + this.leftRowSeriesNumberColumnCount, row: this.columnHeaderTitle ? row + 1 : row };
                }
                let isCol = false;
                for (let j = 0; j < colArr.length; j++) {
                    const dimension = colArr[j];
                    if (((isValid$3(highlightDimension.dimensionKey) && dimension.dimensionKey === highlightDimension.dimensionKey) ||
                        (isValid$3(highlightDimension.indicatorKey) && dimension.indicatorKey === highlightDimension.indicatorKey)) &&
                        dimension.value === highlightDimension.value) {
                        colArr = dimension.children;
                        colDimension = dimension;
                        isCol = true;
                        break;
                    }
                }
                if (isCol) {
                    continue;
                }
                for (let k = 0; k < rowArr.length; k++) {
                    const dimension = rowArr[k];
                    if (((isValid$3(highlightDimension.dimensionKey) && dimension.dimensionKey === highlightDimension.dimensionKey) ||
                        (isValid$3(highlightDimension.indicatorKey) && dimension.indicatorKey === highlightDimension.indicatorKey)) &&
                        dimension.value === highlightDimension.value) {
                        rowArr = dimension.children;
                        rowDimension = dimension;
                        break;
                    }
                }
            }
            let col = 0;
            let row = 0;
            if (rowDimension) {
                row = this.columnHeaderLevelCount;
                const { startInTotal, afterSpanLevel } = rowDimension;
                row += startInTotal;
                if (this.rowHierarchyType === 'grid') {
                    col = (this.rowHeaderTitle ? afterSpanLevel + 1 : afterSpanLevel) + this.leftRowSeriesNumberColumnCount;
                }
                else {
                    col = 0 + this.leftRowSeriesNumberColumnCount;
                }
                return { col, row };
            }
            else if (colDimension) {
                col = this.rowHeaderLevelCount + this.leftRowSeriesNumberColumnCount;
                const { startInTotal, afterSpanLevel } = colDimension;
                col += startInTotal;
                row = this.columnHeaderTitle ? afterSpanLevel + 1 : afterSpanLevel;
                return { col, row };
            }
            return undefined;
        }
        getPivotDimensionInfo(col, row) {
            const { colHeaderPaths, rowHeaderPaths } = this.getCellHeaderPaths(col, row);
            const pivotInfo = [];
            if (colHeaderPaths.length) {
                colHeaderPaths.forEach((path, i) => {
                    pivotInfo.push({
                        dimensionKey: path.dimensionKey,
                        value: path.value,
                        isPivotCorner: false,
                        indicatorKey: path.indicatorKey
                    });
                });
            }
            else if (rowHeaderPaths.length) {
                rowHeaderPaths.forEach((path, i) => {
                    pivotInfo.push({
                        dimensionKey: path.dimensionKey,
                        value: path.value,
                        isPivotCorner: false,
                        indicatorKey: path.indicatorKey
                    });
                });
            }
            else if (this.isCornerHeader(col, row)) {
                if (this?.cornerSetting?.titleOnDimension === 'row') {
                    pivotInfo.push({
                        dimensionKey: this.rowDimensionKeys[(this.rowHeaderTitle ? col - 1 : col) - this.leftRowSeriesNumberColumnCount],
                        isPivotCorner: true
                    });
                }
                else {
                    pivotInfo.push({
                        dimensionKey: this.colDimensionKeys[this.columnHeaderTitle ? row - 1 : row],
                        isPivotCorner: true
                    });
                }
            }
            return pivotInfo;
        }
        getIndicatorKey(col, row) {
            return this.getBody(col, row)?.indicatorKey;
        }
        getParentCellId(col, row) {
            if (row === 0) {
                return undefined;
            }
            if (this.isColumnHeader(col, row)) {
                return this.getCellId(col, row - 1);
            }
            else if (this.isRowHeader(col, row)) {
                return this.getCellId(col - 1, row);
            }
            return undefined;
        }
        getRowHeaderCellAddressByCellId(cellId) {
            let col;
            let row;
            this._rowHeaderCellIds.find((cellIds, rowIndex) => {
                const finded = cellIds.find((id, colIndex) => {
                    if (id === cellId) {
                        col = colIndex;
                        return true;
                    }
                    return false;
                });
                if (finded) {
                    row = rowIndex;
                    return true;
                }
                return false;
            });
            if (isValid$3(col) && isValid$3(row)) {
                return { col, row: row + this.columnHeaderLevelCount };
            }
            return undefined;
        }
        canMoveHeaderPosition(source, target) {
            if (this.isSeriesNumberInHeader(target.col, target.row) || this.isSeriesNumberInHeader(source.col, source.row)) {
                return false;
            }
            if (this.isCornerHeader(target.col, target.row)) {
                return false;
            }
            if (source.col < 0 || source.row < 0 || target.col < 0 || target.row < 0) {
                return false;
            }
            if (this.isSeriesNumberInBody(target.col, target.row) && this.isSeriesNumberInBody(source.col, source.row)) {
                source.col = source.col + this.leftRowSeriesNumberColumnCount + this.rowHeaderLevelCount - 1;
                target.col = target.col + this.leftRowSeriesNumberColumnCount + this.rowHeaderLevelCount - 1;
            }
            const sourceCellRange = this.getCellRange(source.col, source.row);
            if (this.isColumnHeader(source.col, source.row)) {
                const sourceTopId = this.getParentCellId(source.col, sourceCellRange.start.row);
                const targetTopId = this.getParentCellId(target.col, sourceCellRange.start.row);
                return sourceTopId === targetTopId;
            }
            else if (this.isRowHeader(source.col, source.row)) {
                if (this.rowHierarchyType === 'tree') {
                    const sourceRowHeaderPaths = cloneDeep$1(this.getCellHeaderPathsWithTreeNode(source.col, source.row).rowHeaderPaths);
                    const targetRowHeaderPaths = cloneDeep$1(this.getCellHeaderPathsWithTreeNode(target.col, target.row).rowHeaderPaths);
                    sourceRowHeaderPaths.pop();
                    targetRowHeaderPaths.pop();
                    if (sourceRowHeaderPaths.length <= targetRowHeaderPaths.length) {
                        if (sourceRowHeaderPaths.length === targetRowHeaderPaths.length) {
                            return !sourceRowHeaderPaths.find((item, i) => item.dimensionKey !== targetRowHeaderPaths[i].dimensionKey ||
                                item.value !== targetRowHeaderPaths[i].value);
                        }
                        if (sourceRowHeaderPaths.length > 0) {
                            for (let i = 0; i < sourceRowHeaderPaths.length; i++) {
                                if (sourceRowHeaderPaths[i].startInTotal !== targetRowHeaderPaths[i].startInTotal) {
                                    return false;
                                }
                            }
                        }
                        return true;
                    }
                }
                else {
                    const sourceTopId = this.getParentCellId(sourceCellRange.start.col, source.row);
                    const targetTopId = this.getParentCellId(sourceCellRange.start.col, target.row);
                    return sourceTopId === targetTopId;
                }
            }
            return false;
        }
        moveHeaderPosition(source, target) {
            if ((!this._table.options.dragOrder?.validateDragOrderOnEnd ||
                this._table.options.dragOrder?.validateDragOrderOnEnd(source, target)) &&
                this.canMoveHeaderPosition(source, target) &&
                !this.isCellRangeEqual(source.col, source.row, target.col, target.row)) {
                const sourceCellRange = this.getCellRange(source.col, source.row);
                if (this.isColumnHeader(source.col, source.row)) {
                    const sourceSize = sourceCellRange.end.col - sourceCellRange.start.col + 1;
                    let targetIndex;
                    const targetCellRange = this.getCellRange(target.col, sourceCellRange.start.row);
                    if (target.col >= source.col) {
                        targetIndex = targetCellRange.end.col - sourceSize + 1;
                    }
                    else {
                        targetIndex = targetCellRange.start.col;
                    }
                    if (targetIndex === sourceCellRange.start.col) {
                        return null;
                    }
                    for (let row = 0; row < this._columnHeaderCellFullPathIds.length; row++) {
                        const sourceIds = this._columnHeaderCellFullPathIds[row].splice(sourceCellRange.start.col - this.rowHeaderLevelCount - this.leftRowSeriesNumberColumnCount, sourceSize);
                        sourceIds.unshift(targetIndex - this.rowHeaderLevelCount - this.leftRowSeriesNumberColumnCount, 0);
                        Array.prototype.splice.apply(this._columnHeaderCellFullPathIds[row], sourceIds);
                    }
                    const sourceColumns = this._columnWidths.splice(sourceCellRange.start.col - this.leftRowSeriesNumberColumnCount, sourceSize);
                    sourceColumns.unshift((targetIndex - this.leftRowSeriesNumberColumnCount), 0);
                    Array.prototype.splice.apply(this._columnWidths, sourceColumns);
                    this.columnDimensionTree.movePosition(this.getCellHeaderPathsWithTreeNode(source.col, source.row).colHeaderPaths.length - 1, sourceCellRange.start.col - this.rowHeaderLevelCount - this.leftRowSeriesNumberColumnCount, targetCellRange.start.col - this.rowHeaderLevelCount - this.leftRowSeriesNumberColumnCount);
                    this.columnDimensionTree.reset(this.columnDimensionTree.tree.children);
                    this._CellHeaderPathMap = new Map();
                    this._largeCellRangeCache.length = 0;
                    return {
                        sourceIndex: sourceCellRange.start.col,
                        targetIndex,
                        sourceSize,
                        targetSize: targetCellRange.end.col - targetCellRange.start.col + 1,
                        moveType: 'column'
                    };
                }
                else if (this.isRowHeader(source.col, source.row)) {
                    let targetIndex;
                    const sourceRowHeaderPaths = this.getCellHeaderPathsWithTreeNode(source.col, source.row).rowHeaderPaths;
                    const targetRowHeaderPaths = this.getCellHeaderPathsWithTreeNode(target.col, target.row).rowHeaderPaths;
                    const sourceRowHeaderNode = sourceRowHeaderPaths[sourceRowHeaderPaths.length - 1];
                    const targetRowHeaderNode = targetRowHeaderPaths[sourceRowHeaderPaths.length - 1];
                    const sourceSize = sourceRowHeaderNode.size;
                    if (target.row >= source.row) {
                        targetIndex = targetRowHeaderNode.startInTotal + targetRowHeaderNode.size - sourceSize;
                    }
                    else {
                        targetIndex = targetRowHeaderNode.startInTotal;
                    }
                    if (targetIndex ===
                        sourceCellRange.start.row - this.columnHeaderLevelCount) {
                        return null;
                    }
                    const sourceIds = this._rowHeaderCellIds.splice(sourceCellRange.start.row - this.columnHeaderLevelCount, sourceSize);
                    sourceIds.unshift((targetIndex - this.currentPageStartIndex), 0);
                    Array.prototype.splice.apply(this._rowHeaderCellIds, sourceIds);
                    const sourceIds0 = this._rowHeaderCellFullPathIds.splice(sourceCellRange.start.row - this.columnHeaderLevelCount, sourceSize);
                    sourceIds0.unshift((targetIndex - this.currentPageStartIndex), 0);
                    Array.prototype.splice.apply(this._rowHeaderCellFullPathIds, sourceIds0);
                    const sourceIds_FULL = this._rowHeaderCellIds_FULL.splice(sourceCellRange.start.row - this.columnHeaderLevelCount + this.currentPageStartIndex, sourceSize);
                    sourceIds_FULL.unshift(targetIndex, 0);
                    Array.prototype.splice.apply(this._rowHeaderCellIds_FULL, sourceIds_FULL);
                    const sourceIds_FULL0 = this._rowHeaderCellFullPathIds_FULL.splice(sourceCellRange.start.row - this.columnHeaderLevelCount + this.currentPageStartIndex, sourceSize);
                    sourceIds_FULL0.unshift(targetIndex, 0);
                    Array.prototype.splice.apply(this._rowHeaderCellFullPathIds_FULL, sourceIds_FULL0);
                    this.rowDimensionTree.movePosition(sourceRowHeaderPaths.length - 1, sourceCellRange.start.row - this.columnHeaderLevelCount, targetIndex + (target.row > source.row ? sourceRowHeaderNode.size - 1 : 0));
                    this.rowDimensionTree.reset(this.rowDimensionTree.tree.children);
                    this._CellHeaderPathMap = new Map();
                    this._largeCellRangeCache.length = 0;
                    return {
                        sourceIndex: sourceCellRange.start.row,
                        targetIndex: targetIndex + this.columnHeaderLevelCount,
                        sourceSize,
                        targetSize: targetRowHeaderNode.size,
                        moveType: 'row'
                    };
                }
            }
            return null;
        }
        getCellAdressByHeaderPath(dimensionPaths) {
            let colHeaderPaths;
            let rowHeaderPaths;
            let isCornerCell = false;
            let forceBody = false;
            if (Array.isArray(dimensionPaths)) {
                if (dimensionPaths.length > this.rowDimensionKeys.length + this.colDimensionKeys.length) {
                    return undefined;
                }
                colHeaderPaths = dimensionPaths.filter((path) => this.colDimensionKeys.indexOf(path.dimensionKey) >= 0 ||
                    (this.colDimensionKeys.indexOf(this.indicatorDimensionKey) >= 0 && path.indicatorKey));
                rowHeaderPaths = dimensionPaths.filter((path) => this.rowDimensionKeys.indexOf(path.dimensionKey) >= 0 ||
                    (this.rowDimensionKeys.indexOf(this.indicatorDimensionKey) >= 0 && path.indicatorKey));
            }
            else {
                colHeaderPaths = dimensionPaths.colHeaderPaths;
                rowHeaderPaths = dimensionPaths.rowHeaderPaths;
                if (dimensionPaths?.cellLocation === 'body' && this._table.isPivotTable()) {
                    forceBody = true;
                }
            }
            if (!Array.isArray(colHeaderPaths) && !Array.isArray(rowHeaderPaths)) {
                return undefined;
            }
            colHeaderPaths?.sort((a, b) => {
                return (this.colDimensionKeys.indexOf(a.dimensionKey ?? this.indicatorDimensionKey) -
                    this.colDimensionKeys.indexOf(b.dimensionKey ?? this.indicatorDimensionKey));
            });
            rowHeaderPaths?.sort((a, b) => {
                return (this.fullRowDimensionKeys.indexOf(a.dimensionKey ?? this.indicatorDimensionKey) -
                    this.fullRowDimensionKeys.indexOf(b.dimensionKey ?? this.indicatorDimensionKey));
            });
            colHeaderPaths?.forEach(a => {
                if (a.isPivotCorner) {
                    isCornerCell = true;
                }
            });
            rowHeaderPaths?.forEach(a => {
                if (a.isPivotCorner) {
                    isCornerCell = true;
                }
            });
            if (isCornerCell) {
                if (this.cornerSetting.titleOnDimension === 'all' && this.indicatorsAsCol && colHeaderPaths.length === 0) {
                    for (let i = 0; i < this.rowDimensionKeys.length; i++) {
                        if (rowHeaderPaths[0]?.dimensionKey === this.rowDimensionKeys[i]) {
                            return { col: i + this.leftRowSeriesNumberColumnCount, row: this.columnHeaderLevelCount - 1 };
                        }
                    }
                }
                else if (this.cornerSetting.titleOnDimension === 'all' &&
                    !this.indicatorsAsCol &&
                    rowHeaderPaths.length === 0) {
                    for (let i = 0; i < this.colDimensionKeys.length; i++) {
                        if (colHeaderPaths[0]?.dimensionKey === this.colDimensionKeys[i]) {
                            return { col: this.rowHeaderLevelCount - 1, row: i };
                        }
                    }
                }
                else if (this.cornerSetting.titleOnDimension === 'row' ||
                    (this.cornerSetting.titleOnDimension === 'all' && !this.indicatorsAsCol)) {
                    for (let i = 0; i < this.rowDimensionKeys.length; i++) {
                        if (rowHeaderPaths[0]?.dimensionKey === this.rowDimensionKeys[i]) {
                            return { col: i + this.leftRowSeriesNumberColumnCount, row: 0 };
                        }
                    }
                }
                else {
                    for (let i = 0; i < this.colDimensionKeys.length; i++) {
                        if (colHeaderPaths[0]?.dimensionKey === this.colDimensionKeys[i]) {
                            return { col: 0, row: i };
                        }
                    }
                }
            }
            let needLowestLevel_colPaths = false;
            let needLowestLevel_rowPaths = false;
            if (colHeaderPaths?.length >= 1 && rowHeaderPaths?.length >= 1) {
                needLowestLevel_colPaths = true;
                needLowestLevel_rowPaths = true;
            }
            if (colHeaderPaths.length >= this._getColumnHeaderTreeExpandedMaxLevelCount()) {
                needLowestLevel_colPaths = true;
            }
            if (rowHeaderPaths.length >= this._getRowHeaderTreeExpandedMaxLevelCount()) {
                needLowestLevel_rowPaths = true;
            }
            let col;
            let row;
            let defaultCol;
            let defaultRow;
            let rowArr = this.rowTree;
            let rowDimensionFinded;
            let colArr = this.columnTree;
            let colDimensionFinded;
            if (colHeaderPaths) {
                for (let i = 0; i < colHeaderPaths.length; i++) {
                    const colDimension = colHeaderPaths[i];
                    for (let j = 0; j < colArr.length; j++) {
                        const dimension = colArr[j];
                        if ((!isValid$3(colDimension.indicatorKey) &&
                            dimension.dimensionKey === colDimension.dimensionKey &&
                            dimension.value === colDimension.value) ||
                            (isValid$3(colDimension.indicatorKey) &&
                                dimension.indicatorKey === colDimension.indicatorKey &&
                                ((isValid$3(dimension.value) && isValid$3(colDimension.value) && colDimension.value === dimension.value) ||
                                    !isValid$3(dimension.value) ||
                                    !isValid$3(colDimension.value)))) {
                            colArr = dimension.children;
                            if (needLowestLevel_colPaths && !colArr?.length) {
                                colDimensionFinded = dimension;
                            }
                            else if (!needLowestLevel_colPaths) {
                                colDimensionFinded = dimension;
                            }
                            break;
                        }
                    }
                }
            }
            if (rowHeaderPaths?.length >= 1) {
                if (this.rowHierarchyType === 'tree') {
                    const rowDimension = rowHeaderPaths[rowHeaderPaths.length - 1];
                    const cellIDs = this.headerObjects
                        .filter((hd) => {
                        return ((hd?.field === rowDimension.dimensionKey || hd?.field === rowDimension.indicatorKey) &&
                            hd?.title === rowDimension.value);
                    })
                        .map((hd) => {
                        return hd.id;
                    });
                    const findedCellIdPaths = this._rowHeaderCellIds.filter(rowHdCellIDs => {
                        return cellIDs.indexOf(rowHdCellIDs[rowHdCellIDs.length - 1]) >= 0;
                    });
                    const findedCellIdPath = findedCellIdPaths.find(pathIds => {
                        const fullCellIds = this.findFullCellIds(pathIds);
                        return (fullCellIds.length === rowHeaderPaths.length &&
                            fullCellIds.every(id => {
                                const curHd = this._headerObjectMap[id];
                                return rowHeaderPaths.find(rowDimensionPath => {
                                    return rowDimensionPath.dimensionKey === curHd.field && rowDimensionPath.value === curHd.title;
                                });
                            }));
                    });
                    row = this._rowHeaderCellIds.indexOf(findedCellIdPath) + this.columnHeaderLevelCount;
                }
                else {
                    for (let i = 0; i < rowHeaderPaths.length; i++) {
                        const rowDimension = rowHeaderPaths[i];
                        for (let j = 0; j < rowArr.length; j++) {
                            const dimension = rowArr[j];
                            if ((!isValid$3(rowDimension.indicatorKey) &&
                                dimension.dimensionKey === rowDimension.dimensionKey &&
                                dimension.value === rowDimension.value) ||
                                (isValid$3(rowDimension.indicatorKey) &&
                                    dimension.indicatorKey === rowDimension.indicatorKey &&
                                    (!isValid$3(rowDimension.value) || dimension.value === rowDimension.value))) {
                                rowArr = dimension.children;
                                if (needLowestLevel_rowPaths && (!rowArr?.length || rowArr.some(row => row.dimensionKey === 'axis'))) {
                                    rowDimensionFinded = dimension;
                                }
                                else if (!needLowestLevel_rowPaths) {
                                    rowDimensionFinded = dimension;
                                }
                                break;
                            }
                        }
                    }
                }
            }
            if (!forceBody && needLowestLevel_colPaths && needLowestLevel_rowPaths) {
                if ((!rowDimensionFinded && !isValid$3(row)) || !colDimensionFinded) {
                    return undefined;
                }
            }
            if (rowDimensionFinded || forceBody) {
                row = this.columnHeaderLevelCount;
                const { startInTotal, afterSpanLevel } = rowDimensionFinded ?? defaultDimension;
                row += startInTotal ?? 0;
                if (this.rowHierarchyType === 'grid') {
                    defaultCol = (this.rowHeaderTitle ? afterSpanLevel + 1 : afterSpanLevel) + this.leftRowSeriesNumberColumnCount;
                }
                else {
                    defaultCol = 0;
                }
            }
            if (colDimensionFinded || forceBody) {
                col = this.rowHeaderLevelCount + this.leftRowSeriesNumberColumnCount;
                const { startInTotal, afterSpanLevel } = colDimensionFinded ?? defaultDimension;
                col += startInTotal ?? 0;
                defaultRow = this.columnHeaderTitle ? afterSpanLevel + 1 : afterSpanLevel;
            }
            if (isValid$3(col) || isValid$3(row)) {
                return { col: col ?? defaultCol, row: row ?? defaultRow };
            }
            return undefined;
        }
        setChartInstance(_col, _row, chartInstance) {
            const paths = this.getCellHeaderPaths(_col, _row);
            let indicatorObj;
            if (this.indicatorsAsCol) {
                const indicatorKey = paths.colHeaderPaths.find(colPath => colPath.indicatorKey)?.indicatorKey;
                indicatorObj = this._indicators?.find(indicator => indicator.indicatorKey === indicatorKey);
            }
            else {
                const indicatorKey = paths.rowHeaderPaths.find(rowPath => rowPath.indicatorKey)?.indicatorKey;
                indicatorObj = this._indicators?.find(indicator => indicator.indicatorKey === indicatorKey);
            }
            if (typeof indicatorObj?.chartSpec === 'function') {
                return;
            }
            indicatorObj && (indicatorObj.chartInstance = chartInstance);
        }
        getChartInstance(_col, _row) {
            const paths = this.getCellHeaderPaths(_col, _row);
            let indicatorObj;
            if (this.indicatorsAsCol) {
                const indicatorKey = paths.colHeaderPaths.find(colPath => colPath.indicatorKey)?.indicatorKey;
                indicatorObj = this._indicators?.find(indicator => indicator.indicatorKey === indicatorKey);
            }
            else {
                const indicatorKey = paths.rowHeaderPaths.find(rowPath => rowPath.indicatorKey)?.indicatorKey;
                indicatorObj = this._indicators?.find(indicator => indicator.indicatorKey === indicatorKey);
            }
            return indicatorObj?.chartInstance;
        }
        checkHasChart() {
            return checkHasChart(this);
        }
        getDimension(dimensionKey, type) {
            if (type === 'column') {
                return this.columnsDefine?.find(dimension => typeof dimension === 'string' ? false : dimension.dimensionKey === dimensionKey);
            }
            else if (type === 'row') {
                return this.rowsDefine?.find(dimension => typeof dimension === 'string' ? false : dimension.dimensionKey === dimensionKey);
            }
        }
        getAxisConfigInPivotChart(col, row) {
            if (((this.isFrozenColumn(col, row) || this.isRightFrozenColumn(col, row)) &&
                isHasCartesianChartInline(col, row, 'row', this)) ||
                ((this.isFrozenRow(col, row) || this.isBottomFrozenRow(col, row)) &&
                    isHasCartesianChartInline(col, row, 'col', this))) {
                const getAxisConfigInPivotChart = Factory.getFunction('getAxisConfigInPivotChart');
                const config = getAxisConfigInPivotChart(col, row, this);
                if (config?.visible === false) {
                    return undefined;
                }
                return config;
            }
            return undefined;
        }
        isEmpty(col, row) {
            if (!this._table.isPivotChart()) {
                return false;
            }
            if (this.isLeftBottomCorner(col, row)) {
                return true;
            }
            if (this.isRightBottomCorner(col, row)) {
                return true;
            }
            if (this.isRightTopCorner(col, row)) {
                return true;
            }
            return false;
        }
        isAxisCell(col, row) {
            if (!this._table.isPivotChart()) {
                return false;
            }
            if (this.indicatorKeys.length >= 1 && checkHasCartesianChart(this.indicatorsDefine)) {
                if ((this.isBottomFrozenRow(col, row) && isHasCartesianChartInline(col, row, 'col', this)) ||
                    (this.isRightFrozenColumn(col, row) && isHasCartesianChartInline(col, row, 'row', this))) {
                    return true;
                }
                if (this.isRowHeader(col, row) &&
                    col === this.rowHeaderLevelCount - 1 &&
                    isHasCartesianChartInline(col, row, 'row', this)) {
                    return true;
                }
                if (this.hasTwoIndicatorAxes &&
                    this.indicatorsAsCol &&
                    row === this.columnHeaderLevelCount - 1 &&
                    isHasCartesianChartInline(col, row, 'col', this)) {
                    return true;
                }
            }
            return false;
        }
        getChartAxes(col, row) {
            if (isCartesianChart(col, row, this) || this.isAxisCell(col, row)) {
                return getChartAxes(col, row, this);
            }
            return undefined;
        }
        getRawChartSpec(col, row) {
            return getRawChartSpec(col, row, this);
        }
        getChartSpec(col, row) {
            return getChartSpec(col, row, this);
        }
        isShareChartSpec(col, row) {
            return isShareChartSpec(col, row, this);
        }
        getChartDataId(col, row) {
            return getChartDataId(col, row, this);
        }
        isNoChartDataRenderNothing(col, row) {
            return isNoChartDataRenderNothing(col, row, this);
        }
        setPagination(pagination) {
            this.clearCellRangeMap();
            this._table.internalProps.useOneRowHeightFillAll = false;
            this.pagination = pagination;
            if (this.rowHierarchyType === 'grid' &&
                isValid$3(this.pagination?.perPageCount) &&
                isValid$3(this.pagination?.currentPage)) {
                if (this.indicatorsAsCol === false) {
                    this.pagination.perPageCount =
                        Math.ceil(this.pagination.perPageCount / this.indicatorKeys.length) * this.indicatorKeys.length;
                }
                const { perPageCount, currentPage } = this.pagination;
                this.currentPageStartIndex = perPageCount * (currentPage || 0);
                this.currentPageEndIndex = this.currentPageStartIndex + perPageCount;
                this._rowHeaderCellIds = this._rowHeaderCellIds_FULL?.slice(this.currentPageStartIndex, this.currentPageEndIndex);
                this._rowHeaderCellFullPathIds = this._rowHeaderCellFullPathIds_FULL?.slice(this.currentPageStartIndex, this.currentPageEndIndex);
            }
            else {
                this.currentPageStartIndex = 0;
                this.currentPageEndIndex = this._rowHeaderCellIds_FULL.length;
                this._rowHeaderCellIds = this._rowHeaderCellIds_FULL?.slice(this.currentPageStartIndex, this.currentPageEndIndex);
                this._rowHeaderCellFullPathIds = this._rowHeaderCellFullPathIds_FULL?.slice(this.currentPageStartIndex, this.currentPageEndIndex);
            }
            this.pagination && (this.pagination.totalCount = this._rowHeaderCellIds_FULL?.length);
        }
        release() {
            const activeChartInstance = this._table._getActiveChartInstance();
            activeChartInstance?.release();
            this._indicators?.forEach(indicatorObject => {
                indicatorObject.chartInstance?.release();
            });
        }
        getHeadNode(col, row) {
            let dimensions;
            const headerPaths = this.getCellHeaderPaths(col, row);
            if (headerPaths.rowHeaderPaths && (headerPaths.rowHeaderPaths?.length ?? 0) > 0) {
                dimensions = headerPaths.rowHeaderPaths?.slice(0, headerPaths.rowHeaderPaths.length);
            }
            else if (headerPaths.colHeaderPaths && headerPaths.colHeaderPaths.length > 0) {
                dimensions = headerPaths.colHeaderPaths.slice(0, headerPaths.colHeaderPaths.length);
            }
            return this.getHeadNodeByRowOrColDimensions(dimensions, col, row);
        }
        getHeadNodeByRowOrColDimensions(dimensions, col, row) {
            if (!Array.isArray(dimensions)) {
                return undefined;
            }
            let rowArr = this.rowTree;
            let rowDimension;
            let colArr = this.columnTree;
            let colDimension;
            if (isValid$3(row) &&
                isValid$3(col) &&
                this.rowHierarchyType === 'tree' &&
                this.extensionRows &&
                col >= 1 + this.leftRowSeriesNumberColumnCount) {
                const hdId = this.getCellId(col - 1, row);
                rowArr = this._rowHeaderExtensionTree[hdId].tree.children;
            }
            for (let i = 0; i < dimensions.length; i++) {
                const highlightDimension = dimensions[i];
                if ((highlightDimension.isPivotCorner || !isValid$3(highlightDimension.value)) &&
                    i === dimensions.length - 1) {
                    return undefined;
                }
                let isCol = false;
                for (let j = 0; j < colArr.length; j++) {
                    const dimension = colArr[j];
                    if ((isValid$3(highlightDimension.dimensionKey) &&
                        dimension.dimensionKey === highlightDimension.dimensionKey &&
                        dimension.value === highlightDimension.value) ||
                        (isValid$3(highlightDimension.indicatorKey) &&
                            dimension.indicatorKey === highlightDimension.indicatorKey &&
                            (dimension.value === highlightDimension.value ||
                                !isValid$3(highlightDimension.value) ||
                                !isValid$3(dimension.value)))) {
                        colArr = dimension.children;
                        colDimension = dimension;
                        isCol = true;
                        break;
                    }
                }
                if (isCol) {
                    continue;
                }
                for (let k = 0; k < (rowArr?.length ?? 0); k++) {
                    const dimension = rowArr[k];
                    if ((isValid$3(highlightDimension.dimensionKey) &&
                        dimension.dimensionKey === highlightDimension.dimensionKey &&
                        dimension.value === highlightDimension.value) ||
                        (isValid$3(highlightDimension.indicatorKey) &&
                            dimension.indicatorKey === highlightDimension.indicatorKey &&
                            (dimension.value === highlightDimension.value ||
                                !isValid$3(highlightDimension.value) ||
                                !isValid$3(dimension.value)))) {
                        rowArr = dimension.children;
                        rowDimension = dimension;
                        break;
                    }
                }
            }
            if (rowDimension) {
                return rowDimension;
            }
            else if (colDimension) {
                return colDimension;
            }
            return undefined;
        }
        clearCellRangeMap() {
            this._largeCellRangeCache.length = 0;
            this._CellHeaderPathMap = new Map();
        }
        getDimensionKeyInChartSpec(_col, _row) {
            let dimensionKey;
            if (this.indicatorsAsCol === false) {
                for (let i = 0; i < this.indicatorsDefine.length; i++) {
                    const chartSpec = this.indicatorsDefine[i].chartSpec;
                    if (chartSpec) {
                        dimensionKey = chartSpec.xField ?? chartSpec?.series?.[0]?.xField;
                        if (dimensionKey) {
                            return dimensionKey;
                        }
                    }
                }
            }
            else {
                for (let i = 0; i < this.indicatorsDefine.length; i++) {
                    const chartSpec = this.indicatorsDefine[i].chartSpec;
                    if (chartSpec) {
                        dimensionKey = chartSpec.yField ?? chartSpec?.series?.[0]?.yField;
                        if (dimensionKey) {
                            return dimensionKey;
                        }
                    }
                }
            }
            return null;
        }
        _generateChartState() {
            const state = {
                vtable_selected: {
                    filter: (datum) => {
                        if (this._table._selectedDataItemsInChart.length >= 1) {
                            const match = this._table._selectedDataItemsInChart.find(item => {
                                for (const itemKey in item) {
                                    if (typeof item[itemKey] !== 'object' && item[itemKey] !== datum[itemKey]) {
                                        return false;
                                    }
                                }
                                return true;
                            });
                            return !!match;
                        }
                        else if (this._table._selectedDimensionInChart?.length) {
                            const match = this._table._selectedDimensionInChart.every(item => {
                                if (typeof item.value !== 'object' && datum[item.key] !== item.value) {
                                    return false;
                                }
                                return true;
                            });
                            return !!match;
                        }
                        return false;
                    }
                },
                vtable_selected_reverse: {
                    filter: (datum) => {
                        if (this._table._selectedDataItemsInChart.length >= 1) {
                            const match = this._table._selectedDataItemsInChart.find(item => {
                                for (const itemKey in item) {
                                    if (typeof item[itemKey] !== 'object' && item[itemKey] !== datum[itemKey]) {
                                        return false;
                                    }
                                }
                                return true;
                            });
                            return !match;
                        }
                        else if (this._table._selectedDimensionInChart?.length) {
                            const match = this._table._selectedDimensionInChart.every(item => {
                                if (typeof item.value !== 'object' && datum[item.key] !== item.value) {
                                    return false;
                                }
                                return true;
                            });
                            return !match;
                        }
                        return false;
                    }
                }
            };
            return state;
        }
        updateDataStateToChartInstance(activeChartInstance) {
            if (activeChartInstance?.getSpec().select?.enable !== false) {
                if (!activeChartInstance) {
                    activeChartInstance = this._table._getActiveChartInstance();
                }
                const state = this._generateChartState();
                this._indicators.forEach((_indicatorObject) => {
                    const chartInstance = _indicatorObject.chartInstance;
                    if (_indicatorObject.chartSpec.select?.enable !== false) {
                        chartInstance.updateState(state);
                    }
                });
                activeChartInstance?.updateState(state);
            }
        }
        updateDataStateToActiveChartInstance(activeChartInstance) {
            if (activeChartInstance?.getSpec().select?.enable !== false) {
                if (!activeChartInstance) {
                    activeChartInstance = this._table._getActiveChartInstance();
                }
                const state = this._generateChartState();
                activeChartInstance?.updateState(state);
            }
        }
        getIndicatorKeyInChartSpec(_col, _row) {
            const chartSpec = this.getRawChartSpec(_col, _row);
            const indicatorKeys = [];
            if (chartSpec) {
                if (chartSpec.series || chartSpec.xField || chartSpec.yField) {
                    if (this.indicatorsAsCol === false) {
                        if (chartSpec.series) {
                            chartSpec.series.forEach((chartSeries) => {
                                const yField = chartSeries.yField;
                                indicatorKeys.push(yField);
                            });
                        }
                        else {
                            indicatorKeys.push(chartSpec.yField);
                        }
                    }
                    else {
                        if (chartSpec.series) {
                            chartSpec.series.forEach((chartSeries) => {
                                const xField = chartSeries.xField;
                                indicatorKeys.push(xField);
                            });
                        }
                        else {
                            indicatorKeys.push(chartSpec.xField);
                        }
                    }
                    return indicatorKeys;
                }
                else if (chartSpec.valueField) {
                    indicatorKeys.push(chartSpec.valueField);
                }
                if (indicatorKeys.length >= 1) {
                    return indicatorKeys;
                }
            }
            return null;
        }
        getOptimunHeightForChart(row) {
            const path = this.getCellHeaderPaths(this.rowHeaderLevelCount, row).rowHeaderPaths;
            let collectedValues;
            for (const key in this.dataset.collectValuesBy) {
                if (this.dataset.collectValuesBy[key].type === 'yField' && !this.dataset.collectValuesBy[key].range) {
                    collectedValues =
                        this.dataset.collectedValues[key]?.[path
                            .map(pathObj => {
                            return pathObj.value;
                        })
                            .join(this.dataset.stringJoinChar)];
                    break;
                }
            }
            let height;
            if (this._chartItemBandSize) {
                height = scaleWholeRangeSize(collectedValues?.length ?? 0, this._chartItemBandSize, this._chartPaddingInner, this._chartPaddingOuter);
            }
            else {
                const barWidth = this._chartItemSpanSize || 25;
                height = (collectedValues?.length ?? 0) * (barWidth + barWidth / 3);
            }
            const padding = getQuadProps(this._chartPadding ?? this._table.theme.bodyStyle.padding ?? 0);
            return height + padding[0] + padding[2];
        }
        getOptimunWidthForChart(col) {
            const path = this.getCellHeaderPaths(col, this.columnHeaderLevelCount).colHeaderPaths;
            let collectedValues;
            for (const key in this.dataset.collectValuesBy) {
                if (this.dataset.collectValuesBy[key].type === 'xField' && !this.dataset.collectValuesBy[key].range) {
                    collectedValues =
                        this.dataset.collectedValues[key]?.[path
                            .map(pathObj => {
                            return pathObj.value;
                        })
                            .join(this.dataset.stringJoinChar)];
                    break;
                }
            }
            let width;
            if (this._chartItemBandSize) {
                width = scaleWholeRangeSize(collectedValues?.length ?? 0, this._chartItemBandSize, this._chartPaddingInner, this._chartPaddingOuter);
            }
            else {
                const barWidth = this._chartItemSpanSize || 25;
                width = (collectedValues?.length ?? 0) * (barWidth + barWidth / 3);
            }
            const padding = getQuadProps(this._chartPadding ?? this._table.theme.bodyStyle.padding ?? 0);
            return width + padding[1] + padding[3];
        }
        get leftAxesCount() {
            if (!this._table.isPivotChart()) {
                return 0;
            }
            const axisOption = this._table.pivotChartAxes.find(axisOption => {
                return axisOption.orient === 'left';
            });
            if (axisOption?.visible === false) {
                return 0;
            }
            if (this.indicatorsAsCol) {
                return 1;
            }
            return 1;
        }
        get topAxesCount() {
            if (!this._table.isPivotChart()) {
                return 0;
            }
            const axisOption = this._table.pivotChartAxes.find(axisOption => {
                return axisOption.orient === 'top';
            });
            if (axisOption?.visible === false) {
                return 0;
            }
            if (this.indicatorsAsCol && this.hasTwoIndicatorAxes) {
                return 1;
            }
            return 0;
        }
        get rightAxesCount() {
            return this.rightFrozenColCount;
        }
        get bottomAxesCount() {
            return this.bottomFrozenRowCount;
        }
        getColKeysPath(col, row) {
            const path = this.getCellHeaderPaths(col, row);
            const colKey = [];
            if (path.colHeaderPaths.length) {
                path.colHeaderPaths.forEach(path => {
                    if (path.dimensionKey) {
                        colKey.push(path.value);
                    }
                });
            }
            return colKey?.join(this.dataset.stringJoinChar);
        }
        getRowKeysPath(col, row) {
            const path = this.getCellHeaderPaths(col, row);
            const rowKey = [];
            if (path.rowHeaderPaths.length) {
                path.rowHeaderPaths.forEach(path => {
                    if (path.dimensionKey) {
                        rowKey.push(path.value);
                    }
                });
            }
            return rowKey?.join(this.dataset.stringJoinChar);
        }
        getIndicatorInfo(indicatorKey, indicatorValue = '') {
            const indicatorInfo = this.indicatorsDefine?.find(indicator => {
                if (typeof indicator === 'string') {
                    return false;
                }
                if (indicatorKey) {
                    return indicator.indicatorKey === indicatorKey;
                }
                if (indicatorValue) {
                    return indicator.title === indicatorValue;
                }
                return false;
            });
            return indicatorInfo;
        }
        getLayoutColumnTree() {
            const tree = [];
            const children = this.columnDimensionTree.tree.children;
            generateLayoutTree(tree, children);
            return tree;
        }
        getLayoutRowTree() {
            const tree = [];
            const children = this.rowDimensionTree.tree.children;
            generateLayoutTree(tree, children);
            return tree;
        }
        getLayoutColumnTreeCount() {
            const children = this.columnDimensionTree.tree.children;
            const mainTreeCount = countLayoutTree(children, this.rowHierarchyType === 'tree');
            return mainTreeCount;
        }
        getLayoutRowTreeCount() {
            const children = this.rowDimensionTree.tree.children;
            const mainTreeCount = countLayoutTree(children, this.rowHierarchyType === 'tree');
            let totalCount = mainTreeCount;
            this.extensionRows?.forEach(extensionRow => {
                if (typeof extensionRow.rowTree !== 'function') {
                    const thisTreeCount = countLayoutTree(extensionRow.rowTree, true);
                    totalCount *= thisTreeCount;
                }
            });
            return totalCount;
        }
        resetHeaderTree() {
            this.colIndex = 0;
            this._rowHeaderCellFullPathIds_FULL = [];
            this._columnHeaderCellFullPathIds = [];
            this._columnHeaderCellIds = [];
            const dataset = this.dataset;
            this.rowTree = dataset.rowHeaderTree;
            this.columnTree = dataset.colHeaderTree;
            const beforeRowDimensions = this.rowDimensionTree.tree.children;
            this.rowTree?.forEach((node, index) => {
                const beforeRowDimension = beforeRowDimensions.find(item => item.dimensionKey === node.dimensionKey && item.value === node.value);
                if (beforeRowDimension) {
                    this._table._syncHierarchyState(beforeRowDimension, node);
                }
            });
            this.columnDimensionTree = new DimensionTree(this.columnTree ?? [], this.sharedVar, this.columnHierarchyType, this.columnHierarchyType !== 'grid' ? this.columnExpandLevel : undefined);
            this.rowDimensionTree = new DimensionTree(this.rowTree ?? [], this.sharedVar, this.rowHierarchyType, this.rowHierarchyType !== 'grid' ? this.rowExpandLevel : undefined);
            this.resetColumnHeaderLevelCount();
            this._generateColHeaderIds();
            this.colIndex = 0;
            this._generateRowHeaderIds();
            this._rowHeaderCellFullPathIds_FULL = transpose(this._rowHeaderCellFullPathIds_FULL);
            this._headerObjectMap = this._headerObjects.reduce((o, e) => {
                o[e.id] = e;
                return o;
            }, {});
            this._CellHeaderPathMap = new Map();
            this._largeCellRangeCache.length = 0;
            this.generateCellIdsConsiderHideHeader();
            this.setPagination(this.pagination);
        }
        isSeriesNumberInHeader(col, row) {
            if (this.leftRowSeriesNumberColumnCount > 0 && col >= 0 && row >= 0 && col < this.leftRowSeriesNumberColumnCount) {
                if (row < this.headerLevelCount) {
                    return true;
                }
            }
            if (this.rightRowSeriesNumberColumnCount > 0 &&
                row >= 0 &&
                col >= this.colCount - this.rightRowSeriesNumberColumnCount) {
                if (row < this.headerLevelCount) {
                    return true;
                }
            }
            return false;
        }
        isSeriesNumberInBody(col, row) {
            if (this.leftRowSeriesNumberColumnCount > 0 && col >= 0 && col < this.leftRowSeriesNumberColumnCount) {
                if (row >= this.headerLevelCount) {
                    return true;
                }
            }
            if (this.rightRowSeriesNumberColumnCount > 0 && col >= this.colCount - this.rightRowSeriesNumberColumnCount) {
                if (row >= this.headerLevelCount) {
                    return true;
                }
            }
            return false;
        }
        isSeriesNumber(col, row) {
            if (isValid$3(col) && isValid$3(row)) {
                if (this.leftRowSeriesNumberColumnCount > 0 &&
                    col >= 0 &&
                    row >= 0 &&
                    col < this.leftRowSeriesNumberColumnCount) {
                    return true;
                }
                if (this.rightRowSeriesNumberColumnCount > 0 &&
                    row >= 0 &&
                    col >= this.colCount - this.rightRowSeriesNumberColumnCount) {
                    return true;
                }
            }
            return false;
        }
        getSeriesNumberHeader(col, row) {
            if (this.leftRowSeriesNumberColumnCount > 0 && col >= 0 && col < this.leftRowSeriesNumberColumnCount) {
                if (row < this.headerLevelCount) {
                    return Object.assign({}, this.leftRowSeriesNumberColumn[col], {
                        style: Object.assign({}, this._table.internalProps.theme.cornerHeaderStyle, this._table.internalProps.rowSeriesNumber.headerStyle)
                    });
                }
            }
            if (this.rightRowSeriesNumberColumnCount > 0 &&
                col >= this.colCount - this.rightRowSeriesNumberColumnCount &&
                row < this.headerLevelCount) {
                if (row < this.headerLevelCount) {
                    return this.rightRowSeriesNumberColumn[col - (this.colCount - this.rightRowSeriesNumberColumnCount)];
                }
            }
            return undefined;
        }
        getSeriesNumberBody(col, row) {
            if (this.leftRowSeriesNumberColumnCount > 0 && col >= 0 && col < this.leftRowSeriesNumberColumnCount) {
                if (row >= this.headerLevelCount) {
                    return this.leftRowSeriesNumberColumn[col];
                }
            }
            if (this.rightRowSeriesNumberColumnCount > 0 && col >= this.colCount - this.rightRowSeriesNumberColumnCount) {
                if (row >= this.headerLevelCount) {
                    return this.rightRowSeriesNumberColumn[col - (this.colCount - this.rightRowSeriesNumberColumnCount)];
                }
            }
            return undefined;
        }
        changeTreeNodeTitle(col, row, value) {
            const headerTreeNode = this.getHeadNode(col, row);
            headerTreeNode.value = value;
            const id = this.getCellId(col, row);
            this._headerObjectMap[id].title = value;
        }
        changeCornerTitle(col, row, value) {
            if (this.isCornerHeader(col, row)) {
                const id = this.getCellId(col, row);
                this._headerObjectMap[id].title = value;
            }
        }
        generateCellIdsConsiderHideHeader() {
            this._columnHeaderCellIds = this._columnHeaderCellFullPathIds.slice();
            if (!this.showColumnHeader) {
                if (this.indicatorsAsCol && !this.hideIndicatorName) {
                    const indicatorIndex = this.colDimensionKeys.indexOf(IndicatorDimensionKeyPlaceholder);
                    const indicatorIds = this._columnHeaderCellIds.splice(indicatorIndex, 1);
                    this._columnHeaderCellIds.splice(0, this._columnHeaderCellIds.length);
                    this._columnHeaderCellIds.push(indicatorIds[0]);
                }
                else {
                    this._columnHeaderCellIds.splice(0, this._columnHeaderCellIds.length);
                }
            }
            this._rowHeaderCellIds_FULL = this._rowHeaderCellFullPathIds_FULL.slice();
            if (!this.showRowHeader) {
                if (!this.indicatorsAsCol && !this.hideIndicatorName) {
                    const indicatorIndex = this.rowDimensionKeys.indexOf(IndicatorDimensionKeyPlaceholder);
                    this._rowHeaderCellIds_FULL.forEach((cellIds, index) => {
                        const _cellIds = cellIds.slice();
                        const indicator = _cellIds.splice(indicatorIndex, 1);
                        _cellIds.splice(0, _cellIds.length);
                        _cellIds.push(indicator[0]);
                        this._rowHeaderCellIds_FULL[index] = _cellIds;
                    });
                }
                else {
                    this._rowHeaderCellIds_FULL.forEach((cellIds, index) => {
                        const _cellIds = cellIds.slice();
                        _cellIds.splice(0, _cellIds.length);
                        this._rowHeaderCellIds_FULL[index] = _cellIds;
                    });
                }
            }
            this._rowHeaderCellIds = this._rowHeaderCellIds_FULL.slice();
            this._cornerHeaderCellIds = this._cornerHeaderCellFullPathIds.slice();
            if (this.rowHeaderLevelCount === 0 || this.columnHeaderLevelCount === 0) {
                this._cornerHeaderCellIds = [];
            }
            else if (this.cornerSetting.titleOnDimension === 'row' && !this.showRowHeader) {
                if (!this.indicatorsAsCol && !this.hideIndicatorName) {
                    const indicatorIndex = this.rowDimensionKeys.indexOf(IndicatorDimensionKeyPlaceholder);
                    this._cornerHeaderCellIds.forEach((cellIds, index) => {
                        const _cellIds = cellIds.slice();
                        const indicator = _cellIds.splice(indicatorIndex, 1);
                        _cellIds.splice(0, _cellIds.length);
                        _cellIds.push(indicator[0]);
                        this._cornerHeaderCellIds[index] = _cellIds;
                    });
                }
                else {
                    this._cornerHeaderCellIds.forEach((cellIds, index) => {
                        const _cellIds = cellIds.slice();
                        _cellIds.splice(0, _cellIds.length);
                        this._cornerHeaderCellIds[index] = _cellIds;
                    });
                }
            }
            else if (this.cornerSetting.titleOnDimension === 'column' && !this.showColumnHeader) {
                if (this.indicatorsAsCol && !this.hideIndicatorName) {
                    const indicatorIndex = this.colDimensionKeys.indexOf(IndicatorDimensionKeyPlaceholder);
                    const indicatorIds = this._cornerHeaderCellIds.splice(indicatorIndex, 1);
                    this._cornerHeaderCellIds.splice(0, this._cornerHeaderCellIds.length);
                    this._cornerHeaderCellIds.push(indicatorIds[0]);
                }
                else {
                    this._cornerHeaderCellIds.splice(0, this._cornerHeaderCellIds.length);
                }
            }
            if (this.rowHierarchyType === 'grid-tree' && this.cornerSetting.titleOnDimension === 'column') {
                if (this._cornerHeaderCellIds[0].length < this._rowHeaderCellIds[0].length) {
                    this._cornerHeaderCellIds.forEach((cellIds, index) => {
                        const oldLength = cellIds.length;
                        cellIds.length = this._rowHeaderCellIds[0].length;
                        cellIds.fill(cellIds[0], oldLength);
                    });
                }
                else if (this._cornerHeaderCellIds[0].length > this._rowHeaderCellIds[0].length) {
                    this._cornerHeaderCellIds.forEach((cellIds, index) => {
                        cellIds.length = this._rowHeaderCellIds[0].length;
                    });
                }
            }
            else if (this.columnHierarchyType === 'grid-tree' && this.cornerSetting.titleOnDimension === 'row') {
                if (this._cornerHeaderCellIds?.length < this._columnHeaderCellIds?.length) {
                    const oldLength = this._cornerHeaderCellIds.length;
                    this._cornerHeaderCellIds.length = this._columnHeaderCellIds.length;
                    this._cornerHeaderCellIds.fill(this._cornerHeaderCellIds[0], oldLength);
                }
                else if (this._cornerHeaderCellIds?.length > this._columnHeaderCellIds?.length) {
                    this._cornerHeaderCellIds.length = this._columnHeaderCellIds.length;
                }
            }
        }
        enableUseGetBodyCache() {
            this._useGetBodyCache = true;
            this._getBodyCache.clear();
        }
        disableUseGetBodyCache() {
            this._useGetBodyCache = false;
            this._getBodyCache.clear();
        }
        enableUseHeaderPathCache() {
            if (this._table.options?.customConfig?.enablePivotPathCache) {
                this._useHeaderPathCache = true;
            }
            else {
                this._useHeaderPathCache = true;
                this._colHeaderPathCache.clear();
                this._rowHeaderPathCache.clear();
            }
        }
        disableUseHeaderPathCache() {
            if (this._table.options?.customConfig?.enablePivotPathCache) {
                this._useHeaderPathCache = true;
            }
            else {
                this._useHeaderPathCache = false;
                this._colHeaderPathCache.clear();
                this._rowHeaderPathCache.clear();
            }
        }
        getBodyWidthCache(col, row) {
            if (!this._useGetBodyCache || this.isHeader(col, row) || this.isSeriesNumber(col, row)) {
                return undefined;
            }
            if (this.indicatorsAsCol && this._getBodyCache.has(col)) {
                return this._getBodyCache.get(col);
            }
            else if (!this.indicatorsAsCol && this._getBodyCache.has(row)) {
                return this._getBodyCache.get(row);
            }
            return undefined;
        }
        setBodyWidthCache(col, row, cache) {
            if (!this._useGetBodyCache || this.isHeader(col, row) || this.isSeriesNumber(col, row)) {
                return;
            }
            if (this.indicatorsAsCol) {
                this._getBodyCache.set(col, cache);
            }
            else {
                this._getBodyCache.set(row, cache);
            }
        }
        getColHeaderPathCache(col, row) {
            if (this._useHeaderPathCache &&
                !this.isHeader(col, row) &&
                !this.isSeriesNumber(col, row) &&
                this._colHeaderPathCache.has(col)) {
                return this._colHeaderPathCache.get(col);
            }
            return undefined;
        }
        setColHeaderPathCache(col, row, cache) {
            if (this._useHeaderPathCache && !this.isHeader(col, row) && !this.isSeriesNumber(col, row)) {
                this._colHeaderPathCache.set(col, cache);
            }
        }
        getRowHeaderPathCache(col, row) {
            if (this._useHeaderPathCache &&
                !this.isHeader(col, row) &&
                !this.isSeriesNumber(col, row) &&
                this._rowHeaderPathCache.has(row)) {
                return this._rowHeaderPathCache.get(row);
            }
            return undefined;
        }
        setRowHeaderPathCache(col, row, cache) {
            if (this._useHeaderPathCache && !this.isHeader(col, row) && !this.isSeriesNumber(col, row)) {
                this._rowHeaderPathCache.set(row, cache);
            }
        }
        clearHeaderPathCache() {
            this._colHeaderPathCache.clear();
            this._rowHeaderPathCache.clear();
        }
    }
    function scaleWholeRangeSize(count, bandwidth, paddingInner, paddingOuter) {
        if (paddingInner === 1) {
            paddingInner = 0;
        }
        const space = bandSpace(count, paddingInner, paddingOuter);
        const step = bandwidth / (1 - paddingInner);
        const wholeSize = Math.ceil(space * step);
        return wholeSize;
    }
    function bandSpace(count, paddingInner, paddingOuter) {
        let space;
        if (count === 1) {
            space = count + paddingOuter * 2;
        }
        else {
            space = count - paddingInner + paddingOuter * 2;
        }
        return count ? (space > 0 ? space : 1) : 0;
    }

    class FlatDataToObjects {
        dataConfig;
        records;
        tree = {};
        beforeChangedTree = {};
        colFlatKeys = {};
        rowFlatKeys = {};
        stringJoinChar = String.fromCharCode(0);
        rowsIsTotal = [];
        colsIsTotal = [];
        colGrandTotalLabel;
        colSubTotalLabel;
        rowGrandTotalLabel;
        rowSubTotalLabel;
        constructor(dataConfig, records) {
            this.dataConfig = dataConfig;
            if (records) {
                this.records = records;
                typeof window !== 'undefined' ? window.performance.now() : 0;
                this.setRecords(records);
                typeof window !== 'undefined' ? window.performance.now() : 0;
            }
        }
        changeDataConfig(dataConfig) {
            this.dataConfig = dataConfig;
        }
        setRecords(records) {
            this.processRecords();
        }
        processRecords() {
            for (let i = 0, len = this.records.length; i < len; i++) {
                const record = this.records[i];
                this.processRecord(record);
            }
        }
        processRecord(record) {
            const colKey = [];
            const rowKey = [];
            for (let l = 0, len1 = this.dataConfig.rows.length; l < len1; l++) {
                const rowAttr = this.dataConfig.rows[l];
                if (record[rowAttr] !== undefined &&
                    rowAttr !== this.dataConfig.indicatorDimensionKey) {
                    rowKey.push(record[rowAttr]);
                }
            }
            for (let n = 0, len2 = this.dataConfig.columns.length; n < len2; n++) {
                const colAttr = this.dataConfig.columns[n];
                if (record[colAttr] !== undefined &&
                    colAttr !== this.dataConfig.indicatorDimensionKey) {
                    colKey.push(record[colAttr]);
                }
            }
            this.dataConfig.indicators?.forEach((indicatorKey) => {
                const recordValue = record[indicatorKey];
                if (recordValue !== undefined) {
                    if (this.dataConfig.indicatorsAsCol) {
                        colKey.push(indicatorKey);
                    }
                    else {
                        rowKey.push(indicatorKey);
                    }
                }
                const flatRowKey = rowKey.join(this.stringJoinChar);
                const flatColKey = colKey.join(this.stringJoinChar);
                if (rowKey.length !== 0) {
                    if (!this.rowFlatKeys[flatRowKey]) {
                        this.rowFlatKeys[flatRowKey] = 1;
                    }
                }
                if (colKey.length !== 0) {
                    if (!this.colFlatKeys[flatColKey]) {
                        this.colFlatKeys[flatColKey] = 1;
                    }
                }
                if (colKey.length !== 0 || rowKey.length !== 0) {
                    if (!this.tree[flatRowKey]) {
                        this.tree[flatRowKey] = {};
                    }
                    if (recordValue !== undefined) {
                        this.tree[flatRowKey][flatColKey] = { value: recordValue, record };
                        if (this.dataConfig.indicatorsAsCol) {
                            colKey.pop();
                        }
                        else {
                            rowKey.pop();
                        }
                    }
                }
            });
        }
        getTreeNode(rowKey = [], colKey = [], indicator, ifChangedValue = true) {
            let flatRowKey;
            let flatColKey;
            if (typeof rowKey === 'string') {
                flatRowKey = rowKey;
            }
            else {
                let isHasIndicator = false;
                rowKey.map((key, i) => {
                    if (key === indicator) {
                        rowKey.splice(i, 1);
                        isHasIndicator = true;
                    }
                });
                isHasIndicator && rowKey.push(indicator);
                flatRowKey = rowKey.join(this.stringJoinChar);
            }
            if (typeof colKey === 'string') {
                flatColKey = colKey;
            }
            else {
                let isHasIndicator = false;
                colKey.map((key, i) => {
                    if (key === indicator) {
                        colKey.splice(i, 1);
                        isHasIndicator = true;
                    }
                });
                isHasIndicator && colKey.push(indicator);
                flatColKey = colKey.join(this.stringJoinChar);
            }
            if (ifChangedValue) {
                return this.tree?.[flatRowKey]?.[flatColKey] ?? undefined;
            }
            if (isValid$3(this.beforeChangedTree[flatRowKey]?.[flatColKey])) {
                return {
                    value: this.beforeChangedTree[flatRowKey][flatColKey].value,
                    record: this.beforeChangedTree[flatRowKey][flatColKey].record
                };
            }
            return undefined;
        }
        changeTreeNodeValue(rowKey = [], colKey = [], indicator, newValue) {
            let flatRowKey;
            let flatColKey;
            if (typeof rowKey === 'string') {
                flatRowKey = rowKey;
            }
            else {
                let isHasIndicator = false;
                rowKey.map((key, i) => {
                    if (key === indicator) {
                        rowKey.splice(i, 1);
                        isHasIndicator = true;
                    }
                });
                isHasIndicator && rowKey.push(indicator);
                flatRowKey = rowKey.join(this.stringJoinChar);
            }
            if (typeof colKey === 'string') {
                flatColKey = colKey;
            }
            else {
                let isHasIndicator = false;
                colKey.map((key, i) => {
                    if (key === indicator) {
                        colKey.splice(i, 1);
                        isHasIndicator = true;
                    }
                });
                isHasIndicator && colKey.push(indicator);
                flatColKey = colKey.join(this.stringJoinChar);
            }
            const oldValue = this.tree[flatRowKey]?.[flatColKey]?.value;
            const oldRecord = Object.assign({}, this.tree[flatRowKey]?.[flatColKey]?.record);
            if (this.tree[flatRowKey]?.[flatColKey]?.record) {
                this.tree[flatRowKey][flatColKey].record[indicator] = newValue;
                this.tree[flatRowKey][flatColKey].value = newValue;
            }
            else {
                if (!this.tree[flatRowKey]) {
                    this.tree[flatRowKey] = {};
                }
                this.tree[flatRowKey][flatColKey] = {
                    record: this._buildRecord(rowKey, colKey, indicator, newValue),
                    value: newValue
                };
            }
            if (!this.beforeChangedTree[flatRowKey]?.[flatColKey]) {
                this.beforeChangedTree[flatRowKey] = {};
                this.beforeChangedTree[flatRowKey][flatColKey] = { record: undefined, value: undefined };
                this.beforeChangedTree[flatRowKey][flatColKey].record = oldRecord;
                this.beforeChangedTree[flatRowKey][flatColKey].value = oldValue;
            }
        }
        _buildRecord(rowKey = [], colKey = [], indicator, value) {
            const record = {};
            const rowDimensions = this.dataConfig.rows;
            const colDimensions = this.dataConfig.columns;
            rowDimensions.forEach((dimension, index) => {
                if (dimension !== this.dataConfig.indicatorDimensionKey) {
                    record[dimension] = rowKey[index];
                }
            });
            colDimensions.forEach((dimension, index) => {
                if (dimension !== this.dataConfig.indicatorDimensionKey) {
                    record[dimension] = colKey[index];
                }
            });
            record[indicator] = value;
            this.records.push(record);
            return record;
        }
        addRecords(records) {
            for (let i = 0, len = records.length; i < len; i++) {
                const record = records[i];
                this.processRecord(record);
            }
            this.records.push(records);
        }
        changeRecordFieldValue(fieldName, oldValue, value) {
            let isIndicatorName = false;
            for (let i = 0; i < this.dataConfig.indicators.length; i++) {
                if (this.dataConfig.indicators[i] === fieldName) {
                    isIndicatorName = true;
                }
            }
            if (!isIndicatorName) {
                for (let i = 0, len = this.records.length; i < len; i++) {
                    const record = this.records[i];
                    if (record[fieldName] === oldValue) {
                        record[fieldName] = value;
                    }
                }
                this.rowFlatKeys = {};
                this.colFlatKeys = {};
                this.tree = {};
                this.processRecords();
            }
        }
    }

    function join(strArr, joinChar) {
        let str = '';
        for (let i = 0; i < strArr.length; i++) {
            str += strArr[i];
            if (i !== strArr.length - 1) {
                str += joinChar;
            }
        }
        return str;
    }

    class Dataset {
        dataConfig;
        records;
        filteredRecords;
        tree = {};
        changedTree = {};
        colFlatKeys = {};
        rowFlatKeys = {};
        colKeys = [];
        rowKeys = [];
        colKeys_normal = [];
        rowKeys_normal = [];
        rowOrder = 'key_a_to_z';
        colOrder = 'key_a_to_z';
        sorted = false;
        sortRules;
        filterRules;
        aggregationRules;
        derivedFieldRules;
        mappingRules;
        calculatedFieldRules;
        calculatedFiledKeys;
        calculatedFieldDependIndicatorKeys;
        totals;
        indicatorStatistics = [];
        stringJoinChar = String.fromCharCode(0);
        rowsIsTotal = [];
        colsIsTotal = [];
        colGrandTotalLabel;
        colSubTotalLabel;
        rowGrandTotalLabel;
        rowSubTotalLabel;
        needSplitPositiveAndNegative;
        collectValuesBy;
        collectedValues = {};
        cacheCollectedValues = {};
        rows;
        rowsHasValue;
        columns;
        columnsHasValue;
        indicatorKeys;
        indicatorKeysIncludeCalculatedFieldDependIndicatorKeys;
        customRowTree;
        customColTree;
        customRowTreeDimensionPaths;
        customColTreeDimensionPaths;
        colHeaderTree;
        rowHeaderTree;
        rowHierarchyType;
        columnHierarchyType;
        indicators;
        indicatorsAsCol;
        totalRecordsTree = {};
        hasExtensionRowTree;
        parseCustomTreeToMatchRecords;
        constructor(dataConfig, rows, columns, indicatorKeys, indicators, indicatorsAsCol, records, rowHierarchyType, columnHierarchyType, customColTree, customRowTree, needSplitPositiveAndNegative, hasExtensionRowTree, parseCustomTreeToMatchRecords) {
            this.registerAggregators();
            this.dataConfig = dataConfig;
            this.filterRules = this.dataConfig?.filterRules;
            this.rowHierarchyType = rowHierarchyType ?? 'grid';
            this.columnHierarchyType = columnHierarchyType ?? 'grid';
            this.sortRules = this.dataConfig?.sortRules;
            this.aggregationRules = this.dataConfig?.aggregationRules;
            this.derivedFieldRules = this.dataConfig?.derivedFieldRules;
            this.mappingRules = this.dataConfig?.mappingRules;
            this.calculatedFieldRules = this.dataConfig?.calculatedFieldRules;
            this.calculatedFiledKeys = this.calculatedFieldRules?.map(rule => rule.key) ?? [];
            this.calculatedFieldDependIndicatorKeys =
                this.calculatedFieldRules?.reduce((arr, rule) => {
                    for (let i = 0; i < rule.dependIndicatorKeys.length; i++) {
                        if (arr.indexOf(rule.dependIndicatorKeys[i]) === -1) {
                            arr.push(rule.dependIndicatorKeys[i]);
                        }
                    }
                    return arr;
                }, []) ?? [];
            this.totals = this.dataConfig?.totals;
            this.rows = rows;
            this.columns = columns;
            this.indicatorKeys = indicatorKeys;
            this.indicatorKeysIncludeCalculatedFieldDependIndicatorKeys = [...indicatorKeys];
            for (let m = 0; m < this.calculatedFieldDependIndicatorKeys.length; m++) {
                if (this.indicatorKeysIncludeCalculatedFieldDependIndicatorKeys.indexOf(this.calculatedFieldDependIndicatorKeys[m]) === -1) {
                    this.indicatorKeysIncludeCalculatedFieldDependIndicatorKeys.push(this.calculatedFieldDependIndicatorKeys[m]);
                }
            }
            this.indicatorsAsCol = indicatorsAsCol;
            this.indicators = indicators;
            this.customColTree = customColTree;
            this.customRowTree = customRowTree;
            this.hasExtensionRowTree = hasExtensionRowTree;
            this.parseCustomTreeToMatchRecords = parseCustomTreeToMatchRecords;
            if (this.parseCustomTreeToMatchRecords) {
                this.customColTreeDimensionPaths = this.customTreeToDimensionPathArr(this.customColTree, 'col');
                if (!this.hasExtensionRowTree) {
                    this.customRowTreeDimensionPaths = this.customTreeToDimensionPathArr(this.customRowTree, 'row');
                }
            }
            this.colGrandTotalLabel = this.totals?.column?.grandTotalLabel ?? '总计';
            this.colSubTotalLabel = this.totals?.column?.subTotalLabel ?? '小计';
            this.rowGrandTotalLabel = this.totals?.row?.grandTotalLabel ?? '总计';
            this.rowSubTotalLabel = this.totals?.row?.subTotalLabel ?? '小计';
            this.collectValuesBy = this.dataConfig?.collectValuesBy;
            this.needSplitPositiveAndNegative = needSplitPositiveAndNegative ?? false;
            this.rowsIsTotal = new Array(this.rows?.length ?? 0).fill(false);
            this.colsIsTotal = new Array(this.columns?.length ?? 0).fill(false);
            if (this.totals?.row && this.totals.row.showSubTotals !== false && this.totals.row.subTotalsDimensions) {
                for (let i = 0, len = this.totals?.row?.subTotalsDimensions?.length ?? 0; i < len; i++) {
                    const dimension = this.totals.row.subTotalsDimensions[i];
                    const dimensionIndex = this.rows.indexOf(dimension);
                    this.rowsIsTotal[dimensionIndex] = true;
                }
            }
            if (this.totals?.column && this.totals.column.showSubTotals !== false && this.totals.column.subTotalsDimensions) {
                for (let i = 0, len = this.totals?.column?.subTotalsDimensions?.length ?? 0; i < len; i++) {
                    const dimension = this.totals.column.subTotalsDimensions[i];
                    const dimensionIndex = this.columns.indexOf(dimension);
                    this.colsIsTotal[dimensionIndex] = true;
                }
            }
            this.setRecords(records);
        }
        setRecords(records) {
            this.records = records;
            this.collectedValues = {};
            this.cacheCollectedValues = {};
            this.totalRecordsTree = {};
            this.tree = {};
            this.colFlatKeys = {};
            this.rowFlatKeys = {};
            this.colKeys = [];
            this.rowKeys = [];
            this.rowsHasValue = [];
            this.columnsHasValue = [];
            this.sorted = false;
            if (records) {
                this.records = records;
                typeof window !== 'undefined' ? window.performance.now() : 0;
                this.processRecords();
                this.processCollectedValuesWithSumBy();
                this.generateCollectedValuesSortRule();
                this.processCollectedValuesWithSortBy();
                typeof window !== 'undefined' ? window.performance.now() : 0;
                typeof window !== 'undefined' ? window.performance.now() : 0;
                this.totalStatistics();
                typeof window !== 'undefined' ? window.performance.now() : 0;
                this.rowKeys_normal = this.rowKeys.slice();
                this.colKeys_normal = this.colKeys.slice();
                typeof window !== 'undefined' ? window.performance.now() : 0;
                this.sortKeys();
                typeof window !== 'undefined' ? window.performance.now() : 0;
                typeof window !== 'undefined' ? window.performance.now() : 0;
                if (this.customRowTree) {
                    this.rowHeaderTree = this.customRowTree;
                }
                else {
                    if (this.rowHierarchyType === 'tree') {
                        this.rowHeaderTree = this.ArrToTree1(this.rowKeys, this.rows.filter((key, index) => {
                            return this.rowsHasValue[index];
                        }), this.indicatorsAsCol ? undefined : this.indicators, this.totals?.row?.showGrandTotals ||
                            (!this.indicatorsAsCol && this.columns.length === 0) ||
                            (this.indicatorsAsCol && this.rows.length === 0), this.rowGrandTotalLabel, this.totals?.row?.showGrandTotalsOnTop ?? false);
                    }
                    else {
                        this.rowHeaderTree = this.ArrToTree(this.rowKeys, this.rows.filter((key, index) => {
                            return this.rowsHasValue[index];
                        }), this.indicatorsAsCol ? undefined : this.indicators, this.rowsIsTotal, this.totals?.row?.showGrandTotals || (this.indicatorsAsCol && this.rows.length === 0), this.rowGrandTotalLabel, this.rowSubTotalLabel, this.totals?.row?.showGrandTotalsOnTop ?? false, this.totals?.row?.showSubTotalsOnTop ?? false);
                    }
                }
                if (this.customColTree) {
                    this.colHeaderTree = this.customColTree;
                }
                else {
                    this.colHeaderTree = this.ArrToTree(this.colKeys, this.columns.filter((key, index) => {
                        return this.columnsHasValue[index];
                    }), this.indicatorsAsCol ? this.indicators : undefined, this.colsIsTotal, this.totals?.column?.showGrandTotals || (!this.indicatorsAsCol && this.columns.length === 0), this.colGrandTotalLabel, this.colSubTotalLabel, this.totals?.column?.showGrandTotalsOnLeft ?? false, this.totals?.column?.showSubTotalsOnLeft ?? false);
                }
                typeof window !== 'undefined' ? window.performance.now() : 0;
                if (this.dataConfig?.isPivotChart) {
                    this.cacheDeminsionCollectedValues();
                }
            }
        }
        registerAggregator(type, aggregator) {
            registeredAggregators[type] = aggregator;
        }
        registerAggregators() {
            this.registerAggregator(AggregationType.RECORD, RecordAggregator);
            this.registerAggregator(AggregationType.SUM, SumAggregator);
            this.registerAggregator(AggregationType.COUNT, CountAggregator);
            this.registerAggregator(AggregationType.MAX, MaxAggregator);
            this.registerAggregator(AggregationType.MIN, MinAggregator);
            this.registerAggregator(AggregationType.AVG, AvgAggregator);
            this.registerAggregator(AggregationType.NONE, NoneAggregator);
            this.registerAggregator(AggregationType.RECALCULATE, RecalculateAggregator);
            this.registerAggregator(AggregationType.CUSTOM, CustomAggregator);
        }
        processCollectedValuesWithSumBy() {
            for (const field in this.collectedValues) {
                if (this.collectValuesBy?.[field]?.sumBy) {
                    for (const byKeys in this.collectedValues[field]) {
                        let max;
                        if (this.collectValuesBy[field]?.extendRange === 'sum') {
                            max = Object.values(this.collectedValues[field][byKeys]).reduce((acc, cur) => {
                                return acc + cur.value();
                            }, 0);
                            max += Math.round(max / 20);
                        }
                        else {
                            max = Object.values(this.collectedValues[field][byKeys]).reduce((acc, cur) => {
                                return cur.value() > acc ? cur.value() : acc;
                            }, Number.MIN_SAFE_INTEGER);
                            if (this.collectValuesBy[field]?.extendRange === 'max') {
                                max += Math.round(max / 20);
                            }
                            else if (typeof this.collectValuesBy[field]?.extendRange === 'number') {
                                max = Math.max(max, this.collectValuesBy[field]?.extendRange);
                            }
                        }
                        const min = Object.values(this.collectedValues[field][byKeys]).reduce((acc, cur) => {
                            return cur.value() < acc ? cur.value() : acc;
                        }, Number.MAX_SAFE_INTEGER);
                        let positiveMax;
                        let negativeMin;
                        if (this.needSplitPositiveAndNegative) {
                            positiveMax = Object.values(this.collectedValues[field][byKeys]).reduce((acc, cur) => {
                                return cur.positiveValue() > acc ? cur.positiveValue() : acc;
                            }, Number.MIN_SAFE_INTEGER);
                            negativeMin = Object.values(this.collectedValues[field][byKeys]).reduce((acc, cur) => {
                                return cur.negativeValue() < acc ? cur.negativeValue() : acc;
                            }, Number.MAX_SAFE_INTEGER);
                        }
                        this.collectedValues[field][byKeys] = {};
                        this.collectedValues[field][byKeys].max = max;
                        this.collectedValues[field][byKeys].min = min;
                        if (this.needSplitPositiveAndNegative) {
                            this.collectedValues[field][byKeys].positiveMax = positiveMax;
                            this.collectedValues[field][byKeys].negativeMin = negativeMin;
                        }
                    }
                }
            }
        }
        processCollectedValuesWithSortBy() {
            const that = this;
            for (const field in this.collectedValues) {
                if (this.collectValuesBy?.[field]?.sortBy) {
                    for (const byKeys in this.collectedValues[field]) {
                        this.collectedValues[field][byKeys] = this.collectedValues[field][byKeys].sort((a, b) => (that.collectValuesBy[field].sortBy?.indexOf(a) ?? -1) -
                            (that.collectValuesBy[field].sortBy?.indexOf(b) ?? -1));
                    }
                }
            }
        }
        generateCollectedValuesSortRule() {
            for (const field in this.collectedValues) {
                if (this.collectValuesBy && this.collectValuesBy[field] && !this.collectValuesBy[field].sortBy) {
                    let sortByRule = [];
                    for (const byKeys in this.collectedValues[field]) {
                        if (Array.isArray(this.collectedValues[field][byKeys])) {
                            sortByRule.push(...this.collectedValues[field][byKeys]);
                            sortByRule = Array.from(new Set(sortByRule));
                        }
                    }
                    if (sortByRule.length > 0) {
                        this.collectValuesBy[field].sortBy = sortByRule;
                    }
                }
            }
        }
        processRecords() {
            let isNeedFilter = false;
            if ((this.filterRules?.length ?? 0) >= 1) {
                isNeedFilter = true;
            }
            if (Array.isArray(this.records)) {
                if (!this.filteredRecords) {
                    this.filteredRecords = [];
                }
                for (let i = 0, len = this.records.length; i < len; i++) {
                    const record = this.records[i];
                    if (!isNeedFilter || this.filterRecord(record)) {
                        this.filteredRecords.push(record);
                        this.processRecord(record);
                    }
                }
            }
            else {
                if (!this.filteredRecords) {
                    this.filteredRecords = {};
                }
                for (const key in this.records) {
                    for (let i = 0, len = this.records[key].length; i < len; i++) {
                        const record = this.records[key][i];
                        if (!isNeedFilter || this.filterRecord(record)) {
                            if (!this.filteredRecords[key]) {
                                this.filteredRecords[key] = [];
                            }
                            this.filteredRecords[key].push(record);
                            this.processRecord(record, key);
                        }
                    }
                }
            }
            this.rowFlatKeys = {};
            this.colFlatKeys = {};
        }
        filterRecord(record) {
            let isReserved = true;
            if (this.filterRules) {
                for (let i = 0; i < this.filterRules.length; i++) {
                    const filterRule = this.filterRules[i];
                    if (filterRule.filterKey) {
                        const filterValue = record[filterRule.filterKey];
                        if (filterRule.filteredValues?.indexOf(filterValue) === -1) {
                            isReserved = false;
                            break;
                        }
                    }
                    else if (!filterRule.filterFunc?.(record)) {
                        isReserved = false;
                        break;
                    }
                }
            }
            return isReserved;
        }
        processRecord(record, assignedIndicatorKey) {
            this.derivedFieldRules?.forEach((derivedFieldRule, i) => {
                if (derivedFieldRule.fieldName && derivedFieldRule.derivedFunc) {
                    record[derivedFieldRule.fieldName] = derivedFieldRule.derivedFunc(record);
                }
            });
            for (const field in this.collectValuesBy) {
                if (isValid$3(record[field])) {
                    if (!this.collectedValues[field]) {
                        this.collectedValues[field] = {};
                    }
                    const collectKeys = this.collectValuesBy[field].by.map(byField => record[byField]).join(this.stringJoinChar);
                    if (!this.collectedValues[field][collectKeys]) {
                        if (this.collectValuesBy[field].sumBy) {
                            this.collectedValues[field][collectKeys] = {};
                        }
                        else if (this.collectValuesBy[field].range) {
                            this.collectedValues[field][collectKeys] = {
                                min: Number.MAX_SAFE_INTEGER,
                                max: Number.MIN_SAFE_INTEGER
                            };
                        }
                        else {
                            this.collectedValues[field][collectKeys] = [];
                        }
                    }
                    if (this.collectValuesBy[field].sumBy) {
                        const sumByKeys = this.collectValuesBy[field].sumBy
                            ?.map(byField => record[byField])
                            .join(this.stringJoinChar);
                        if (!this.collectedValues[field][collectKeys][sumByKeys]) {
                            this.collectedValues[field][collectKeys][sumByKeys] = new registeredAggregators[AggregationType.SUM]({
                                key: field,
                                field: field,
                                isRecord: undefined,
                                needSplitPositiveAndNegative: this.needSplitPositiveAndNegative
                            });
                        }
                        this.collectedValues[field][collectKeys][sumByKeys].push(record);
                    }
                    else if (this.collectValuesBy[field].range) {
                        const fieldRange = this.collectedValues[field][collectKeys];
                        const max = Math.max(record[field], fieldRange.max);
                        const min = Math.min(record[field], fieldRange.min);
                        if (!isNaN(max)) {
                            fieldRange.max = max;
                            fieldRange.min = min;
                        }
                    }
                    else {
                        const fieldRange = this.collectedValues[field][collectKeys];
                        if (fieldRange.indexOf(record[field]) === -1) {
                            fieldRange.push(record[field]);
                        }
                    }
                }
            }
            let isToTalRecord = false;
            const colKeys = [];
            const rowKeys = [];
            if (this.parseCustomTreeToMatchRecords &&
                !this.dataConfig?.isPivotChart &&
                this.customRowTree?.length &&
                !assignedIndicatorKey &&
                !this.hasExtensionRowTree) {
                const rowTreePath = this.getFieldMatchRowDimensionPaths(record);
                if (rowTreePath.length > 0) {
                    for (let i = 0, len = rowTreePath.length; i < len; i++) {
                        const rowPath = rowTreePath[i];
                        const rowKey = [];
                        let indicatorKey;
                        for (let j = 0, len1 = rowPath.length; j < len1; j++) {
                            if (isValid$3(rowPath[j].indicatorKey)) {
                                indicatorKey = rowPath[j].indicatorKey;
                            }
                            else {
                                rowKey.push(rowPath[j].value);
                            }
                        }
                        rowKeys.push({ rowKey, indicatorKey });
                    }
                }
            }
            else {
                const rowKey = [];
                rowKeys.push({ rowKey, indicatorKey: assignedIndicatorKey });
                for (let l = 0, len1 = this.rows.length; l < len1; l++) {
                    const rowAttr = this.rows[l];
                    if (rowAttr in record) {
                        this.rowsHasValue[l] = true;
                        rowKey.push(record[rowAttr]);
                    }
                    else if (rowAttr !== IndicatorDimensionKeyPlaceholder) {
                        if (this.dataConfig?.totals?.row?.showGrandTotals &&
                            l === 0 &&
                            !this.rows.find((rk) => {
                                return rk in record;
                            })) {
                            rowKey.push(this.rowGrandTotalLabel);
                            isToTalRecord = true;
                            break;
                        }
                        else if (this.dataConfig?.totals?.row?.subTotalsDimensions &&
                            this.dataConfig?.totals?.row?.subTotalsDimensions.indexOf(this.rows[l - 1]) >= 0) {
                            if (this.rowHierarchyType !== 'tree') {
                                rowKey.push(this.rowSubTotalLabel);
                            }
                            isToTalRecord = true;
                            break;
                        }
                    }
                }
            }
            if (this.parseCustomTreeToMatchRecords &&
                !this.dataConfig?.isPivotChart &&
                this.customColTree?.length &&
                !assignedIndicatorKey &&
                !this.hasExtensionRowTree) {
                const colTreePath = this.getFieldMatchColDimensionPaths(record);
                if (colTreePath.length > 0) {
                    for (let i = 0, len = colTreePath.length; i < len; i++) {
                        const colPath = colTreePath[i];
                        const colKey = [];
                        let indicatorKey;
                        for (let j = 0, len1 = colPath.length; j < len1; j++) {
                            if (isValid$3(colPath[j].indicatorKey)) {
                                indicatorKey = colPath[j].indicatorKey;
                            }
                            else {
                                colKey.push(colPath[j].value);
                            }
                        }
                        colKeys.push({ colKey: colKey, indicatorKey });
                    }
                }
            }
            else {
                const colKey = [];
                colKeys.push({ colKey, indicatorKey: assignedIndicatorKey });
                for (let n = 0, len2 = this.columns.length; n < len2; n++) {
                    const colAttr = this.columns[n];
                    if (colAttr in record) {
                        this.columnsHasValue[n] = true;
                        colKey.push(record[colAttr]);
                    }
                    else if (colAttr !== IndicatorDimensionKeyPlaceholder) {
                        if (this.dataConfig?.totals?.column?.showGrandTotals &&
                            n === 0 &&
                            !this.columns.find((ck) => {
                                return ck in record;
                            })) {
                            colKey.push(this.colGrandTotalLabel);
                            isToTalRecord = true;
                            break;
                        }
                        else if (this.dataConfig?.totals?.column?.subTotalsDimensions &&
                            this.dataConfig?.totals?.column?.subTotalsDimensions.indexOf(this.columns[n - 1]) >= 0) {
                            colKey.push(this.colSubTotalLabel);
                            isToTalRecord = true;
                            break;
                        }
                    }
                }
            }
            for (let row_i = 0; row_i < rowKeys.length; row_i++) {
                const rowKey = rowKeys[row_i].rowKey;
                let assignedIndicatorKey_value;
                if (!this.indicatorsAsCol) {
                    assignedIndicatorKey_value = rowKeys[row_i].indicatorKey;
                }
                for (let col_j = 0; col_j < colKeys.length; col_j++) {
                    const colKey = colKeys[col_j].colKey;
                    if (this.indicatorsAsCol) {
                        assignedIndicatorKey_value = colKeys[col_j].indicatorKey;
                    }
                    const flatRowKey = rowKey.join(this.stringJoinChar);
                    const flatColKey = colKey.join(this.stringJoinChar);
                    if (isToTalRecord) {
                        if (!this.totalRecordsTree[flatRowKey]) {
                            this.totalRecordsTree[flatRowKey] = {};
                        }
                        if (!this.totalRecordsTree[flatRowKey][flatColKey]) {
                            this.totalRecordsTree[flatRowKey][flatColKey] = [];
                        }
                        const toComputeIndicatorKeys = this.indicatorKeysIncludeCalculatedFieldDependIndicatorKeys;
                        for (let i = 0; i < toComputeIndicatorKeys.length; i++) {
                            if (this.calculatedFiledKeys.indexOf(toComputeIndicatorKeys[i]) >= 0) {
                                const calculatedFieldRule = this.calculatedFieldRules?.find(rule => rule.key === toComputeIndicatorKeys[i]);
                                if (!this.totalRecordsTree[flatRowKey]?.[flatColKey]?.[i]) {
                                    this.totalRecordsTree[flatRowKey][flatColKey][i] = new registeredAggregators[AggregationType.RECALCULATE]({
                                        key: toComputeIndicatorKeys[i],
                                        field: toComputeIndicatorKeys[i],
                                        isRecord: true,
                                        formatFun: this.indicators?.find((indicator) => {
                                            if (typeof indicator !== 'string') {
                                                return indicator.indicatorKey === toComputeIndicatorKeys[i];
                                            }
                                            return false;
                                        })?.format,
                                        calculateFun: calculatedFieldRule?.calculateFun,
                                        dependAggregators: this.totalRecordsTree[flatRowKey][flatColKey],
                                        dependIndicatorKeys: calculatedFieldRule?.dependIndicatorKeys
                                    });
                                }
                                toComputeIndicatorKeys[i] in record && this.totalRecordsTree[flatRowKey]?.[flatColKey]?.[i].push(record);
                            }
                            else {
                                const aggRule = this.getAggregatorRule(toComputeIndicatorKeys[i]);
                                if (!this.totalRecordsTree[flatRowKey]?.[flatColKey]?.[i]) {
                                    this.totalRecordsTree[flatRowKey][flatColKey][i] = new registeredAggregators[aggRule?.aggregationType ?? AggregationType.SUM]({
                                        key: toComputeIndicatorKeys[i],
                                        field: aggRule?.field ?? toComputeIndicatorKeys[i],
                                        aggregationFun: aggRule?.aggregationFun,
                                        formatFun: aggRule?.formatFun ??
                                            this.indicators?.find((indicator) => {
                                                if (typeof indicator !== 'string') {
                                                    return indicator.indicatorKey === toComputeIndicatorKeys[i];
                                                }
                                                return false;
                                            })?.format
                                    });
                                }
                                toComputeIndicatorKeys[i] in record && this.totalRecordsTree[flatRowKey]?.[flatColKey]?.[i].push(record);
                            }
                        }
                        return;
                    }
                    if (rowKey.length !== 0) {
                        if (!this.rowFlatKeys[flatRowKey]) {
                            this.rowKeys.push(rowKey);
                            this.rowFlatKeys[flatRowKey] = 1;
                        }
                    }
                    if (colKey.length !== 0) {
                        if (!this.colFlatKeys[flatColKey]) {
                            this.colKeys.push(colKey);
                            this.colFlatKeys[flatColKey] = 1;
                        }
                    }
                    if (!this.tree[flatRowKey]) {
                        this.tree[flatRowKey] = {};
                    }
                    if (!this.tree[flatRowKey]?.[flatColKey]) {
                        this.tree[flatRowKey][flatColKey] = [];
                    }
                    const toComputeIndicatorKeys = this.indicatorKeysIncludeCalculatedFieldDependIndicatorKeys;
                    for (let i = 0; i < toComputeIndicatorKeys.length; i++) {
                        if (this.calculatedFiledKeys.indexOf(toComputeIndicatorKeys[i]) >= 0) {
                            const calculatedFieldRule = this.calculatedFieldRules?.find(rule => rule.key === toComputeIndicatorKeys[i]);
                            if (!this.tree[flatRowKey]?.[flatColKey]?.[i]) {
                                this.tree[flatRowKey][flatColKey][i] = new registeredAggregators[AggregationType.RECALCULATE]({
                                    key: toComputeIndicatorKeys[i],
                                    field: toComputeIndicatorKeys[i],
                                    isRecord: true,
                                    formatFun: this.indicators?.find((indicator) => {
                                        if (typeof indicator !== 'string') {
                                            return indicator.indicatorKey === toComputeIndicatorKeys[i];
                                        }
                                        return false;
                                    })?.format,
                                    calculateFun: calculatedFieldRule?.calculateFun,
                                    dependAggregators: this.tree[flatRowKey][flatColKey],
                                    dependIndicatorKeys: calculatedFieldRule?.dependIndicatorKeys
                                });
                            }
                            this.tree[flatRowKey]?.[flatColKey]?.[i].push(record);
                        }
                        else {
                            const aggRule = this.getAggregatorRule(toComputeIndicatorKeys[i]);
                            let needAddToAggregator = false;
                            if (assignedIndicatorKey_value) {
                                if (assignedIndicatorKey === assignedIndicatorKey_value) {
                                    toComputeIndicatorKeys[i] === assignedIndicatorKey_value && (needAddToAggregator = true);
                                }
                                else {
                                    toComputeIndicatorKeys[i] === assignedIndicatorKey_value &&
                                        toComputeIndicatorKeys[i] in record &&
                                        (needAddToAggregator = true);
                                }
                            }
                            else if (aggRule?.field) {
                                if (typeof aggRule?.field === 'string') {
                                    aggRule?.field in record && (needAddToAggregator = true);
                                }
                                else {
                                    const isPush = aggRule?.field.find((field) => {
                                        return field in record;
                                    });
                                    isPush && (needAddToAggregator = true);
                                }
                            }
                            else {
                                toComputeIndicatorKeys[i] in record && (needAddToAggregator = true);
                            }
                            if (!this.tree[flatRowKey]?.[flatColKey]?.[i] && needAddToAggregator) {
                                this.tree[flatRowKey][flatColKey][i] = new registeredAggregators[aggRule?.aggregationType ?? AggregationType.SUM]({
                                    key: toComputeIndicatorKeys[i],
                                    field: aggRule?.field ?? toComputeIndicatorKeys[i],
                                    aggregationFun: aggRule?.aggregationFun,
                                    formatFun: aggRule?.formatFun ??
                                        this.indicators?.find((indicator) => {
                                            if (typeof indicator !== 'string') {
                                                return indicator.indicatorKey === toComputeIndicatorKeys[i];
                                            }
                                            return false;
                                        })?.format
                                });
                            }
                            if (needAddToAggregator) {
                                this.tree[flatRowKey]?.[flatColKey]?.[i].push(record);
                            }
                        }
                    }
                    if (this.mappingRules) {
                        for (let i = 0; i < this.indicatorKeys.length; i++) {
                            if (!this.indicatorStatistics[i]) {
                                const aggRule = this.getAggregatorRule(this.indicatorKeys[i]);
                                this.indicatorStatistics[i] = {
                                    max: new registeredAggregators[AggregationType.MAX]({
                                        key: this.indicatorKeys[i],
                                        field: this.indicatorKeys[i]
                                    }),
                                    min: new registeredAggregators[AggregationType.MIN]({
                                        key: this.indicatorKeys[i],
                                        field: this.indicatorKeys[i]
                                    }),
                                    total: new registeredAggregators[aggRule?.aggregationType ?? AggregationType.SUM]({
                                        key: this.indicatorKeys[i],
                                        field: aggRule?.field ?? this.indicatorKeys[i],
                                        aggregationFun: aggRule?.aggregationFun,
                                        formatFun: aggRule?.formatFun ??
                                            this.indicators?.find((indicator) => {
                                                if (typeof indicator !== 'string') {
                                                    return indicator.indicatorKey === this.indicatorKeys[i];
                                                }
                                                return false;
                                            })?.format
                                    })
                                };
                            }
                            this.indicatorStatistics[i].max.push(this.tree[flatRowKey]?.[flatColKey]?.[i].value());
                            this.indicatorStatistics[i].min.push(this.tree[flatRowKey]?.[flatColKey]?.[i].value());
                            this.indicatorStatistics[i].total.push(record);
                        }
                    }
                }
            }
        }
        updateSortRules(sortRules) {
            this.sorted = false;
            this.sortRules = sortRules;
            this.sortKeys();
            if (!this.customRowTree) {
                if (this.rowHierarchyType === 'tree') {
                    this.rowHeaderTree = this.ArrToTree1(this.rowKeys, this.rows.filter((key, index) => {
                        return this.rowsHasValue[index];
                    }), this.indicatorsAsCol ? undefined : this.indicators, this.totals?.row?.showGrandTotals ||
                        (!this.indicatorsAsCol && this.columns.length === 0) ||
                        (this.indicatorsAsCol && this.rows.length === 0), this.rowGrandTotalLabel, this.totals?.row?.showGrandTotalsOnTop ?? false);
                }
                else {
                    this.rowHeaderTree = this.ArrToTree(this.rowKeys, this.rows.filter((key, index) => {
                        return this.rowsHasValue[index];
                    }), this.indicatorsAsCol ? undefined : this.indicators, this.rowsIsTotal, this.totals?.row?.showGrandTotals || (this.indicatorsAsCol && this.rows.length === 0), this.rowGrandTotalLabel, this.rowSubTotalLabel, this.totals?.row?.showGrandTotalsOnTop ?? false, this.totals?.row?.showSubTotalsOnTop ?? false);
                }
            }
            if (!this.customColTree) {
                this.colHeaderTree = this.ArrToTree(this.colKeys, this.columns.filter((key, index) => {
                    return this.columnsHasValue[index];
                }), this.indicatorsAsCol ? this.indicators : undefined, this.colsIsTotal, this.totals?.column?.showGrandTotals || (!this.indicatorsAsCol && this.columns.length === 0), this.colGrandTotalLabel, this.colSubTotalLabel, this.totals?.column?.showGrandTotalsOnLeft ?? false, this.totals?.column?.showSubTotalsOnLeft ?? false);
            }
        }
        updateFilterRules(filterRules, isResetTree = false) {
            this.filterRules = filterRules;
            this.filteredRecords = undefined;
            if (isResetTree) {
                this.tree = {};
            }
            else {
                for (const treeRowKey in this.tree) {
                    for (const treeColKey in this.tree[treeRowKey]) {
                        for (let i = 0; i < this.tree[treeRowKey][treeColKey].length; i++) {
                            this.tree[treeRowKey][treeColKey][i]?.reset();
                        }
                    }
                }
            }
            this.collectedValues = {};
            this.processRecords();
            this.processCollectedValuesWithSumBy();
            this.processCollectedValuesWithSortBy();
            this.totalStatistics();
            if (this.dataConfig?.isPivotChart) {
                this.cacheDeminsionCollectedValues();
            }
        }
        getAggregatorRule(indicatorKey) {
            return this.aggregationRules?.find((value, index) => {
                return indicatorKey === value.indicatorKey;
            });
        }
        getAggregator(rowKey = [], colKey = [], indicator, considerChangedValue = true, indicatorPosition) {
            const indicatorIndex = this.indicatorKeys.indexOf(indicator);
            let flatRowKey;
            let flatColKey;
            if (typeof rowKey === 'string') {
                flatRowKey = rowKey;
            }
            else {
                if (!indicatorPosition || indicatorPosition.position === 'row') {
                    rowKey.map((key, i) => {
                        if (key === indicator && (!isValid$3(indicatorPosition?.index) || i === indicatorPosition.index)) {
                            rowKey.splice(i, 1);
                        }
                    });
                }
                if (rowKey.length < this.rows.length && this.rowHierarchyType === 'grid-tree') {
                    if (rowKey[0] === this.rowGrandTotalLabel) ;
                    else if (this.totals?.row?.subTotalsDimensions &&
                        this.totals?.row?.subTotalsDimensions?.length >= 1 &&
                        rowKey[rowKey.length - 1] !== this.rowSubTotalLabel) {
                        rowKey.push(this.rowSubTotalLabel);
                    }
                }
                flatRowKey = join(rowKey, this.stringJoinChar);
            }
            if (typeof colKey === 'string') {
                flatColKey = colKey;
            }
            else {
                if (!indicatorPosition || indicatorPosition.position === 'col') {
                    colKey.map((key, i) => {
                        if (key === indicator && (!isValid$3(indicatorPosition?.index) || i === indicatorPosition.index)) {
                            colKey.splice(i, 1);
                        }
                    });
                }
                if (colKey.length < this.columns.length && this.columnHierarchyType === 'grid-tree') {
                    if (colKey[0] === this.colGrandTotalLabel) ;
                    else if (this.totals?.column?.subTotalsDimensions &&
                        this.totals?.column?.subTotalsDimensions?.length >= 1 &&
                        colKey[colKey.length - 1] !== this.colSubTotalLabel) {
                        colKey.push(this.colSubTotalLabel);
                    }
                }
                flatColKey = join(colKey, this.stringJoinChar);
            }
            const agg = this.tree[flatRowKey]?.[flatColKey]?.[indicatorIndex];
            if (considerChangedValue && isValid$3(this.changedTree[flatRowKey]?.[flatColKey]?.[indicatorIndex])) {
                const changeValue = this.changedTree[flatRowKey][flatColKey][indicatorIndex];
                if (agg) {
                    return {
                        value: () => {
                            return changeValue;
                        },
                        formatValue: agg.formatValue,
                        formatFun: agg.formatFun,
                        records: agg.records,
                        recalculate() {
                        },
                        push() {
                        },
                        deleteRecord() {
                        },
                        updateRecord() {
                        },
                        clearCacheValue() {
                        },
                        reset() {
                        }
                    };
                }
                return {
                    records: [],
                    value() {
                        return changeValue;
                    },
                    push() {
                    },
                    deleteRecord() {
                    },
                    updateRecord() {
                    },
                    recalculate() {
                    },
                    formatValue() {
                        return changeValue;
                    },
                    clearCacheValue() {
                    },
                    reset() {
                    }
                };
            }
            return agg
                ? agg
                : {
                    records: [],
                    push() {
                    },
                    deleteRecord() {
                    },
                    updateRecord() {
                    },
                    recalculate() {
                    },
                    value() {
                        return null;
                    },
                    clearCacheValue() {
                    },
                    reset() {
                    }
                };
        }
        sortKeys() {
            this.colKeys = this.colKeys_normal.slice();
            this.rowKeys = this.rowKeys_normal.slice();
            if (!this.sorted) {
                this.sorted = true;
                this.rowKeys.sort(this.arrSort(this.rows, true));
                const sortfun = this.arrSort(this.columns, false);
                this.colKeys.sort(sortfun);
            }
        }
        arrSort(fieldArr, isRow) {
            let field;
            const that = this;
            const sortersArr = function (_this) {
                const results = [];
                for (let l = 0, len1 = fieldArr.length; l < len1; l++) {
                    field = fieldArr[l];
                    if (that.sortRules) {
                        for (let m = 0, len2 = that.sortRules.length; m < len2; m++) {
                            if (that.sortRules[m].sortField === field) {
                                results.push({
                                    field,
                                    fieldIndex: l,
                                    sortRule: that.sortRules[m],
                                    func: that.getSort(that.sortRules[m], isRow)
                                });
                            }
                        }
                    }
                }
                return results;
            }.call(this);
            return function (a, b) {
                let comparison;
                let sorter;
                for (let i = 0; i < sortersArr.length; i++) {
                    sorter = sortersArr[i];
                    if (sorter.sortRule?.sortByIndicator) {
                        let aChanged = a;
                        let bChanged = b;
                        if (sorter.fieldIndex < fieldArr.length - 1) {
                            aChanged = a.slice(0, sorter.fieldIndex + 1);
                            if (that.rowHierarchyType === 'grid' && isRow) {
                                aChanged.push(that.rowSubTotalLabel);
                            }
                            else if (!isRow) {
                                aChanged.push(that.colSubTotalLabel);
                            }
                            bChanged = b.slice(0, sorter.fieldIndex + 1);
                            if (that.rowHierarchyType === 'grid' && isRow) {
                                bChanged.push(that.rowSubTotalLabel);
                            }
                            else if (!isRow) {
                                bChanged.push(that.colSubTotalLabel);
                            }
                        }
                        comparison = sorter.func(aChanged, bChanged, sorter.sortRule?.sortType);
                    }
                    else {
                        comparison = sorter.func?.(a[sorter.fieldIndex], b[sorter.fieldIndex], sorter.sortRule?.sortType);
                    }
                    if (comparison !== 0) {
                        return comparison;
                    }
                }
                return 0;
            };
        }
        getSort(sortRule, isSortRow) {
            const that = this;
            if (sortRule.sortByIndicator) {
                return (a, b, sortType) => {
                    const getValue = function (rowKey, colKey) {
                        if (that.rowHierarchyType === 'grid' &&
                            rowKey.length < that.rows.length &&
                            rowKey[rowKey.length - 1] !== that.rowSubTotalLabel &&
                            rowKey[rowKey.length - 1] !== that.rowGrandTotalLabel) {
                            rowKey.push(that.rowSubTotalLabel);
                        }
                        if (colKey.length < that.columns.length &&
                            colKey[colKey.length - 1] !== that.colSubTotalLabel &&
                            colKey[colKey.length - 1] !== that.colGrandTotalLabel) {
                            colKey.push(that.colSubTotalLabel);
                        }
                        return that.getAggregator(rowKey, colKey, sortRule.sortByIndicator).value();
                    };
                    if (isSortRow) {
                        if (sortRule.sortFunc) {
                            return sortRule.sortFunc(getValue(a, sortRule.query), getValue(b, sortRule.query), a, b, sortType);
                        }
                        return naturalSort(getValue(a, sortRule.query), getValue(b, sortRule.query), sortType);
                    }
                    if (sortRule.sortFunc) {
                        return sortRule.sortFunc(getValue(sortRule.query, a), getValue(sortRule.query, b), a, b, sortType);
                    }
                    return naturalSort(getValue(sortRule.query, a), getValue(sortRule.query, b), sortType);
                };
            }
            else if (sortRule.sortBy) {
                return sortBy(sortRule.sortBy);
            }
            if (sortRule.sortFunc) {
                return sortRule.sortFunc;
            }
            if (sortRule.sortType) {
                return typeSort;
            }
            return naturalSort;
        }
        totalStatistics() {
            const that = this;
            const colCompute = (flatRowKey, flatColKey) => {
                if (this.totalRecordsTree?.[flatRowKey]?.[flatColKey]) {
                    if (!this.tree[flatRowKey]) {
                        this.tree[flatRowKey] = {};
                    }
                    this.tree[flatRowKey][flatColKey] = this.totalRecordsTree?.[flatRowKey]?.[flatColKey];
                    return;
                }
                const colKey = flatColKey.split(this.stringJoinChar);
                if (that.totals?.column?.subTotalsDimensions &&
                    that.totals?.column?.subTotalsDimensions?.length > 0 &&
                    that.totals.column.showSubTotals !== false) {
                    for (let i = 0, len = that.totals?.column?.subTotalsDimensions?.length; i < len; i++) {
                        const dimension = that.totals.column.subTotalsDimensions[i];
                        const dimensionIndex = that.columns.indexOf(dimension);
                        if (dimensionIndex >= 0) {
                            const colTotalKey = colKey.slice(0, dimensionIndex + 1);
                            colTotalKey.push(that.colSubTotalLabel);
                            const flatColTotalKey = colTotalKey.join(this.stringJoinChar);
                            if (this.totalRecordsTree?.[flatRowKey]?.[flatColTotalKey]) {
                                this.tree[flatRowKey][flatColTotalKey] = this.totalRecordsTree?.[flatRowKey]?.[flatColTotalKey];
                                return;
                            }
                            if (!this.tree[flatRowKey][flatColTotalKey]) {
                                this.tree[flatRowKey][flatColTotalKey] = [];
                            }
                            const toComputeIndicatorKeys = this.indicatorKeysIncludeCalculatedFieldDependIndicatorKeys;
                            for (let i = 0; i < toComputeIndicatorKeys.length; i++) {
                                if (this.calculatedFiledKeys.indexOf(toComputeIndicatorKeys[i]) >= 0) {
                                    const calculatedFieldRule = this.calculatedFieldRules?.find(rule => rule.key === toComputeIndicatorKeys[i]);
                                    if (!this.tree[flatRowKey]?.[flatColTotalKey]?.[i]) {
                                        this.tree[flatRowKey][flatColTotalKey][i] = new registeredAggregators[AggregationType.RECALCULATE]({
                                            key: toComputeIndicatorKeys[i],
                                            field: toComputeIndicatorKeys[i],
                                            isRecord: true,
                                            formatFun: this.indicators?.find((indicator) => {
                                                if (typeof indicator !== 'string') {
                                                    return indicator.indicatorKey === toComputeIndicatorKeys[i];
                                                }
                                                return false;
                                            })?.format,
                                            calculateFun: calculatedFieldRule?.calculateFun,
                                            dependAggregators: this.tree[flatRowKey][flatColTotalKey],
                                            dependIndicatorKeys: calculatedFieldRule?.dependIndicatorKeys
                                        });
                                    }
                                    if (flatColTotalKey !== flatColKey) {
                                        this.tree[flatRowKey][flatColTotalKey][i].push(that.tree[flatRowKey]?.[flatColKey]?.[i]);
                                    }
                                }
                                else {
                                    if (!this.tree[flatRowKey][flatColTotalKey][i]) {
                                        const aggRule = this.getAggregatorRule(toComputeIndicatorKeys[i]);
                                        this.tree[flatRowKey][flatColTotalKey][i] = new registeredAggregators[aggRule?.aggregationType ?? AggregationType.SUM]({
                                            key: toComputeIndicatorKeys[i],
                                            field: aggRule?.field ?? toComputeIndicatorKeys[i],
                                            aggregationFun: aggRule?.aggregationFun,
                                            formatFun: aggRule?.formatFun ??
                                                this.indicators?.find((indicator) => {
                                                    if (typeof indicator !== 'string') {
                                                        return indicator.indicatorKey === toComputeIndicatorKeys[i];
                                                    }
                                                    return false;
                                                })?.format
                                        });
                                    }
                                    if (flatColTotalKey !== flatColKey) {
                                        this.tree[flatRowKey][flatColTotalKey][i].push(that.tree[flatRowKey]?.[flatColKey]?.[i]);
                                    }
                                }
                            }
                        }
                    }
                }
                if (that.totals?.column?.showGrandTotals || this.rows.length === 0) {
                    const flatColTotalKey = that.colGrandTotalLabel;
                    if (this.totalRecordsTree?.[flatRowKey]?.[flatColTotalKey]) {
                        this.tree[flatRowKey][flatColTotalKey] = this.totalRecordsTree?.[flatRowKey]?.[flatColTotalKey];
                        return;
                    }
                    if (!this.tree[flatRowKey][flatColTotalKey]) {
                        this.tree[flatRowKey][flatColTotalKey] = [];
                    }
                    const toComputeIndicatorKeys = this.indicatorKeysIncludeCalculatedFieldDependIndicatorKeys;
                    for (let i = 0; i < toComputeIndicatorKeys.length; i++) {
                        if (this.calculatedFiledKeys.indexOf(toComputeIndicatorKeys[i]) >= 0) {
                            const calculatedFieldRule = this.calculatedFieldRules?.find(rule => rule.key === toComputeIndicatorKeys[i]);
                            if (!this.tree[flatRowKey]?.[flatColTotalKey]?.[i]) {
                                this.tree[flatRowKey][flatColTotalKey][i] = new registeredAggregators[AggregationType.RECALCULATE]({
                                    key: toComputeIndicatorKeys[i],
                                    field: toComputeIndicatorKeys[i],
                                    isRecord: true,
                                    formatFun: this.indicators?.find((indicator) => {
                                        if (typeof indicator !== 'string') {
                                            return indicator.indicatorKey === toComputeIndicatorKeys[i];
                                        }
                                        return false;
                                    })?.format,
                                    calculateFun: calculatedFieldRule?.calculateFun,
                                    dependAggregators: this.tree[flatRowKey][flatColTotalKey],
                                    dependIndicatorKeys: calculatedFieldRule?.dependIndicatorKeys
                                });
                            }
                            if (flatColTotalKey !== flatColKey) {
                                this.tree[flatRowKey][flatColTotalKey][i].push(that.tree[flatRowKey]?.[flatColKey]?.[i]);
                            }
                        }
                        else {
                            if (!this.tree[flatRowKey][flatColTotalKey][i]) {
                                const aggRule = this.getAggregatorRule(toComputeIndicatorKeys[i]);
                                this.tree[flatRowKey][flatColTotalKey][i] = new registeredAggregators[aggRule?.aggregationType ?? AggregationType.SUM]({
                                    key: toComputeIndicatorKeys[i],
                                    field: aggRule?.field ?? toComputeIndicatorKeys[i],
                                    formatFun: aggRule?.formatFun ??
                                        this.indicators?.find((indicator) => {
                                            if (typeof indicator !== 'string') {
                                                return indicator.indicatorKey === toComputeIndicatorKeys[i];
                                            }
                                            return false;
                                        })?.format
                                });
                            }
                            if (flatColTotalKey !== flatColKey) {
                                this.tree[flatRowKey][flatColTotalKey][i].push(that.tree[flatRowKey]?.[flatColKey]?.[i]);
                            }
                        }
                    }
                }
            };
            if ((that?.totals?.column?.subTotalsDimensions && that?.totals?.column?.subTotalsDimensions?.length >= 1) ||
                (that?.totals?.row?.subTotalsDimensions && that?.totals?.row?.subTotalsDimensions?.length >= 1) ||
                that?.totals?.column?.showGrandTotals ||
                that?.totals?.row?.showGrandTotals) {
                const rowTotalKeys = [];
                Object.keys(that.tree).forEach(flatRowKey => {
                    const rowKey = flatRowKey.split(this.stringJoinChar);
                    Object.keys(that.tree[flatRowKey]).forEach(flatColKey => {
                        if (that.totals?.row?.subTotalsDimensions &&
                            that.totals?.row?.subTotalsDimensions?.length > 0 &&
                            that.totals.row.showSubTotals !== false) {
                            for (let i = 0, len = that.totals?.row?.subTotalsDimensions?.length; i < len; i++) {
                                const dimension = that.totals.row.subTotalsDimensions[i];
                                const dimensionIndex = that.rows.indexOf(dimension);
                                if (dimensionIndex >= 0 && dimensionIndex < that.rows.length - 1) {
                                    const rowTotalKey = rowKey.slice(0, dimensionIndex + 1);
                                    if (this.rowHierarchyType !== 'tree') {
                                        rowTotalKey.push(that.rowSubTotalLabel);
                                    }
                                    const flatRowTotalKey = rowTotalKey.join(this.stringJoinChar);
                                    if (!this.tree[flatRowTotalKey]) {
                                        this.tree[flatRowTotalKey] = {};
                                        rowTotalKeys.push(flatRowTotalKey);
                                    }
                                    if (!this.tree[flatRowTotalKey][flatColKey]) {
                                        this.tree[flatRowTotalKey][flatColKey] = [];
                                    }
                                    const toComputeIndicatorKeys = this.indicatorKeysIncludeCalculatedFieldDependIndicatorKeys;
                                    for (let i = 0; i < toComputeIndicatorKeys.length; i++) {
                                        if (!this.tree[flatRowTotalKey][flatColKey][i]) {
                                            if (this.calculatedFiledKeys.indexOf(toComputeIndicatorKeys[i]) >= 0) {
                                                const calculatedFieldRule = this.calculatedFieldRules?.find(rule => rule.key === toComputeIndicatorKeys[i]);
                                                this.tree[flatRowTotalKey][flatColKey][i] = new registeredAggregators[AggregationType.RECALCULATE]({
                                                    key: toComputeIndicatorKeys[i],
                                                    field: toComputeIndicatorKeys[i],
                                                    isRecord: true,
                                                    formatFun: this.indicators?.find((indicator) => {
                                                        if (typeof indicator !== 'string') {
                                                            return indicator.indicatorKey === toComputeIndicatorKeys[i];
                                                        }
                                                        return false;
                                                    })?.format,
                                                    calculateFun: calculatedFieldRule?.calculateFun,
                                                    dependAggregators: this.tree[flatRowTotalKey][flatColKey],
                                                    dependIndicatorKeys: calculatedFieldRule?.dependIndicatorKeys
                                                });
                                            }
                                            else {
                                                const aggRule = this.getAggregatorRule(toComputeIndicatorKeys[i]);
                                                this.tree[flatRowTotalKey][flatColKey][i] = new registeredAggregators[aggRule?.aggregationType ?? AggregationType.SUM]({
                                                    key: toComputeIndicatorKeys[i],
                                                    field: aggRule?.field ?? toComputeIndicatorKeys[i],
                                                    formatFun: aggRule?.formatFun ??
                                                        this.indicators?.find((indicator) => {
                                                            if (typeof indicator !== 'string') {
                                                                return indicator.indicatorKey === toComputeIndicatorKeys[i];
                                                            }
                                                            return false;
                                                        })?.format
                                                });
                                            }
                                        }
                                        if (flatRowTotalKey !== flatRowKey) {
                                            this.tree[flatRowTotalKey][flatColKey][i].push(that.tree[flatRowKey]?.[flatColKey]?.[i]);
                                        }
                                    }
                                }
                            }
                        }
                        if (that.totals?.row?.showGrandTotals || this.columns.length === 0) {
                            const flatRowTotalKey = that.rowGrandTotalLabel;
                            if (!this.tree[flatRowTotalKey]) {
                                this.tree[flatRowTotalKey] = {};
                                rowTotalKeys.push(flatRowTotalKey);
                            }
                            if (!this.tree[flatRowTotalKey][flatColKey]) {
                                this.tree[flatRowTotalKey][flatColKey] = [];
                            }
                            const toComputeIndicatorKeys = this.indicatorKeysIncludeCalculatedFieldDependIndicatorKeys;
                            for (let i = 0; i < toComputeIndicatorKeys.length; i++) {
                                if (!this.tree[flatRowTotalKey][flatColKey][i]) {
                                    if (this.calculatedFiledKeys.indexOf(toComputeIndicatorKeys[i]) >= 0) {
                                        const calculatedFieldRule = this.calculatedFieldRules?.find(rule => rule.key === toComputeIndicatorKeys[i]);
                                        this.tree[flatRowTotalKey][flatColKey][i] = new registeredAggregators[AggregationType.RECALCULATE]({
                                            key: toComputeIndicatorKeys[i],
                                            field: toComputeIndicatorKeys[i],
                                            isRecord: true,
                                            formatFun: this.indicators?.find((indicator) => {
                                                if (typeof indicator !== 'string') {
                                                    return indicator.indicatorKey === toComputeIndicatorKeys[i];
                                                }
                                                return false;
                                            })?.format,
                                            calculateFun: calculatedFieldRule?.calculateFun,
                                            dependAggregators: this.tree[flatRowTotalKey][flatColKey],
                                            dependIndicatorKeys: calculatedFieldRule?.dependIndicatorKeys
                                        });
                                    }
                                    else {
                                        const aggRule = this.getAggregatorRule(toComputeIndicatorKeys[i]);
                                        this.tree[flatRowTotalKey][flatColKey][i] = new registeredAggregators[aggRule?.aggregationType ?? AggregationType.SUM]({
                                            key: toComputeIndicatorKeys[i],
                                            field: aggRule?.field ?? toComputeIndicatorKeys[i],
                                            formatFun: aggRule?.formatFun ??
                                                this.indicators?.find((indicator) => {
                                                    if (typeof indicator !== 'string') {
                                                        return indicator.indicatorKey === toComputeIndicatorKeys[i];
                                                    }
                                                    return false;
                                                })?.format
                                        });
                                    }
                                }
                                if (flatRowTotalKey !== flatRowKey) {
                                    this.tree[flatRowTotalKey][flatColKey][i].push(that.tree[flatRowKey]?.[flatColKey]?.[i]);
                                }
                            }
                        }
                        colCompute(flatRowKey, flatColKey);
                    });
                });
                rowTotalKeys.forEach(flatRowKey => {
                    Object.keys(that.tree[flatRowKey]).forEach(flatColKey => {
                        colCompute(flatRowKey, flatColKey);
                    });
                });
            }
            for (const flatRowKey in that.totalRecordsTree) {
                for (const flatColKey in that.totalRecordsTree[flatRowKey]) {
                    colCompute(flatRowKey, flatColKey);
                }
            }
        }
        ArrToTree1(arr, rows, indicators, isGrandTotal, grandTotalLabel, showGrandTotalsOnTop) {
            const result = [];
            const concatStr = this.stringJoinChar;
            const map = new Map();
            function addList(list, isGrandTotal) {
                const path = [];
                let node;
                list.forEach((value, index) => {
                    path.push(value);
                    const flatKey = path.join(concatStr);
                    let item = map.get(flatKey);
                    if (!item) {
                        item = {
                            value,
                            dimensionKey: rows[index],
                            children: index === list.length - 1 && (indicators?.length ?? 0) >= 1
                                ? indicators?.map(indicator => {
                                    if (typeof indicator === 'string') {
                                        return {
                                            indicatorKey: indicator,
                                            value: indicator
                                        };
                                    }
                                    return {
                                        indicatorKey: indicator.indicatorKey,
                                        value: indicator.title
                                    };
                                })
                                : []
                        };
                        map.set(flatKey, item);
                        if (node) {
                            node.children.push(item);
                        }
                        else {
                            if (showGrandTotalsOnTop && isGrandTotal) {
                                result.unshift(item);
                            }
                            else {
                                result.push(item);
                            }
                        }
                    }
                    node = item;
                });
            }
            arr.forEach(item => addList(item, false));
            if (isGrandTotal) {
                addList([grandTotalLabel], isGrandTotal);
            }
            return result;
        }
        ArrToTree(arr, rows, indicators, subTotalFlags, isGrandTotal, grandTotalLabel, subTotalLabel, showGrandTotalsOnTop, showSubTotalsOnTop) {
            let result = [];
            const concatStr = this.stringJoinChar;
            const map = new Map();
            function addList(list) {
                const path = [];
                let node;
                list.forEach((value, index) => {
                    path.push(value);
                    const flatKey = path.join(concatStr);
                    let item = map.get(flatKey);
                    if (!item) {
                        item = {
                            value,
                            dimensionKey: rows[index],
                            children: index === list.length - 1 && (indicators?.length ?? 0) >= 1
                                ? indicators?.map(indicator => {
                                    if (typeof indicator === 'string') {
                                        return {
                                            indicatorKey: indicator,
                                            value: indicator
                                        };
                                    }
                                    return {
                                        indicatorKey: indicator.indicatorKey,
                                        value: indicator.title
                                    };
                                })
                                : []
                        };
                        if (subTotalFlags[index]) {
                            let curChild = item.children ?? [];
                            const totalChild = {
                                value: subTotalLabel,
                                dimensionKey: rows[index + 1],
                                levelSpan: subTotalFlags.length - index - 1,
                                children: (indicators?.length ?? 0) >= 1
                                    ? indicators?.map(indicator => {
                                        if (typeof indicator === 'string') {
                                            return {
                                                indicatorKey: indicator,
                                                value: indicator
                                            };
                                        }
                                        return {
                                            indicatorKey: indicator.indicatorKey,
                                            value: indicator.title
                                        };
                                    })
                                    : [],
                                role: 'sub-total'
                            };
                            curChild.push(totalChild);
                            curChild = totalChild.children ?? [];
                        }
                        map.set(flatKey, item);
                        if (node) {
                            if (subTotalFlags[index - 1] && !showSubTotalsOnTop) {
                                node.children.splice(node.children.length - 1, 0, item);
                            }
                            else {
                                node.children.push(item);
                            }
                        }
                        else {
                            result.push(item);
                        }
                    }
                    node = item;
                });
            }
            if (arr?.length) {
                arr.forEach(item => addList(item));
            }
            else if (indicators) {
                result = indicators?.map((indicator) => {
                    if (typeof indicator === 'string') {
                        return { indicatorKey: indicator, value: indicator };
                    }
                    return { indicatorKey: indicator.indicatorKey, value: indicator.title ?? indicator.indicatorKey };
                });
            }
            if (isGrandTotal && arr?.length) {
                const node = {
                    value: grandTotalLabel,
                    dimensionKey: rows[0],
                    levelSpan: subTotalFlags.length,
                    children: indicators?.map(indicator => {
                        if (typeof indicator === 'string') {
                            return {
                                indicatorKey: indicator,
                                value: indicator
                            };
                        }
                        return {
                            indicatorKey: indicator.indicatorKey,
                            value: indicator.title
                        };
                    }) ?? [],
                    role: 'grand-total'
                };
                if (showGrandTotalsOnTop) {
                    result.unshift(node);
                }
                else {
                    result.push(node);
                }
            }
            return result;
        }
        cacheDeminsionCollectedValues() {
            for (const key in this.collectValuesBy) {
                if (this.collectValuesBy[key].type === 'xField' || this.collectValuesBy[key].type === 'yField') {
                    if (this.dataConfig.dimensionSortArray) {
                        this.cacheCollectedValues[key] = arraySortByAnotherArray(this.collectedValues[key], this.dataConfig.dimensionSortArray);
                    }
                    else {
                        this.cacheCollectedValues[key] = this.collectedValues[key];
                    }
                }
            }
        }
        changeTreeNodeValue(rowKey = [], colKey = [], indicator, newValue) {
            const indicatorIndex = this.indicatorKeys.indexOf(indicator);
            let flatRowKey;
            let flatColKey;
            if (typeof rowKey === 'string') {
                flatRowKey = rowKey;
            }
            else {
                flatRowKey = rowKey.join(this.stringJoinChar);
            }
            if (typeof colKey === 'string') {
                flatColKey = colKey;
            }
            else {
                flatColKey = colKey.join(this.stringJoinChar);
            }
            if (this.changedTree[flatRowKey]?.[flatColKey]) {
                this.changedTree[flatRowKey][flatColKey][indicatorIndex] = newValue;
            }
            else if (this.changedTree[flatRowKey]) {
                this.changedTree[flatRowKey][flatColKey] = [];
                this.changedTree[flatRowKey][flatColKey][indicatorIndex] = newValue;
            }
            else {
                this.changedTree[flatRowKey] = {};
                this.changedTree[flatRowKey][flatColKey] = [];
                this.changedTree[flatRowKey][flatColKey][indicatorIndex] = newValue;
            }
            const cellAggregator = this.tree[flatRowKey]?.[flatColKey]?.[indicatorIndex];
            if (cellAggregator?.records.length === 1) {
                cellAggregator.records[0][this.indicatorKeys[indicatorIndex]] = newValue;
            }
        }
        changeRecordFieldValue(fieldName, oldValue, value) {
            let isIndicatorName = false;
            for (let i = 0; i < this.indicatorKeys.length; i++) {
                if (this.indicatorKeys[i] === fieldName) {
                    isIndicatorName = true;
                }
            }
            if (!isIndicatorName) {
                if (Array.isArray(this.records)) {
                    for (let i = 0, len = this.records.length; i < len; i++) {
                        const record = this.records[i];
                        if (record[fieldName] === oldValue) {
                            record[fieldName] = value;
                        }
                    }
                }
                else {
                    for (const key in this.records) {
                        for (let i = 0, len = this.records[key].length; i < len; i++) {
                            const record = this.records[key][i];
                            if (record[fieldName] === oldValue) {
                                record[fieldName] = value;
                            }
                        }
                    }
                }
                this.rowFlatKeys = {};
                this.colFlatKeys = {};
                this.tree = {};
                this.processRecords();
            }
        }
        _rowTreeHasChanged() {
            if (!this.hasExtensionRowTree) {
                this.customRowTreeDimensionPaths = this.customTreeToDimensionPathArr(this.customRowTree, 'row');
            }
        }
        changeDataConfig(dataConfig) {
            this.rows = dataConfig.rows;
            this.columns = dataConfig.columns;
        }
        addRecords(records) {
            for (let i = 0, len = records.length; i < len; i++) {
                const record = records[i];
                this.processRecord(record);
            }
            if (Array.isArray(this.records)) {
                this.records.push(records);
            }
        }
        customTreeToDimensionPathArr(tree, type) {
            const result = [];
            const that = this;
            function getPath(node, arr) {
                if (!node.virtual) {
                    if (arr[arr.length - 1]?.childKeys &&
                        node.dimensionKey &&
                        arr[arr.length - 1].childKeys.indexOf(node.dimensionKey) === -1 &&
                        node.dimensionKey !== arr[arr.length - 1].dimensionKey) {
                        arr[arr.length - 1].childKeys.push(node.dimensionKey);
                    }
                    arr.push({
                        dimensionKey: isValid$3(node.indicatorKey) ? undefined : node.dimensionKey,
                        value: node.value,
                        indicatorKey: node.indicatorKey,
                        virtual: node.virtual
                    });
                }
                if (node.children?.length > 0) {
                    if (that.rowHierarchyType === 'tree' && type === 'row') {
                        arr[arr.length - 1].childKeys = [];
                        result.push([...arr]);
                    }
                    node.children?.forEach((childItem) => getPath(childItem, [...arr]));
                }
                else {
                    result.push(arr);
                }
            }
            tree?.forEach((treeNode) => getPath(treeNode, []));
            return result;
        }
        getFieldMatchColDimensionPaths(record) {
            const fieldMatchDimensionPaths = [];
            for (let i = 0; i < (this.customColTreeDimensionPaths?.length ?? 0); i++) {
                const dimensionPath = this.customColTreeDimensionPaths[i];
                let isMatch = true;
                for (let j = 0; j < dimensionPath.length; j++) {
                    const dimension = dimensionPath[j];
                    if ((dimension.dimensionKey && record[dimension.dimensionKey] !== dimension.value) ||
                        (dimension.indicatorKey && record[dimension.indicatorKey] === undefined)) {
                        isMatch = false;
                        break;
                    }
                }
                if (isMatch) {
                    fieldMatchDimensionPaths.push(dimensionPath);
                }
            }
            return fieldMatchDimensionPaths;
        }
        getFieldMatchRowDimensionPaths(record) {
            const fieldMatchDimensionPaths = [];
            for (let i = 0; i < (this.customRowTreeDimensionPaths?.length ?? 0); i++) {
                const dimensionPath = this.customRowTreeDimensionPaths[i];
                let isMatch = true;
                for (let j = 0; j < dimensionPath.length; j++) {
                    const dimension = dimensionPath[j];
                    if ((dimension.dimensionKey && record[dimension.dimensionKey] !== dimension.value) ||
                        (dimension.indicatorKey && record[dimension.indicatorKey] === undefined)) {
                        isMatch = false;
                        break;
                    }
                    if (dimension.childKeys && j === dimensionPath.length - 1) {
                        if (dimension.childKeys.length > 0 && dimension.childKeys.find(key => isValid$3(record[key]))) {
                            isMatch = false;
                            break;
                        }
                    }
                }
                if (isMatch) {
                    if (!this.indicatorsAsCol && this.rowHierarchyType === 'tree') {
                        if (!dimensionPath.find(path => {
                            return path.indicatorKey;
                        })) {
                            isMatch = false;
                        }
                    }
                }
                if (isMatch) {
                    fieldMatchDimensionPaths.push(dimensionPath);
                }
            }
            return fieldMatchDimensionPaths;
        }
    }
    function arraySortByAnotherArray(array, sortArray) {
        return array.sort((a, b) => {
            const aIndex = sortArray.indexOf(a);
            const bIndex = sortArray.indexOf(b);
            if (aIndex < bIndex) {
                return -1;
            }
            if (aIndex > bIndex) {
                return 1;
            }
            return 0;
        });
    }

    class PivotTable extends BaseTable {
        layoutNodeId = { seqId: 0 };
        pivotSortState;
        dataset;
        flatDataToObjects;
        constructor(container, options) {
            super(container, options);
            options = this.options;
            if (options) {
                if (!options.rowHierarchyType) {
                    options.rowHierarchyType = 'grid';
                }
                if (!options.columnHierarchyType) {
                    options.columnHierarchyType = 'grid';
                }
                if (options.layout) {
                    Object.assign(options, options.layout);
                }
                this.internalProps.columns = cloneDeep$1(options.columns);
                this.internalProps.rows = cloneDeep$1(options.rows);
                this.internalProps.indicators = cloneDeepSpec(options.indicators);
                options.indicators?.forEach((indicatorDefine, index) => {
                    if (typeof indicatorDefine === 'object' && indicatorDefine?.editor) {
                        this.internalProps.indicators[index].editor = indicatorDefine.editor;
                    }
                });
                this.internalProps.columnTree =
                    options.indicatorsAsCol && !options.columns?.length && !options.columnTree ? [] : cloneDeep$1(options.columnTree);
                this.internalProps.rowTree =
                    !options.indicatorsAsCol && !options.rows?.length && !options.rowTree ? [] : cloneDeep$1(options.rowTree);
                this.internalProps.records = options.records;
                this.pagination = options.pagination;
                this.internalProps.columnResizeType = options.resize?.columnResizeType ?? options.columnResizeType ?? 'column';
                this.internalProps.rowResizeType = options.resize?.rowResizeType ?? options.rowResizeType ?? 'row';
                this.internalProps.dataConfig = cloneDeep$1(options.dataConfig);
                this.internalProps.columnWidthConfig = options.columnWidthConfig;
                this.internalProps.columnWidthConfigForRowHeader = options.columnWidthConfigForRowHeader;
                const records = this.internalProps.records;
                this.internalProps.recordsIsTwoDimensionalArray = false;
                if (records?.[0]?.constructor === Array) {
                    this.internalProps.recordsIsTwoDimensionalArray = true;
                }
                if (options.customConfig?.enableDataAnalysis === false) {
                    const columnDimensionTree = new DimensionTree(this.internalProps.columnTree ?? [], this.layoutNodeId, this.options.columnHierarchyType, this.options.columnHierarchyType !== 'grid' ? this.options.columnExpandLevel ?? 1 : undefined);
                    const rowDimensionTree = new DimensionTree(this.internalProps.rowTree ?? [], this.layoutNodeId, this.options.rowHierarchyType, this.options.rowHierarchyType !== 'grid' ? this.options.rowExpandLevel ?? 1 : undefined);
                    this.internalProps.layoutMap = new PivotHeaderLayoutMap(this, null, columnDimensionTree, rowDimensionTree);
                    if (this.internalProps.recordsIsTwoDimensionalArray === false) {
                        this.flatDataToObjects = new FlatDataToObjects({
                            rows: this.internalProps.layoutMap.fullRowDimensionKeys,
                            columns: this.internalProps.layoutMap.colDimensionKeys,
                            indicators: this.internalProps.layoutMap.indicatorKeys,
                            indicatorsAsCol: this.internalProps.layoutMap.indicatorsAsCol,
                            indicatorDimensionKey: this.internalProps.layoutMap.indicatorDimensionKey
                        }, records);
                    }
                }
                else {
                    const keysResults = parseColKeyRowKeyForPivotTable(this, options);
                    const { rowKeys, columnKeys, indicatorKeys } = keysResults;
                    let { columnDimensionTree, rowDimensionTree } = keysResults;
                    this.dataset = new Dataset(this.internalProps.dataConfig, rowKeys, columnKeys, indicatorKeys, this.internalProps.indicators, options.indicatorsAsCol ?? true, options.records, options.rowHierarchyType, options.columnHierarchyType, this.internalProps.columnTree, this.internalProps.rowTree, false, !!options.extensionRows, !!options.parseCustomTreeToMatchRecords);
                    if (!options.columnTree) {
                        if (options.indicatorsAsCol !== false) {
                            this.dataset.colHeaderTree = supplementIndicatorNodesForCustomTree(this.dataset.colHeaderTree, options.indicators);
                        }
                        options.indicatorsAsCol !== false &&
                            options.indicators &&
                            this.dataset.colHeaderTree &&
                            deleteHideIndicatorNode(this.dataset.colHeaderTree, options.indicators, false, this);
                        columnDimensionTree = new DimensionTree(this.dataset.colHeaderTree ?? [], this.layoutNodeId, this.options.columnHierarchyType, this.options.columnHierarchyType !== 'grid' ? this.options.columnExpandLevel ?? 1 : undefined);
                    }
                    else {
                        if (columnDimensionTree.hasHideNode) {
                            deleteHideIndicatorNode(columnDimensionTree.tree.children, options.indicators, true, this);
                            columnDimensionTree.reset(columnDimensionTree.tree.children);
                        }
                    }
                    if (!options.rowTree) {
                        if (options.indicatorsAsCol === false) {
                            this.dataset.rowHeaderTree = supplementIndicatorNodesForCustomTree(this.dataset.rowHeaderTree, options.indicators);
                        }
                        options.indicatorsAsCol === false &&
                            this.dataset.rowHeaderTree &&
                            options.indicators &&
                            deleteHideIndicatorNode(this.dataset.rowHeaderTree, options.indicators, false, this);
                        rowDimensionTree = new DimensionTree(this.dataset.rowHeaderTree ?? [], this.layoutNodeId, this.options.rowHierarchyType, this.options.rowHierarchyType !== 'grid' ? this.options.rowExpandLevel ?? 1 : undefined);
                    }
                    else {
                        if (rowDimensionTree.hasHideNode) {
                            deleteHideIndicatorNode(rowDimensionTree.tree.children, options.indicators, true, this);
                            rowDimensionTree.reset(rowDimensionTree.tree.children);
                        }
                    }
                    this.internalProps.layoutMap = new PivotHeaderLayoutMap(this, this.dataset, columnDimensionTree, rowDimensionTree);
                }
                this._changePivotSortStateBySortRules();
                if ((options.pivotSortState?.length ?? 0) > 0) {
                    this.pivotSortState = [];
                    this.pivotSortState = options.pivotSortState;
                }
                if (Env.mode !== 'node') {
                    this.editorManager = new EditManager(this);
                }
                this.refreshHeader();
                this.internalProps.useOneRowHeightFillAll = false;
                this.stateManager.initCheckedState(records);
                this.scenegraph.createSceneGraph();
                if (options.title) {
                    const Title = Factory.getComponent('title');
                    this.internalProps.title = new Title(options.title, this);
                    this.scenegraph.resize();
                }
                if (this.options.emptyTip) {
                    if (this.internalProps.emptyTip) {
                        this.internalProps.emptyTip?.resetVisible();
                    }
                    else {
                        const EmptyTip = Factory.getComponent('emptyTip');
                        this.internalProps.emptyTip = new EmptyTip(this.options.emptyTip, this);
                        this.internalProps.emptyTip?.resetVisible();
                    }
                }
                setTimeout(() => {
                    this.fireListeners(TABLE_EVENT_TYPE.INITIALIZED, null);
                }, 0);
            }
        }
        static get EVENT_TYPE() {
            return PIVOT_TABLE_EVENT_TYPE;
        }
        isListTable() {
            return false;
        }
        isPivotTable() {
            return true;
        }
        isPivotChart() {
            return false;
        }
        get recordsCount() {
            return this.records?.length;
        }
        _canResizeColumn(col, row) {
            const ifCan = super._canResizeColumn(col, row);
            if (ifCan) {
                const isSeriesNumber = this.internalProps.layoutMap.isSeriesNumber(col, row);
                if (isSeriesNumber && this.internalProps.rowSeriesNumber.disableColumnResize === true) {
                    return false;
                }
                else if (!this.internalProps.layoutMap.indicatorsAsCol) {
                    const cellDefine = this.internalProps.layoutMap.getBody(col, this.columnHeaderLevelCount);
                    if (cellDefine?.disableColumnResize) {
                        return false;
                    }
                }
            }
            return ifCan;
        }
        updateOption(options) {
            const internalProps = this.internalProps;
            super.updateOption(options);
            if (!options.rowHierarchyType) {
                options.rowHierarchyType = 'grid';
            }
            if (!options.columnHierarchyType) {
                options.columnHierarchyType = 'grid';
            }
            this.layoutNodeId = { seqId: 0 };
            this.internalProps.columns = cloneDeep$1(options.columns);
            this.internalProps.rows = cloneDeep$1(options.rows);
            this.internalProps.indicators = !options.indicators?.length ? [] : cloneDeepSpec(options.indicators);
            options.indicators?.forEach((indicatorDefine, index) => {
                if (typeof indicatorDefine === 'object' && indicatorDefine?.editor) {
                    this.internalProps.indicators[index].editor = indicatorDefine.editor;
                }
            });
            this.internalProps.columnTree =
                options.indicatorsAsCol && !options.columns?.length && !options.columnTree ? [] : cloneDeep$1(options.columnTree);
            this.internalProps.rowTree =
                !options.indicatorsAsCol && !options.rows?.length && !options.rowTree ? [] : cloneDeep$1(options.rowTree);
            options.records && (this.internalProps.records = options.records);
            this.stateManager.initCheckedState(this.internalProps.records);
            this.stateManager.updateDrillState(undefined, undefined, false, false, -1, -1);
            this.pagination = options.pagination;
            internalProps.columnResizeType = options.resize?.columnResizeType ?? options.columnResizeType ?? 'column';
            internalProps.rowResizeType = options.resize?.rowResizeType ?? options.rowResizeType ?? 'row';
            internalProps.dataConfig = cloneDeep$1(options.dataConfig);
            this.internalProps.columnWidthConfig = options.columnWidthConfig;
            this.internalProps.columnWidthConfigForRowHeader = options.columnWidthConfigForRowHeader;
            if (options?.rowHierarchyType !== 'grid' &&
                this.internalProps.layoutMap.rowHierarchyType !== 'grid' &&
                this.internalProps.layoutMap.rowExpandLevel === options?.rowExpandLevel) {
                const beforeRowDimensions = this.internalProps.layoutMap.rowDimensionTree.tree.children;
                this.internalProps.rowTree?.forEach((node, index) => {
                    const beforeRowDimension = beforeRowDimensions.find(item => item.dimensionKey === node.dimensionKey && item.value === node.value);
                    if (beforeRowDimension) {
                        this._syncHierarchyState(beforeRowDimension, node);
                    }
                });
            }
            const records = this.internalProps.records;
            this.internalProps.recordsIsTwoDimensionalArray = false;
            if (records?.[0]?.constructor === Array) {
                this.internalProps.recordsIsTwoDimensionalArray = true;
            }
            if (options.customConfig?.enableDataAnalysis === false) {
                let columnDimensionTree;
                let rowDimensionTree;
                if (options.columnTree) {
                    columnDimensionTree = new DimensionTree(this.internalProps.columnTree ?? [], this.layoutNodeId, this.options.columnHierarchyType, this.options.columnHierarchyType !== 'grid' ? this.options.columnExpandLevel ?? 1 : undefined);
                }
                if (options.rowTree) {
                    rowDimensionTree = new DimensionTree(this.internalProps.rowTree ?? [], this.layoutNodeId, this.options.rowHierarchyType, this.options.rowHierarchyType !== 'grid' ? this.options.rowExpandLevel ?? 1 : undefined);
                }
                internalProps.layoutMap.clearHeaderPathCache();
                internalProps.layoutMap = new PivotHeaderLayoutMap(this, null, columnDimensionTree, rowDimensionTree);
                if (this.internalProps.recordsIsTwoDimensionalArray === false) {
                    this.flatDataToObjects = new FlatDataToObjects({
                        rows: internalProps.layoutMap.fullRowDimensionKeys,
                        columns: internalProps.layoutMap.colDimensionKeys,
                        indicators: internalProps.layoutMap.indicatorKeys,
                        indicatorsAsCol: internalProps.layoutMap.indicatorsAsCol,
                        indicatorDimensionKey: internalProps.layoutMap.indicatorDimensionKey
                    }, records);
                }
            }
            else {
                const keysResults = parseColKeyRowKeyForPivotTable(this, options);
                const { rowKeys, columnKeys, indicatorKeys } = keysResults;
                let { columnDimensionTree, rowDimensionTree } = keysResults;
                this.dataset = new Dataset(internalProps.dataConfig, rowKeys, columnKeys, indicatorKeys, this.internalProps.indicators, options.indicatorsAsCol ?? true, records, options.rowHierarchyType, options.columnHierarchyType, this.internalProps.columnTree, this.internalProps.rowTree, false, !!options.extensionRows, !!options.parseCustomTreeToMatchRecords);
                if (!options.columnTree) {
                    if (options.indicatorsAsCol !== false) {
                        this.dataset.colHeaderTree = supplementIndicatorNodesForCustomTree(this.dataset.colHeaderTree, options.indicators);
                    }
                    options.indicatorsAsCol !== false &&
                        options.indicators &&
                        this.dataset.colHeaderTree &&
                        deleteHideIndicatorNode(this.dataset.colHeaderTree, options.indicators, false, this);
                    columnDimensionTree = new DimensionTree(this.dataset.colHeaderTree ?? [], this.layoutNodeId, this.options.columnHierarchyType, this.options.columnHierarchyType !== 'grid' ? this.options.columnExpandLevel ?? 1 : undefined);
                }
                else {
                    if (columnDimensionTree.hasHideNode) {
                        deleteHideIndicatorNode(columnDimensionTree.tree.children, options.indicators, true, this);
                        columnDimensionTree.reset(columnDimensionTree.tree.children);
                    }
                }
                if (!options.rowTree) {
                    if (options.indicatorsAsCol === false) {
                        this.dataset.rowHeaderTree = supplementIndicatorNodesForCustomTree(this.dataset.rowHeaderTree, options.indicators);
                    }
                    options.indicatorsAsCol === false &&
                        this.dataset.rowHeaderTree &&
                        options.indicators &&
                        deleteHideIndicatorNode(this.dataset.rowHeaderTree, options.indicators, false, this);
                    rowDimensionTree = new DimensionTree(this.dataset.rowHeaderTree ?? [], this.layoutNodeId, this.options.rowHierarchyType, this.options.rowHierarchyType !== 'grid' ? this.options.rowExpandLevel ?? 1 : undefined);
                }
                else {
                    if (rowDimensionTree.hasHideNode) {
                        deleteHideIndicatorNode(rowDimensionTree.tree.children, options.indicators, true, this);
                        rowDimensionTree.reset(rowDimensionTree.tree.children);
                    }
                }
                internalProps.layoutMap = new PivotHeaderLayoutMap(this, this.dataset, columnDimensionTree, rowDimensionTree);
            }
            this._changePivotSortStateBySortRules();
            if ((options.pivotSortState?.length ?? 0) > 0) {
                this.pivotSortState = [];
                this.pivotSortState = options.pivotSortState;
            }
            this.refreshHeader();
            this.internalProps.useOneRowHeightFillAll = false;
            if (internalProps.releaseList) {
                internalProps.releaseList.forEach(releaseObj => releaseObj?.release?.());
                internalProps.releaseList = null;
            }
            this.scenegraph.clearCells();
            this.scenegraph.createSceneGraph();
            if (options.title) {
                const Title = Factory.getComponent('title');
                this.internalProps.title = new Title(options.title, this);
                this.scenegraph.resize();
            }
            if (this.options.emptyTip) {
                if (this.internalProps.emptyTip) {
                    this.internalProps.emptyTip?.resetVisible();
                }
                else {
                    const EmptyTip = Factory.getComponent('emptyTip');
                    this.internalProps.emptyTip = new EmptyTip(this.options.emptyTip, this);
                    this.internalProps.emptyTip?.resetVisible();
                }
            }
            return new Promise(resolve => {
                setTimeout(resolve, 0);
            });
        }
        updatePagination(pagination) {
            this.internalProps.layoutMap.clearHeaderPathCache();
            if (pagination) {
                if (!this.pagination) {
                    this.pagination = { currentPage: 0, perPageCount: 0 };
                }
                typeof pagination.currentPage === 'number' &&
                    pagination.currentPage >= 0 &&
                    (this.pagination.currentPage = pagination.currentPage);
                pagination.perPageCount &&
                    (this.pagination.perPageCount = pagination.perPageCount || this.pagination.perPageCount);
                this.scenegraph.clearCells();
                this.internalProps.layoutMap.setPagination(this.pagination);
                this.refreshRowColCount();
                this.scenegraph.createSceneGraph();
                this.render();
            }
            else if (this.pagination) {
                this.pagination = undefined;
                this.scenegraph.clearCells();
                this.internalProps.layoutMap.setPagination(undefined);
                this.refreshRowColCount();
                this.scenegraph.createSceneGraph();
                this.render();
            }
        }
        refreshHeader() {
            this.setMinMaxLimitWidth(true);
            this.refreshRowColCount();
        }
        refreshRowColCount() {
            const table = this;
            const { layoutMap } = table.internalProps;
            if (!layoutMap) {
                return;
            }
            table.colCount = layoutMap.colCount ?? 0;
            table.rowCount = layoutMap.rowCount ?? 0;
            this.internalProps.frozenColCount = this.options.frozenColCount
                ? this.options.frozenColCount
                : (layoutMap.rowHeaderLevelCount ?? 0) + layoutMap.leftRowSeriesNumberColumnCount;
            table.frozenRowCount = Math.max(layoutMap.headerLevelCount, this.options.frozenRowCount ?? 0);
            if (table.bottomFrozenRowCount !== (this.options.bottomFrozenRowCount ?? 0)) {
                table.bottomFrozenRowCount = this.options.bottomFrozenRowCount ?? 0;
            }
            if (table.rightFrozenColCount !== (this.options.rightFrozenColCount ?? 0)) {
                table.rightFrozenColCount = this.options.rightFrozenColCount ?? 0;
            }
            this.stateManager.setFrozenCol(this.internalProps.frozenColCount);
            this.stateManager.setFrozenRow(this.frozenRowCount);
        }
        _getSortFuncFromHeaderOption(columns, field, fieldKey) {
            return undefined;
        }
        get rowHierarchyType() {
            return this.internalProps.layoutMap.rowHierarchyType;
        }
        get columnHierarchyType() {
            return this.internalProps.layoutMap.columnHierarchyType;
        }
        _syncHierarchyState(sourceNode, targetNode) {
            if (sourceNode.value === targetNode.value && sourceNode.dimensionKey === targetNode.dimensionKey) {
                targetNode.hierarchyState =
                    targetNode.hierarchyState ?? (targetNode?.children ? sourceNode.hierarchyState : undefined);
                targetNode?.children?.forEach((targetChildNode, index) => {
                    if (sourceNode?.children?.[index] && targetChildNode) {
                        const beforeRowDimension = sourceNode.children.find((item) => item.dimensionKey === targetChildNode.dimensionKey && item.value === targetChildNode.value);
                        if (beforeRowDimension) {
                            this._syncHierarchyState(beforeRowDimension, targetChildNode);
                        }
                    }
                });
            }
        }
        getRecordShowIndexByCell(col, row) {
            return undefined;
        }
        getTableIndexByRecordIndex(recordIndex) {
            return undefined;
        }
        getTableIndexByField(field) {
            return undefined;
        }
        getCellAddrByFieldRecord(field, recordIndex) {
            return undefined;
        }
        getBodyIndexByRow(row) {
            const { layoutMap } = this.internalProps;
            return layoutMap.getBodyIndexByRow(row);
        }
        getBodyIndexByCol(col) {
            const { layoutMap } = this.internalProps;
            return layoutMap.getBodyIndexByCol(col);
        }
        getFieldData(field, col, row) {
            const table = this;
            if (table.internalProps.layoutMap.isHeader(col, row)) {
                return undefined;
            }
            if (this.internalProps.recordsIsTwoDimensionalArray) {
                const rowIndex = this.getBodyIndexByRow(row);
                const colIndex = this.getBodyIndexByCol(col);
                return this.records[rowIndex]?.[colIndex];
            }
            else if (this.dataset) {
                const cellDimensionPath = this.internalProps.layoutMap.getCellHeaderPaths(col, row);
                if (cellDimensionPath) {
                    let indicatorPosition;
                    const colKeys = cellDimensionPath.colHeaderPaths
                        ?.filter((path) => {
                        return !path.virtual;
                    })
                        .map((colPath, index) => {
                        if (colPath.indicatorKey) {
                            indicatorPosition = {
                                position: 'col',
                                index
                            };
                        }
                        return colPath.indicatorKey ?? colPath.value;
                    });
                    const rowKeys = cellDimensionPath.rowHeaderPaths
                        ?.filter((path) => {
                        return !path.virtual;
                    })
                        .map((rowPath, index) => {
                        if (rowPath.indicatorKey) {
                            indicatorPosition = {
                                position: 'row',
                                index
                            };
                        }
                        return rowPath.indicatorKey ?? rowPath.value;
                    });
                    const aggregator = this.dataset.getAggregator(rowKeys, colKeys, this.internalProps.layoutMap.getIndicatorKey(col, row), true, indicatorPosition);
                    if (aggregator.records && aggregator.records.length >= 1) {
                        return aggregator.records[0][field];
                    }
                }
            }
            else if (this.flatDataToObjects) {
                const cellDimensionPath = this.internalProps.layoutMap.getCellHeaderPaths(col, row);
                const colKeys = cellDimensionPath.colHeaderPaths.map((colPath) => {
                    return colPath.indicatorKey ?? colPath.value;
                });
                const rowKeys = cellDimensionPath.rowHeaderPaths.map((rowPath) => {
                    return rowPath.indicatorKey ?? rowPath.value;
                });
                const treeNode = this.flatDataToObjects.getTreeNode(rowKeys, colKeys, this.internalProps.layoutMap.getBody(col, row).indicatorKey, false);
                if (treeNode?.record) {
                    return treeNode?.record[field];
                }
            }
        }
        getCellValue(col, row, skipCustomMerge) {
            if (!skipCustomMerge) {
                const customMergeText = this.getCustomMergeValue(col, row);
                if (customMergeText) {
                    return customMergeText;
                }
            }
            if (this.internalProps.layoutMap.isSeriesNumber(col, row)) {
                if (this.internalProps.layoutMap.isSeriesNumberInHeader(col, row)) {
                    const { title } = this.internalProps.layoutMap.getSeriesNumberHeader(col, row);
                    return title;
                }
                const { format } = this.internalProps.layoutMap.getSeriesNumberBody(col, row);
                return typeof format === 'function' ? format(col, row, this) : row - this.columnHeaderLevelCount + 1;
            }
            else if (this.internalProps.layoutMap.isHeader(col, row)) {
                const { title, fieldFormat } = this.internalProps.layoutMap.getHeader(col, row);
                return typeof fieldFormat === 'function' ? fieldFormat(title, col, row, this) : title;
            }
            if (this.internalProps.recordsIsTwoDimensionalArray) {
                const { fieldFormat } = this.internalProps.layoutMap.getBody(col, row);
                const rowIndex = this.getBodyIndexByRow(row);
                const colIndex = this.getBodyIndexByCol(col);
                const dataValue = this.records[rowIndex]?.[colIndex];
                if (typeof fieldFormat === 'function') {
                    const fieldResult = fieldFormat(dataValue, col, row, this);
                    return fieldResult;
                }
                return dataValue;
            }
            else if (this.dataset) {
                const cellDimensionPath = this.internalProps.layoutMap.getCellHeaderPaths(col, row);
                let indicatorPosition;
                const colKeys = cellDimensionPath.colHeaderPaths
                    ?.filter((path) => {
                    return !path.virtual;
                })
                    ?.map((colPath, index) => {
                    if (colPath.indicatorKey) {
                        indicatorPosition = {
                            position: 'col',
                            index
                        };
                    }
                    return colPath.indicatorKey ?? colPath.value;
                });
                const rowKeys = cellDimensionPath.rowHeaderPaths
                    ?.filter((path) => {
                    return !path.virtual;
                })
                    ?.map((rowPath, index) => {
                    if (rowPath.indicatorKey) {
                        indicatorPosition = {
                            position: 'row',
                            index
                        };
                    }
                    return rowPath.indicatorKey ?? rowPath.value;
                });
                const aggregator = this.dataset.getAggregator(rowKeys, colKeys, this.internalProps.layoutMap.getIndicatorKey(col, row), true, indicatorPosition);
                const { fieldFormat } = this.internalProps.layoutMap.getBody(col, row);
                return aggregator.formatValue
                    ? aggregator.formatValue(col, row, this)
                    : typeof fieldFormat === 'function'
                        ? fieldFormat(aggregator?.value(), col, row, this)
                        : aggregator?.value() ?? '';
            }
            else if (this.flatDataToObjects) {
                const cellDimensionPath = this.internalProps.layoutMap.getCellHeaderPaths(col, row);
                const colKeys = cellDimensionPath.colHeaderPaths.map((colPath) => {
                    return colPath.indicatorKey ?? colPath.value;
                });
                const rowKeys = cellDimensionPath.rowHeaderPaths.map((rowPath) => {
                    return rowPath.indicatorKey ?? rowPath.value;
                });
                const valueNode = this.flatDataToObjects.getTreeNode(rowKeys, colKeys, this.internalProps.layoutMap.getBody(col, row).indicatorKey);
                const { fieldFormat } = this.internalProps.layoutMap.getBody(col, row);
                return typeof fieldFormat === 'function'
                    ? fieldFormat(valueNode?.value, col, row, this)
                    : valueNode?.value ?? '';
            }
        }
        getCellOriginValue(col, row) {
            const table = this;
            if (table.internalProps.layoutMap.isHeader(col, row)) {
                const { title } = table.internalProps.layoutMap.getHeader(col, row);
                return typeof title === 'function' ? title() : title;
            }
            if (this.internalProps.recordsIsTwoDimensionalArray) {
                const rowIndex = this.getBodyIndexByRow(row);
                const colIndex = this.getBodyIndexByCol(col);
                const dataValue = this.records[rowIndex]?.[colIndex];
                return dataValue;
            }
            else if (this.dataset) {
                let indicatorPosition;
                const cellDimensionPath = this.internalProps.layoutMap.getCellHeaderPaths(col, row);
                const colKeys = cellDimensionPath.colHeaderPaths
                    ?.filter((path) => {
                    return !path.virtual;
                })
                    .map((colPath, index) => {
                    if (colPath.indicatorKey) {
                        indicatorPosition = {
                            position: 'col',
                            index
                        };
                    }
                    return colPath.indicatorKey ?? colPath.value;
                });
                const rowKeys = cellDimensionPath.rowHeaderPaths
                    ?.filter((path) => {
                    return !path.virtual;
                })
                    .map((rowPath, index) => {
                    if (rowPath.indicatorKey) {
                        indicatorPosition = {
                            position: 'row',
                            index
                        };
                    }
                    return rowPath.indicatorKey ?? rowPath.value;
                });
                const aggregator = this.dataset.getAggregator(rowKeys, colKeys, this.internalProps.layoutMap.getIndicatorKey(col, row), true, indicatorPosition);
                return aggregator.value ? aggregator.value() : undefined;
            }
            else if (this.flatDataToObjects) {
                const cellDimensionPath = this.internalProps.layoutMap.getCellHeaderPaths(col, row);
                const colKeys = cellDimensionPath.colHeaderPaths.map((colPath) => {
                    return colPath.indicatorKey ?? colPath.value;
                });
                const rowKeys = cellDimensionPath.rowHeaderPaths.map((rowPath) => {
                    return rowPath.indicatorKey ?? rowPath.value;
                });
                const treeNode = this.flatDataToObjects.getTreeNode(rowKeys, colKeys, this.internalProps.layoutMap.getBody(col, row).indicatorKey);
                return treeNode?.value;
            }
        }
        getCellRawValue(col, row) {
            const table = this;
            if (table.internalProps.layoutMap.isHeader(col, row)) {
                const { title } = table.internalProps.layoutMap.getHeader(col, row);
                return typeof title === 'function' ? title() : title;
            }
            if (this.internalProps.recordsIsTwoDimensionalArray) {
                const rowIndex = this.getBodyIndexByRow(row);
                const colIndex = this.getBodyIndexByCol(col);
                const dataValue = this.records[rowIndex]?.[colIndex];
                return dataValue;
            }
            else if (this.dataset) {
                let indicatorPosition;
                const cellDimensionPath = this.internalProps.layoutMap.getCellHeaderPaths(col, row);
                const colKeys = cellDimensionPath.colHeaderPaths
                    ?.filter((path) => {
                    return !path.virtual;
                })
                    .map((colPath, index) => {
                    if (colPath.indicatorKey) {
                        indicatorPosition = {
                            position: 'col',
                            index
                        };
                    }
                    return colPath.indicatorKey ?? colPath.value;
                });
                const rowKeys = cellDimensionPath.rowHeaderPaths
                    ?.filter((path) => {
                    return !path.virtual;
                })
                    .map((rowPath, index) => {
                    if (rowPath.indicatorKey) {
                        indicatorPosition = {
                            position: 'row',
                            index
                        };
                    }
                    return rowPath.indicatorKey ?? rowPath.value;
                });
                const aggregator = this.dataset.getAggregator(rowKeys, colKeys, this.internalProps.layoutMap.getIndicatorKey(col, row), false, indicatorPosition);
                return aggregator.value ? aggregator.value() : undefined;
            }
            else if (this.flatDataToObjects) {
                const cellDimensionPath = this.internalProps.layoutMap.getCellHeaderPaths(col, row);
                const colKeys = cellDimensionPath.colHeaderPaths.map((colPath) => {
                    return colPath.indicatorKey ?? colPath.value;
                });
                const rowKeys = cellDimensionPath.rowHeaderPaths.map((rowPath) => {
                    return rowPath.indicatorKey ?? rowPath.value;
                });
                const treeNode = this.flatDataToObjects.getTreeNode(rowKeys, colKeys, this.internalProps.layoutMap.getBody(col, row).indicatorKey, false);
                return treeNode?.value;
            }
        }
        getCellOriginRecord(col, row) {
            const table = this;
            if (table.internalProps.layoutMap.isHeader(col, row)) {
                return undefined;
            }
            if (this.internalProps.recordsIsTwoDimensionalArray) {
                const rowIndex = this.getBodyIndexByRow(row);
                const colIndex = this.getBodyIndexByCol(col);
                const dataValue = this.records[rowIndex]?.[colIndex];
                return dataValue;
            }
            else if (this.dataset) {
                let indicatorPosition;
                const cellDimensionPath = this.internalProps.layoutMap.getCellHeaderPaths(col, row);
                const colKeys = cellDimensionPath.colHeaderPaths
                    ?.filter((path) => {
                    return !path.virtual;
                })
                    .map((colPath, index) => {
                    if (colPath.indicatorKey) {
                        indicatorPosition = {
                            position: 'col',
                            index
                        };
                    }
                    return colPath.indicatorKey ?? colPath.value;
                });
                const rowKeys = cellDimensionPath.rowHeaderPaths
                    ?.filter((path) => {
                    return !path.virtual;
                })
                    .map((rowPath, index) => {
                    if (rowPath.indicatorKey) {
                        indicatorPosition = {
                            position: 'row',
                            index
                        };
                    }
                    return rowPath.indicatorKey ?? rowPath.value;
                });
                const aggregator = this.dataset.getAggregator(rowKeys, colKeys, this.internalProps.layoutMap.getIndicatorKey(col, row), true, indicatorPosition);
                return aggregator.records;
            }
            else if (this.flatDataToObjects) {
                const cellDimensionPath = this.internalProps.layoutMap.getCellHeaderPaths(col, row);
                const colKeys = cellDimensionPath.colHeaderPaths.map((colPath) => {
                    return colPath.indicatorKey ?? colPath.value;
                });
                const rowKeys = cellDimensionPath.rowHeaderPaths.map((rowPath) => {
                    return rowPath.indicatorKey ?? rowPath.value;
                });
                const treeNode = this.flatDataToObjects.getTreeNode(rowKeys, colKeys, this.internalProps.layoutMap.getBody(col, row).indicatorKey);
                return treeNode?.record;
            }
        }
        getCellRawRecord(col, row) {
            const table = this;
            if (table.internalProps.layoutMap.isHeader(col, row)) {
                return undefined;
            }
            if (this.internalProps.recordsIsTwoDimensionalArray) {
                const rowIndex = this.getBodyIndexByRow(row);
                const colIndex = this.getBodyIndexByCol(col);
                const dataValue = this.records[rowIndex]?.[colIndex];
                return dataValue;
            }
            else if (this.dataset) {
                let indicatorPosition;
                const cellDimensionPath = this.internalProps.layoutMap.getCellHeaderPaths(col, row);
                const colKeys = cellDimensionPath.colHeaderPaths
                    ?.filter((path) => {
                    return !path.virtual;
                })
                    .map((colPath, index) => {
                    if (colPath.indicatorKey) {
                        indicatorPosition = {
                            position: 'col',
                            index
                        };
                    }
                    return colPath.indicatorKey ?? colPath.value;
                });
                const rowKeys = cellDimensionPath.rowHeaderPaths
                    ?.filter((path) => {
                    return !path.virtual;
                })
                    .map((rowPath, index) => {
                    if (rowPath.indicatorKey) {
                        indicatorPosition = {
                            position: 'row',
                            index
                        };
                    }
                    return rowPath.indicatorKey ?? rowPath.value;
                });
                const aggregator = this.dataset.getAggregator(rowKeys, colKeys, this.internalProps.layoutMap.getIndicatorKey(col, row), false, indicatorPosition);
                return aggregator.records;
            }
            else if (this.flatDataToObjects) {
                const cellDimensionPath = this.internalProps.layoutMap.getCellHeaderPaths(col, row);
                const colKeys = cellDimensionPath.colHeaderPaths.map((colPath) => {
                    return colPath.indicatorKey ?? colPath.value;
                });
                const rowKeys = cellDimensionPath.rowHeaderPaths.map((rowPath) => {
                    return rowPath.indicatorKey ?? rowPath.value;
                });
                const treeNode = this.flatDataToObjects.getTreeNode(rowKeys, colKeys, this.internalProps.layoutMap.getBody(col, row).indicatorKey, false);
                return treeNode?.record;
            }
        }
        updateSortRules(sortRules, col, row) {
            if (this.internalProps.dataConfig) {
                this.internalProps.dataConfig.sortRules = sortRules;
            }
            else {
                this.internalProps.dataConfig = { sortRules };
            }
            this.dataset.updateSortRules(sortRules);
            this._changePivotSortStateBySortRules();
            const { layoutMap } = this.internalProps;
            layoutMap.resetHeaderTree();
            this.scenegraph.clearCells();
            if (isNumber$4(col) && isNumber$4(row)) {
                if (this.isRowHeader(col, row)) {
                    this.setMinMaxLimitWidth(true);
                    this.internalProps._widthResizedColMap.clear();
                }
                else if (this.isCornerHeader(col, row)) {
                    if (layoutMap.cornerSetting.titleOnDimension === 'column') {
                        this.setMinMaxLimitWidth(true);
                        this.internalProps._widthResizedColMap.clear();
                    }
                    else if (layoutMap.cornerSetting.titleOnDimension === 'row') {
                        this.internalProps._heightResizedRowMap.clear();
                    }
                }
                else if (this.isColumnHeader(col, row)) {
                    this.internalProps._heightResizedRowMap.clear();
                }
                this.refreshRowColCount();
            }
            else {
                this.refreshHeader();
            }
            this.internalProps.useOneRowHeightFillAll = false;
            this.scenegraph.createSceneGraph(true);
            this.render();
        }
        _changePivotSortStateBySortRules() {
            this.pivotSortState = [];
            const sortRules = this.internalProps.dataConfig?.sortRules ?? [];
            for (let i = 0; i < sortRules.length; i++) {
                const sortRule = sortRules[i];
                const dimensions = [];
                if (sortRule.sortByIndicator &&
                    sortRule.sortField ===
                        (this.dataset.indicatorsAsCol
                            ? this.dataset.rows[this.dataset.rows.length - 1]
                            : this.dataset.columns[this.dataset.columns.length - 1])) {
                    for (let j = 0; j < sortRule.query.length; j++) {
                        dimensions.push({
                            dimensionKey: this.dataset.indicatorsAsCol ? this.dataset.columns[j] : this.dataset.rows[j],
                            value: sortRule.query[j]
                        });
                    }
                    dimensions.push({
                        indicatorKey: sortRule.sortByIndicator,
                        value: this.internalProps.layoutMap.getIndicatorInfo(sortRule.sortByIndicator)?.title ??
                            sortRule.sortByIndicator
                    });
                }
                else {
                    dimensions.push({
                        dimensionKey: sortRule.sortField,
                        isPivotCorner: true,
                        value: sortRule.sortField
                    });
                }
                const sortType = sortRule.sortType ? sortRule.sortType.toUpperCase() : 'ASC';
                this.pivotSortState.push({
                    dimensions,
                    order: SortType[sortType]
                });
            }
        }
        _parseColumnWidthConfig(columnWidthConfig) {
            for (let i = 0; i < columnWidthConfig?.length; i++) {
                const item = columnWidthConfig[i];
                const dimensions = item.dimensions;
                const width = item.width;
                const cell = this.getCellAddressByHeaderPaths(dimensions);
                if (cell && cell.col >= this.rowHeaderLevelCount) {
                    const cellPath = this.getCellHeaderPaths(cell.col, this.columnHeaderLevelCount);
                    if (cellPath.colHeaderPaths.length === dimensions.length) {
                        let match = true;
                        for (let i = 0; i < dimensions.length; i++) {
                            const dimension = dimensions[i];
                            const finded = cellPath.colHeaderPaths.findIndex((colPath, index) => {
                                if (colPath.indicatorKey === dimension.indicatorKey) {
                                    return true;
                                }
                                if (colPath.dimensionKey === dimension.dimensionKey && colPath.value === dimension.value) {
                                    return true;
                                }
                                return false;
                            });
                            if (finded < 0) {
                                match = false;
                                break;
                            }
                        }
                        if (match && !this.internalProps._widthResizedColMap.has(cell.col)) {
                            this._setColWidth(cell.col, width);
                            this.internalProps._widthResizedColMap.add(cell.col);
                        }
                    }
                }
                else if (cell && cell.col < this.rowHeaderLevelCount) {
                    if (!this.internalProps._widthResizedColMap.has(cell.col)) {
                        this._setColWidth(cell.col, width);
                        this.internalProps._widthResizedColMap.add(cell.col);
                    }
                }
            }
        }
        _parseColumnWidthConfigForRowHeader(columnWidthConfig) {
            for (let i = 0; i < columnWidthConfig?.length; i++) {
                const item = columnWidthConfig[i];
                const dimensions = item.dimensions;
                const width = item.width;
                const cell = this.getCellAddressByHeaderPaths(dimensions);
                if (cell && cell.col < this.rowHeaderLevelCount) {
                    if (!this.internalProps._widthResizedColMap.has(cell.col)) {
                        this._setColWidth(cell.col, width);
                        this.internalProps._widthResizedColMap.add(cell.col);
                    }
                }
            }
        }
        updatePivotSortState(pivotSortStateConfig) {
            this.pivotSortState = pivotSortStateConfig;
        }
        sort(col, row, order) {
            let dimensions;
            if (this.isCornerHeader(col, row)) {
                const dimensionInfo = this.getHeaderDefine(col, row);
                dimensions = [];
                const dimension = {
                    isPivotCorner: true,
                    dimensionKey: dimensionInfo.value,
                    value: dimensionInfo.value
                };
                dimensions.push(dimension);
            }
            else if (this.isColumnHeader(col, row)) {
                dimensions = this.getCellHeaderPaths(col, row).colHeaderPaths;
            }
            else {
                dimensions = this.getCellHeaderPaths(col, row).rowHeaderPaths;
            }
            const sortIndicator = dimensions[dimensions.length - 1].indicatorKey;
            const headerDefine = this.getHeaderDefine(col, row);
            if (headerDefine.sort) {
                if (this.dataset.sortRules) {
                    const cacheOldDimensionSortRule = {};
                    for (let i = this.dataset.sortRules.length - 1; i >= 0; i--) {
                        const sortRule = this.dataset.sortRules[i];
                        if (headerDefine.dimensionKey && sortRule.sortField === headerDefine.dimensionKey) {
                            cacheOldDimensionSortRule[sortRule.sortField] = sortRule;
                            this.dataset.sortRules.splice(i, 1);
                        }
                        else if (sortIndicator &&
                            sortRule.sortField ===
                                (this.dataset.indicatorsAsCol
                                    ? this.dataset.rows[this.dataset.rows.length - 1]
                                    : this.dataset.columns[this.dataset.columns.length - 1])) {
                            cacheOldDimensionSortRule[sortRule.sortField] = sortRule;
                            this.dataset.sortRules.splice(i, 1);
                        }
                    }
                    if (sortIndicator) {
                        const sortField = this.dataset.indicatorsAsCol
                            ? this.dataset.rows[this.dataset.rows.length - 1]
                            : this.dataset.columns[this.dataset.columns.length - 1];
                        this.dataset.sortRules.push({
                            sortField,
                            sortType: SortType[order],
                            sortByIndicator: sortIndicator,
                            query: dimensions.reduce((arr, dimension) => {
                                if (dimension.dimensionKey) {
                                    arr.push(dimension.value);
                                }
                                return arr;
                            }, []),
                            sortFunc: cacheOldDimensionSortRule[sortField]?.sortFunc
                        });
                    }
                    else {
                        this.dataset.sortRules.push(Object.assign(cacheOldDimensionSortRule[headerDefine.dimensionKey] ?? {}, {
                            sortField: headerDefine.dimensionKey,
                            sortType: SortType[order]
                        }));
                    }
                }
                else {
                    if (sortIndicator) {
                        this.dataset.sortRules = [
                            {
                                sortField: this.dataset.indicatorsAsCol
                                    ? this.dataset.rows[this.dataset.rows.length - 1]
                                    : this.dataset.columns[this.dataset.columns.length - 1],
                                sortType: SortType[order],
                                sortByIndicator: sortIndicator,
                                query: dimensions.reduce((arr, dimension) => {
                                    if (dimension.dimensionKey) {
                                        arr.push(dimension.value);
                                    }
                                    return arr;
                                }, [])
                            }
                        ];
                    }
                    else {
                        this.dataset.sortRules = [
                            {
                                sortField: headerDefine.dimensionKey,
                                sortType: SortType[order]
                            }
                        ];
                    }
                }
                this.updateSortRules(this.dataset.sortRules, col, row);
            }
        }
        getPivotSortState(col, row) {
            if (!this.pivotSortState) {
                return undefined;
            }
            const cellRange = this.getCellRange(col, row);
            for (let i = 0; i < this.pivotSortState.length; i++) {
                const pivotState = this.pivotSortState[i];
                const dimensions = pivotState.dimensions;
                const cell = this.getCellAddressByHeaderPaths(dimensions);
                const order = pivotState.order;
                if (cell && cellInRange(cellRange, cell.col, cell.row)) {
                    return order;
                }
            }
            return undefined;
        }
        _moveHeaderPosition(source, target) {
            const sourceCellRange = this.getCellRange(source.col, source.row);
            const targetCellRange = this.getCellRange(target.col, target.row);
            const moveContext = this.internalProps.layoutMap.moveHeaderPosition(source, target);
            if (moveContext) {
                if (moveContext.moveType === 'column') {
                    if (this.internalProps.recordsIsTwoDimensionalArray) {
                        for (let row = 0; row < this.internalProps.records.length; row++) {
                            const sourceColumns = this.internalProps.records[row].splice(moveContext.sourceIndex - this.rowHeaderLevelCount, moveContext.sourceSize);
                            sourceColumns.unshift(moveContext.targetIndex - this.rowHeaderLevelCount, 0);
                            Array.prototype.splice.apply(this.internalProps.records[row], sourceColumns);
                        }
                    }
                    this.colWidthsMap.exchangeOrder(sourceCellRange.start.col, sourceCellRange.end.col - sourceCellRange.start.col + 1, targetCellRange.start.col, targetCellRange.end.col - targetCellRange.start.col + 1, moveContext.targetIndex);
                    this.setMinMaxLimitWidth();
                }
                else if (moveContext.moveType === 'row') {
                    if (this.internalProps.recordsIsTwoDimensionalArray) {
                        const sourceRows = this.internalProps.records.splice(moveContext.sourceIndex - this.columnHeaderLevelCount, moveContext.sourceSize);
                        sourceRows.unshift(moveContext.targetIndex - this.columnHeaderLevelCount, 0);
                        Array.prototype.splice.apply(this.internalProps.records, sourceRows);
                    }
                    if (moveContext.targetIndex > moveContext.sourceIndex) {
                        this.rowHeightsMap.exchangeOrder(moveContext.sourceIndex, moveContext.sourceSize, moveContext.targetIndex + moveContext.sourceSize - moveContext.targetSize, moveContext.targetSize, moveContext.targetIndex);
                    }
                    else {
                        this.rowHeightsMap.exchangeOrder(moveContext.sourceIndex, moveContext.sourceSize, moveContext.targetIndex, moveContext.targetSize, moveContext.targetIndex);
                    }
                }
                return moveContext;
            }
            return null;
        }
        toggleHierarchyState(col, row, recalculateColWidths = true) {
            this.internalProps.layoutMap.clearHeaderPathCache();
            const hierarchyState = this.getHierarchyState(col, row);
            if (hierarchyState === HierarchyState.expand) {
                this._refreshHierarchyState(col, row, recalculateColWidths);
                this.fireListeners(PIVOT_TABLE_EVENT_TYPE.TREE_HIERARCHY_STATE_CHANGE, {
                    col: col,
                    row: row,
                    hierarchyState: HierarchyState.collapse
                });
            }
            else if (hierarchyState === HierarchyState.collapse) {
                const headerTreeNode = this.internalProps.layoutMap.getHeadNode(col, row);
                if (Array.isArray(headerTreeNode.children)) {
                    this._refreshHierarchyState(col, row, recalculateColWidths);
                }
                this.fireListeners(PIVOT_TABLE_EVENT_TYPE.TREE_HIERARCHY_STATE_CHANGE, {
                    col: col,
                    row: row,
                    hierarchyState: HierarchyState.expand,
                    originData: headerTreeNode
                });
            }
        }
        _refreshHierarchyState(col, row, recalculateColWidths = true, beforeUpdateCell) {
            this.frozenColCount;
            this.frozenRowCount;
            const visibleStartRow = this.getBodyVisibleRowRange().rowStart;
            this.internalProps._oldRowCount = this.rowCount;
            this.internalProps._oldColCount = this.colCount;
            let notFillWidth = false;
            let notFillHeight = false;
            this.stateManager.updateHoverIcon(col, row, undefined, undefined);
            const checkHasChart = this.internalProps.layoutMap.checkHasChart();
            if (checkHasChart) {
                if (this.autoFillWidth) {
                    notFillWidth = this.getAllColsWidth() <= this.tableNoFrameWidth;
                }
                if (this.autoFillHeight) {
                    notFillHeight = this.getAllRowsHeight() <= this.tableNoFrameHeight;
                }
            }
            const isChangeRowTree = this.internalProps.layoutMap.isRowHeader(col, row);
            const result = isChangeRowTree
                ? this.internalProps.layoutMap.toggleHierarchyState(col, row)
                : this.internalProps.layoutMap.toggleHierarchyStateForColumnTree(col, row);
            beforeUpdateCell && beforeUpdateCell();
            this.refreshRowColCount();
            this.frozenColCount;
            this.frozenRowCount;
            this.clearCellStyleCache();
            if (this.rowHierarchyType === 'tree') {
                this.scenegraph.updateHierarchyIcon(col, row);
            }
            this.reactCustomLayout?.clearCache();
            if (this.rowHierarchyType !== 'grid-tree' && this.columnHierarchyType !== 'grid-tree') {
                this.scenegraph.updateRow(result.removeCellPositionsRowDirection, result.addCellPositionsRowDirection, result.updateCellPositionsRowDirection, recalculateColWidths);
            }
            else {
                this.internalProps.stick.changedCells.clear();
                this.scenegraph.clearCells();
                this.clearCellStyleCache();
                this.scenegraph.createSceneGraph();
                this.scrollToRow(visibleStartRow);
            }
            this.reactCustomLayout?.updateAllCustomCell();
            if (checkHasChart) {
                if (this.autoFillWidth && !notFillWidth) {
                    notFillWidth = this.getAllColsWidth() <= this.tableNoFrameWidth;
                }
                if (this.autoFillHeight && !notFillHeight) {
                    notFillHeight = this.getAllRowsHeight() <= this.tableNoFrameHeight;
                }
                if (this.widthMode === 'adaptive' || notFillWidth || this.heightMode === 'adaptive' || notFillHeight) {
                    this.scenegraph.updateChartSizeForResizeColWidth(-1);
                }
            }
            this.internalProps._oldRowCount = undefined;
            this.internalProps._oldColCount = undefined;
        }
        getHeaderCellAddressByPath(dimensionPaths) {
            const cellAddress = this.internalProps.layoutMap.getPivotCellAdress(dimensionPaths);
            return cellAddress;
        }
        getCellAddressByHeaderPaths(dimensionPaths) {
            const cellAddress = this.internalProps.layoutMap.getCellAdressByHeaderPath(dimensionPaths);
            return cellAddress;
        }
        getHeaderPathByXY(coordinate) {
            let cellAddr;
            if (coordinate) {
                cellAddr = this.getCellAt(coordinate.x + this.getFrozenColsWidth() + this.scrollLeft + 1, coordinate.y + this.getFrozenRowsHeight() + this.scrollTop + 1);
            }
            else {
                cellAddr = this.getCellAt(this.getFrozenColsWidth() + this.scrollLeft + 1, this.getFrozenRowsHeight() + this.scrollTop + 1);
            }
            const cellHeaderPaths = this.internalProps.layoutMap.getCellHeaderPaths(cellAddr.col, cellAddr.row);
            return cellHeaderPaths;
        }
        getHierarchyState(col, row) {
            return this._getHeaderLayoutMap(col, row)?.hierarchyState;
        }
        getLayoutColumnTree() {
            const layoutMap = this.internalProps.layoutMap;
            return layoutMap.getLayoutColumnTree();
        }
        getLayoutColumnTreeCount() {
            const layoutMap = this.internalProps.layoutMap;
            return layoutMap.getLayoutColumnTreeCount();
        }
        getLayoutRowTree() {
            const layoutMap = this.internalProps.layoutMap;
            return layoutMap.getLayoutRowTree();
        }
        getLayoutRowTreeCount() {
            const layoutMap = this.internalProps.layoutMap;
            return layoutMap.getLayoutRowTreeCount();
        }
        getCellHeaderTreeNodes(col, row) {
            const layoutMap = this.internalProps.layoutMap;
            const headerNodes = layoutMap.getCellHeaderPathsWithTreeNode(col, row);
            return headerNodes;
        }
        getMenuInfo(col, row, type) {
            const dimensionInfos = this.internalProps.layoutMap.getPivotDimensionInfo(col, row);
            const result = {
                dimensionKey: dimensionInfos[dimensionInfos.length - 1].dimensionKey,
                value: this.getCellValue(col, row),
                cellLocation: this.getCellLocation(col, row),
                isPivotCorner: this.isCornerHeader(col, row),
                event: undefined
            };
            return result;
        }
        setRecords(records) {
            clearChartRenderQueue();
            const oldHoverState = { col: this.stateManager.hover.cellPos.col, row: this.stateManager.hover.cellPos.row };
            this.options.records = this.internalProps.records = records;
            this.internalProps.recordsIsTwoDimensionalArray = false;
            if (records?.[0]?.constructor === Array) {
                this.internalProps.recordsIsTwoDimensionalArray = true;
            }
            const options = this.options;
            const internalProps = this.internalProps;
            if (this.options.customConfig?.enableDataAnalysis === false) {
                if (this.internalProps.recordsIsTwoDimensionalArray === false) {
                    this.flatDataToObjects = new FlatDataToObjects({
                        rows: internalProps.layoutMap.fullRowDimensionKeys,
                        columns: internalProps.layoutMap.colDimensionKeys,
                        indicators: internalProps.layoutMap.indicatorKeys,
                        indicatorsAsCol: internalProps.layoutMap.indicatorsAsCol,
                        indicatorDimensionKey: internalProps.layoutMap.indicatorDimensionKey
                    }, records);
                }
            }
            else {
                this.dataset.setRecords(records);
                let columnDimensionTree;
                let rowDimensionTree;
                if (options.columnTree) {
                    columnDimensionTree = internalProps.layoutMap.columnDimensionTree;
                }
                else {
                    options.indicatorsAsCol !== false &&
                        options.indicators &&
                        this.dataset.colHeaderTree &&
                        deleteHideIndicatorNode(this.dataset.colHeaderTree, options.indicators, false, this);
                    columnDimensionTree = new DimensionTree(this.dataset.colHeaderTree ?? [], this.layoutNodeId, this.options.columnHierarchyType, this.options.columnHierarchyType !== 'grid' ? this.options.columnExpandLevel ?? 1 : undefined);
                }
                if (options.rowTree) {
                    rowDimensionTree = internalProps.layoutMap.rowDimensionTree;
                }
                else {
                    options.indicatorsAsCol === false &&
                        this.dataset.rowHeaderTree &&
                        options.indicators &&
                        deleteHideIndicatorNode(this.dataset.rowHeaderTree, options.indicators, false, this);
                    rowDimensionTree = new DimensionTree(this.dataset.rowHeaderTree ?? [], this.layoutNodeId, this.options.rowHierarchyType, this.options.rowHierarchyType !== 'grid' ? this.options.rowExpandLevel ?? 1 : undefined);
                }
                internalProps.layoutMap = new PivotHeaderLayoutMap(this, this.dataset, columnDimensionTree, rowDimensionTree);
                this.pivotSortState = [];
                if (options.pivotSortState) {
                    this.pivotSortState = options.pivotSortState;
                }
            }
            this.refreshHeader();
            this.internalProps.useOneRowHeightFillAll = false;
            this.scenegraph.clearCells();
            this.clearCellStyleCache();
            this.scenegraph.createSceneGraph();
            this.stateManager.updateHoverPos(oldHoverState.col, oldHoverState.row);
            if (this.internalProps.title && !this.internalProps.title.isReleased) {
                this._updateSize();
                this.internalProps.title.resize();
                this.scenegraph.resize();
            }
            this.eventManager.updateEventBinder();
            if (this.options.emptyTip) {
                if (this.internalProps.emptyTip) {
                    this.internalProps.emptyTip?.resetVisible();
                }
                else {
                    const EmptyTip = Factory.getComponent('emptyTip');
                    this.internalProps.emptyTip = new EmptyTip(this.options.emptyTip, this);
                    this.internalProps.emptyTip?.resetVisible();
                }
            }
        }
        startEditCell(col, row, value) {
            if (isValid$3(col) && isValid$3(row)) {
                this.eventManager.isDraging = false;
                this.selectCell(col, row);
                this.editorManager.startEditCell(col, row, value);
            }
            else if (this.stateManager.select?.cellPos) {
                const { col, row } = this.stateManager.select.cellPos;
                if (isValid$3(col) && isValid$3(row)) {
                    this.editorManager.startEditCell(col, row, value);
                }
            }
        }
        completeEditCell() {
            this.editorManager.completeEdit();
        }
        getEditor(col, row) {
            let editorDefine;
            if (this.isCornerHeader(col, row)) {
                const define = this.getHeaderDefine(col, row);
                editorDefine = define?.headerEditor ?? this.options.headerEditor;
            }
            else if (this.isHeader(col, row)) {
                const define = this.getHeaderDefine(col, row);
                editorDefine = define?.headerEditor ?? this.options.headerEditor;
            }
            else {
                const define = this.getBodyColumnDefine(col, row);
                editorDefine = define?.editor ?? this.options.editor;
            }
            if (typeof editorDefine === 'function') {
                const arg = {
                    col,
                    row,
                    dataValue: this.getCellOriginValue(col, row),
                    value: this.getCellValue(col, row) || '',
                    table: this
                };
                editorDefine = editorDefine(arg);
            }
            if (typeof editorDefine === 'string') {
                return get(editorDefine);
            }
            return editorDefine;
        }
        isHasEditorDefine(col, row) {
            const define = this.getBodyColumnDefine(col, row);
            let editorDefine = define?.editor ?? this.options.editor;
            if (typeof editorDefine === 'function') {
                const arg = {
                    col,
                    row,
                    dataValue: this.getCellOriginValue(col, row),
                    value: this.getCellValue(col, row) || '',
                    table: this
                };
                editorDefine = editorDefine(arg);
            }
            return isValid$3(editorDefine);
        }
        changeCellValue(col, row, value, workOnEditableCell = false) {
            if ((workOnEditableCell && this.isHasEditorDefine(col, row)) || workOnEditableCell === false) {
                let newValue = value;
                const oldValue = this.getCellOriginValue(col, row);
                const rawValue = this.getCellRawValue(col, row);
                if (typeof rawValue === 'number' && isAllDigits(value)) {
                    newValue = parseFloat(value);
                }
                this._changeCellValueToDataSet(col, row, oldValue, newValue);
                const range = this.getCellRange(col, row);
                for (let sCol = range.start.col; sCol <= range.end.col; sCol++) {
                    for (let sRow = range.start.row; sRow <= range.end.row; sRow++) {
                        this.scenegraph.updateCellContent(sCol, sRow);
                    }
                }
                if (this.widthMode === 'adaptive' || (this.autoFillWidth && this.getAllColsWidth() <= this.tableNoFrameWidth)) {
                    if (this.internalProps._widthResizedColMap.size === 0) {
                        this.scenegraph.recalculateColWidths();
                    }
                }
                else if (!this.internalProps._widthResizedColMap.has(col)) {
                    const oldWidth = this.getColWidth(col);
                    const newWidth = computeColWidth(col, 0, this.rowCount - 1, this, false);
                    if (newWidth !== oldWidth) {
                        this.scenegraph.updateColWidth(col, newWidth - oldWidth);
                    }
                }
                if (this.heightMode === 'adaptive' ||
                    (this.autoFillHeight && this.getAllRowsHeight() <= this.tableNoFrameHeight)) {
                    if (this.internalProps._heightResizedRowMap.size === 0) {
                        this.scenegraph.recalculateRowHeights();
                    }
                }
                else if (this.isAutoRowHeight(row) && !this.internalProps._heightResizedRowMap.has(row)) {
                    const oldHeight = this.getRowHeight(row);
                    const newHeight = computeRowHeight(row, 0, this.colCount - 1, this);
                    this.scenegraph.updateRowHeight(row, newHeight - oldHeight);
                }
                if (oldValue !== newValue) {
                    this.fireListeners(TABLE_EVENT_TYPE.CHANGE_CELL_VALUE, {
                        col,
                        row,
                        rawValue,
                        currentValue: oldValue,
                        changedValue: newValue
                    });
                }
                this.scenegraph.updateNextFrame();
            }
        }
        changeCellValues(startCol, startRow, values, workOnEditableCell = false) {
            let pasteColEnd = startCol;
            let pasteRowEnd = startRow;
            const beforeChangeValues = [];
            const oldValues = [];
            for (let i = 0; i < values.length; i++) {
                if (startRow + i > this.rowCount - 1) {
                    break;
                }
                const rowValues = values[i];
                const rawRowValues = [];
                const oldRowValues = [];
                beforeChangeValues.push(rawRowValues);
                oldValues.push(oldRowValues);
                for (let j = 0; j < rowValues.length; j++) {
                    if (startCol + j > this.colCount - 1) {
                        break;
                    }
                    const beforeChangeValue = this.getCellRawValue(startCol + j, startRow + i);
                    rawRowValues.push(beforeChangeValue);
                    const oldValue = this.getCellOriginValue(startCol + j, startRow + i);
                    oldRowValues.push(oldValue);
                }
            }
            for (let i = 0; i < values.length; i++) {
                if (startRow + i > this.rowCount - 1) {
                    break;
                }
                pasteRowEnd = startRow + i;
                const rowValues = values[i];
                let thisRowPasteColEnd = startCol;
                for (let j = 0; j < rowValues.length; j++) {
                    if (startCol + j > this.colCount - 1) {
                        break;
                    }
                    thisRowPasteColEnd = startCol + j;
                    if ((workOnEditableCell && this.isHasEditorDefine(startCol + j, startRow + i)) ||
                        workOnEditableCell === false) {
                        const value = rowValues[j];
                        let newValue = value;
                        const oldValue = oldValues[i][j];
                        const rawValue = beforeChangeValues[i][j];
                        if (typeof rawValue === 'number' && isAllDigits(value)) {
                            newValue = parseFloat(value);
                        }
                        this._changeCellValueToDataSet(startCol + j, startRow + i, oldValue, newValue);
                        const changedValue = this.getCellOriginValue(startCol + j, startRow + i);
                        if (changedValue !== oldValue) {
                            this.fireListeners(TABLE_EVENT_TYPE.CHANGE_CELL_VALUE, {
                                col: startCol + j,
                                row: startRow + i,
                                rawValue,
                                currentValue: oldValue,
                                changedValue
                            });
                        }
                    }
                }
                pasteColEnd = Math.max(pasteColEnd, thisRowPasteColEnd);
            }
            const startRange = this.getCellRange(startCol, startRow);
            const range = this.getCellRange(pasteColEnd, pasteRowEnd);
            for (let sCol = startRange.start.col; sCol <= range.end.col; sCol++) {
                for (let sRow = startRange.start.row; sRow <= range.end.row; sRow++) {
                    this.scenegraph.updateCellContent(sCol, sRow);
                }
            }
            if (this.widthMode === 'adaptive' || (this.autoFillWidth && this.getAllColsWidth() <= this.tableNoFrameWidth)) {
                if (this.internalProps._widthResizedColMap.size === 0) {
                    this.scenegraph.recalculateColWidths();
                }
            }
            else {
                for (let sCol = startCol; sCol <= range.end.col; sCol++) {
                    if (!this.internalProps._widthResizedColMap.has(sCol)) {
                        const oldWidth = this.getColWidth(sCol);
                        const newWidth = computeColWidth(sCol, 0, this.rowCount - 1, this, false);
                        if (newWidth !== oldWidth) {
                            this.scenegraph.updateColWidth(sCol, newWidth - oldWidth);
                        }
                    }
                }
            }
            if (this.heightMode === 'adaptive' || (this.autoFillHeight && this.getAllRowsHeight() <= this.tableNoFrameHeight)) {
                this.scenegraph.recalculateRowHeights();
            }
            else if (this.isAutoRowHeight(startRow)) {
                const rows = [];
                const deltaYs = [];
                for (let sRow = startRow; sRow <= range.end.row; sRow++) {
                    if (this.rowHeightsMap.get(sRow)) {
                        const oldHeight = this.getRowHeight(sRow);
                        const newHeight = computeRowHeight(sRow, 0, this.colCount - 1, this);
                        rows.push(sRow);
                        deltaYs.push(newHeight - oldHeight);
                    }
                }
                this.scenegraph.updateRowsHeight(rows, deltaYs);
            }
            this.scenegraph.updateNextFrame();
        }
        _changeCellValueToDataSet(col, row, oldValue, newValue) {
            if (this.internalProps.recordsIsTwoDimensionalArray) {
                const rowIndex = this.getBodyIndexByRow(row);
                const colIndex = this.getBodyIndexByCol(col);
                this.records[rowIndex][colIndex] = newValue;
            }
            else if (this.dataset) {
                const cellDimensionPath = this.internalProps.layoutMap.getCellHeaderPaths(col, row);
                if (this.isCornerHeader(col, row)) {
                    this.internalProps.layoutMap.changeCornerTitle(col, row, newValue);
                }
                else if (this.isHeader(col, row)) {
                    this.internalProps.layoutMap.changeTreeNodeTitle(col, row, newValue);
                    !this.isCornerHeader(col, row) &&
                        this.dataset.changeRecordFieldValue(cellDimensionPath.colHeaderPaths?.length
                            ? cellDimensionPath.colHeaderPaths[cellDimensionPath.colHeaderPaths.length - 1].indicatorKey ??
                                cellDimensionPath.colHeaderPaths[cellDimensionPath.colHeaderPaths.length - 1].dimensionKey
                            : cellDimensionPath.rowHeaderPaths[cellDimensionPath.rowHeaderPaths.length - 1].indicatorKey ??
                                cellDimensionPath.rowHeaderPaths[cellDimensionPath.rowHeaderPaths.length - 1].dimensionKey, oldValue, newValue);
                }
                else {
                    const colKeys = cellDimensionPath.colHeaderPaths
                        ?.filter((path) => {
                        return !path.virtual;
                    })
                        .map((colPath) => {
                        return colPath.indicatorKey ?? colPath.value;
                    });
                    const rowKeys = cellDimensionPath.rowHeaderPaths
                        ?.filter((path) => {
                        return !path.virtual;
                    })
                        .map((rowPath) => {
                        return rowPath.indicatorKey ?? rowPath.value;
                    });
                    this.dataset.changeTreeNodeValue(!this.internalProps.layoutMap.indicatorsAsCol ? rowKeys.slice(0, -1) : rowKeys, this.internalProps.layoutMap.indicatorsAsCol ? colKeys.slice(0, -1) : colKeys, this.internalProps.layoutMap.getIndicatorKey(col, row), newValue);
                }
            }
            else if (this.flatDataToObjects) {
                const cellDimensionPath = this.internalProps.layoutMap.getCellHeaderPaths(col, row);
                if (this.isHeader(col, row)) {
                    this.internalProps.layoutMap.changeTreeNodeTitle(col, row, newValue);
                    !this.isCornerHeader(col, row) &&
                        this.flatDataToObjects.changeRecordFieldValue(cellDimensionPath.colHeaderPaths?.length
                            ? cellDimensionPath.colHeaderPaths[cellDimensionPath.colHeaderPaths.length - 1].indicatorKey ??
                                cellDimensionPath.colHeaderPaths[cellDimensionPath.colHeaderPaths.length - 1].dimensionKey
                            : cellDimensionPath.rowHeaderPaths[cellDimensionPath.rowHeaderPaths.length - 1].indicatorKey ??
                                cellDimensionPath.rowHeaderPaths[cellDimensionPath.rowHeaderPaths.length - 1].dimensionKey, oldValue, newValue);
                }
                else {
                    const colKeys = cellDimensionPath.colHeaderPaths.map((colPath) => {
                        return colPath.indicatorKey ?? colPath.value;
                    });
                    const rowKeys = cellDimensionPath.rowHeaderPaths.map((rowPath) => {
                        return rowPath.indicatorKey ?? rowPath.value;
                    });
                    this.flatDataToObjects.changeTreeNodeValue(rowKeys, colKeys, this.internalProps.layoutMap.getBody(col, row).indicatorKey, newValue);
                }
            }
        }
        _hasCustomRenderOrLayout() {
            if (this.options.customRender) {
                return true;
            }
            const { columnsDefine, rowsDefine, indicatorsDefine } = this.internalProps.layoutMap;
            for (let i = 0; i < columnsDefine.length; i++) {
                const columnDefine = columnsDefine[i];
                if (typeof columnDefine !== 'string' && (columnDefine.headerCustomLayout || columnDefine.headerCustomRender)) {
                    return true;
                }
            }
            for (let i = 0; i < rowsDefine.length; i++) {
                const rowDefine = rowsDefine[i];
                if (typeof rowDefine !== 'string' && (rowDefine.headerCustomLayout || rowDefine.headerCustomRender)) {
                    return true;
                }
            }
            for (let i = 0; i < indicatorsDefine.length; i++) {
                const indicatorDefine = indicatorsDefine[i];
                if (typeof indicatorDefine !== 'string' &&
                    (indicatorDefine.customLayout ||
                        indicatorDefine.headerCustomLayout ||
                        indicatorDefine.customRender ||
                        indicatorDefine.headerCustomRender)) {
                    return true;
                }
            }
            return false;
        }
        changeRecordOrder(source, target) {
        }
        setTreeNodeChildren(children, records, col, row) {
            if (this.flatDataToObjects) {
                const headerTreeNode = this.internalProps.layoutMap.getHeadNode(col, row);
                headerTreeNode.children = children;
                this._refreshHierarchyState(col, row, true, () => {
                    this.flatDataToObjects.changeDataConfig({
                        rows: this.internalProps.layoutMap.fullRowDimensionKeys,
                        columns: this.internalProps.layoutMap.colDimensionKeys,
                        indicators: this.internalProps.layoutMap.indicatorKeys,
                        indicatorsAsCol: this.internalProps.layoutMap.indicatorsAsCol,
                        indicatorDimensionKey: this.internalProps.layoutMap.indicatorDimensionKey
                    });
                    this.flatDataToObjects.addRecords(records);
                });
            }
            else {
                const headerTreeNode = this.internalProps.layoutMap.getHeadNode(col, row);
                headerTreeNode.children = children;
                this._refreshHierarchyState(col, row, true, () => {
                    this.dataset._rowTreeHasChanged();
                    this.dataset.changeDataConfig({
                        rows: this.internalProps.layoutMap.fullRowDimensionKeys,
                        columns: this.internalProps.layoutMap.colDimensionKeys
                    });
                    this.dataset.addRecords(records);
                });
            }
        }
        updateFilterRules(filterRules) {
            this.internalProps.dataConfig.filterRules = filterRules;
            this.dataset.updateFilterRules(filterRules);
            this.renderWithRecreateCells();
        }
        getFilteredRecords() {
            return this.dataset?.filterRules;
        }
        getCellPivotRole(col, row) {
            const path = this.getCellHeaderPaths(col, row);
            const { cellLocation, colHeaderPaths, rowHeaderPaths } = path;
            let colRole = colHeaderPaths.length ? 'normal' : undefined;
            let rowRole = rowHeaderPaths.length ? 'normal' : undefined;
            colHeaderPaths.forEach((path) => {
                if (path.role === 'sub-total') {
                    colRole = 'sub-total';
                }
                else if (path.role === 'grand-total') {
                    colRole = 'grand-total';
                }
            });
            rowHeaderPaths.forEach((path) => {
                if (path.role === 'sub-total') {
                    rowRole = 'sub-total';
                }
                else if (path.role === 'grand-total') {
                    rowRole = 'grand-total';
                }
            });
            return {
                colRole,
                rowRole,
                cellLocation
            };
        }
        setLoadingHierarchyState(col, row) {
            this.scenegraph.setLoadingHierarchyState(col, row);
        }
        release() {
            this.internalProps.layoutMap.clearHeaderPathCache();
            this.editorManager.release();
            super.release();
        }
    }

    registerAxis();
    registerEmptyTip();
    registerLegend();
    registerMenu();
    registerTitle();
    registerTooltip();
    registerChartCell();
    registerCheckboxCell();
    registerImageCell();
    registerProgressBarCell();
    registerRadioCell();
    registerSparkLineCell();
    registerTextCell();
    registerVideoCell();
    class PivotTableAll extends PivotTable {
    }

    registerTextCell();
    class PivotTableSimple extends PivotTable {
    }

    registerAxis();
    registerEmptyTip();
    registerLegend();
    registerMenu();
    registerTitle();
    registerTooltip();
    registerChartCell();
    registerCheckboxCell();
    registerImageCell();
    registerProgressBarCell();
    registerRadioCell();
    registerSparkLineCell();
    registerTextCell();
    registerVideoCell();
    class PivotChart extends BaseTable {
        layoutNodeId = { seqId: 0 };
        pivotSortState;
        dataset;
        _selectedDataItemsInChart = [];
        _selectedDimensionInChart = [];
        _chartEventMap = {};
        _axes;
        constructor(container, options) {
            super(container, options);
            options = this.options;
            if (options.layout) {
                Object.assign(options, options.layout);
            }
            this.internalProps.columns = cloneDeep$1(options.columns);
            this.internalProps.rows = cloneDeep$1(options.rows);
            this.internalProps.indicators = cloneDeepSpec(options.indicators);
            this.internalProps.columnTree =
                options.indicatorsAsCol && !options.columns?.length && !options.columnTree ? [] : cloneDeep$1(options.columnTree);
            this.internalProps.rowTree =
                !options.indicatorsAsCol && !options.rows?.length && !options.rowTree ? [] : cloneDeep$1(options.rowTree);
            this.internalProps.records = options.records;
            this.setCustomStateNameToSpec();
            this.internalProps.columnResizeType = options.resize?.columnResizeType ?? options.columnResizeType ?? 'column';
            this.internalProps.rowResizeType = options.resize?.rowResizeType ?? options.rowResizeType ?? 'row';
            this.internalProps.dataConfig = { isPivotChart: true };
            this._axes = isArray$7(options.axes) ? options.axes : [];
            let columnDimensionTree;
            let rowDimensionTree;
            if (options.columnTree) {
                if (options.indicatorsAsCol !== false) {
                    this.internalProps.columnTree = supplementIndicatorNodesForCustomTree(this.internalProps.columnTree, options.indicators);
                }
                columnDimensionTree = new DimensionTree(this.internalProps.columnTree ?? [], this.layoutNodeId);
            }
            if (options.rowTree) {
                if (options.indicatorsAsCol === false) {
                    this.internalProps.rowTree = supplementIndicatorNodesForCustomTree(this.internalProps.rowTree, options.indicators);
                }
                rowDimensionTree = new DimensionTree(this.internalProps.rowTree ?? [], this.layoutNodeId);
            }
            const rowKeys = rowDimensionTree?.dimensionKeys?.count
                ? rowDimensionTree.dimensionKeys.valueArr()
                : options.rows?.reduce((keys, rowObj) => {
                    if (typeof rowObj === 'string') {
                        keys.push(rowObj);
                    }
                    else {
                        keys.push(rowObj.dimensionKey);
                    }
                    return keys;
                }, []) ?? [];
            const columnKeys = columnDimensionTree?.dimensionKeys?.count
                ? columnDimensionTree.dimensionKeys.valueArr()
                : options.columns?.reduce((keys, columnObj) => {
                    if (typeof columnObj === 'string') {
                        keys.push(columnObj);
                    }
                    else {
                        keys.push(columnObj.dimensionKey);
                    }
                    return keys;
                }, []) ?? [];
            const indicatorKeys = options.indicators?.reduce((keys, indicatorObj) => {
                if (typeof indicatorObj === 'string') {
                    keys.push(indicatorObj);
                }
                else {
                    keys.push(indicatorObj.indicatorKey);
                }
                return keys;
            }, []) ?? [];
            this.internalProps.dataConfig.collectValuesBy = this._generateCollectValuesConfig(columnKeys, rowKeys);
            this.internalProps.dataConfig.aggregationRules = this._generateAggregationRules();
            this.internalProps.dataConfig.dimensionSortArray = this._getDimensionSortArray();
            this.dataset = new Dataset(this.internalProps.dataConfig, rowKeys, columnKeys, indicatorKeys, this.internalProps.indicators, options.indicatorsAsCol ?? true, options.records, undefined, undefined, this.internalProps.columnTree, this.internalProps.rowTree, true);
            if (this.options.indicatorsAsCol && checkHasCartesianChart(this.internalProps.indicators)) {
                const supplyAxisNode = (nodes) => {
                    nodes.forEach((node) => {
                        if (node.children?.length) {
                            supplyAxisNode(node.children);
                        }
                        else {
                            node.children = [
                                {
                                    dimensionKey: 'axis',
                                    value: ''
                                }
                            ];
                        }
                    });
                };
                if (this.dataset.rowHeaderTree?.length) {
                    supplyAxisNode(this.dataset.rowHeaderTree);
                }
                else {
                    this.dataset.rowHeaderTree = [
                        {
                            dimensionKey: 'axis',
                            value: ''
                        }
                    ];
                }
            }
            if (!options.columnTree) {
                if (options.indicatorsAsCol !== false) {
                    this.dataset.colHeaderTree = supplementIndicatorNodesForCustomTree(this.dataset.colHeaderTree, options.indicators);
                }
            }
            if (!options.rowTree) {
                if (options.indicatorsAsCol === false) {
                    this.dataset.rowHeaderTree = supplementIndicatorNodesForCustomTree(this.dataset.rowHeaderTree, options.indicators);
                }
            }
            columnDimensionTree = new DimensionTree(this.dataset.colHeaderTree ?? [], this.layoutNodeId);
            rowDimensionTree = new DimensionTree(this.dataset.rowHeaderTree ?? [], this.layoutNodeId);
            this.internalProps.layoutMap = new PivotHeaderLayoutMap(this, this.dataset, columnDimensionTree, rowDimensionTree);
            this.refreshHeader();
            this.internalProps.useOneRowHeightFillAll = false;
            this.scenegraph.createSceneGraph();
            if (options.title) {
                const Title = Factory.getComponent('title');
                this.internalProps.title = new Title(options.title, this);
                this.scenegraph.resize();
            }
            if (this.options.emptyTip) {
                if (this.internalProps.emptyTip) {
                    this.internalProps.emptyTip?.resetVisible();
                }
                else {
                    const EmptyTip = Factory.getComponent('emptyTip');
                    this.internalProps.emptyTip = new EmptyTip(this.options.emptyTip, this);
                    this.internalProps.emptyTip?.resetVisible();
                }
            }
            setTimeout(() => {
                this.fireListeners(TABLE_EVENT_TYPE.INITIALIZED, null);
            }, 0);
        }
        static get EVENT_TYPE() {
            return PIVOT_CHART_EVENT_TYPE;
        }
        get pivotChartAxes() {
            return this._axes;
        }
        get recordsCount() {
            return this.records?.length;
        }
        isListTable() {
            return false;
        }
        isPivotTable() {
            return true;
        }
        isPivotChart() {
            return true;
        }
        _canResizeColumn(col, row) {
            const ifCan = super._canResizeColumn(col, row);
            if (ifCan) {
                if (!this.internalProps.layoutMap.indicatorsAsCol) {
                    const cellDefine = this.internalProps.layoutMap.getBody(col, this.columnHeaderLevelCount);
                    if (cellDefine?.disableColumnResize) {
                        return false;
                    }
                }
            }
            return ifCan;
        }
        updateOption(options) {
            const internalProps = this.internalProps;
            super.updateOption(options);
            this.layoutNodeId = { seqId: 0 };
            this.internalProps.columns = cloneDeep$1(options.columns);
            this.internalProps.rows = cloneDeep$1(options.rows);
            this.internalProps.indicators = !options.indicators?.length ? [] : cloneDeepSpec(options.indicators);
            this.internalProps.columnTree =
                options.indicatorsAsCol && !options.columns?.length && !options.columnTree ? [] : cloneDeep$1(options.columnTree);
            this.internalProps.rowTree =
                !options.indicatorsAsCol && !options.rows?.length && !options.rowTree ? [] : cloneDeep$1(options.rowTree);
            options.records && (this.internalProps.records = options.records);
            this.setCustomStateNameToSpec();
            this._selectedDataItemsInChart = [];
            internalProps.columnResizeType = options.resize?.columnResizeType ?? options.columnResizeType ?? 'column';
            internalProps.rowResizeType = options.resize?.rowResizeType ?? options.rowResizeType ?? 'row';
            internalProps.dataConfig = { isPivotChart: true };
            this._axes = isArray$7(options.axes) ? options.axes : [];
            let columnDimensionTree;
            let rowDimensionTree;
            if (options.columnTree) {
                if (options.indicatorsAsCol !== false) {
                    this.internalProps.columnTree = supplementIndicatorNodesForCustomTree(this.internalProps.columnTree, options.indicators);
                }
                columnDimensionTree = new DimensionTree(this.internalProps.columnTree ?? [], this.layoutNodeId);
            }
            if (options.rowTree) {
                if (options.indicatorsAsCol === false) {
                    this.internalProps.rowTree = supplementIndicatorNodesForCustomTree(this.internalProps.rowTree, options.indicators);
                }
                rowDimensionTree = new DimensionTree(this.internalProps.rowTree ?? [], this.layoutNodeId);
            }
            const rowKeys = rowDimensionTree?.dimensionKeys?.count
                ? rowDimensionTree.dimensionKeys.valueArr()
                : options.rows?.reduce((keys, rowObj) => {
                    if (typeof rowObj === 'string') {
                        keys.push(rowObj);
                    }
                    else {
                        keys.push(rowObj.dimensionKey);
                    }
                    return keys;
                }, []) ?? [];
            const columnKeys = columnDimensionTree?.dimensionKeys?.count
                ? columnDimensionTree.dimensionKeys.valueArr()
                : options.columns?.reduce((keys, columnObj) => {
                    if (typeof columnObj === 'string') {
                        keys.push(columnObj);
                    }
                    else {
                        keys.push(columnObj.dimensionKey);
                    }
                    return keys;
                }, []) ?? [];
            const indicatorKeys = options.indicators?.reduce((keys, indicatorObj) => {
                if (typeof indicatorObj === 'string') {
                    keys.push(indicatorObj);
                }
                else {
                    keys.push(indicatorObj.indicatorKey);
                }
                return keys;
            }, []) ?? [];
            this.internalProps.dataConfig.collectValuesBy = this._generateCollectValuesConfig(columnKeys, rowKeys);
            this.internalProps.dataConfig.aggregationRules = this._generateAggregationRules();
            this.internalProps.dataConfig.dimensionSortArray = this._getDimensionSortArray();
            this.dataset = new Dataset(this.internalProps.dataConfig, rowKeys, columnKeys, indicatorKeys, this.internalProps.indicators, options.indicatorsAsCol ?? true, options.records ?? this.internalProps.records, undefined, undefined, this.internalProps.columnTree, this.internalProps.rowTree, true);
            if (this.options.indicatorsAsCol && checkHasCartesianChart(this.internalProps.indicators)) {
                const supplyAxisNode = (nodes) => {
                    nodes.forEach((node) => {
                        if (node.children?.length) {
                            supplyAxisNode(node.children);
                        }
                        else {
                            node.children = [
                                {
                                    dimensionKey: 'axis',
                                    value: ''
                                }
                            ];
                        }
                    });
                };
                if (this.dataset.rowHeaderTree?.length) {
                    supplyAxisNode(this.dataset.rowHeaderTree);
                }
                else {
                    this.dataset.rowHeaderTree = [
                        {
                            dimensionKey: 'axis',
                            value: ''
                        }
                    ];
                }
            }
            if (!options.columnTree) {
                if (options.indicatorsAsCol !== false) {
                    this.dataset.colHeaderTree = supplementIndicatorNodesForCustomTree(this.dataset.colHeaderTree, options.indicators);
                }
            }
            if (!options.rowTree) {
                if (options.indicatorsAsCol === false) {
                    this.dataset.rowHeaderTree = supplementIndicatorNodesForCustomTree(this.dataset.rowHeaderTree, options.indicators);
                }
            }
            columnDimensionTree = new DimensionTree(this.dataset.colHeaderTree ?? [], this.layoutNodeId);
            rowDimensionTree = new DimensionTree(this.dataset.rowHeaderTree ?? [], this.layoutNodeId);
            internalProps.layoutMap = new PivotHeaderLayoutMap(this, this.dataset, columnDimensionTree, rowDimensionTree);
            this.refreshHeader();
            this.internalProps.useOneRowHeightFillAll = false;
            if (internalProps.releaseList) {
                internalProps.releaseList.forEach(releaseObj => releaseObj?.release?.());
                internalProps.releaseList = null;
            }
            this.scenegraph.clearCells();
            this.scenegraph.createSceneGraph();
            if (options.title) {
                const Title = Factory.getComponent('title');
                this.internalProps.title = new Title(options.title, this);
                this.scenegraph.resize();
            }
            if (this.options.emptyTip) {
                if (this.internalProps.emptyTip) {
                    this.internalProps.emptyTip?.resetVisible();
                }
                else {
                    const EmptyTip = Factory.getComponent('emptyTip');
                    this.internalProps.emptyTip = new EmptyTip(this.options.emptyTip, this);
                    this.internalProps.emptyTip?.resetVisible();
                }
            }
            return new Promise(resolve => {
                setTimeout(resolve, 0);
            });
        }
        updatePagination() {
        }
        refreshHeader() {
            this.setMinMaxLimitWidth(true);
            this.refreshRowColCount();
        }
        refreshRowColCount() {
            const table = this;
            const { layoutMap } = table.internalProps;
            if (!layoutMap) {
                return;
            }
            table.colCount = layoutMap.colCount ?? 0;
            table.rowCount = layoutMap.rowCount ?? 0;
            table.internalProps.frozenColCount = layoutMap.rowHeaderLevelCount ?? 0;
            table.frozenRowCount = Math.max(layoutMap.headerLevelCount, this.options.frozenRowCount ?? 0);
            if (table.bottomFrozenRowCount !== (layoutMap?.bottomFrozenRowCount ?? 0)) {
                table.bottomFrozenRowCount = layoutMap?.bottomFrozenRowCount ?? 0;
            }
            if (table.rightFrozenColCount !== (layoutMap?.rightFrozenColCount ?? 0)) {
                table.rightFrozenColCount = layoutMap?.rightFrozenColCount ?? 0;
            }
            this.stateManager.setFrozenCol(this.internalProps.frozenColCount);
        }
        _getSortFuncFromHeaderOption(columns, field, fieldKey) {
            return undefined;
        }
        syncHierarchyState(sourceNode, targetNode) {
            if (sourceNode.value === targetNode.value && sourceNode.dimensionKey === targetNode.dimensionKey) {
                targetNode.hierarchyState =
                    targetNode.hierarchyState ?? (targetNode?.children ? sourceNode.hierarchyState : undefined);
                targetNode?.children?.forEach((targetChildNode, index) => {
                    if (sourceNode?.children?.[index] && targetChildNode) {
                        this.syncHierarchyState(sourceNode.children[index], targetChildNode);
                    }
                });
            }
        }
        getRecordShowIndexByCell(col, row) {
            return undefined;
        }
        getTableIndexByRecordIndex(recordIndex) {
            return undefined;
        }
        getTableIndexByField(field) {
            return undefined;
        }
        getCellAddrByFieldRecord(field, recordIndex) {
            return undefined;
        }
        getBodyIndexByRow(row) {
            const { layoutMap } = this.internalProps;
            return layoutMap.getBodyIndexByRow(row);
        }
        getBodyIndexByCol(col) {
            const { layoutMap } = this.internalProps;
            return layoutMap.getBodyIndexByCol(col);
        }
        getCellValue(col, row, skipCustomMerge) {
            if (!skipCustomMerge) {
                const customMergeText = this.getCustomMergeValue(col, row);
                if (customMergeText) {
                    return customMergeText;
                }
            }
            if (this.internalProps.layoutMap.isHeader(col, row)) {
                if (this.internalProps.layoutMap.isBottomFrozenRow(col, row) ||
                    this.internalProps.layoutMap.isRightFrozenColumn(col, row)) {
                    const indicatorKeys = this.internalProps.layoutMap.getIndicatorKeyInChartSpec(col, row);
                    let indicatorInfo;
                    indicatorKeys?.forEach(key => {
                        const info = this.internalProps.layoutMap.getIndicatorInfo(key);
                        if (info) {
                            indicatorInfo = info;
                        }
                    });
                    return indicatorInfo?.title ?? indicatorInfo?.indicatorKey ?? '';
                }
                const { title, fieldFormat } = this.internalProps.layoutMap.getHeader(col, row);
                return typeof fieldFormat === 'function' ? fieldFormat(title, col, row, this) : title;
            }
            if (this.dataset) {
                let indicatorPosition;
                const cellDimensionPath = this.internalProps.layoutMap.getCellHeaderPaths(col, row);
                const colKeys = cellDimensionPath.colHeaderPaths.map((colPath, index) => {
                    if (colPath.indicatorKey) {
                        indicatorPosition = {
                            position: 'col',
                            index
                        };
                    }
                    return colPath.indicatorKey ?? colPath.value;
                });
                const rowKeys = cellDimensionPath.rowHeaderPaths.map((rowPath, index) => {
                    if (rowPath.indicatorKey) {
                        indicatorPosition = {
                            position: 'row',
                            index
                        };
                    }
                    return rowPath.indicatorKey ?? rowPath.value;
                });
                const aggregator = this.dataset.getAggregator(rowKeys, colKeys, this.internalProps.layoutMap.getIndicatorKey(col, row), true, indicatorPosition);
                return aggregator.value ? aggregator.value() : undefined;
            }
            const { fieldFormat } = this.internalProps.layoutMap.getBody(col, row);
            const rowIndex = this.getBodyIndexByRow(row);
            const colIndex = this.getBodyIndexByCol(col);
            const dataValue = this.records[rowIndex]?.[colIndex];
            if (typeof fieldFormat === 'function') {
                const fieldResult = fieldFormat(dataValue, col, row, this);
                return fieldResult;
            }
            return dataValue;
        }
        getCellOriginValue(col, row) {
            const table = this;
            if (table.internalProps.layoutMap.isHeader(col, row)) {
                if (this.internalProps.layoutMap.isBottomFrozenRow(col, row) ||
                    this.internalProps.layoutMap.isRightFrozenColumn(col, row)) {
                    const indicatorKeys = this.internalProps.layoutMap.getIndicatorKeyInChartSpec(col, row);
                    let indicatorInfo;
                    indicatorKeys?.forEach(key => {
                        const info = this.internalProps.layoutMap.getIndicatorInfo(key);
                        if (info) {
                            indicatorInfo = info;
                        }
                    });
                    return indicatorInfo?.title ?? indicatorInfo?.indicatorKey ?? '';
                }
                const { title } = table.internalProps.layoutMap.getHeader(col, row);
                return typeof title === 'function' ? title() : title;
            }
            if (this.dataset) {
                let indicatorPosition;
                const cellDimensionPath = this.internalProps.layoutMap.getCellHeaderPaths(col, row);
                const colKeys = cellDimensionPath.colHeaderPaths.map((colPath, index) => {
                    if (colPath.indicatorKey) {
                        indicatorPosition = {
                            position: 'col',
                            index
                        };
                    }
                    return colPath.indicatorKey ?? colPath.value;
                });
                const rowKeys = cellDimensionPath.rowHeaderPaths.map((rowPath, index) => {
                    if (rowPath.indicatorKey) {
                        indicatorPosition = {
                            position: 'row',
                            index
                        };
                    }
                    return rowPath.indicatorKey ?? rowPath.value;
                });
                const aggregator = this.dataset.getAggregator(rowKeys, colKeys, this.internalProps.layoutMap.getIndicatorKey(col, row), true, indicatorPosition);
                return aggregator.value ? aggregator.value() : undefined;
            }
            const rowIndex = this.getBodyIndexByRow(row);
            const colIndex = this.getBodyIndexByCol(col);
            const dataValue = this.records[rowIndex]?.[colIndex];
            return dataValue;
        }
        getCellRawValue(col, row) {
            return this.getCellOriginValue(col, row);
        }
        getCellOriginRecord(col, row) {
            const table = this;
            if (table.internalProps.layoutMap.isHeader(col, row)) {
                return undefined;
            }
            if (this.dataset) {
                let indicatorPosition;
                const cellDimensionPath = this.internalProps.layoutMap.getCellHeaderPaths(col, row);
                const colKeys = cellDimensionPath.colHeaderPaths.map((colPath, index) => {
                    if (colPath.indicatorKey) {
                        indicatorPosition = {
                            position: 'col',
                            index
                        };
                    }
                    return colPath.indicatorKey ?? colPath.value;
                });
                const rowKeys = cellDimensionPath.rowHeaderPaths.map((rowPath, index) => {
                    if (rowPath.indicatorKey) {
                        indicatorPosition = {
                            position: 'row',
                            index
                        };
                    }
                    return rowPath.indicatorKey ?? rowPath.value;
                });
                const aggregator = this.dataset.getAggregator(rowKeys, colKeys, this.internalProps.layoutMap.getIndicatorKey(col, row), true, indicatorPosition);
                return aggregator.records;
            }
            return undefined;
        }
        getCellRawRecord(col, row) {
            return this.getCellOriginRecord(col, row);
        }
        getPivotSortState(col, row) {
            if (!this.pivotSortState) {
                return undefined;
            }
            const cellRange = this.getCellRange(col, row);
            for (let i = 0; i < this.pivotSortState.length; i++) {
                const { col: sortCol, row: sortRow, order } = this.pivotSortState[i];
                if (cellInRange(cellRange, sortCol, sortRow)) {
                    return order;
                }
            }
            return undefined;
        }
        _moveHeaderPosition(source, target) {
            const moveContext = this.internalProps.layoutMap.moveHeaderPosition(source, target);
            if (moveContext) {
                if (moveContext.moveType === 'column') {
                    if (this.options.records?.[0]?.constructor === Array) {
                        for (let row = 0; row < this.internalProps.records.length; row++) {
                            const sourceColumns = this.internalProps.records[row].splice(moveContext.sourceIndex - this.rowHeaderLevelCount, moveContext.sourceSize);
                            sourceColumns.unshift(moveContext.targetIndex - this.rowHeaderLevelCount, 0);
                            Array.prototype.splice.apply(this.internalProps.records[row], sourceColumns);
                        }
                    }
                    this.colWidthsMap.adjustOrder(moveContext.sourceIndex, moveContext.targetIndex, moveContext.sourceSize);
                    this.setMinMaxLimitWidth();
                }
                else if (moveContext.moveType === 'row') {
                    if (this.options.records?.[0]?.constructor === Array) {
                        const sourceRows = this.internalProps.records.splice(moveContext.sourceIndex - this.columnHeaderLevelCount, moveContext.sourceSize);
                        sourceRows.unshift(moveContext.targetIndex - this.columnHeaderLevelCount, 0);
                        Array.prototype.splice.apply(this.internalProps.records, sourceRows);
                    }
                    this.rowHeightsMap.adjustOrder(moveContext.sourceIndex, moveContext.targetIndex, moveContext.sourceSize);
                }
                return moveContext;
            }
            return null;
        }
        toggleHierarchyState(col, row, recalculateColWidths = true) {
        }
        getHeaderCellAddressByPath(dimensionPaths) {
            const cellAddress = this.internalProps.layoutMap.getPivotCellAdress(dimensionPaths);
            return cellAddress;
        }
        getCellAddressByHeaderPaths(dimensionPaths) {
            const cellAddress = this.internalProps.layoutMap.getCellAdressByHeaderPath(dimensionPaths);
            return cellAddress;
        }
        getHeaderPathByXY(coordinate) {
            let cellAddr;
            if (coordinate) {
                cellAddr = this.getCellAt(coordinate.x + this.getFrozenColsWidth() + this.scrollLeft + 1, coordinate.y + this.getFrozenRowsHeight() + this.scrollTop + 1);
            }
            else {
                cellAddr = this.getCellAt(this.getFrozenColsWidth() + this.scrollLeft + 1, this.getFrozenRowsHeight() + this.scrollTop + 1);
            }
            const cellHeaderPaths = this.internalProps.layoutMap.getCellHeaderPaths(cellAddr.col, cellAddr.row);
            return cellHeaderPaths;
        }
        getHierarchyState(col, row) {
            return this._getHeaderLayoutMap(col, row)?.hierarchyState;
        }
        getMenuInfo(col, row, type) {
            const dimensionInfos = this.internalProps.layoutMap.getPivotDimensionInfo(col, row);
            const result = {
                dimensionKey: dimensionInfos[dimensionInfos.length - 1].dimensionKey,
                value: this.getCellValue(col, row),
                cellLocation: this.getCellLocation(col, row),
                isPivotCorner: this.isCornerHeader(col, row),
                event: undefined
            };
            return result;
        }
        _generateCollectValuesConfig(columnKeys, rowKeys) {
            columnKeys = columnKeys.filter(key => key !== IndicatorDimensionKeyPlaceholder);
            rowKeys = rowKeys.filter(key => key !== IndicatorDimensionKeyPlaceholder);
            const indicators = this.internalProps.indicators;
            const collectValuesBy = {};
            for (let i = 0, len = indicators?.length; i < len; i++) {
                if (typeof indicators[i] !== 'string' && indicators[i].chartSpec) {
                    if (indicators[i].chartSpec?.type === 'pie' ||
                        indicators[i].chartSpec?.type === 'rose' ||
                        indicators[i].chartSpec?.type === 'radar' ||
                        indicators[i].chartSpec?.type === 'gauge' ||
                        indicators[i].chartSpec?.type === 'wordCloud') {
                        continue;
                    }
                    const indicatorDefine = indicators[i];
                    const indicatorSpec = indicatorDefine.chartSpec;
                    if (this.options.indicatorsAsCol === false) {
                        indicatorSpec?.stack !== false &&
                            (indicatorSpec?.type === 'bar' || indicatorSpec?.type === 'area') &&
                            (indicatorSpec.stack = true);
                        collectValuesBy[indicatorDefine.indicatorKey] = {
                            by: rowKeys,
                            range: true,
                            sumBy: indicatorSpec?.stack && columnKeys.concat(indicatorSpec?.xField)
                        };
                        if (indicatorSpec.series) {
                            indicatorSpec.series.forEach((chartSeries) => {
                                const xField = typeof chartSeries.xField === 'string' ? chartSeries.xField : chartSeries.xField[0];
                                collectValuesBy[xField] = {
                                    by: columnKeys,
                                    type: chartSeries.direction !== 'horizontal' ? 'xField' : undefined,
                                    range: hasLinearAxis(chartSeries, this._axes, chartSeries.direction === 'horizontal', true),
                                    sortBy: chartSeries.direction !== 'horizontal'
                                        ? chartSeries?.data?.fields?.[xField]?.domain ?? indicatorSpec?.data?.fields?.[xField]?.domain
                                        : undefined
                                };
                                const yField = chartSeries.yField;
                                chartSeries.stack !== false &&
                                    (chartSeries.type === 'bar' || chartSeries.type === 'area') &&
                                    (chartSeries.stack = true);
                                collectValuesBy[yField] = {
                                    by: rowKeys,
                                    range: hasLinearAxis(chartSeries, this._axes, chartSeries.direction === 'horizontal', false),
                                    sumBy: chartSeries.stack && columnKeys.concat(chartSeries?.xField),
                                    sortBy: chartSeries.direction === 'horizontal'
                                        ? chartSeries?.data?.fields?.[yField]?.domain ?? indicatorSpec?.data?.fields?.[yField]?.domain
                                        : undefined,
                                    extendRange: parseMarkLineGetExtendRange(indicatorSpec.markLine)
                                };
                            });
                        }
                        else {
                            const xField = typeof indicatorSpec.xField === 'string' ? indicatorSpec.xField : indicatorSpec.xField[0];
                            collectValuesBy[xField] = {
                                by: columnKeys,
                                type: indicatorSpec.direction !== 'horizontal' ? 'xField' : undefined,
                                range: hasLinearAxis(indicatorSpec, this._axes, indicatorSpec.direction === 'horizontal', true),
                                sortBy: indicatorSpec.direction !== 'horizontal' ? indicatorSpec?.data?.fields?.[xField]?.domain : undefined
                            };
                            indicatorSpec?.stack !== false &&
                                (indicatorSpec?.type === 'bar' || indicatorSpec?.type === 'area') &&
                                (indicatorSpec.stack = true);
                            const yField = indicatorSpec.yField;
                            collectValuesBy[yField] = {
                                by: rowKeys,
                                range: indicatorSpec.direction !== 'horizontal',
                                sumBy: indicatorSpec.stack && columnKeys.concat(indicatorSpec?.xField),
                                sortBy: indicatorSpec.direction === 'horizontal' ? indicatorSpec?.data?.fields?.[yField]?.domain : undefined,
                                extendRange: parseMarkLineGetExtendRange(indicatorSpec.markLine)
                            };
                        }
                    }
                    else {
                        const indicatorDefine = indicators[i];
                        indicatorSpec?.stack !== false &&
                            (indicatorSpec?.type === 'bar' || indicatorSpec?.type === 'area') &&
                            (indicatorSpec.stack = true);
                        collectValuesBy[indicatorDefine.indicatorKey] = {
                            by: columnKeys,
                            range: true,
                            sumBy: indicatorSpec?.stack && rowKeys.concat(indicatorSpec?.yField)
                        };
                        if (indicatorSpec.series) {
                            indicatorSpec.series.forEach((chartSeries) => {
                                const yField = typeof chartSeries.yField === 'string' ? chartSeries.yField : chartSeries.yField[0];
                                collectValuesBy[yField] = {
                                    by: rowKeys,
                                    type: chartSeries.direction === 'horizontal' ? 'yField' : undefined,
                                    range: hasLinearAxis(chartSeries, this._axes, chartSeries.direction === 'horizontal', false),
                                    sortBy: chartSeries.direction === 'horizontal'
                                        ? chartSeries?.data?.fields?.[yField]?.domain ?? indicatorSpec?.data?.fields?.[yField]?.domain
                                        : undefined
                                };
                                const xField = chartSeries.xField;
                                chartSeries.stack !== false &&
                                    (chartSeries.type === 'bar' || chartSeries.type === 'area') &&
                                    (chartSeries.stack = true);
                                collectValuesBy[xField] = {
                                    by: columnKeys,
                                    range: hasLinearAxis(chartSeries, this._axes, chartSeries.direction === 'horizontal', true),
                                    sumBy: chartSeries.stack && rowKeys.concat(chartSeries?.yField),
                                    sortBy: chartSeries.direction !== 'horizontal'
                                        ? chartSeries?.data?.fields?.[xField]?.domain ?? indicatorSpec?.data?.fields?.[xField]?.domain
                                        : undefined,
                                    extendRange: parseMarkLineGetExtendRange(indicatorSpec.markLine)
                                };
                            });
                        }
                        else {
                            const yField = typeof indicatorSpec.yField === 'string' ? indicatorSpec.yField : indicatorSpec.yField[0];
                            collectValuesBy[yField] = {
                                by: rowKeys,
                                type: indicatorSpec.direction === 'horizontal' ? 'yField' : undefined,
                                range: hasLinearAxis(indicatorSpec, this._axes, indicatorSpec.direction === 'horizontal', false),
                                sortBy: indicatorSpec.direction === 'horizontal' ? indicatorSpec?.data?.fields?.[yField]?.domain : undefined
                            };
                            indicatorSpec?.stack !== false &&
                                (indicatorSpec?.type === 'bar' || indicatorSpec?.type === 'area') &&
                                (indicatorSpec.stack = true);
                            const xField = indicatorSpec.xField;
                            collectValuesBy[xField] = {
                                by: columnKeys,
                                range: hasLinearAxis(indicatorSpec, this._axes, indicatorSpec.direction === 'horizontal', true),
                                sumBy: indicatorSpec.stack && rowKeys.concat(indicatorSpec?.yField),
                                sortBy: indicatorSpec.direction !== 'horizontal' ? indicatorSpec?.data?.fields?.[xField]?.domain : undefined,
                                extendRange: parseMarkLineGetExtendRange(indicatorSpec.markLine)
                            };
                        }
                    }
                }
            }
            return collectValuesBy;
        }
        _generateAggregationRules() {
            const aggregationRules = [];
            this.internalProps.indicators?.forEach((indicator) => {
                if (typeof indicator === 'string') {
                    aggregationRules.push({
                        indicatorKey: indicator,
                        field: indicator,
                        aggregationType: AggregationType.RECORD
                    });
                }
                else {
                    if (indicator.chartSpec?.series) {
                        const fields = [];
                        indicator.chartSpec?.series.forEach((seriesSpec) => {
                            const seriesField = this.options.indicatorsAsCol === false ? seriesSpec.yField : seriesSpec.xField;
                            if (fields.indexOf(seriesField) === -1) {
                                fields.push(seriesField);
                            }
                        });
                        aggregationRules.push({
                            indicatorKey: indicator.indicatorKey,
                            field: fields,
                            aggregationType: AggregationType.RECORD
                        });
                    }
                    else {
                        const field = this.options.indicatorsAsCol === false
                            ? indicator.chartSpec.yField
                            : indicator.chartSpec.xField;
                        aggregationRules.push({
                            indicatorKey: indicator.indicatorKey,
                            field: field ?? indicator.indicatorKey,
                            aggregationType: AggregationType.RECORD
                        });
                    }
                }
            });
            return aggregationRules;
        }
        setCustomStateNameToSpec() {
            const setCustomStateName = (spec) => {
                if (spec.bar?.state?.selected) {
                    spec.bar.state.vtable_selected = spec.bar.state.selected;
                    spec.bar.state.vtable_selected_reverse = spec.bar.state.selected_reverse;
                    delete spec.bar.state.selected;
                    delete spec.bar.state.selected_reverse;
                }
                if (spec.point?.state?.selected) {
                    spec.point.state.vtable_selected = spec.point.state.selected;
                    spec.point.state.vtable_selected_reverse = spec.point.state.selected_reverse;
                    delete spec.point.state.selected;
                    delete spec.point.state.selected_reverse;
                }
                if (spec.line?.state?.selected) {
                    spec.line.state.vtable_selected = spec.line.state.selected;
                    spec.line.state.vtable_selected_reverse = spec.line.state.selected_reverse;
                    delete spec.line.state.selected;
                    delete spec.line.state.selected_reverse;
                }
                if (spec.area?.state?.selected) {
                    spec.area.state.vtable_selected = spec.area.state.selected;
                    spec.area.state.vtable_selected_reverse = spec.area.state.selected_reverse;
                    delete spec.area.state.selected;
                    delete spec.area.state.selected_reverse;
                }
                if (spec.pie?.state?.selected) {
                    spec.pie.state.vtable_selected = spec.pie.state.selected;
                    spec.pie.state.vtable_selected_reverse = spec.pie.state.selected_reverse;
                    delete spec.pie.state.selected;
                    delete spec.pie.state.selected_reverse;
                }
            };
            this.internalProps.indicators?.forEach((indicator) => {
                if (indicator.chartSpec) {
                    const spec = indicator.chartSpec;
                    if (spec.series) {
                        spec.series.forEach((series) => {
                            setCustomStateName(series);
                        });
                    }
                    else {
                        setCustomStateName(spec);
                    }
                }
            });
        }
        updateFilterRules(filterRules) {
            this.internalProps.dataConfig.filterRules = filterRules;
            this.dataset.updateFilterRules(filterRules);
            clearChartCacheImage(this.scenegraph);
            updateChartData(this.scenegraph);
            this.render();
        }
        clearChartCacheImage(col, row) {
            if (isNumber$4(col) && isNumber$4(row)) {
                clearCellChartCacheImage(col, row, this.scenegraph);
            }
            else {
                clearChartCacheImage(this.scenegraph);
            }
        }
        getLegendSelected() {
            const selected = [];
            this.internalProps.legends?.forEach(legend => {
                const data = legend.legendComponent._getSelectedLegends().map((d) => d.label);
                selected.push(...data);
            });
            return selected;
        }
        setLegendSelected(selectedData) {
            this.internalProps.legends?.forEach(legend => {
                legend.legendComponent.setSelected(selectedData);
            });
        }
        getChartDatumPosition(datum, cellHeaderPaths) {
            const { chartInstance, bounds } = this.getChartInstance(cellHeaderPaths);
            if (chartInstance) {
                const position = chartInstance.convertDatumToPosition(datum);
                return position ? { x: Math.round(position.x + bounds.x1), y: Math.round(position.y + bounds.y1) } : null;
            }
            return null;
        }
        getCellAddressByRecord(record) {
            const rowHeaderPaths = [];
            const colHeaderPaths = [];
            const recordKeyMapToIndicatorKeys = {};
            const indicatorRecordKeys = [];
            this.dataset.dataConfig.aggregationRules.forEach(aggregationRule => {
                if (typeof aggregationRule.field === 'string') {
                    recordKeyMapToIndicatorKeys[aggregationRule.field] = aggregationRule.indicatorKey;
                    indicatorRecordKeys.push(aggregationRule.field);
                }
                else {
                    for (let i = 0; i < aggregationRule.field.length; i++) {
                        recordKeyMapToIndicatorKeys[aggregationRule.field[i]] = aggregationRule.indicatorKey;
                        indicatorRecordKeys.push(aggregationRule.field[i]);
                    }
                }
            });
            for (const key in record) {
                if (this.dataset.rows.indexOf(key) >= 0) {
                    rowHeaderPaths.push({
                        dimensionKey: key,
                        value: record[key]
                    });
                }
                if (this.dataset.columns.indexOf(key) >= 0) {
                    colHeaderPaths.push({
                        dimensionKey: key,
                        value: record[key]
                    });
                }
                if (indicatorRecordKeys.indexOf(key) >= 0) {
                    if (this.dataset.indicatorsAsCol) {
                        colHeaderPaths.push({
                            indicatorKey: recordKeyMapToIndicatorKeys[key]
                        });
                    }
                    else {
                        rowHeaderPaths.push({
                            indicatorKey: recordKeyMapToIndicatorKeys[key]
                        });
                    }
                }
            }
            return this.getCellAddressByHeaderPaths({
                rowHeaderPaths,
                colHeaderPaths,
                cellLocation: 'body'
            });
        }
        getChartInstance(cellHeaderPaths) {
            const cellAddr = this.getCellAddressByHeaderPaths(cellHeaderPaths);
            if (cellAddr) {
                const cellPosition = this.getCellRelativeRect(cellAddr.col, cellAddr.row);
                const cellGroup = this.scenegraph.getCell(cellAddr.col, cellAddr.row);
                let chartInstance;
                const chartNode = cellGroup?.getChildren()?.[0];
                if (chartNode.attribute.chartInstance) {
                    chartInstance = chartNode.attribute.chartInstance;
                    const { dataId, data, axes, spec } = chartNode.attribute;
                    const viewBox = chartNode.getViewBox();
                    axes?.forEach((axis, index) => {
                        if (axis.type === 'linear') {
                            chartInstance.updateModelSpecSync({ type: 'axes', index }, {
                                min: axis.range?.min ?? 0,
                                max: axis.range?.max ?? 0,
                                tick: {
                                    tickMode: axis.tick?.tickMode
                                }
                            }, true);
                        }
                        else if (axis.type === 'band') {
                            chartInstance.updateModelSpec({ type: 'axes', index }, { domain: axis.domain.slice(0) }, true);
                        }
                    });
                    chartInstance.updateViewBox({
                        x1: 0,
                        x2: viewBox.x2 - viewBox.x1,
                        y1: 0,
                        y2: viewBox.y2 - viewBox.y1
                    }, false, false);
                    const chartStage = chartInstance.getStage();
                    const matrix = chartNode.globalTransMatrix.clone();
                    const stageMatrix = chartNode.stage.window.getViewBoxTransform();
                    matrix.multiply(stageMatrix.a, stageMatrix.b, stageMatrix.c, stageMatrix.d, stageMatrix.e, stageMatrix.f);
                    chartStage.window.setViewBoxTransform &&
                        chartStage.window.setViewBoxTransform(matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f);
                    if (typeof dataId === 'string') {
                        chartInstance.updateDataSync(dataId, data ?? []);
                    }
                    else {
                        const dataBatch = [];
                        for (const dataIdStr in dataId) {
                            const dataIdAndField = dataId[dataIdStr];
                            const series = spec.series.find((item) => item?.data?.id === dataIdStr);
                            dataBatch.push({
                                id: dataIdStr,
                                values: dataIdAndField
                                    ? data?.filter((item) => {
                                        return item.hasOwnProperty(dataIdAndField);
                                    }) ?? []
                                    : data ?? [],
                                fields: series?.data?.fields
                            });
                            if (!chartInstance.updateFullDataSync) {
                                chartInstance.updateDataSync(dataIdStr, dataIdAndField
                                    ? data?.filter((item) => {
                                        return item.hasOwnProperty(dataIdAndField);
                                    }) ?? []
                                    : data ?? []);
                            }
                        }
                        chartInstance.updateFullDataSync?.(dataBatch);
                    }
                    this.render();
                }
                return {
                    chartInstance,
                    bounds: cellPosition.bounds
                };
            }
            return {};
        }
        activateChartInstance(cellHeaderPaths) {
            const cellAddr = this.getCellAddressByHeaderPaths(cellHeaderPaths);
            if (cellAddr) {
                const col = cellAddr.col;
                const row = cellAddr.row;
                const cellGroup = this.scenegraph.getCell(col, row);
                const chartNode = cellGroup?.getChildren()?.[0];
                const activeChartInstance = this.scenegraph.activateChart(col, row);
                const { dataId, data, axes, spec } = chartNode.attribute;
                const viewBox = chartNode.getViewBox();
                axes?.forEach((axis, index) => {
                    if (axis.type === 'linear') {
                        activeChartInstance.updateModelSpecSync({ type: 'axes', index }, {
                            min: axis.range?.min ?? 0,
                            max: axis.range?.max ?? 0,
                            tick: {
                                tickMode: axis.tick?.tickMode
                            }
                        }, true);
                    }
                    else if (axis.type === 'band') {
                        activeChartInstance.updateModelSpec({ type: 'axes', index }, { domain: axis.domain.slice(0) }, true);
                    }
                });
                activeChartInstance.updateViewBox({
                    x1: 0,
                    x2: viewBox.x2 - viewBox.x1,
                    y1: 0,
                    y2: viewBox.y2 - viewBox.y1
                }, false, false);
                const chartStage = activeChartInstance.getStage();
                chartStage.needRender = true;
                const matrix = chartNode.globalTransMatrix.clone();
                const stageMatrix = chartNode.stage.window.getViewBoxTransform().clone();
                stageMatrix.multiply(matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f);
                chartStage.window.setViewBoxTransform(stageMatrix.a, stageMatrix.b, stageMatrix.c, stageMatrix.d, stageMatrix.e, stageMatrix.f);
                if (typeof dataId === 'string') {
                    activeChartInstance.updateDataSync(dataId, data ?? []);
                }
                else {
                    const dataBatch = [];
                    for (const dataIdStr in dataId) {
                        const dataIdAndField = dataId[dataIdStr];
                        const series = spec.series.find((item) => item?.data?.id === dataIdStr);
                        dataBatch.push({
                            id: dataIdStr,
                            values: dataIdAndField
                                ? data?.filter((item) => {
                                    return item.hasOwnProperty(dataIdAndField);
                                }) ?? []
                                : data ?? [],
                            fields: series?.data?.fields
                        });
                        if (!activeChartInstance.updateFullDataSync) {
                            activeChartInstance.updateDataSync(dataIdStr, dataIdAndField
                                ? data?.filter((item) => {
                                    return item.hasOwnProperty(dataIdAndField);
                                }) ?? []
                                : data ?? []);
                        }
                    }
                    activeChartInstance.updateFullDataSync?.(dataBatch);
                }
                return activeChartInstance;
            }
        }
        replaceChartCacheImage(cellHeaderPaths, chartInstance) {
            const cellAddr = this.getCellAddressByHeaderPaths(cellHeaderPaths);
            if (cellAddr) {
                const cellGroup = this.scenegraph.getCell(cellAddr.col, cellAddr.row);
                const chartNode = cellGroup?.getChildren()?.[0];
                cacheStageCanvas(chartInstance.getStage(), chartNode);
            }
        }
        _getDimensionSortArray() {
            if (this.options?.axes?.length) {
                const dimensionAxisOrient = this.options.indicatorsAsCol ? 'left' : 'bottom';
                const dimensionAxisOption = this.options.axes.find(axis => {
                    if (axis.orient === dimensionAxisOrient) {
                        return true;
                    }
                    return false;
                });
                if (dimensionAxisOption && isArray$7(dimensionAxisOption.domain)) {
                    return dimensionAxisOption.domain;
                }
            }
            return undefined;
        }
        setRecords(records) {
            this.internalProps.layoutMap.release();
            clearChartRenderQueue();
            const oldHoverState = { col: this.stateManager.hover.cellPos.col, row: this.stateManager.hover.cellPos.row };
            this.options.records = this.internalProps.records = records;
            const options = this.options;
            const internalProps = this.internalProps;
            this.dataset.setRecords(records);
            let columnDimensionTree;
            let rowDimensionTree;
            if (options.columnTree) {
                columnDimensionTree = internalProps.layoutMap.columnDimensionTree;
            }
            else {
                columnDimensionTree = new DimensionTree(this.dataset.colHeaderTree ?? [], this.layoutNodeId);
            }
            if (options.rowTree) {
                rowDimensionTree = internalProps.layoutMap.rowDimensionTree;
            }
            else {
                rowDimensionTree = new DimensionTree(this.dataset.rowHeaderTree ?? [], this.layoutNodeId);
            }
            internalProps.layoutMap = new PivotHeaderLayoutMap(this, this.dataset, columnDimensionTree, rowDimensionTree);
            this.refreshHeader();
            this.internalProps.useOneRowHeightFillAll = false;
            this.scenegraph.clearCells();
            this.clearCellStyleCache();
            this.scenegraph.createSceneGraph();
            this.stateManager.updateHoverPos(oldHoverState.col, oldHoverState.row);
            if (this.internalProps.title && !this.internalProps.title.isReleased) {
                this._updateSize();
                this.internalProps.title.resize();
                this.scenegraph.resize();
            }
            this.eventManager.updateEventBinder();
        }
        _hasCustomRenderOrLayout() {
            if (this.options.customRender) {
                return true;
            }
            const { columnsDefine, rowsDefine, indicatorsDefine } = this.internalProps.layoutMap;
            for (let i = 0; i < columnsDefine.length; i++) {
                const columnDefine = columnsDefine[i];
                if (typeof columnDefine !== 'string' && (columnDefine.headerCustomLayout || columnDefine.headerCustomRender)) {
                    return true;
                }
            }
            for (let i = 0; i < rowsDefine.length; i++) {
                const rowDefine = rowsDefine[i];
                if (typeof rowDefine !== 'string' && (rowDefine.headerCustomLayout || rowDefine.headerCustomRender)) {
                    return true;
                }
            }
            for (let i = 0; i < indicatorsDefine.length; i++) {
                const indicatorDefine = indicatorsDefine[i];
                if (typeof indicatorDefine !== 'string' &&
                    (indicatorDefine.customLayout ||
                        indicatorDefine.headerCustomLayout ||
                        indicatorDefine.customRender ||
                        indicatorDefine.headerCustomRender)) {
                    return true;
                }
            }
            return false;
        }
        changeRecordOrder(source, target) {
        }
        getLayoutColumnTree() {
            const layoutMap = this.internalProps.layoutMap;
            return layoutMap.getLayoutColumnTree();
        }
        getLayoutColumnTreeCount() {
            const layoutMap = this.internalProps.layoutMap;
            return layoutMap.getLayoutColumnTreeCount();
        }
        getLayoutRowTree() {
            const layoutMap = this.internalProps.layoutMap;
            return layoutMap.getLayoutRowTree();
        }
        getLayoutRowTreeCount() {
            const layoutMap = this.internalProps.layoutMap;
            return layoutMap.getLayoutRowTreeCount();
        }
        getCellHeaderTreeNodes(col, row) {
            const layoutMap = this.internalProps.layoutMap;
            const headerNodes = layoutMap.getCellHeaderPathsWithTreeNode(col, row);
            return headerNodes;
        }
    }

    class Circle extends Circle$1 {
        constructor(options) {
            const isPaddingNumber = isArray$7(options.boundsPadding);
            const padding = [
                options.marginTop ?? (isPaddingNumber ? options.boundsPadding[0] : options.boundsPadding) ?? 0,
                options.marginRight ?? (isPaddingNumber ? options.boundsPadding[1] : options.boundsPadding) ?? 0,
                options.marginBottom ??
                    (isPaddingNumber ? options.boundsPadding[2] ?? options.boundsPadding[0] : options.boundsPadding) ??
                    0,
                options.marginLeft ??
                    (isPaddingNumber ? options.boundsPadding[3] ?? options.boundsPadding[1] : options.boundsPadding) ??
                    0
            ];
            options.boundsPadding = padding;
            super(options);
        }
    }

    class Container extends Group$2 {
        constructor(containerOptions) {
            if (containerOptions.direction) {
                containerOptions.flexDirection = containerOptions.direction;
            }
            if (containerOptions.justifyContent &&
                (containerOptions.justifyContent === 'start' || containerOptions.justifyContent === 'end')) {
                containerOptions.justifyContent = ('flex-' + containerOptions.justifyContent);
            }
            if (containerOptions.alignItems &&
                (containerOptions.alignItems === 'start' || containerOptions.alignItems === 'end')) {
                containerOptions.alignItems = ('flex-' + containerOptions.alignItems);
            }
            if (containerOptions.alignContent &&
                (containerOptions.alignContent === 'start' || containerOptions.alignContent === 'end')) {
                containerOptions.alignContent = ('flex-' + containerOptions.alignContent);
            }
            containerOptions.display = 'flex';
            if (!containerOptions.flexDirection) {
                containerOptions.flexDirection = 'row';
            }
            containerOptions.clip = true;
            containerOptions.fill = containerOptions?.background?.fill;
            containerOptions.stroke = containerOptions?.background?.stroke;
            containerOptions.lineWidth = containerOptions?.background?.lineWidth;
            containerOptions.cornerRadius = containerOptions?.background?.cornerRadius;
            const isPaddingNumber = isArray$7(containerOptions.boundsPadding);
            const padding = [
                containerOptions.marginTop ??
                    (isPaddingNumber ? containerOptions.boundsPadding[0] : containerOptions.boundsPadding) ??
                    0,
                containerOptions.marginRight ??
                    (isPaddingNumber ? containerOptions.boundsPadding[1] : containerOptions.boundsPadding) ??
                    0,
                containerOptions.marginBottom ??
                    (isPaddingNumber
                        ? containerOptions.boundsPadding[2] ?? containerOptions.boundsPadding[0]
                        : containerOptions.boundsPadding) ??
                    0,
                containerOptions.marginLeft ??
                    (isPaddingNumber
                        ? containerOptions.boundsPadding[3] ?? containerOptions.boundsPadding[1]
                        : containerOptions.boundsPadding) ??
                    0
            ];
            containerOptions.boundsPadding = padding;
            super(containerOptions);
        }
    }

    class GroupElement extends Container {
        constructor(option) {
            option.flexWrap = 'nowrap';
            super(option);
        }
    }

    class Icon extends Image$2 {
        svg;
        iconName;
        cache;
        constructor(options) {
            let cache;
            if (isString$4(options.iconName)) {
                const regedIcons = get$2();
                cache = regedIcons[options.iconName];
                if (cache) {
                    options.width = options.width ?? cache.width;
                    options.height = options.height ?? cache.height;
                    options.svg = cache.svg;
                    options.cursor = cache.cursor;
                }
            }
            if (options.svg) {
                options.image = options.svg;
            }
            const isPaddingNumber = isArray$7(options.boundsPadding);
            const padding = [
                options.marginTop ?? (isPaddingNumber ? options.boundsPadding[0] : options.boundsPadding) ?? 0,
                options.marginRight ?? (isPaddingNumber ? options.boundsPadding[1] : options.boundsPadding) ?? 0,
                options.marginBottom ??
                    (isPaddingNumber ? options.boundsPadding[2] ?? options.boundsPadding[0] : options.boundsPadding) ??
                    0,
                options.marginLeft ??
                    (isPaddingNumber ? options.boundsPadding[3] ?? options.boundsPadding[1] : options.boundsPadding) ??
                    0
            ];
            options.boundsPadding = padding;
            super(options);
            this.cache = cache;
        }
    }

    let Image$1 = class Image extends Image$2 {
        constructor(options) {
            if (options.src) {
                options.image = options.src;
            }
            if (options.shape === 'circle') {
                options.cornerRadius = options.width / 2;
            }
            const isPaddingNumber = isArray$7(options.boundsPadding);
            const padding = [
                options.marginTop ?? (isPaddingNumber ? options.boundsPadding[0] : options.boundsPadding) ?? 0,
                options.marginRight ?? (isPaddingNumber ? options.boundsPadding[1] : options.boundsPadding) ?? 0,
                options.marginBottom ??
                    (isPaddingNumber ? options.boundsPadding[2] ?? options.boundsPadding[0] : options.boundsPadding) ??
                    0,
                options.marginLeft ??
                    (isPaddingNumber ? options.boundsPadding[3] ?? options.boundsPadding[1] : options.boundsPadding) ??
                    0
            ];
            options.boundsPadding = padding;
            super(options);
        }
    };

    class Rect extends Rect$2 {
        constructor(options) {
            const isPaddingNumber = isArray$7(options.boundsPadding);
            const padding = [
                options.marginTop ?? (isPaddingNumber ? options.boundsPadding[0] : options.boundsPadding) ?? 0,
                options.marginRight ?? (isPaddingNumber ? options.boundsPadding[1] : options.boundsPadding) ?? 0,
                options.marginBottom ??
                    (isPaddingNumber ? options.boundsPadding[2] ?? options.boundsPadding[0] : options.boundsPadding) ??
                    0,
                options.marginLeft ??
                    (isPaddingNumber ? options.boundsPadding[3] ?? options.boundsPadding[1] : options.boundsPadding) ??
                    0
            ];
            options.boundsPadding = padding;
            super(options);
        }
    }

    class Text extends Text$1 {
        constructor(options) {
            if (!options.textBaseline) {
                options.textBaseline = 'top';
            }
            const isPaddingNumber = isArray$7(options.boundsPadding);
            const padding = [
                options.marginTop ?? (isPaddingNumber ? options.boundsPadding[0] : options.boundsPadding) ?? 0,
                options.marginRight ?? (isPaddingNumber ? options.boundsPadding[1] : options.boundsPadding) ?? 0,
                options.marginBottom ??
                    (isPaddingNumber ? options.boundsPadding[2] ?? options.boundsPadding[0] : options.boundsPadding) ??
                    0,
                options.marginLeft ??
                    (isPaddingNumber ? options.boundsPadding[3] ?? options.boundsPadding[1] : options.boundsPadding) ??
                    0
            ];
            options.boundsPadding = padding;
            options.fill = options.fill ?? '#000';
            super(options);
        }
        getSize(table) {
            this.AABBBounds.width();
        }
    }

    function percentCalc(percent, delta = 0) {
        return {
            percent,
            delta
        };
    }

    class Arc extends Arc$1 {
        constructor(options) {
            const isPaddingNumber = isArray$7(options.boundsPadding);
            const padding = [
                options.marginTop ?? (isPaddingNumber ? options.boundsPadding[0] : options.boundsPadding) ?? 0,
                options.marginRight ?? (isPaddingNumber ? options.boundsPadding[1] : options.boundsPadding) ?? 0,
                options.marginBottom ??
                    (isPaddingNumber ? options.boundsPadding[2] ?? options.boundsPadding[0] : options.boundsPadding) ??
                    0,
                options.marginLeft ??
                    (isPaddingNumber ? options.boundsPadding[3] ?? options.boundsPadding[1] : options.boundsPadding) ??
                    0
            ];
            options.boundsPadding = padding;
            super(options);
        }
    }

    class Tag extends Tag$1 {
        constructor(options) {
            const isPaddingNumber = isArray$7(options.boundsPadding);
            const padding = [
                options.marginTop ?? (isPaddingNumber ? options.boundsPadding[0] : options.boundsPadding) ?? 0,
                options.marginRight ?? (isPaddingNumber ? options.boundsPadding[1] : options.boundsPadding) ?? 0,
                options.marginBottom ??
                    (isPaddingNumber ? options.boundsPadding[2] ?? options.boundsPadding[0] : options.boundsPadding) ??
                    0,
                options.marginLeft ??
                    (isPaddingNumber ? options.boundsPadding[3] ?? options.boundsPadding[1] : options.boundsPadding) ??
                    0
            ];
            options.boundsPadding = padding;
            super(options);
        }
        getSize(table) {
            this.AABBBounds.width();
        }
    }

    class Group extends Group$2 {
        constructor(options) {
            const isPaddingNumber = isArray$7(options.boundsPadding);
            const padding = [
                options.marginTop ?? (isPaddingNumber ? options.boundsPadding[0] : options.boundsPadding) ?? 0,
                options.marginRight ?? (isPaddingNumber ? options.boundsPadding[1] : options.boundsPadding) ?? 0,
                options.marginBottom ??
                    (isPaddingNumber ? options.boundsPadding[2] ?? options.boundsPadding[0] : options.boundsPadding) ??
                    0,
                options.marginLeft ??
                    (isPaddingNumber ? options.boundsPadding[3] ?? options.boundsPadding[1] : options.boundsPadding) ??
                    0
            ];
            options.boundsPadding = padding;
            super(options);
        }
    }

    var index = /*#__PURE__*/Object.freeze({
        __proto__: null,
        Arc: Arc,
        CheckBox: CheckBox,
        Circle: Circle,
        Container: Container,
        Group: Group,
        GroupElement: GroupElement,
        Icon: Icon,
        Image: Image$1,
        Line: Line$1,
        Radio: Radio,
        Rect: Rect,
        Tag: Tag,
        Text: Text,
        percentCalc: percentCalc
    });

    function createDataset(options) {
        const layoutNodeId = { seqId: 0 };
        const dataConfig = { isPivotChart: true };
        let columnDimensionTree;
        let rowDimensionTree;
        let columnTree;
        let rowTree;
        if (options.columnTree) {
            if (options.indicatorsAsCol !== false) {
                columnTree = supplementIndicatorNodesForCustomTree(options.columnTree, options.indicators);
            }
            columnDimensionTree = new DimensionTree(options.columnTree ?? [], layoutNodeId);
        }
        if (options.rowTree) {
            if (options.indicatorsAsCol === false) {
                rowTree = supplementIndicatorNodesForCustomTree(options.rowTree, options.indicators);
            }
            rowDimensionTree = new DimensionTree(options.rowTree ?? [], layoutNodeId);
        }
        const rowKeys = rowDimensionTree.dimensionKeys?.count
            ? rowDimensionTree.dimensionKeys.valueArr()
            : options.rows?.reduce((keys, rowObj) => {
                if (typeof rowObj === 'string') {
                    keys.push(rowObj);
                }
                else {
                    keys.push(rowObj.dimensionKey);
                }
                return keys;
            }, []) ?? [];
        const columnKeys = columnDimensionTree.dimensionKeys?.count
            ? columnDimensionTree.dimensionKeys.valueArr()
            : options.columns?.reduce((keys, columnObj) => {
                if (typeof columnObj === 'string') {
                    keys.push(columnObj);
                }
                else {
                    keys.push(columnObj.dimensionKey);
                }
                return keys;
            }, []) ?? [];
        const indicatorKeys = options.indicators?.reduce((keys, indicatorObj) => {
            if (typeof indicatorObj === 'string') {
                keys.push(indicatorObj);
            }
            else {
                keys.push(indicatorObj.indicatorKey);
            }
            return keys;
        }, []) ?? [];
        dataConfig.collectValuesBy = _generateCollectValuesConfig(options, columnKeys, rowKeys);
        dataConfig.aggregationRules = _generateAggregationRules(options);
        const dataset = new Dataset(dataConfig, rowKeys, columnKeys, indicatorKeys, options.indicators, options.indicatorsAsCol ?? true, options.records, undefined, undefined, columnTree || options.columnTree, rowTree || options.rowTree, true);
        return { dataset, columnDimensionTree, rowDimensionTree, layoutNodeId };
    }
    function _generateCollectValuesConfig(option, columnKeys, rowKeys) {
        const collectValuesBy = {};
        for (let i = 0, len = option.indicators?.length; i < len; i++) {
            if (typeof option.indicators[i] !== 'string' && option.indicators[i].chartSpec) {
                if (option.indicatorsAsCol === false) {
                    const indicatorDefine = option.indicators[i];
                    collectValuesBy[indicatorDefine.indicatorKey] = {
                        by: rowKeys,
                        range: true,
                        sumBy: indicatorDefine.chartSpec?.stack !== false &&
                            columnKeys.concat(indicatorDefine.chartSpec?.xField)
                    };
                    if (indicatorDefine.chartSpec.series) {
                        indicatorDefine.chartSpec.series.forEach((chartSeries) => {
                            const xField = typeof chartSeries.xField === 'string' ? chartSeries.xField : chartSeries.xField[0];
                            collectValuesBy[xField] = {
                                by: columnKeys,
                                type: chartSeries.direction !== 'horizontal' ? 'xField' : undefined,
                                range: chartSeries.direction === 'horizontal',
                                sortBy: chartSeries.direction !== 'horizontal'
                                    ? chartSeries?.data?.fields?.[xField]?.domain ??
                                        indicatorDefine.chartSpec?.data?.fields?.[xField]?.domain
                                    : undefined
                            };
                            const yField = chartSeries.yField;
                            collectValuesBy[yField] = {
                                by: rowKeys,
                                range: chartSeries.direction !== 'horizontal',
                                sumBy: chartSeries.stack !== false && columnKeys.concat(chartSeries?.xField),
                                sortBy: chartSeries.direction === 'horizontal'
                                    ? chartSeries?.data?.fields?.[yField]?.domain ??
                                        indicatorDefine.chartSpec?.data?.fields?.[yField]?.domain
                                    : undefined
                            };
                        });
                    }
                    else {
                        const xField = typeof indicatorDefine.chartSpec.xField === 'string'
                            ? indicatorDefine.chartSpec.xField
                            : indicatorDefine.chartSpec.xField[0];
                        collectValuesBy[xField] = {
                            by: columnKeys,
                            type: indicatorDefine.chartSpec.direction !== 'horizontal' ? 'xField' : undefined,
                            range: indicatorDefine.chartSpec.direction === 'horizontal',
                            sortBy: indicatorDefine.chartSpec.direction !== 'horizontal'
                                ? indicatorDefine.chartSpec?.data?.fields?.[xField]?.domain
                                : undefined
                        };
                        const yField = indicatorDefine.chartSpec.yField;
                        collectValuesBy[yField] = {
                            by: rowKeys,
                            range: option.indicators[i].chartSpec.direction !== 'horizontal',
                            sumBy: indicatorDefine.chartSpec.stack !== false &&
                                columnKeys.concat(indicatorDefine.chartSpec?.xField),
                            sortBy: indicatorDefine.chartSpec.direction === 'horizontal'
                                ? indicatorDefine.chartSpec?.data?.fields?.[yField]?.domain
                                : undefined
                        };
                    }
                }
                else {
                    const indicatorDefine = option.indicators[i];
                    collectValuesBy[indicatorDefine.indicatorKey] = {
                        by: columnKeys,
                        range: true,
                        sumBy: indicatorDefine.chartSpec?.stack !== false &&
                            rowKeys.concat(indicatorDefine.chartSpec?.yField)
                    };
                    if (indicatorDefine.chartSpec.series) {
                        indicatorDefine.chartSpec.series.forEach((chartSeries) => {
                            const yField = typeof chartSeries.yField === 'string' ? chartSeries.yField : chartSeries.yField[0];
                            collectValuesBy[yField] = {
                                by: rowKeys,
                                type: chartSeries.direction === 'horizontal' ? 'yField' : undefined,
                                range: chartSeries.direction !== 'horizontal',
                                sortBy: chartSeries.direction === 'horizontal'
                                    ? chartSeries?.data?.fields?.[yField]?.domain ??
                                        indicatorDefine.chartSpec?.data?.fields?.[yField]?.domain
                                    : undefined
                            };
                            const xField = chartSeries.xField;
                            collectValuesBy[xField] = {
                                by: columnKeys,
                                range: chartSeries.direction === 'horizontal',
                                sumBy: chartSeries.stack !== false && rowKeys.concat(chartSeries?.yField),
                                sortBy: chartSeries.direction !== 'horizontal'
                                    ? chartSeries?.data?.fields?.[xField]?.domain ??
                                        indicatorDefine.chartSpec?.data?.fields?.[xField]?.domain
                                    : undefined
                            };
                        });
                    }
                    else {
                        const yField = typeof indicatorDefine.chartSpec.yField === 'string'
                            ? indicatorDefine.chartSpec.yField
                            : indicatorDefine.chartSpec.yField[0];
                        collectValuesBy[yField] = {
                            by: rowKeys,
                            type: indicatorDefine.chartSpec.direction === 'horizontal' ? 'yField' : undefined,
                            range: indicatorDefine.chartSpec.direction !== 'horizontal',
                            sortBy: indicatorDefine.chartSpec.direction === 'horizontal'
                                ? indicatorDefine.chartSpec?.data?.fields?.[yField]?.domain
                                : undefined
                        };
                        const xField = indicatorDefine.chartSpec.xField;
                        collectValuesBy[xField] = {
                            by: columnKeys,
                            range: option.indicators[i].chartSpec.direction === 'horizontal',
                            sumBy: indicatorDefine.chartSpec.stack !== false &&
                                rowKeys.concat(indicatorDefine.chartSpec?.yField),
                            sortBy: indicatorDefine.chartSpec.direction !== 'horizontal'
                                ? indicatorDefine.chartSpec?.data?.fields?.[xField]?.domain
                                : undefined
                        };
                    }
                }
            }
        }
        return collectValuesBy;
    }
    function _generateAggregationRules(options) {
        const aggregationRules = [];
        options.indicators?.forEach((indicator) => {
            if (typeof indicator === 'string') {
                aggregationRules.push({
                    indicatorKey: indicator,
                    field: indicator,
                    aggregationType: AggregationType.RECORD
                });
            }
            else {
                if (indicator.chartSpec?.series) {
                    const fields = [];
                    indicator.chartSpec?.series.forEach((seriesSpec) => {
                        const seriesField = options.indicatorsAsCol === false ? seriesSpec.yField : seriesSpec.xField;
                        if (fields.indexOf(seriesField) === -1) {
                            fields.push(seriesField);
                        }
                    });
                    aggregationRules.push({
                        indicatorKey: indicator.indicatorKey,
                        field: fields,
                        aggregationType: AggregationType.RECORD
                    });
                }
                else {
                    const field = options.indicatorsAsCol === false
                        ? indicator.chartSpec.yField
                        : indicator.chartSpec.xField;
                    aggregationRules.push({
                        indicatorKey: indicator.indicatorKey,
                        field: field ?? indicator.indicatorKey,
                        aggregationType: AggregationType.RECORD
                    });
                }
            }
        });
        return aggregationRules;
    }

    function getDataCellPath(options, data, compareFunc) {
        const results = createDataset(options);
        let columnDimensionTree = results.columnDimensionTree;
        let rowDimensionTree = results.rowDimensionTree;
        let isNeedResetColumnDimensionTree = false;
        let isNeedResetRowDimensionTree = false;
        if (options.columnTree) {
            if (options.indicatorsAsCol && !columnDimensionTree.dimensionKeys.contain(IndicatorDimensionKeyPlaceholder)) {
                isNeedResetColumnDimensionTree = true;
            }
        }
        if (options.rowTree) {
            if (!options.indicatorsAsCol && !rowDimensionTree.dimensionKeys.contain(IndicatorDimensionKeyPlaceholder)) {
                isNeedResetRowDimensionTree = true;
            }
        }
        const { dataset, layoutNodeId } = results;
        const mockTable = {
            options,
            layoutNodeId,
            internalProps: options,
            isPivotChart: () => true,
            pivotChartAxes: [],
            _selectedDataItemsInChart: [],
            _getActiveChartInstance: () => {
                return {
                    updateState: () => {
                    }
                };
            }
        };
        if (!options.columnTree || isNeedResetColumnDimensionTree) {
            columnDimensionTree = new DimensionTree(dataset.colHeaderTree ?? [], layoutNodeId);
        }
        if (!options.rowTree || isNeedResetRowDimensionTree) {
            rowDimensionTree = new DimensionTree(dataset.rowHeaderTree ?? [], layoutNodeId);
        }
        const layoutMap = new PivotHeaderLayoutMap(mockTable, dataset, columnDimensionTree, rowDimensionTree);
        for (let col = 0; col < layoutMap.colCount; col++) {
            for (let row = 0; row < layoutMap.rowCount; row++) {
                if (layoutMap.isHeader(col, row)) {
                    continue;
                }
                const cellDimensionPath = layoutMap.getCellHeaderPaths(col, row);
                const colKeys = cellDimensionPath.colHeaderPaths.map((colPath) => {
                    return colPath.indicatorKey ?? colPath.value;
                });
                const rowKeys = cellDimensionPath.rowHeaderPaths.map((rowPath) => {
                    return rowPath.indicatorKey ?? rowPath.value;
                });
                const aggregator = dataset.getAggregator(!layoutMap.indicatorsAsCol ? rowKeys.slice(0, -1) : rowKeys, layoutMap.indicatorsAsCol ? colKeys.slice(0, -1) : colKeys, layoutMap.getIndicatorKey(col, row));
                const result = compareData(aggregator.value ? aggregator.value() : undefined, data, col, row, layoutMap, compareFunc);
                if (result) {
                    return result;
                }
            }
        }
        return undefined;
    }
    function compareData(data1, data2, col, row, layoutMap, compareFunc) {
        if (isArray$7(data1)) {
            for (let i = 0; i < data1.length; i++) {
                if (compareFunc ? compareFunc(data1[i], data2) : defaultCompare(data1[i], data2)) {
                    return layoutMap.getCellHeaderPaths(col, row);
                }
            }
        }
        return undefined;
    }
    function defaultCompare(a, b) {
        return JSON.stringify(a) === JSON.stringify(b);
    }

    function VTag(params) {
        return new Tag$1(params ? params.attribute : {});
    }
    function VCheckBox(params) {
        return new CheckBox(params ? params.attribute : {});
    }
    function VRadio(params) {
        return new Radio(params ? params.attribute : {});
    }

    registerForVrender();
    const version = "1.18.3";
    function getIcons() {
        return get$2();
    }
    function clearGlobal() {
        clearAll();
    }

    exports.CustomLayout = index;
    exports.DataStatistics = DataStatistics;
    exports.EventTarget = EventTarget$1;
    exports.Icon = Icon$1;
    exports.ListTable = ListTableAll;
    exports.ListTableSimple = ListTableSimple;
    exports.PIVOT_CHART_EVENT_TYPE = PIVOT_CHART_EVENT_TYPE;
    exports.PIVOT_TABLE_EVENT_TYPE = PIVOT_TABLE_EVENT_TYPE;
    exports.PivotChart = PivotChart;
    exports.PivotTable = PivotTableAll;
    exports.PivotTableSimple = PivotTableSimple;
    exports.TABLE_EVENT_TYPE = TABLE_EVENT_TYPE;
    exports.TYPES = index$2;
    exports.VArc = VArc;
    exports.VArea = VArea;
    exports.VCheckBox = VCheckBox;
    exports.VCircle = VCircle;
    exports.VGlyph = VGlyph;
    exports.VGroup = VGroup;
    exports.VImage = VImage;
    exports.VLine = VLine;
    exports.VPath = VPath;
    exports.VPolygon = VPolygon;
    exports.VRadio = VRadio;
    exports.VRect = VRect;
    exports.VSymbol = VSymbol;
    exports.VTag = VTag;
    exports.VText = VText;
    exports.clearGlobal = clearGlobal;
    exports.core = core;
    exports.data = data;
    exports.getDataCellPath = getDataCellPath;
    exports.getIcons = getIcons;
    exports.getTargetCell = getTargetCell;
    exports.graphicUtil = graphicUtil;
    exports.jsx = jsx;
    exports.plugins = index$1;
    exports.register = register$1;
    exports.registerAxis = registerAxis;
    exports.registerButtonCell = registerButtonCell;
    exports.registerChartCell = registerChartCell;
    exports.registerCheckboxCell = registerCheckboxCell;
    exports.registerEmptyTip = registerEmptyTip;
    exports.registerImageCell = registerImageCell;
    exports.registerLegend = registerLegend;
    exports.registerMenu = registerMenu;
    exports.registerProgressBarCell = registerProgressBarCell;
    exports.registerRadioCell = registerRadioCell;
    exports.registerSparkLineCell = registerSparkLineCell;
    exports.registerSwitchCell = registerSwitchCell;
    exports.registerTextCell = registerTextCell;
    exports.registerTitle = registerTitle;
    exports.registerTooltip = registerTooltip;
    exports.registerVideoCell = registerVideoCell;
    exports.renderChart = renderChart;
    exports.restoreMeasureText = restoreMeasureText;
    exports.setCustomAlphabetCharSet = setCustomAlphabetCharSet;
    exports.textMeasure = textMeasure;
    exports.themes = themes$1;
    exports.updateCell = updateCell$1;
    exports.version = version;

}));
