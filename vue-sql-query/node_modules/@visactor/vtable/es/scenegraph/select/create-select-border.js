import { createRect } from "./../../vrender";

export function createCellSelectBorder(scene, start_Col, start_Row, end_Col, end_Row, selectRangeType, selectId, strokes) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    let isHasFillHandleRect = !!(null === (_a = scene.table.options.excelOptions) || void 0 === _a ? void 0 : _a.fillHandle);
    if ((null === (_b = scene.table.stateManager.select.ranges) || void 0 === _b ? void 0 : _b.length) > 1) isHasFillHandleRect = !1, 
    scene.removeFillHandleFromSelectComponents(); else if (1 === (null === (_c = scene.table.stateManager.select.ranges) || void 0 === _c ? void 0 : _c.length)) {
        const maxRow = Math.max(scene.table.stateManager.select.ranges[0].start.row, scene.table.stateManager.select.ranges[0].end.row), maxCol = Math.max(scene.table.stateManager.select.ranges[0].start.col, scene.table.stateManager.select.ranges[0].end.col);
        scene.table.isHeader(maxCol, maxRow) && (isHasFillHandleRect = !1);
    }
    !Array.isArray(strokes) || !1 !== strokes[1] && !1 !== strokes[2] || (isHasFillHandleRect = !1);
    const startCol = Math.min(start_Col, end_Col), startRow = Math.min(start_Row, end_Row), endCol = Math.max(start_Col, end_Col), endRow = Math.max(start_Row, end_Row), firstCellBound = scene.highPerformanceGetCell(startCol, startRow).globalAABBBounds, lastCellBound = scene.highPerformanceGetCell(endCol, endRow).globalAABBBounds, theme = scene.table.theme, bodyClickBorderColor = null === (_d = theme.selectionStyle) || void 0 === _d ? void 0 : _d.cellBorderColor, bodyClickLineWidth = null === (_e = theme.selectionStyle) || void 0 === _e ? void 0 : _e.cellBorderLineWidth, rect = createRect({
        pickable: !1,
        fill: "replace" !== (null === (_f = theme.selectionStyle) || void 0 === _f ? void 0 : _f.selectionFillMode) && (null !== (_h = null === (_g = theme.selectionStyle) || void 0 === _g ? void 0 : _g.cellBgColor) && void 0 !== _h ? _h : "rgba(0, 0, 255,0.1)"),
        lineWidth: bodyClickLineWidth,
        stroke: strokes.map((stroke => !!stroke && bodyClickBorderColor)),
        x: firstCellBound.x1 - scene.tableGroup.attribute.x,
        y: firstCellBound.y1 - scene.tableGroup.attribute.y,
        width: 0,
        height: 0,
        visible: !0,
        cornerRadius: getCornerRadius(selectRangeType, null === (_j = scene.table.theme.frameStyle) || void 0 === _j ? void 0 : _j.cornerRadius, start_Col, start_Row, end_Col, end_Row, scene.table)
    });
    let fillhandle;
    isHasFillHandleRect && (fillhandle = createRect({
        pickable: !1,
        fill: bodyClickBorderColor,
        stroke: bodyClickBorderColor,
        x: lastCellBound.x2 - 3,
        y: lastCellBound.y2 - 3,
        width: 6,
        height: 6,
        visible: !0
    })), scene.lastSelectId = selectId, scene.selectingRangeComponents.set(`${startCol}-${startRow}-${endCol}-${endRow}-${selectId}`, {
        rect: rect,
        fillhandle: fillhandle,
        role: selectRangeType
    }), scene.tableGroup.insertAfter(rect, "body" === selectRangeType ? scene.bodyGroup : "columnHeader" === selectRangeType ? scene.colHeaderGroup : "rowHeader" === selectRangeType ? scene.rowHeaderGroup : "cornerHeader" === selectRangeType ? scene.cornerHeaderGroup : "rightTopCorner" === selectRangeType ? scene.rightTopCornerGroup : "rightFrozen" === selectRangeType ? scene.rightFrozenGroup : "leftBottomCorner" === selectRangeType ? scene.leftBottomCornerGroup : "bottomFrozen" === selectRangeType ? scene.bottomFrozenGroup : scene.rightBottomCornerGroup), 
    isHasFillHandleRect && scene.tableGroup.insertAfter(fillhandle, "body" === selectRangeType ? scene.bodyGroup : "columnHeader" === selectRangeType ? scene.colHeaderGroup : "rowHeader" === selectRangeType ? scene.rowHeaderGroup : "cornerHeader" === selectRangeType ? scene.cornerHeaderGroup : "rightTopCorner" === selectRangeType ? scene.rightTopCornerGroup : "rightFrozen" === selectRangeType ? scene.rightFrozenGroup : "leftBottomCorner" === selectRangeType ? scene.leftBottomCornerGroup : "bottomFrozen" === selectRangeType ? scene.bottomFrozenGroup : scene.rightBottomCornerGroup);
}

function getCornerRadius(selectRangeType, cornerRadius, start_Col, start_Row, end_Col, end_Row, table) {
    if (!cornerRadius) return;
    const cornerRadiusArray = Array.isArray(cornerRadius) ? cornerRadius : [ cornerRadius, cornerRadius, cornerRadius, cornerRadius ], tableEndCol = table.colCount - 1, tableEndRow = table.rowCount - 1, result = [ 0, 0, 0, 0 ];
    let changed = !1;
    return 0 === start_Col && 0 === start_Row ? (result[0] = cornerRadiusArray[0], changed = !0) : end_Col === tableEndCol && end_Row === tableEndRow ? (result[2] = cornerRadiusArray[2], 
    changed = !0) : 0 === start_Col && end_Row === tableEndRow ? (result[3] = cornerRadiusArray[3], 
    changed = !0) : end_Col === tableEndCol && 0 === start_Row && (result[1] = cornerRadiusArray[1], 
    changed = !0), changed ? result : void 0;
}
//# sourceMappingURL=create-select-border.js.map
