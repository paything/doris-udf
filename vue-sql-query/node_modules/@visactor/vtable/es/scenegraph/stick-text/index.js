import { isNumber } from "@visactor/vutils";

import { getCellMergeRange } from "../../tools/merge-range";

export function resetTextStick(table) {
    const {changedCells: changedCells} = table.internalProps.stick;
    return changedCells.forEach((cellPos => {
        table.scenegraph.getCell(cellPos.col, cellPos.row).forEachChildren((child => {
            child.setAttributes({
                dx: cellPos.dx,
                dy: cellPos.dy
            });
        }));
    })), changedCells.clear(), changedCells;
}

export function handleTextStick(table) {
    const changedCells = resetTextStick(table), {scrollTop: scrollTop, scrollLeft: scrollLeft, frozenRowCount: frozenRowCount, frozenColCount: frozenColCount} = table, frozenRowsHeight = table.getFrozenRowsHeight(), frozenColsWidth = table.getFrozenColsWidth(), {row: rowTop} = table.getRowAt(scrollTop + frozenRowsHeight + 1), {col: colLeft} = table.getColAt(scrollLeft + frozenColsWidth + 1), rowStart = Math.max(rowTop, table.frozenRowCount), colStart = Math.max(colLeft, table.frozenColCount), rowEnd = table.getAllRowsHeight() > table.tableNoFrameHeight ? table.getRowAt(scrollTop + table.tableNoFrameHeight - table.getBottomFrozenRowsHeight() - 1).row : table.rowCount - table.bottomFrozenRowCount - 1, colEnd = table.getAllColsWidth() > table.tableNoFrameWidth ? table.getColAt(scrollLeft + table.tableNoFrameWidth - table.getRightFrozenColsWidth() - 1).col : table.colCount - table.rightFrozenColCount - 1;
    if (!(colEnd < 0 || rowEnd < 0)) {
        for (let row = 0; row < frozenRowCount && !(colEnd < colStart); row++) [ colStart, colEnd ].forEach((col => {
            const style = table._getCellStyle(col, row);
            if ((null == style ? void 0 : style.textStick) && "vertical" !== (null == style ? void 0 : style.textStick)) {
                adjustCellContentHorizontalLayout(table.scenegraph.getCell(col, row), frozenColsWidth + table.tableX, table.tableNoFrameWidth - table.getRightFrozenColsWidth() + table.tableX, changedCells, null == style ? void 0 : style.textStickBaseOnAlign, table);
            }
        }));
        for (let col = 0; col < frozenColCount && !(rowEnd < rowStart); col++) [ rowStart, rowEnd ].forEach((row => {
            const style = table._getCellStyle(col, row);
            if ((null == style ? void 0 : style.textStick) && "horizontal" !== (null == style ? void 0 : style.textStick)) {
                adjustCellContentVerticalLayout(table.scenegraph.getCell(col, row), frozenRowsHeight + table.tableY, table.tableNoFrameHeight - table.getBottomFrozenRowsHeight() + table.tableY, changedCells, null == style ? void 0 : style.textStickBaseOnAlign, table);
            }
        }));
        for (let col = colStart; col <= colEnd && !(rowEnd < rowStart); col++) [ rowStart, rowEnd ].forEach((row => {
            const style = table._getCellStyle(col, row);
            if ((null == style ? void 0 : style.textStick) && "horizontal" !== (null == style ? void 0 : style.textStick)) {
                adjustCellContentVerticalLayout(table.scenegraph.getCell(col, row), frozenRowsHeight + table.tableY, table.tableNoFrameHeight - table.getBottomFrozenRowsHeight() + table.tableY, changedCells, null == style ? void 0 : style.textStickBaseOnAlign, table);
            }
        }));
        for (let row = rowStart; row <= rowEnd && !(colEnd < colStart); row++) [ colStart, colEnd ].forEach((col => {
            const style = table._getCellStyle(col, row);
            if ((null == style ? void 0 : style.textStick) && "vertical" !== (null == style ? void 0 : style.textStick)) {
                adjustCellContentHorizontalLayout(table.scenegraph.getCell(col, row), frozenColsWidth + table.tableX, table.tableNoFrameWidth - table.getRightFrozenColsWidth() + table.tableX, changedCells, null == style ? void 0 : style.textStickBaseOnAlign, table);
            }
        }));
    }
}

function adjustCellContentVerticalLayout(cellGroup, minTop, maxTop, changedCells, textStickBaseOnAlign, table) {
    if (isNumber(cellGroup.mergeStartCol) && isNumber(cellGroup.mergeStartRow) && isNumber(cellGroup.mergeEndCol) && isNumber(cellGroup.mergeEndRow)) {
        const {colStart: colStart, colEnd: colEnd, rowStart: rowStart, rowEnd: rowEnd} = getCellMergeRange(cellGroup, table.scenegraph);
        for (let col = colStart; col <= colEnd; col++) for (let row = rowStart; row <= rowEnd; row++) {
            const singleCellGroup = table.scenegraph.getCell(col, row);
            "cell" === singleCellGroup.role && dealVertical(singleCellGroup, minTop, maxTop, changedCells, textStickBaseOnAlign);
        }
    } else dealVertical(cellGroup, minTop, maxTop, changedCells, textStickBaseOnAlign);
}

function dealVertical(cellGroup, minTop, maxTop, changedCells, textStickBaseOnAlign) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s;
    const graphic = cellGroup.getChildByName("text", !0) || cellGroup.getChildByName("image", !0);
    if (!graphic) return;
    if ("image" === graphic.type) {
        const {image: url} = graphic.attribute;
        if (!url || !graphic.resources) return;
        if ("success" !== graphic.resources.get(url).state) return;
    }
    const textBaseline = null !== (_a = graphic.textBaseline) && void 0 !== _a ? _a : "top";
    graphic.AABBBounds.width();
    const textTop = graphic.globalAABBBounds.y1, textBottom = graphic.globalAABBBounds.y2;
    if ("middle" === textBaseline && textStickBaseOnAlign) {
        const cellTop = cellGroup.globalAABBBounds.y1 + (null !== (_c = null === (_b = cellGroup.firstChild) || void 0 === _b ? void 0 : _b.attribute.dy) && void 0 !== _c ? _c : 0), cellBottom = cellTop + (null !== (_e = null !== (_d = cellGroup.contentHeight) && void 0 !== _d ? _d : cellGroup.attribute.height) && void 0 !== _e ? _e : 0);
        if (cellTop < minTop || cellBottom > maxTop) {
            const visibleCellTop = Math.max(cellTop, minTop), visibleCellBottom = Math.min(cellBottom, maxTop), delta = graphic.globalTransMatrix.f - (visibleCellBottom + visibleCellTop) / 2 + graphic.AABBBounds.height() / 2;
            !changedCells.has(`${cellGroup.col}-${cellGroup.row}`) && changedCells.set(`${cellGroup.col}-${cellGroup.row}`, {
                col: cellGroup.col,
                row: cellGroup.row,
                dx: null !== (_g = null === (_f = cellGroup.firstChild) || void 0 === _f ? void 0 : _f.attribute.dx) && void 0 !== _g ? _g : 0,
                dy: null !== (_j = null === (_h = cellGroup.firstChild) || void 0 === _h ? void 0 : _h.attribute.dy) && void 0 !== _j ? _j : 0
            }), cellGroup.forEachChildren((child => {
                var _a;
                child.setAttribute("dy", (null !== (_a = child.attribute.dy) && void 0 !== _a ? _a : 0) - delta + 2);
            }));
        }
    } else if (textTop < minTop) {
        const deltaHeight = textTop - minTop;
        !changedCells.has(`${cellGroup.col}-${cellGroup.row}`) && changedCells.set(`${cellGroup.col}-${cellGroup.row}`, {
            col: cellGroup.col,
            row: cellGroup.row,
            dx: null !== (_l = null === (_k = cellGroup.firstChild) || void 0 === _k ? void 0 : _k.attribute.dx) && void 0 !== _l ? _l : 0,
            dy: null !== (_o = null === (_m = cellGroup.firstChild) || void 0 === _m ? void 0 : _m.attribute.dy) && void 0 !== _o ? _o : 0
        }), cellGroup.forEachChildren((child => {
            var _a;
            child.setAttribute("dy", (null !== (_a = child.attribute.dy) && void 0 !== _a ? _a : 0) - deltaHeight + 2);
        }));
    } else if (textBottom > maxTop) {
        const deltaHeight = textBottom - maxTop;
        !changedCells.has(`${cellGroup.col}-${cellGroup.row}`) && changedCells.set(`${cellGroup.col}-${cellGroup.row}`, {
            col: cellGroup.col,
            row: cellGroup.row,
            dx: null !== (_q = null === (_p = cellGroup.firstChild) || void 0 === _p ? void 0 : _p.attribute.dx) && void 0 !== _q ? _q : 0,
            dy: null !== (_s = null === (_r = cellGroup.firstChild) || void 0 === _r ? void 0 : _r.attribute.dy) && void 0 !== _s ? _s : 0
        }), cellGroup.forEachChildren((child => {
            var _a;
            child.setAttribute("dy", (null !== (_a = child.attribute.dy) && void 0 !== _a ? _a : 0) - deltaHeight);
        }));
    }
}

function adjustCellContentHorizontalLayout(cellGroup, minLeft, maxLeft, changedCells, textStickBaseOnAlign, table) {
    if (isNumber(cellGroup.mergeStartCol) && isNumber(cellGroup.mergeStartRow) && isNumber(cellGroup.mergeEndCol) && isNumber(cellGroup.mergeEndRow)) {
        const {colStart: colStart, colEnd: colEnd, rowStart: rowStart, rowEnd: rowEnd} = getCellMergeRange(cellGroup, table.scenegraph);
        for (let col = colStart; col <= colEnd; col++) for (let row = rowStart; row <= rowEnd; row++) {
            const singleCellGroup = table.scenegraph.getCell(col, row);
            "cell" === singleCellGroup.role && dealHorizontal(singleCellGroup, minLeft, maxLeft, changedCells, textStickBaseOnAlign);
        }
    } else dealHorizontal(cellGroup, minLeft, maxLeft, changedCells, textStickBaseOnAlign);
}

function dealHorizontal(cellGroup, minLeft, maxLeft, changedCells, textStickBaseOnAlign) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
    const graphic = cellGroup.getChildByName("text", !0) || cellGroup.getChildByName("image", !0);
    if (!graphic) return;
    if ("image" === graphic.type) {
        const {image: url} = graphic.attribute;
        if (!url || !graphic.resources) return;
        if ("success" !== graphic.resources.get(url).state) return;
    }
    const textAlign = null !== (_b = null !== (_a = graphic.attribute.textAlign) && void 0 !== _a ? _a : graphic.textAlign) && void 0 !== _b ? _b : "left";
    graphic.AABBBounds.width();
    const textLeft = graphic.globalAABBBounds.x1, textRight = graphic.globalAABBBounds.x2;
    if ("center" === textAlign && textStickBaseOnAlign) {
        const cellLeft = cellGroup.globalAABBBounds.x1 + (null !== (_d = null === (_c = cellGroup.firstChild) || void 0 === _c ? void 0 : _c.attribute.dx) && void 0 !== _d ? _d : 0), cellRight = cellLeft + (null !== (_f = null !== (_e = cellGroup.contentWidth) && void 0 !== _e ? _e : cellGroup.attribute.width) && void 0 !== _f ? _f : 0);
        if (cellLeft < minLeft || cellRight > maxLeft) {
            const visibleCellLeft = Math.max(cellLeft, minLeft), visibleCellRight = Math.min(cellRight, maxLeft), delta = graphic.globalTransMatrix.e - (visibleCellRight + visibleCellLeft) / 2;
            !changedCells.has(`${cellGroup.col}-${cellGroup.row}`) && changedCells.set(`${cellGroup.col}-${cellGroup.row}`, {
                col: cellGroup.col,
                row: cellGroup.row,
                dx: null !== (_h = null === (_g = cellGroup.firstChild) || void 0 === _g ? void 0 : _g.attribute.dx) && void 0 !== _h ? _h : 0,
                dy: null !== (_k = null === (_j = cellGroup.firstChild) || void 0 === _j ? void 0 : _j.attribute.dy) && void 0 !== _k ? _k : 0
            }), cellGroup.forEachChildren((child => {
                var _a;
                child.setAttribute("dx", (null !== (_a = child.attribute.dx) && void 0 !== _a ? _a : 0) - delta + 2);
            }));
        }
    } else if (textLeft < minLeft) {
        const deltaWidth = textLeft - minLeft;
        !changedCells.has(`${cellGroup.col}-${cellGroup.row}`) && changedCells.set(`${cellGroup.col}-${cellGroup.row}`, {
            col: cellGroup.col,
            row: cellGroup.row,
            dx: null !== (_m = null === (_l = cellGroup.firstChild) || void 0 === _l ? void 0 : _l.attribute.dx) && void 0 !== _m ? _m : 0,
            dy: null !== (_p = null === (_o = cellGroup.firstChild) || void 0 === _o ? void 0 : _o.attribute.dy) && void 0 !== _p ? _p : 0
        }), cellGroup.forEachChildren((child => {
            var _a;
            child.setAttribute("dx", (null !== (_a = child.attribute.dx) && void 0 !== _a ? _a : 0) - deltaWidth + 2);
        }));
    } else if (textRight > maxLeft) {
        const deltaWidth = textRight - maxLeft;
        !changedCells.has(`${cellGroup.col}-${cellGroup.row}`) && changedCells.set(`${cellGroup.col}-${cellGroup.row}`, {
            col: cellGroup.col,
            row: cellGroup.row,
            dx: null !== (_r = null === (_q = cellGroup.firstChild) || void 0 === _q ? void 0 : _q.attribute.dx) && void 0 !== _r ? _r : 0,
            dy: null !== (_t = null === (_s = cellGroup.firstChild) || void 0 === _s ? void 0 : _s.attribute.dy) && void 0 !== _t ? _t : 0
        }), cellGroup.forEachChildren((child => {
            var _a;
            child.setAttribute("dx", (null !== (_a = child.attribute.dx) && void 0 !== _a ? _a : 0) - deltaWidth);
        }));
    }
}

export function checkHaveTextStick(table) {
    var _a, _b;
    const headerObjects = table.internalProps.layoutMap.headerObjects, columnObjects = table.internalProps.layoutMap.columnObjects;
    for (let i = 0; i < headerObjects.length; i++) {
        const header = headerObjects[i];
        if (header && (null === (_a = header.style) || void 0 === _a ? void 0 : _a.textStick)) return !0;
    }
    for (let i = 0; i < columnObjects.length; i++) {
        const column = columnObjects[i];
        if (column && (null === (_b = column.style) || void 0 === _b ? void 0 : _b.textStick)) return !0;
    }
    return !!(table.theme.headerStyle.textStick || table.theme.rowHeaderStyle.textStick || table.theme.bodyStyle.textStick);
}
//# sourceMappingURL=index.js.map
