import { createStage, container, vglobal, registerForVrender } from "./../vrender";

import { InternalIconName } from "../ts-types";

import { getCellMergeInfo } from "./utils/get-cell-merge";

import { updateColWidth } from "./layout/update-width";

import { TableComponent } from "./component/table-component";

import { updateRowHeight } from "./layout/update-height";

import { updateImageCellContentWhileResize } from "./group-creater/cell-type/image-cell";

import { getQuadProps } from "./utils/padding";

import { createFrameBorder, updateCornerRadius, updateFrameBorder, updateFrameBorderSize } from "./style/frame-border";

import splitModule from "./graphic/contributions";

import { getProp } from "./utils/get-prop";

import { dealWithIcon } from "./utils/text-icon-layout";

import { SceneProxy } from "./group-creater/progress/proxy";

import { computeColWidth, computeColsWidth, getAdaptiveWidth } from "./layout/compute-col-width";

import { moveHeaderPosition } from "./layout/move-cell";

import { updateCell } from "./group-creater/cell-helper";

import { updateAllSelectComponent, updateCellSelectBorder } from "./select/update-select-border";

import { createCellSelectBorder } from "./select/create-select-border";

import { moveSelectingRangeComponentsToSelectedRangeComponents } from "./select/move-select-border";

import { deleteAllSelectBorder, deleteAllSelectingBorder, deleteLastSelectedRangeComponents, removeFillHandleFromSelectComponents } from "./select/delete-select-border";

import { updateRow } from "./layout/update-row";

import { handleTextStick } from "./stick-text";

import { computeRowHeight, computeRowsHeight } from "./layout/compute-row-height";

import { emptyGroup } from "./utils/empty-group";

import { dealBottomFrozen, dealFrozen, dealRightFrozen, resetFrozen, resetRowFrozen } from "./layout/frozen";

import { updateChartSizeForResizeColWidth, updateChartSizeForResizeRowHeight, updateChartState } from "./refresh-node/update-chart";

import { initSceneGraph } from "./group-creater/init-scenegraph";

import { updateContainerChildrenX } from "./utils/update-container";

import { setPoptipTheme } from "./../vrender";

import textMeasureModule from "./utils/text-measure";

import { getIconByXY, hideClickIcon, hideHoverIcon, resetResidentHoverIcon, residentHoverIcon, setIconHoverStyle, setIconNormalStyle, showClickIcon, showHoverIcon, updateFrozenIcon, updateHierarchyIcon, updateSortIcon } from "./icon/icon-update";

import { Env } from "../tools/env";

import { createCornerCell } from "./style/corner-cell";

import { updateCol } from "./layout/update-col";

import { deduplication } from "../tools/util";

import { dealWithAnimationAppear } from "./animation/appear";

import { updateReactContainer } from "./layout/frozen-react";

import * as registerIcons from "../icons";

import { temporarilyUpdateSelectRectStyle } from "./select/update-select-style";

registerForVrender(), container.load(splitModule), container.load(textMeasureModule);

export class Scenegraph {
    constructor(table) {
        let width, height;
        this._needUpdateContainer = !1, this.table = table, this.hasFrozen = !1, this.clear = !0, 
        this.mergeMap = new Map, setPoptipTheme(this.table.theme.textPopTipStyle), "node" === Env.mode ? (vglobal.setEnv("node", table.options.modeParams), 
        width = table.canvasWidth, height = table.canvasHeight) : table.options.canvas && table.options.viewBox ? (vglobal.setEnv("browser"), 
        width = table.options.viewBox.x2 - table.options.viewBox.x1, height = table.options.viewBox.y2 - table.options.viewBox.y1) : (vglobal.setEnv("browser"), 
        width = table.canvas.width, height = table.canvas.height), this.stage = createStage(Object.assign({
            canvas: table.canvas,
            width: width,
            height: height,
            disableDirtyBounds: !1,
            background: table.theme.underlayBackgroundColor,
            dpr: table.internalProps.pixelRatio,
            enableLayout: !0,
            beforeRender: stage => {
                this.table.options.beforeRender && this.table.options.beforeRender(stage), this.table.animationManager.ticker.start();
            },
            afterRender: stage => {
                this.table.options.afterRender && this.table.options.afterRender(stage), this.table.fireListeners("after_render", null);
            },
            canvasControled: !table.options.canvas,
            viewBox: table.options.viewBox
        }, table.options.renderOption)), this.stage.defaultLayer.setTheme({
            group: {
                boundsPadding: 0,
                strokeBoundsBuffer: 0,
                lineJoin: "round"
            },
            text: {
                ignoreBuf: !0
            }
        }), this.initSceneGraph(), this.stage.defaultLayer.add(this.tableGroup), this.stage.table = this.table, 
        this.createComponent();
    }
    get width() {
        var _a, _b;
        return null !== (_b = null === (_a = this.tableGroup.attribute) || void 0 === _a ? void 0 : _a.width) && void 0 !== _b ? _b : 0;
    }
    get height() {
        var _a, _b;
        return null !== (_b = null === (_a = this.tableGroup.attribute) || void 0 === _a ? void 0 : _a.height) && void 0 !== _b ? _b : 0;
    }
    get x() {
        var _a, _b;
        return null !== (_b = null === (_a = this.tableGroup.attribute) || void 0 === _a ? void 0 : _a.x) && void 0 !== _b ? _b : 0;
    }
    get y() {
        var _a, _b;
        return null !== (_b = null === (_a = this.tableGroup.attribute) || void 0 === _a ? void 0 : _a.y) && void 0 !== _b ? _b : 0;
    }
    get bodyRowStart() {
        var _a;
        return null !== (_a = this.proxy.rowStart) && void 0 !== _a ? _a : 0;
    }
    get bodyRowEnd() {
        var _a;
        return null !== (_a = this.proxy.rowEnd) && void 0 !== _a ? _a : this.table.rowCount - 1;
    }
    get bodyColStart() {
        var _a;
        return null !== (_a = this.proxy.colStart) && void 0 !== _a ? _a : 0;
    }
    get bodyColEnd() {
        var _a;
        return null !== (_a = this.proxy.colEnd) && void 0 !== _a ? _a : this.table.colCount - 1;
    }
    initSceneGraph() {
        this.isPivot = this.table.isPivotTable(), initSceneGraph(this);
    }
    clearCells() {
        var _a, _b;
        this.table.animationManager.clear(), (this.table.isPivotChart() || this.table._hasCustomRenderOrLayout()) && this.stage.pluginService.findPluginsByName("poptipForText").forEach((plugin => {
            plugin.deactivate(this.stage.pluginService);
        })), this.clear = !0, this.hasFrozen = !1, this.mergeMap.clear(), this.colHeaderGroup.clear(), 
        delete this.colHeaderGroup.border, this.rowHeaderGroup.clear(), delete this.rowHeaderGroup.border, 
        this.cornerHeaderGroup.clear(), delete this.cornerHeaderGroup.border, this.bodyGroup.clear(), 
        delete this.bodyGroup.border, this.bottomFrozenGroup.clear(), delete this.bottomFrozenGroup.border, 
        this.rightFrozenGroup.clear(), delete this.rightFrozenGroup.border, this.rightTopCornerGroup.clear(), 
        delete this.rightTopCornerGroup.border, this.rightBottomCornerGroup.clear(), delete this.rightBottomCornerGroup.border, 
        this.leftBottomCornerGroup.clear(), delete this.leftBottomCornerGroup.border, this.colHeaderGroup.setAttributes({
            x: 0,
            y: 0,
            width: 0,
            height: 0
        }), this.rowHeaderGroup.setAttributes({
            x: 0,
            y: 0,
            width: 0,
            height: 0
        }), this.cornerHeaderGroup.setAttributes({
            x: 0,
            y: 0,
            width: 0,
            height: 0
        }), this.bodyGroup.setAttributes({
            x: 0,
            y: 0,
            width: 0,
            height: 0
        }), this.rightFrozenGroup.setAttributes({
            x: 0,
            y: 0,
            width: 0,
            height: 0
        }), this.bottomFrozenGroup.setAttributes({
            x: 0,
            y: 0,
            width: 0,
            height: 0
        }), this.rightTopCornerGroup.setAttributes({
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            visible: !1
        }), this.leftBottomCornerGroup.setAttributes({
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            visible: !1
        }), this.rightBottomCornerGroup.setAttributes({
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            visible: !1
        }), this.tableGroup.setAttributes({
            x: this.table.tableX,
            y: this.table.tableY,
            width: 0,
            height: 0
        }), this.tableGroup.border && (this.tableGroup.parent.removeChild(this.tableGroup.border), 
        delete this.tableGroup.border), null === (_a = this.proxy) || void 0 === _a || _a.release(), 
        null === (_b = this.table.reactCustomLayout) || void 0 === _b || _b.clearCache();
    }
    updateStageBackground() {
        this.stage.background = this.table.theme.underlayBackgroundColor, this.stage.renderNextFrame();
    }
    createComponent() {
        this.component = new TableComponent(this.table), this.component.addToGroup(this.componentGroup), 
        this.selectedRangeComponents = new Map, this.selectingRangeComponents = new Map, 
        this.customSelectedRangeComponents = new Map;
    }
    updateComponent() {
        this.component.updateStyle();
    }
    createSceneGraph(skipRowHeightClear = !1) {
        skipRowHeightClear || (this.table.rowHeightsMap.clear(), this.table.internalProps.layoutMap.clearCellRangeMap()), 
        (this.table.isPivotChart() || this.table._hasCustomRenderOrLayout()) && this.stage.pluginService.autoEnablePlugins.getContributions().forEach((p => {
            "poptipForText" === p.name && this.stage.pluginService.register(p);
        })), this.clear = !1, this.frozenColCount = this.table.frozenColCount, this.frozenRowCount = this.table.frozenRowCount, 
        this.proxy = new SceneProxy(this.table), createFrameBorder(this.tableGroup, this.table.theme.frameStyle, this.tableGroup.role, void 0, !0), 
        this.table.isPivotChart() && (createCornerCell(this.rightTopCornerGroup, this.table.theme.cornerRightTopCellStyle || this.table.theme.cornerHeaderStyle || {}), 
        createCornerCell(this.leftBottomCornerGroup, this.table.theme.cornerLeftBottomCellStyle || this.table.theme.cornerHeaderStyle || {}), 
        createCornerCell(this.rightBottomCornerGroup, this.table.theme.cornerRightBottomCellStyle || this.table.theme.cornerHeaderStyle || {})), 
        this.proxy.createGroupForFirstScreen(this.cornerHeaderGroup, this.colHeaderGroup, this.rowHeaderGroup, this.rightFrozenGroup, this.bottomFrozenGroup, this.bodyGroup, 0, 0), 
        this.afterScenegraphCreated();
    }
    renderSceneGraph() {
        this.stage.render();
    }
    getCell(col, row, getShadow) {
        var _a, _b, _c, _d, _e, _f;
        let cell;
        if (cell = this.table.rightFrozenColCount > 0 && col >= this.table.colCount - this.table.rightFrozenColCount && row < this.table.frozenRowCount ? null === (_a = this.rightTopCornerGroup.getColGroup(col)) || void 0 === _a ? void 0 : _a.getRowGroup(row) : this.table.bottomFrozenRowCount > 0 && row >= this.table.rowCount - this.table.bottomFrozenRowCount && col < this.table.frozenColCount ? null === (_b = this.leftBottomCornerGroup.getColGroup(col)) || void 0 === _b ? void 0 : _b.getRowGroup(row) : this.table.rightFrozenColCount > 0 && this.table.bottomFrozenRowCount > 0 && col >= this.table.colCount - this.table.rightFrozenColCount && row >= this.table.rowCount - this.table.bottomFrozenRowCount ? null === (_c = this.rightBottomCornerGroup.getColGroup(col)) || void 0 === _c ? void 0 : _c.getRowGroup(row) : this.table.rightFrozenColCount > 0 && col > this.table.colCount - 1 - this.table.rightFrozenColCount ? null === (_d = this.rightFrozenGroup.getColGroup(col)) || void 0 === _d ? void 0 : _d.getRowGroup(row) : this.table.bottomFrozenRowCount > 0 && row > this.table.rowCount - 1 - this.table.bottomFrozenRowCount ? null === (_e = this.bottomFrozenGroup.getColGroup(col)) || void 0 === _e ? void 0 : _e.getRowGroup(row) : null === (_f = this.getColGroup(col, row < this.frozenRowCount)) || void 0 === _f ? void 0 : _f.getRowGroup(row), 
        cell && "shadow-cell" === cell.role && !getShadow) {
            const range = this.table.getCellRange(col, row);
            range.start.col === col && range.start.row === row || (cell = this.getCell(range.start.col, range.start.row));
        }
        return cell || emptyGroup;
    }
    highPerformanceGetCell(col, row, getShadow) {
        return this.proxy.highPerformanceGetCell(col, row, getShadow);
    }
    getColGroup(col, isCornerOrColHeader = !1) {
        let element;
        return element = col < this.frozenColCount && isCornerOrColHeader ? this.cornerHeaderGroup.getColGroup(col) : col < this.frozenColCount ? this.rowHeaderGroup.getColGroup(col) : isCornerOrColHeader && this.table.rightFrozenColCount > 0 && col > this.table.colCount - 1 - this.table.rightFrozenColCount ? this.rightTopCornerGroup.getColGroup(col) : !isCornerOrColHeader && this.table.rightFrozenColCount > 0 && col > this.table.colCount - 1 - this.table.rightFrozenColCount ? this.rightFrozenGroup.getColGroup(col) : isCornerOrColHeader ? this.colHeaderGroup.getColGroup(col) : this.bodyGroup.getColGroup(col), 
        element || void 0;
    }
    getColGroupInBottom(col, isCornerOrColHeader = !1) {
        var _a;
        if (isCornerOrColHeader) {
            const element = null !== (_a = this.getColGroupInLeftBottomCorner(col)) && void 0 !== _a ? _a : this.getColGroupInRightBottomCorner(col);
            if (element) return element;
        }
        if (this.table.bottomFrozenRowCount > 0) return this.bottomFrozenGroup.getColGroup(col);
    }
    getColGroupInLeftBottomCorner(col) {
        if (this.table.bottomFrozenRowCount > 0) return this.leftBottomCornerGroup.getColGroup(col);
    }
    getColGroupInRightTopCorner(col) {
        if (this.table.rightFrozenColCount > 0) return this.rightTopCornerGroup.getColGroup(col);
    }
    getColGroupInRightBottomCorner(col) {
        if (this.table.rightFrozenColCount > 0 && this.table.bottomFrozenRowCount > 0) return this.rightBottomCornerGroup.getColGroup(col);
    }
    getCellSize(col, row) {
        const cell = this.getCell(col, row), mergeInfo = getCellMergeInfo(this.table, col, row);
        let width = cell.attribute.width, height = cell.attribute.height;
        return mergeInfo && (width /= mergeInfo.end.col - mergeInfo.start.col + 1, height /= mergeInfo.end.row - mergeInfo.start.row + 1), 
        {
            width: width,
            height: height
        };
    }
    updateNextFrame() {
        this.updateContainerSync(), this.resetAllSelectComponent(), this.stage.renderNextFrame();
    }
    resetAllSelectComponent() {
        var _a, _b, _c, _d;
        ((null === (_b = null === (_a = this.table.stateManager.select) || void 0 === _a ? void 0 : _a.ranges) || void 0 === _b ? void 0 : _b.length) > 0 || (null === (_d = null === (_c = this.table.stateManager.select) || void 0 === _c ? void 0 : _c.customSelectRanges) || void 0 === _d ? void 0 : _d.length) > 0) && updateAllSelectComponent(this);
    }
    hideHoverIcon(col, row) {
        hideHoverIcon(col, row, this);
    }
    showHoverIcon(col, row) {
        showHoverIcon(col, row, this);
    }
    hideClickIcon(col, row) {
        hideClickIcon(col, row, this);
    }
    showClickIcon(col, row) {
        showClickIcon(col, row, this);
    }
    getIcon(col, row, x, y) {
        return getIconByXY(col, row, x, y, this);
    }
    setIconHoverStyle(icon, col, row, cellGroup) {
        setIconHoverStyle(icon, col, row, cellGroup, this);
    }
    updateSortIcon(options) {
        const {col: col, row: row, iconMark: iconMark, order: order, oldSortCol: oldSortCol, oldSortRow: oldSortRow, oldIconMark: oldIconMark} = options;
        updateSortIcon({
            col: col,
            row: row,
            iconMark: iconMark,
            order: order,
            oldSortCol: oldSortCol,
            oldSortRow: oldSortRow,
            oldIconMark: oldIconMark,
            scene: this
        });
    }
    updateFrozenIcon(col, oldFrozenCol) {
        updateFrozenIcon(this);
    }
    updateHierarchyIcon(col, row) {
        updateHierarchyIcon(col, row, this);
    }
    setIconNormalStyle(icon, col, row) {
        setIconNormalStyle(icon, col, row, this);
    }
    residentHoverIcon(col, row) {
        residentHoverIcon(col, row, this);
    }
    resetResidentHoverIcon(col, row) {
        resetResidentHoverIcon(col, row, this);
    }
    deactivateChart(col, row) {
        var _a, _b;
        if (-1 === col || -1 === row) return;
        const cellGroup = this.getCell(col, row);
        null === (_b = null === (_a = null == cellGroup ? void 0 : cellGroup.firstChild) || void 0 === _a ? void 0 : _a.deactivate) || void 0 === _b || _b.call(_a);
    }
    activateChart(col, row) {
        var _a, _b, _c;
        if (-1 === col || -1 === row) return;
        const cellGroup = this.getCell(col, row);
        return null === (_b = null === (_a = null == cellGroup ? void 0 : cellGroup.firstChild) || void 0 === _a ? void 0 : _a.activate) || void 0 === _b || _b.call(_a, this.table), 
        null === (_c = null == cellGroup ? void 0 : cellGroup.firstChild) || void 0 === _c ? void 0 : _c.activeChartInstance;
    }
    removeInteractionBorder(col, row) {
        const cellGroup = this.getCell(col, row);
        cellGroup.setAttribute("highlightStroke", void 0), cellGroup.setAttribute("highlightStrokeArrayWidth", void 0), 
        cellGroup.setAttribute("highlightStrokeArrayColor", void 0);
    }
    createCellSelectBorder(start_Col, start_Row, end_Col, end_Row, selectRangeType, selectId, strokes) {
        createCellSelectBorder(this, start_Col, start_Row, end_Col, end_Row, selectRangeType, selectId, strokes);
    }
    moveSelectingRangeComponentsToSelectedRangeComponents() {
        moveSelectingRangeComponentsToSelectedRangeComponents(this);
    }
    deleteLastSelectedRangeComponents() {
        deleteLastSelectedRangeComponents(this);
    }
    deleteAllSelectBorder() {
        deleteAllSelectBorder(this), deleteAllSelectingBorder(this);
    }
    updateCellSelectBorder(selectRange, extendSelectRange = !0) {
        updateCellSelectBorder(this, selectRange, extendSelectRange);
    }
    removeFillHandleFromSelectComponents() {
        removeFillHandleFromSelectComponents(this);
    }
    recreateAllSelectRangeComponents() {
        deleteAllSelectBorder(this), this.table.stateManager.select.ranges.forEach((cellRange => {
            updateCellSelectBorder(this, cellRange), moveSelectingRangeComponentsToSelectedRangeComponents(this);
        }));
    }
    updateColWidth(col, detaX, skipUpdateContainer, skipTableWidthMap) {
        updateColWidth(this, col, Math.round(detaX), skipTableWidthMap), skipUpdateContainer || this.updateContainer(!0);
    }
    updateChartSizeForResizeColWidth(col) {
        updateChartSizeForResizeColWidth(this, col);
    }
    updateChartSizeForResizeRowHeight(row) {
        updateChartSizeForResizeRowHeight(this, row);
    }
    updateChartState(datum) {
        this.table.isPivotChart() && updateChartState(this, datum);
    }
    updateCheckboxCellState(col, row, checked) {
        var _a, _b;
        if (this.table.transpose) null === (_a = this.bodyGroup.children) || void 0 === _a || _a.forEach((columnGroup => {
            var _a;
            null === (_a = columnGroup.getChildAt(row)) || void 0 === _a || _a.getChildren().forEach((node => {
                "checkbox" === node.name && ("indeterminate" === checked ? (node.setAttribute("indeterminate", !0), 
                node.setAttribute("checked", void 0)) : (node.setAttribute("indeterminate", void 0), 
                node.setAttribute("checked", checked)));
            }));
        })); else {
            const columnGroup = this.getColGroup(col);
            null === (_b = null == columnGroup ? void 0 : columnGroup.children) || void 0 === _b || _b.forEach((cellNode => {
                cellNode.getChildren().find((node => {
                    "checkbox" === node.name && ("indeterminate" === checked ? (node.setAttribute("indeterminate", !0), 
                    node.setAttribute("checked", void 0)) : (node.setAttribute("indeterminate", void 0), 
                    node.setAttribute("checked", checked)));
                }));
            }));
        }
    }
    updateHeaderCheckboxCellState(col, row, checked) {
        var _a, _b;
        if (this.table.transpose) null === (_a = this.rowHeaderGroup.children) || void 0 === _a || _a.forEach((columnGroup => {
            columnGroup.getChildAt(row).getChildren().forEach((node => {
                "checkbox" === node.name && ("indeterminate" === checked ? (node.setAttribute("indeterminate", !0), 
                node.setAttribute("checked", void 0)) : (node.setAttribute("indeterminate", void 0), 
                node.setAttribute("checked", checked)));
            }));
        })); else {
            null === (_b = this.getColGroup(col, !0).children) || void 0 === _b || _b.forEach((cellNode => {
                cellNode.getChildren().find((node => {
                    "checkbox" === node.name && ("indeterminate" === checked ? (node.setAttribute("indeterminate", !0), 
                    node.setAttribute("checked", void 0)) : (node.setAttribute("indeterminate", void 0), 
                    node.setAttribute("checked", checked)));
                }));
            }));
        }
    }
    updateAutoColWidth(col) {
        this.table.internalProps._widthResizedColMap.delete(col);
        const oldWidth = this.table.getColWidth(col), newWidth = computeColWidth(col, 0, this.table.rowCount - 1, this.table, !0);
        newWidth !== oldWidth && this.updateColWidth(col, newWidth - oldWidth);
    }
    recalculateColWidths() {
        const table = this.table;
        "adaptive" === table.widthMode || table.autoFillWidth || table.internalProps.transpose ? computeColsWidth(this.table, 0, this.table.colCount - 1, !0) : (table._clearColRangeWidthsMap(), 
        table.frozenColCount > 0 && computeColsWidth(this.table, 0, table.frozenColCount - 1, !0), 
        table.rightFrozenColCount > 0 && computeColsWidth(this.table, table.rightFrozenColCount, table.colCount - 1, !0), 
        computeColsWidth(table, this.proxy.colStart, this.proxy.colEnd, !0));
    }
    recalculateRowHeights() {
        const table = this.table;
        table.internalProps.useOneRowHeightFillAll = !1, "adaptive" === table.heightMode || table.autoFillHeight ? computeRowsHeight(this.table, 0, this.table.rowCount - 1, !0, !0) : (table.frozenRowCount > 0 && computeRowsHeight(this.table, 0, table.frozenRowCount - 1, !0, !0), 
        table.bottomFrozenRowCount > 0 && computeRowsHeight(this.table, table.bottomFrozenRowCount, table.rowCount - 1, !0, !0), 
        computeRowsHeight(table, this.proxy.rowStart, this.proxy.rowEnd, !0, !0));
    }
    resize() {
        this.proxy.resize(), ("adaptive" === this.table.widthMode || this.table.autoFillWidth) && (0 === this.table.internalProps._widthResizedColMap.size ? this.recalculateColWidths() : this.dealWidthMode()), 
        "adaptive" === this.table.heightMode ? 0 === this.table.internalProps._heightResizedRowMap.size ? this.recalculateRowHeights() : this.dealHeightMode() : this.table.autoFillHeight && this.dealHeightMode(), 
        this.resetFrozen(), this.updateTableSize(), this.updateBorderSizeAndPosition(), 
        this.component.updateScrollBar(), ("adaptive" === this.table.widthMode || "adaptive" === this.table.heightMode || this.table.autoFillWidth || this.table.autoFillHeight) && this.updateChartSizeForResizeColWidth(-1), 
        this.proxy.progress(), this.updateNextFrame();
    }
    updateTableSize() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        if (this.tableGroup.setAttributes({
            x: this.table.tableX,
            y: this.table.tableY,
            width: Math.min(this.table.tableNoFrameWidth, Math.max(this.colHeaderGroup.attribute.width, this.bodyGroup.attribute.width, this.bottomFrozenGroup.attribute.width, 0) + Math.max(this.cornerHeaderGroup.attribute.width, this.rowHeaderGroup.attribute.width, this.leftBottomCornerGroup.attribute.width, 0) + Math.max(this.rightTopCornerGroup.attribute.width, this.rightFrozenGroup.attribute.width, this.rightBottomCornerGroup.attribute.width, 0)),
            height: Math.min(this.table.tableNoFrameHeight, Math.max(this.colHeaderGroup.attribute.height, this.cornerHeaderGroup.attribute.height, this.rightTopCornerGroup.attribute.height, 0) + Math.max(this.rowHeaderGroup.attribute.height, this.bodyGroup.attribute.height, this.rightFrozenGroup.attribute.height, 0) + Math.max(this.leftBottomCornerGroup.attribute.height, this.bottomFrozenGroup.attribute.height, this.rightBottomCornerGroup.attribute.height, 0))
        }), this.tableGroup.border) {
            const rectAttributes = null === (_a = this.tableGroup.border) || void 0 === _a ? void 0 : _a.attribute;
            let borderTop, borderRight, borderBottom, borderLeft;
            (null == rectAttributes ? void 0 : rectAttributes.strokeArrayWidth) ? (borderTop = rectAttributes.strokeArrayWidth ? rectAttributes.strokeArrayWidth[0] : null !== (_b = rectAttributes.lineWidth) && void 0 !== _b ? _b : 0, 
            borderRight = rectAttributes.strokeArrayWidth ? rectAttributes.strokeArrayWidth[1] : null !== (_c = rectAttributes.lineWidth) && void 0 !== _c ? _c : 0, 
            borderBottom = rectAttributes.strokeArrayWidth ? rectAttributes.strokeArrayWidth[2] : null !== (_d = rectAttributes.lineWidth) && void 0 !== _d ? _d : 0, 
            borderLeft = rectAttributes.strokeArrayWidth ? rectAttributes.strokeArrayWidth[3] : null !== (_e = rectAttributes.lineWidth) && void 0 !== _e ? _e : 0) : (borderTop = null !== (_f = null == rectAttributes ? void 0 : rectAttributes.lineWidth) && void 0 !== _f ? _f : 0, 
            borderRight = null !== (_g = null == rectAttributes ? void 0 : rectAttributes.lineWidth) && void 0 !== _g ? _g : 0, 
            borderBottom = null !== (_h = null == rectAttributes ? void 0 : rectAttributes.lineWidth) && void 0 !== _h ? _h : 0, 
            borderLeft = null !== (_j = null == rectAttributes ? void 0 : rectAttributes.lineWidth) && void 0 !== _j ? _j : 0), 
            "rect" === this.tableGroup.border.type ? (null === (_k = this.table.theme.frameStyle) || void 0 === _k ? void 0 : _k.innerBorder) ? this.tableGroup.border.setAttributes({
                x: this.table.tableX + borderLeft / 2,
                y: this.table.tableY + borderTop / 2,
                width: this.tableGroup.attribute.width - borderLeft / 2 - borderRight / 2,
                height: this.tableGroup.attribute.height - borderTop / 2 - borderBottom / 2
            }) : this.tableGroup.border.setAttributes({
                x: this.table.tableX - borderLeft / 2,
                y: this.table.tableY - borderTop / 2,
                width: this.tableGroup.attribute.width + borderLeft / 2 + borderRight / 2,
                height: this.tableGroup.attribute.height + borderTop / 2 + borderBottom / 2
            }) : "group" === this.tableGroup.border.type && ((null === (_l = this.table.theme.frameStyle) || void 0 === _l ? void 0 : _l.innerBorder) ? (this.tableGroup.border.setAttributes({
                x: this.table.tableX + borderLeft / 2,
                y: this.table.tableY + borderTop / 2,
                width: this.tableGroup.attribute.width - borderLeft / 2 - borderRight / 2,
                height: this.tableGroup.attribute.height - borderTop / 2 - borderBottom / 2
            }), null === (_m = this.tableGroup.border.firstChild) || void 0 === _m || _m.setAttributes({
                x: 0,
                y: 0,
                width: this.tableGroup.attribute.width - borderLeft / 2 - borderRight / 2,
                height: this.tableGroup.attribute.height - borderTop / 2 - borderBottom / 2
            })) : (this.tableGroup.border.setAttributes({
                x: this.table.tableX - borderLeft / 2,
                y: this.table.tableY - borderTop / 2,
                width: this.tableGroup.attribute.width + borderLeft / 2 + borderRight / 2,
                height: this.tableGroup.attribute.height + borderTop / 2 + borderBottom / 2
            }), null === (_o = this.tableGroup.border.firstChild) || void 0 === _o || _o.setAttributes({
                x: borderLeft / 2,
                y: borderTop / 2,
                width: this.tableGroup.attribute.width,
                height: this.tableGroup.attribute.height
            })));
        }
        this.table.bottomFrozenRowCount > 0 && (this.bottomFrozenGroup.setAttribute("y", this.tableGroup.attribute.height - this.table.getBottomFrozenRowsHeight()), 
        this.leftBottomCornerGroup.setAttributes({
            visible: !0,
            y: this.tableGroup.attribute.height - this.table.getBottomFrozenRowsHeight(),
            height: this.table.getBottomFrozenRowsHeight(),
            width: this.table.getFrozenColsWidth()
        }), this.rightBottomCornerGroup.setAttributes({
            visible: !0,
            y: this.tableGroup.attribute.height - this.table.getBottomFrozenRowsHeight(),
            height: this.table.getBottomFrozenRowsHeight()
        })), this.table.rightFrozenColCount > 0 && (this.rightFrozenGroup.setAttribute("x", this.tableGroup.attribute.width - this.table.getRightFrozenColsWidth()), 
        this.rightTopCornerGroup.setAttributes({
            visible: !0,
            x: this.tableGroup.attribute.width - this.table.getRightFrozenColsWidth(),
            width: this.table.getRightFrozenColsWidth(),
            height: this.table.getFrozenRowsHeight()
        }), this.rightBottomCornerGroup.setAttributes({
            visible: !0,
            x: this.tableGroup.attribute.width - this.table.getRightFrozenColsWidth(),
            width: this.table.getRightFrozenColsWidth()
        })), this.updateDomContainer();
    }
    updateRowHeight(row, detaY, skipTableHeightMap) {
        detaY = Math.round(detaY), updateRowHeight(this, row, detaY, skipTableHeightMap), 
        this.updateContainerHeight(row, detaY);
    }
    updateRowsHeight(rows, detaYs, skipTableHeightMap) {
        for (let i = 0; i < rows.length; i++) {
            const row = rows[i];
            if (row >= this.proxy.rowStart && row <= this.proxy.rowEnd) {
                const detaY = detaYs[i];
                updateRowHeight(this, row, Math.round(detaY), skipTableHeightMap), this._updateContainerHeight(row, detaY);
            }
        }
        this.updateTableSize(), this.component.updateScrollBar(), this.updateNextFrame();
    }
    updateContainerWidth(col, detaX) {
        col < this.frozenColCount ? (this.rowHeaderGroup.setDeltaWidth(detaX), this.cornerHeaderGroup.setDeltaWidth(detaX), 
        this.colHeaderGroup.setDeltaX(detaX), this.bodyGroup.setDeltaX(detaX)) : (this.colHeaderGroup.setDeltaWidth(detaX), 
        this.bodyGroup.setDeltaWidth(detaX)), this.updateTableSize(), this.component.updateScrollBar(), 
        this.updateNextFrame();
    }
    _updateContainerHeight(row, detaY) {
        row < this.table.frozenRowCount ? (this.colHeaderGroup.setDeltaHeight(detaY), this.cornerHeaderGroup.setDeltaHeight(detaY), 
        this.rowHeaderGroup.setDeltaY(detaY), this.bodyGroup.setDeltaY(detaY), this.table.rightFrozenColCount && this.rightFrozenGroup.setDeltaY(detaY)) : row >= this.table.rowCount - this.table.bottomFrozenRowCount ? (this.leftBottomCornerGroup.setDeltaHeight(detaY), 
        this.bottomFrozenGroup.setDeltaHeight(detaY), this.table.rightFrozenColCount && this.rightBottomCornerGroup.setDeltaHeight(detaY)) : (this.rowHeaderGroup.setDeltaHeight(detaY), 
        this.bodyGroup.setDeltaHeight(detaY), this.table.rightFrozenColCount && this.rightFrozenGroup.setDeltaHeight(detaY));
    }
    updateContainerHeight(row, detaY) {
        this._updateContainerHeight(row, detaY), this.updateTableSize(), this.component.updateScrollBar(), 
        this.updateNextFrame();
    }
    setColWidth(col, width) {
        const oldWidth = this.table.getColWidth(col);
        oldWidth !== width && (this.updateColWidth(col, width - oldWidth), this.table._clearColRangeWidthsMap(col));
    }
    setRowHeight(row, height) {
        const oldHeight = this.table.getRowHeight(row);
        oldHeight !== height && ((row >= this.proxy.rowStart && row <= this.proxy.rowEnd || row >= this.table.rowCount - this.table.bottomFrozenRowCount && row <= this.table.rowCount - 1 || row < this.table.frozenRowCount) && this.updateRowHeight(row, height - oldHeight), 
        this.table._clearRowRangeHeightsMap(row));
    }
    setX(x, isEnd = !1) {
        this.table.scenegraph.proxy.setX(-x, isEnd);
    }
    setY(y, isEnd = !1) {
        this.table.scenegraph.proxy.setY(-y, isEnd);
    }
    setBodyAndRowHeaderY(y) {
        var _a, _b, _c, _d, _e, _f;
        const firstBodyCell = null !== (_b = null === (_a = this.bodyGroup.firstChild) || void 0 === _a ? void 0 : _a.firstChild) && void 0 !== _b ? _b : null === (_c = this.rowHeaderGroup.firstChild) || void 0 === _c ? void 0 : _c.firstChild, lastBodyCell = null !== (_e = null === (_d = this.bodyGroup.firstChild) || void 0 === _d ? void 0 : _d.lastChild) && void 0 !== _e ? _e : null === (_f = this.rowHeaderGroup.firstChild) || void 0 === _f ? void 0 : _f.lastChild;
        0 === y && firstBodyCell && firstBodyCell.row === this.table.frozenRowCount && firstBodyCell.attribute.y + y < 0 ? y = -firstBodyCell.attribute.y : lastBodyCell && this.table.tableNoFrameHeight < this.table.getAllRowsHeight() && lastBodyCell.row === this.table.rowCount - this.table.bottomFrozenRowCount - 1 && lastBodyCell.attribute.y + lastBodyCell.attribute.height + y < this.table.tableNoFrameHeight - this.table.getFrozenRowsHeight() - this.table.getBottomFrozenRowsHeight() && (y = this.table.tableNoFrameHeight - this.table.getFrozenRowsHeight() - this.table.getBottomFrozenRowsHeight() - lastBodyCell.attribute.y - lastBodyCell.attribute.height), 
        this.colHeaderGroup.attribute.height + y !== this.bodyGroup.attribute.y && (this.bodyGroup.setAttribute("y", this.colHeaderGroup.attribute.height + y), 
        this.rowHeaderGroup.setAttribute("y", this.cornerHeaderGroup.attribute.height + y), 
        this.table.rightFrozenColCount > 0 && this.rightFrozenGroup.setAttribute("y", this.rightTopCornerGroup.attribute.height + y), 
        this.updateNextFrame());
    }
    setBodyAndColHeaderX(x) {
        const firstBodyCol = this.bodyGroup.firstChild, lastBodyCol = this.bodyGroup.lastChild;
        0 === x && firstBodyCol && firstBodyCol.col === this.table.frozenColCount && firstBodyCol.attribute.x + x < 0 ? x = -firstBodyCol.attribute.x : lastBodyCol && this.table.tableNoFrameWidth < this.table.getAllColsWidth() && lastBodyCol.col === this.table.colCount - this.table.rightFrozenColCount - 1 && lastBodyCol.attribute.x + lastBodyCol.attribute.width + x < this.table.tableNoFrameWidth - this.table.getFrozenColsWidth() - this.table.getRightFrozenColsWidth() && (x = this.table.tableNoFrameWidth - this.table.getFrozenColsWidth() - this.table.getRightFrozenColsWidth() - lastBodyCol.attribute.x - lastBodyCol.attribute.width), 
        this.table.getFrozenColsWidth() + x !== this.bodyGroup.attribute.x && (this.bodyGroup.setAttribute("x", this.table.getFrozenColsWidth() + x), 
        this.colHeaderGroup.setAttribute("x", this.table.getFrozenColsWidth() + x), this.table.bottomFrozenRowCount > 0 && this.bottomFrozenGroup.setAttribute("x", this.table.getFrozenColsWidth() + x), 
        this.updateNextFrame());
    }
    afterScenegraphCreated() {
        this.isPivot || this.table.transpose ? this.table.options.frozenColCount ? this.component.setFrozenColumnShadow(this.table.frozenColCount - 1) : this.table.options.rightFrozenColCount ? this.component.setRightFrozenColumnShadow(this.table.colCount - this.table.rightFrozenColCount) : this.component.setFrozenColumnShadow(-1) : (this.component.setFrozenColumnShadow(this.table.frozenColCount - 1), 
        this.component.setRightFrozenColumnShadow(this.table.colCount - this.table.rightFrozenColCount)), 
        this.table.stateManager.checkFrozen(), this.updateContainer(), this.createFrameBorder(), 
        this.updateBorderSizeAndPosition(), this.component.updateScrollBar(), handleTextStick(this.table), 
        this.table.options.animationAppear && dealWithAnimationAppear(this.table), this.updateNextFrame();
    }
    dealWidthMode() {
        const table = this.table;
        if ("adaptive" === table.widthMode) {
            table._clearColRangeWidthsMap();
            const canvasWidth = table.tableNoFrameWidth;
            let actualHeaderWidth = 0, startCol = 0, endCol = table.colCount;
            if ("only-body" === table.widthAdaptiveMode) {
                for (let col = 0; col < table.colCount; col++) if (col < table.rowHeaderLevelCount || table.isPivotChart() && col >= table.colCount - table.rightFrozenColCount) {
                    actualHeaderWidth += table.getColWidth(col);
                }
                startCol = table.rowHeaderLevelCount, endCol = table.isPivotChart() ? table.colCount - table.rightFrozenColCount : table.colCount;
            }
            getAdaptiveWidth(canvasWidth - actualHeaderWidth, startCol, endCol, !1, [], table, !0);
        } else if (table.autoFillWidth) {
            table._clearColRangeWidthsMap();
            const canvasWidth = table.tableNoFrameWidth;
            let actualHeaderWidth = 0, actualWidth = 0;
            for (let col = 0; col < table.colCount; col++) {
                const colWidth = table.getColWidth(col);
                (col < table.rowHeaderLevelCount || table.isPivotChart() && col >= table.colCount - table.rightFrozenColCount) && (actualHeaderWidth += colWidth), 
                actualWidth += colWidth;
            }
            if (actualWidth < canvasWidth && actualWidth > actualHeaderWidth) {
                const startCol = table.rowHeaderLevelCount, endCol = table.isPivotChart() ? table.colCount - table.rightFrozenColCount : table.colCount;
                getAdaptiveWidth(canvasWidth - actualHeaderWidth, startCol, endCol, !1, [], table, !0);
            }
        }
        let bodyWidth = 0;
        this.bodyGroup.forEachChildrenSkipChild((column => {
            bodyWidth += column.attribute.width;
        })), this.bodyGroup.setAttribute("width", bodyWidth);
        let colHeaderWidth = 0;
        this.colHeaderGroup.forEachChildrenSkipChild((column => {
            colHeaderWidth += column.attribute.width;
        })), this.colHeaderGroup.setAttribute("width", colHeaderWidth);
        let rowHeaderWidth = 0;
        this.rowHeaderGroup.forEachChildrenSkipChild((column => {
            rowHeaderWidth += column.attribute.width;
        })), this.rowHeaderGroup.setAttribute("width", rowHeaderWidth);
        let cornerHeaderWidth = 0;
        this.cornerHeaderGroup.forEachChildrenSkipChild((column => {
            cornerHeaderWidth += column.attribute.width;
        })), this.cornerHeaderGroup.setAttribute("width", cornerHeaderWidth), this.colHeaderGroup.setAttribute("x", this.cornerHeaderGroup.attribute.width), 
        this.rowHeaderGroup.setAttribute("y", this.cornerHeaderGroup.attribute.height), 
        this.bodyGroup.setAttributes({
            x: this.rowHeaderGroup.attribute.width,
            y: this.colHeaderGroup.attribute.height
        });
    }
    dealHeightMode() {
        var _a;
        const table = this.table;
        if ("adaptive" === table.heightMode) {
            table._clearRowRangeHeightsMap();
            const columnHeaderHeight = table.getRowsHeight(0, table.columnHeaderLevelCount - 1), bottomHeaderHeight = table.isPivotChart() ? table.getBottomFrozenRowsHeight() : 0, totalDrawHeight = table.tableNoFrameHeight - columnHeaderHeight - bottomHeaderHeight, startRow = table.columnHeaderLevelCount, endRow = table.isPivotChart() ? table.rowCount - table.bottomFrozenRowCount : table.rowCount;
            let actualHeight = 0;
            for (let row = startRow; row < endRow; row++) actualHeight += table.getRowHeight(row);
            const factor = totalDrawHeight / actualHeight;
            for (let row = startRow; row < endRow; row++) {
                let rowHeight;
                rowHeight = row === endRow - 1 ? totalDrawHeight - table.getRowsHeight(startRow, endRow - 2) : Math.round(table.getRowHeight(row) * factor), 
                this.setRowHeight(row, rowHeight);
            }
        } else if (table.autoFillHeight) {
            table._clearRowRangeHeightsMap();
            const canvasHeight = table.tableNoFrameHeight;
            let actualHeight = 0, actualHeaderHeight = 0;
            for (let row = 0; row < table.rowCount; row++) {
                const rowHeight = table.getRowHeight(row);
                (row < table.columnHeaderLevelCount || table.isPivotChart() && row >= table.rowCount - table.bottomFrozenRowCount) && (actualHeaderHeight += rowHeight), 
                actualHeight += rowHeight;
            }
            if ((null !== (_a = this._dealAutoFillHeightOriginRowsHeight) && void 0 !== _a ? _a : actualHeight) < canvasHeight && actualHeight - actualHeaderHeight > 0) {
                const startRow = table.columnHeaderLevelCount, endRow = table.isPivotChart() ? table.rowCount - table.bottomFrozenRowCount : table.rowCount, factor = (canvasHeight - actualHeaderHeight) / (actualHeight - actualHeaderHeight);
                for (let row = startRow; row < endRow; row++) {
                    let rowHeight;
                    rowHeight = row === endRow - 1 ? canvasHeight - actualHeaderHeight - table.getRowsHeight(startRow, endRow - 2) : Math.round(table.getRowHeight(row) * factor), 
                    this.setRowHeight(row, rowHeight);
                }
            }
        }
    }
    dealFrozen() {
        dealFrozen(this);
    }
    resetFrozen() {
        resetFrozen(this);
    }
    resetRowFrozen() {
        resetRowFrozen(this);
    }
    updateCellLayoutWidthCertainWidth(columnGroup, detaRow, col) {
        const width = columnGroup.attribute.width;
        let isUpdate = !1;
        return columnGroup.forEachChildren(((cellGroup, row) => {
            row += detaRow;
            const mergeInfo = getCellMergeInfo(this.table, col, row);
            mergeInfo ? cellGroup = this.getCell(mergeInfo.start.col, mergeInfo.start.row) : cellGroup.setAttribute("width", width);
            const headerStyle = this.table._getCellStyle(col, row), padding = getQuadProps(getProp("padding", headerStyle, col, row, this.table)), text = cellGroup.getChildByName("text");
            let oldCellHeight = 0, newCellHeight = 0;
            if (text) oldCellHeight = text.AABBBounds.height() + (padding[0] + padding[2]), 
            text.setAttribute("maxLineWidth", width - (padding[1] + padding[3])), newCellHeight = text.AABBBounds.height() + (padding[0] + padding[2]); else {
                const group = cellGroup.getChildAt(1);
                oldCellHeight = group.AABBBounds.height() + (padding[0] + padding[2]), group._cellWidth = width - (padding[1] + padding[3]), 
                group.layout(), newCellHeight = group.AABBBounds.height() + (padding[0] + padding[2]);
            }
            const rowHeight = this.table.getRowHeight(row);
            cellGroup.attribute.height !== newCellHeight && (cellGroup.setAttribute("height", newCellHeight), 
            (rowHeight === oldCellHeight || newCellHeight > rowHeight) && (isUpdate = !0));
        })), isUpdate;
    }
    updateHeaderPosition(updateColStart, updateColEnd, updateRowStart, updateRowEnd, moveType) {
        moveHeaderPosition(updateColStart, updateColEnd, updateRowStart, updateRowEnd, moveType, this.table);
    }
    updateContainerAttrWidthAndX() {
        var _a, _b, _c;
        const cornerX = updateContainerChildrenX(this.cornerHeaderGroup, 0), rowHeaderX = updateContainerChildrenX(this.rowHeaderGroup, 0), colHeaderX = this.colHeaderGroup.hasChildNodes() && this.colHeaderGroup.firstChild ? updateContainerChildrenX(this.colHeaderGroup, this.colHeaderGroup.firstChild.col > 0 ? this.table.getColsWidth(null !== (_a = this.table.frozenColCount) && void 0 !== _a ? _a : 0, this.colHeaderGroup.firstChild.col - 1) : 0) : 0, bodyX = this.bodyGroup.hasChildNodes() && this.bodyGroup.firstChild ? updateContainerChildrenX(this.bodyGroup, this.bodyGroup.firstChild.col > 0 ? this.table.getColsWidth(null !== (_b = this.table.frozenColCount) && void 0 !== _b ? _b : 0, this.bodyGroup.firstChild.col - 1) : 0) : 0, rightX = updateContainerChildrenX(this.rightFrozenGroup.childrenCount > 0 ? this.rightFrozenGroup : this.rightTopCornerGroup, 0);
        this.bottomFrozenGroup.hasChildNodes() && this.bottomFrozenGroup.firstChild && updateContainerChildrenX(this.bottomFrozenGroup, this.bottomFrozenGroup.firstChild.col > 0 ? this.table.getColsWidth(null !== (_c = this.table.frozenColCount) && void 0 !== _c ? _c : 0, this.bottomFrozenGroup.firstChild.col - 1) : 0), 
        updateContainerChildrenX(this.leftBottomCornerGroup, 0), updateContainerChildrenX(this.rightTopCornerGroup, 0), 
        updateContainerChildrenX(this.rightBottomCornerGroup, 0), this.cornerHeaderGroup.setDeltaWidth(cornerX - this.cornerHeaderGroup.attribute.width), 
        this.leftBottomCornerGroup.setDeltaWidth(cornerX - this.leftBottomCornerGroup.attribute.width), 
        this.colHeaderGroup.setDeltaWidth(colHeaderX - this.colHeaderGroup.attribute.width), 
        this.rowHeaderGroup.setDeltaWidth(rowHeaderX - this.rowHeaderGroup.attribute.width), 
        this.bottomFrozenGroup.setDeltaWidth(colHeaderX - this.bottomFrozenGroup.attribute.width), 
        this.rightFrozenGroup.setDeltaWidth(rightX - this.rightFrozenGroup.attribute.width), 
        this.rightTopCornerGroup.setDeltaWidth(rightX - this.rightTopCornerGroup.attribute.width), 
        this.rightBottomCornerGroup.setDeltaWidth(rightX - this.rightBottomCornerGroup.attribute.width), 
        this.bodyGroup.setDeltaWidth(bodyX - this.bodyGroup.attribute.width), this.colHeaderGroup.setAttribute("x", this.cornerHeaderGroup.attribute.width), 
        this.bottomFrozenGroup.setAttribute("x", this.table.getFrozenColsWidth()), this.bodyGroup.setAttribute("x", this.rowHeaderGroup.attribute.width);
    }
    updateContainer(async = !1) {
        async ? this._needUpdateContainer || (this._needUpdateContainer = !0, setTimeout((() => {
            this.updateContainerSync();
        }), 0)) : (this._needUpdateContainer = !0, this.updateContainerSync());
    }
    updateContainerSync() {
        this._needUpdateContainer && (this._needUpdateContainer = !1, this.updateContainerAttrWidthAndX(), 
        this.updateTableSize(), this.component.updateScrollBar(), this.updateNextFrame());
    }
    updateCellContentWhileResize(col, row) {
        var _a;
        const type = (null === (_a = this.table.getCellRawRecord(col, row)) || void 0 === _a ? void 0 : _a.vtableMerge) ? "text" : this.table.isHeader(col, row) ? this.table._getHeaderLayoutMap(col, row).headerType : this.table.getBodyColumnType(col, row), cellGroup = this.getCell(col, row);
        "image" !== type && "video" !== type || updateImageCellContentWhileResize(cellGroup, col, row, 0, 0, this.table);
    }
    createFrameBorder() {
        var _a, _b, _c, _d, _e;
        this.updateTableSize();
        const isListTableWithFrozen = !this.isPivot && !this.table.internalProps.transpose;
        createFrameBorder(this.bodyGroup, this.table.theme.bodyStyle.frameStyle, this.bodyGroup.role, isListTableWithFrozen ? [ !0, !0, !0, !1 ] : void 0), 
        createFrameBorder(this.rowHeaderGroup, this.isPivot || this.table.internalProps.transpose ? this.table.theme.rowHeaderStyle.frameStyle : this.table.theme.bodyStyle.frameStyle, this.rowHeaderGroup.role, isListTableWithFrozen ? [ !0, !1, !0, !0 ] : void 0), 
        createFrameBorder(this.colHeaderGroup, this.table.theme.headerStyle.frameStyle, this.colHeaderGroup.role, isListTableWithFrozen ? [ !0, !0, !0, !1 ] : void 0), 
        createFrameBorder(this.cornerHeaderGroup, this.isPivot ? this.table.theme.cornerHeaderStyle.frameStyle : this.table.theme.headerStyle.frameStyle, this.cornerHeaderGroup.role, isListTableWithFrozen ? [ !0, !1, !0, !0 ] : void 0), 
        (null === (_a = this.table.theme.cornerLeftBottomCellStyle) || void 0 === _a ? void 0 : _a.frameStyle) && createFrameBorder(this.leftBottomCornerGroup, this.table.theme.cornerLeftBottomCellStyle.frameStyle, this.leftBottomCornerGroup.role, isListTableWithFrozen ? [ !0, !1, !0, !0 ] : void 0), 
        (null === (_b = this.table.theme.bottomFrozenStyle) || void 0 === _b ? void 0 : _b.frameStyle) && createFrameBorder(this.bottomFrozenGroup, this.table.theme.bottomFrozenStyle.frameStyle, this.bottomFrozenGroup.role, isListTableWithFrozen ? [ !0, !0, !0, !1 ] : void 0), 
        (null === (_c = this.table.theme.rightFrozenStyle) || void 0 === _c ? void 0 : _c.frameStyle) && createFrameBorder(this.rightFrozenGroup, this.table.theme.rightFrozenStyle.frameStyle, this.rightFrozenGroup.role, void 0), 
        (null === (_d = this.table.theme.cornerRightTopCellStyle) || void 0 === _d ? void 0 : _d.frameStyle) && createFrameBorder(this.rightTopCornerGroup, this.table.theme.cornerRightTopCellStyle.frameStyle, this.rightTopCornerGroup.role, void 0), 
        (null === (_e = this.table.theme.cornerRightBottomCellStyle) || void 0 === _e ? void 0 : _e.frameStyle) && createFrameBorder(this.rightBottomCornerGroup, this.table.theme.cornerRightBottomCellStyle.frameStyle, this.rightBottomCornerGroup.role, void 0), 
        createFrameBorder(this.tableGroup, this.table.theme.frameStyle, this.tableGroup.role, void 0);
    }
    getResizeColAt(abstractX, abstractY, cellGroup) {
        const offset = this.table.theme.columnResize.resizeHotSpotSize / 2;
        let cell;
        if (!cellGroup) {
            const drawRange = this.table.getDrawRange();
            return abstractY >= drawRange.top && abstractY <= drawRange.bottom && (cell = this.table.getCellAtRelativePosition(abstractX - offset, abstractY), 
            cell.col === this.table.colCount - 1) ? cell : {
                col: -1,
                row: -1
            };
        }
        return cellGroup.stage ? (abstractX < cellGroup.globalAABBBounds.x1 + offset ? cell = {
            col: cellGroup.col - 1,
            row: cellGroup.row,
            x: cellGroup.globalAABBBounds.x1
        } : cellGroup.globalAABBBounds.x2 - offset < abstractX && (cell = {
            col: cellGroup.col,
            row: cellGroup.row,
            x: cellGroup.globalAABBBounds.x2
        }), cell && this.table.rightFrozenColCount > 0 && cell.col >= this.table.colCount - this.table.rightFrozenColCount - 1 && this.table.tableNoFrameWidth - this.table.getFrozenColsWidth() - this.table.getRightFrozenColsWidth() + this.table.scrollLeft < this.bodyGroup.attribute.width && (cell.col = cell.col + 1, 
        cell.rightFrozen = !0), cell || {
            col: -1,
            row: -1
        }) : {
            col: -1,
            row: -1
        };
    }
    getResizeRowAt(abstractX, abstractY, cellGroup) {
        const offset = this.table.theme.columnResize.resizeHotSpotSize / 2;
        if (cellGroup) {
            let cell;
            if (abstractY < cellGroup.globalAABBBounds.y1 + offset ? cell = {
                col: cellGroup.col,
                row: cellGroup.row - 1,
                y: cellGroup.globalAABBBounds.y1
            } : cellGroup.globalAABBBounds.y2 - offset < abstractY && (cell = {
                col: cellGroup.col,
                row: cellGroup.row,
                y: cellGroup.globalAABBBounds.y2
            }), cell && this.table.bottomFrozenRowCount > 0 && cell.row >= this.table.rowCount - this.table.bottomFrozenRowCount - 1 && this.table.tableNoFrameHeight - this.table.getFrozenRowsHeight() - this.table.getBottomFrozenRowsHeight() + this.table.scrollTop < this.bodyGroup.attribute.height && (cell.row = cell.row + 1, 
            cell.bottomFrozen = !0), cell) return cell;
        } else ;
        return {
            col: -1,
            row: -1
        };
    }
    updateFrozen() {
        this.clear || (this.resetFrozen(), this.component.updateScrollBar());
    }
    updateRowFrozen() {
        this.clear || (this.resetRowFrozen(), this.component.updateScrollBar());
    }
    dealWidthRightFrozen(rightFrozenColCount) {
        this.clear ? this.table.internalProps.rightFrozenColCount = rightFrozenColCount : dealRightFrozen(rightFrozenColCount, this);
    }
    dealWidthBottomFrozen(bottomFrozenRowCount) {
        this.clear ? this.table.internalProps.bottomFrozenRowCount = bottomFrozenRowCount : dealBottomFrozen(bottomFrozenRowCount, this);
    }
    updateBorderSizeAndPosition() {
        this.bodyGroup.border && (this.bodyGroup.appendChild(this.bodyGroup.border), updateFrameBorderSize(this.bodyGroup), 
        this.rowHeaderGroup.attribute.width, updateFrameBorder(this.bodyGroup, this.table.theme.bodyStyle.frameStyle)), 
        this.colHeaderGroup.border && (this.colHeaderGroup.appendChild(this.colHeaderGroup.border), 
        updateFrameBorderSize(this.colHeaderGroup), this.cornerHeaderGroup.attribute.width, 
        updateFrameBorder(this.colHeaderGroup, this.table.theme.headerStyle.frameStyle)), 
        this.rowHeaderGroup.border && (this.rowHeaderGroup.appendChild(this.rowHeaderGroup.border), 
        updateFrameBorderSize(this.rowHeaderGroup)), this.cornerHeaderGroup.border && (this.cornerHeaderGroup.appendChild(this.cornerHeaderGroup.border), 
        updateFrameBorderSize(this.cornerHeaderGroup)), this.leftBottomCornerGroup.border && (this.leftBottomCornerGroup.appendChild(this.leftBottomCornerGroup.border), 
        updateFrameBorderSize(this.leftBottomCornerGroup)), this.bottomFrozenGroup.border && (this.bottomFrozenGroup.appendChild(this.bottomFrozenGroup.border), 
        updateFrameBorderSize(this.bottomFrozenGroup)), this.rightFrozenGroup.border && (this.rightFrozenGroup.appendChild(this.rightFrozenGroup.border), 
        updateFrameBorderSize(this.rightFrozenGroup)), this.rightTopCornerGroup.border && (this.rightTopCornerGroup.appendChild(this.rightTopCornerGroup.border), 
        updateFrameBorderSize(this.rightTopCornerGroup)), this.rightBottomCornerGroup.border && (this.rightBottomCornerGroup.appendChild(this.rightBottomCornerGroup.border), 
        updateFrameBorderSize(this.rightBottomCornerGroup)), updateCornerRadius(this.table);
    }
    sortCell() {
        this.isPivot || (this.table.transpose ? this.proxy.sortCellHorizontal() : this.proxy.sortCellVertical());
    }
    getCellOverflowText(col, row) {
        const text = this.getCell(col, row).getChildByName("text", !0);
        if (text && "text" === text.type) {
            if (text.attribute.moreThanMaxCharacters) return this.table.getCellValue(col, row);
            if (text.cliped) return this.table.getCellValue(col, row);
        } else if (text && "richtext" === text.type) {
            const richtext = text;
            if (richtext.attribute.ellipsis && richtext._frameCache && richtext.attribute.height < richtext._frameCache.actualHeight) {
                richtext.attribute.textConfig.find((item => item.text));
                return this.table.getCellValue(col, row);
            }
        }
        return null;
    }
    updateDrill(visible, x, y, drillDown, drillUp) {
        this.component.drillIcon.update(visible, x, y, drillDown, drillUp, this);
    }
    updateCellContent(col, row, forceFastUpdate = !1) {
        if (!this.clear) return updateCell(col, row, this.table, void 0, void 0, forceFastUpdate);
    }
    setPixelRatio(pixelRatio) {
        this.stage.disableDirtyBounds(), this.stage.window.setDpr(pixelRatio), this.stage.render(), 
        this.stage.enableDirtyBounds();
    }
    updateRow(removeCells, addCells, updateCells = [], recalculateColWidths = !0, skipUpdateProxy) {
        this.table.internalProps.layoutMap.clearCellRangeMap(), this.table.internalProps.useOneRowHeightFillAll = !1;
        const addRows = deduplication(addCells.map((cell => cell.row))).sort(((a, b) => a - b)), updateRows = deduplication(updateCells.map((cell => cell.row))).sort(((a, b) => a - b)), isNotFillHeight = this.table.getAllRowsHeight() - [ ...addRows, ...updateRows ].reduce(((tolHeight, rowNumber) => tolHeight + this.table.getRowHeight(rowNumber)), 0) <= this.table.tableNoFrameHeight;
        if (updateRow(removeCells, addCells, updateCells, this.table, skipUpdateProxy), 
        recalculateColWidths && this.recalculateColWidths(), "adaptive" === this.table.heightMode || this.table.autoFillHeight && (this.table.getAllRowsHeight() <= this.table.tableNoFrameHeight || isNotFillHeight)) this.table.scenegraph.recalculateRowHeights(); else if (this.table.isAutoRowHeight(this.table.columnHeaderLevelCount)) for (let i = 0; i < updateRows.length; i++) {
            const row = updateRows[i], oldHeight = this.table.getRowHeight(row), newHeight = computeRowHeight(row, 0, this.table.colCount - 1, this.table);
            (row >= this.proxy.rowStart && row <= this.proxy.rowEnd || row >= this.table.rowCount - this.table.bottomFrozenRowCount && row <= this.table.rowCount - 1) && this.table.scenegraph.updateRowHeight(row, newHeight - oldHeight);
        }
        this.table.stateManager.checkFrozen(), this.isPivot || this.table.transpose ? this.table.options.frozenColCount ? this.component.setFrozenColumnShadow(this.table.frozenColCount - 1) : this.table.options.rightFrozenColCount && this.component.setRightFrozenColumnShadow(this.table.colCount - this.table.rightFrozenColCount) : (this.component.setFrozenColumnShadow(this.table.frozenColCount - 1), 
        this.component.setRightFrozenColumnShadow(this.table.colCount - this.table.rightFrozenColCount)), 
        this.component.updateScrollBar(), this.updateNextFrame();
    }
    updateCol(removeCells, addCells, updateCells = []) {
        updateCol(removeCells, addCells, updateCells, this.table), this.recalculateColWidths(), 
        this.recalculateRowHeights(), this.table.stateManager.checkFrozen(), this.isPivot || this.table.transpose ? this.table.options.frozenColCount ? this.component.setFrozenColumnShadow(this.table.frozenColCount - 1) : this.table.options.rightFrozenColCount && this.component.setRightFrozenColumnShadow(this.table.colCount - this.table.rightFrozenColCount) : (this.component.setFrozenColumnShadow(this.table.frozenColCount - 1), 
        this.component.setRightFrozenColumnShadow(this.table.colCount - this.table.rightFrozenColCount)), 
        this.component.updateScrollBar(), this.updateNextFrame();
    }
    updateCornerHeaderCells() {
        for (let col = 0; col < this.table.frozenColCount; col++) for (let row = 0; row < this.table.frozenRowCount; row++) updateCell(col, row, this.table, !1);
    }
    updateRowHeaderCells() {
        for (let col = 0; col < this.table.frozenColCount; col++) for (let row = this.table.frozenRowCount; row < this.table.rowCount; row++) updateCell(col, row, this.table, !1);
    }
    updateColumnHeaderCells() {
        for (let row = 0; row < this.table.frozenRowCount; row++) for (let col = this.table.frozenColCount; col < this.table.colCount; col++) updateCell(col, row, this.table, !1);
    }
    getColumnGroupX(col) {
        return col < this.table.rowHeaderLevelCount ? this.table.getColsWidth(0, col - 1) : col < this.table.colCount - this.table.rightFrozenColCount ? this.table.getColsWidth(this.table.rowHeaderLevelCount, col - 1) : col < this.table.colCount ? this.table.getColsWidth(this.table.colCount - this.table.bottomFrozenRowCount, col - 1) : 0;
    }
    getCellGroupY(row) {
        return row < this.table.frozenRowCount ? this.table.getRowsHeight(0, row - 1) : row < this.table.rowCount - this.table.bottomFrozenRowCount ? this.table.getRowsHeight(this.table.frozenRowCount, row - 1) : row < this.table.rowCount ? this.table.getRowsHeight(this.table.rowCount - this.table.bottomFrozenRowCount, row - 1) : 0;
    }
    getCellGroupX(col) {
        return col < this.table.rowHeaderLevelCount ? this.table.getColsWidth(0, col - 1) : col < this.table.colCount - this.table.rightFrozenColCount ? this.table.getColsWidth(this.table.rowHeaderLevelCount, col - 1) : col < this.table.colCount ? this.table.getColsWidth(this.table.colCount - this.table.rightFrozenColCount, col - 1) : 0;
    }
    updateDomContainer() {
        updateReactContainer(this.table);
    }
    setLoadingHierarchyState(col, row) {
        const cellGroup = this.getCell(col, row), iconGraphic = cellGroup.getChildByName("collapse", !0) || cellGroup.getChildByName("expand", !0);
        if (iconGraphic) {
            const loadingIcon = registerIcons.get()[InternalIconName.loadingIconName];
            loadingIcon && dealWithIcon(loadingIcon, iconGraphic, col, row);
        }
    }
    temporarilyUpdateSelectRectStyle(rectAttribute) {
        temporarilyUpdateSelectRectStyle(rectAttribute, this);
    }
    resetSelectRectStyle() {
        this.recreateAllSelectRangeComponents();
    }
}
//# sourceMappingURL=scenegraph.js.map
