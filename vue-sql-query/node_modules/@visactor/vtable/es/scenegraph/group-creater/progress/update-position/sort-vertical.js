var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))((function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator.throw(value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            var value;
            result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P((function(resolve) {
                resolve(value);
            }))).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    }));
};

import { computeRowsHeight } from "../../../layout/compute-row-height";

import { updateRowContent } from "./dynamic-set-y";

import { updateAutoRow } from "./update-auto-row";

export function sortVertical(proxy) {
    var _a;
    return __awaiter(this, void 0, void 0, (function*() {
        let syncTopRow, syncBottomRow;
        proxy.table.scenegraph.bodyGroup.forEachChildren(((colGroup, index) => {
            "group" === colGroup.type && (colGroup.needUpdate = !0, null == colGroup || colGroup.forEachChildren((cellGroup => {
                cellGroup.needUpdate = !0;
            })));
        })), proxy.table.isAutoRowHeight(proxy.rowStart) ? (syncTopRow = proxy.rowStart, 
        syncBottomRow = proxy.rowEnd) : (syncTopRow = Math.max(proxy.bodyTopRow, proxy.screenTopRow - 1 * proxy.screenRowCount), 
        syncBottomRow = Math.min(proxy.bodyBottomRow, proxy.screenTopRow + 2 * proxy.screenRowCount, proxy.table.rowCount - 1));
        const oldBodyHeight = proxy.table.getAllRowsHeight();
        computeRowsHeight(proxy.table, syncTopRow, syncBottomRow);
        const newBodyHeight = proxy.table.getAllRowsHeight();
        oldBodyHeight !== newBodyHeight && proxy.table.scenegraph.updateContainerHeight(proxy.table.frozenRowCount, newBodyHeight - oldBodyHeight);
        for (let col = 0; col < (null !== (_a = proxy.table.frozenColCount) && void 0 !== _a ? _a : 0); col++) {
            const columnGroup = proxy.table.scenegraph.getColGroup(col);
            null == columnGroup || columnGroup.setAttribute("chartInstance", void 0);
            for (let row = proxy.rowStart; row <= proxy.rowEnd; row++) proxy.table.scenegraph.updateCellContent(col, row);
            for (let row = proxy.table.rowCount - proxy.table.bottomFrozenRowCount; row < proxy.table.rowCount; row++) proxy.table.scenegraph.updateCellContent(col, row);
        }
        for (let col = proxy.colStart; col <= proxy.colEnd; col++) {
            const columnGroup = proxy.table.scenegraph.getColGroup(col);
            null == columnGroup || columnGroup.setAttribute("chartInstance", void 0);
            for (let row = proxy.table.rowCount - proxy.table.bottomFrozenRowCount; row < proxy.table.rowCount; row++) proxy.table.scenegraph.updateCellContent(col, row);
        }
        for (let col = proxy.table.colCount - proxy.table.rightFrozenColCount; col < proxy.table.colCount; col++) {
            const columnGroup = proxy.table.scenegraph.getColGroup(col);
            null == columnGroup || columnGroup.setAttribute("chartInstance", void 0);
            for (let row = proxy.rowStart; row <= proxy.rowEnd; row++) proxy.table.scenegraph.updateCellContent(col, row);
            for (let row = proxy.table.rowCount - proxy.table.bottomFrozenRowCount; row < proxy.table.rowCount; row++) proxy.table.scenegraph.updateCellContent(col, row);
        }
        updateRowContent(syncTopRow, syncBottomRow, proxy), proxy.table.isAutoRowHeight(syncTopRow) && updateAutoRow(proxy.bodyLeftCol, proxy.bodyRightCol, syncTopRow, syncBottomRow, proxy.table, proxy.rowEnd > proxy.bodyBottomRow - (proxy.rowEnd - proxy.rowStart + 1) ? "down" : "up"), 
        proxy.rowUpdatePos = proxy.rowStart, proxy.rowUpdateDirection = proxy.rowEnd > proxy.bodyBottomRow - (proxy.rowEnd - proxy.rowStart + 1) ? "down" : "up", 
        proxy.table.scenegraph.updateNextFrame(), proxy.table.isAutoRowHeight(proxy.rowStart) || (yield proxy.progress());
    }));
}
//# sourceMappingURL=sort-vertical.js.map
