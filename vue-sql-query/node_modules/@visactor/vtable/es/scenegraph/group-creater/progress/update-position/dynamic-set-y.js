var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))((function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator.throw(value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            var value;
            result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P((function(resolve) {
                resolve(value);
            }))).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    }));
};

import { computeRowsHeight } from "../../../layout/compute-row-height";

import { updateAutoRow } from "./update-auto-row";

import { getLastChild } from "./util";

export function dynamicSetY(y, screenTop, isEnd, proxy) {
    return __awaiter(this, void 0, void 0, (function*() {
        if (!screenTop) return;
        const screenTopRow = screenTop.row, screenTopY = screenTop.top;
        let deltaRow;
        if (deltaRow = isEnd ? proxy.bodyBottomRow - proxy.rowEnd : screenTopRow - proxy.referenceRow, 
        move(deltaRow, screenTopRow, screenTopY, y, proxy), isEnd) {
            const cellGroup = proxy.table.scenegraph.highPerformanceGetCell(proxy.colStart, proxy.rowEnd, !0);
            if ("cell" === cellGroup.role) {
                const deltaY = cellGroup.attribute.y + cellGroup.attribute.height - (proxy.table.tableNoFrameHeight - proxy.table.getFrozenRowsHeight() - proxy.table.getBottomFrozenRowsHeight()) - y;
                proxy.deltaY = -deltaY, proxy.updateBody(y - proxy.deltaY);
            }
        }
    }));
}

function move(deltaRow, screenTopRow, screenTopY, y, proxy) {
    deltaRow > 0 ? (moveCell(deltaRow, "up", screenTopRow, screenTopY, y, proxy), proxy.updateDeltaY(y, screenTopY, screenTopRow), 
    proxy.updateBody(y - proxy.deltaY)) : deltaRow < 0 ? (moveCell(-deltaRow, "down", screenTopRow, screenTopY, y, proxy), 
    proxy.updateDeltaY(y, screenTopY, screenTopRow), proxy.updateBody(y - proxy.deltaY)) : (proxy.updateDeltaY(y, screenTopY, screenTopRow), 
    proxy.updateBody(y - proxy.deltaY));
}

function moveCell(count, direction, screenTopRow, screenTopY, y, proxy) {
    return __awaiter(this, void 0, void 0, (function*() {
        if ("up" === direction && proxy.rowEnd + count > proxy.bodyBottomRow ? count = proxy.bodyBottomRow - proxy.rowEnd : "down" === direction && proxy.rowStart - count < proxy.bodyTopRow && (count = proxy.rowStart - proxy.bodyTopRow), 
        0 !== count) if (count < 0 && (direction = "up" === direction ? "down" : "up", count = -count), 
        count < proxy.rowEnd - proxy.rowStart) {
            const startRow = "up" === direction ? proxy.rowStart : proxy.rowEnd - count + 1, endRow = "up" === direction ? proxy.rowStart + count - 1 : proxy.rowEnd, distStartRow = "up" === direction ? proxy.rowEnd + 1 : proxy.rowStart - count, distEndRow = "up" === direction ? proxy.rowEnd + count : proxy.rowStart - 1;
            let syncTopRow, syncBottomRow;
            if (proxy.table.isAutoRowHeight(startRow)) syncTopRow = distStartRow, syncBottomRow = distEndRow; else {
                syncTopRow = Math.max(proxy.bodyTopRow, screenTopRow - 1 * proxy.screenRowCount), 
                syncBottomRow = Math.min(proxy.bodyBottomRow, screenTopRow + 2 * proxy.screenRowCount, proxy.table.rowCount - 1);
            }
            computeRowsHeight(proxy.table, syncTopRow, syncBottomRow, !1), updatePartRowPosition(startRow, endRow, direction, proxy), 
            proxy.rowStart = "up" === direction ? proxy.rowStart + count : proxy.rowStart - count, 
            proxy.rowEnd = "up" === direction ? proxy.rowEnd + count : proxy.rowEnd - count;
            const sync = updateRowContent(syncTopRow, syncBottomRow, proxy, !0);
            proxy.table.isAutoRowHeight(startRow) && (updateAutoRow(proxy.bodyLeftCol, proxy.bodyRightCol, syncTopRow, syncBottomRow, proxy.table, distEndRow > proxy.bodyBottomRow - (proxy.rowEnd - proxy.rowStart + 1) ? "down" : "up", !0), 
            updateAutoRow(0, proxy.table.frozenColCount - 1, syncTopRow, syncBottomRow, proxy.table, distEndRow > proxy.bodyBottomRow - (proxy.rowEnd - proxy.rowStart + 1) ? "down" : "up", !0), 
            updateAutoRow(proxy.table.colCount - proxy.table.rightFrozenColCount, proxy.table.colCount - 1, syncTopRow, syncBottomRow, proxy.table, distEndRow > proxy.bodyBottomRow - (proxy.rowEnd - proxy.rowStart + 1) ? "down" : "up", !0)), 
            proxy.currentRow = "up" === direction ? proxy.currentRow + count : proxy.currentRow - count, 
            proxy.totalRow = Math.max(0, Math.min(proxy.bodyBottomRow, "up" === direction ? proxy.totalRow + count : proxy.totalRow - count, proxy.table.rowCount - 1)), 
            proxy.referenceRow = proxy.rowStart + Math.floor((proxy.rowEnd - proxy.rowStart) / 2), 
            proxy.table.isAutoRowHeight(startRow) && sync ? proxy.rowUpdatePos = Math.min(proxy.rowUpdatePos, proxy.rowEnd + 1) : proxy.rowUpdatePos = Math.min(proxy.rowUpdatePos, distStartRow), 
            proxy.rowUpdateDirection = direction, proxy.table.scenegraph.updateNextFrame(), 
            yield proxy.progress();
        } else {
            const distStartRow = "up" === direction ? proxy.rowStart + count : proxy.rowStart - count, distEndRow = Math.min(proxy.table.rowCount - 1, "up" === direction ? proxy.rowEnd + count : proxy.rowEnd - count), distStartRowY = proxy.table.getRowsHeight(proxy.bodyTopRow, distStartRow - 1);
            let syncTopRow, syncBottomRow;
            proxy.table.isAutoRowHeight(distStartRow) ? (syncTopRow = distStartRow, syncBottomRow = distEndRow) : (syncTopRow = Math.max(proxy.bodyTopRow, screenTopRow - 1 * proxy.screenRowCount), 
            syncBottomRow = Math.min(proxy.bodyBottomRow, screenTopRow + 2 * proxy.screenRowCount, proxy.table.rowCount - 1)), 
            computeRowsHeight(proxy.table, syncTopRow, syncBottomRow, !1), updateAllRowPosition(distStartRowY, count, direction, proxy), 
            proxy.rowStart = distStartRow, proxy.rowEnd = distEndRow;
            const sync = updateRowContent(syncTopRow, syncBottomRow, proxy, !0);
            proxy.table.isAutoRowHeight(distStartRow) && (updateAutoRow(proxy.bodyLeftCol, proxy.bodyRightCol, syncTopRow, syncBottomRow, proxy.table, distEndRow > proxy.bodyBottomRow - (proxy.rowEnd - proxy.rowStart + 1) ? "down" : "up"), 
            updateAutoRow(0, proxy.table.frozenColCount - 1, syncTopRow, syncBottomRow, proxy.table, distEndRow > proxy.bodyBottomRow - (proxy.rowEnd - proxy.rowStart + 1) ? "down" : "up"), 
            updateAutoRow(proxy.table.colCount - proxy.table.rightFrozenColCount, proxy.table.colCount - 1, syncTopRow, syncBottomRow, proxy.table, distEndRow > proxy.bodyBottomRow - (proxy.rowEnd - proxy.rowStart + 1) ? "down" : "up")), 
            proxy.currentRow = "up" === direction ? proxy.currentRow + count : proxy.currentRow - count, 
            proxy.totalRow = Math.max(0, Math.min(proxy.bodyBottomRow, "up" === direction ? proxy.totalRow + count : proxy.totalRow - count, proxy.table.rowCount - 1)), 
            proxy.referenceRow = proxy.rowStart + Math.floor((proxy.rowEnd - proxy.rowStart) / 2), 
            proxy.table.isAutoRowHeight(distStartRow) && sync ? proxy.rowUpdatePos = proxy.rowEnd + 1 : proxy.rowUpdatePos = proxy.rowStart, 
            proxy.rowUpdateDirection = distEndRow > proxy.bodyBottomRow - (proxy.rowEnd - proxy.rowStart + 1) ? "down" : "up", 
            proxy.table.scenegraph.updateNextFrame(), yield proxy.progress();
        }
    }));
}

function updatePartRowPosition(startRow, endRow, direction, proxy) {
    for (let col = 0; col < proxy.table.frozenColCount; col++) {
        const colGroup = proxy.table.scenegraph.getColGroup(col);
        if (colGroup) for (let row = startRow; row <= endRow; row++) updateCellGroupPosition(colGroup, direction, proxy);
    }
    for (let col = proxy.table.colCount - proxy.table.rightFrozenColCount; col < proxy.table.colCount; col++) {
        const colGroup = proxy.table.scenegraph.getColGroup(col);
        if (colGroup) for (let row = startRow; row <= endRow; row++) updateCellGroupPosition(colGroup, direction, proxy);
    }
    for (let col = proxy.bodyLeftCol; col <= proxy.bodyRightCol; col++) {
        const colGroup = proxy.table.scenegraph.getColGroup(col);
        if (colGroup) for (let row = startRow; row <= endRow; row++) updateCellGroupPosition(colGroup, direction, proxy);
    }
}

function updateCellGroupPosition(colGroup, direction, proxy) {
    if (colGroup.childrenCount >= 1) if ("up" === direction) {
        const cellGroup = colGroup.firstChild;
        proxy.updateCellGroupPosition(cellGroup, colGroup.lastChild.row + 1, colGroup.lastChild.attribute.y + proxy.table.getRowHeight(colGroup.lastChild.row)), 
        colGroup.appendChild(cellGroup);
    } else {
        const cellGroup = colGroup.lastChild;
        proxy.updateCellGroupPosition(cellGroup, colGroup.firstChild.row - 1, colGroup.firstChild.attribute.y - proxy.table.getRowHeight(cellGroup.row)), 
        colGroup.insertBefore(cellGroup, colGroup.firstChild);
    }
}

function updateAllRowPosition(distStartRowY, count, direction, proxy) {
    for (let col = 0; col < proxy.table.frozenColCount; col++) {
        const colGroup = proxy.table.scenegraph.getColGroup(col);
        null == colGroup || colGroup.forEachChildren(((cellGroup, index) => {
            proxy.updateCellGroupPosition(cellGroup, "up" === direction ? cellGroup.row + count : cellGroup.row - count, 0 === index ? distStartRowY : cellGroup._prev.attribute.y + proxy.table.getRowHeight(cellGroup._prev.row));
        }));
    }
    for (let col = proxy.table.colCount - proxy.table.rightFrozenColCount; col < proxy.table.colCount; col++) {
        const colGroup = proxy.table.scenegraph.getColGroup(col);
        null == colGroup || colGroup.forEachChildren(((cellGroup, index) => {
            proxy.updateCellGroupPosition(cellGroup, "up" === direction ? cellGroup.row + count : cellGroup.row - count, 0 === index ? distStartRowY : cellGroup._prev.attribute.y + proxy.table.getRowHeight(cellGroup._prev.row));
        }));
    }
    for (let col = proxy.bodyLeftCol; col <= proxy.bodyRightCol; col++) {
        const colGroup = proxy.table.scenegraph.getColGroup(col);
        null == colGroup || colGroup.forEachChildren(((cellGroup, index) => {
            proxy.updateCellGroupPosition(cellGroup, "up" === direction ? cellGroup.row + count : cellGroup.row - count, 0 === index ? distStartRowY : cellGroup._prev.attribute.y + proxy.table.getRowHeight(cellGroup._prev.row));
        }));
    }
}

export function updateRowContent(syncTopRow, syncBottomRow, proxy, async = !1) {
    for (let col = 0; col < proxy.table.frozenColCount; col++) for (let row = syncTopRow; row <= syncBottomRow; row++) {
        const cellGroup = proxy.highPerformanceGetCell(col, row, !0);
        proxy.updateCellGroupContent(cellGroup);
    }
    for (let col = proxy.table.colCount - proxy.table.rightFrozenColCount; col < proxy.table.colCount; col++) for (let row = syncTopRow; row <= syncBottomRow; row++) {
        const cellGroup = proxy.highPerformanceGetCell(col, row);
        proxy.updateCellGroupContent(cellGroup);
    }
    let leftCol = proxy.bodyLeftCol, rightCol = proxy.bodyRightCol, sync = !0;
    if (async) {
        const screenLeftCol = proxy.screenLeftCol;
        leftCol = Math.max(proxy.bodyLeftCol, screenLeftCol - 1 * proxy.screenColCount), 
        rightCol = Math.min(proxy.bodyRightCol, screenLeftCol + 2 * proxy.screenColCount), 
        leftCol === proxy.bodyLeftCol && rightCol === proxy.bodyRightCol || (sync = !1);
    }
    for (let col = leftCol; col <= rightCol; col++) for (let row = syncTopRow; row <= syncBottomRow; row++) {
        const cellGroup = proxy.highPerformanceGetCell(col, row);
        proxy.updateCellGroupContent(cellGroup);
    }
    return updateColumnContainerHeight(proxy.table.scenegraph.rowHeaderGroup), updateColumnContainerHeight(proxy.table.scenegraph.rightFrozenGroup), 
    updateColumnContainerHeight(proxy.table.scenegraph.bodyGroup), proxy.table.scenegraph.updateNextFrame(), 
    sync;
}

function updateColumnContainerHeight(containerGroup) {
    var _a, _b;
    const lastColGroup = getLastChild(containerGroup);
    if (!lastColGroup) return;
    const lastCellGroup = getLastChild(lastColGroup);
    if (lastCellGroup && (containerGroup.setAttribute("height", lastCellGroup.attribute.y + lastCellGroup.attribute.height), 
    containerGroup.border)) {
        const border = containerGroup.border;
        border.setAttribute("height", lastCellGroup.attribute.y + lastCellGroup.attribute.height - (null !== (_a = border.attribute.borderTop) && void 0 !== _a ? _a : 0) / 2 - (null !== (_b = border.attribute.borderBottom) && void 0 !== _b ? _b : 0) / 2);
    }
}
//# sourceMappingURL=dynamic-set-y.js.map
