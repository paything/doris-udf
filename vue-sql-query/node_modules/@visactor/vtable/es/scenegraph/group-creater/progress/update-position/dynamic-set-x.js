var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))((function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator.throw(value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            var value;
            result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P((function(resolve) {
                resolve(value);
            }))).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    }));
};

import { computeColsWidth } from "../../../layout/compute-col-width";

import { updateAutoColumn } from "./update-auto-column";

import { getFirstChild, getLastChild } from "./util";

export function dynamicSetX(x, screenLeft, isEnd, proxy) {
    return __awaiter(this, void 0, void 0, (function*() {
        if (!screenLeft) return;
        const screenLeftCol = screenLeft.col, screenLeftX = screenLeft.left;
        let deltaCol;
        if (deltaCol = isEnd ? proxy.bodyRightCol - proxy.colEnd : proxy.screenLeftCol - proxy.referenceCol, 
        move(deltaCol, screenLeftCol, screenLeftX, x, proxy), isEnd) {
            const colGroup = proxy.table.scenegraph.getColGroup(proxy.colEnd);
            if (colGroup) {
                const deltaX = colGroup.attribute.x + colGroup.attribute.width - (proxy.table.tableNoFrameWidth - proxy.table.getFrozenColsWidth() - proxy.table.getRightFrozenColsWidth()) - x;
                proxy.deltaX = -deltaX, proxy.table.scenegraph.setBodyAndColHeaderX(-x + proxy.deltaX);
            }
        }
        proxy.table.scenegraph.updateNextFrame();
    }));
}

function move(deltaCol, screenLeftCol, screenLeftX, x, proxy) {
    deltaCol > 0 ? (moveColumn(deltaCol, "left", proxy.screenLeftCol, screenLeftX, x, proxy), 
    proxy.updateDeltaX(x, screenLeftX, screenLeftCol), proxy.table.scenegraph.setBodyAndColHeaderX(-x + proxy.deltaX)) : deltaCol < 0 ? (moveColumn(-deltaCol, "right", proxy.screenLeftCol, screenLeftX, x, proxy), 
    proxy.updateDeltaX(x, screenLeftX, screenLeftCol), proxy.table.scenegraph.setBodyAndColHeaderX(-x + proxy.deltaX)) : (proxy.updateDeltaX(x, screenLeftX, screenLeftCol), 
    proxy.table.scenegraph.setBodyAndColHeaderX(-x + proxy.deltaX));
}

function moveColumn(count, direction, screenLeftCol, screenLeftX, x, proxy) {
    return __awaiter(this, void 0, void 0, (function*() {
        if ("left" === direction && proxy.colEnd + count > proxy.bodyRightCol ? count = proxy.bodyRightCol - proxy.colEnd : "right" === direction && proxy.colStart - count < proxy.bodyLeftCol && (count = proxy.colStart - proxy.bodyLeftCol), 
        0 !== count) if (count < 0 && (direction = "left" === direction ? "right" : "left", 
        count = -count), count < proxy.colEnd - proxy.colStart) {
            const startCol = "left" === direction ? proxy.colStart : proxy.colEnd - count + 1, endCol = "left" === direction ? proxy.colStart + count - 1 : proxy.colEnd, distStartCol = "left" === direction ? proxy.colEnd + 1 : proxy.colStart - count, distEndCol = "left" === direction ? proxy.colEnd + count : proxy.colStart - 1;
            computeColsWidth(proxy.table, distStartCol, distEndCol), updatePartColPosition(startCol, endCol, direction, proxy);
            const syncLeftCol = distStartCol, syncRightCol = distEndCol;
            proxy.colStart = "left" === direction ? proxy.colStart + count : proxy.colStart - count, 
            proxy.colEnd = "left" === direction ? proxy.colEnd + count : proxy.colEnd - count, 
            updateColContent(syncLeftCol, syncRightCol, proxy), updateAutoColumn(syncLeftCol, syncRightCol, proxy.table, direction);
            const colGroup = proxy.table.scenegraph.getColGroup(screenLeftCol) || proxy.table.scenegraph.getColGroup(screenLeftCol, !0), deltaX = screenLeftX - (colGroup.attribute.x + proxy.table.getFrozenColsWidth() + proxy.table.scenegraph.proxy.deltaX);
            proxy.table.scenegraph.proxy.deltaX += deltaX, proxy.currentCol = "left" === direction ? proxy.currentCol + count : proxy.currentCol - count, 
            proxy.totalCol = Math.max(0, Math.min(proxy.table.colCount - 1, "left" === direction ? proxy.totalCol + count : proxy.totalCol - count)), 
            proxy.referenceCol = proxy.colStart + Math.floor((proxy.colEnd - proxy.colStart) / 2), 
            proxy.colUpdatePos = distStartCol, proxy.colUpdateDirection = direction, proxy.table.scenegraph.updateNextFrame();
        } else {
            const distStartCol = "left" === direction ? proxy.colStart + count : proxy.colStart - count, distEndCol = "left" === direction ? proxy.colEnd + count : proxy.colEnd - count;
            computeColsWidth(proxy.table, distStartCol, distEndCol);
            updateAllColPosition(proxy.table.getColsWidth(proxy.bodyLeftCol, distStartCol - 1), count, direction, proxy);
            const syncLeftCol = distStartCol, syncRightCol = distEndCol;
            proxy.colStart = distStartCol, proxy.colEnd = distEndCol, updateColContent(syncLeftCol, syncRightCol, proxy), 
            updateAutoColumn(syncLeftCol, syncRightCol, proxy.table, distEndCol > proxy.bodyRightCol - (proxy.colEnd - proxy.colStart + 1) ? "right" : "left"), 
            proxy.currentCol = "left" === direction ? proxy.currentCol + count : proxy.currentCol - count, 
            proxy.totalCol = Math.max(0, Math.min(proxy.table.colCount - 1, "left" === direction ? proxy.totalCol + count : proxy.totalCol - count)), 
            proxy.referenceCol = proxy.colStart + Math.floor((proxy.colEnd - proxy.colStart) / 2), 
            proxy.colUpdatePos = proxy.colStart, proxy.colUpdateDirection = distEndCol > proxy.bodyRightCol - (proxy.colEnd - proxy.colStart + 1) ? "right" : "left", 
            proxy.table.scenegraph.updateNextFrame();
        }
    }));
}

function updateColGroupPosition(colGroup, newCol, x) {
    colGroup.col = newCol, colGroup.forEachChildren((cellGroup => {
        cellGroup.col = newCol, cellGroup.needUpdate = !0;
    })), colGroup.setAttribute("x", x), colGroup.needUpdate = !0;
}

function updateColGroupContent(colGroup, proxy) {
    if (!colGroup) return;
    let cellGroup = colGroup.firstChild;
    for (;cellGroup; ) {
        cellGroup = proxy.updateCellGroupContent(cellGroup)._next;
    }
    colGroup.needUpdate = !1, colGroup.setAttribute("width", proxy.table.getColWidth(colGroup.col));
}

function updateColGroupContentAsync(colGroup, proxy) {
    if (!colGroup) return;
    const screenTopRow = proxy.screenTopRow, topRow = Math.max(proxy.bodyTopRow, screenTopRow - 1 * proxy.screenRowCount), bottomRow = Math.min(proxy.bodyBottomRow, screenTopRow + 2 * proxy.screenRowCount, proxy.table.rowCount - 1);
    for (let row = topRow; row <= bottomRow; row++) {
        const cellGroup = proxy.highPerformanceGetCell(colGroup.col, row, !0);
        proxy.updateCellGroupContent(cellGroup);
    }
    proxy.rowUpdatePos = proxy.rowStart, colGroup.needUpdate = !1, colGroup.setAttribute("width", proxy.table.getColWidth(colGroup.col));
}

function updatePartColPosition(startCol, endCol, direction, proxy) {
    for (let col = startCol; col <= endCol; col++) proxy.table.scenegraph.bodyGroup.childrenCount > 0 && "group" === proxy.table.scenegraph.bodyGroup.firstChild.type && updateColPosition(proxy.table.scenegraph.bodyGroup, direction, proxy), 
    proxy.table.scenegraph.colHeaderGroup.childrenCount > 0 && "group" === proxy.table.scenegraph.colHeaderGroup.firstChild.type && updateColPosition(proxy.table.scenegraph.colHeaderGroup, direction, proxy), 
    proxy.table.scenegraph.bottomFrozenGroup.childrenCount > 0 && "group" === proxy.table.scenegraph.bottomFrozenGroup.firstChild.type && updateColPosition(proxy.table.scenegraph.bottomFrozenGroup, direction, proxy);
}

function updateColPosition(containerGroup, direction, proxy) {
    if ("left" === direction) {
        const colGroup = getFirstChild(containerGroup), lastChild = getLastChild(containerGroup);
        updateColGroupPosition(colGroup, lastChild.col + 1, lastChild.attribute.x + proxy.table.getColWidth(lastChild.col)), 
        containerGroup.appendChild(colGroup), containerGroup.border && containerGroup.appendChild(containerGroup.border);
    } else {
        const colGroup = getLastChild(containerGroup), firstChild = getFirstChild(containerGroup);
        updateColGroupPosition(colGroup, firstChild.col - 1, firstChild.attribute.x - proxy.table.getColWidth(firstChild.col - 1)), 
        containerGroup.insertBefore(colGroup, containerGroup.firstChild);
    }
}

export function updateColContent(syncLeftCol, syncRightCol, proxy) {
    for (let col = syncLeftCol; col <= syncRightCol; col++) {
        const colHeaderColGroup = proxy.table.scenegraph.getColGroup(col, !0);
        colHeaderColGroup && updateColGroupContent(colHeaderColGroup, proxy);
        const bottomColGroup = proxy.table.scenegraph.getColGroupInBottom(col);
        bottomColGroup && updateColGroupContent(bottomColGroup, proxy);
        const rightTopColGroup = proxy.table.scenegraph.getColGroupInRightTopCorner(col);
        rightTopColGroup && updateColGroupContent(rightTopColGroup, proxy);
        const rightBottomColGroup = proxy.table.scenegraph.getColGroupInRightBottomCorner(col);
        rightBottomColGroup && updateColGroupContent(rightBottomColGroup, proxy);
        const colGroup = proxy.table.scenegraph.getColGroup(col);
        colGroup && updateColGroupContentAsync(colGroup, proxy);
    }
    updateColumnContainerWidth(proxy.table.scenegraph.colHeaderGroup), updateColumnContainerWidth(proxy.table.scenegraph.bottomFrozenGroup), 
    updateColumnContainerWidth(proxy.table.scenegraph.bodyGroup), proxy.progress();
}

function updateAllColPosition(distStartColY, count, direction, proxy) {
    proxy.table.scenegraph.colHeaderGroup.forEachChildren(((colGroup, index) => {
        "group" === colGroup.type && updateColGroupPosition(colGroup, "left" === direction ? colGroup.col + count : colGroup.col - count, 0 === index ? distStartColY : colGroup._prev.attribute.x + proxy.table.getColWidth(colGroup._prev.col));
    })), proxy.table.scenegraph.bottomFrozenGroup.forEachChildren(((colGroup, index) => {
        "group" === colGroup.type && updateColGroupPosition(colGroup, "left" === direction ? colGroup.col + count : colGroup.col - count, 0 === index ? distStartColY : colGroup._prev.attribute.x + proxy.table.getColWidth(colGroup._prev.col));
    })), proxy.table.scenegraph.bodyGroup.forEachChildren(((colGroup, index) => {
        "group" === colGroup.type && updateColGroupPosition(colGroup, "left" === direction ? colGroup.col + count : colGroup.col - count, 0 === index ? distStartColY : colGroup._prev.attribute.x + proxy.table.getColWidth(colGroup._prev.col));
    }));
}

function updateColumnContainerWidth(containerGroup) {
    var _a, _b;
    const lastColGroup = getLastChild(containerGroup);
    if (lastColGroup && (containerGroup.setAttribute("width", lastColGroup.attribute.x + lastColGroup.attribute.width), 
    containerGroup.border)) {
        const border = containerGroup.border;
        border.setAttribute("width", lastColGroup.attribute.x + lastColGroup.attribute.width - (null !== (_a = border.attribute.borderLeft) && void 0 !== _a ? _a : 0) / 2 - (null !== (_b = border.attribute.borderRight) && void 0 !== _b ? _b : 0) / 2);
    }
}
//# sourceMappingURL=dynamic-set-x.js.map
