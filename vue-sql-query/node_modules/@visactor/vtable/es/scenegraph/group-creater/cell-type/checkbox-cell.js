import { Group } from "../../graphic/group";

import { isObject } from "@visactor/vutils";

import { CheckBox } from "./../../../vrender";

import { getHierarchyOffset } from "../../utils/get-hierarchy-offset";

import { getOrApply } from "../../../tools/helper";

import { getProp } from "../../utils/get-prop";

import { getCellBorderStrokeWidth } from "../../utils/cell-border-stroke-width";

import { dealWithIconLayout } from "../../utils/text-icon-layout";

export function createCheckboxCellGroup(cellGroup, columnGroup, xOrigin, yOrigin, col, row, colWidth, width, height, padding, textAlign, textBaseline, mayHaveIcon, table, cellTheme, define, range, isAsync) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z;
    if (!cellGroup) {
        const strokeArrayWidth = getCellBorderStrokeWidth(col, row, cellTheme, table);
        isAsync && (cellGroup = table.scenegraph.highPerformanceGetCell(col, row, !0)) && "cell" === cellGroup.role && cellGroup.setAttributes({
            x: xOrigin,
            y: yOrigin,
            width: width,
            height: height,
            lineWidth: null !== (_b = null === (_a = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _a ? void 0 : _a.lineWidth) && void 0 !== _b ? _b : void 0,
            fill: null !== (_d = null === (_c = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _c ? void 0 : _c.fill) && void 0 !== _d ? _d : void 0,
            stroke: null !== (_f = null === (_e = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _e ? void 0 : _e.stroke) && void 0 !== _f ? _f : void 0,
            strokeArrayWidth: strokeArrayWidth,
            strokeArrayColor: null !== (_h = null === (_g = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _g ? void 0 : _g.strokeArrayColor) && void 0 !== _h ? _h : void 0,
            cursor: null !== (_k = null === (_j = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _j ? void 0 : _j.cursor) && void 0 !== _k ? _k : void 0,
            lineDash: null !== (_m = null === (_l = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _l ? void 0 : _l.lineDash) && void 0 !== _m ? _m : void 0,
            lineCap: "butt",
            clip: !0,
            cornerRadius: cellTheme.group.cornerRadius
        }), cellGroup && "cell" === cellGroup.role || ((cellGroup = new Group({
            x: xOrigin,
            y: yOrigin,
            width: width,
            height: height,
            lineWidth: null !== (_p = null === (_o = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _o ? void 0 : _o.lineWidth) && void 0 !== _p ? _p : void 0,
            fill: null !== (_r = null === (_q = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _q ? void 0 : _q.fill) && void 0 !== _r ? _r : void 0,
            stroke: null !== (_t = null === (_s = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _s ? void 0 : _s.stroke) && void 0 !== _t ? _t : void 0,
            strokeArrayWidth: strokeArrayWidth,
            strokeArrayColor: null !== (_v = null === (_u = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _u ? void 0 : _u.strokeArrayColor) && void 0 !== _v ? _v : void 0,
            cursor: null !== (_x = null === (_w = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _w ? void 0 : _w.cursor) && void 0 !== _x ? _x : void 0,
            lineDash: null !== (_z = null === (_y = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _y ? void 0 : _y.lineDash) && void 0 !== _z ? _z : void 0,
            lineCap: "butt",
            clip: !0,
            cornerRadius: cellTheme.group.cornerRadius
        })).role = "cell", cellGroup.col = col, cellGroup.row = row, null == columnGroup || columnGroup.addCellGroup(cellGroup));
    }
    let icons;
    if (mayHaveIcon) {
        let iconCol = col, iconRow = row;
        range && (iconCol = range.start.col, iconRow = range.start.row), icons = table.getCellIcons(iconCol, iconRow);
    }
    let iconWidth = 0, cellLeftIconWidth = 0, cellRightIconWidth = 0;
    if (Array.isArray(icons) && 0 !== icons.length) {
        const {leftIconWidth: leftIconWidth, rightIconWidth: rightIconWidth, absoluteLeftIconWidth: absoluteLeftIconWidth, absoluteRightIconWidth: absoluteRightIconWidth} = dealWithIconLayout(icons, cellGroup, range, table);
        iconWidth = leftIconWidth + rightIconWidth, cellLeftIconWidth = leftIconWidth, cellRightIconWidth = rightIconWidth, 
        cellGroup.forEachChildren((child => {
            "icon-left" === child.role ? child.setAttribute("x", child.attribute.x + padding[3]) : "icon-right" === child.role ? child.setAttribute("x", child.attribute.x + width - rightIconWidth - padding[1]) : "icon-absolute-right" === child.role && child.setAttribute("x", child.attribute.x + width - absoluteRightIconWidth - padding[1]);
        })), cellGroup.forEachChildren((child => {
            "middle" === textBaseline ? child.setAttribute("y", (height - child.AABBBounds.height()) / 2) : "bottom" === textBaseline ? child.setAttribute("y", height - child.AABBBounds.height() - padding[2]) : child.setAttribute("y", padding[0]);
        }));
    }
    const checkboxComponent = createCheckbox(col, row, colWidth - iconWidth, width, height, padding, cellTheme, define, table);
    return checkboxComponent && cellGroup.appendChild(checkboxComponent), checkboxComponent.render(), 
    width -= padding[1] + padding[3] + iconWidth, height -= padding[0] + padding[2], 
    "center" === textAlign ? checkboxComponent.setAttribute("x", padding[3] + cellLeftIconWidth + (width - checkboxComponent.AABBBounds.width()) / 2) : "right" === textAlign ? checkboxComponent.setAttribute("x", padding[3] + cellLeftIconWidth + width - checkboxComponent.AABBBounds.width()) : checkboxComponent.setAttribute("x", padding[3] + cellLeftIconWidth), 
    "middle" === textBaseline ? checkboxComponent.setAttribute("y", padding[0] + (height - checkboxComponent.AABBBounds.height()) / 2) : "bottom" === textBaseline ? checkboxComponent.setAttribute("y", padding[0] + height - checkboxComponent.AABBBounds.height()) : checkboxComponent.setAttribute("y", padding[0]), 
    cellGroup;
}

function createCheckbox(col, row, colWidth, cellWidth, cellHeight, padding, cellTheme, define, table) {
    var _a, _b, _c, _d;
    const style = table._getCellStyle(col, row), size = getProp("size", style, col, row, table), spaceBetweenTextAndIcon = getProp("spaceBetweenTextAndIcon", style, col, row, table), defaultFill = getProp("defaultFill", style, col, row, table), defaultStroke = getProp("defaultStroke", style, col, row, table), disableFill = getProp("disableFill", style, col, row, table), checkedFill = getProp("checkedFill", style, col, row, table), checkedStroke = getProp("checkedStroke", style, col, row, table), disableCheckedFill = getProp("disableCheckedFill", style, col, row, table), disableCheckedStroke = getProp("disableCheckedStroke", style, col, row, table), checkIconImage = getProp("checkIconImage", style, col, row, table), indeterminateIconImage = getProp("indeterminateIconImage", style, col, row, table), value = table.getCellValue(col, row), dataValue = table.getCellOriginValue(col, row);
    let isChecked, isDisabled, text = null !== (_a = value) && void 0 !== _a ? _a : "";
    isObject(value) ? (isChecked = value.checked, isDisabled = value.disable, text = null !== (_b = value.text) && void 0 !== _b ? _b : "") : "boolean" == typeof value && (isChecked = value, 
    text = ""), isChecked = table.stateManager.syncCheckedState(col, row, define.field, isChecked);
    const hierarchyOffset = getHierarchyOffset(col, row, table), cellStyle = table._getCellStyle(col, row), autoWrapText = null !== (_c = cellStyle.autoWrapText) && void 0 !== _c ? _c : table.internalProps.autoWrapText, {lineClamp: lineClamp} = cellStyle, {checked: checked, disable: disable} = define;
    if (null == isChecked || "function" == typeof isChecked) {
        const globalChecked = getOrApply(checked, {
            col: col,
            row: row,
            table: table,
            context: null,
            value: value,
            dataValue: dataValue
        });
        isChecked = table.stateManager.syncCheckedState(col, row, define.field, globalChecked);
    }
    const globalDisable = getOrApply(disable, {
        col: col,
        row: row,
        table: table,
        context: null,
        value: value,
        dataValue: dataValue
    }), autoColWidth = "auto" === colWidth, autoRowHeight = table.isAutoRowHeight(row), attribute = {
        text: 1 === text.length ? text[0] : text,
        maxLineWidth: autoColWidth ? 1 / 0 : cellWidth - (padding[1] + padding[3] + hierarchyOffset) - size - spaceBetweenTextAndIcon,
        textAlign: "left",
        textBaseline: "top",
        autoWrapText: autoWrapText,
        lineClamp: lineClamp,
        wordBreak: "break-word",
        heightLimit: autoRowHeight ? -1 : cellHeight - Math.floor(padding[0] + padding[2]),
        pickable: !1,
        dx: hierarchyOffset,
        whiteSpace: 1 !== text.length || autoWrapText ? "normal" : "no-wrap"
    }, checkboxAttributes = {
        x: 0,
        y: 0,
        text: cellTheme.text ? Object.assign({}, cellTheme.text, attribute) : attribute,
        icon: {
            width: Math.floor(size / 1.4),
            height: Math.floor(size / 1.4)
        },
        box: {
            width: size,
            height: size
        },
        spaceBetweenTextAndIcon: spaceBetweenTextAndIcon,
        disabled: null !== (_d = null != isDisabled ? isDisabled : globalDisable) && void 0 !== _d && _d
    };
    "indeterminate" === isChecked ? (checkboxAttributes.checked = void 0, checkboxAttributes.indeterminate = !0) : (checkboxAttributes.checked = isChecked, 
    checkboxAttributes.indeterminate = void 0), defaultFill && (checkboxAttributes.box.fill = defaultFill), 
    defaultStroke && (checkboxAttributes.box.stroke = defaultStroke), disableFill && (checkboxAttributes.box.disableFill = disableFill), 
    checkedFill && (checkboxAttributes.box.checkedFill = checkedFill), checkedStroke && (checkboxAttributes.box.checkedStroke = checkedStroke), 
    disableCheckedFill && (checkboxAttributes.box.disableCheckedFill = disableCheckedFill), 
    disableCheckedStroke && (checkboxAttributes.box.disableCheckedStroke = disableCheckedStroke), 
    checkIconImage && (checkboxAttributes.icon.checkIconImage = checkIconImage), indeterminateIconImage && (checkboxAttributes.icon.indeterminateIconImage = indeterminateIconImage);
    const checkbox = new CheckBox(checkboxAttributes);
    return checkbox.name = "checkbox", checkbox;
}
//# sourceMappingURL=checkbox-cell.js.map
