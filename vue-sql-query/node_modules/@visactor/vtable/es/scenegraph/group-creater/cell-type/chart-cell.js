import { Group } from "../../graphic/group";

import { Chart } from "../../graphic/chart";

import * as registerChartTypes from "../../../chartModule";

import { getFunctionalProp } from "../../utils/get-prop";

import { isValid } from "@visactor/vutils";

import { getCellBorderStrokeWidth } from "../../utils/cell-border-stroke-width";

export function createChartCellGroup(cellGroup, columnGroup, xOrigin, yOrigin, col, row, width, height, padding, dataValue, chartModule, chartSpec, chartInstance, dataId, table, cellTheme, isShareChartSpec, isAsync, isNoChartDataRenderNothing) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
    const ClassType = registerChartTypes.get()[chartModule], headerStyle = table._getCellStyle(col, row), functionalPadding = getFunctionalProp("padding", headerStyle, col, row, table);
    if (isValid(functionalPadding) && (padding = functionalPadding), !cellGroup) {
        const strokeArrayWidth = getCellBorderStrokeWidth(col, row, cellTheme, table);
        isAsync && (cellGroup = table.scenegraph.highPerformanceGetCell(col, row, !0)) && "cell" === cellGroup.role && cellGroup.setAttributes({
            x: xOrigin,
            y: yOrigin,
            width: width,
            height: height,
            lineWidth: null !== (_b = null === (_a = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _a ? void 0 : _a.lineWidth) && void 0 !== _b ? _b : void 0,
            fill: null !== (_d = null === (_c = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _c ? void 0 : _c.fill) && void 0 !== _d ? _d : void 0,
            stroke: null !== (_f = null === (_e = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _e ? void 0 : _e.stroke) && void 0 !== _f ? _f : void 0,
            strokeArrayWidth: strokeArrayWidth,
            strokeArrayColor: null !== (_h = null === (_g = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _g ? void 0 : _g.strokeArrayColor) && void 0 !== _h ? _h : void 0,
            cursor: null !== (_k = null === (_j = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _j ? void 0 : _j.cursor) && void 0 !== _k ? _k : void 0,
            lineDash: null !== (_m = null === (_l = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _l ? void 0 : _l.lineDash) && void 0 !== _m ? _m : void 0,
            lineCap: "butt",
            clip: !0,
            cornerRadius: cellTheme.group.cornerRadius
        }), cellGroup && "cell" === cellGroup.role || ((cellGroup = new Group({
            x: xOrigin,
            y: yOrigin,
            width: width,
            height: height,
            lineWidth: null !== (_p = null === (_o = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _o ? void 0 : _o.lineWidth) && void 0 !== _p ? _p : void 0,
            fill: null !== (_r = null === (_q = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _q ? void 0 : _q.fill) && void 0 !== _r ? _r : void 0,
            stroke: null !== (_t = null === (_s = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _s ? void 0 : _s.stroke) && void 0 !== _t ? _t : void 0,
            strokeArrayWidth: strokeArrayWidth,
            strokeArrayColor: null !== (_v = null === (_u = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _u ? void 0 : _u.strokeArrayColor) && void 0 !== _v ? _v : void 0,
            cursor: null !== (_x = null === (_w = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _w ? void 0 : _w.cursor) && void 0 !== _x ? _x : void 0,
            lineDash: null !== (_z = null === (_y = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _y ? void 0 : _y.lineDash) && void 0 !== _z ? _z : void 0,
            lineCap: "butt",
            clip: !0,
            cornerRadius: cellTheme.group.cornerRadius
        })).role = "cell", cellGroup.col = col, cellGroup.row = row, null == columnGroup || columnGroup.addCellGroup(cellGroup));
    }
    if (cellGroup.AABBBounds.width(), isNoChartDataRenderNothing && Array.isArray(table.getCellValue(col, row)) || !isNoChartDataRenderNothing) {
        const chartGroup = new Chart(isShareChartSpec, {
            stroke: !1,
            x: padding[3],
            y: padding[0],
            canvas: null !== (_0 = table.canvas) && void 0 !== _0 ? _0 : table.scenegraph.stage.window.getContext().canvas,
            mode: table.options.mode,
            modeParams: table.options.modeParams,
            spec: table.options.specTransformInCell ? table.options.specTransformInCell(chartSpec, col, row) : chartSpec,
            ClassType: ClassType,
            width: width - padding[3] - padding[1],
            height: height - padding[2] - padding[0],
            chartInstance: chartInstance,
            dataId: dataId,
            data: table.getCellValue(col, row) || [],
            cellPadding: padding,
            dpr: table.internalProps.pixelRatio,
            axes: table.isPivotChart() ? table.internalProps.layoutMap.getChartAxes(col, row) : [],
            tableChartOption: table.options.chartOption,
            col: col,
            row: row
        });
        cellGroup.appendChild(chartGroup), table.internalProps.layoutMap.setChartInstance(col, row, chartGroup.chartInstance);
    }
    return cellGroup;
}
//# sourceMappingURL=chart-cell.js.map
