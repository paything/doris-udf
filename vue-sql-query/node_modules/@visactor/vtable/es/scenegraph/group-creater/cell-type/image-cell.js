import { createImage } from "./../../../vrender";

import * as icons from "../../../icons";

import { Group } from "../../graphic/group";

import { calcKeepAspectRatioSize } from "../../utils/keep-aspect-ratio";

import { calcStartPosition } from "../../utils/cell-pos";

import { getProp, getFunctionalProp } from "../../utils/get-prop";

import { isValid } from "@visactor/vutils";

import { getQuadProps } from "../../utils/padding";

import { getCellBorderStrokeWidth } from "../../utils/cell-border-stroke-width";

import { dealWithIconLayout } from "../../utils/text-icon-layout";

export function createImageCellGroup(columnGroup, xOrigin, yOrigin, col, row, width, height, keepAspectRatio, imageAutoSizing, padding, textAlign, textBaseline, mayHaveIcon, table, cellTheme, range, isAsync) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5;
    const headerStyle = table._getCellStyle(col, row), functionalPadding = getFunctionalProp("padding", headerStyle, col, row, table);
    (null === (_a = table.options.customConfig) || void 0 === _a ? void 0 : _a.imageMargin) ? padding = getQuadProps(null === (_b = table.options.customConfig) || void 0 === _b ? void 0 : _b.imageMargin) : isValid(functionalPadding) && (padding = functionalPadding), 
    (null === (_c = null == cellTheme ? void 0 : cellTheme.text) || void 0 === _c ? void 0 : _c.textAlign) && (textAlign = null === (_d = null == cellTheme ? void 0 : cellTheme.text) || void 0 === _d ? void 0 : _d.textAlign), 
    (null === (_e = null == cellTheme ? void 0 : cellTheme.text) || void 0 === _e ? void 0 : _e.textBaseline) && (textBaseline = null === (_f = null == cellTheme ? void 0 : cellTheme.text) || void 0 === _f ? void 0 : _f.textBaseline);
    const strokeArrayWidth = getCellBorderStrokeWidth(col, row, cellTheme, table);
    let cellGroup, cellIcons;
    if (isAsync && (cellGroup = table.scenegraph.highPerformanceGetCell(col, row, !0), 
    cellGroup && "cell" === cellGroup.role && cellGroup.setAttributes({
        x: xOrigin,
        y: yOrigin,
        width: width,
        height: height,
        lineWidth: null !== (_h = null === (_g = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _g ? void 0 : _g.lineWidth) && void 0 !== _h ? _h : void 0,
        fill: null !== (_k = null === (_j = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _j ? void 0 : _j.fill) && void 0 !== _k ? _k : void 0,
        stroke: null !== (_m = null === (_l = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _l ? void 0 : _l.stroke) && void 0 !== _m ? _m : void 0,
        strokeArrayWidth: null != strokeArrayWidth ? strokeArrayWidth : void 0,
        strokeArrayColor: null !== (_p = null === (_o = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _o ? void 0 : _o.strokeArrayColor) && void 0 !== _p ? _p : void 0,
        cursor: null !== (_r = null === (_q = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _q ? void 0 : _q.cursor) && void 0 !== _r ? _r : void 0,
        lineDash: null !== (_t = null === (_s = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _s ? void 0 : _s.lineDash) && void 0 !== _t ? _t : void 0,
        lineCap: "butt",
        clip: !0,
        cornerRadius: cellTheme.group.cornerRadius
    })), cellGroup && "cell" === cellGroup.role || (cellGroup = new Group({
        x: xOrigin,
        y: yOrigin,
        width: width,
        height: height,
        lineWidth: null !== (_v = null === (_u = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _u ? void 0 : _u.lineWidth) && void 0 !== _v ? _v : void 0,
        fill: null !== (_x = null === (_w = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _w ? void 0 : _w.fill) && void 0 !== _x ? _x : void 0,
        stroke: null !== (_z = null === (_y = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _y ? void 0 : _y.stroke) && void 0 !== _z ? _z : void 0,
        strokeArrayWidth: null != strokeArrayWidth ? strokeArrayWidth : void 0,
        strokeArrayColor: null !== (_1 = null === (_0 = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _0 ? void 0 : _0.strokeArrayColor) && void 0 !== _1 ? _1 : void 0,
        cursor: null !== (_3 = null === (_2 = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _2 ? void 0 : _2.cursor) && void 0 !== _3 ? _3 : void 0,
        lineDash: null !== (_5 = null === (_4 = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _4 ? void 0 : _4.lineDash) && void 0 !== _5 ? _5 : void 0,
        lineCap: "butt",
        clip: !0,
        cornerRadius: cellTheme.group.cornerRadius
    }), cellGroup.role = "cell", cellGroup.col = col, cellGroup.row = row, null == columnGroup || columnGroup.addCellGroup(cellGroup)), 
    mayHaveIcon) {
        let iconCol = col, iconRow = row;
        range && (iconCol = range.start.col, iconRow = range.start.row), cellIcons = table.getCellIcons(iconCol, iconRow);
    }
    let iconWidth = 0, cellLeftIconWidth = 0, cellRightIconWidth = 0;
    if (Array.isArray(cellIcons) && 0 !== cellIcons.length) {
        const {leftIconWidth: leftIconWidth, rightIconWidth: rightIconWidth, absoluteLeftIconWidth: absoluteLeftIconWidth, absoluteRightIconWidth: absoluteRightIconWidth} = dealWithIconLayout(cellIcons, cellGroup, range, table);
        iconWidth = leftIconWidth + rightIconWidth, cellLeftIconWidth = leftIconWidth, cellRightIconWidth = rightIconWidth, 
        cellGroup.forEachChildren((child => {
            "icon-left" === child.role ? child.setAttribute("x", child.attribute.x + padding[3]) : "icon-right" === child.role ? child.setAttribute("x", child.attribute.x + width - rightIconWidth - padding[1]) : "icon-absolute-right" === child.role && child.setAttribute("x", child.attribute.x + width - absoluteRightIconWidth - padding[1]);
        })), cellGroup.forEachChildren((child => {
            "middle" === textBaseline ? child.setAttribute("y", (height - child.AABBBounds.height()) / 2) : "bottom" === textBaseline ? child.setAttribute("y", height - child.AABBBounds.height() - padding[2]) : child.setAttribute("y", padding[0]);
        })), cellGroup._cellLeftIconWidth = cellLeftIconWidth, cellGroup._cellRightIconWidth = cellRightIconWidth;
    }
    const value = table.getCellValue(col, row), image = createImage({
        x: padding[3],
        y: padding[0],
        width: width - padding[1] - padding[3] - iconWidth,
        height: height - padding[0] - padding[2],
        image: value,
        cursor: "pointer"
    });
    return image.name = "image", image.keepAspectRatio = keepAspectRatio, image.textAlign = textAlign, 
    image.textBaseline = textBaseline, keepAspectRatio || imageAutoSizing ? image.resources && image.resources.has(image.attribute.image) && "success" === image.resources.get(image.attribute.image).state ? (image.setAttribute("opacity", 0), 
    setTimeout((() => {
        image.setAttribute("opacity", 1), updateAutoSizingAndKeepAspectRatio(imageAutoSizing, keepAspectRatio, padding, textAlign, textBaseline, image, cellGroup, table), 
        table.scenegraph.updateNextFrame();
    }), 0)) : image.successCallback = () => {
        updateAutoSizingAndKeepAspectRatio(imageAutoSizing, keepAspectRatio, padding, textAlign, textBaseline, image, cellGroup, table), 
        table.scenegraph.updateNextFrame();
    } : image.resources && image.resources.has(image.attribute.image) && "success" === image.resources.get(image.attribute.image).state ? updateImageCellContentWhileResize(cellGroup, col, row, 0, 0, table) : image.successCallback = () => {
        updateImageCellContentWhileResize(cellGroup, col, row, 0, 0, table);
    }, image.failCallback = () => {
        const regedIcons = icons.get();
        image.image = regedIcons.damage_pic.svg;
    }, cellGroup.appendChild(image), cellGroup;
}

export function _adjustWidthHeight(col, row, width, height, scene, padding, cellGroup) {
    let needInvalidate = !1, targetWidth = null, targetHeight = null;
    const {width: cellWidth, height: cellHeight, isMerge: isMerge} = getCellRange(cellGroup, scene.table);
    if (cellWidth < width + padding[1] + padding[3] && (targetWidth = width + padding[1] + padding[3], 
    needInvalidate = !0), cellHeight < height + padding[2] + padding[0] && (targetHeight = height + padding[2] + padding[0], 
    needInvalidate = !0), needInvalidate) {
        if ("number" == typeof targetWidth) if (isMerge) for (let col = cellGroup.mergeStartCol; col <= cellGroup.mergeEndCol; col++) scene.setColWidth(col, targetWidth / (cellGroup.mergeEndCol - cellGroup.mergeStartCol + 1)); else scene.setColWidth(col, targetWidth);
        if ("number" == typeof targetHeight) if (isMerge) for (let row = cellGroup.mergeStartRow; row <= cellGroup.mergeEndRow; row++) scene.setRowHeight(row, targetHeight / (cellGroup.mergeEndRow - cellGroup.mergeStartRow + 1)); else scene.setRowHeight(row, targetHeight);
        return scene.component.updateScrollBar(), !0;
    }
    return !1;
}

export function updateImageCellContentWhileResize(cellGroup, col, row, deltaX, deltaY, table) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
    const image = cellGroup.getChildByName("image");
    if (!image) return;
    const originImage = "string" != typeof image.attribute.image && image.attribute.image || (null === (_a = image.resources) || void 0 === _a ? void 0 : _a.get(image.attribute.image).data);
    if (!originImage) return;
    const headerStyle = table._getCellStyle(col, row), textAlign = null !== (_b = getProp("textAlign", headerStyle, col, row, table)) && void 0 !== _b ? _b : "left", textBaseline = null !== (_c = getProp("textBaseline", headerStyle, col, row, table)) && void 0 !== _c ? _c : "middle";
    let padding;
    padding = (null === (_d = table.options.customConfig) || void 0 === _d ? void 0 : _d.imageMargin) ? getQuadProps(null === (_e = table.options.customConfig) || void 0 === _e ? void 0 : _e.imageMargin) : null !== (_f = getQuadProps(getProp("padding", headerStyle, col, row, table))) && void 0 !== _f ? _f : [ 0, 0, 0, 0 ];
    const {width: cellWidth, height: cellHeight, isMerge: isMerge} = getCellRange(cellGroup, table), colStart = null !== (_g = cellGroup.mergeStartCol) && void 0 !== _g ? _g : cellGroup.col, rowStart = null !== (_h = cellGroup.mergeStartRow) && void 0 !== _h ? _h : cellGroup.row, colEnd = null !== (_j = cellGroup.mergeEndCol) && void 0 !== _j ? _j : cellGroup.col, rowEnd = null !== (_k = cellGroup.mergeEndCol) && void 0 !== _k ? _k : cellGroup.row, leftIconWidth = null !== (_l = cellGroup._cellLeftIconWidth) && void 0 !== _l ? _l : 0, rightIconWidth = null !== (_m = cellGroup._cellRightIconWidth) && void 0 !== _m ? _m : 0;
    if (image.keepAspectRatio) {
        const {width: imageWidth, height: imageHeight} = calcKeepAspectRatioSize(originImage.width || originImage.videoWidth, originImage.height || originImage.videoHeight, cellWidth - (padding[1] + padding[3]), cellHeight - (padding[0] + padding[2])), pos = calcStartPosition(0, 0, cellWidth, cellHeight, imageWidth, imageHeight, textAlign, textBaseline, padding);
        for (let col = colStart; col <= colEnd; col++) for (let row = rowStart; row <= rowEnd; row++) {
            const image = table.scenegraph.getCell(col, row).getChildByName("image");
            null == image || image.setAttributes({
                x: pos.x,
                y: pos.y,
                width: imageWidth,
                height: imageHeight
            });
        }
    } else for (let col = colStart; col <= colEnd; col++) for (let row = rowStart; row <= rowEnd; row++) {
        const image = table.scenegraph.getCell(col, row).getChildByName("image");
        null == image || image.setAttributes({
            x: leftIconWidth + padding[3],
            y: padding[0],
            width: cellWidth - padding[1] - padding[3] - rightIconWidth - leftIconWidth,
            height: cellHeight - padding[0] - padding[2]
        });
    }
    if (cellGroup.getChildByName("play-icon")) {
        const left = 0, top = 0, {width: width, height: height} = getCellRange(cellGroup, table), iconSize = Math.floor(Math.min(width - padding[1] - padding[3], height - padding[2] - padding[0]) / 2), anchorX = left + (width > image.attribute.width ? image.attribute.x - left + image.attribute.width / 2 : width / 2), anchorY = top + (height > image.attribute.height ? image.attribute.y - top + image.attribute.height / 2 : height / 2);
        for (let col = colStart; col <= colEnd; col++) for (let row = rowStart; row <= rowEnd; row++) {
            table.scenegraph.getCell(col, row).getChildByName("play-icon").setAttributes({
                x: anchorX - iconSize / 2,
                y: anchorY - iconSize / 2,
                width: iconSize,
                height: iconSize
            });
        }
    }
    cellGroup.forEachChildren((child => {
        "icon-left" === child.role || ("icon-right" === child.role || "icon-absolute-right" === child.role) && child.setAttribute("x", child.attribute.x + deltaX);
    })), cellGroup.forEachChildren((child => {
        ("rect" === child.type || child.role && child.role.startsWith("icon")) && ("middle" === textBaseline ? child.setAttribute("y", padding[0] + (cellHeight - padding[0] - padding[2] - child.AABBBounds.height()) / 2) : "bottom" === textBaseline ? child.setAttribute("y", padding[0] + cellHeight - padding[0] - padding[2] - child.AABBBounds.height()) : child.setAttribute("y", padding[0]));
    })), isMerge && updateImageDxDy(cellGroup.mergeStartCol, cellGroup.mergeEndCol, cellGroup.mergeStartRow, cellGroup.mergeEndRow, table);
}

export function getCellRange(cellGroup, table) {
    return "cell" === cellGroup.role && isValid(cellGroup.mergeStartCol) && isValid(cellGroup.mergeEndCol) && isValid(cellGroup.mergeStartRow) && isValid(cellGroup.mergeEndRow) ? {
        width: table.getColsWidth(cellGroup.mergeStartCol, cellGroup.mergeEndCol),
        height: table.getRowsHeight(cellGroup.mergeStartRow, cellGroup.mergeEndRow),
        isMerge: !0
    } : {
        width: cellGroup.attribute.width,
        height: cellGroup.attribute.height,
        isMerge: !1
    };
}

export function updateImageDxDy(startCol, endCol, startRow, endRow, table) {
    for (let col = startCol; col <= endCol; col++) for (let row = startRow; row <= endRow; row++) {
        const cellGroup = table.scenegraph.getCell(col, row);
        if (cellGroup) {
            const image = cellGroup.getChildByName("image");
            image && image.setAttributes({
                dx: -table.getColsWidth(cellGroup.mergeStartCol, col - 1),
                dy: -table.getRowsHeight(cellGroup.mergeStartRow, row - 1)
            });
            const playIcon = cellGroup.getChildByName("play-icon");
            playIcon && playIcon.setAttributes({
                dx: -table.getColsWidth(cellGroup.mergeStartCol, col - 1),
                dy: -table.getRowsHeight(cellGroup.mergeStartRow, row - 1)
            });
        }
    }
}

function updateAutoSizingAndKeepAspectRatio(imageAutoSizing, keepAspectRatio, padding, textAlign, textBaseline, image, cellGroup, table) {
    const originImage = image.resources.get(image.attribute.image).data, {col: col, row: row} = cellGroup;
    if (imageAutoSizing && !isDamagePic(image) && _adjustWidthHeight(col, row, originImage.width, originImage.height, table.scenegraph, padding, cellGroup), 
    keepAspectRatio || isDamagePic(image)) {
        const {width: cellWidth, height: cellHeight, isMerge: isMerge} = getCellRange(cellGroup, table), {width: imageWidth, height: imageHeight} = calcKeepAspectRatioSize(originImage.width, originImage.height, cellWidth - padding[1] - padding[3], cellHeight - padding[0] - padding[2]), pos = calcStartPosition(0, 0, cellWidth, cellHeight, imageWidth, imageHeight, textAlign, textBaseline, padding);
        image.setAttributes({
            x: pos.x,
            y: pos.y,
            width: imageWidth,
            height: imageHeight
        }), isMerge && updateImageDxDy(cellGroup.mergeStartCol, cellGroup.mergeEndCol, cellGroup.mergeStartRow, cellGroup.mergeEndRow, table);
    }
}

function isDamagePic(image) {
    const regedIcons = icons.get();
    return image.attribute.image === regedIcons.damage_pic.svg;
}
//# sourceMappingURL=image-cell.js.map
