import { isValid } from "@visactor/vutils";

import { Group } from "../../graphic/group";

import { getFunctionalProp } from "../../utils/get-prop";

import { createCellContent } from "../../utils/text-icon-layout";

import { getCellBorderStrokeWidth } from "../../utils/cell-border-stroke-width";

import { createMark } from "../../graphic/mark";

export function createCellGroup(table, value, columnGroup, xOrigin, yOrigin, col, row, colWidth, cellWidth, cellHeight, padding, textAlign, textBaseline, mayHaveIcon, customElementsGroup, renderDefault, cellTheme, range, isAsync) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8;
    const headerStyle = table._getCellStyle(col, row), functionalPadding = getFunctionalProp("padding", headerStyle, col, row, table);
    isValid(functionalPadding) && (padding = functionalPadding), (null === (_a = null == cellTheme ? void 0 : cellTheme.text) || void 0 === _a ? void 0 : _a.textAlign) && (textAlign = null === (_b = null == cellTheme ? void 0 : cellTheme.text) || void 0 === _b ? void 0 : _b.textAlign), 
    (null === (_c = null == cellTheme ? void 0 : cellTheme.text) || void 0 === _c ? void 0 : _c.textBaseline) && (textBaseline = null === (_d = null == cellTheme ? void 0 : cellTheme.text) || void 0 === _d ? void 0 : _d.textBaseline);
    const autoRowHeight = table.isAutoRowHeight(row), autoColWidth = "auto" === colWidth, autoWrapText = null !== (_e = headerStyle.autoWrapText) && void 0 !== _e ? _e : table.internalProps.autoWrapText, lineClamp = headerStyle.lineClamp, strokeArrayWidth = getCellBorderStrokeWidth(col, row, cellTheme, table);
    let cellGroup;
    if (isAsync && (cellGroup = table.scenegraph.getCell(col, row, !0), cellGroup && "cell" === cellGroup.role && cellGroup.setAttributes({
        x: xOrigin,
        y: yOrigin,
        width: cellWidth,
        height: cellHeight,
        lineWidth: null !== (_g = null === (_f = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _f ? void 0 : _f.lineWidth) && void 0 !== _g ? _g : void 0,
        fill: null !== (_j = null === (_h = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _h ? void 0 : _h.fill) && void 0 !== _j ? _j : void 0,
        stroke: null !== (_l = null === (_k = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _k ? void 0 : _k.stroke) && void 0 !== _l ? _l : void 0,
        strokeArrayWidth: null != strokeArrayWidth ? strokeArrayWidth : void 0,
        strokeArrayColor: null !== (_o = null === (_m = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _m ? void 0 : _m.strokeArrayColor) && void 0 !== _o ? _o : void 0,
        cursor: null !== (_q = null === (_p = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _p ? void 0 : _p.cursor) && void 0 !== _q ? _q : void 0,
        lineDash: null !== (_s = null === (_r = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _r ? void 0 : _r.lineDash) && void 0 !== _s ? _s : void 0,
        lineCap: "butt",
        clip: !0,
        cornerRadius: cellTheme.group.cornerRadius
    })), cellGroup && "cell" === cellGroup.role || (cellGroup = new Group({
        x: xOrigin,
        y: yOrigin,
        width: cellWidth,
        height: cellHeight,
        lineWidth: null !== (_u = null === (_t = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _t ? void 0 : _t.lineWidth) && void 0 !== _u ? _u : void 0,
        fill: null !== (_w = null === (_v = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _v ? void 0 : _v.fill) && void 0 !== _w ? _w : void 0,
        stroke: null !== (_y = null === (_x = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _x ? void 0 : _x.stroke) && void 0 !== _y ? _y : void 0,
        strokeArrayWidth: null != strokeArrayWidth ? strokeArrayWidth : void 0,
        strokeArrayColor: null !== (_0 = null === (_z = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _z ? void 0 : _z.strokeArrayColor) && void 0 !== _0 ? _0 : void 0,
        cursor: null !== (_2 = null === (_1 = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _1 ? void 0 : _1.cursor) && void 0 !== _2 ? _2 : void 0,
        lineDash: null !== (_4 = null === (_3 = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _3 ? void 0 : _3.lineDash) && void 0 !== _4 ? _4 : void 0,
        lineCap: "butt",
        clip: !0,
        cornerRadius: cellTheme.group.cornerRadius
    }), cellGroup.role = "cell", cellGroup.col = col, cellGroup.row = row, null == columnGroup || columnGroup.addCellGroup(cellGroup)), 
    customElementsGroup && cellGroup.appendChild(customElementsGroup), renderDefault) {
        const textStr = value;
        let icons;
        if (mayHaveIcon) {
            let iconCol = col, iconRow = row;
            range && (iconCol = range.start.col, iconRow = range.start.row), icons = table.getCellIcons(iconCol, iconRow);
        }
        createCellContent(cellGroup, icons, textStr, padding, autoColWidth, autoRowHeight, autoWrapText, "number" == typeof lineClamp ? lineClamp : void 0, cellGroup.attribute.width, cellGroup.attribute.height, textAlign, textBaseline, table, cellTheme, range), 
        (null === (_5 = null == cellTheme ? void 0 : cellTheme._vtable) || void 0 === _5 ? void 0 : _5.marked) && createMark(null === (_6 = null == cellTheme ? void 0 : cellTheme._vtable) || void 0 === _6 ? void 0 : _6.marked, cellGroup, table);
    }
    return customElementsGroup && cellGroup.setAttributes({
        width: Math.max(cellGroup.attribute.width, null !== (_7 = customElementsGroup.attribute.width) && void 0 !== _7 ? _7 : 0),
        height: Math.max(cellGroup.attribute.height, null !== (_8 = customElementsGroup.attribute.height) && void 0 !== _8 ? _8 : 0)
    }), cellGroup;
}
//# sourceMappingURL=text-cell.js.map
