import { createImage } from "./../../../vrender";

import * as icons from "../../../icons";

import { Group } from "../../graphic/group";

import { calcKeepAspectRatioSize } from "../../utils/keep-aspect-ratio";

import { Icon } from "../../graphic/icon";

import { calcStartPosition } from "../../utils/cell-pos";

import { _adjustWidthHeight, getCellRange, updateImageDxDy } from "./image-cell";

import { getFunctionalProp } from "../../utils/get-prop";

import { isValid } from "@visactor/vutils";

import { getCellBorderStrokeWidth } from "../../utils/cell-border-stroke-width";

import { getQuadProps } from "../../utils/padding";

import { dealWithIconLayout } from "../../utils/text-icon-layout";

const regedIcons = icons.get();

export function createVideoCellGroup(columnGroup, xOrigin, yOrigin, col, row, width, height, keepAspectRatio, imageAutoSizing, padding, textAlign, textBaseline, mayHaveIcon, table, cellTheme, range, isAsync) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5;
    const headerStyle = table._getCellStyle(col, row), functionalPadding = getFunctionalProp("padding", headerStyle, col, row, table);
    (null === (_a = table.options.customConfig) || void 0 === _a ? void 0 : _a.imageMargin) ? padding = getQuadProps(null === (_b = table.options.customConfig) || void 0 === _b ? void 0 : _b.imageMargin) : isValid(functionalPadding) && (padding = functionalPadding), 
    (null === (_c = null == cellTheme ? void 0 : cellTheme.text) || void 0 === _c ? void 0 : _c.textAlign) && (textAlign = null === (_d = null == cellTheme ? void 0 : cellTheme.text) || void 0 === _d ? void 0 : _d.textAlign), 
    (null === (_e = null == cellTheme ? void 0 : cellTheme.text) || void 0 === _e ? void 0 : _e.textBaseline) && (textBaseline = null === (_f = null == cellTheme ? void 0 : cellTheme.text) || void 0 === _f ? void 0 : _f.textBaseline);
    const strokeArrayWidth = getCellBorderStrokeWidth(col, row, cellTheme, table);
    let cellGroup, cellIcons;
    if (isAsync && (cellGroup = table.scenegraph.highPerformanceGetCell(col, row, !0), 
    cellGroup && "cell" === cellGroup.role && cellGroup.setAttributes({
        x: xOrigin,
        y: yOrigin,
        width: width,
        height: height,
        lineWidth: null !== (_h = null === (_g = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _g ? void 0 : _g.lineWidth) && void 0 !== _h ? _h : void 0,
        fill: null !== (_k = null === (_j = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _j ? void 0 : _j.fill) && void 0 !== _k ? _k : void 0,
        stroke: null !== (_m = null === (_l = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _l ? void 0 : _l.stroke) && void 0 !== _m ? _m : void 0,
        strokeArrayWidth: strokeArrayWidth,
        strokeArrayColor: null !== (_p = null === (_o = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _o ? void 0 : _o.strokeArrayColor) && void 0 !== _p ? _p : void 0,
        cursor: null !== (_r = null === (_q = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _q ? void 0 : _q.cursor) && void 0 !== _r ? _r : void 0,
        lineDash: null !== (_t = null === (_s = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _s ? void 0 : _s.lineDash) && void 0 !== _t ? _t : void 0,
        lineCap: "butt",
        clip: !0,
        cornerRadius: cellTheme.group.cornerRadius
    })), cellGroup && "cell" === cellGroup.role || (cellGroup = new Group({
        x: xOrigin,
        y: yOrigin,
        width: width,
        height: height,
        lineWidth: null !== (_v = null === (_u = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _u ? void 0 : _u.lineWidth) && void 0 !== _v ? _v : void 0,
        fill: null !== (_x = null === (_w = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _w ? void 0 : _w.fill) && void 0 !== _x ? _x : void 0,
        stroke: null !== (_z = null === (_y = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _y ? void 0 : _y.stroke) && void 0 !== _z ? _z : void 0,
        strokeArrayWidth: strokeArrayWidth,
        strokeArrayColor: null !== (_1 = null === (_0 = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _0 ? void 0 : _0.strokeArrayColor) && void 0 !== _1 ? _1 : void 0,
        cursor: null !== (_3 = null === (_2 = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _2 ? void 0 : _2.cursor) && void 0 !== _3 ? _3 : void 0,
        lineDash: null !== (_5 = null === (_4 = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _4 ? void 0 : _4.lineDash) && void 0 !== _5 ? _5 : void 0,
        lineCap: "butt",
        clip: !0,
        cornerRadius: cellTheme.group.cornerRadius
    }), cellGroup.role = "cell", cellGroup.col = col, cellGroup.row = row, null == columnGroup || columnGroup.addCellGroup(cellGroup)), 
    mayHaveIcon) {
        let iconCol = col, iconRow = row;
        range && (iconCol = range.start.col, iconRow = range.start.row), cellIcons = table.getCellIcons(iconCol, iconRow);
    }
    let iconWidth = 0, cellLeftIconWidth = 0, cellRightIconWidth = 0;
    if (Array.isArray(cellIcons) && 0 !== cellIcons.length) {
        const {leftIconWidth: leftIconWidth, rightIconWidth: rightIconWidth, absoluteLeftIconWidth: absoluteLeftIconWidth, absoluteRightIconWidth: absoluteRightIconWidth} = dealWithIconLayout(cellIcons, cellGroup, range, table);
        iconWidth = leftIconWidth + rightIconWidth, cellLeftIconWidth = leftIconWidth, cellRightIconWidth = rightIconWidth, 
        cellGroup.forEachChildren((child => {
            "icon-left" === child.role ? child.setAttribute("x", child.attribute.x + padding[3]) : "icon-right" === child.role ? child.setAttribute("x", child.attribute.x + width - rightIconWidth - padding[1]) : "icon-absolute-right" === child.role && child.setAttribute("x", child.attribute.x + width - absoluteRightIconWidth - padding[1]);
        })), cellGroup.forEachChildren((child => {
            "middle" === textBaseline ? child.setAttribute("y", (height - child.AABBBounds.height()) / 2) : "bottom" === textBaseline ? child.setAttribute("y", height - child.AABBBounds.height() - padding[2]) : child.setAttribute("y", padding[0]);
        })), cellGroup._cellLeftIconWidth = cellLeftIconWidth, cellGroup._cellRightIconWidth = cellRightIconWidth;
    }
    const value = table.getCellValue(col, row), video = document.createElement("video");
    video.addEventListener("loadeddata", (() => {
        imageAutoSizing && _adjustWidthHeight(col, row, video.videoWidth, video.videoHeight, table.scenegraph, padding, cellGroup);
        const {width: cellWidth, height: cellHeight, isMerge: isMerge} = getCellRange(cellGroup, table);
        if (keepAspectRatio) {
            const {width: videoWidth, height: videoHeight} = calcKeepAspectRatioSize(video.videoWidth, video.videoHeight, cellWidth - padding[1] - padding[3], cellHeight - padding[0] - padding[2]), pos = calcStartPosition(0, 0, cellWidth, cellHeight, videoWidth, videoHeight, textAlign, textBaseline, padding);
            image.setAttributes({
                width: videoWidth,
                height: videoHeight,
                x: pos.x,
                y: pos.y,
                dx: 0
            });
        } else image.setAttributes({
            x: padding[3],
            y: padding[0],
            width: cellWidth - padding[1] - padding[3],
            height: cellHeight - padding[2] - padding[0],
            dy: 0
        });
        isMerge && updateImageDxDy(cellGroup.mergeStartCol, cellGroup.mergeEndCol, cellGroup.mergeStartRow, cellGroup.mergeEndRow, table);
        const {width: width, height: height} = getCellRange(cellGroup, table), iconSize = Math.floor(Math.min(width - padding[1] - padding[3], height - padding[2] - padding[0]) / 2), anchorX = 0 + (width > image.attribute.width ? image.attribute.x - 0 + image.attribute.width / 2 : width / 2), anchorY = 0 + (height > image.attribute.height ? image.attribute.y - 0 + image.attribute.height / 2 : height / 2), imageGraphic = cellGroup.getChildByName("image", !0), {dx: dx, dy: dy} = imageGraphic.attribute, playIcon = new Icon({
            x: anchorX - iconSize / 2,
            y: anchorY - iconSize / 2,
            width: iconSize,
            height: iconSize,
            image: regedIcons.play.svg,
            cursor: regedIcons.play.cursor,
            dx: dx,
            dy: dy
        });
        playIcon.name = "play-icon", cellGroup.appendChild(playIcon), table.scenegraph.updateNextFrame();
    })), video.onerror = () => {
        image.image = regedIcons.damage_pic.svg;
    }, video.src = value, video.setAttribute("preload", "auto");
    const image = createImage({
        x: padding[3],
        y: padding[0],
        width: width - padding[1] - padding[3],
        height: height - padding[2] - padding[0],
        image: video,
        cursor: "pointer"
    });
    return image.name = "image", image.keepAspectRatio = keepAspectRatio, image.textAlign = textAlign, 
    image.textBaseline = textBaseline, cellGroup.appendChild(image), cellGroup;
}
//# sourceMappingURL=video-cell.js.map
