import { createLine, createSymbol } from "./../../../vrender";

import { PointScale, LinearScale } from "@visactor/vscale";

import { isValid } from "@visactor/vutils";

import { Group } from "../../graphic/group";

import { getCellBorderStrokeWidth } from "../../utils/cell-border-stroke-width";

const xScale = new PointScale, yScale = new LinearScale;

export function createSparkLineCellGroup(cellGroup, columnGroup, xOrigin, yOrigin, col, row, width, height, padding, table, cellTheme, isAsync) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z;
    if (!cellGroup) {
        const strokeArrayWidth = getCellBorderStrokeWidth(col, row, cellTheme, table);
        isAsync && (cellGroup = table.scenegraph.highPerformanceGetCell(col, row, !0)) && "cell" === cellGroup.role && cellGroup.setAttributes({
            x: xOrigin,
            y: yOrigin,
            width: width,
            height: height,
            lineWidth: null !== (_b = null === (_a = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _a ? void 0 : _a.lineWidth) && void 0 !== _b ? _b : void 0,
            fill: null !== (_d = null === (_c = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _c ? void 0 : _c.fill) && void 0 !== _d ? _d : void 0,
            stroke: null !== (_f = null === (_e = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _e ? void 0 : _e.stroke) && void 0 !== _f ? _f : void 0,
            strokeArrayWidth: strokeArrayWidth,
            strokeArrayColor: null !== (_h = null === (_g = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _g ? void 0 : _g.strokeArrayColor) && void 0 !== _h ? _h : void 0,
            cursor: null !== (_k = null === (_j = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _j ? void 0 : _j.cursor) && void 0 !== _k ? _k : void 0,
            lineDash: null !== (_m = null === (_l = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _l ? void 0 : _l.lineDash) && void 0 !== _m ? _m : void 0,
            lineCap: "butt",
            clip: !0,
            cornerRadius: cellTheme.group.cornerRadius
        }), cellGroup && "cell" === cellGroup.role || ((cellGroup = new Group({
            x: xOrigin,
            y: yOrigin,
            width: width,
            height: height,
            lineWidth: null !== (_p = null === (_o = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _o ? void 0 : _o.lineWidth) && void 0 !== _p ? _p : void 0,
            fill: null !== (_r = null === (_q = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _q ? void 0 : _q.fill) && void 0 !== _r ? _r : void 0,
            stroke: null !== (_t = null === (_s = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _s ? void 0 : _s.stroke) && void 0 !== _t ? _t : void 0,
            strokeArrayWidth: strokeArrayWidth,
            strokeArrayColor: null !== (_v = null === (_u = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _u ? void 0 : _u.strokeArrayColor) && void 0 !== _v ? _v : void 0,
            cursor: null !== (_x = null === (_w = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _w ? void 0 : _w.cursor) && void 0 !== _x ? _x : void 0,
            lineDash: null !== (_z = null === (_y = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _y ? void 0 : _y.lineDash) && void 0 !== _z ? _z : void 0,
            lineCap: "butt",
            clip: !0,
            cornerRadius: cellTheme.group.cornerRadius
        })).role = "cell", cellGroup.col = col, cellGroup.row = row, null == columnGroup || columnGroup.addCellGroup(cellGroup));
    }
    const chartGroup = createSparkLine(col, row, width, height, padding, table);
    return chartGroup && cellGroup.appendChild(chartGroup), cellGroup;
}

function createSparkLine(col, row, width, height, padding, table) {
    let sparklineSpec, chartGroup;
    const chartSpecRaw = table.internalProps.layoutMap.getBody(col, row).sparklineSpec, dataValue = table.getCellValue(col, row);
    if (!Array.isArray(dataValue)) return;
    const x = padding[3], y = padding[0];
    width -= padding[1] + padding[3];
    const bottom = height -= padding[0] + padding[2];
    if ("function" == typeof chartSpecRaw) {
        const arg = {
            col: col,
            row: row,
            dataValue: table.getCellOriginValue(col, row) || "",
            value: table.getCellValue(col, row) || "",
            rect: table.getCellRangeRelativeRect(table.getCellRange(col, row)),
            table: table
        };
        sparklineSpec = chartSpecRaw(arg), chartGroup = createChartGroup(sparklineSpec, x, y, width, height);
    } else sparklineSpec = chartSpecRaw, chartGroup = createChartGroup(chartSpecRaw, x, y, width, height);
    const items = [], dataItems = [];
    let xField, yField;
    if ("object" == typeof sparklineSpec.xField) xScale.domain(sparklineSpec.xField.domain), 
    xField = sparklineSpec.xField.field; else if ("string" == typeof sparklineSpec.xField) {
        const indexValues = dataValue.map((value => value[sparklineSpec.xField]));
        xScale.domain(indexValues), xField = sparklineSpec.xField;
    } else Array.isArray(dataValue) && (xScale.domain(Array.from({
        length: dataValue.length
    }, ((_, i) => i))), xField = sparklineSpec.xField);
    if (xScale.range([ 0, width ]), "object" == typeof sparklineSpec.yField) yScale.domain(sparklineSpec.yField.domain), 
    yField = sparklineSpec.yField.field; else if ("string" == typeof sparklineSpec.yField) {
        const values = getYNumbers(dataValue, sparklineSpec.yField);
        yScale.domain([ Math.min(...values), Math.max(...values) ]), yField = sparklineSpec.yField;
    } else if (Array.isArray(dataValue)) {
        const values = getYNumbers(dataValue);
        yScale.domain([ Math.min(...values), Math.max(...values) ]), yField = sparklineSpec.yField;
    }
    if (yScale.range([ 0, height ]), "object" == typeof sparklineSpec.xField && Array.isArray(sparklineSpec.xField.domain)) {
        const values = dataValue.map((value => value[sparklineSpec.xField.field])), domain = sparklineSpec.xField.domain;
        for (let i = 0; i < domain.length; i++) {
            let valid = !1;
            for (let j = 0; j < values.length; j++) if (domain[i] === values[j]) {
                const data = dataValue[j];
                if (!isValid(data[xField]) || !isValid(data[yField])) break;
                items.push({
                    x: 0 + xScale.scale(data[xField]),
                    y: bottom - yScale.scale(data[yField]),
                    defined: isValid(data[yField])
                }), dataItems.push(data), valid = !0;
                break;
            }
            valid || (items.push({
                x: 0 + xScale.scale(domain[i]),
                y: 0,
                defined: !1
            }), dataItems.push({
                [xField]: domain[i],
                [yField]: null
            }));
        }
    } else for (let i = 0; i < dataValue.length; i++) {
        const data = dataValue[i];
        items.push({
            x: 0 + xScale.scale(xField ? data[xField] : i),
            y: bottom - yScale.scale(yField ? data[yField] : data),
            defined: isValid(yField ? data[yField] : data),
            rawData: data
        }), dataItems.push(data);
    }
    const line = chartGroup.getChildByName("sparkline-line");
    line && line.setAttribute("points", items), line.bandwidth = xScale.step(), line.min = yScale.range()[0], 
    line.max = yScale.range()[1];
    const symbolGroup = chartGroup.getChildByName("sparkline-symbol-group");
    if (symbolGroup) {
        const isShowIsolatedPoint = "isolatedPoint" === sparklineSpec.pointShowRule;
        if ("all" === sparklineSpec.pointShowRule) for (let i = 0; i < items.length; i++) {
            const {x: x, y: y, defined: defined} = items[i];
            if (defined) {
                const symbol = createSymbol({
                    x: x,
                    y: y
                });
                symbolGroup.appendChild(symbol);
            }
        } else if (isShowIsolatedPoint) for (let i = 0; i < items.length; i++) {
            const {x: x, y: y, defined: defined} = items[i];
            if (defined && (!items[i - 1] || !items[i - 1].defined) && (!items[i + 1] || !items[i + 1].defined)) {
                const symbol = createSymbol({
                    x: x,
                    y: y
                });
                symbolGroup.appendChild(symbol);
            }
        }
    }
    return chartGroup;
}

function createChartGroup(spec, x, y, width, height) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;
    let specObj;
    specObj = "function" == typeof spec ? spec(null) : spec;
    const group = new Group({
        x: x,
        y: y,
        width: width,
        height: height,
        stroke: !1,
        fill: !1
    });
    if (group.name = "sparkline", "line" === specObj.type) {
        const line = createLine({
            x: 0,
            y: 0,
            curveType: specObj.smooth ? "monotoneX" : "linear",
            stroke: null !== (_c = null === (_b = null === (_a = specObj.line) || void 0 === _a ? void 0 : _a.style) || void 0 === _b ? void 0 : _b.stroke) && void 0 !== _c ? _c : "blue",
            lineWidth: null !== (_f = null === (_e = null === (_d = specObj.line) || void 0 === _d ? void 0 : _d.style) || void 0 === _e ? void 0 : _e.strokeWidth) && void 0 !== _f ? _f : 2
        });
        line.name = "sparkline-line", group.addChild(line), specObj.crosshair && (line.hover = null !== (_h = null === (_g = specObj.crosshair) || void 0 === _g ? void 0 : _g.style) && void 0 !== _h ? _h : {
            stroke: "#000",
            interpolate: "linear"
        });
        const symbolGroup = new Group({
            x: 0,
            y: 0,
            width: width,
            height: height,
            stroke: !1,
            fill: !1
        });
        symbolGroup.name = "sparkline-symbol-group", symbolGroup.setTheme({
            symbol: {
                stroke: null !== (_l = null === (_k = null === (_j = specObj.point) || void 0 === _j ? void 0 : _j.style) || void 0 === _k ? void 0 : _k.stroke) && void 0 !== _l ? _l : "#000",
                lineWidth: null !== (_p = null === (_o = null === (_m = specObj.point) || void 0 === _m ? void 0 : _m.style) || void 0 === _o ? void 0 : _o.strokeWidth) && void 0 !== _p ? _p : 1,
                fill: null !== (_s = null === (_r = null === (_q = specObj.point) || void 0 === _q ? void 0 : _q.style) || void 0 === _r ? void 0 : _r.fill) && void 0 !== _s ? _s : "#000",
                size: 2 * (null !== (_v = null === (_u = null === (_t = specObj.point) || void 0 === _t ? void 0 : _t.style) || void 0 === _u ? void 0 : _u.size) && void 0 !== _v ? _v : 3),
                symbolType: "circle"
            }
        }), group.addChild(symbolGroup), symbolGroup.hover = null !== (_x = null === (_w = specObj.point) || void 0 === _w ? void 0 : _w.hover) && void 0 !== _x && _x;
    }
    return group;
}

function getYNumbers(data, field) {
    const numbers = [];
    for (let i = 0; i < data.length; i++) {
        const item = data[i];
        isValid(field) && isValid(item[field]) ? numbers.push(item[field]) : !isValid(field) && isValid(item) && numbers.push(item);
    }
    return numbers;
}
//# sourceMappingURL=spark-line-cell.js.map
