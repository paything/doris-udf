import { Tag } from "./../../../vrender";

import { Group } from "../../graphic/group";

import { getCellBorderStrokeWidth } from "../../utils/cell-border-stroke-width";

import { getProp } from "../../utils/get-prop";

import { getOrApply } from "../../../tools/helper";

import { getHierarchyOffset } from "../../utils/get-hierarchy-offset";

import { dealWithIconLayout } from "../../utils/text-icon-layout";

export function createButtonCellGroup(cellGroup, columnGroup, xOrigin, yOrigin, col, row, colWidth, width, height, padding, textAlign, textBaseline, mayHaveIcon, table, cellTheme, define, range, isAsync) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z;
    if (!cellGroup) {
        const strokeArrayWidth = getCellBorderStrokeWidth(col, row, cellTheme, table);
        isAsync && (cellGroup = table.scenegraph.highPerformanceGetCell(col, row, !0)) && "cell" === cellGroup.role && cellGroup.setAttributes({
            x: xOrigin,
            y: yOrigin,
            width: width,
            height: height,
            lineWidth: null !== (_b = null === (_a = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _a ? void 0 : _a.lineWidth) && void 0 !== _b ? _b : void 0,
            fill: null !== (_d = null === (_c = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _c ? void 0 : _c.fill) && void 0 !== _d ? _d : void 0,
            stroke: null !== (_f = null === (_e = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _e ? void 0 : _e.stroke) && void 0 !== _f ? _f : void 0,
            strokeArrayWidth: strokeArrayWidth,
            strokeArrayColor: null !== (_h = null === (_g = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _g ? void 0 : _g.strokeArrayColor) && void 0 !== _h ? _h : void 0,
            cursor: null !== (_k = null === (_j = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _j ? void 0 : _j.cursor) && void 0 !== _k ? _k : void 0,
            lineDash: null !== (_m = null === (_l = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _l ? void 0 : _l.lineDash) && void 0 !== _m ? _m : void 0,
            lineCap: "butt",
            clip: !0,
            cornerRadius: cellTheme.group.cornerRadius
        }), cellGroup && "cell" === cellGroup.role || ((cellGroup = new Group({
            x: xOrigin,
            y: yOrigin,
            width: width,
            height: height,
            lineWidth: null !== (_p = null === (_o = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _o ? void 0 : _o.lineWidth) && void 0 !== _p ? _p : void 0,
            fill: null !== (_r = null === (_q = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _q ? void 0 : _q.fill) && void 0 !== _r ? _r : void 0,
            stroke: null !== (_t = null === (_s = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _s ? void 0 : _s.stroke) && void 0 !== _t ? _t : void 0,
            strokeArrayWidth: strokeArrayWidth,
            strokeArrayColor: null !== (_v = null === (_u = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _u ? void 0 : _u.strokeArrayColor) && void 0 !== _v ? _v : void 0,
            cursor: null !== (_x = null === (_w = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _w ? void 0 : _w.cursor) && void 0 !== _x ? _x : void 0,
            lineDash: null !== (_z = null === (_y = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _y ? void 0 : _y.lineDash) && void 0 !== _z ? _z : void 0,
            lineCap: "butt",
            clip: !0,
            cornerRadius: cellTheme.group.cornerRadius
        })).role = "cell", cellGroup.col = col, cellGroup.row = row, null == columnGroup || columnGroup.addCellGroup(cellGroup));
    }
    let icons;
    if (mayHaveIcon) {
        let iconCol = col, iconRow = row;
        range && (iconCol = range.start.col, iconRow = range.start.row), icons = table.getCellIcons(iconCol, iconRow);
    }
    let iconWidth = 0, cellLeftIconWidth = 0, cellRightIconWidth = 0;
    if (Array.isArray(icons) && 0 !== icons.length) {
        const {leftIconWidth: leftIconWidth, rightIconWidth: rightIconWidth, absoluteLeftIconWidth: absoluteLeftIconWidth, absoluteRightIconWidth: absoluteRightIconWidth} = dealWithIconLayout(icons, cellGroup, range, table);
        iconWidth = leftIconWidth + rightIconWidth, cellLeftIconWidth = leftIconWidth, cellRightIconWidth = rightIconWidth, 
        cellGroup.forEachChildren((child => {
            "icon-left" === child.role ? child.setAttribute("x", child.attribute.x + padding[3]) : "icon-right" === child.role ? child.setAttribute("x", child.attribute.x + width - rightIconWidth - padding[1]) : "icon-absolute-right" === child.role && child.setAttribute("x", child.attribute.x + width - absoluteRightIconWidth - padding[1]);
        })), cellGroup.forEachChildren((child => {
            "middle" === textBaseline ? child.setAttribute("y", (height - child.AABBBounds.height()) / 2) : "bottom" === textBaseline ? child.setAttribute("y", height - child.AABBBounds.height() - padding[2]) : child.setAttribute("y", padding[0]);
        }));
    }
    const buttonComponent = createButton(col, row, colWidth - iconWidth, width, height, padding, cellTheme, define, table);
    return buttonComponent && cellGroup.appendChild(buttonComponent), width -= padding[1] + padding[3] + iconWidth, 
    height -= padding[0] + padding[2], "center" === textAlign ? buttonComponent.setAttribute("x", padding[3] + cellLeftIconWidth + (width - buttonComponent.AABBBounds.width()) / 2) : "right" === textAlign ? buttonComponent.setAttribute("x", padding[3] + cellLeftIconWidth + width - buttonComponent.AABBBounds.width()) : buttonComponent.setAttribute("x", padding[3] + cellLeftIconWidth), 
    "middle" === textBaseline ? buttonComponent.setAttribute("y", padding[0] + (height - buttonComponent.AABBBounds.height()) / 2) : "bottom" === textBaseline ? buttonComponent.setAttribute("y", padding[0] + height - buttonComponent.AABBBounds.height()) : buttonComponent.setAttribute("y", padding[0]), 
    cellGroup;
}

function createButton(col, row, colWidth, cellWidth, cellHeight, padding, cellTheme, define, table) {
    var _a, _b;
    const style = table._getCellStyle(col, row), buttonColor = getProp("buttonColor", style, col, row, table), buttonBorderColor = getProp("buttonBorderColor", style, col, row, table), buttonLineWidth = getProp("buttonLineWidth", style, col, row, table), buttonBorderRadius = getProp("buttonBorderRadius", style, col, row, table), buttonHoverColor = getProp("buttonHoverColor", style, col, row, table), buttonHoverBorderColor = getProp("buttonHoverBorderColor", style, col, row, table), buttonPadding = getProp("buttonPadding", style, col, row, table), buttonTextHoverColor = getProp("buttonTextHoverColor", style, col, row, table), buttonDisableColor = getProp("buttonDisableColor", style, col, row, table), buttonDisableBorderColor = getProp("buttonDisableBorderColor", style, col, row, table), buttonTextDisableColor = getProp("buttonTextDisableColor", style, col, row, table), value = table.getCellValue(col, row), dataValue = table.getCellOriginValue(col, row), hierarchyOffset = getHierarchyOffset(col, row, table), cellStyle = table._getCellStyle(col, row), autoWrapText = null !== (_a = cellStyle.autoWrapText) && void 0 !== _a ? _a : table.internalProps.autoWrapText, {lineClamp: lineClamp} = cellStyle, autoColWidth = "auto" === colWidth, autoRowHeight = table.isAutoRowHeight(row), {disable: disable, text: text} = define, isDisable = getOrApply(disable, {
        col: col,
        row: row,
        table: table,
        context: null,
        value: value,
        dataValue: dataValue
    }), buttonTextValue = getOrApply(text, {
        col: col,
        row: row,
        table: table,
        context: null,
        value: value,
        dataValue: dataValue
    }), buttonText = null !== (_b = null != buttonTextValue ? buttonTextValue : value) && void 0 !== _b ? _b : "", attribute = {
        maxLineWidth: autoColWidth ? 1 / 0 : cellWidth - (padding[1] + padding[3] + hierarchyOffset),
        textAlign: "left",
        textBaseline: "top",
        autoWrapText: autoWrapText,
        lineClamp: lineClamp,
        wordBreak: "break-word",
        heightLimit: autoRowHeight ? -1 : cellHeight - Math.floor(padding[0] + padding[2]),
        pickable: !1,
        dx: hierarchyOffset,
        whiteSpace: 1 !== buttonText.length || autoWrapText ? "normal" : "no-wrap"
    }, testAttribute = cellTheme.text ? Object.assign({}, cellTheme.text, attribute) : attribute, buttonAttributes = {
        x: 0,
        y: 0,
        cursor: isDisable ? "not-allowed" : "pointer",
        disable: isDisable,
        childrenPickable: !1,
        text: 1 === buttonText.length ? buttonText[0] : buttonText,
        textStyle: testAttribute,
        padding: buttonPadding,
        panel: {
            visible: !0,
            fill: isDisable ? buttonDisableColor : buttonColor,
            stroke: isDisable ? buttonDisableBorderColor : buttonBorderColor,
            lineWidth: buttonLineWidth,
            cornerRadius: buttonBorderRadius
        },
        state: {
            text: {
                hover: {}
            },
            panel: {
                hover: {
                    fill: buttonHoverColor,
                    stroke: buttonHoverBorderColor
                }
            }
        }
    };
    buttonTextDisableColor && (buttonAttributes.state.text.fill = buttonTextDisableColor), 
    buttonTextHoverColor && (buttonAttributes.state.text.hover.fill = buttonTextHoverColor);
    const buttonComponent = new Tag(buttonAttributes);
    return buttonComponent.name = "button", isDisable || (buttonComponent.addEventListener("mouseenter", (() => {
        buttonComponent.addState("hover", !0, !1), buttonComponent.stage.renderNextFrame();
    })), buttonComponent.addEventListener("mouseleave", (() => {
        buttonComponent.removeState("hover", !1), buttonComponent.stage.renderNextFrame();
    }))), buttonComponent;
}
//# sourceMappingURL=button-cell.js.map
