import { isEqual } from "@visactor/vutils";

import { Factory } from "../../core/factory";

import { getQuadProps } from "../utils/padding";

import { getProp } from "../utils/get-prop";

export function updateChartSizeForResizeColWidth(scenegraph, col) {
    const {table: table} = scenegraph, layout = table.internalProps.layoutMap, columnResizeType = -1 === col ? "all" : table.internalProps.columnResizeType;
    if ("column" === columnResizeType) {
        const columnGroup = scenegraph.getColGroup(col), columnHeaderGroup = scenegraph.getColGroup(col, !0), columnBottomGroup = scenegraph.getColGroupInBottom(col, !0);
        if (null == columnGroup || columnGroup.forEachChildren((cellNode => {
            updateChartGraphicSize(cellNode, table.getColWidth(cellNode.col), table.getRowHeight(cellNode.row));
        })), null == columnHeaderGroup || columnHeaderGroup.forEachChildren((cellNode => {
            updateChartGraphicSize(cellNode, table.getColWidth(cellNode.col), table.getRowHeight(cellNode.row));
        })), null == columnBottomGroup || columnBottomGroup.forEachChildren((cellNode => {
            updateChartGraphicSize(cellNode, table.getColWidth(cellNode.col), table.getRowHeight(cellNode.row));
        })), "adaptive" === table.widthMode && col < table.colCount - 1) {
            const columnGroup = scenegraph.getColGroup(col + 1), columnHeaderGroup = scenegraph.getColGroup(col + 1, !0), columnBottomGroup = scenegraph.getColGroupInBottom(col + 1, !0);
            null == columnGroup || columnGroup.forEachChildren((cellNode => {
                updateChartGraphicSize(cellNode, table.getColWidth(cellNode.col), table.getRowHeight(cellNode.row));
            })), null == columnHeaderGroup || columnHeaderGroup.forEachChildren((cellNode => {
                updateChartGraphicSize(cellNode, table.getColWidth(cellNode.col), table.getRowHeight(cellNode.row));
            })), null == columnBottomGroup || columnBottomGroup.forEachChildren((cellNode => {
                updateChartGraphicSize(cellNode, table.getColWidth(cellNode.col), table.getRowHeight(cellNode.row));
            }));
        }
    } else {
        let resizeIndicatorKey, resizeDimensionKey, resizeDimensionValue, startCol = table.rowHeaderLevelCount, endCol = table.colCount - 1;
        if ("indicator" === columnResizeType) if (layout.indicatorsAsCol) resizeIndicatorKey = layout.getIndicatorKey(col, table.columnHeaderLevelCount); else {
            const headerPaths = layout.getCellHeaderPaths(col, table.columnHeaderLevelCount - 1), headerPath = headerPaths.colHeaderPaths[headerPaths.colHeaderPaths.length - 1];
            resizeDimensionKey = headerPath.dimensionKey, resizeDimensionValue = headerPath.value;
        } else if ("indicatorGroup" === columnResizeType) {
            const layout = table.internalProps.layoutMap, headerPaths = layout.getCellHeaderPaths(table.stateManager.columnResize.col, table.columnHeaderLevelCount), node = layout.getHeadNodeByRowOrColDimensions(headerPaths.colHeaderPaths.slice(0, headerPaths.colHeaderPaths.length - 1));
            startCol = node.startInTotal + table.frozenColCount, endCol = node.startInTotal + table.frozenColCount + node.size - 1;
        }
        for (let c = startCol; c <= endCol; c++) {
            const columnGroup = scenegraph.getColGroup(c), columnHeaderGroup = scenegraph.getColGroup(c, !0), columnBottomGroup = scenegraph.getColGroupInBottom(c, !0);
            if (columnGroup) {
                if ("indicator" === columnResizeType) {
                    const indicatorKey = layout.getIndicatorKey(c, table.columnHeaderLevelCount);
                    if (layout.indicatorsAsCol && indicatorKey !== resizeIndicatorKey) continue;
                    if (!layout.indicatorsAsCol) {
                        const headerPaths = layout.getCellHeaderPaths(c, table.columnHeaderLevelCount - 1), headerPath = null == headerPaths ? void 0 : headerPaths.colHeaderPaths[headerPaths.colHeaderPaths.length - 1];
                        if (!headerPath || resizeDimensionKey !== headerPath.dimensionKey || resizeDimensionValue !== headerPath.value) continue;
                    }
                }
                columnGroup.forEachChildren((cellNode => {
                    updateChartGraphicSize(cellNode, table.getColWidth(cellNode.col), table.getRowHeight(cellNode.row));
                })), null == columnHeaderGroup || columnHeaderGroup.forEachChildren((cellNode => {
                    updateChartGraphicSize(cellNode, table.getColWidth(cellNode.col), table.getRowHeight(cellNode.row));
                })), null == columnBottomGroup || columnBottomGroup.forEachChildren((cellNode => {
                    updateChartGraphicSize(cellNode, table.getColWidth(cellNode.col), table.getRowHeight(cellNode.row));
                }));
            }
        }
    }
}

export function updateChartSizeForResizeRowHeight(scenegraph, row) {
    var _a;
    const {table: table} = scenegraph, layout = table.internalProps.layoutMap, state = table.stateManager, rowResizeType = -1 === row ? "all" : table.internalProps.rowResizeType;
    let resizeIndicatorKey, resizeDimensionKey, resizeDimensionValue, startRow = table.columnHeaderLevelCount, endRow = table.rowCount - 1;
    if ("indicator" === rowResizeType) if (layout.indicatorsAsCol) {
        const headerPaths = layout.getCellHeaderPaths(table.rowHeaderLevelCount - 1, row), headerPath = null === (_a = headerPaths.rowHeaderPaths) || void 0 === _a ? void 0 : _a[headerPaths.rowHeaderPaths.length - 1];
        resizeDimensionKey = null == headerPath ? void 0 : headerPath.dimensionKey, resizeDimensionValue = null == headerPath ? void 0 : headerPath.value;
    } else resizeIndicatorKey = layout.getIndicatorKey(table.rowHeaderLevelCount, row); else if ("indicatorGroup" === rowResizeType) {
        const layout = table.internalProps.layoutMap, headerPaths = layout.getCellHeaderPaths(table.rowHeaderLevelCount, row), node = layout.getHeadNodeByRowOrColDimensions(headerPaths.rowHeaderPaths.slice(0, headerPaths.rowHeaderPaths.length - 1));
        startRow = node.startInTotal + table.frozenRowCount, endRow = node.startInTotal + table.frozenRowCount + node.size - 1;
    }
    const colsRange = [ {
        startCol: scenegraph.proxy.colStart,
        endCol: scenegraph.proxy.colEnd
    } ];
    table.frozenColCount && colsRange.push({
        startCol: 0,
        endCol: table.frozenColCount - 1
    }), table.rightFrozenColCount && colsRange.push({
        startCol: table.colCount - table.rightFrozenColCount,
        endCol: table.colCount - 1
    }), colsRange.forEach((({startCol: startCol, endCol: endCol}) => {
        for (let col = startCol; col <= endCol; col++) if ("row" === rowResizeType) {
            const cellNode = scenegraph.highPerformanceGetCell(col, row);
            if ("cell" !== cellNode.role) continue;
            if (updateChartGraphicSize(cellNode, table.getColWidth(cellNode.col), table.getRowHeight(cellNode.row)), 
            "adaptive" === table.heightMode && row < table.rowCount - 1) {
                const cellNode = scenegraph.highPerformanceGetCell(col, row + 1);
                updateChartGraphicSize(cellNode, table.getColWidth(cellNode.col), table.getRowHeight(cellNode.row));
            }
        } else for (let r = startRow; r <= endRow; r++) {
            if ("indicator" === rowResizeType) {
                const indicatorKey = layout.getIndicatorKey(state.table.rowHeaderLevelCount, r);
                if (!layout.indicatorsAsCol && indicatorKey !== resizeIndicatorKey) continue;
                if (layout.indicatorsAsCol) {
                    const headerPaths = layout.getCellHeaderPaths(state.table.rowHeaderLevelCount - 1, r), headerPath = null == headerPaths ? void 0 : headerPaths.rowHeaderPaths[headerPaths.rowHeaderPaths.length - 1];
                    if (!headerPath || resizeDimensionKey !== headerPath.dimensionKey || resizeDimensionValue !== headerPath.value) continue;
                }
            }
            const cellNode = scenegraph.highPerformanceGetCell(col, r);
            if ("cell" !== cellNode.role) continue;
            updateChartGraphicSize(cellNode, table.getColWidth(cellNode.col), table.getRowHeight(cellNode.row));
        }
    }));
}

export function clearChartCacheImage(scenegraph) {
    var _a;
    for (let c = scenegraph.proxy.colStart; c <= scenegraph.proxy.colEnd; c++) {
        const columnGroup = scenegraph.getColGroup(c);
        null === (_a = null == columnGroup ? void 0 : columnGroup.getChildren()) || void 0 === _a || _a.forEach((cellNode => {
            cellNode.children.forEach((node => {
                "chart" === node.type && (node.cacheCanvas = null, node.addUpdateBoundTag());
            }));
        }));
    }
}

export function clearCellChartCacheImage(col, row, scenegraph) {
    scenegraph.getCell(col, row).children.forEach((node => {
        "chart" === node.type && (node.cacheCanvas = null, node.addUpdateBoundTag());
    }));
}

export function updateChartData(scenegraph) {
    var _a;
    const table = scenegraph.table;
    for (let c = scenegraph.proxy.colStart; c <= scenegraph.proxy.colEnd; c++) {
        const columnGroup = scenegraph.getColGroup(c);
        null === (_a = null == columnGroup ? void 0 : columnGroup.getChildren()) || void 0 === _a || _a.forEach((cellNode => {
            const col = cellNode.col, row = cellNode.row;
            cellNode.children.forEach((node => {
                if ("chart" === node.type) {
                    node.updateData(table.getCellValue(col, row));
                    const chartSpec = node.attribute.spec, chartType = chartSpec.type;
                    if ("gauge" !== chartType && "rose" !== chartType && "radar" !== chartType) {
                        const newAxes = table.internalProps.layoutMap.getChartAxes(col, row);
                        node.setAttribute("axes", newAxes), chartSpec.axes = newAxes;
                    }
                    node.setAttribute("spec", chartSpec);
                }
            }));
        }));
    }
    updateTableAxes(scenegraph.rowHeaderGroup, scenegraph.table), updateTableAxes(scenegraph.colHeaderGroup, scenegraph.table), 
    updateTableAxes(scenegraph.rightFrozenGroup, scenegraph.table), updateTableAxes(scenegraph.bottomFrozenGroup, scenegraph.table);
}

export function updateChartState(scenegraph, datum) {
    const table = scenegraph.table;
    if (table.isPivotChart()) {
        const preSelectItemsCount = table._selectedDataItemsInChart.length;
        if ((null === datum || 0 === (null == datum ? void 0 : datum.length) || 0 === Object.keys(datum).length) && 0 === preSelectItemsCount) return;
        const newSelectedDataItemsInChart = [];
        if (Array.isArray(datum)) datum.forEach((dataItem => {
            if (dataItem && 0 !== dataItem.key && Object.keys(dataItem).length > 0) {
                const selectedState = {};
                for (const itemKey in dataItem) itemKey.startsWith("VGRAMMAR_") || itemKey.startsWith("__VCHART") || (selectedState[itemKey] = dataItem[itemKey]);
                newSelectedDataItemsInChart.push(selectedState);
            }
        })); else if (datum && 0 !== datum.key && Object.keys(datum).length > 0) {
            const selectedState = {};
            for (const itemKey in datum) itemKey.startsWith("VGRAMMAR_") || itemKey.startsWith("__VCHART") || (selectedState[itemKey] = datum[itemKey]);
            newSelectedDataItemsInChart.push(selectedState);
        }
        isEqual(table._selectedDataItemsInChart, newSelectedDataItemsInChart) || (table._selectedDataItemsInChart = newSelectedDataItemsInChart, 
        table.internalProps.layoutMap.updateDataStateToChartInstance(), clearChartCacheImage(scenegraph), 
        table.scenegraph.updateNextFrame());
    }
}

function updateTableAxes(containerGroup, table) {
    containerGroup.forEachChildren((column => {
        "column" === column.role && column.forEachChildren((cell => {
            var _a;
            if ("cell" === cell.role) {
                let isAxisComponent = !1;
                if (cell.forEachChildren((mark => "axis" === mark.name && (isAxisComponent = !0, 
                !0))), isAxisComponent) {
                    const axisConfig = table.internalProps.layoutMap.getAxisConfigInPivotChart(cell.col, cell.row), cellStyle = table._getCellStyle(cell.col, cell.row), padding = getQuadProps(getProp("padding", cellStyle, cell.col, cell.row, table)), axis = new (Factory.getComponent("axis"))(axisConfig, cell.attribute.width, cell.attribute.height, null !== (_a = axisConfig.__vtablePadding) && void 0 !== _a ? _a : padding, table);
                    cell.clear(), cell.appendChild(axis.component), axis.overlap();
                }
            }
        }));
    }));
}

function updateChartGraphicSize(cellNode, width, height) {
    cellNode.forEachChildren((graphic => {
        "chart" === graphic.type && (graphic.cacheCanvas = null, graphic.setAttributes({
            width: Math.ceil(width - graphic.attribute.cellPadding[3] - graphic.attribute.cellPadding[1]),
            height: Math.ceil(height - graphic.attribute.cellPadding[0] - graphic.attribute.cellPadding[2])
        }));
    }));
}
//# sourceMappingURL=update-chart.js.map
