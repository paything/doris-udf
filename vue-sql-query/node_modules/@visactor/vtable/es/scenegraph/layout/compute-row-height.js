import { RichText } from "./../../vrender";

import { IconPosition } from "../../ts-types";

import { getProp } from "../utils/get-prop";

import { getQuadProps } from "../utils/padding";

import { dealWithRichTextIcon } from "../utils/text-icon-layout";

import { Factory } from "../../core/factory";

import { isArray, isFunction, isNumber, isValid } from "@visactor/vutils";

import { decodeReactDom, dealPercentCalc } from "../component/custom";

import { getCellMergeInfo } from "../utils/get-cell-merge";

import { getHierarchyOffset } from "../utils/get-hierarchy-offset";

import { computeButtonCellHeight, computeCheckboxCellHeight, computeRadioCellHeight, computeSwitchCellHeight } from "./height-util";

import { measureTextBounds } from "../utils/text-measure";

import { breakString } from "../utils/break-string";

import { emptyCustomLayout } from "../../components/react/react-custom-layout";

const utilRichTextMark = new RichText({
    width: 0,
    height: 0,
    textConfig: []
});

export function computeRowsHeight(table, rowStart, rowEnd, isClearRowRangeHeightsMap = !0, update) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
    "undefined" != typeof window && window.performance.now();
    const oldRowHeights = [], newHeights = [];
    if (update) for (let row = rowStart; row <= rowEnd; row++) oldRowHeights[row] = table.getRowHeight(row);
    const layoutMap = table.internalProps.layoutMap;
    table.isPivotTable() && (layoutMap.enableUseGetBodyCache(), layoutMap.enableUseHeaderPathCache()), 
    table.defaultHeaderRowHeight, table.defaultHeaderColWidth;
    const isDefaultHeaderHasAuto = "auto" === table.defaultHeaderRowHeight || isArray(table.defaultHeaderRowHeight) && table.defaultHeaderRowHeight.some((item => "auto" === item)), isAllRowsAuto = table.isAutoRowHeight(rowStart) || "adaptive" === table.heightMode && !1 !== table.options.autoHeightInAdaptiveMode, isDefaultRowHeightIsAuto = "auto" === table.options.defaultRowHeight;
    if (isAllRowsAuto || isDefaultHeaderHasAuto || isDefaultRowHeightIsAuto) {
        rowStart = null != rowStart ? rowStart : 0, rowEnd = null != rowEnd ? rowEnd : table.rowCount - 1, 
        (0 === rowStart && rowEnd === table.rowCount - 1 || isClearRowRangeHeightsMap) && table._clearRowRangeHeightsMap();
        for (let row = rowStart; row < table.columnHeaderLevelCount; row++) {
            let startCol = 0, endCol = table.colCount - 1;
            if ((table.isPivotTable() && !table.isPivotChart() || table.isPivotChart() && !table.internalProps.layoutMap.indicatorsAsCol) && checkPivotFixedStyleAndNoWrap(table, row) && !getCellMergeInfo(table, table.rowHeaderLevelCount, row) && (startCol = 0, 
            endCol = table.rowHeaderLevelCount), isAllRowsAuto || "auto" === table.getDefaultRowHeight(row)) {
                const height = computeRowHeight(row, startCol, endCol, table);
                newHeights[row] = Math.round(height), "only-body" !== table.heightAdaptiveMode && update || table._setRowHeight(row, height);
            }
        }
        for (let row = table.rowCount - table.bottomFrozenRowCount; row <= rowEnd; row++) if (isAllRowsAuto || "auto" === table.getDefaultRowHeight(row)) {
            const height = computeRowHeight(row, 0, table.colCount - 1, table);
            update ? newHeights[row] = Math.round(height) : table._setRowHeight(row, height);
        }
        if (rowEnd < table.columnHeaderLevelCount || !isAllRowsAuto && !isDefaultRowHeightIsAuto) ; else if (table.internalProps.transpose || table.isPivotTable() && !table.internalProps.layoutMap.indicatorsAsCol || table.options.customComputeRowHeight || !checkFixedStyleAndNoWrap(table, rowStart)) if (table.internalProps.transpose || table.isPivotTable() && !table.internalProps.layoutMap.indicatorsAsCol) for (let row = Math.max(rowStart, table.columnHeaderLevelCount); row <= rowEnd; row++) {
            let height;
            height = checkFixedStyleAndNoWrapForTranspose(table, row) ? computeRowHeight(row, 0, table.rowHeaderLevelCount, table) : computeRowHeight(row, 0, table.colCount - 1, table), 
            update ? newHeights[row] = Math.round(height) : table._setRowHeight(row, height);
        } else for (let row = Math.max(rowStart, table.columnHeaderLevelCount); row <= rowEnd; row++) {
            const height = computeRowHeight(row, 0, table.colCount - 1, table);
            update ? newHeights[row] = Math.round(height) : table._setRowHeight(row, height);
        } else {
            fillRowsHeight(computeRowHeight(table.columnHeaderLevelCount, 0, table.colCount - 1, table), table.columnHeaderLevelCount, table.rowCount - 1 - table.bottomFrozenRowCount, table, update ? newHeights : void 0);
            for (let row = table.rowCount - table.bottomFrozenRowCount; row <= rowEnd; row++) {
                const height = computeRowHeight(row, 0, table.colCount - 1, table);
                update ? newHeights[row] = Math.round(height) : table._setRowHeight(row, height);
            }
        }
    } else if (("adaptive" === table.heightMode || table.autoFillHeight) && table.clearRowHeightCache(), 
    update) for (let row = rowStart; row <= rowEnd; row++) newHeights[row] = table.getRowHeight(row);
    if ((0 === rowStart && rowEnd === table.rowCount - 1 || isClearRowRangeHeightsMap) && table._clearRowRangeHeightsMap(), 
    "adaptive" === table.heightMode) {
        table._clearRowRangeHeightsMap();
        let totalDrawHeight = table.tableNoFrameHeight, startRow = 0, endRow = table.rowCount;
        if ("only-body" === table.heightAdaptiveMode) {
            const columnHeaderHeight = table.getRowsHeight(0, table.columnHeaderLevelCount - 1), bottomHeaderHeight = table.isPivotChart() ? table.getBottomFrozenRowsHeight() : 0;
            totalDrawHeight = table.tableNoFrameHeight - columnHeaderHeight - bottomHeaderHeight, 
            startRow = table.columnHeaderLevelCount, endRow = table.isPivotChart() ? table.rowCount - table.bottomFrozenRowCount : table.rowCount;
        }
        let actualHeight = 0;
        for (let row = startRow; row < endRow; row++) actualHeight += update && null !== (_a = newHeights[row]) && void 0 !== _a ? _a : table.getRowHeight(row);
        const factor = totalDrawHeight / actualHeight;
        for (let row = startRow; row < endRow; row++) {
            let rowHeight;
            rowHeight = row === endRow - 1 ? totalDrawHeight - (update ? newHeights.reduce(((acr, cur, index) => index >= startRow && index <= endRow - 2 ? acr + cur : acr), 0) : table.getRowsHeight(startRow, endRow - 2)) : Math.round((update && null !== (_b = newHeights[row]) && void 0 !== _b ? _b : table.getRowHeight(row)) * factor), 
            update ? newHeights[row] = rowHeight : table._setRowHeight(row, rowHeight, !1);
        }
    } else if (table.autoFillHeight) {
        table._clearRowRangeHeightsMap();
        const canvasHeight = table.tableNoFrameHeight;
        let actualHeight = 0, actualHeaderHeight = 0;
        for (let row = 0; row < table.rowCount; row++) {
            const rowHeight = update && null !== (_c = newHeights[row]) && void 0 !== _c ? _c : table.getRowHeight(row);
            (row < table.columnHeaderLevelCount || table.isPivotChart() && row >= table.rowCount - table.bottomFrozenRowCount) && (actualHeaderHeight += rowHeight), 
            actualHeight += rowHeight;
        }
        if (table.scenegraph._dealAutoFillHeightOriginRowsHeight = actualHeight, actualHeight < canvasHeight && actualHeight - actualHeaderHeight > 0) {
            const startRow = table.columnHeaderLevelCount, endRow = table.isPivotChart() ? table.rowCount - table.bottomFrozenRowCount : table.rowCount, factor = (canvasHeight - actualHeaderHeight) / (actualHeight - actualHeaderHeight);
            for (let row = startRow; row < endRow; row++) {
                let rowHeight;
                rowHeight = row === endRow - 1 ? canvasHeight - actualHeaderHeight - (update ? newHeights.reduce(((acr, cur, index) => index >= startRow && index <= endRow - 2 ? acr + cur : acr), 0) : table.getRowsHeight(startRow, endRow - 2)) : Math.round((update && null !== (_d = newHeights[row]) && void 0 !== _d ? _d : table.getRowHeight(row)) * factor), 
                update ? newHeights[row] = rowHeight : table._setRowHeight(row, rowHeight, !1);
            }
        }
    }
    if (update) {
        for (let row = rowStart; row <= rowEnd; row++) {
            const newRowHeight = null !== (_e = newHeights[row]) && void 0 !== _e ? _e : table.getRowHeight(row);
            isValid(newRowHeight) && table._setRowHeight(row, newRowHeight);
        }
        for (let row = 0; row <= table.frozenRowCount - 1; row++) {
            const newRowHeight = table.getRowHeight(row);
            newRowHeight !== (null !== (_f = oldRowHeights[row]) && void 0 !== _f ? _f : table.getRowHeight(row)) && table.scenegraph.updateRowHeight(row, newRowHeight - (null !== (_g = oldRowHeights[row]) && void 0 !== _g ? _g : table.getRowHeight(row)), !0);
        }
        for (let row = table.rowCount - table.bottomFrozenRowCount; row <= table.rowCount - 1; row++) {
            const newRowHeight = table.getRowHeight(row);
            newRowHeight !== (null !== (_h = oldRowHeights[row]) && void 0 !== _h ? _h : table.getRowHeight(row)) && table.scenegraph.updateRowHeight(row, newRowHeight - (null !== (_j = oldRowHeights[row]) && void 0 !== _j ? _j : table.getRowHeight(row)), !0);
        }
        for (let row = table.scenegraph.proxy.rowStart; row <= table.scenegraph.proxy.rowEnd; row++) {
            const newRowHeight = table.getRowHeight(row);
            newRowHeight !== (null !== (_k = oldRowHeights[row]) && void 0 !== _k ? _k : table.getRowHeight(row)) && table.scenegraph.updateRowHeight(row, newRowHeight - (null !== (_l = oldRowHeights[row]) && void 0 !== _l ? _l : table.getRowHeight(row)), !0);
        }
    }
    table.isPivotTable() && (layoutMap.disableUseGetBodyCache(), layoutMap.disableUseHeaderPathCache());
}

export function computeRowHeight(row, startCol, endCol, table) {
    var _a;
    if (!(table.isAutoRowHeight(row) || "adaptive" === table.heightMode && !1 !== table.options.autoHeightInAdaptiveMode) && "auto" !== table.getDefaultRowHeight(row)) return table.getDefaultRowHeight(row);
    let maxHeight;
    if (table.options.customComputeRowHeight) {
        const customRowHeight = table.options.customComputeRowHeight({
            row: row,
            table: table
        });
        if ("number" == typeof customRowHeight) return customRowHeight;
        if ("auto" !== customRowHeight) return table.getDefaultRowHeight(row);
    }
    if (table.isPivotChart() && row >= table.columnHeaderLevelCount && row < table.rowCount - table.bottomFrozenRowCount) if (table.internalProps.layoutMap.indicatorsAsCol) {
        const optimunHeight = table.internalProps.layoutMap.getOptimunHeightForChart(row);
        if (optimunHeight > 0) return optimunHeight;
    } else {
        const defaultHeight = table.getDefaultRowHeight(row);
        if (isNumber(defaultHeight)) return defaultHeight;
    }
    for (let col = startCol; col <= endCol; col++) {
        const customHeight = computeCustomRenderHeight(col, row, table);
        if (customHeight && (maxHeight = isValid(maxHeight) ? Math.max(customHeight.height, maxHeight) : customHeight.height, 
        !customHeight.renderDefault)) continue;
        if (table.isPivotChart()) {
            const axisConfig = table.internalProps.layoutMap.getAxisConfigInPivotChart(col, row);
            if (axisConfig) {
                const axisWidth = Factory.getFunction("computeAxisComponentHeight")(axisConfig, table);
                if ("number" == typeof axisWidth) {
                    maxHeight = isValid(maxHeight) ? Math.max(axisWidth, maxHeight) : axisWidth;
                    continue;
                }
            }
        }
        if (table.isPivotChart() && (table.isLeftFrozenColumn(col) && table.isBottomFrozenRow(row) || table.isRightFrozenColumn(col) && table.isBottomFrozenRow(row))) continue;
        const textHeight = computeTextHeight(col, row, table.isHeader(col, row) ? null === (_a = table._getHeaderLayoutMap(col, row)) || void 0 === _a ? void 0 : _a.headerType : table.getBodyColumnType(col, row), table);
        maxHeight = isValid(maxHeight) ? Math.max(textHeight, maxHeight) : textHeight;
    }
    if (isValid(maxHeight)) return maxHeight;
    const defaultHeight = table.getDefaultRowHeight(row);
    return isNumber(defaultHeight) ? defaultHeight : table.defaultRowHeight;
}

function checkFixedStyleAndNoWrap(table, rowStart) {
    var _a, _b, _c;
    const {layoutMap: layoutMap} = table.internalProps, row = table.columnHeaderLevelCount;
    if ((table.internalProps.autoWrapText || table.internalProps.enableLineBreak || table.isPivotChart()) && (table.isAutoRowHeight(rowStart) || "adaptive" === table.options.heightMode)) return !1;
    for (let col = 0; col < table.colCount; col++) {
        const cellDefine = layoutMap.getBody(col, row);
        if ("radio" === cellDefine.cellType) return !1;
        if ("function" == typeof cellDefine.style || "function" == typeof cellDefine.icon || (null === (_a = cellDefine.define) || void 0 === _a ? void 0 : _a.customRender) || (null === (_b = cellDefine.define) || void 0 === _b ? void 0 : _b.customLayout) || "function" == typeof (null === (_c = cellDefine.define) || void 0 === _c ? void 0 : _c.icon)) return !1;
        const cellStyle = table._getCellStyle(col, row);
        if ("function" == typeof cellStyle.padding || "function" == typeof cellStyle.fontSize || "function" == typeof cellStyle.lineHeight || !0 === cellStyle.autoWrapText) return !1;
    }
    return !0;
}

function checkFixedStyleAndNoWrapForTranspose(table, row) {
    var _a, _b, _c;
    const {layoutMap: layoutMap} = table.internalProps;
    if ((table.internalProps.autoWrapText || table.internalProps.enableLineBreak) && (table.isAutoRowHeight(row) || "adaptive" === table.options.heightMode)) return !1;
    const cellDefine = layoutMap.getBody(table.rowHeaderLevelCount, row);
    if ("function" == typeof cellDefine.style || "function" == typeof cellDefine.icon || (null === (_a = cellDefine.define) || void 0 === _a ? void 0 : _a.customRender) || (null === (_b = cellDefine.define) || void 0 === _b ? void 0 : _b.customLayout) || "function" == typeof (null === (_c = cellDefine.define) || void 0 === _c ? void 0 : _c.icon)) return !1;
    const cellStyle = table._getCellStyle(table.rowHeaderLevelCount, row);
    return "function" != typeof cellStyle.padding && "function" != typeof cellStyle.fontSize && "function" != typeof cellStyle.lineHeight && !0 !== cellStyle.autoWrapText;
}

function checkPivotFixedStyleAndNoWrap(table, row) {
    var _a, _b, _c;
    const {layoutMap: layoutMap} = table.internalProps;
    if (table.internalProps.autoWrapText && (table.isAutoRowHeight(row) || "adaptive" === table.options.heightMode)) return !1;
    const headerDefine = layoutMap.getHeader(table.rowHeaderLevelCount, row);
    if ("function" == typeof headerDefine.style || "function" == typeof headerDefine.icons || (null === (_a = headerDefine.define) || void 0 === _a ? void 0 : _a.headerCustomRender) || (null === (_b = headerDefine.define) || void 0 === _b ? void 0 : _b.headerCustomLayout) || "function" == typeof (null === (_c = headerDefine.define) || void 0 === _c ? void 0 : _c.icon)) return !1;
    const headerStyle = table._getCellStyle(table.rowHeaderLevelCount, row);
    return "function" != typeof headerStyle.padding && "function" != typeof headerStyle.fontSize && "function" != typeof headerStyle.lineHeight && !0 !== headerStyle.autoWrapText;
}

function fillRowsHeight(height, startRow, endRow, table, newHeights) {
    if (!table.internalProps.useOneRowHeightFillAll) {
        for (let row = startRow; row <= endRow; row++) newHeights ? newHeights[row] = height : table._setRowHeight(row, height);
        table.internalProps.useOneRowHeightFillAll = !0;
    }
}

function computeCustomRenderHeight(col, row, table) {
    var _a, _b, _c, _d, _e, _f, _g;
    const customRender = table.getCustomRender(col, row);
    let customLayout = table.getCustomLayout(col, row);
    if (customRender || customLayout) {
        let cellRange, spanRow = 1, height = 0, renderDefault = !1, enableCellPadding = !1;
        (table.isHeader(col, row) || (null === (_a = table.getBodyColumnDefine(col, row)) || void 0 === _a ? void 0 : _a.mergeCell) || table.hasCustomMerge()) && (cellRange = table.getCellRange(col, row), 
        spanRow = cellRange.end.row - cellRange.start.row + 1);
        const arg = {
            col: null !== (_b = null == cellRange ? void 0 : cellRange.start.col) && void 0 !== _b ? _b : col,
            row: null !== (_c = null == cellRange ? void 0 : cellRange.start.row) && void 0 !== _c ? _c : row,
            dataValue: table.getCellOriginValue(col, row),
            value: table.getCellValue(col, row) || "",
            rect: getCellRect(col, row, table),
            table: table,
            originCol: col,
            originRow: row,
            forComputation: !0
        };
        if ("react-custom-layout" === customLayout && (customLayout = (null === (_d = table.reactCustomLayout) || void 0 === _d ? void 0 : _d.getCustomLayoutFunc(col, row)) || emptyCustomLayout), 
        isFunction(customLayout)) {
            const customLayoutObj = customLayout(arg);
            customLayoutObj.rootContainer ? (customLayoutObj.rootContainer = decodeReactDom(customLayoutObj.rootContainer), 
            dealPercentCalc(customLayoutObj.rootContainer, table.getColWidth(col), 0), customLayoutObj.rootContainer.setStage(table.scenegraph.stage), 
            height = null !== (_e = customLayoutObj.rootContainer.AABBBounds.height()) && void 0 !== _e ? _e : 0, 
            renderDefault = customLayoutObj.renderDefault, enableCellPadding = customLayoutObj.enableCellPadding) : (height = 0, 
            renderDefault = customLayoutObj.renderDefault, enableCellPadding = customLayoutObj.enableCellPadding);
        } else if ("function" == typeof customRender) {
            const customRenderObj = customRender(arg);
            height = null !== (_f = null == customRenderObj ? void 0 : customRenderObj.expectedHeight) && void 0 !== _f ? _f : 0, 
            renderDefault = null == customRenderObj ? void 0 : customRenderObj.renderDefault;
        } else height = null !== (_g = null == customRender ? void 0 : customRender.expectedHeight) && void 0 !== _g ? _g : 0, 
        renderDefault = null == customRender ? void 0 : customRender.renderDefault;
        if (enableCellPadding) {
            const actStyle = table._getCellStyle(col, row), padding = getQuadProps(getProp("padding", actStyle, col, row, table));
            height += padding[0] + padding[2];
        }
        return {
            height: height / spanRow,
            renderDefault: renderDefault
        };
    }
}

function computeTextHeight(col, row, cellType, table) {
    var _a, _b, _c, _d;
    let maxHeight = 0;
    const cellValue = table.getCellValue(col, row), actStyle = table._getCellStyle(col, row);
    let iconHeight = 0, iconWidth = 0;
    const iconInlineFront = [];
    let iconInlineFrontHeight = 0;
    const iconInlineEnd = [];
    let iconInlineEndHeight = 0, mayHaveIcon = !1;
    if ("body" !== table.getCellLocation(col, row)) mayHaveIcon = !0; else {
        const define = table.getBodyColumnDefine(col, row);
        mayHaveIcon = !!(null == define ? void 0 : define.icon) || !!(null == define ? void 0 : define.tree) || (null == define ? void 0 : define.dragOrder);
    }
    if (mayHaveIcon) {
        const icons = table.getCellIcons(col, row);
        null == icons || icons.forEach((icon => {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
            icon.positionType !== IconPosition.absoluteRight && icon.positionType !== IconPosition.inlineFront && icon.positionType !== IconPosition.inlineEnd ? (iconWidth += (null !== (_a = icon.width) && void 0 !== _a ? _a : 0) + (null !== (_b = icon.marginLeft) && void 0 !== _b ? _b : 0) + (null !== (_c = icon.marginRight) && void 0 !== _c ? _c : 0), 
            iconHeight = Math.max(iconHeight, null !== (_d = icon.height) && void 0 !== _d ? _d : 0)) : icon.positionType === IconPosition.inlineFront ? (iconInlineFront.push(icon), 
            iconInlineFrontHeight = Math.max(iconInlineFrontHeight, (null !== (_e = icon.height) && void 0 !== _e ? _e : 0) + (null !== (_f = icon.marginLeft) && void 0 !== _f ? _f : 0) + (null !== (_g = icon.marginRight) && void 0 !== _g ? _g : 0))) : icon.positionType === IconPosition.inlineEnd && (iconInlineEnd.push(icon), 
            iconInlineEndHeight = Math.max(iconInlineEndHeight, (null !== (_h = icon.height) && void 0 !== _h ? _h : 0) + (null !== (_j = icon.marginLeft) && void 0 !== _j ? _j : 0) + (null !== (_k = icon.marginRight) && void 0 !== _k ? _k : 0)));
        }));
    }
    let spanRow = 1, endCol = col;
    if (table.isHeader(col, row) || (null === (_a = table.getBodyColumnDefine(col, row)) || void 0 === _a ? void 0 : _a.mergeCell) || table.hasCustomMerge()) {
        const cellRange = table.getCellRange(col, row);
        spanRow = cellRange.end.row - cellRange.start.row + 1, col = cellRange.start.col, 
        endCol = cellRange.end.col;
    }
    const padding = getQuadProps(getProp("padding", actStyle, col, row, table)), fontSize = getProp("fontSize", actStyle, col, row, table), fontStyle = getProp("fontStyle", actStyle, col, row, table), fontWeight = getProp("fontWeight", actStyle, col, row, table), lineHeight = null !== (_b = getProp("lineHeight", actStyle, col, row, table)) && void 0 !== _b ? _b : fontSize, fontFamily = getProp("fontFamily", actStyle, col, row, table), autoWrapText = getProp("autoWrapText", actStyle, col, row, table), lineClamp = getProp("lineClamp", actStyle, col, row, table), underline = getProp("underline", actStyle, col, row, table), underlineOffset = null !== (_c = getProp("underlineOffset", actStyle, col, row, table)) && void 0 !== _c ? _c : 0;
    let text;
    if ("text" !== cellType && "link" !== cellType && "progressbar" !== cellType && "checkbox" !== cellType && "radio" !== cellType && "switch" !== cellType && "button" !== cellType) maxHeight = lineHeight; else if ("checkbox" === cellType) maxHeight = computeCheckboxCellHeight(cellValue, col, row, endCol, actStyle, autoWrapText, iconWidth, fontSize, fontStyle, fontWeight, fontFamily, lineHeight, lineClamp, padding, table); else if ("radio" === cellType) maxHeight = computeRadioCellHeight(cellValue, col, row, endCol, actStyle, autoWrapText, iconWidth, fontSize, fontStyle, fontWeight, fontFamily, lineHeight, lineClamp, padding, table); else if ("switch" === cellType) maxHeight = computeSwitchCellHeight(cellValue, col, row, endCol, actStyle, autoWrapText, iconWidth, fontSize, fontStyle, fontWeight, fontFamily, lineHeight, lineClamp, padding, table); else if ("button" === cellType) maxHeight = computeButtonCellHeight(cellValue, col, row, endCol, actStyle, autoWrapText, iconWidth, fontSize, fontStyle, fontWeight, fontFamily, lineHeight, lineClamp, padding, table); else {
        text = cellValue;
        const lines = breakString(text, table).text, cellWidth = table.getColsWidth(col, endCol);
        if (iconInlineFront.length || iconInlineEnd.length) if (autoWrapText) {
            const textOption = Object.assign({
                text: null == cellValue ? void 0 : cellValue.toString(),
                fontFamily: fontFamily,
                fontSize: fontSize,
                fontStyle: fontStyle,
                fontWeight: fontWeight,
                lineHeight: lineHeight
            });
            textOption.textBaseline = "middle";
            const textConfig = [ ...iconInlineFront.map((icon => dealWithRichTextIcon(icon))), textOption, ...iconInlineEnd.map((icon => dealWithRichTextIcon(icon))) ];
            utilRichTextMark.setAttributes({
                width: cellWidth - (padding[1] + padding[3]) - iconWidth,
                height: 0,
                textConfig: textConfig
            }), maxHeight = utilRichTextMark.AABBBounds.height();
        } else maxHeight = 0, lines.forEach(((line, index) => {
            var _a;
            (null === (_a = table.options.customConfig) || void 0 === _a ? void 0 : _a.multilinesForXTable) && 0 !== index || (0 === index && iconInlineFront.length ? maxHeight += Math.max(lineHeight, iconInlineFrontHeight) : index === lines.length - 1 && iconInlineEnd.length ? maxHeight += Math.max(lineHeight, iconInlineEndHeight) : maxHeight += lineHeight);
        })); else if (autoWrapText) {
            const hierarchyOffset = getHierarchyOffset(col, row, table), maxLineWidth = cellWidth - (padding[1] + padding[3]) - iconWidth - hierarchyOffset, bounds = measureTextBounds({
                maxLineWidth: maxLineWidth,
                text: lines,
                fontSize: fontSize,
                fontStyle: fontStyle,
                fontWeight: fontWeight,
                fontFamily: fontFamily,
                lineHeight: lineHeight,
                wordBreak: "break-word",
                whiteSpace: 1 !== lines.length || autoWrapText ? "normal" : "no-wrap",
                lineClamp: lineClamp
            });
            maxHeight = (bounds.height() || ("number" == typeof lineHeight ? lineHeight : fontSize)) + (underline ? underlineOffset : 0);
        } else maxHeight = (null === (_d = table.options.customConfig) || void 0 === _d ? void 0 : _d.multilinesForXTable) ? lineHeight : lines.length * lineHeight;
    }
    return (Math.max(maxHeight, iconHeight) + padding[0] + padding[2]) / spanRow;
}

function getCellRect(col, row, table) {
    return {
        left: 0,
        top: 0,
        right: table.getColWidth(col),
        bottom: table.getRowHeight(row),
        width: table.getColWidth(col),
        height: 0
    };
}
//# sourceMappingURL=compute-row-height.js.map
