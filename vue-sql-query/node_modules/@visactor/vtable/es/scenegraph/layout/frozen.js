import { getStyleTheme } from "../../core/tableHelper";

import { Group } from "../graphic/group";

import { createColGroup } from "../group-creater/column";

import { getProp } from "../utils/get-prop";

import { updateReactComponentContainer } from "./frozen-react";

export function dealFrozen(scene) {
    var _a, _b, _c, _d;
    if (scene.table.frozenColCount > scene.table.rowHeaderLevelCount) {
        scene.rowHeaderGroup.setAttribute("height", scene.bodyGroup.attribute.height), scene.rowHeaderGroup.setAttribute("y", scene.bodyGroup.attribute.y), 
        scene.cornerHeaderGroup.setAttribute("height", scene.colHeaderGroup.attribute.height);
        for (let i = 0; i < scene.table.frozenColCount - scene.table.rowHeaderLevelCount; i++) moveColumnFromBodyToRowHeader(scene), 
        moveColumnFromColHeaderToCornerHeader(scene), moveColumnFromBottomToLeftBottomCorner(scene);
    } else if (scene.table.frozenColCount < scene.table.rowHeaderLevelCount) {
        scene.bodyGroup.setAttribute("height", scene.rowHeaderGroup.attribute.height), scene.bodyGroup.setAttribute("y", scene.rowHeaderGroup.attribute.y), 
        scene.colHeaderGroup.setAttribute("height", scene.cornerHeaderGroup.attribute.height);
        for (let i = 0; i < scene.table.rowHeaderLevelCount - scene.table.frozenColCount; i++) moveColumnFromRowHeaderToBody(scene), 
        moveColumnFromCornerHeaderToColHeader(scene), moveColumnFromLeftBottomCornerToBottom(scene);
    }
    scene.bodyGroup.setAttribute("x", scene.rowHeaderGroup.attribute.width), scene.colHeaderGroup.setAttribute("x", scene.cornerHeaderGroup.attribute.width), 
    scene.updateContainer(), scene.updateBorderSizeAndPosition(), scene.isPivot || scene.table.transpose ? scene.table.options.frozenColCount ? scene.component.setFrozenColumnShadow(scene.table.frozenColCount - 1) : scene.table.options.frozenColCount && scene.component.setRightFrozenColumnShadow(scene.table.colCount - scene.table.rightFrozenColCount) : (scene.component.setFrozenColumnShadow(scene.table.frozenColCount - 1), 
    scene.component.setRightFrozenColumnShadow(scene.table.colCount - scene.table.rightFrozenColCount)), 
    scene.hasFrozen = !0, scene.frozenColCount = scene.table.frozenColCount, scene.frozenRowCount = null !== (_d = null !== (_b = null === (_a = scene.colHeaderGroup.firstChild) || void 0 === _a ? void 0 : _a.childrenCount) && void 0 !== _b ? _b : null === (_c = scene.cornerHeaderGroup.firstChild) || void 0 === _c ? void 0 : _c.childrenCount) && void 0 !== _d ? _d : scene.table.frozenRowCount;
}

export function resetFrozen(scene) {
    var _a, _b, _c, _d, _e, _f;
    if (scene.frozenColCount > scene.table.frozenColCount) {
        scene.bodyGroup.setAttribute("height", scene.rowHeaderGroup.attribute.height), scene.bodyGroup.setAttribute("y", scene.rowHeaderGroup.attribute.y), 
        scene.colHeaderGroup.setAttribute("height", scene.cornerHeaderGroup.attribute.height);
        for (let i = 0; i < scene.frozenColCount - scene.table.frozenColCount; i++) moveColumnFromRowHeaderToBody(scene), 
        moveColumnFromCornerHeaderToColHeader(scene), moveColumnFromLeftBottomCornerToBottom(scene);
    } else if (scene.frozenColCount < scene.table.frozenColCount) {
        scene.rowHeaderGroup.setAttribute("height", scene.bodyGroup.attribute.height), scene.rowHeaderGroup.setAttribute("y", scene.bodyGroup.attribute.y), 
        scene.cornerHeaderGroup.setAttribute("height", scene.colHeaderGroup.attribute.height);
        for (let i = 0; i < scene.table.frozenColCount - scene.frozenColCount; i++) moveColumnFromBodyToRowHeader(scene), 
        moveColumnFromColHeaderToCornerHeader(scene), moveColumnFromBottomToLeftBottomCorner(scene);
    }
    updateReactComponentContainer(scene), scene.recreateAllSelectRangeComponents(), 
    scene.frozenColCount = scene.table.frozenColCount, scene.frozenRowCount = null !== (_d = null !== (_b = null === (_a = scene.colHeaderGroup.firstChild) || void 0 === _a ? void 0 : _a.childrenCount) && void 0 !== _b ? _b : null === (_c = scene.cornerHeaderGroup.firstChild) || void 0 === _c ? void 0 : _c.childrenCount) && void 0 !== _d ? _d : scene.table.frozenRowCount, 
    scene.proxy.colStart = null !== (_f = null === (_e = scene.bodyGroup.firstChild) || void 0 === _e ? void 0 : _e.col) && void 0 !== _f ? _f : scene.table.frozenColCount, 
    scene.bodyGroup.setAttribute("x", scene.rowHeaderGroup.attribute.width), scene.colHeaderGroup.setAttribute("x", scene.cornerHeaderGroup.attribute.width), 
    scene.updateContainer(), scene.updateBorderSizeAndPosition(), scene.isPivot || scene.table.transpose ? scene.table.options.frozenColCount ? scene.component.setFrozenColumnShadow(scene.table.frozenColCount - 1) : scene.table.options.rightFrozenColCount && scene.component.setRightFrozenColumnShadow(scene.table.colCount - scene.table.rightFrozenColCount) : (scene.component.setFrozenColumnShadow(scene.table.frozenColCount - 1), 
    scene.component.setRightFrozenColumnShadow(scene.table.colCount - scene.table.rightFrozenColCount)), 
    scene.hasFrozen = !0;
}

function moveColumnFromBodyToRowHeader(scene) {
    const column = scene.bodyGroup.firstChild instanceof Group ? scene.bodyGroup.firstChild : null;
    column && (scene.rowHeaderGroup.appendChild(column), scene.rowHeaderGroup.setAttribute("width", scene.rowHeaderGroup.attribute.width + column.attribute.width), 
    scene.bodyGroup.setAttribute("width", scene.bodyGroup.attribute.width - column.attribute.width));
}

function moveColumnFromColHeaderToCornerHeader(scene) {
    const headerColumn = scene.colHeaderGroup.firstChild instanceof Group ? scene.colHeaderGroup.firstChild : null;
    headerColumn && (scene.cornerHeaderGroup.appendChild(headerColumn), scene.cornerHeaderGroup.setAttribute("width", scene.cornerHeaderGroup.attribute.width + headerColumn.attribute.width), 
    scene.colHeaderGroup.setAttribute("width", scene.colHeaderGroup.attribute.width - headerColumn.attribute.width));
}

function moveColumnFromRowHeaderToBody(scene) {
    var _a;
    const column = scene.rowHeaderGroup.lastChild instanceof Group ? scene.rowHeaderGroup.lastChild : null === (_a = scene.rowHeaderGroup.lastChild) || void 0 === _a ? void 0 : _a._prev;
    column && (insertBefore(scene.bodyGroup, column, scene.bodyGroup.firstChild), scene.bodyGroup.setAttribute("width", scene.bodyGroup.attribute.width + column.attribute.width), 
    scene.rowHeaderGroup.setAttribute("width", scene.rowHeaderGroup.attribute.width - column.attribute.width));
}

function moveColumnFromCornerHeaderToColHeader(scene) {
    var _a;
    const headerColumn = scene.cornerHeaderGroup.lastChild instanceof Group ? scene.cornerHeaderGroup.lastChild : null === (_a = scene.cornerHeaderGroup.lastChild) || void 0 === _a ? void 0 : _a._prev;
    headerColumn && (insertBefore(scene.colHeaderGroup, headerColumn, scene.colHeaderGroup.firstChild), 
    scene.colHeaderGroup.setAttribute("width", scene.colHeaderGroup.attribute.width + headerColumn.attribute.width), 
    scene.cornerHeaderGroup.setAttribute("width", scene.cornerHeaderGroup.attribute.width - headerColumn.attribute.width));
}

function moveColumnFromBottomToLeftBottomCorner(scene) {
    const column = scene.bottomFrozenGroup.firstChild instanceof Group ? scene.bottomFrozenGroup.firstChild : null;
    column && (scene.leftBottomCornerGroup.appendChild(column), scene.leftBottomCornerGroup.setAttribute("width", scene.leftBottomCornerGroup.attribute.width + column.attribute.width), 
    scene.bottomFrozenGroup.setAttribute("width", scene.bottomFrozenGroup.attribute.width - column.attribute.width), 
    scene.table.isPivotChart() && column.forEachChildren((child => {
        child.setAttributes({
            stroke: !1,
            fill: !1
        });
    })));
}

function moveColumnFromLeftBottomCornerToBottom(scene) {
    var _a;
    const column = scene.leftBottomCornerGroup.lastChild instanceof Group ? scene.leftBottomCornerGroup.lastChild : null === (_a = scene.leftBottomCornerGroup.lastChild) || void 0 === _a ? void 0 : _a._prev;
    column && (insertBefore(scene.bottomFrozenGroup, column, scene.bottomFrozenGroup.firstChild), 
    scene.bottomFrozenGroup.setAttribute("width", scene.bottomFrozenGroup.attribute.width + column.attribute.width), 
    scene.leftBottomCornerGroup.setAttribute("width", scene.leftBottomCornerGroup.attribute.width - column.attribute.width), 
    scene.table.isPivotChart() && column.forEachChildren((child => {
        var _a, _b, _c, _d;
        const cellStyle = scene.table._getCellStyle(child.col, child.row), range = scene.table.getCellRange(child.col, child.row), cellTheme = getStyleTheme(cellStyle, scene.table, range ? range.start.col : child.col, range ? range.start.row : child.row, getProp).theme;
        child.setAttributes({
            fill: null !== (_b = null === (_a = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _a ? void 0 : _a.fill) && void 0 !== _b ? _b : void 0,
            stroke: null !== (_d = null === (_c = null == cellTheme ? void 0 : cellTheme.group) || void 0 === _c ? void 0 : _c.stroke) && void 0 !== _d ? _d : void 0
        });
    })));
}

export function dealRightFrozen(distRightFrozenCol, scene) {
    const {table: table, proxy: proxy, rightTopCornerGroup: rightTopCornerGroup, rightFrozenGroup: rightFrozenGroup, rightBottomCornerGroup: rightBottomCornerGroup, bottomFrozenGroup: bottomFrozenGroup, bodyGroup: bodyGroup, colHeaderGroup: colHeaderGroup} = scene, currentRightFrozenCol = scene.table.rightFrozenColCount;
    if (distRightFrozenCol > currentRightFrozenCol) {
        for (let col = table.colCount - currentRightFrozenCol - 1; col >= table.colCount - distRightFrozenCol; col--) {
            insertBefore(rightFrozenGroup, scene.getColGroup(col), rightFrozenGroup.firstChild);
            insertBefore(rightTopCornerGroup, scene.getColGroup(col, !0), rightTopCornerGroup.firstChild);
            insertBefore(rightBottomCornerGroup, scene.getColGroupInBottom(col), rightBottomCornerGroup.firstChild);
        }
        let x = 0;
        rightFrozenGroup.forEachChildren((columnGroup => {
            columnGroup.setAttribute("x", x), x += columnGroup.attribute.width;
        })), x = 0, rightTopCornerGroup.forEachChildren((columnGroup => {
            columnGroup.setAttribute("x", x), x += columnGroup.attribute.width;
        })), x = 0, rightBottomCornerGroup.forEachChildren((columnGroup => {
            columnGroup.setAttribute("x", x), x += columnGroup.attribute.width;
        }));
    } else if (distRightFrozenCol < currentRightFrozenCol) {
        for (let col = table.colCount - currentRightFrozenCol; col < table.colCount - distRightFrozenCol; col++) {
            const colGroup = scene.getColGroup(col);
            colGroup.setAttribute("x", bodyGroup.lastChild.attribute.x + table.getColWidth(bodyGroup.lastChild.col)), 
            bodyGroup.appendChild(colGroup);
            const headerColGroup = scene.getColGroupInRightTopCorner(col);
            headerColGroup.setAttribute("x", colHeaderGroup.lastChild.attribute.x + table.getColWidth(colHeaderGroup.lastChild.col)), 
            colHeaderGroup.appendChild(headerColGroup);
            const bottomColGroup = scene.getColGroupInRightBottomCorner(col);
            bottomColGroup.setAttribute("x", bottomFrozenGroup.lastChild.attribute.x + table.getColWidth(bottomFrozenGroup.lastChild.col)), 
            bottomFrozenGroup.appendChild(bottomColGroup);
        }
        let x = 0;
        rightFrozenGroup.forEachChildren((columnGroup => {
            columnGroup.setAttribute("x", x), x += columnGroup.attribute.width;
        })), x = 0, rightTopCornerGroup.forEachChildren((columnGroup => {
            columnGroup.setAttribute("x", x), x += columnGroup.attribute.width;
        })), x = 0, rightBottomCornerGroup.forEachChildren((columnGroup => {
            columnGroup.setAttribute("x", x), x += columnGroup.attribute.width;
        }));
    }
    rightFrozenGroup.setAttribute("width", table.getColsWidth(table.colCount - distRightFrozenCol, table.colCount - 1)), 
    rightTopCornerGroup.setAttribute("width", table.getColsWidth(table.colCount - distRightFrozenCol, table.colCount - 1)), 
    rightBottomCornerGroup.setAttribute("width", table.getColsWidth(table.colCount - distRightFrozenCol, table.colCount - 1)), 
    table.internalProps.rightFrozenColCount = distRightFrozenCol, scene.updateContainer(), 
    scene.component.updateScrollBar(), scene.updateNextFrame();
}

export function dealBottomFrozen(distBottomFrozenRow, scene) {
    const {table: table, proxy: proxy, bottomFrozenGroup: bottomFrozenGroup, leftBottomCornerGroup: leftBottomCornerGroup, rightBottomCornerGroup: rightBottomCornerGroup} = scene;
    bottomFrozenGroup.childrenCount || (proxy.table.isPivotChart() || (createColGroup(leftBottomCornerGroup, 0, 0, 0, table.frozenColCount - 1, 0, -1, "rowHeader", table), 
    createColGroup(rightBottomCornerGroup, 0, 0, table.colCount - table.rightFrozenColCount, table.colCount - 1, 0, -1, "body", table)), 
    createColGroup(bottomFrozenGroup, 0, 0, proxy.colStart, proxy.colEnd, 0, -1, "body", table));
    const currentBottomFrozenRow = scene.table.bottomFrozenRowCount;
    if (distBottomFrozenRow > currentBottomFrozenRow) {
        for (let col = 0; col < table.frozenColCount; col++) {
            const bottomFrozenColumnGroup = scene.getColGroupInLeftBottomCorner(col);
            for (let row = table.rowCount - currentBottomFrozenRow - 1; row >= table.rowCount - distBottomFrozenRow; row--) {
                insertBefore(bottomFrozenColumnGroup, scene.getCell(col, row, !0), bottomFrozenColumnGroup.firstChild);
            }
            let y = 0;
            bottomFrozenColumnGroup.forEachChildren((cellGroup => {
                cellGroup.setAttribute("y", y), y += table.getRowHeight(cellGroup.row);
            }));
        }
        for (let col = proxy.colStart; col <= proxy.colEnd; col++) {
            const bottomFrozenColumnGroup = scene.getColGroupInBottom(col);
            for (let row = table.rowCount - currentBottomFrozenRow - 1; row >= table.rowCount - distBottomFrozenRow; row--) {
                insertBefore(bottomFrozenColumnGroup, scene.getCell(col, row, !0), bottomFrozenColumnGroup.firstChild);
            }
            let y = 0;
            bottomFrozenColumnGroup.forEachChildren((cellGroup => {
                cellGroup.setAttribute("y", y), y += table.getRowHeight(cellGroup.row);
            }));
        }
        if (table.rightFrozenColCount > 0) for (let col = table.colCount - table.rightFrozenColCount; col < table.colCount; col++) {
            const bottomFrozenColumnGroup = scene.getColGroupInRightBottomCorner(col);
            for (let row = table.rowCount - currentBottomFrozenRow - 1; row >= table.rowCount - distBottomFrozenRow; row--) {
                insertBefore(bottomFrozenColumnGroup, scene.getCell(col, row, !0), bottomFrozenColumnGroup.firstChild);
            }
            let y = 0;
            bottomFrozenColumnGroup.forEachChildren((cellGroup => {
                cellGroup.setAttribute("y", y), y += table.getRowHeight(cellGroup.row);
            }));
        }
    } else if (distBottomFrozenRow < currentBottomFrozenRow) {
        for (let col = 0; col < table.rowHeaderLevelCount; col++) {
            const columnGroup = scene.getColGroup(col);
            for (let row = table.rowCount - currentBottomFrozenRow; row < table.rowCount - distBottomFrozenRow; row++) {
                const cellGroup = scene.getCell(col, row, !0);
                cellGroup.setAttribute("y", columnGroup.lastChild.attribute.y + table.getRowHeight(columnGroup.lastChild.row)), 
                columnGroup.appendChild(cellGroup);
            }
            const bottomFrozenColumnGroup = scene.getColGroupInLeftBottomCorner(col);
            let y = 0;
            bottomFrozenColumnGroup.forEachChildren((cellGroup => {
                cellGroup.setAttribute("y", y), y += table.getRowHeight(cellGroup.row);
            }));
        }
        for (let col = proxy.colStart; col <= proxy.colEnd; col++) {
            const columnGroup = scene.getColGroup(col);
            for (let row = table.rowCount - currentBottomFrozenRow; row < table.rowCount - distBottomFrozenRow; row++) {
                const cellGroup = scene.getCell(col, row, !0);
                cellGroup.setAttribute("y", columnGroup.lastChild.attribute.y + table.getRowHeight(columnGroup.lastChild.row)), 
                columnGroup.appendChild(cellGroup);
            }
            const bottomFrozenColumnGroup = scene.getColGroupInBottom(col);
            let y = 0;
            bottomFrozenColumnGroup.forEachChildren((cellGroup => {
                cellGroup.setAttribute("y", y), y += table.getRowHeight(cellGroup.row);
            }));
        }
        if (table.rightFrozenColCount > 0) for (let col = table.colCount - table.rightFrozenColCount; col < table.colCount; col++) {
            const columnGroup = scene.getColGroup(col);
            for (let row = table.rowCount - currentBottomFrozenRow; row < table.rowCount - distBottomFrozenRow; row++) {
                const cellGroup = scene.getCell(col, row, !0);
                cellGroup.setAttribute("y", columnGroup.lastChild.attribute.y + table.getRowHeight(columnGroup.lastChild.row)), 
                columnGroup.appendChild(cellGroup);
            }
            const bottomFrozenColumnGroup = scene.getColGroupInRightBottomCorner(col);
            let y = 0;
            bottomFrozenColumnGroup.forEachChildren((cellGroup => {
                cellGroup.setAttribute("y", y), y += table.getRowHeight(cellGroup.row);
            }));
        }
    }
    bottomFrozenGroup.setAttribute("height", table.getRowsHeight(table.rowCount - distBottomFrozenRow, table.rowCount - 1)), 
    leftBottomCornerGroup.setAttribute("height", table.getRowsHeight(table.rowCount - distBottomFrozenRow, table.rowCount - 1)), 
    rightBottomCornerGroup.setAttribute("height", table.getRowsHeight(table.rowCount - distBottomFrozenRow, table.rowCount - 1)), 
    table.internalProps.bottomFrozenRowCount = distBottomFrozenRow, scene.updateContainer(), 
    scene.component.updateScrollBar(), scene.updateNextFrame();
}

function insertBefore(container, newNode, targetGroup) {
    newNode && container && (targetGroup ? container.insertBefore(newNode, targetGroup) : container.appendChild(newNode));
}

export function resetRowFrozen(scene) {
    var _a, _b, _c, _d, _e;
    if (scene.frozenRowCount > scene.table.frozenRowCount) {
        scene.bodyGroup.setAttribute("width", scene.colHeaderGroup.attribute.width), scene.bodyGroup.setAttribute("x", scene.colHeaderGroup.attribute.x), 
        scene.rowHeaderGroup.setAttribute("width", scene.cornerHeaderGroup.attribute.width);
        for (let i = 0; i < scene.frozenRowCount - scene.table.frozenRowCount; i++) moveRowFromColHeaderToBody(scene), 
        moveRowFromCornerHeaderToRowHeader(scene), moveRowFromTopRightCornerToRight(scene);
    } else if (scene.frozenRowCount < scene.table.frozenRowCount) {
        scene.colHeaderGroup.setAttribute("width", scene.bodyGroup.attribute.width), scene.colHeaderGroup.setAttribute("x", scene.bodyGroup.attribute.x), 
        scene.cornerHeaderGroup.setAttribute("width", scene.rowHeaderGroup.attribute.width);
        for (let i = 0; i < scene.table.frozenRowCount - scene.frozenRowCount; i++) moveRowFromBodyToColHeader(scene), 
        moveRowFromRowHeaderToCornerHeader(scene), moveRowFromRightToTopRightCorner(scene);
    }
    updateReactComponentContainer(scene), scene.recreateAllSelectRangeComponents(), 
    scene.frozenRowCount = scene.table.frozenRowCount, scene.frozenColCount = null !== (_b = null === (_a = scene.rowHeaderGroup) || void 0 === _a ? void 0 : _a.childrenCount) && void 0 !== _b ? _b : 0, 
    scene.proxy.rowStart = null !== (_e = null === (_d = null === (_c = scene.bodyGroup.firstChild) || void 0 === _c ? void 0 : _c.firstChild) || void 0 === _d ? void 0 : _d.row) && void 0 !== _e ? _e : scene.table.frozenRowCount, 
    scene.bodyGroup.setAttribute("y", scene.colHeaderGroup.attribute.height), scene.rowHeaderGroup.setAttribute("y", scene.cornerHeaderGroup.attribute.height), 
    scene.updateContainer(), scene.updateBorderSizeAndPosition(), scene.hasFrozen = !0;
}

function moveRowFromBodyToColHeader(scene) {
    var _a;
    let hasSetedHeight = !1;
    for (let i = 0; i < scene.bodyGroup.childrenCount; i++) {
        const child = scene.bodyGroup.children[i];
        if (!checkBeforeMove(child)) continue;
        const rowCell = child.firstChild;
        null === (_a = scene.colHeaderGroup.children[i]) || void 0 === _a || _a.appendChild(rowCell), 
        hasSetedHeight || (scene.colHeaderGroup.setAttribute("height", scene.colHeaderGroup.attribute.height + rowCell.attribute.height), 
        scene.bodyGroup.setAttribute("height", scene.bodyGroup.attribute.height - rowCell.attribute.height), 
        hasSetedHeight = !0);
    }
}

function moveRowFromRowHeaderToCornerHeader(scene) {
    var _a;
    let hasSetedHeight = !1;
    for (let i = 0; i < scene.rowHeaderGroup.childrenCount; i++) {
        const child = scene.rowHeaderGroup.children[i];
        if (!checkBeforeMove(child)) continue;
        const rowCell = child.firstChild;
        null === (_a = scene.cornerHeaderGroup.children[i]) || void 0 === _a || _a.appendChild(rowCell), 
        hasSetedHeight || (scene.cornerHeaderGroup.setAttribute("height", scene.cornerHeaderGroup.attribute.height + rowCell.attribute.height), 
        scene.rowHeaderGroup.setAttribute("height", scene.rowHeaderGroup.attribute.height - rowCell.attribute.height), 
        hasSetedHeight = !0);
    }
}

function moveRowFromRightToTopRightCorner(scene) {
    var _a;
    let hasSetedHeight = !1;
    for (let i = 0; i < scene.rightFrozenGroup.childrenCount; i++) {
        const child = scene.rightFrozenGroup.children[i];
        if (!checkBeforeMove(child)) continue;
        const rowCell = child.firstChild;
        null === (_a = scene.rightTopCornerGroup.children[i]) || void 0 === _a || _a.appendChild(rowCell), 
        hasSetedHeight || (scene.rightTopCornerGroup.setAttribute("height", scene.rightTopCornerGroup.attribute.height + rowCell.attribute.height), 
        scene.rightFrozenGroup.setAttribute("height", scene.rightFrozenGroup.attribute.height - rowCell.attribute.height), 
        hasSetedHeight = !0);
    }
}

function moveRowFromColHeaderToBody(scene) {
    let hasSetedHeight = !1;
    for (let i = 0; i < scene.colHeaderGroup.childrenCount; i++) {
        const child = scene.colHeaderGroup.children[i];
        if (!checkBeforeMove(child)) continue;
        const target = scene.bodyGroup.children[i];
        if (!target) continue;
        const rowCell = child.lastChild;
        insertBefore(target, rowCell, target.firstChild), hasSetedHeight || (scene.colHeaderGroup.setAttribute("height", scene.colHeaderGroup.attribute.height - rowCell.attribute.height), 
        scene.bodyGroup.setAttribute("height", scene.bodyGroup.attribute.height + rowCell.attribute.height), 
        hasSetedHeight = !0);
    }
}

function moveRowFromCornerHeaderToRowHeader(scene) {
    let hasSetedHeight = !1;
    for (let i = 0; i < scene.cornerHeaderGroup.childrenCount; i++) {
        const child = scene.cornerHeaderGroup.children[i];
        if (!checkBeforeMove(child)) continue;
        const target = scene.rowHeaderGroup.children[i];
        if (!target) continue;
        const rowCell = child.lastChild;
        insertBefore(target, rowCell, target.firstChild), hasSetedHeight || (scene.cornerHeaderGroup.setAttribute("height", scene.cornerHeaderGroup.attribute.height - rowCell.attribute.height), 
        scene.rowHeaderGroup.setAttribute("height", scene.rowHeaderGroup.attribute.height + rowCell.attribute.height), 
        hasSetedHeight = !0);
    }
}

function moveRowFromTopRightCornerToRight(scene) {
    let hasSetedHeight = !1;
    for (let i = 0; i < scene.rightTopCornerGroup.childrenCount; i++) {
        const child = scene.rightTopCornerGroup.children[i];
        if (!checkBeforeMove(child)) continue;
        const target = scene.rightFrozenGroup.children[i];
        if (!target) continue;
        const rowCell = child.lastChild;
        insertBefore(target, rowCell, target.firstChild), hasSetedHeight || (scene.rightTopCornerGroup.setAttribute("height", scene.rightTopCornerGroup.attribute.height - rowCell.attribute.height), 
        scene.rightFrozenGroup.setAttribute("height", scene.rightFrozenGroup.attribute.height + rowCell.attribute.height), 
        hasSetedHeight = !0);
    }
}

function checkBeforeMove(child) {
    return child instanceof Group && "table-border-rect" !== (null == child ? void 0 : child.name);
}
//# sourceMappingURL=frozen.js.map
