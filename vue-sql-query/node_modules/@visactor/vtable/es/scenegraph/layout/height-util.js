import { isArray, isNumber, isObject } from "@visactor/vutils";

import { validToString } from "../../tools/util";

import { getProp } from "../utils/get-prop";

import { CheckBox, Radio, Tag } from "./../../vrender";

const utilCheckBoxMark = new CheckBox({}), utilRadioMark = new Radio({}), utilButtonMark = new Tag({});

export function computeCheckboxCellHeight(cellValue, col, row, endCol, actStyle, autoWrapText, iconWidth, fontSize, fontStyle, fontWeight, fontFamily, lineHeight, lineClamp, padding, table) {
    const text = isObject(cellValue) ? cellValue.text : cellValue, lines = validToString(text).split("\n") || [], cellWidth = table.getColsWidth(col, endCol), size = getProp("size", actStyle, col, row, table);
    let maxHeight = 0;
    if (autoWrapText) {
        const spaceBetweenTextAndIcon = getProp("spaceBetweenTextAndIcon", actStyle, col, row, table), maxLineWidth = cellWidth - (padding[1] + padding[3]) - iconWidth - size - spaceBetweenTextAndIcon;
        utilCheckBoxMark.setAttributes({
            text: {
                maxLineWidth: maxLineWidth,
                text: lines,
                fontSize: fontSize,
                fontStyle: fontStyle,
                fontWeight: fontWeight,
                fontFamily: fontFamily,
                lineHeight: lineHeight,
                wordBreak: "break-word",
                lineClamp: lineClamp
            },
            icon: {
                width: Math.floor(size / 1.4),
                height: Math.floor(size / 1.4)
            },
            box: {
                width: size,
                height: size
            },
            spaceBetweenTextAndIcon: spaceBetweenTextAndIcon
        }), utilCheckBoxMark.render(), maxHeight = utilCheckBoxMark.AABBBounds.height();
    } else maxHeight = Math.max(size, lines.length * lineHeight);
    return maxHeight;
}

export function computeRadioCellHeight(cellValue, col, row, endCol, actStyle, autoWrapText, iconWidth, fontSize, fontStyle, fontWeight, fontFamily, lineHeight, lineClamp, padding, table) {
    var _a;
    if (isArray(cellValue)) {
        let maxHeight = 0;
        const define = table.getBodyColumnDefine(col, row), spaceBetweenRadio = getProp("spaceBetweenRadio", actStyle, col, row, table), radioDirectionInCell = null !== (_a = null == define ? void 0 : define.radioDirectionInCell) && void 0 !== _a ? _a : "vertical";
        return "vertical" === radioDirectionInCell ? cellValue.forEach(((singleValue, index) => {
            const height = computeSingleRadioCellHeight(singleValue, col, row, endCol, actStyle, autoWrapText, iconWidth, fontSize, fontStyle, fontWeight, fontFamily, lineHeight, lineClamp, padding, table);
            maxHeight += height, index !== cellValue.length - 1 && (maxHeight += spaceBetweenRadio);
        })) : "horizontal" === radioDirectionInCell && cellValue.forEach((singleValue => {
            const height = computeSingleRadioCellHeight(singleValue, col, row, endCol, actStyle, autoWrapText, iconWidth, fontSize, fontStyle, fontWeight, fontFamily, lineHeight, lineClamp, padding, table);
            maxHeight = Math.max(height, maxHeight);
        })), maxHeight;
    }
    return computeSingleRadioCellHeight(cellValue, col, row, endCol, actStyle, autoWrapText, iconWidth, fontSize, fontStyle, fontWeight, fontFamily, lineHeight, lineClamp, padding, table);
}

export function computeSingleRadioCellHeight(cellValue, col, row, endCol, actStyle, autoWrapText, iconWidth, fontSize, fontStyle, fontWeight, fontFamily, lineHeight, lineClamp, padding, table) {
    const text = isObject(cellValue) ? cellValue.text : cellValue, lines = validToString(text).split("\n") || [], cellWidth = table.getColsWidth(col, endCol), size = getProp("size", actStyle, col, row, table);
    let outerRadius = getProp("outerRadius", actStyle, col, row, table);
    const circleSize = isNumber(outerRadius) ? 2 * outerRadius : size;
    let maxHeight = 0;
    if (autoWrapText) {
        const spaceBetweenTextAndIcon = getProp("spaceBetweenTextAndIcon", actStyle, col, row, table), maxLineWidth = cellWidth - (padding[1] + padding[3]) - iconWidth - circleSize - spaceBetweenTextAndIcon;
        isNumber(outerRadius) || (outerRadius = Math.round(size / 2)), utilRadioMark.setAttributes({
            text: {
                maxLineWidth: maxLineWidth,
                text: lines,
                fontSize: fontSize,
                fontStyle: fontStyle,
                fontWeight: fontWeight,
                fontFamily: fontFamily,
                lineHeight: lineHeight,
                wordBreak: "break-word",
                lineClamp: lineClamp
            },
            circle: {
                outerRadius: outerRadius
            },
            spaceBetweenTextAndIcon: spaceBetweenTextAndIcon
        }), utilRadioMark.render(), maxHeight = utilRadioMark.AABBBounds.height();
    } else maxHeight = Math.max(size, lines.length * lineHeight);
    return maxHeight;
}

export function computeSwitchCellHeight(cellValue, col, row, endCol, actStyle, autoWrapText, iconWidth, fontSize, fontStyle, fontWeight, fontFamily, lineHeight, lineClamp, padding, table) {
    return getProp("boxWidth", actStyle, col, row, table);
}

export function computeButtonCellHeight(cellValue, col, row, endCol, actStyle, autoWrapText, iconWidth, fontSize, fontStyle, fontWeight, fontFamily, lineHeight, lineClamp, padding, table) {
    const text = isObject(cellValue) ? cellValue.text : cellValue, lines = validToString(text).split("\n") || [], cellWidth = table.getColsWidth(col, endCol), buttonPadding = getProp("buttonPadding", actStyle, col, row, table), buttonLineWidth = getProp("buttonLineWidth", actStyle, col, row, table);
    let maxHeight = 0;
    if (autoWrapText) {
        const maxLineWidth = cellWidth - (padding[1] + padding[3]);
        utilButtonMark.setAttributes({
            text: lines,
            textStyle: {
                maxLineWidth: maxLineWidth,
                fontSize: fontSize,
                fontStyle: fontStyle,
                fontWeight: fontWeight,
                fontFamily: fontFamily,
                lineHeight: lineHeight,
                wordBreak: "break-word",
                lineClamp: lineClamp
            },
            padding: buttonPadding,
            panel: {
                visible: !0,
                fill: "red",
                stroke: "red",
                lineWidth: buttonLineWidth
            }
        }), utilRadioMark.render(), maxHeight = utilRadioMark.AABBBounds.height();
    } else maxHeight = lines.length * lineHeight + 2 * buttonPadding;
    return maxHeight;
}
//# sourceMappingURL=height-util.js.map
