import { isNumber } from "@visactor/vutils";

import { Group } from "../graphic/group";

import { updateCell } from "../group-creater/cell-helper";

import { getCellMergeInfo } from "../utils/get-cell-merge";

import { checkHaveTextStick, resetTextStick } from "../stick-text";

export function updateCol(removeCells, addCells, updateCells, table) {
    var _a, _b;
    checkHaveTextStick(table) && resetTextStick(table);
    const scene = table.scenegraph, removeCols = deduplication(removeCells.map((cell => cell.col))).sort(((a, b) => b - a)), addCols = deduplication(addCells.map((cell => cell.col))).sort(((a, b) => a - b)), updateCols = deduplication(updateCells.map((cell => cell.col))).sort(((a, b) => a - b));
    removeCols.forEach((col => {
        removeCol(col, scene);
    }));
    const colWidthsMap = table.colWidthsMap;
    let updateAfter;
    if (removeCols.forEach((col => {
        colWidthsMap.delAndReorder(col);
    })), removeCols.length && resetColNumber(scene), scene.table._clearColRangeWidthsMap(), 
    addCols.forEach((col => {
        const needUpdateAfter = addCol(col, scene);
        resetColNumber(scene), updateAfter = null != updateAfter ? updateAfter : needUpdateAfter, 
        colWidthsMap.addAndReorder(col);
    })), resetColNumberAndX(scene), updateCols.forEach((col => {
        for (let row = 0; row < table.rowCount; row++) {
            const mergeInfo = getCellMergeInfo(scene.table, col, row);
            if (mergeInfo) for (let col = mergeInfo.start.col; col <= mergeInfo.end.col; col++) for (let col = mergeInfo.start.col; col <= mergeInfo.end.col; col++) updateCell(col, row, scene.table, !1); else updateCell(col, row, scene.table, !1);
        }
    })), isNumber(updateAfter)) {
        for (let col = updateAfter; col < Math.max(table.colCount, null !== (_a = table.internalProps._oldColCount) && void 0 !== _a ? _a : table.colCount); col++) for (let row = 0; row < Math.max(table.rowCount, null !== (_b = table.internalProps._oldRowCount) && void 0 !== _b ? _b : table.rowCount); row++) {
            const cellGroup = scene.highPerformanceGetCell(col, row, !0);
            cellGroup && (cellGroup.needUpdate = !0);
        }
        scene.proxy.colUpdatePos = updateAfter;
    }
    if (addCols.length) {
        if (!isNumber(updateAfter)) {
            const minCol = Math.min(...addCols);
            scene.proxy.colUpdatePos = minCol;
        }
        scene.proxy.colUpdateDirection = "left", scene.proxy.updateColGroups(2 * scene.proxy.screenColCount), 
        updateRightFrozeCellGroups(), scene.proxy.progress();
    } else removeCols.length && (scene.proxy.updateColGroups(2 * scene.proxy.screenColCount), 
    updateRightFrozeCellGroups(), scene.proxy.progress());
    const newTotalWidth = table.getColsWidth(table.frozenColCount, table.colCount - 1);
    function updateRightFrozeCellGroups() {
        if ((null == addCols ? void 0 : addCols[(null == addCols ? void 0 : addCols.length) - 1]) >= table.colCount - table.rightFrozenColCount || (null == updateCols ? void 0 : updateCols[(null == updateCols ? void 0 : updateCols.length) - 1]) >= table.colCount - table.rightFrozenColCount || (null == removeCols ? void 0 : removeCols[0]) >= table.colCount - table.rightFrozenColCount) {
            for (let col = table.colCount - table.rightFrozenColCount; col < table.colCount; col++) for (let row = 0; row < table.rowCount; row++) {
                const cellGroup = scene.highPerformanceGetCell(col, row, !0);
                cellGroup && (cellGroup.needUpdate = !0);
            }
            scene.proxy.updateRightFrozenCellGroups();
        }
    }
    scene.updateContainerWidth(scene.table.frozenColCount, newTotalWidth - scene.bodyGroup.attribute.width);
}

function removeCol(col, scene) {
    const proxy = scene.proxy;
    if (col >= scene.table.rowHeaderLevelCount) if (col >= scene.table.colCount - scene.table.rightFrozenColCount) ; else {
        const colGroup = scene.getColGroup(col, !1);
        colGroup && colGroup.parent === scene.bodyGroup && scene.bodyGroup.removeChild(colGroup);
        const bottomColGroup = scene.getColGroupInBottom(col);
        bottomColGroup && bottomColGroup.parent === scene.bottomFrozenGroup && scene.bottomFrozenGroup.removeChild(bottomColGroup);
        const headerColGroup = scene.getColGroup(col, !0);
        headerColGroup && headerColGroup.parent === scene.colHeaderGroup && scene.colHeaderGroup.removeChild(headerColGroup);
    }
    col >= proxy.colStart && col <= proxy.colEnd && (proxy.colEnd--, proxy.currentCol--), 
    proxy.bodyRightCol--;
    const totalActualBodyColCount = Math.min(proxy.colLimit, proxy.bodyRightCol - proxy.bodyLeftCol + 1);
    proxy.totalActualBodyColCount = totalActualBodyColCount, proxy.totalCol = proxy.colStart + totalActualBodyColCount - 1;
}

function addCol(col, scene) {
    const proxy = scene.proxy;
    proxy.bodyRightCol++;
    const totalActualBodyColCount = Math.min(proxy.colLimit, proxy.bodyRightCol - proxy.bodyLeftCol + 1);
    if (proxy.totalActualBodyColCount = totalActualBodyColCount, proxy.totalCol = proxy.colStart + totalActualBodyColCount - 1, 
    !(col < proxy.colStart)) return col > proxy.colEnd ? proxy.colEnd - proxy.colStart + 1 < proxy.colLimit ? (proxy.colEnd++, 
    proxy.currentCol++, addColGroup(col, scene), col) : void 0 : proxy.colEnd - proxy.colStart + 1 < proxy.colLimit ? (proxy.colEnd++, 
    proxy.currentCol++, addColGroup(col, scene), col) : col;
}

function deduplication(array) {
    const result = [];
    for (let i = 0; i < array.length; i++) -1 === result.indexOf(array[i]) && result.push(array[i]);
    return result;
}

function resetColNumber(scene) {
    let colIndex = scene.bodyColStart;
    function processCell(cellGroup) {
        cellGroup.col = colIndex;
        const merge = getCellMergeInfo(scene.table, cellGroup.col, cellGroup.row);
        merge && (cellGroup.mergeStartCol = merge.start.col, cellGroup.mergeStartCol = merge.start.col, 
        cellGroup.mergeEndCol = merge.end.col, cellGroup.mergeEndCol = merge.end.col), cellGroup.role;
    }
    scene.bodyGroup.forEachChildren((colGroup => {
        colGroup.col = colIndex, null == colGroup || colGroup.forEachChildren((cellGroup => {
            processCell(cellGroup);
        })), colIndex++;
    })), colIndex = scene.bodyColStart, scene.colHeaderGroup.forEachChildren((colGroup => {
        colGroup.col = colIndex, null == colGroup || colGroup.forEachChildren((cellGroup => {
            processCell(cellGroup);
        })), colIndex++;
    })), colIndex = scene.bodyColStart, scene.bottomFrozenGroup.forEachChildren((colGroup => {
        colGroup.col = colIndex, null == colGroup || colGroup.forEachChildren((cellGroup => {
            processCell(cellGroup);
        })), colIndex++;
    }));
}

function resetColNumberAndX(scene) {
    let colIndex = scene.bodyColStart, x = scene.getCellGroupX(colIndex);
    function processCell(cellGroup) {
        cellGroup.col = colIndex;
        const merge = getCellMergeInfo(scene.table, cellGroup.col, cellGroup.row);
        merge && (cellGroup.mergeStartCol = merge.start.col, cellGroup.mergeStartCol = merge.start.col, 
        cellGroup.mergeEndCol = merge.end.col, cellGroup.mergeEndCol = merge.end.col), cellGroup.role;
    }
    scene.bodyGroup.forEachChildren((colGroup => {
        colGroup.col = colIndex, null == colGroup || colGroup.forEachChildren((cellGroup => {
            processCell(cellGroup);
        })), colGroup.setAttribute("x", x), x += colGroup.attribute.width, colIndex++;
    })), colIndex = scene.bodyColStart, x = scene.getCellGroupX(colIndex), scene.colHeaderGroup.forEachChildren((colGroup => {
        colGroup.col = colIndex, null == colGroup || colGroup.forEachChildren((cellGroup => {
            processCell(cellGroup);
        })), colGroup.setAttribute("x", x), x += colGroup.attribute.width, colIndex++;
    })), colIndex = scene.bodyColStart, x = scene.getCellGroupX(colIndex), scene.bottomFrozenGroup.forEachChildren((colGroup => {
        colGroup.col = colIndex, null == colGroup || colGroup.forEachChildren((cellGroup => {
            processCell(cellGroup);
        })), colGroup.setAttribute("x", x), x += colGroup.attribute.width, colIndex++;
    })), colIndex = scene.table.colCount - scene.table.rightFrozenColCount, x = 0, scene.rightFrozenGroup.forEachChildren((colGroup => {
        colGroup.col = colIndex, null == colGroup || colGroup.forEachChildren((cellGroup => {
            processCell(cellGroup);
        })), colGroup.setAttribute("x", x), x += colGroup.attribute.width, colIndex++;
    })), colIndex = scene.table.colCount - scene.table.rightFrozenColCount, x = 0, scene.rightTopCornerGroup.forEachChildren((colGroup => {
        colGroup.col = colIndex, null == colGroup || colGroup.forEachChildren((cellGroup => {
            processCell(cellGroup);
        })), colGroup.setAttribute("x", x), x += colGroup.attribute.width, colIndex++;
    })), colIndex = scene.table.colCount - scene.table.rightFrozenColCount, x = 0, scene.rightBottomCornerGroup.forEachChildren((colGroup => {
        colGroup.col = colIndex, null == colGroup || colGroup.forEachChildren((cellGroup => {
            processCell(cellGroup);
        })), colGroup.setAttribute("x", x), x += colGroup.attribute.width, colIndex++;
    }));
}

function addColGroup(col, scene) {
    if (scene.colHeaderGroup && scene.table.columnHeaderLevelCount > 0) {
        const columnGroup = new Group({
            x: 0,
            y: 0,
            width: scene.table.getColWidth(col),
            height: 0,
            clip: !1,
            pickable: !1
        });
        columnGroup.role = "column", columnGroup.col = col;
        const colAfter = scene.getColGroup(col, !0);
        colAfter ? scene.colHeaderGroup.insertBefore(columnGroup, colAfter) : scene.colHeaderGroup.appendChild(columnGroup), 
        generateCellGroup(columnGroup, col, 0, scene.table.columnHeaderLevelCount - 1);
    }
    if (scene.bodyGroup) {
        const columnGroup = new Group({
            x: 0,
            y: 0,
            width: scene.table.getColWidth(col),
            height: 0,
            clip: !1,
            pickable: !1
        });
        columnGroup.role = "column", columnGroup.col = col;
        const colAfter = scene.getColGroup(col, !1);
        colAfter ? scene.bodyGroup.insertBefore(columnGroup, colAfter) : scene.bodyGroup.appendChild(columnGroup), 
        generateCellGroup(columnGroup, col, scene.bodyRowStart, scene.bodyRowEnd);
    }
    if (scene.bottomFrozenGroup && scene.table.bottomFrozenRowCount > 0) {
        const columnGroup = new Group({
            x: 0,
            y: 0,
            width: scene.table.getColWidth(col),
            height: 0,
            clip: !1,
            pickable: !1
        });
        columnGroup.role = "column", columnGroup.col = col;
        const colAfter = scene.getColGroupInBottom(col);
        colAfter ? scene.bottomFrozenGroup.insertBefore(columnGroup, colAfter) : scene.bottomFrozenGroup.appendChild(columnGroup), 
        generateCellGroup(columnGroup, col, scene.table.rowCount - scene.table.bottomFrozenRowCount, scene.table.rowCount - 1);
    }
    function generateCellGroup(group, col, rowStart, rowEnd) {
        for (let row = rowStart; row <= rowEnd; row++) {
            const cellGroup = new Group({
                x: 0,
                y: 0,
                width: scene.table.getColWidth(col),
                height: scene.table.getRowHeight(row)
            });
            cellGroup.role = "cell", cellGroup.col = col, cellGroup.row = row, cellGroup.needUpdate = !0, 
            group.appendChild(cellGroup);
        }
    }
}
//# sourceMappingURL=update-col.js.map
