import { Factory } from "../../core/factory";

import { getStyleTheme } from "../../core/tableHelper";

import { CUSTOM_CONTAINER_NAME, CUSTOM_MERGE_CONTAINER_NAME, dealWithCustom } from "../component/custom";

import { updateImageCellContentWhileResize } from "../group-creater/cell-type/image-cell";

import { resizeCellGroup, getCustomCellMergeCustom } from "../group-creater/cell-helper";

import { getCellMergeInfo } from "../utils/get-cell-merge";

import { getProp } from "../utils/get-prop";

import { isMergeCellGroup } from "../utils/is-merge-cell-group";

import { getQuadProps } from "../utils/padding";

import { updateCellContentWidth } from "../utils/text-icon-layout";

import { computeRowHeight } from "./compute-row-height";

import { updateCellHeightForRow } from "./update-height";

import { getHierarchyOffset } from "../utils/get-hierarchy-offset";

import { getCellMergeRange } from "../../tools/merge-range";

export function updateColWidth(scene, col, detaX, skipTableWidthMap) {
    skipTableWidthMap || scene.table._setColWidth(col, scene.table.getColWidth(col) + detaX, !0);
    const colOrCornerHeaderColumn = scene.getColGroup(col, !0), rightTopColumn = scene.getColGroupInRightTopCorner(col);
    colOrCornerHeaderColumn && !rightTopColumn && updateColunmWidth(colOrCornerHeaderColumn, detaX, "col-corner", scene), 
    rightTopColumn && updateColunmWidth(rightTopColumn, detaX, "right-top", scene);
    const rowHeaderOrBodyColumn = scene.getColGroup(col);
    rowHeaderOrBodyColumn && updateColunmWidth(rowHeaderOrBodyColumn, detaX, "row-body", scene);
    const leftBottomColumn = scene.getColGroupInLeftBottomCorner(col);
    leftBottomColumn && updateColunmWidth(leftBottomColumn, detaX, "left-bottom", scene);
    const bottomColumn = scene.getColGroupInBottom(col);
    bottomColumn && updateColunmWidth(bottomColumn, detaX, "bottom", scene);
    const rightBottomColumn = scene.getColGroupInRightBottomCorner(col);
    rightBottomColumn && updateColunmWidth(rightBottomColumn, detaX, "right-bottom", scene), 
    col < scene.frozenColCount ? (scene.cornerHeaderGroup.forEachChildrenSkipChild(((column, index) => {
        column.col > col && column.setAttribute("x", column.attribute.x + detaX);
    })), scene.rowHeaderGroup.forEachChildrenSkipChild(((column, index) => {
        column.col > col && column.setAttribute("x", column.attribute.x + detaX);
    }))) : (scene.colHeaderGroup.forEachChildrenSkipChild(((column, index) => {
        column.col > col && column.setAttribute("x", column.attribute.x + detaX);
    })), scene.bodyGroup.forEachChildrenSkipChild(((column, index) => {
        column.col > col && column.setAttribute("x", column.attribute.x + detaX);
    }))), leftBottomColumn && scene.leftBottomCornerGroup.forEachChildrenSkipChild(((column, index) => {
        column.col > col && column.setAttribute("x", column.attribute.x + detaX);
    })), bottomColumn && scene.bottomFrozenGroup.forEachChildrenSkipChild(((column, index) => {
        column.col > col && column.setAttribute("x", column.attribute.x + detaX);
    })), rightBottomColumn && scene.rightBottomCornerGroup.forEachChildrenSkipChild(((column, index) => {
        column.col > col && column.setAttribute("x", column.attribute.x + detaX);
    }));
}

function updateColunmWidth(columnGroup, detaX, mode, scene) {
    var _a, _b, _c, _d, _e, _f, _g;
    let needRerangeRow = !1;
    const oldColumnWidth = null !== (_a = null == columnGroup ? void 0 : columnGroup.attribute.width) && void 0 !== _a ? _a : 0;
    if (null == columnGroup || columnGroup.setAttribute("width", oldColumnWidth + detaX), 
    null == columnGroup || columnGroup.forEachChildren(((cell, index) => {
        if (updateCellWidth(scene, cell, cell.col, cell.row, oldColumnWidth, oldColumnWidth + detaX, detaX, "row-body" !== mode || cell.col < scene.table.rowHeaderLevelCount, scene.table.internalProps.autoWrapText)) {
            const mergeInfo = getCellMergeInfo(scene.table, cell.col, cell.row);
            if (mergeInfo && mergeInfo.end.row - mergeInfo.start.row) for (let row = mergeInfo.start.row; row <= mergeInfo.end.row; row++) resetRowHeight(scene, row); else resetRowHeight(scene, cell.row);
            needRerangeRow = !0;
        }
    })), needRerangeRow) {
        let colGroup, oldContainerHeight, row, newTotalHeight = 0;
        for (let col = 0; col < scene.table.colCount; col++) {
            if ("col-corner" === mode ? (row = 0, colGroup = scene.getColGroup(col, !0), oldContainerHeight = null !== (_b = scene.colHeaderGroup.attribute.height) && void 0 !== _b ? _b : 0) : "row-body" === mode ? (row = scene.table.frozenRowCount, 
            colGroup = scene.getColGroup(col, !1), oldContainerHeight = null !== (_c = scene.bodyGroup.attribute.height) && void 0 !== _c ? _c : 0) : "bottom" === mode ? (row = scene.table.rowCount - scene.table.bottomFrozenRowCount, 
            colGroup = scene.getColGroupInBottom(col), oldContainerHeight = null !== (_d = scene.bottomFrozenGroup.attribute.height) && void 0 !== _d ? _d : 0) : "left-bottom" === mode ? (row = scene.table.rowCount - scene.table.bottomFrozenRowCount, 
            colGroup = scene.getColGroupInLeftBottomCorner(col), oldContainerHeight = null !== (_e = scene.leftBottomCornerGroup.attribute.height) && void 0 !== _e ? _e : 0) : "right-top" === mode ? (row = 0, 
            colGroup = scene.getColGroupInRightTopCorner(col), oldContainerHeight = null !== (_f = scene.rightTopCornerGroup.attribute.height) && void 0 !== _f ? _f : 0) : "right-bottom" === mode && (row = scene.table.rowCount - scene.table.bottomFrozenRowCount, 
            colGroup = scene.getColGroupInRightBottomCorner(col), oldContainerHeight = null !== (_g = scene.rightBottomCornerGroup.attribute.height) && void 0 !== _g ? _g : 0), 
            !colGroup) continue;
            let y = 0;
            colGroup.forEachChildren((cellGroup => {
                var _a;
                cellGroup.setAttribute("y", y), y += null !== (_a = scene.table.getRowHeight(cellGroup.row)) && void 0 !== _a ? _a : 0;
            })), newTotalHeight = y;
        }
        scene.updateContainerHeight(row, newTotalHeight - oldContainerHeight);
        for (let col = 0; col < scene.table.frozenColCount; col++) {
            const leftBottomFrozenColumnGroup = scene.getColGroupInLeftBottomCorner(col);
            let y = 0;
            null == leftBottomFrozenColumnGroup || leftBottomFrozenColumnGroup.forEachChildren((cellGroup => {
                cellGroup.setAttribute("y", y), y += scene.table.getRowHeight(cellGroup.row);
            }));
        }
        for (let col = scene.table.colCount - scene.table.rightFrozenColCount; col < scene.table.colCount; col++) {
            const rightBottomFrozenColumnGroup = scene.getColGroupInRightBottomCorner(col);
            let y = 0;
            null == rightBottomFrozenColumnGroup || rightBottomFrozenColumnGroup.forEachChildren((cellGroup => {
                cellGroup.setAttribute("y", y), y += scene.table.getRowHeight(cellGroup.row);
            }));
        }
        for (let col = scene.table.frozenColCount; col < scene.table.colCount - scene.table.rightFrozenColCount; col++) {
            const rightBottomFrozenColumnGroup = scene.getColGroupInBottom(col);
            let y = 0;
            null == rightBottomFrozenColumnGroup || rightBottomFrozenColumnGroup.forEachChildren((cellGroup => {
                cellGroup.setAttribute("y", y), y += scene.table.getRowHeight(cellGroup.row);
            }));
        }
    }
}

function updateCellWidth(scene, cell, col, row, oldWidth, distWidth, detaX, isHeader, autoWrapText) {
    var _a, _b, _c, _d, _e, _f, _g;
    if (cell.attribute.width === distWidth && !cell.needUpdateWidth) return !1;
    cell.needUpdateWidth = !1, cell.setAttribute("width", distWidth);
    const cellGroup = cell;
    if (!cellGroup) return !1;
    const autoRowHeight = scene.table.isAutoRowHeight(row), isVtableMerge = null === (_a = scene.table.getCellRawRecord(col, row)) || void 0 === _a ? void 0 : _a.vtableMerge, isCustomMerge = !!scene.table.getCustomMerge(col, row), type = isVtableMerge || isCustomMerge ? "text" : scene.table.isHeader(col, row) ? null !== (_b = scene.table._getHeaderLayoutMap(col, row).headerType) && void 0 !== _b ? _b : "text" : null !== (_c = scene.table.getBodyColumnType(col, row)) && void 0 !== _c ? _c : "text";
    let isHeightChange = !1;
    if ("progressbar" === type) {
        const columnDefine = scene.table.getBodyColumnDefine(col, row), style = scene.table._getCellStyle(col, row), value = scene.table.getCellValue(col, row), dataValue = scene.table.getCellOriginValue(col, row), padding = getQuadProps(getProp("padding", style, col, row, scene.table));
        let range;
        (null == columnDefine ? void 0 : columnDefine.mergeCell) && (range = scene.table.getCellRange(col, row));
        const newBarCell = Factory.getFunction("createProgressBarCell")(columnDefine, style, cellGroup.attribute.width, value, dataValue, col, row, padding, scene.table, range), oldBarCell = cellGroup.getChildByName("progress-bar");
        cellGroup.insertBefore(newBarCell, oldBarCell), cellGroup.removeChild(oldBarCell), 
        oldBarCell.removeAllChild(), oldBarCell.release();
        const cellChange = updateMergeCellContentWidth(cellGroup, distWidth, detaX, autoRowHeight, !0, scene.table);
        isHeightChange = isHeightChange || cellChange;
    } else if ("sparkline" === type) {
        cellGroup.removeAllChild();
        const headerStyle = scene.table._getCellStyle(col, row), padding = getQuadProps(getProp("padding", headerStyle, col, row, scene.table));
        Factory.getFunction("createSparkLineCellGroup")(cellGroup, cellGroup.parent, cellGroup.attribute.x, cellGroup.attribute.y, col, row, cellGroup.attribute.width, cellGroup.attribute.height, padding, scene.table, getStyleTheme(headerStyle, scene.table, col, row, getProp).theme, !1);
    } else if ("image" === type || "video" === type) updateImageCellContentWhileResize(cellGroup, col, row, detaX, 0, scene.table); else if ("axis" === (null === (_d = cellGroup.firstChild) || void 0 === _d ? void 0 : _d.name)) {
        const axisConfig = scene.table.internalProps.layoutMap.getAxisConfigInPivotChart(col, row), cellStyle = scene.table._getCellStyle(col, row), padding = getQuadProps(getProp("padding", cellStyle, col, row, scene.table));
        if (axisConfig) {
            const axis = new (Factory.getComponent("axis"))(axisConfig, cellGroup.attribute.width, cellGroup.attribute.height, null !== (_e = axisConfig.__vtablePadding) && void 0 !== _e ? _e : padding, scene.table);
            cellGroup.clear(), cellGroup.appendChild(axis.component), axis.overlap();
        }
    } else if ("axis" === (null === (_f = cell.firstChild) || void 0 === _f ? void 0 : _f.name)) null === (_g = cell.firstChild) || void 0 === _g || _g.originAxis.resize(cell.attribute.width, cell.attribute.height); else {
        let renderDefault = !0;
        const customContainer = cell.getChildByName(CUSTOM_CONTAINER_NAME) || cell.getChildByName(CUSTOM_MERGE_CONTAINER_NAME);
        if (customContainer) {
            let customElementsGroup;
            cell.removeChild(customContainer);
            const customMergeRange = getCustomCellMergeCustom(col, row, cell, scene.table);
            if (customMergeRange) for (let mergeCol = customMergeRange.start.col; mergeCol <= customMergeRange.end.col; mergeCol++) {
                if (mergeCol === col) continue;
                const mergedCell = scene.getCell(mergeCol, row), customContainer = mergedCell.getChildByName(CUSTOM_CONTAINER_NAME) || mergedCell.getChildByName(CUSTOM_MERGE_CONTAINER_NAME);
                customContainer.removeAllChild(), mergedCell.removeChild(customContainer), getCustomCellMergeCustom(mergeCol, row, mergedCell, scene.table);
            } else {
                let customRender, customLayout;
                const cellType = scene.table.getCellLocation(col, row), {vtableMerge: vtableMerge} = scene.table.getCellRawRecord(col, row) || {};
                if (vtableMerge && scene.table.options.groupTitleCustomLayout) customLayout = scene.table.options.groupTitleCustomLayout; else if ("body" !== cellType) {
                    const define = scene.table.getHeaderDefine(col, row);
                    customRender = null == define ? void 0 : define.headerCustomRender, customLayout = null == define ? void 0 : define.headerCustomLayout;
                } else {
                    const define = scene.table.getBodyColumnDefine(col, row);
                    customRender = (null == define ? void 0 : define.customRender) || scene.table.customRender, 
                    customLayout = null == define ? void 0 : define.customLayout;
                }
                if ((customRender || customLayout) && isMergeCellGroup(cellGroup)) for (let mergeCol = cellGroup.mergeStartCol; mergeCol <= cellGroup.mergeEndCol; mergeCol++) if (mergeCol !== col) for (let mergeRow = cellGroup.mergeStartRow; mergeRow <= cellGroup.mergeEndRow; mergeRow++) scene.updateCellContent(mergeCol, mergeRow);
                if (customLayout || customRender) {
                    const style = scene.table._getCellStyle(col, row), padding = getQuadProps(getProp("padding", style, col, row, scene.table));
                    let width = cellGroup.attribute.width, height = cellGroup.attribute.height;
                    isMergeCellGroup(cellGroup) && (width = scene.table.getColsWidth(cellGroup.mergeStartCol, cellGroup.mergeEndCol), 
                    height = scene.table.getRowsHeight(cellGroup.mergeStartRow, cellGroup.mergeEndRow));
                    const customResult = dealWithCustom(customLayout, customRender, col, row, width, height, !1, scene.table.isAutoRowHeight(row), padding, isMergeCellGroup(cellGroup) ? {
                        start: {
                            col: cellGroup.mergeStartCol,
                            row: cellGroup.mergeStartRow
                        },
                        end: {
                            col: cellGroup.mergeEndCol,
                            row: cellGroup.mergeEndRow
                        }
                    } : void 0, scene.table);
                    customElementsGroup = customResult.elementsGroup, renderDefault = customResult.renderDefault, 
                    isHeightChange = !0;
                }
                cell.childrenCount > 0 && customElementsGroup ? cell.insertBefore(customElementsGroup, cell.firstChild) : customElementsGroup && cell.appendChild(customElementsGroup);
            }
        }
        const cellChange = updateMergeCellContentWidth(cellGroup, distWidth, detaX, autoRowHeight, renderDefault, scene.table);
        isHeightChange = isHeightChange || cellChange;
    }
    if (!autoWrapText) {
        autoWrapText = scene.table._getCellStyle(col, row).autoWrapText;
    }
    return !(!autoRowHeight || !autoWrapText) && isHeightChange;
}

function updateMergeCellContentWidth(cellGroup, distWidth, detaX, autoRowHeight, renderDefault, table) {
    if (isMergeCellGroup(cellGroup)) {
        distWidth = 0;
        let isHeightChange = !1;
        for (let col = cellGroup.mergeStartCol; col <= cellGroup.mergeEndCol; col++) distWidth += table.getColWidth(col);
        let cellHeight = 0;
        for (let row = cellGroup.mergeStartRow; row <= cellGroup.mergeEndRow; row++) cellHeight += table.getRowHeight(row);
        const {colStart: colStart, colEnd: colEnd, rowStart: rowStart, rowEnd: rowEnd} = getCellMergeRange(cellGroup, table.scenegraph);
        for (let col = colStart; col <= colEnd; col++) for (let row = rowStart; row <= rowEnd; row++) {
            if (col === cellGroup.col && row !== cellGroup.row) continue;
            const singleCellGroup = table.scenegraph.getCell(col, row);
            if ("cell" !== singleCellGroup.role) continue;
            singleCellGroup.forEachChildren((child => {
                child.setAttributes({
                    dx: 0,
                    dy: 0
                });
            }));
            let changed = !1;
            if (renderDefault) {
                const style = table._getCellStyle(colStart, rowStart), padding = getQuadProps(getProp("padding", style, col, row, table)), textAlign = style.textAlign, textBaseline = style.textBaseline;
                changed = updateCellContentWidth(singleCellGroup, distWidth, cellHeight, detaX, autoRowHeight, padding, textAlign, textBaseline, table.scenegraph);
                const hierarchyOffset = getHierarchyOffset(singleCellGroup.col, singleCellGroup.row, table);
                if (hierarchyOffset) {
                    const text = singleCellGroup.getChildByName("text"), icon = singleCellGroup.getChildByName("expand") || singleCellGroup.getChildByName("collapse");
                    "icon-left" !== (null == icon ? void 0 : icon.role) && text && text.setAttribute("dx", hierarchyOffset);
                }
            }
            const rangeHeight = table.getRowHeight(row), rangeWidth = table.getColWidth(col);
            singleCellGroup.contentWidth = distWidth;
            const {heightChange: heightChange} = resizeCellGroup(singleCellGroup, rangeWidth, rangeHeight, {
                start: {
                    col: cellGroup.mergeStartCol,
                    row: cellGroup.mergeStartRow
                },
                end: {
                    col: cellGroup.mergeEndCol,
                    row: cellGroup.mergeEndRow
                }
            }, table);
            heightChange && (singleCellGroup.needUpdateHeight = !0), isHeightChange = isHeightChange || changed;
        }
        return isHeightChange;
    }
    const style = table._getCellStyle(cellGroup.col, cellGroup.row), padding = getQuadProps(getProp("padding", style, cellGroup.col, cellGroup.row, table)), textAlign = style.textAlign, textBaseline = style.textBaseline;
    return updateCellContentWidth(cellGroup, distWidth, table.getRowHeight(cellGroup.row), detaX, autoRowHeight, padding, textAlign, textBaseline, table.scenegraph);
}

function resetRowHeight(scene, row) {
    const maxHeight = Math.round(computeRowHeight(row, 0, scene.table.colCount - 1, scene.table));
    scene.table._setRowHeight(row, maxHeight, !0);
    for (let col = 0; col < scene.table.colCount; col++) {
        const distHeight = maxHeight, cell = scene.highPerformanceGetCell(col, row);
        "empty" !== cell.role && updateCellHeightForRow(scene, cell, col, row, distHeight, distHeight - cell.attribute.height, scene.table.isHeader(col, row));
    }
}
//# sourceMappingURL=update-width.js.map
