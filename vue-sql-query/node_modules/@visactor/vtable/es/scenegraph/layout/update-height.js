import { getCellMergeInfo } from "../utils/get-cell-merge";

import { getProp } from "../utils/get-prop";

import { getQuadProps } from "../utils/padding";

import { updateCellContentHeight } from "../utils/text-icon-layout";

import { CUSTOM_CONTAINER_NAME, CUSTOM_MERGE_CONTAINER_NAME, dealWithCustom } from "../component/custom";

import { updateImageCellContentWhileResize } from "../group-creater/cell-type/image-cell";

import { getStyleTheme } from "../../core/tableHelper";

import { isMergeCellGroup } from "../utils/is-merge-cell-group";

import { resizeCellGroup, getCustomCellMergeCustom } from "../group-creater/cell-helper";

import { getCellMergeRange } from "../../tools/merge-range";

import { Factory } from "../../core/factory";

export function updateRowHeight(scene, row, detaY, skipTableHeightMap) {
    skipTableHeightMap || scene.table._setRowHeight(row, scene.table.getRowHeight(row) + detaY, !0);
    for (let col = 0; col < scene.table.colCount; col++) {
        const cell = scene.getCell(col, row);
        if ("empty" === cell.role) continue;
        const mergeInfo = getCellMergeInfo(scene.table, col, row);
        if (mergeInfo && mergeInfo.start.col !== col) continue;
        updateCellHeightForRow(scene, cell, col, row, cell.attribute.height + detaY, detaY, scene.table.isHeader(col, row)), 
        scene.updateCellContentWhileResize(col, row);
    }
    let rowStart = 0, rowEnd = 0;
    row < scene.table.frozenRowCount ? (rowStart = row + 1, rowEnd = scene.table.frozenRowCount - 1) : row >= scene.table.rowCount - scene.table.bottomFrozenRowCount ? (rowStart = row + 1, 
    rowEnd = scene.table.rowCount - 1) : (rowStart = row + 1, rowEnd = Math.min(scene.proxy.rowEnd, scene.table.rowCount - scene.table.bottomFrozenRowCount - 1));
    for (let colIndex = 0; colIndex < scene.table.colCount; colIndex++) for (let rowIndex = rowStart; rowIndex <= rowEnd; rowIndex++) {
        const cellGroup = scene.highPerformanceGetCell(colIndex, rowIndex);
        "cell" === cellGroup.role && cellGroup.setAttribute("y", cellGroup.attribute.y + detaY);
    }
}

export function updateCellHeightForRow(scene, cell, col, row, height, detaY, isHeader) {
    cell && updateCellHeight(scene, cell, col, row, height, detaY, isHeader);
}

export function updateCellHeightForColumn(scene, cell, col, row, height, detaY, isHeader) {
    updateCellHeight(scene, cell, col, row, height, 0, isHeader);
}

export function updateCellHeight(scene, cell, col, row, distHeight, detaY, isHeader) {
    var _a, _b, _c, _d, _e;
    if (cell.attribute.height === distHeight && !cell.needUpdateHeight) return;
    cell.needUpdateHeight = !1, cell.setAttribute("height", distHeight);
    const isVtableMerge = null === (_a = scene.table.getCellRawRecord(col, row)) || void 0 === _a ? void 0 : _a.vtableMerge, isCustomMerge = !!scene.table.getCustomMerge(col, row), type = isVtableMerge || isCustomMerge ? "text" : scene.table.isHeader(col, row) ? null !== (_b = scene.table._getHeaderLayoutMap(col, row).headerType) && void 0 !== _b ? _b : "text" : null !== (_c = scene.table.getBodyColumnType(col, row)) && void 0 !== _c ? _c : "text";
    if ("progressbar" === type) {
        const columnDefine = scene.table.getBodyColumnDefine(col, row), style = scene.table._getCellStyle(col, row), value = scene.table.getCellValue(col, row), dataValue = scene.table.getCellOriginValue(col, row), padding = getQuadProps(getProp("padding", style, col, row, scene.table));
        let range;
        (null == columnDefine ? void 0 : columnDefine.mergeCell) && (range = scene.table.getCellRange(col, row));
        const newBarCell = Factory.getFunction("createProgressBarCell")(columnDefine, style, cell.attribute.width, value, dataValue, col, row, padding, scene.table, range), oldBarCell = cell.getChildByName("progress-bar");
        cell.insertBefore(newBarCell, oldBarCell), cell.removeChild(oldBarCell), oldBarCell.removeAllChild(), 
        oldBarCell.release(), updateMergeCellContentHeight(cell, distHeight, detaY, scene.table.isAutoRowHeight(row), !0, scene.table);
    } else if ("sparkline" === type) {
        cell.removeAllChild();
        const headerStyle = scene.table._getCellStyle(col, row), padding = getQuadProps(getProp("padding", headerStyle, col, row, scene.table));
        Factory.getFunction("createSparkLineCellGroup")(cell, cell.parent, cell.attribute.x, cell.attribute.y, col, row, cell.attribute.width, cell.attribute.height, padding, scene.table, getStyleTheme(headerStyle, scene.table, col, row, getProp).theme, !1);
    } else if ("image" === type || "video" === type) updateImageCellContentWhileResize(cell, col, row, 0, detaY, scene.table); else if ("axis" === (null === (_d = cell.firstChild) || void 0 === _d ? void 0 : _d.name)) null === (_e = cell.firstChild) || void 0 === _e || _e.originAxis.resize(cell.attribute.width, cell.attribute.height); else {
        let renderDefault = !0;
        const customContainer = cell.getChildByName(CUSTOM_CONTAINER_NAME) || cell.getChildByName(CUSTOM_MERGE_CONTAINER_NAME);
        if (customContainer) {
            let customElementsGroup;
            cell.removeChild(customContainer);
            const customMergeRange = getCustomCellMergeCustom(col, row, cell, scene.table);
            if (customMergeRange) for (let mergeRow = customMergeRange.start.row; mergeRow <= customMergeRange.end.row; mergeRow++) {
                if (mergeRow === row) continue;
                const mergedCell = scene.getCell(col, mergeRow), customContainer = mergedCell.getChildByName(CUSTOM_CONTAINER_NAME) || mergedCell.getChildByName(CUSTOM_MERGE_CONTAINER_NAME);
                customContainer.removeAllChild(), mergedCell.removeChild(customContainer), getCustomCellMergeCustom(col, mergeRow, mergedCell, scene.table);
            } else {
                let customRender, customLayout;
                const cellLocation = scene.table.getCellLocation(col, row), {vtableMerge: vtableMerge} = scene.table.getCellRawRecord(col, row) || {};
                if (vtableMerge && scene.table.options.groupTitleCustomLayout) customLayout = scene.table.options.groupTitleCustomLayout; else if ("body" !== cellLocation) {
                    const define = scene.table.getHeaderDefine(col, row);
                    customRender = null == define ? void 0 : define.headerCustomRender, customLayout = null == define ? void 0 : define.headerCustomLayout;
                } else {
                    const define = scene.table.getBodyColumnDefine(col, row);
                    customRender = (null == define ? void 0 : define.customRender) || scene.table.customRender, 
                    customLayout = null == define ? void 0 : define.customLayout;
                }
                if ((customRender || customLayout) && isMergeCellGroup(cell)) for (let mergeCol = cell.mergeStartCol; mergeCol <= cell.mergeEndCol; mergeCol++) for (let mergeRow = cell.mergeStartRow; mergeRow <= cell.mergeEndRow; mergeRow++) mergeRow !== row && scene.updateCellContent(mergeCol, mergeRow);
                if (customLayout || customRender) {
                    const style = scene.table._getCellStyle(col, row), padding = getQuadProps(getProp("padding", style, col, row, scene.table));
                    let width = cell.attribute.width, height = cell.attribute.height;
                    isMergeCellGroup(cell) && (width = scene.table.getColsWidth(cell.mergeStartCol, cell.mergeEndCol), 
                    height = scene.table.getRowsHeight(cell.mergeStartRow, cell.mergeEndRow));
                    const customResult = dealWithCustom(customLayout, customRender, col, row, width, height, !1, scene.table.isAutoRowHeight(row), padding, isMergeCellGroup(cell) ? {
                        start: {
                            col: cell.mergeStartCol,
                            row: cell.mergeStartRow
                        },
                        end: {
                            col: cell.mergeEndCol,
                            row: cell.mergeEndRow
                        }
                    } : void 0, scene.table);
                    customElementsGroup = customResult.elementsGroup, renderDefault = customResult.renderDefault;
                }
                cell.childrenCount > 0 && customElementsGroup ? cell.insertBefore(customElementsGroup, cell.firstChild) : customElementsGroup && cell.appendChild(customElementsGroup);
            }
        }
        updateMergeCellContentHeight(cell, distHeight, detaY, scene.table.isAutoRowHeight(row), renderDefault, scene.table);
    }
}

function updateMergeCellContentHeight(cellGroup, distHeight, detaY, autoRowHeight, renderDefault, table) {
    if (isMergeCellGroup(cellGroup)) {
        distHeight = 0;
        for (let row = cellGroup.mergeStartRow; row <= cellGroup.mergeEndRow; row++) distHeight += table.getRowHeight(row);
        const {colStart: colStart, colEnd: colEnd, rowStart: rowStart, rowEnd: rowEnd} = getCellMergeRange(cellGroup, table.scenegraph);
        for (let col = colStart; col <= colEnd; col++) for (let row = rowStart; row <= rowEnd; row++) {
            const singleCellGroup = table.scenegraph.getCell(col, row);
            if ("cell" !== singleCellGroup.role) continue;
            if (singleCellGroup.forEachChildren((child => {
                child.setAttributes({
                    dx: 0,
                    dy: 0
                });
            })), renderDefault) {
                const style = table._getCellStyle(colStart, rowStart), padding = getQuadProps(getProp("padding", style, col, row, table));
                updateCellContentHeight(singleCellGroup, distHeight, detaY, autoRowHeight, padding, style.textAlign, style.textBaseline, table);
            }
            const rangeHeight = table.getRowHeight(row), rangeWidth = table.getColWidth(col);
            singleCellGroup.contentHeight = distHeight;
            const {widthChange: widthChange} = resizeCellGroup(singleCellGroup, rangeWidth, rangeHeight, {
                start: {
                    col: cellGroup.mergeStartCol,
                    row: cellGroup.mergeStartRow
                },
                end: {
                    col: cellGroup.mergeEndCol,
                    row: cellGroup.mergeEndRow
                }
            }, table);
            widthChange && (singleCellGroup.needUpdateWidth = !0);
        }
    } else {
        const style = table._getCellStyle(cellGroup.col, cellGroup.row), padding = getQuadProps(getProp("padding", style, cellGroup.col, cellGroup.row, table));
        updateCellContentHeight(cellGroup, distHeight, detaY, autoRowHeight, padding, style.textAlign, style.textBaseline, table);
    }
}
//# sourceMappingURL=update-height.js.map
