import { isValid } from "@visactor/vutils";

import { IconFuncTypeEnum } from "../../ts-types";

import { IContainPointMode, createRect } from "./../../vrender";

import { dealWithIcon } from "../utils/text-icon-layout";

import { getCellMergeRange } from "../../tools/merge-range";

import { traverseObject } from "../../tools/util";

export function hideHoverIcon(col, row, scene) {
    -1 !== col && -1 !== row && (updateCellRangeIcon(col, row, (icon => "mouseenter_cell" === icon.attribute.visibleTime), (icon => {
        icon.setAttribute("opacity", 0);
        const iconBack = icon.parent.getChildByName("icon-back");
        iconBack && iconBack.setAttribute("visible", !1);
    }), scene), scene.updateNextFrame());
}

export function showHoverIcon(col, row, scene) {
    -1 !== col && -1 !== row && (updateCellRangeIcon(col, row, (icon => "mouseenter_cell" === icon.attribute.visibleTime), (icon => {
        icon.setAttribute("opacity", 1);
    }), scene), scene.updateNextFrame());
}

export function hideClickIcon(col, row, scene) {
    -1 !== col && -1 !== row && (updateCellRangeIcon(col, row, (icon => "click_cell" === icon.attribute.visibleTime), (icon => {
        icon.setAttribute("opacity", 0);
    }), scene), scene.updateNextFrame());
}

export function showClickIcon(col, row, scene) {
    -1 !== col && -1 !== row && (updateCellRangeIcon(col, row, (icon => "click_cell" === icon.attribute.visibleTime), (icon => {
        icon.setAttribute("opacity", 1);
    }), scene), scene.updateNextFrame());
}

export function getIconByXY(col, row, x, y, scene) {
    let pickMark;
    return scene.getCell(col, row).forEachChildren((mark => {
        mark.role && mark.role.startsWith("icon") && mark.containsPoint(x, y, IContainPointMode.GLOBAL) && (pickMark = mark);
    })), pickMark;
}

export function setIconHoverStyle(baseIcon, col, row, cellGroup, scene) {
    var _a, _b;
    if ((baseIcon.attribute.backgroundColor || baseIcon.attribute.hoverImage) && updateCellRangeIcon(col, row, (icon => icon.name === baseIcon.name), (icon => {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        if (icon.attribute.backgroundColor) {
            let iconBack = icon.parent.getChildByName("icon-back");
            iconBack ? iconBack.setAttributes({
                x: (null !== (_a = icon.attribute.x) && void 0 !== _a ? _a : 0) + (icon.AABBBounds.width() - icon.backgroundWidth) / 2,
                y: (null !== (_b = icon.attribute.y) && void 0 !== _b ? _b : 0) + (icon.AABBBounds.height() - icon.backgroundHeight) / 2,
                dx: null !== (_c = icon.attribute.dx) && void 0 !== _c ? _c : 0,
                dy: null !== (_d = icon.attribute.dy) && void 0 !== _d ? _d : 0,
                width: icon.backgroundWidth,
                height: icon.backgroundHeight,
                fill: icon.attribute.backgroundColor,
                cornerRadius: 5,
                visible: !0
            }) : (iconBack = createRect({
                x: (null !== (_e = icon.attribute.x) && void 0 !== _e ? _e : 0) + (icon.AABBBounds.width() - icon.backgroundWidth) / 2,
                y: (null !== (_f = icon.attribute.y) && void 0 !== _f ? _f : 0) + (icon.AABBBounds.height() - icon.backgroundHeight) / 2,
                dx: null !== (_g = icon.attribute.dx) && void 0 !== _g ? _g : 0,
                dy: null !== (_h = icon.attribute.dy) && void 0 !== _h ? _h : 0,
                width: icon.backgroundWidth,
                height: icon.backgroundHeight,
                fill: icon.attribute.backgroundColor,
                cornerRadius: 5,
                pickable: !1,
                visible: !0
            }), iconBack.name = "icon-back"), icon.parent.insertBefore(iconBack, icon);
        }
        icon.attribute.hoverImage && icon.attribute.image !== icon.attribute.hoverImage && (icon.image = icon.attribute.hoverImage);
    }), scene), baseIcon.tooltip) {
        const {x1: left, x2: right, y1: top, y2: bottom} = baseIcon.globalAABBBounds, tooltipOptions = {
            content: baseIcon.tooltip.title,
            referencePosition: {
                rect: {
                    left: left,
                    right: right,
                    top: top,
                    bottom: bottom,
                    width: baseIcon.globalAABBBounds.width(),
                    height: baseIcon.globalAABBBounds.height()
                },
                placement: baseIcon.tooltip.placement
            },
            disappearDelay: baseIcon.tooltip.disappearDelay,
            style: Object.assign({}, null === (_a = scene.table.internalProps.theme) || void 0 === _a ? void 0 : _a.tooltipStyle, null === (_b = baseIcon.tooltip) || void 0 === _b ? void 0 : _b.style)
        };
        scene.table.internalProps.tooltipHandler.isBinded(tooltipOptions) || scene.table.showTooltip(col, row, tooltipOptions);
    }
}

export function setIconNormalStyle(baseIcon, col, row, scene) {
    (baseIcon.attribute.backgroundColor || baseIcon.attribute.hoverImage) && updateCellRangeIcon(col, row, (icon => icon.name === baseIcon.name), (icon => {
        const iconBack = icon.parent.getChildByName("icon-back");
        iconBack && iconBack.setAttribute("visible", !1), icon.attribute.hoverImage && icon.attribute.image !== icon.attribute.originImage && (icon.image = icon.attribute.originImage);
    }), scene);
}

export function updateIcon(baseIcon, iconConfig, col, row, scene) {
    const iconName = baseIcon.name;
    updateCellRangeIcon(col, row, (icon => icon.name === iconName), (icon => {
        dealWithIcon(iconConfig, icon), icon.name = iconConfig.name;
    }), scene), scene.updateNextFrame();
}

function resetSortIcon(oldSortCol, oldSortRow, iconConfig, scene) {
    const oldSortCell = scene.getCell(oldSortCol, oldSortRow);
    if (isValid(oldSortCell.mergeStartCol) && isValid(oldSortCell.mergeStartRow) && isValid(oldSortCell.mergeEndCol) && isValid(oldSortCell.mergeEndRow)) for (let col = oldSortCell.mergeStartCol; col <= oldSortCell.mergeEndCol; col++) for (let row = oldSortCell.mergeStartRow; row <= oldSortCell.mergeEndRow; row++) {
        let oldIconMark;
        scene.getCell(col, row).forEachChildren((mark => "sort" === mark.attribute.funcType && (oldIconMark = mark, 
        !0))), oldIconMark && (dealWithIcon(iconConfig, oldIconMark), oldIconMark.name = iconConfig.name);
    } else {
        let oldIconMark;
        traverseObject(oldSortCell, "children", (mark => "sort" === mark.attribute.funcType && (oldIconMark = mark, 
        !0))), oldIconMark && (dealWithIcon(iconConfig, oldIconMark), oldIconMark.name = iconConfig.name);
    }
}

function checkSameCell(col1, row1, col2, row2, table) {
    const range1 = table.getCellRange(col1, row1), range2 = table.getCellRange(col2, row2);
    return range1.start.col === range2.start.col && range1.start.row === range2.start.row && range1.end.col === range2.end.col && range1.end.row === range2.end.row;
}

export function updateSortIcon(options) {
    const {col: col, row: row, iconMark: iconMark, order: order, oldSortCol: oldSortCol, oldSortRow: oldSortRow, oldIconMark: oldIconMark, scene: scene} = options, icon = scene.table.internalProps.headerHelper.getSortIcon(order, scene.table, col, row);
    if (iconMark && updateIcon(iconMark, icon, col, row, scene), !checkSameCell(col, row, oldSortCol, oldSortRow, scene.table)) {
        const oldIcon = scene.table.internalProps.headerHelper.getSortIcon("normal", scene.table, oldSortCol, oldSortRow);
        oldIconMark ? updateIcon(oldIconMark, oldIcon, oldSortCol, oldSortRow, scene) : resetSortIcon(oldSortCol, oldSortRow, oldIcon, scene);
    }
}

export function updateFrozenIcon(scene) {
    for (let col = 0; col < scene.table.colCount; col++) for (let row = 0; row < scene.table.columnHeaderLevelCount; row++) updateCellRangeIcon(col, row, (icon => "frozen" === icon.attribute.funcType), (icon => {
        const iconConfig = scene.table.internalProps.headerHelper.getFrozenIcon(col, row);
        dealWithIcon(iconConfig, icon), icon.name = iconConfig.name;
    }), scene);
}

export function updateHierarchyIcon(col, row, scene) {
    let iconConfig;
    iconConfig = scene.table.isHeader(col, row) ? scene.table.internalProps.headerHelper.getHierarchyIcon(col, row) : scene.table.internalProps.bodyHelper.getHierarchyIcon(col, row), 
    updateCellRangeIcon(col, row, (icon => icon.attribute.funcType === IconFuncTypeEnum.collapse || icon.attribute.funcType === IconFuncTypeEnum.expand), (icon => {
        dealWithIcon(iconConfig, icon), icon.name = iconConfig.name;
    }), scene);
}

export function updateCellGroupIcon(cellGroup, filter, dealer) {
    cellGroup && "empty" !== cellGroup.role && cellGroup.forEachChildren((child => {
        "group" === child.type ? updateCellGroupIcon(child, filter, dealer) : filter(child) && dealer(child);
    }));
}

export function updateCellRangeIcon(col, row, filter, dealer, scene) {
    const cellGroup = scene.getCell(col, row);
    if ("cell" === cellGroup.role && isValid(cellGroup.mergeStartCol) && isValid(cellGroup.mergeStartRow) && isValid(cellGroup.mergeEndCol) && isValid(cellGroup.mergeEndRow)) {
        const {colStart: colStart, colEnd: colEnd, rowStart: rowStart, rowEnd: rowEnd} = getCellMergeRange(cellGroup, scene);
        for (let col = colStart; col <= colEnd; col++) for (let row = rowStart; row <= rowEnd; row++) updateCellGroupIcon(scene.highPerformanceGetCell(col, row), filter, dealer);
    } else updateCellGroupIcon(cellGroup, filter, dealer);
}

export function residentHoverIcon(col, row, scene) {
    updateCellRangeIcon(col, row, (icon => icon.attribute.funcType === IconFuncTypeEnum.dropDown), (icon => {
        icon.oldVisibleTime = icon.attribute.visibleTime, icon.setAttribute("visibleTime", "always"), 
        icon.setAttribute("opacity", 1);
    }), scene);
}

export function resetResidentHoverIcon(col, row, scene) {
    updateCellRangeIcon(col, row, (icon => icon.attribute.funcType === IconFuncTypeEnum.dropDown), (icon => {
        icon.oldVisibleTime && icon.setAttribute("visibleTime", icon.oldVisibleTime), icon.setAttribute("opacity", "always" === icon.attribute.visibleTime ? 1 : 0);
    }), scene);
}
//# sourceMappingURL=icon-update.js.map
