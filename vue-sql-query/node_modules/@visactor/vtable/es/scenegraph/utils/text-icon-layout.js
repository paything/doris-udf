import { RichText, Text } from "./../../vrender";

import { IconFuncTypeEnum, IconPosition } from "../../ts-types";

import { CellContent } from "../component/cell-content";

import { Icon, TextIcon } from "../graphic/icon";

import { getCellMergeInfo } from "./get-cell-merge";

import { getHierarchyOffset } from "./get-hierarchy-offset";

import { isNumber, isValid, isValidNumber, merge } from "@visactor/vutils";

import { breakString } from "./break-string";

import { CUSTOM_CONTAINER_NAME } from "../component/custom";

import { getTargetCell } from "../../event/util";

export function createCellContent(cellGroup, icons, textStr, padding, autoColWidth, autoRowHeight, autoWrapText, lineClamp, cellWidth, cellHeight, textAlign, textBaseline, table, cellTheme, range) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    let contentWidth, contentHeight, leftIconWidth = 0, rightIconWidth = 0, absoluteRightIconWidth = 0;
    if (Array.isArray(icons) && 0 !== icons.length) {
        const {inlineFrontIcons: inlineFrontIcons, inlineEndIcons: inlineEndIcons, contentLeftIcons: contentLeftIcons, contentRightIcons: contentRightIcons, leftIconWidth: layoutLeftIconWidth, rightIconWidth: layoutRightIconWidth, absoluteRightIconWidth: layoutAbsoluteRightIconWidth} = dealWithIconLayout(icons, cellGroup, range, table);
        let textMark;
        if (leftIconWidth = layoutLeftIconWidth, rightIconWidth = layoutRightIconWidth, 
        absoluteRightIconWidth = layoutAbsoluteRightIconWidth, 0 === inlineFrontIcons.length && 0 === inlineEndIcons.length) {
            let _contentOffset = 0;
            isNumber(table.theme._contentOffset) && ("left" === textAlign ? _contentOffset = table.theme._contentOffset : "right" === textAlign && (_contentOffset = -table.theme._contentOffset));
            const hierarchyOffset = range ? getHierarchyOffset(range.start.col, range.start.row, table) : getHierarchyOffset(cellGroup.col, cellGroup.row, table), {text: text, moreThanMaxCharacters: moreThanMaxCharacters} = breakString(textStr, table), attribute = {
                text: 1 === text.length ? text[0] : text,
                moreThanMaxCharacters: moreThanMaxCharacters,
                maxLineWidth: autoColWidth ? 1 / 0 : cellWidth - (padding[1] + padding[3]) - leftIconWidth - rightIconWidth - hierarchyOffset,
                textBaseline: "top",
                heightLimit: !1 === (null === (_d = table.options.customConfig) || void 0 === _d ? void 0 : _d.limitContentHeight) || autoRowHeight && !(null === (_e = table.options.customConfig) || void 0 === _e ? void 0 : _e.multilinesForXTable) ? -1 : cellHeight - Math.floor(padding[0] + padding[2]),
                pickable: !1,
                autoWrapText: autoWrapText,
                lineClamp: lineClamp,
                wordBreak: "break-word",
                whiteSpace: !1 === (null === (_f = table.options.customConfig) || void 0 === _f ? void 0 : _f.limitContentHeight) || 1 !== text.length || autoWrapText ? "normal" : "no-wrap",
                dx: ("left" === textAlign ? contentLeftIcons.length ? 0 : hierarchyOffset : 0) + _contentOffset,
                keepCenterInLine: !0
            }, wrapText = new Text(cellTheme.text ? Object.assign({}, cellTheme.text, attribute) : attribute);
            wrapText.name = "text", textMark = wrapText;
        } else {
            const textOption = Object.assign({
                text: null == textStr ? void 0 : textStr.toString()
            }, (null === (_j = null === (_h = null === (_g = cellGroup.parent) || void 0 === _g ? void 0 : _g.theme) || void 0 === _h ? void 0 : _h.userTheme) || void 0 === _j ? void 0 : _j.text) || {});
            cellTheme.text && Object.assign(textOption, cellTheme.text), textOption.textBaseline = "middle";
            const textConfig = [ ...inlineFrontIcons.map((icon => dealWithRichTextIcon(icon))), textOption, ...inlineEndIcons.map((icon => dealWithRichTextIcon(icon))) ];
            textConfig[0].textAlign = textAlign;
            const text = new RichText({
                width: autoColWidth ? 0 : cellWidth - (padding[1] + padding[3]) - leftIconWidth - rightIconWidth,
                height: autoRowHeight && autoWrapText ? 0 : Math.ceil(cellHeight - (padding[0] + padding[2])),
                textConfig: textConfig,
                verticalDirection: autoRowHeight && autoWrapText ? "top" : textBaseline,
                ellipsis: textOption.ellipsis
            });
            text.name = "text", textMark = text, text.bindIconEvent(), !range || range.start.col === range.end.col && range.start.row === range.end.row || (text.onBeforeAttributeUpdate = onBeforeAttributeUpdate);
        }
        if (0 !== contentLeftIcons.length || 0 !== contentRightIcons.length) {
            const cellContent = new CellContent({
                x: 0,
                y: 0,
                fill: !1,
                stroke: !1,
                pickable: !1
            });
            cellContent.name = "content", cellContent.setCellContentOption({
                autoWidth: autoColWidth,
                autoHeight: autoRowHeight,
                cellWidth: cellWidth - (padding[1] + padding[3]) - leftIconWidth - rightIconWidth,
                cellHeight: cellHeight - (padding[0] + padding[2]),
                align: textAlign,
                baseline: textBaseline
            });
            const dealWithIconComputeVar = {
                addedHierarchyOffset: 0
            };
            contentLeftIcons.forEach((icon => {
                const iconMark = dealWithIcon(icon, void 0, cellGroup.col, cellGroup.row, range, table, dealWithIconComputeVar);
                iconMark.role = "icon-content-left", iconMark.name = icon.name, cellContent.addLeftOccupyingIcon(iconMark);
            })), contentRightIcons.forEach((icon => {
                const iconMark = dealWithIcon(icon, void 0, cellGroup.col, cellGroup.row, range, table, dealWithIconComputeVar);
                iconMark.role = "icon-content-right", iconMark.name = icon.name, cellContent.addRightOccupyingIcon(iconMark);
            })), cellContent.addContent(textMark), cellGroup.appendChild(cellContent), cellContent.layout(), 
            contentWidth = cellContent.AABBBounds.width(), contentHeight = cellContent.AABBBounds.height();
        } else cellGroup.firstChild ? cellGroup.insertBefore(textMark, cellGroup.firstChild) : cellGroup.appendChild(textMark), 
        contentWidth = textMark.AABBBounds.width(), contentHeight = textMark.AABBBounds.height();
    } else if (isValid(textStr)) {
        const {text: text, moreThanMaxCharacters: moreThanMaxCharacters} = breakString(textStr, table), hierarchyOffset = range ? getHierarchyOffset(range.start.col, range.start.row, table) : getHierarchyOffset(cellGroup.col, cellGroup.row, table);
        let _contentOffset = 0;
        isNumber(table.theme._contentOffset) && ("left" === textAlign ? _contentOffset = table.theme._contentOffset : "right" === textAlign && (_contentOffset = -table.theme._contentOffset));
        const attribute = {
            text: 1 === text.length ? text[0] : text,
            moreThanMaxCharacters: moreThanMaxCharacters,
            maxLineWidth: autoColWidth ? 1 / 0 : cellWidth - (padding[1] + padding[3] + hierarchyOffset),
            textBaseline: "top",
            autoWrapText: autoWrapText,
            lineClamp: lineClamp,
            wordBreak: "break-word",
            heightLimit: !1 === (null === (_a = table.options.customConfig) || void 0 === _a ? void 0 : _a.limitContentHeight) || autoRowHeight && !(null === (_b = table.options.customConfig) || void 0 === _b ? void 0 : _b.multilinesForXTable) ? -1 : cellHeight - Math.floor(padding[0] + padding[2]),
            pickable: !1,
            dx: ("left" === textAlign ? hierarchyOffset : 0) + _contentOffset,
            whiteSpace: !1 === (null === (_c = table.options.customConfig) || void 0 === _c ? void 0 : _c.limitContentHeight) || 1 !== text.length || autoWrapText ? "normal" : "no-wrap",
            keepCenterInLine: !0
        }, wrapText = new Text(cellTheme.text ? Object.assign({}, cellTheme.text, attribute) : attribute);
        wrapText.name = "text", wrapText.textBaseline = textBaseline, cellGroup.appendChild(wrapText), 
        contentWidth = wrapText.AABBBounds.width(), contentHeight = wrapText.AABBBounds.height();
    }
    const width = autoColWidth ? leftIconWidth + contentWidth + rightIconWidth : cellWidth - (padding[1] + padding[3]), height = cellHeight - (padding[0] + padding[2]);
    cellGroup.forEachChildren((child => {
        "icon-left" === child.role ? child.setAttribute("x", child.attribute.x + padding[3]) : "icon-right" === child.role ? child.setAttribute("x", child.attribute.x + width - rightIconWidth + padding[3]) : "icon-absolute-right" === child.role ? child.setAttribute("x", child.attribute.x + width - absoluteRightIconWidth + padding[3] + padding[1]) : "content" !== child.name && "text" !== child.name || ("center" === textAlign && "richtext" !== child.type ? child.setAttribute("x", padding[3] + leftIconWidth + (width - leftIconWidth - rightIconWidth) / 2) : "right" === textAlign && "richtext" !== child.type ? child.setAttribute("x", padding[3] + width - rightIconWidth) : child.setAttribute("x", padding[3] + leftIconWidth));
    })), cellGroup.forEachChildren((child => {
        child.name !== CUSTOM_CONTAINER_NAME && ("middle" === textBaseline ? child.setAttribute("y", padding[0] + (height - child.AABBBounds.height()) / 2) : "bottom" === textBaseline ? child.setAttribute("y", padding[0] + height - child.AABBBounds.height()) : child.setAttribute("y", padding[0]));
    })), cellGroup.setAttributes({
        width: width + padding[1] + padding[3],
        height: height + padding[0] + padding[2]
    });
}

export function dealWithIcon(icon, mark, col, row, range, table, dealWithIconComputeVar) {
    var _a, _b, _c, _d, _e, _f;
    const iconAttribute = {};
    "image" === icon.type ? icon.isGif ? (iconAttribute.gif = icon.src, iconAttribute.image = icon.src) : iconAttribute.image = icon.src : ("svg" === icon.type || "svg" in icon) && (iconAttribute.image = icon.svg), 
    iconAttribute.width = icon.width, iconAttribute.height = icon.height, iconAttribute.visibleTime = null !== (_a = icon.visibleTime) && void 0 !== _a ? _a : "always", 
    iconAttribute.funcType = icon.funcType, iconAttribute.interactive = icon.interactive, 
    iconAttribute.isGif = icon.isGif;
    let iconMark, hierarchyOffset = 0;
    return dealWithIconComputeVar && 0 !== (null == dealWithIconComputeVar ? void 0 : dealWithIconComputeVar.addedHierarchyOffset) || !isNumber(col) || !isNumber(row) || !table || icon.funcType !== IconFuncTypeEnum.collapse && icon.funcType !== IconFuncTypeEnum.expand && icon.positionType !== IconPosition.contentLeft && icon.positionType !== IconPosition.contentRight || (hierarchyOffset = range ? getHierarchyOffset(range.start.col, range.start.row, table) : getHierarchyOffset(col, row, table), 
    dealWithIconComputeVar && (dealWithIconComputeVar.addedHierarchyOffset = 1)), iconAttribute.marginLeft = (null !== (_b = icon.marginLeft) && void 0 !== _b ? _b : 0) + hierarchyOffset, 
    iconAttribute.marginRight = null !== (_c = icon.marginRight) && void 0 !== _c ? _c : 0, 
    !1 === icon.interactive && (iconAttribute.pickable = !1), icon.hover && (iconAttribute.backgroundWidth = null !== (_d = icon.hover.width) && void 0 !== _d ? _d : icon.width, 
    iconAttribute.backgroundHeight = null !== (_e = icon.hover.width) && void 0 !== _e ? _e : icon.width, 
    iconAttribute.backgroundColor = null !== (_f = icon.hover.bgColor) && void 0 !== _f ? _f : "rgba(22,44,66,0.2)", 
    iconAttribute.hoverImage = icon.hover.image), icon.cursor && (iconAttribute.cursor = icon.cursor), 
    "shape" in icon && "circle" === icon.shape && (iconAttribute.shape = icon.shape), 
    mark ? (mark.setAttributes(iconAttribute), mark.loadImage(iconAttribute.image), 
    mark.tooltip = icon.tooltip, mark.name = icon.name, mark) : ("text" === icon.type ? (iconAttribute.text = icon.content, 
    merge(iconAttribute, icon.style), iconMark = new TextIcon(iconAttribute), iconMark.tooltip = icon.tooltip, 
    iconMark.name = icon.name) : (iconMark = new Icon(iconAttribute), iconMark.tooltip = icon.tooltip, 
    iconMark.name = icon.name), iconMark);
}

export function dealWithRichTextIcon(icon) {
    var _a, _b, _c, _d, _e, _f;
    const config = {};
    return "image" === icon.type ? config.image = icon.src : ("svg" === icon.type || "svg" in icon) && (config.image = icon.svg), 
    config.visibleTime = null !== (_a = icon.visibleTime) && void 0 !== _a ? _a : "always", 
    config.funcType = icon.funcType, config.id = icon.name, config.width = icon.width, 
    config.height = icon.height, (icon.marginRight || icon.marginLeft) && (config.margin = [ 0, null !== (_b = icon.marginRight) && void 0 !== _b ? _b : 0, 0, null !== (_c = icon.marginLeft) && void 0 !== _c ? _c : 0 ]), 
    icon.hover && (config.backgroundWidth = null !== (_d = icon.hover.width) && void 0 !== _d ? _d : icon.width, 
    config.backgroundHeight = null !== (_e = icon.hover.height) && void 0 !== _e ? _e : icon.height, 
    config.backgroundShowMode = "hover", config.hoverImage = icon.hover.image, config.backgroundStroke = !1, 
    config.backgroundFill = null !== (_f = icon.hover.bgColor) && void 0 !== _f ? _f : "rgba(22,44,66,0.2)"), 
    icon.cursor && (config.cursor = icon.cursor), config.tooltip = icon.tooltip, config;
}

export function updateCellContentWidth(cellGroup, distWidth, cellHeight, detaX, autoRowHeight, padding, textAlign, textBaseline, scene) {
    var _a, _b, _c, _d;
    isValidNumber(cellGroup.contentWidth) && (detaX = distWidth - (null !== (_a = cellGroup.contentWidth) && void 0 !== _a ? _a : cellGroup.attribute.width));
    let oldTextHeight, leftIconWidth = 0, leftIconHeight = 0, rightIconWidth = 0, rightIconHeight = 0;
    cellGroup.forEachChildren((iconMark => {
        var _a, _b, _c, _d;
        "icon-left" === iconMark.role ? (leftIconWidth += iconMark.AABBBounds.width() + (null !== (_a = iconMark.attribute.marginLeft) && void 0 !== _a ? _a : 0) + (null !== (_b = iconMark.attribute.marginRight) && void 0 !== _b ? _b : 0), 
        leftIconHeight = Math.max(leftIconHeight, iconMark.AABBBounds.height())) : "icon-right" === iconMark.role && (rightIconWidth += iconMark.AABBBounds.width() + (null !== (_c = iconMark.attribute.marginLeft) && void 0 !== _c ? _c : 0) + (null !== (_d = iconMark.attribute.marginRight) && void 0 !== _d ? _d : 0), 
        rightIconHeight = Math.max(rightIconHeight, iconMark.AABBBounds.height()));
    }));
    const textMark = cellGroup.getChildByName("text"), cellContent = cellGroup.getChildByName("content");
    let contentHeight;
    textMark instanceof Text ? (oldTextHeight = textMark.AABBBounds.height(), textMark.setAttribute("maxLineWidth", distWidth - leftIconWidth - rightIconWidth - (padding[1] + padding[3]) - (null !== (_b = textMark.attribute.dx) && void 0 !== _b ? _b : 0) - (null !== (_c = scene.table.theme._contentOffset) && void 0 !== _c ? _c : 0)), 
    contentHeight = textMark.AABBBounds.height()) : textMark instanceof RichText ? (oldTextHeight = textMark.AABBBounds.height(), 
    textMark.setAttribute("width", distWidth - leftIconWidth - rightIconWidth - (padding[1] + padding[3])), 
    contentHeight = textMark.AABBBounds.height()) : cellContent && (oldTextHeight = cellContent.AABBBounds.height(), 
    cellContent.updateWidth(distWidth - leftIconWidth - rightIconWidth - (padding[1] + padding[3])), 
    contentHeight = cellContent.AABBBounds.height());
    const oldCellHeight = Math.round(Math.max(leftIconHeight, rightIconHeight, oldTextHeight) + padding[0] + padding[2]);
    if (cellGroup.forEachChildren((child => {
        var _a;
        if ("icon-left" === child.role) ; else if ("icon-right" === child.role) child.setAttribute("x", child.attribute.x + detaX); else if ("icon-absolute-right" === child.role) child.setAttribute("x", child.attribute.x + detaX); else if ("content" === child.name || "text" === child.name && "richtext" !== child.type) {
            const childTextAlign = null !== (_a = child.attribute.textAlign) && void 0 !== _a ? _a : textAlign;
            "center" === childTextAlign ? child.setAttribute("x", padding[3] + leftIconWidth + (distWidth - (padding[1] + padding[3]) - leftIconWidth - rightIconWidth) / 2) : "right" === childTextAlign && child.setAttribute("x", padding[3] + distWidth - (padding[1] + padding[3]) - rightIconWidth);
        } else "mark" === child.name && child.setAttribute("x", cellGroup.attribute.width);
    })), autoRowHeight) {
        let newHeight = Math.max(leftIconHeight, contentHeight, rightIconHeight);
        if (isCellHeightUpdate(scene, cellGroup, Math.round(newHeight + padding[0] + padding[2]), oldCellHeight)) return !0;
        newHeight = (null !== (_d = cellGroup.contentHeight) && void 0 !== _d ? _d : cellHeight) - (padding[0] + padding[2]), 
        cellGroup.forEachChildren((child => {
            "rect" !== child.type && "chart" !== child.type && child.name !== CUSTOM_CONTAINER_NAME && ("mark" === child.name ? child.setAttribute("y", 0) : "middle" === textBaseline ? child.setAttribute("y", padding[0] + (newHeight - child.AABBBounds.height()) / 2) : "bottom" === textBaseline ? child.setAttribute("y", padding[0] + newHeight - child.AABBBounds.height()) : child.setAttribute("y", padding[0]));
        }));
    } else "middle" !== textBaseline && "bottom" !== textBaseline || cellGroup.forEachChildren((child => {
        "rect" !== child.type && "chart" !== child.type && child.name !== CUSTOM_CONTAINER_NAME && ("mark" === child.name ? child.setAttribute("y", 0) : "middle" === textBaseline ? child.setAttribute("y", (cellHeight - padding[2] + padding[0] - child.AABBBounds.height()) / 2) : "bottom" === textBaseline ? child.setAttribute("y", cellHeight - child.AABBBounds.height() - padding[2]) : child.setAttribute("y", padding[0]));
    }));
    return !1;
}

export function updateCellContentHeight(cellGroup, distHeight, detaY, autoRowHeight, padding, textAlign, textBaseline, table) {
    var _a;
    const newHeight = distHeight - Math.floor(padding[0] + padding[2]), textMark = cellGroup.getChildByName("text");
    if (textMark instanceof Text && !autoRowHeight) textMark.setAttributes({
        heightLimit: !1 === (null === (_a = table.options.customConfig) || void 0 === _a ? void 0 : _a.limitContentHeight) ? -1 : newHeight
    }); else if (textMark instanceof RichText && !autoRowHeight) textMark.setAttributes({
        height: newHeight
    }); else if (cellGroup.getChildByName("content")) {
        cellGroup.getChildByName("content").updateHeight(newHeight);
    }
    cellGroup.forEachChildren((child => {
        child.setAttribute("dy", 0), "rect" === child.type || "chart" === child.type || child.name === CUSTOM_CONTAINER_NAME || ("mark" === child.name ? child.setAttribute("y", 0) : "middle" === textBaseline ? child.setAttribute("y", padding[0] + (newHeight - child.AABBBounds.height()) / 2) : "bottom" === textBaseline ? child.setAttribute("y", padding[0] + newHeight - child.AABBBounds.height()) : child.setAttribute("y", padding[0]));
    }));
}

function isCellHeightUpdate(scene, cellGroup, newHeight, oldHeight) {
    const table = scene.table, mergeInfo = getCellMergeInfo(table, cellGroup.col, cellGroup.row);
    if (mergeInfo && mergeInfo.end.row - mergeInfo.start.row) {
        oldHeight /= mergeInfo.end.row - mergeInfo.start.row + 1, newHeight /= mergeInfo.end.row - mergeInfo.start.row + 1;
        for (let rowIndex = mergeInfo.start.row; rowIndex <= mergeInfo.end.row; rowIndex++) {
            const rowHeight = table.getRowHeight(rowIndex);
            if (rowHeight === oldHeight && newHeight !== rowHeight) return !0;
            if (newHeight > rowHeight) return !0;
        }
    } else {
        const rowHeight = table.getRowHeight(cellGroup.row);
        if (rowHeight === oldHeight && newHeight !== rowHeight) return !0;
        if (newHeight > rowHeight) return !0;
    }
    return !1;
}

export function dealWithIconLayout(icons, cellGroup, range, table) {
    const leftIcons = [], rightIcons = [], contentLeftIcons = [], contentRightIcons = [], inlineFrontIcons = [], inlineEndIcons = [], absoluteLeftIcons = [], absoluteRightIcons = [];
    let leftIconWidth = 0, leftIconHeight = 0, rightIconWidth = 0, rightIconHeight = 0, absoluteLeftIconWidth = 0, absoluteRightIconWidth = 0;
    return icons.forEach((icon => {
        switch (icon.positionType) {
          case IconPosition.left:
            leftIcons.push(icon);
            break;

          case IconPosition.right:
            rightIcons.push(icon);
            break;

          case IconPosition.contentLeft:
            contentLeftIcons.push(icon);
            break;

          case IconPosition.contentRight:
            contentRightIcons.push(icon);
            break;

          case IconPosition.absoluteRight:
            absoluteRightIcons.push(icon);
            break;

          case IconPosition.inlineFront:
            inlineFrontIcons.push(icon);
            break;

          case IconPosition.inlineEnd:
            inlineEndIcons.push(icon);
        }
    })), leftIcons.forEach((icon => {
        var _a, _b, _c;
        const iconMark = dealWithIcon(icon, void 0, cellGroup.col, cellGroup.row, range, table);
        iconMark.role = "icon-left", iconMark.name = icon.name, iconMark.setAttribute("x", leftIconWidth + (null !== (_a = iconMark.attribute.marginLeft) && void 0 !== _a ? _a : 0)), 
        leftIconWidth += iconMark.AABBBounds.width() + (null !== (_b = iconMark.attribute.marginLeft) && void 0 !== _b ? _b : 0) + (null !== (_c = iconMark.attribute.marginRight) && void 0 !== _c ? _c : 0), 
        leftIconHeight = Math.max(leftIconHeight, iconMark.AABBBounds.height()), cellGroup.appendChild(iconMark);
    })), rightIcons.forEach((icon => {
        var _a, _b, _c;
        const iconMark = dealWithIcon(icon, void 0, cellGroup.col, cellGroup.row, range, table);
        iconMark.role = "icon-right", iconMark.name = icon.name, iconMark.setAttribute("x", rightIconWidth + (null !== (_a = iconMark.attribute.marginLeft) && void 0 !== _a ? _a : 0)), 
        rightIconWidth += iconMark.AABBBounds.width() + (null !== (_b = iconMark.attribute.marginLeft) && void 0 !== _b ? _b : 0) + (null !== (_c = iconMark.attribute.marginRight) && void 0 !== _c ? _c : 0), 
        rightIconHeight = Math.max(rightIconHeight, iconMark.AABBBounds.height()), cellGroup.appendChild(iconMark);
    })), absoluteLeftIcons.forEach((icon => {
        var _a, _b, _c;
        const iconMark = dealWithIcon(icon, void 0, cellGroup.col, cellGroup.row, range, table);
        iconMark.role = "icon-absolute-left", iconMark.name = icon.name, iconMark.setAttribute("x", absoluteLeftIconWidth + (null !== (_a = iconMark.attribute.marginLeft) && void 0 !== _a ? _a : 0)), 
        absoluteLeftIconWidth += iconMark.AABBBounds.width() + (null !== (_b = iconMark.attribute.marginLeft) && void 0 !== _b ? _b : 0) + (null !== (_c = iconMark.attribute.marginRight) && void 0 !== _c ? _c : 0), 
        cellGroup.appendChild(iconMark);
    })), absoluteRightIcons.forEach((icon => {
        var _a, _b, _c;
        const iconMark = dealWithIcon(icon, void 0, cellGroup.col, cellGroup.row, range, table);
        iconMark.role = "icon-absolute-right", iconMark.name = icon.name, iconMark.setAttribute("x", absoluteRightIconWidth + (null !== (_a = iconMark.attribute.marginLeft) && void 0 !== _a ? _a : 0)), 
        absoluteRightIconWidth += iconMark.AABBBounds.width() + (null !== (_b = iconMark.attribute.marginLeft) && void 0 !== _b ? _b : 0) + (null !== (_c = iconMark.attribute.marginRight) && void 0 !== _c ? _c : 0), 
        cellGroup.appendChild(iconMark);
    })), {
        leftIcons: leftIcons,
        rightIcons: rightIcons,
        contentLeftIcons: contentLeftIcons,
        contentRightIcons: contentRightIcons,
        inlineFrontIcons: inlineFrontIcons,
        inlineEndIcons: inlineEndIcons,
        absoluteLeftIcons: absoluteLeftIcons,
        absoluteRightIcons: absoluteRightIcons,
        leftIconWidth: leftIconWidth,
        leftIconHeight: leftIconHeight,
        rightIconWidth: rightIconWidth,
        rightIconHeight: rightIconHeight,
        absoluteLeftIconWidth: absoluteLeftIconWidth,
        absoluteRightIconWidth: absoluteRightIconWidth
    };
}

function onBeforeAttributeUpdate(val, attribute) {
    if (val.hasOwnProperty("hoverIconId")) {
        const graphic = this;
        if (graphic.skipMergeUpdate) return;
        const cellGroup = getTargetCell(graphic);
        if (!cellGroup || !cellGroup.stage) return;
        const table = cellGroup.stage.table;
        graphic.skipAttributeUpdate = !0;
        const {mergeStartCol: mergeStartCol, mergeEndCol: mergeEndCol, mergeStartRow: mergeStartRow, mergeEndRow: mergeEndRow} = cellGroup;
        if (isValid(mergeStartCol) && isValid(mergeEndCol) && isValid(mergeStartRow) && isValid(mergeEndRow) && (mergeStartCol !== mergeEndCol || mergeStartRow !== mergeEndRow)) {
            for (let col = mergeStartCol; col <= mergeEndCol; col++) for (let row = mergeStartRow; row <= mergeEndRow; row++) {
                if (col === cellGroup.col && row === cellGroup.row) {
                    if (val.hoverIconId !== graphic.attribute.hoverIconId) {
                        const icon = graphic._frameCache.icons.get(val.hoverIconId);
                        graphic.updateHoverIconState(icon);
                    }
                    continue;
                }
                const cell = table.scenegraph.highPerformanceGetCell(col, row);
                if ("cell" === cell.role) {
                    const target = cell.getChildByName(graphic.name, !0);
                    if (!target || target.skipAttributeUpdate) continue;
                    val.hoverIconId !== target.attribute.hoverIconId && (target.setAttribute("hoverIconId", val.hoverIconId), 
                    cell.addUpdateBoundTag());
                }
            }
            graphic.skipAttributeUpdate = void 0;
        }
    }
}
//# sourceMappingURL=text-icon-layout.js.map
