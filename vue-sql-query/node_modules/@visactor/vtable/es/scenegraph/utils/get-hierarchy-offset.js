import { isArray, isValid } from "@visactor/vutils";

import { HierarchyState } from "../../ts-types";

export function getHierarchyOffset(col, row, table) {
    var _a, _b, _c, _d, _e;
    let cellHierarchyIndent = 0;
    const layoutMap = table.internalProps.layoutMap;
    if (layoutMap.isHeader(col, row)) {
        const hd = layoutMap.getHeader(col, row);
        isValid(null == hd ? void 0 : hd.hierarchyLevel) && (cellHierarchyIndent = (null !== (_a = hd.hierarchyLevel) && void 0 !== _a ? _a : 0) * ("tree" === layoutMap.rowHierarchyType && null !== (_b = layoutMap.rowHierarchyIndent) && void 0 !== _b ? _b : 0), 
        layoutMap.rowHierarchyTextStartAlignment && !table.internalProps.headerHelper.getHierarchyIcon(col, row) && (cellHierarchyIndent += table.internalProps.headerHelper.getHierarchyIconWidth()));
    } else if (table.options.groupBy || (null === (_c = table.getBodyColumnDefine(col, row)) || void 0 === _c ? void 0 : _c.tree)) {
        const indexArr = table.dataSource.getIndexKey(table.getRecordShowIndexByCell(col, row)), groupLength = null !== (_d = table.dataSource.getGroupLength()) && void 0 !== _d ? _d : 0;
        let indexArrLngth = isArray(indexArr) ? indexArr.length - 1 : 0;
        groupLength > 0 && indexArrLngth === groupLength && (indexArrLngth = 0), cellHierarchyIndent = Array.isArray(indexArr) && table.getHierarchyState(col, row) !== HierarchyState.none ? indexArrLngth * (null !== (_e = layoutMap.hierarchyIndent) && void 0 !== _e ? _e : 0) : 0, 
        layoutMap.hierarchyTextStartAlignment && !table.internalProps.bodyHelper.getHierarchyIcon(col, row) && (cellHierarchyIndent += table.internalProps.bodyHelper.getHierarchyIconWidth());
    }
    return cellHierarchyIndent;
}
//# sourceMappingURL=get-hierarchy-offset.js.map
