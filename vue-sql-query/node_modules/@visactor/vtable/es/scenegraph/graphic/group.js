import { Group as VRenderGroup } from "./../../vrender";

export class Group extends VRenderGroup {
    clear() {
        this.removeAllChild();
    }
    getChildByName(name, deep) {
        let result = null;
        return this.forEachChildren((child => child.name === name && (result = child, !0))), 
        deep && this.forEachChildren((child => {
            if (child.getChildByName) {
                const target = child.getChildByName(name, !0);
                if (target) return result = target, !0;
            }
            return !1;
        })), result;
    }
    get width() {
        var _a;
        let width = this.AABBBounds.width();
        return width !== 1 / 0 && width !== -1 / 0 || (width = 0), Math.max(width, null !== (_a = this.attribute.width) && void 0 !== _a ? _a : 0);
    }
    get height() {
        var _a;
        let height = this.AABBBounds.height();
        return height !== 1 / 0 && height !== -1 / 0 || (height = 0), Math.max(height, null !== (_a = this.attribute.height) && void 0 !== _a ? _a : 0);
    }
    setDeltaWidth(deltaX) {
        var _a;
        0 !== deltaX && (this.setAttribute("width", (null !== (_a = this.attribute.width) && void 0 !== _a ? _a : 0) + deltaX), 
        this.border && (this.border.setAttribute("width", this.border.attribute.width + deltaX), 
        "group" === this.border.type && this.border.firstChild.setAttribute("width", this.border.firstChild.attribute.width + deltaX)));
    }
    setDeltaHeight(deltaY) {
        var _a;
        0 !== deltaY && (this.setAttribute("height", (null !== (_a = this.attribute.height) && void 0 !== _a ? _a : 0) + deltaY), 
        this.border && (this.border.setAttribute("height", this.border.attribute.height + deltaY), 
        "group" === this.border.type && this.border.firstChild.setAttribute("width", this.border.firstChild.attribute.height + deltaY)));
    }
    setDeltaX(deltaX) {
        0 !== deltaX && this.setAttribute("x", this.attribute.x + deltaX);
    }
    setDeltaY(deltaY) {
        0 !== deltaY && this.setAttribute("y", this.attribute.y + deltaY);
    }
    forEachChildrenSkipChild(cb, skipChildName = "border-rect", reverse = !1) {
        if (reverse) {
            let child = this._lastChild, i = 0;
            for (;child; ) {
                if (child.name !== skipChildName) {
                    if (cb(child, i++)) return;
                }
                child = child._prev;
            }
        } else {
            let child = this._firstChild, i = 0;
            for (;child; ) {
                if (child.name !== skipChildName) {
                    if (cb(child, i++)) return;
                }
                child = child._next;
            }
        }
    }
    getColGroup(col) {
        let c = this._firstChild;
        if (!c) return null;
        for (let i = 0; i < this.childrenCount; i++) {
            if (c.col === col) return c;
            c = c._next;
        }
        return null;
    }
    getRowGroup(row) {
        let c = this._firstChild;
        if (!c) return null;
        for (let i = 0; i < this.childrenCount; i++) {
            if (c.row === row) return c;
            c = c._next;
        }
        return null;
    }
    addCellGroup(cellGroup) {
        if (0 === this.childrenCount || this.lastChild.row === cellGroup.row - 1) this.addChild(cellGroup); else {
            let c = this._firstChild;
            for (let i = 0; i < this.childrenCount; i++) {
                if (c.row === cellGroup.row - 1) return void this.insertAfter(cellGroup, c);
                c = c._next;
            }
            this.addChild(cellGroup);
        }
    }
    getChildAt(index) {
        const child = super.getChildAt(index);
        return child && "border-rect" === child.name ? child._next : child;
    }
    tryUpdateAABBBounds() {
        if ("cell" === this.role) {
            if (!this.shouldUpdateAABBBounds()) return this._AABBBounds;
            const selfChange = this.shouldSelfChangeUpdateAABBBounds(), bounds = this.doUpdateAABBBounds();
            return this.addUpdateLayoutTag(), after(this, selfChange), bounds;
        }
        return super.tryUpdateAABBBounds();
    }
    doUpdateAABBBounds() {
        if ("cell" === this.role) {
            const attribute = this.attribute, {x: x, y: y, width: width, height: height} = attribute;
            return this._AABBBounds.setValue(x, y, x + width, y + height), this.parent && this.parent.addChildUpdateBoundTag(), 
            this.clearUpdateBoundTag(), this.shadowRoot && this.shadowRoot.tryUpdateAABBBounds(), 
            this._AABBBounds;
        }
        return "body" === this.role || "row-header" === this.role || "col-header" === this.role || "right-frozen" === this.role || "bottom-frozen" === this.role || "corner-header" === this.role || "corner-right-top-header" === this.role || "corner-right-bottom-header" === this.role || "corner-left-bottom-header" === this.role ? (this._AABBBounds.setValue(-1 / 0, -1 / 0, 1 / 0, 1 / 0), 
        this.parent && this.parent.addChildUpdateBoundTag(), this.clearUpdateBoundTag(), 
        this.shadowRoot && this.shadowRoot.tryUpdateAABBBounds(), this._AABBBounds) : super.doUpdateAABBBounds();
    }
    updateColumnRowNumber(row) {
        this.rowNumber ? this.rowNumber = Math.max(this.rowNumber, row) : this.rowNumber = row;
    }
    updateColumnHeight(cellHeight) {
        this.colHeight ? this.colHeight += cellHeight : this.colHeight = cellHeight;
    }
}

function after(group, selfChange) {
    group.stage && group.stage.dirtyBounds && group.stage.renderCount && (group.isContainer && !selfChange || group.stage.dirty(group.globalAABBBounds));
}
//# sourceMappingURL=group.js.map
