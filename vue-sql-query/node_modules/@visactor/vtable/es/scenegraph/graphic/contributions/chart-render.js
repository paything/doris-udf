var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

import { getTheme, injectable, BaseRender } from "./../../../vrender";

import { CHART_NUMBER_TYPE } from "../chart";

import { IsHandlingChartQueue, chartRenderKeys, chartRenderQueueList, renderChart, startRenderChartQueue } from "./chart-render-helper";

import { isArray } from "@visactor/vutils";

export const ChartRender = Symbol.for("ChartRender");

export const ChartRenderContribution = Symbol.for("ChartRenderContribution");

let DefaultCanvasChartRender = class extends BaseRender {
    constructor() {
        super(...arguments), this.numberType = CHART_NUMBER_TYPE;
    }
    drawShape(chart, context, x, y, drawContext, params, fillCb, strokeCb) {
        var _a, _b, _c, _d;
        const groupAttribute = getTheme(chart, null == params ? void 0 : params.theme).group, {dataId: dataId, data: data, spec: spec} = chart.attribute, {width: width = groupAttribute.width, height: height = groupAttribute.height} = (chart.getViewBox(), 
        chart.attribute), {table: table} = chart.getRootNode(), {active: active, cacheCanvas: cacheCanvas, activeChartInstance: activeChartInstance} = chart;
        if (!active && cacheCanvas) isArray(cacheCanvas) ? cacheCanvas.forEach((singleCacheCanvas => {
            const {x: x, y: y, width: width, height: height, canvas: canvas} = singleCacheCanvas;
            context.drawImage(canvas, x, y, width, height);
        })) : context.drawImage(cacheCanvas, x, y, width, height); else if (activeChartInstance) {
            if (table.options.specFormat) {
                const formatResult = table.options.specFormat(chart.attribute.spec, activeChartInstance, chart);
                if (formatResult.needFormatSpec && formatResult.spec) {
                    const spec = formatResult.spec;
                    activeChartInstance.updateSpecSync(spec);
                }
            }
            const viewBox = chart.getViewBox();
            activeChartInstance.updateViewBox({
                x1: 0,
                x2: viewBox.x2 - viewBox.x1,
                y1: 0,
                y2: viewBox.y2 - viewBox.y1
            }, !1, !1);
            const chartStage = activeChartInstance.getStage();
            chartStage.needRender = !0;
            const matrix = chart.globalTransMatrix.clone(), stageMatrix = chart.stage.window.getViewBoxTransform().clone();
            if (stageMatrix.multiply(matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f), 
            chartStage.window.setViewBoxTransform(stageMatrix.a, stageMatrix.b, stageMatrix.c, stageMatrix.d, stageMatrix.e, stageMatrix.f), 
            "string" == typeof dataId) activeChartInstance.updateDataSync(dataId, null != data ? data : []); else {
                const dataBatch = [];
                for (const dataIdStr in dataId) {
                    const dataIdAndField = dataId[dataIdStr], series = spec.series.find((item => {
                        var _a;
                        return (null === (_a = null == item ? void 0 : item.data) || void 0 === _a ? void 0 : _a.id) === dataIdStr;
                    }));
                    dataBatch.push({
                        id: dataIdStr,
                        values: dataIdAndField ? null !== (_a = null == data ? void 0 : data.filter((item => item.hasOwnProperty(dataIdAndField)))) && void 0 !== _a ? _a : [] : null != data ? data : [],
                        fields: null === (_b = null == series ? void 0 : series.data) || void 0 === _b ? void 0 : _b.fields
                    }), activeChartInstance.updateFullDataSync || activeChartInstance.updateDataSync(dataIdStr, dataIdAndField ? null !== (_c = null == data ? void 0 : data.filter((item => item.hasOwnProperty(dataIdAndField)))) && void 0 !== _c ? _c : [] : null != data ? data : []);
                }
                null === (_d = activeChartInstance.updateFullDataSync) || void 0 === _d || _d.call(activeChartInstance, dataBatch);
            }
        } else table.internalProps.renderChartAsync ? (-1 === chartRenderKeys.indexOf(`${chart.parent.col}+${chart.parent.row}`) && (chartRenderKeys.push(`${chart.parent.col}+${chart.parent.row}`), 
        chartRenderQueueList.push(chart)), IsHandlingChartQueue() || startRenderChartQueue(table)) : renderChart(chart);
    }
    draw(chart, renderService, drawContext, params) {
        this._draw(chart, {}, !1, drawContext, params);
    }
};

DefaultCanvasChartRender = __decorate([ injectable() ], DefaultCanvasChartRender);

export { DefaultCanvasChartRender };
//# sourceMappingURL=chart-render.js.map
