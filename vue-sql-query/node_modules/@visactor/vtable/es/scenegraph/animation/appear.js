export function dealWithAnimationAppear(table) {
    var _a, _b, _c, _d;
    if (!table.options.animationAppear) return;
    let duration, delay, type, direction;
    !0 === table.options.animationAppear ? (duration = 500, delay = 0, type = "one-by-one", 
    direction = "column") : (duration = null !== (_a = table.options.animationAppear.duration) && void 0 !== _a ? _a : 500, 
    delay = null !== (_b = table.options.animationAppear.delay) && void 0 !== _b ? _b : 0, 
    type = null !== (_c = table.options.animationAppear.type) && void 0 !== _c ? _c : "one-by-one", 
    direction = null !== (_d = table.options.animationAppear.direction) && void 0 !== _d ? _d : "row");
    const {scenegraph: scene, frozenColCount: frozenColCount, frozenRowCount: frozenRowCount} = table, {colStart: colStart, colEnd: colEnd, rowStart: rowStart, rowEnd: rowEnd} = scene.proxy;
    for (let col = 0; col <= colEnd; col++) for (let row = 0; row <= rowEnd; row++) {
        const cellGroup = scene.highPerformanceGetCell(col, row);
        cellGroup && "cell" === cellGroup.role && cellGroup.forEachChildren((child => {
            child.setAttribute("opacity", 0), child.animate().wait("one-by-one" === type ? ("row" === direction ? row : col) * (duration - delay) : delay).to({
                opacity: 1
            }, duration, "linear");
        }));
    }
}
//# sourceMappingURL=appear.js.map
