import { isArray, isNumber } from "@visactor/vutils";

import { setCellCheckboxStateByAttribute } from "../../../state/checkbox/checkbox";

import { HierarchyState } from "../../../ts-types";

export function bindGroupTitleCheckboxChange(table) {
    table.on("checkbox_state_change", (args => {
        var _a, _b;
        const {col: col, row: row, checked: checked, field: field} = args;
        if ("_vtable_rowSeries_number" !== field || !0 !== (null === (_a = table.internalProps.rowSeriesNumber) || void 0 === _a ? void 0 : _a.enableTreeCheckbox)) return;
        if (table.isHeader(col, row)) return;
        const record = table.getCellOriginRecord(col, row), indexedData = table.dataSource.currentPagerIndexedData, titleShowIndex = table.getRecordShowIndexByCell(col, row);
        let titleIndex = indexedData[titleShowIndex];
        if (isNumber(titleIndex) && (titleIndex = [ titleIndex ]), record.vtableMerge || (null === (_b = record.children) || void 0 === _b ? void 0 : _b.length)) if (checked) getHierarchyState(table, col, row) === HierarchyState.collapse ? updateChildrenCheckboxState(!0, titleIndex, table) : setAllChildrenCheckboxState(!0, titleShowIndex, titleIndex, indexedData, table), 
        updateGroupTitleCheckboxState(titleShowIndex, titleIndex, indexedData, table); else {
            getHierarchyState(table, col, row) === HierarchyState.collapse ? updateChildrenCheckboxState(!1, titleIndex, table) : setAllChildrenCheckboxState(!1, titleShowIndex, titleIndex, indexedData, table), 
            updateGroupTitleCheckboxState(titleShowIndex, titleIndex, indexedData, table);
            const oldHeaderCheckedState = table.stateManager.headerCheckedState._vtable_rowSeries_number, newHeaderCheckedState = table.stateManager.updateHeaderCheckedState("_vtable_rowSeries_number", col, row);
            oldHeaderCheckedState !== newHeaderCheckedState && table.scenegraph.updateHeaderCheckboxCellState(col, row, newHeaderCheckedState);
        } else updateGroupTitleCheckboxState(titleShowIndex, titleIndex, indexedData, table);
    }));
}

function setAllChildrenCheckboxState(state, titleShowIndex, titleIndex, indexedData, table) {
    var _a;
    let i = titleShowIndex + 1;
    for (;isArray(indexedData[i]) && (null === (_a = indexedData[i]) || void 0 === _a ? void 0 : _a.length) > titleIndex.length; ) {
        const row = table.columnHeaderLevelCount + i;
        table.stateManager.setCheckedState(0, row, "_vtable_rowSeries_number", state), setCellCheckboxStateByAttribute(0, row, state, table), 
        i++;
    }
}

function updateGroupTitleCheckboxState(titleShowIndex, titleIndex, indexedData, table) {
    var _a;
    let parentLength = titleIndex.length - 1;
    if (parentLength > 0) {
        let i = titleShowIndex - 1;
        for (;parentLength > 0 && i >= 0; ) {
            if (isArray(indexedData[i]) && (null === (_a = indexedData[i]) || void 0 === _a ? void 0 : _a.length) === parentLength || 1 === parentLength && isNumber(indexedData[i])) {
                updateParentCheckboxState(0, table.columnHeaderLevelCount + i, indexedData[i], table), 
                parentLength--;
            }
            i--;
        }
    }
}

function updateParentCheckboxState(col, row, currentIndex, table) {
    const {checkedState: checkedState} = table.stateManager, key = currentIndex.toString(), currentIndexLength = isArray(currentIndex) ? currentIndex.length : 1;
    let start = !1;
    const result = [], keys = Array.from(checkedState.keys()).sort(((a, b) => {
        var _a, _b;
        const aArr = a.split(","), bArr = b.split(","), maxLength = Math.max(aArr.length, bArr.length);
        for (let i = 0; i < maxLength; i++) {
            const a = null !== (_a = Number(aArr[i])) && void 0 !== _a ? _a : 0, b = null !== (_b = Number(bArr[i])) && void 0 !== _b ? _b : 0;
            if (a !== b) return a - b;
        }
        return 0;
    })), stateArr = keys.map((key => checkedState.get(key)));
    if (stateArr.forEach(((state, i) => {
        const index = keys[i], value = state;
        if (start) {
            index.split(",").length === currentIndexLength ? start = !1 : result.push(value._vtable_rowSeries_number);
        }
        index === key && (start = !0);
    })), 0 === result.length) return;
    const allChecked = result.every((item => !!item)), allUnChecked = result.every((item => !item));
    allChecked ? (table.stateManager.setCheckedState(col, row, "_vtable_rowSeries_number", !0), 
    setCellCheckboxStateByAttribute(col, row, !0, table)) : allUnChecked ? (table.stateManager.setCheckedState(col, row, "_vtable_rowSeries_number", !1), 
    setCellCheckboxStateByAttribute(col, row, !1, table)) : (table.stateManager.setCheckedState(col, row, "_vtable_rowSeries_number", "indeterminate"), 
    setCellCheckboxStateByAttribute(col, row, "indeterminate", table));
}

function updateChildrenCheckboxState(parentState, currentIndex, table) {
    const {checkedState: checkedState} = table.stateManager, key = currentIndex.toString(), currentIndexLength = isArray(currentIndex) ? currentIndex.length : 1;
    let start = !1;
    const keys = Array.from(checkedState.keys()).sort(((a, b) => {
        var _a, _b;
        const aArr = a.split(","), bArr = b.split(","), maxLength = Math.max(aArr.length, bArr.length);
        for (let i = 0; i < maxLength; i++) {
            const a = null !== (_a = Number(aArr[i])) && void 0 !== _a ? _a : 0, b = null !== (_b = Number(bArr[i])) && void 0 !== _b ? _b : 0;
            if (a !== b) return a - b;
        }
        return 0;
    })), stateArr = keys.map((key => checkedState.get(key)));
    stateArr.forEach(((state, i) => {
        const index = keys[i], value = state;
        if (start) {
            index.split(",").length === currentIndexLength ? start = !1 : value._vtable_rowSeries_number = parentState;
        }
        index === key && (start = !0);
    }));
}

export function bindHeaderCheckboxChange(table) {
    table.on("checkbox_state_change", (args => {
        const {col: col, row: row, checked: checked, field: field} = args;
        if (table.isHeader(col, row)) {
            table.stateManager.setHeaderCheckedState(field, checked);
            "checkbox" === table.getCellType(col, row) && table.scenegraph.updateCheckboxCellState(col, row, checked);
        } else {
            table.stateManager.setCheckedState(col, row, field, checked);
            if ("checkbox" === table.getCellType(col, row)) {
                const oldHeaderCheckedState = table.stateManager.headerCheckedState[field], newHeaderCheckedState = table.stateManager.updateHeaderCheckedState(field, col, row);
                oldHeaderCheckedState !== newHeaderCheckedState && table.scenegraph.updateHeaderCheckboxCellState(col, row, newHeaderCheckedState);
            }
        }
    }));
}

function getHierarchyState(table, col, row) {
    const index = table.getRecordShowIndexByCell(col, row);
    return table.dataSource.getHierarchyState(index);
}
//# sourceMappingURL=checkbox.js.map
