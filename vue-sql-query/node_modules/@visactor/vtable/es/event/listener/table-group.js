import { Gesture } from "./../../vrender";

import { IconFuncTypeEnum, InteractionState } from "../../ts-types";

import { getCellEventArgsSet, regIndexReg } from "../util";

import { TABLE_EVENT_TYPE } from "../../core/TABLE_EVENT_TYPE";

import { isValid } from "@visactor/vutils";

import { getIconAndPositionFromTarget } from "../../scenegraph/utils/icon";

import { cellInRanges, getPromiseValue } from "../../tools/helper";

import { Rect } from "../../tools/Rect";

import { getCellMergeInfo } from "../../scenegraph/utils/get-cell-merge";

import { handleWhell } from "../scroll";

import { fireMoveColEventListeners } from "../helper";

export function bindTableGroupListener(eventManager) {
    const table = eventManager.table, stateManager = table.stateManager;
    table.scenegraph.tableGroup.addEventListener("pointermove", (e => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u;
        const lastX = null !== (_b = null === (_a = table.eventManager.LastPointerXY) || void 0 === _a ? void 0 : _a.x) && void 0 !== _b ? _b : e.x, lastY = null !== (_d = null === (_c = table.eventManager.LastPointerXY) || void 0 === _c ? void 0 : _c.y) && void 0 !== _d ? _d : e.y;
        table.eventManager.LastPointerXY = {
            x: e.x,
            y: e.y
        }, eventManager.touchSetTimeout && (clearTimeout(eventManager.touchSetTimeout), 
        eventManager.touchSetTimeout = void 0);
        const eventArgsSet = getCellEventArgsSet(e);
        if (eventArgsSet.eventArgs && table.hasListeners(TABLE_EVENT_TYPE.MOUSEMOVE_TABLE) && table.fireListeners(TABLE_EVENT_TYPE.MOUSEMOVE_TABLE, {
            col: eventArgsSet.eventArgs.col,
            row: eventArgsSet.eventArgs.row,
            x: eventArgsSet.abstractPos.x,
            y: eventArgsSet.abstractPos.y,
            event: e.nativeEvent,
            target: null === (_e = null == eventArgsSet ? void 0 : eventArgsSet.eventArgs) || void 0 === _e ? void 0 : _e.target,
            mergeCellInfo: null === (_f = eventArgsSet.eventArgs) || void 0 === _f ? void 0 : _f.mergeInfo
        }), stateManager.interactionState === InteractionState.grabing && !(null === (_g = table.editorManager) || void 0 === _g ? void 0 : _g.editingEditor)) return void (Math.abs(lastX - e.x) + Math.abs(lastY - e.y) >= 1 && (stateManager.isResizeCol() || stateManager.isResizeRow() || (stateManager.isMoveCol() ? eventManager.dealColumnMover(eventArgsSet) : stateManager.isFillHandle() ? eventManager.dealFillSelect(eventArgsSet, !0) : (null === (_h = table.options.select) || void 0 === _h ? void 0 : _h.disableDragSelect) || eventManager.dealTableSelect(eventArgsSet, !0))));
        !(null === (_j = table.options.select) || void 0 === _j ? void 0 : _j.disableDragSelect) && table.eventManager.isDraging && stateManager.isSelecting() && !(null === (_k = table.editorManager) || void 0 === _k ? void 0 : _k.editingEditor) && eventManager.dealTableSelect(eventArgsSet, !0);
        const cellGoup = e.path.find((node => "cell" === node.role));
        if (table.hasListeners(TABLE_EVENT_TYPE.MOUSELEAVE_CELL) && (-1 === table.stateManager.hover.cellPos.col || -1 === table.stateManager.hover.cellPos.row || (null == cellGoup ? void 0 : cellGoup.col) === table.stateManager.hover.cellPos.col && (null == cellGoup ? void 0 : cellGoup.row) === table.stateManager.hover.cellPos.row || table.fireListeners(TABLE_EVENT_TYPE.MOUSELEAVE_CELL, {
            col: table.stateManager.hover.cellPos.col,
            row: table.stateManager.hover.cellPos.row,
            cellRange: table.getCellRangeRelativeRect({
                col: table.stateManager.hover.cellPos.col,
                row: table.stateManager.hover.cellPos.row
            }),
            scaleRatio: table.canvas.getBoundingClientRect().width / table.canvas.offsetWidth,
            event: e.nativeEvent,
            target: null === (_l = null == eventArgsSet ? void 0 : eventArgsSet.eventArgs) || void 0 === _l ? void 0 : _l.target
        })), table.hasListeners(TABLE_EVENT_TYPE.MOUSEENTER_CELL) && ("cell" !== (null == cellGoup ? void 0 : cellGoup.role) || !isValid(cellGoup.col) || !isValid(cellGoup.row) || cellGoup.col === table.stateManager.hover.cellPos.col && cellGoup.row === table.stateManager.hover.cellPos.row || cellGoup.col === (null === (_m = table.stateManager.hover.cellPosContainHeader) || void 0 === _m ? void 0 : _m.col) && cellGoup.row === (null === (_o = table.stateManager.hover.cellPosContainHeader) || void 0 === _o ? void 0 : _o.row) || table.fireListeners(TABLE_EVENT_TYPE.MOUSEENTER_CELL, {
            col: cellGoup.col,
            row: cellGoup.row,
            cellRange: table.getCellRangeRelativeRect({
                col: cellGoup.col,
                row: cellGoup.row
            }),
            scaleRatio: table.canvas.getBoundingClientRect().width / table.canvas.offsetWidth,
            event: e.nativeEvent,
            target: null === (_p = null == eventArgsSet ? void 0 : eventArgsSet.eventArgs) || void 0 === _p ? void 0 : _p.target,
            mergeCellInfo: null === (_q = eventArgsSet.eventArgs) || void 0 === _q ? void 0 : _q.mergeInfo
        })), eventManager.dealIconHover(eventArgsSet), eventManager.dealTableHover(eventArgsSet), 
        table.theme.columnResize.visibleOnHover && eventManager.checkColumnResize(eventArgsSet, !0), 
        eventArgsSet.eventArgs && table.hasListeners(TABLE_EVENT_TYPE.MOUSEMOVE_CELL)) {
            let icon, position;
            if (null === (_r = eventArgsSet.eventArgs) || void 0 === _r ? void 0 : _r.target) {
                const iconInfo = getIconAndPositionFromTarget(null === (_s = eventArgsSet.eventArgs) || void 0 === _s ? void 0 : _s.target);
                iconInfo && (icon = iconInfo.icon, position = iconInfo.position);
            }
            table.fireListeners(TABLE_EVENT_TYPE.MOUSEMOVE_CELL, {
                col: eventArgsSet.eventArgs.col,
                row: eventArgsSet.eventArgs.row,
                x: eventArgsSet.abstractPos.x,
                y: eventArgsSet.abstractPos.y,
                event: e.nativeEvent,
                targetIcon: icon ? {
                    name: icon.name,
                    position: position,
                    funcType: icon.attribute.funcType
                } : void 0,
                target: null === (_t = null == eventArgsSet ? void 0 : eventArgsSet.eventArgs) || void 0 === _t ? void 0 : _t.target,
                mergeCellInfo: null === (_u = eventArgsSet.eventArgs) || void 0 === _u ? void 0 : _u.mergeInfo
            });
        }
    })), table.scenegraph.tableGroup.addEventListener("pointerout", (e => {
        var _a;
        const eventArgsSet = getCellEventArgsSet(e), cellGoup = null === (_a = null == eventArgsSet ? void 0 : eventArgsSet.eventArgs) || void 0 === _a ? void 0 : _a.target;
        "table" === (null == cellGoup ? void 0 : cellGoup.role) && eventManager.dealTableHover();
    })), table.scenegraph.tableGroup.addEventListener("pointerover", (e => {
        var _a, _b;
        const eventArgsSet = getCellEventArgsSet(e), cellGoup = null === (_a = null == eventArgsSet ? void 0 : eventArgsSet.eventArgs) || void 0 === _a ? void 0 : _a.target;
        if (cellGoup && table.hasListeners(TABLE_EVENT_TYPE.MOUSEOVER_CHART_SYMBOL) && "symbol" === cellGoup.type) {
            const cellGroup = e.composedPath().find((p => "cell" === p.roll));
            if (cellGroup) {
                const {col: col, row: row} = cellGroup, eventInfo = {
                    col: col,
                    row: row,
                    field: table.getHeaderField(col, row),
                    value: table.getCellValue(col, row),
                    dataValue: table.getCellOriginValue(col, row),
                    cellHeaderPaths: table.internalProps.layoutMap.getCellHeaderPaths(col, row),
                    title: table.getBodyColumnDefine(col, row).title,
                    cellRange: table.getCellRelativeRect(col, row),
                    event: e.nativeEvent,
                    sparkline: {
                        pointData: void 0
                    },
                    scaleRatio: table.canvas.getBoundingClientRect().width / table.canvas.offsetWidth,
                    target: null === (_b = null == eventArgsSet ? void 0 : eventArgsSet.eventArgs) || void 0 === _b ? void 0 : _b.target
                };
                table.fireListeners(TABLE_EVENT_TYPE.MOUSEOVER_CHART_SYMBOL, eventInfo);
            }
        }
    })), table.scenegraph.tableGroup.addEventListener("pointerenter", (e => {
        (table.theme.scrollStyle.horizontalVisible && "focus" === table.theme.scrollStyle.horizontalVisible || !table.theme.scrollStyle.horizontalVisible && "focus" === table.theme.scrollStyle.visible) && stateManager.showHorizontalScrollBar(), 
        (table.theme.scrollStyle.verticalVisible && "focus" === table.theme.scrollStyle.verticalVisible || !table.theme.scrollStyle.verticalVisible && "focus" === table.theme.scrollStyle.visible) && stateManager.showVerticalScrollBar(), 
        table.hasListeners(TABLE_EVENT_TYPE.MOUSEENTER_TABLE) && table.fireListeners(TABLE_EVENT_TYPE.MOUSEENTER_TABLE, {
            event: e.nativeEvent
        });
    })), table.scenegraph.tableGroup.addEventListener("pointerleave", (e => {
        stateManager.isResizeCol() || stateManager.isResizeRow() || stateManager.isMoveCol() || stateManager.isSelecting() || (stateManager.updateInteractionState(InteractionState.default), 
        stateManager.updateCursor()), (table.theme.scrollStyle.horizontalVisible && "focus" === table.theme.scrollStyle.horizontalVisible || !table.theme.scrollStyle.horizontalVisible && "focus" === table.theme.scrollStyle.visible) && stateManager.hideHorizontalScrollBar(), 
        (table.theme.scrollStyle.verticalVisible && "focus" === table.theme.scrollStyle.verticalVisible || !table.theme.scrollStyle.verticalVisible && "focus" === table.theme.scrollStyle.visible) && stateManager.hideVerticalScrollBar(), 
        table.hasListeners(TABLE_EVENT_TYPE.MOUSELEAVE_CELL) && -1 !== table.stateManager.hover.cellPos.col && -1 !== table.stateManager.hover.cellPos.row && table.fireListeners(TABLE_EVENT_TYPE.MOUSELEAVE_CELL, {
            col: table.stateManager.hover.cellPos.col,
            row: table.stateManager.hover.cellPos.row,
            cellRange: table.getCellRangeRelativeRect({
                col: table.stateManager.hover.cellPos.col,
                row: table.stateManager.hover.cellPos.row
            }),
            scaleRatio: table.canvas.getBoundingClientRect().width / table.canvas.offsetWidth,
            event: e.nativeEvent,
            target: void 0
        }), eventManager.dealTableHover();
        const target = e.target;
        target && !target.isDescendantsOf(table.scenegraph.tableGroup) && table.fireListeners(TABLE_EVENT_TYPE.MOUSELEAVE_TABLE, {
            event: e.nativeEvent
        });
    })), table.scenegraph.tableGroup.addEventListener("pointerdown", (e => {
        var _a, _b, _c, _d, _e;
        if (table.hasListeners(TABLE_EVENT_TYPE.MOUSEDOWN_TABLE) && table.fireListeners(TABLE_EVENT_TYPE.MOUSEDOWN_TABLE, {
            event: e.nativeEvent
        }), table.eventManager.isDown = !0, table.eventManager.LastBodyPointerXY = {
            x: e.x,
            y: e.y
        }, table.eventManager.LastPointerXY = {
            x: e.x,
            y: e.y
        }, 0 !== e.button) return;
        const eventArgsSet = getCellEventArgsSet(e);
        if (eventManager.downIcon = void 0, stateManager.interactionState !== InteractionState.default) return;
        if (table.isPivotChart() && "chart" !== (null === (_a = null == eventArgsSet ? void 0 : eventArgsSet.eventArgs) || void 0 === _a ? void 0 : _a.target.type) && table.scenegraph.updateChartState(null), 
        (null === (_b = eventArgsSet.eventArgs) || void 0 === _b ? void 0 : _b.target) !== (null === (_c = stateManager.residentHoverIcon) || void 0 === _c ? void 0 : _c.icon) && stateManager.hideMenu(), 
        "chart" === (null === (_d = null == eventArgsSet ? void 0 : eventArgsSet.eventArgs) || void 0 === _d ? void 0 : _d.target.type)) return;
        const isCompleteEdit = null === (_e = table.editorManager) || void 0 === _e ? void 0 : _e.completeEdit(e.nativeEvent);
        getPromiseValue(isCompleteEdit, (isCompleteEdit => {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
            if (!1 === isCompleteEdit) return;
            const hitIcon = (null === (_c = null === (_b = null === (_a = null == eventArgsSet ? void 0 : eventArgsSet.eventArgs) || void 0 === _a ? void 0 : _a.target) || void 0 === _b ? void 0 : _b.role) || void 0 === _c ? void 0 : _c.startsWith("icon")) ? eventArgsSet.eventArgs.target : (null === (_d = e.target.role) || void 0 === _d ? void 0 : _d.startsWith("icon")) ? e.target : void 0;
            if (eventManager.downIcon = hitIcon, hitIcon && !1 !== hitIcon.attribute.interactive) hitIcon.attribute.funcType === IconFuncTypeEnum.dragReorder && (stateManager.startMoveCol(eventArgsSet.eventArgs.col, eventArgsSet.eventArgs.row, eventArgsSet.abstractPos.x, eventArgsSet.abstractPos.y, null === (_k = null === (_j = eventArgsSet.eventArgs) || void 0 === _j ? void 0 : _j.event) || void 0 === _k ? void 0 : _k.nativeEvent), 
            stateManager.updateInteractionState(InteractionState.grabing)); else {
                if (eventManager.cellIsHeaderCheck(eventArgsSet)) return;
                if ("touch" === e.pointerType) {
                    if (eventManager.touchEnd = !1, eventManager.touchSetTimeout = setTimeout((() => {
                        eventManager.isTouchdown = !1, eventManager.isLongTouch = !0, (eventManager.touchEnd || !eventManager.checkColumnResize(eventArgsSet, !0) && !eventManager.checkRowResize(eventArgsSet, !0)) && (eventManager.touchEnd || !eventManager.checkColumnMover(eventArgsSet)) ? eventManager.dealTableSelect(eventArgsSet) && !eventManager.touchEnd && stateManager.updateInteractionState(InteractionState.grabing) : stateManager.updateInteractionState(InteractionState.grabing);
                    }), 500), table.hasListeners(TABLE_EVENT_TYPE.MOUSEENTER_CELL)) {
                        const cellGoup = e.path.find((node => "cell" === node.role));
                        "cell" !== (null == cellGoup ? void 0 : cellGoup.role) || !isValid(cellGoup.col) || !isValid(cellGoup.row) || cellGoup.col === table.stateManager.hover.cellPos.col && cellGoup.row === table.stateManager.hover.cellPos.row || cellGoup.col === (null === (_e = table.stateManager.hover.cellPosContainHeader) || void 0 === _e ? void 0 : _e.col) && cellGoup.row === (null === (_f = table.stateManager.hover.cellPosContainHeader) || void 0 === _f ? void 0 : _f.row) || table.fireListeners(TABLE_EVENT_TYPE.MOUSEENTER_CELL, {
                            col: cellGoup.col,
                            row: cellGoup.row,
                            cellRange: table.getCellRangeRelativeRect({
                                col: cellGoup.col,
                                row: cellGoup.row
                            }),
                            scaleRatio: table.canvas.getBoundingClientRect().width / table.canvas.offsetWidth,
                            event: e.nativeEvent,
                            target: null === (_g = null == eventArgsSet ? void 0 : eventArgsSet.eventArgs) || void 0 === _g ? void 0 : _g.target,
                            mergeCellInfo: null === (_h = eventArgsSet.eventArgs) || void 0 === _h ? void 0 : _h.mergeInfo
                        });
                    }
                    eventManager.dealTableHover(eventArgsSet);
                } else {
                    if (!eventManager.checkCellFillhandle(eventArgsSet) && (eventManager.checkColumnResize(eventArgsSet, !0) || eventManager.checkRowResize(eventArgsSet, !0))) return table.scenegraph.updateChartState(null), 
                    void stateManager.updateInteractionState(InteractionState.grabing);
                    if (eventManager.checkColumnMover(eventArgsSet)) return void stateManager.updateInteractionState(InteractionState.grabing);
                    if (eventManager.checkCellFillhandle(eventArgsSet, !0) && eventManager.dealFillSelect(eventArgsSet)) return void stateManager.updateInteractionState(InteractionState.grabing);
                    eventManager.dealTableSelect(eventArgsSet) && stateManager.updateInteractionState(InteractionState.grabing);
                }
            }
            if (table.hasListeners(TABLE_EVENT_TYPE.MOUSEDOWN_CELL)) {
                const eventArgsSet = getCellEventArgsSet(e);
                eventArgsSet.eventArgs && table.fireListeners(TABLE_EVENT_TYPE.MOUSEDOWN_CELL, {
                    col: eventArgsSet.eventArgs.col,
                    row: eventArgsSet.eventArgs.row,
                    event: e.nativeEvent,
                    target: null === (_l = null == eventArgsSet ? void 0 : eventArgsSet.eventArgs) || void 0 === _l ? void 0 : _l.target,
                    mergeCellInfo: eventArgsSet.eventArgs.mergeInfo
                });
            }
        }));
    })), table.scenegraph.tableGroup.addEventListener("pointerup", (e => {
        var _a, _b, _c, _d;
        if (0 === e.button) {
            if ("grabing" === stateManager.interactionState) {
                if (stateManager.updateInteractionState(InteractionState.default), stateManager.isResizeCol()) endResizeCol(table); else if (stateManager.isResizeRow()) endResizeRow(table); else if (stateManager.isMoveCol()) {
                    const endMoveColSuccess = table.stateManager.endMoveCol();
                    fireMoveColEventListeners(table, endMoveColSuccess, e.nativeEvent);
                } else if (stateManager.isSelecting()) {
                    table.stateManager.endSelectCells(), table.stateManager.isFillHandle() && table.stateManager.endFillSelect();
                    const eventArgsSet = getCellEventArgsSet(e);
                    if (table.eventManager.isDraging && eventArgsSet.eventArgs && table.hasListeners(TABLE_EVENT_TYPE.DRAG_SELECT_END)) {
                        const cellsEvent = {
                            event: e.nativeEvent,
                            cells: [],
                            col: eventArgsSet.eventArgs.target.col,
                            row: eventArgsSet.eventArgs.target.row,
                            scaleRatio: table.canvas.getBoundingClientRect().width / table.canvas.offsetWidth,
                            target: null === (_a = null == eventArgsSet ? void 0 : eventArgsSet.eventArgs) || void 0 === _a ? void 0 : _a.target,
                            mergeCellInfo: null === (_b = eventArgsSet.eventArgs) || void 0 === _b ? void 0 : _b.mergeInfo
                        };
                        cellsEvent.cells = table.getSelectedCellInfos(), table.fireListeners(TABLE_EVENT_TYPE.DRAG_SELECT_END, cellsEvent);
                    }
                }
            } else stateManager.interactionState === InteractionState.scrolling && stateManager.updateInteractionState(InteractionState.default);
            if (table.hasListeners(TABLE_EVENT_TYPE.MOUSEUP_CELL)) {
                const eventArgsSet = getCellEventArgsSet(e);
                eventArgsSet.eventArgs && table.fireListeners(TABLE_EVENT_TYPE.MOUSEUP_CELL, {
                    col: eventArgsSet.eventArgs.col,
                    row: eventArgsSet.eventArgs.row,
                    event: e.nativeEvent,
                    target: null === (_c = null == eventArgsSet ? void 0 : eventArgsSet.eventArgs) || void 0 === _c ? void 0 : _c.target,
                    mergeCellInfo: null === (_d = eventArgsSet.eventArgs) || void 0 === _d ? void 0 : _d.mergeInfo
                });
            }
            setTimeout((() => {
                eventManager.isTouchdown = !1, eventManager.isTouchMove = !1, eventManager.isDraging = !1, 
                eventManager.touchMovePoints = [];
            }), 0);
        }
    })), table.scenegraph.tableGroup.addEventListener("rightdown", (e => {
        var _a, _b, _c, _d;
        const eventArgsSet = getCellEventArgsSet(e);
        if (eventArgsSet.eventArgs) {
            stateManager.triggerContextMenu(eventArgsSet.eventArgs.col, eventArgsSet.eventArgs.row, eventArgsSet.abstractPos.x, eventArgsSet.abstractPos.y);
            const {col: col, row: row} = eventArgsSet.eventArgs;
            if (table.hasListeners(TABLE_EVENT_TYPE.CONTEXTMENU_CELL)) {
                const cellInfo = table.getCellInfo(col, row);
                let icon, position;
                if (null === (_a = eventArgsSet.eventArgs) || void 0 === _a ? void 0 : _a.target) {
                    const iconInfo = getIconAndPositionFromTarget(null === (_b = eventArgsSet.eventArgs) || void 0 === _b ? void 0 : _b.target);
                    iconInfo && (icon = iconInfo.icon, position = iconInfo.position);
                }
                const cellsEvent = Object.assign(Object.assign({}, cellInfo), {
                    event: e.nativeEvent,
                    cells: [],
                    targetIcon: icon ? {
                        name: icon.name,
                        position: position,
                        funcType: icon.attribute.funcType
                    } : void 0,
                    target: null === (_c = null == eventArgsSet ? void 0 : eventArgsSet.eventArgs) || void 0 === _c ? void 0 : _c.target,
                    mergeCellInfo: null === (_d = eventArgsSet.eventArgs) || void 0 === _d ? void 0 : _d.mergeInfo
                });
                cellInRanges(table.stateManager.select.ranges, col, row) ? cellsEvent.cells = table.getSelectedCellInfos() : cellsEvent.cells = [ [ cellInfo ] ], 
                table.fireListeners(TABLE_EVENT_TYPE.CONTEXTMENU_CELL, cellsEvent);
            }
        }
    })), table.scenegraph.tableGroup.addEventListener("pointertap", (e => {
        var _a, _b, _c, _d, _e;
        if (table.stateManager.columnResize.resizing) return;
        const eventArgsSet = getCellEventArgsSet(e);
        if (!eventManager.isTouchMove && 0 === e.button && eventArgsSet.eventArgs && table.hasListeners(TABLE_EVENT_TYPE.CLICK_CELL)) {
            const {col: col, row: row} = eventArgsSet.eventArgs, cellInfo = table.getCellInfo(col, row);
            let icon, position;
            if (null === (_a = eventArgsSet.eventArgs) || void 0 === _a ? void 0 : _a.target) {
                const iconInfo = getIconAndPositionFromTarget(null === (_b = eventArgsSet.eventArgs) || void 0 === _b ? void 0 : _b.target);
                iconInfo && (icon = iconInfo.icon, position = iconInfo.position);
            }
            const cellsEvent = Object.assign(Object.assign({}, cellInfo), {
                event: e.nativeEvent,
                federatedEvent: e,
                cells: [],
                targetIcon: icon ? {
                    name: icon.name,
                    position: position,
                    funcType: icon.attribute.funcType
                } : void 0,
                target: null === (_c = null == eventArgsSet ? void 0 : eventArgsSet.eventArgs) || void 0 === _c ? void 0 : _c.target,
                mergeCellInfo: null === (_d = eventArgsSet.eventArgs) || void 0 === _d ? void 0 : _d.mergeInfo
            });
            table.fireListeners(TABLE_EVENT_TYPE.CLICK_CELL, cellsEvent);
        }
        if (!table.stateManager.columnResize.resizing && !table.stateManager.columnMove.moving && (eventManager.dealIconClick(e, eventArgsSet), 
        (null == eventArgsSet ? void 0 : eventArgsSet.eventArgs) && eventManager.touchSetTimeout && "touch" === e.pointerType)) {
            const eventArgsSet = getCellEventArgsSet(e);
            if (eventManager.touchSetTimeout) {
                clearTimeout(eventManager.touchSetTimeout);
                const isHasSelected = !!(null === (_e = stateManager.select.ranges) || void 0 === _e ? void 0 : _e.length);
                eventManager.dealTableSelect(eventArgsSet), stateManager.endSelectCells(!0, isHasSelected), 
                eventManager.touchSetTimeout = void 0;
            }
        }
    })), table.scenegraph.stage.addEventListener("pointerdown", (e => {
        var _a, _b, _c, _d;
        const eventArgsSet = getCellEventArgsSet(e);
        (null === (_a = eventArgsSet.eventArgs) || void 0 === _a ? void 0 : _a.target) && (null === (_b = eventArgsSet.eventArgs) || void 0 === _b ? void 0 : _b.target) === (null === (_c = stateManager.residentHoverIcon) || void 0 === _c ? void 0 : _c.icon) || stateManager.hideMenu();
        const isCompleteEdit = null === (_d = table.editorManager) || void 0 === _d ? void 0 : _d.completeEdit(e.nativeEvent);
        getPromiseValue(isCompleteEdit, (isCompleteEdit => {
            var _a;
            if (!1 === isCompleteEdit) return;
            const hitIcon = (null === (_a = e.target.role) || void 0 === _a ? void 0 : _a.startsWith("icon")) ? e.target : void 0;
            if (eventManager.downIcon = hitIcon, "touch" === e.pointerType || hitIcon || eventManager.checkCellFillhandle(eventArgsSet) || stateManager.columnResize.resizing || !eventManager.checkColumnResize(eventArgsSet, !0)) ; else {
                table.scenegraph.updateChartState(null), stateManager.updateInteractionState(InteractionState.grabing);
                const {eventArgs: eventArgs} = eventArgsSet;
                if (!(null == eventArgs ? void 0 : eventArgs.targetCell)) {
                    table.getCellAt(eventArgsSet.abstractPos.x - table.theme.columnResize.resizeHotSpotSize / 2, eventArgsSet.abstractPos.y) && table.hasListeners(TABLE_EVENT_TYPE.MOUSEDOWN_TABLE) && table.fireListeners(TABLE_EVENT_TYPE.MOUSEDOWN_TABLE, {
                        event: e.nativeEvent
                    });
                }
            }
        }));
    })), table.scenegraph.stage.addEventListener("pointerup", (e => {
        "grabing" === stateManager.interactionState && (stateManager.updateInteractionState(InteractionState.default), 
        stateManager.isResizeCol() ? endResizeCol(table) : stateManager.isResizeRow() && endResizeRow(table));
    })), table.scenegraph.stage.addEventListener("pointertap", (e => {
        var _a, _b, _c;
        const target = e.target;
        if (table.eventManager.isDraging || !target || !target.isDescendantsOf(table.scenegraph.stage) && target.stage !== target || target.isDescendantsOf(table.scenegraph.tableGroup)) table.eventManager.isDraging && stateManager.isSelecting() && stateManager.endSelectCells(); else {
            stateManager.updateInteractionState(InteractionState.default), eventManager.dealTableHover();
            const isHasSelected = !!(null === (_a = stateManager.select.ranges) || void 0 === _a ? void 0 : _a.length);
            (null === (_c = null === (_b = table.options.select) || void 0 === _b ? void 0 : _b.blankAreaClickDeselect) || void 0 === _c || _c) && eventManager.dealTableSelect(), 
            stateManager.endSelectCells(!0, isHasSelected), stateManager.updateCursor(), table.scenegraph.updateChartState(null);
        }
    })), table.scenegraph.stage.addEventListener("pointermove", (e => {
        const eventArgsSet = getCellEventArgsSet(e);
        stateManager.isResizeCol() || eventManager.checkColumnResize(eventArgsSet) ? table.stateManager.select && eventManager.checkCellFillhandle(eventArgsSet) ? stateManager.updateCursor("crosshair") : stateManager.updateCursor("col-resize") : stateManager.isResizeRow() || eventManager.checkRowResize(eventArgsSet) ? table.stateManager.select && eventManager.checkCellFillhandle(eventArgsSet) ? stateManager.updateCursor("crosshair") : stateManager.updateCursor("row-resize") : stateManager.isMoveCol() || stateManager.updateCursor();
    })), table.scenegraph.tableGroup.addEventListener("checkbox_state_change", (e => {
        var _a, _b;
        const eventArgsSet = getCellEventArgsSet(e), {col: col, row: row} = eventArgsSet.eventArgs, cellInfo = table.getCellInfo(col, row), mergeRange = getCellMergeInfo(table, col, row);
        if (mergeRange) for (let col = mergeRange.start.col; col <= mergeRange.end.col; col++) for (let row = mergeRange.start.row; row <= mergeRange.end.row; row++) {
            table.scenegraph.getCell(col, row).forEachChildren((checkbox => {
                "checkbox" === checkbox.name && checkbox.setAttributes({
                    checked: e.target.attribute.checked,
                    indeterminate: e.target.attribute.indeterminate
                });
            }));
        }
        const cellsEvent = Object.assign(Object.assign({}, cellInfo), {
            event: e.nativeEvent,
            target: null === (_a = null == eventArgsSet ? void 0 : eventArgsSet.eventArgs) || void 0 === _a ? void 0 : _a.target,
            mergeCellInfo: null === (_b = null == eventArgsSet ? void 0 : eventArgsSet.eventArgs) || void 0 === _b ? void 0 : _b.mergeInfo,
            checked: e.detail.checked
        });
        if (table.isHeader(col, row)) {
            table.stateManager.setHeaderCheckedState(cellInfo.field, e.detail.checked);
            "checkbox" === table.getCellType(col, row) && table.scenegraph.updateCheckboxCellState(col, row, e.detail.checked);
        } else {
            table.stateManager.setCheckedState(col, row, cellInfo.field, e.detail.checked);
            if ("checkbox" === table.getCellType(col, row)) {
                const oldHeaderCheckedState = table.stateManager.headerCheckedState[cellInfo.field], newHeaderCheckedState = table.stateManager.updateHeaderCheckedState(cellInfo.field, col, row);
                oldHeaderCheckedState !== newHeaderCheckedState && table.scenegraph.updateHeaderCheckboxCellState(col, row, newHeaderCheckedState);
            }
        }
        table.fireListeners(TABLE_EVENT_TYPE.CHECKBOX_STATE_CHANGE, cellsEvent), table.scenegraph.updateNextFrame();
    })), table.scenegraph.tableGroup.addEventListener("radio_checked", (e => {
        var _a, _b, _c;
        const eventArgsSet = getCellEventArgsSet(e), {col: col, row: row, target: target} = eventArgsSet.eventArgs, cellInfo = table.getCellInfo(col, row), indexInCell = null === (_a = regIndexReg.exec(target.id)) || void 0 === _a ? void 0 : _a[1], mergeRange = getCellMergeInfo(table, col, row);
        if (mergeRange) for (let col = mergeRange.start.col; col <= mergeRange.end.col; col++) for (let row = mergeRange.start.row; row <= mergeRange.end.row; row++) {
            table.scenegraph.getCell(col, row).forEachChildren((radio => {
                "radio" === radio.name && radio.id === target.id && radio.setAttributes({
                    checked: !0
                });
            }));
        }
        const radioCheckType = table.getBodyColumnDefine(col, row).radioCheckType || "column";
        if ("cell" === radioCheckType) if (mergeRange) for (let col = mergeRange.start.col; col <= mergeRange.end.col; col++) for (let row = mergeRange.start.row; row <= mergeRange.end.row; row++) {
            table.scenegraph.getCell(col, row).forEachChildren((radio => {
                "radio" === radio.name && radio.id !== target.id && radio.setAttributes({
                    checked: !1
                });
            }));
        } else {
            table.scenegraph.getCell(col, row).forEachChildren((radio => {
                "radio" === radio.name && radio.id !== target.id && radio.setAttributes({
                    checked: !1
                });
            }));
        } else if ("column" === radioCheckType) {
            table.scenegraph.getColGroup(col).forEachChildren((cellGroup => {
                cellGroup.forEachChildren((radio => {
                    "radio" === radio.name && radio.id !== target.id && radio.setAttributes({
                        checked: !1
                    });
                }));
            }));
        }
        const radioIndexInCell = indexInCell ? Number(indexInCell) : void 0;
        table.stateManager.setRadioState(col, row, cellInfo.field, radioCheckType, radioIndexInCell);
        const cellsEvent = Object.assign(Object.assign({}, cellInfo), {
            event: e.nativeEvent,
            target: null === (_b = null == eventArgsSet ? void 0 : eventArgsSet.eventArgs) || void 0 === _b ? void 0 : _b.target,
            mergeCellInfo: null === (_c = null == eventArgsSet ? void 0 : eventArgsSet.eventArgs) || void 0 === _c ? void 0 : _c.mergeInfo,
            radioIndexInCell: radioIndexInCell
        });
        table.fireListeners(TABLE_EVENT_TYPE.RADIO_STATE_CHANGE, cellsEvent), table.scenegraph.updateNextFrame();
    })), table.scenegraph.tableGroup.addEventListener("switch_state_change", (e => {
        var _a, _b;
        const eventArgsSet = getCellEventArgsSet(e), {col: col, row: row, target: target} = eventArgsSet.eventArgs, cellInfo = table.getCellInfo(col, row), mergeRange = getCellMergeInfo(table, col, row);
        if (mergeRange) for (let col = mergeRange.start.col; col <= mergeRange.end.col; col++) for (let row = mergeRange.start.row; row <= mergeRange.end.row; row++) {
            table.scenegraph.getCell(col, row).forEachChildren((switchComponent => {
                "switch" === switchComponent.name && switchComponent.setAttributes({
                    checked: e.target.attribute.checked
                });
            }));
        }
        const cellsEvent = Object.assign(Object.assign({}, cellInfo), {
            event: e.nativeEvent,
            target: null === (_a = null == eventArgsSet ? void 0 : eventArgsSet.eventArgs) || void 0 === _a ? void 0 : _a.target,
            mergeCellInfo: null === (_b = null == eventArgsSet ? void 0 : eventArgsSet.eventArgs) || void 0 === _b ? void 0 : _b.mergeInfo,
            checked: e.detail.checked
        });
        table.stateManager.setCheckedState(col, row, cellInfo.field, e.detail.checked), 
        table.fireListeners(TABLE_EVENT_TYPE.SWITCH_STATE_CHANGE, cellsEvent), table.scenegraph.updateNextFrame();
    })), table.scenegraph.stage.addEventListener("wheel", (e => {
        var _a;
        e.path.find((node => "legend" === node.name)) || (null === (_a = table.editorManager) || void 0 === _a || _a.completeEdit(), 
        table.eventManager._enableTableScroll && handleWhell(e, stateManager));
    }));
}

export function bindGesture(eventManager) {
    const table = eventManager.table;
    eventManager.gesture = new Gesture(table.scenegraph.tableGroup, {
        tap: {
            interval: 300
        }
    }), eventManager.gesture.on("doubletap", (e => {
        dblclickHandler(e, table);
    }));
}

export function endResizeCol(table) {
    table.stateManager.endResizeCol();
    const columns = [];
    for (let col = 0; col < table.colCount; col++) columns.push(table.getColWidth(col));
    table.fireListeners(TABLE_EVENT_TYPE.RESIZE_COLUMN_END, {
        col: table.stateManager.columnResize.col,
        colWidths: columns
    });
}

export function endResizeRow(table) {
    table.stateManager.endResizeRow(), table.fireListeners(TABLE_EVENT_TYPE.RESIZE_ROW_END, {
        row: table.stateManager.rowResize.row,
        rowHeight: table.getRowHeight(table.stateManager.rowResize.row)
    });
}

function dblclickHandler(e, table) {
    var _a, _b, _c, _d, _e, _f;
    const eventArgsSet = getCellEventArgsSet(e);
    let col = -1, row = -1;
    eventArgsSet.eventArgs && (col = eventArgsSet.eventArgs.col, row = eventArgsSet.eventArgs.row);
    const value = table.getCellValue(col, row), bounds = null === (_b = null === (_a = eventArgsSet.eventArgs) || void 0 === _a ? void 0 : _a.targetCell) || void 0 === _b ? void 0 : _b.globalAABBBounds;
    if (bounds && table.internalProps.focusControl.setFocusRect(new Rect(bounds.x1 + table.scrollLeft, bounds.y1 + table.scrollTop, bounds.x2 - bounds.x1, bounds.y2 - bounds.y1), value), 
    table.hasListeners(TABLE_EVENT_TYPE.DBLCLICK_CELL)) {
        const cellInfo = table.getCellInfo(col, row);
        let icon, position;
        if (null === (_c = eventArgsSet.eventArgs) || void 0 === _c ? void 0 : _c.target) {
            const iconInfo = getIconAndPositionFromTarget(null === (_d = eventArgsSet.eventArgs) || void 0 === _d ? void 0 : _d.target);
            iconInfo && (icon = iconInfo.icon, position = iconInfo.position);
        }
        const cellsEvent = Object.assign(Object.assign({}, cellInfo), {
            event: e.nativeEvent,
            federatedEvent: e,
            cells: [],
            targetIcon: icon ? {
                name: icon.name,
                position: position,
                funcType: icon.attribute.funcType
            } : void 0,
            target: null === (_e = null == eventArgsSet ? void 0 : eventArgsSet.eventArgs) || void 0 === _e ? void 0 : _e.target,
            mergeCellInfo: null === (_f = null == eventArgsSet ? void 0 : eventArgsSet.eventArgs) || void 0 === _f ? void 0 : _f.mergeInfo
        });
        table.fireListeners(TABLE_EVENT_TYPE.DBLCLICK_CELL, cellsEvent);
    }
}
//# sourceMappingURL=table-group.js.map
