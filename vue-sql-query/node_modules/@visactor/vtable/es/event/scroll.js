import { InteractionState } from "../ts-types";

export function handleWhell(event, state, isWheelEvent = !0) {
    var _a;
    let {deltaX: deltaX, deltaY: deltaY} = event;
    event.shiftKey && event.deltaY && (deltaX = deltaY, deltaY = 0);
    const [optimizedDeltaX, optimizedDeltaY] = optimizeScrollXY(deltaX, deltaY, {
        horizontal: 1,
        vertical: 1
    });
    (optimizedDeltaX || optimizedDeltaY) && state.interactionState !== InteractionState.scrolling && state.updateInteractionState(InteractionState.scrolling), 
    optimizedDeltaX && (state.setScrollLeft(state.scroll.horizontalBarPos + optimizedDeltaX, event), 
    state.showHorizontalScrollBar(!0)), optimizedDeltaY && (state.setScrollTop(state.scroll.verticalBarPos + optimizedDeltaY, event), 
    state.showVerticalScrollBar(!0)), isWheelEvent && state.resetInteractionState(state.interactionStateBeforeScroll), 
    (null === (_a = event.nativeEvent) || void 0 === _a ? void 0 : _a.cancelable) && ("none" === state.table.internalProps.overscrollBehavior || Math.abs(deltaY) >= Math.abs(deltaX) && 0 !== deltaY && isVerticalScrollable(deltaY, state) || Math.abs(deltaY) <= Math.abs(deltaX) && 0 !== deltaX && isHorizontalScrollable(deltaX, state)) && event.nativeEvent.preventDefault();
}

function optimizeScrollXY(x, y, ratio) {
    var _a, _b;
    const angle = Math.abs(x / y), deltaX = angle <= .5 ? 0 : x, deltaY = angle > 2 ? 0 : y;
    return [ Math.ceil(deltaX * (null !== (_a = ratio.horizontal) && void 0 !== _a ? _a : 0)), Math.ceil(deltaY * (null !== (_b = ratio.vertical) && void 0 !== _b ? _b : 0)) ];
}

export function isVerticalScrollable(deltaY, state) {
    return 0 != state.table.getAllRowsHeight() - state.table.scenegraph.height && (!isScrollToTop(deltaY, state) && !isScrollToBottom(deltaY, state));
}

export function isHorizontalScrollable(deltaX, state) {
    return 0 != state.table.getAllColsWidth() - state.table.scenegraph.width && (!isScrollToLeft(deltaX, state) && !isScrollToRight(deltaX, state));
}

function isScrollToTop(deltaY, state) {
    return 0 !== state.table.getAllRowsHeight() - state.table.scenegraph.height && deltaY <= 0 && state.scroll.verticalBarPos < 1;
}

function isScrollToBottom(deltaY, state) {
    var _a;
    const sizeTolerance = (null === (_a = state.table.options.customConfig) || void 0 === _a ? void 0 : _a._disableColumnAndRowSizeRound) ? 1 : 0, totalHeight = state.table.getAllRowsHeight() - state.table.scenegraph.height;
    return 0 !== totalHeight && deltaY >= 0 && Math.abs(state.scroll.verticalBarPos - totalHeight) < 1 + sizeTolerance;
}

function isScrollToLeft(deltaX, state) {
    return 0 !== state.table.getAllColsWidth() - state.table.scenegraph.width && deltaX <= 0 && state.scroll.horizontalBarPos < 1;
}

function isScrollToRight(deltaX, state) {
    var _a;
    const sizeTolerance = (null === (_a = state.table.options.customConfig) || void 0 === _a ? void 0 : _a._disableColumnAndRowSizeRound) ? 1 : 0, totalWidth = state.table.getAllColsWidth() - state.table.scenegraph.width;
    return 0 !== totalWidth && deltaX >= 0 && Math.abs(state.scroll.horizontalBarPos - totalWidth) < 1 + sizeTolerance;
}

export class InertiaScroll {
    constructor(stateManager) {
        this.stateManager = stateManager;
    }
    setScrollHandle(scrollHandle) {
        this.scrollHandle = scrollHandle;
    }
    startInertia(speedX, speedY, friction) {
        this.lastTime = Date.now(), this.speedX = speedX, this.speedY = speedY, this.friction = friction, 
        this.runingId || (this.runingId = requestAnimationFrame(this.inertia.bind(this)));
    }
    inertia() {
        var _a;
        const now = Date.now(), dffTime = now - this.lastTime;
        let stopped = !0;
        const f = Math.pow(this.friction, dffTime / 16), newSpeedX = f * this.speedX, newSpeedY = f * this.speedY;
        let dx = 0, dy = 0;
        Math.abs(newSpeedX) > .05 && (stopped = !1, dx = (this.speedX + newSpeedX) / 2 * dffTime), 
        Math.abs(newSpeedY) > .05 && (stopped = !1, dy = (this.speedY + newSpeedY) / 2 * dffTime), 
        null === (_a = this.scrollHandle) || void 0 === _a || _a.call(this, dx, dy), stopped ? this.runingId = null : (this.lastTime = now, 
        this.speedX = newSpeedX, this.speedY = newSpeedY, this.runingId = requestAnimationFrame(this.inertia.bind(this)));
    }
    endInertia() {
        cancelAnimationFrame(this.runingId), this.runingId = null;
    }
    isInertiaScrolling() {
        return !!this.runingId;
    }
}
//# sourceMappingURL=scroll.js.map