import { isLeftOrRightAxis, isTopOrBottomAxis } from "../layout/chart-helper/get-axis-config";

import { isFunction } from "@visactor/vutils";

import * as headerStyleContents from "../header-helper/style";

import * as columnStyleContents from "../body-helper/style";

import { mergeStyle } from "../plugins/custom-cell-style";

const EMPTY_STYLE = {};

export function getCellStyle(col, row, table) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    const customCellStyle = null === (_a = table.customCellStylePlugin) || void 0 === _a ? void 0 : _a.getCustomCellStyle(col, row), {layoutMap: layoutMap} = table.internalProps;
    if (layoutMap.isHeader(col, row)) {
        let cacheKey;
        if (!table.isPivotTable() || table.isBottomFrozenRow(row) || table.isRightFrozenColumn(col)) cacheKey = `${col}-${row}`; else {
            const define = table.getHeaderDefine(col, row), isCorner = table.isCornerHeader(col, row);
            cacheKey = (null == define ? void 0 : define.dimensionKey) ? isCorner ? `dim-cor-${define.dimensionKey}` : `dim-${define.dimensionKey}` : (null == define ? void 0 : define.indicatorKey) ? `ind-${define.indicatorKey}` : `${col}-${row}`;
        }
        let cacheStyle = table.headerStyleCache.get(cacheKey);
        if (cacheStyle) return customCellStyle ? mergeStyle(cacheStyle, customCellStyle) : cacheStyle;
        const hd = layoutMap.getHeader(col, row);
        let paddingForAxis;
        if (table.isPivotChart() && isTopOrBottomAxis(col, row, layoutMap) && layoutMap.isAxisCell(col, row)) {
            paddingForAxis = null !== (_c = null === (_b = layoutMap.getBody(col, table.rowHeaderLevelCount).style) || void 0 === _b ? void 0 : _b.padding) && void 0 !== _c ? _c : table.theme.bodyStyle.padding;
        } else if (table.isPivotChart() && isLeftOrRightAxis(col, row, layoutMap) && layoutMap.isAxisCell(col, row)) {
            paddingForAxis = null !== (_e = null === (_d = layoutMap.getBody(table.columnHeaderLevelCount, row).style) || void 0 === _d ? void 0 : _d.padding) && void 0 !== _e ? _e : table.theme.bodyStyle.padding;
        }
        if ((!hd || hd.isEmpty) && (layoutMap.isLeftBottomCorner(col, row) || layoutMap.isRightBottomCorner(col, row) || layoutMap.isCornerHeader(col, row) || layoutMap.isRightTopCorner(col, row))) return EMPTY_STYLE;
        const styleClass = table.internalProps.headerHelper.getStyleClass((null == hd ? void 0 : hd.headerType) || "text");
        if (layoutMap.isBottomFrozenRow(col, row) && table.theme.bottomFrozenStyle) cacheStyle = headerStyleContents.of(paddingForAxis ? {
            padding: paddingForAxis
        } : {}, table.theme.bottomFrozenStyle, {
            col: col,
            row: row,
            table: table,
            value: table.getCellValue(col, row),
            dataValue: table.getCellOriginValue(col, row),
            cellHeaderPaths: table.getCellHeaderPaths(col, row)
        }, styleClass, table.options.autoWrapText, table.theme); else if (layoutMap.isRightFrozenColumn(col, row) && table.theme.rightFrozenStyle) cacheStyle = headerStyleContents.of(paddingForAxis ? {
            padding: paddingForAxis
        } : {}, table.theme.rightFrozenStyle, {
            col: col,
            row: row,
            table: table,
            value: table.getCellValue(col, row),
            dataValue: table.getCellOriginValue(col, row),
            cellHeaderPaths: table.getCellHeaderPaths(col, row)
        }, styleClass, table.options.autoWrapText, table.theme); else {
            const style = (null == hd ? void 0 : hd.style) || {};
            paddingForAxis && (style.padding = paddingForAxis), cacheStyle = headerStyleContents.of(style, layoutMap.isColumnHeader(col, row) || layoutMap.isBottomFrozenRow(col, row) ? table.theme.headerStyle : layoutMap.isRowHeader(col, row) || layoutMap.isRightFrozenColumn(col, row) ? table.theme.rowHeaderStyle : table.theme.cornerHeaderStyle, {
                col: col,
                row: row,
                table: table,
                value: table.getCellValue(col, row),
                dataValue: table.getCellOriginValue(col, row),
                cellHeaderPaths: table.getCellHeaderPaths(col, row)
            }, styleClass, table.options.autoWrapText, table.theme);
        }
        return table.headerStyleCache.set(cacheKey, cacheStyle), customCellStyle ? mergeStyle(cacheStyle, customCellStyle) : cacheStyle;
    }
    let bgColorFunc, cacheKey;
    (null === (_g = null === (_f = table.internalProps) || void 0 === _f ? void 0 : _f.dataConfig) || void 0 === _g ? void 0 : _g.mappingRules) && !table.isHeader(col, row) && (null === (_k = null === (_j = null === (_h = table.internalProps) || void 0 === _h ? void 0 : _h.dataConfig) || void 0 === _j ? void 0 : _j.mappingRules) || void 0 === _k || _k.forEach(((mappingRule, i) => {
        mappingRule.bgColor && table.internalProps.layoutMap.getIndicatorKey(col, row) === mappingRule.bgColor.indicatorKey && (bgColorFunc = mappingRule.bgColor.mapping);
    })));
    const cellType = table.getCellType(col, row), rawRecord = table.getCellOriginRecord(col, row);
    let cacheStyle;
    if (cacheKey = (null == rawRecord ? void 0 : rawRecord.vtableMerge) ? "merge-title" : table.isSeriesNumberInBody(col, row) ? `${col}-series-` + cellType : table.isListTable() && !table.transpose || table.isPivotTable() && table.internalProps.layoutMap.indicatorsAsCol ? col + cellType : row + cellType, 
    cacheStyle = (null == rawRecord ? void 0 : rawRecord.vtableMerge) ? table.bodyMergeTitleCache.get(cacheKey) : layoutMap.isBottomFrozenRow(row) ? table.bodyBottomStyleCache.get(cacheKey) : table.bodyStyleCache.get(cacheKey), 
    cacheStyle) return customCellStyle ? mergeStyle(cacheStyle, customCellStyle) : cacheStyle;
    const column = layoutMap.getBody(col, row), styleClass = table.internalProps.bodyHelper.getStyleClass(table.getCellType(col, row)), style = null == column ? void 0 : column.style;
    return cacheStyle = columnStyleContents.of(style, (null == rawRecord ? void 0 : rawRecord.vtableMerge) && table.theme.groupTitleStyle ? table.theme.groupTitleStyle : layoutMap.isBottomFrozenRow(row) && table.theme.bottomFrozenStyle ? table.theme.bottomFrozenStyle : layoutMap.isRightFrozenColumn(col) && table.theme.rightFrozenStyle ? table.theme.rightFrozenStyle : table.theme.bodyStyle, {
        col: col,
        row: row,
        table: table,
        value: table.getCellValue(col, row),
        dataValue: table.getCellOriginValue(col, row),
        cellHeaderPaths: table.getCellHeaderPaths(col, row)
    }, styleClass, table.options.autoWrapText, table.theme), bgColorFunc && (cacheStyle = mergeStyle(cacheStyle, {
        bgColor: bgColorFunc
    })), isFunction(style) || (layoutMap.isBottomFrozenRow(row) ? table.bodyBottomStyleCache.set(cacheKey, cacheStyle) : table.bodyStyleCache.set(cacheKey, cacheStyle)), 
    customCellStyle ? mergeStyle(cacheStyle, customCellStyle) : cacheStyle;
}
//# sourceMappingURL=style-helper.js.map