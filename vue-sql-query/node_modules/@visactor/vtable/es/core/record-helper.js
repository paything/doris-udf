import { computeColWidth } from "../scenegraph/layout/compute-col-width";

import { computeRowHeight } from "../scenegraph/layout/compute-row-height";

import { isPromise } from "../tools/helper";

import { defaultOrderFn } from "../tools/util";

import { TABLE_EVENT_TYPE } from "./TABLE_EVENT_TYPE";

export function listTableChangeCellValue(col, row, value, workOnEditableCell, triggerEvent, table) {
    if (workOnEditableCell && table.isHasEditorDefine(col, row) || !1 === workOnEditableCell) {
        const recordIndex = table.getRecordShowIndexByCell(col, row), {field: field} = table.internalProps.layoutMap.getBody(col, row), beforeChangeValue = table.getCellRawValue(col, row), oldValue = table.getCellOriginValue(col, row);
        table.isHeader(col, row) ? table.internalProps.layoutMap.updateColumnTitle(col, row, value) : table.dataSource.changeFieldValue(value, recordIndex, field, col, row, table);
        const range = table.getCellRange(col, row), aggregators = table.internalProps.layoutMap.getAggregatorsByCell(col, row);
        if (aggregators) {
            if (Array.isArray(aggregators)) for (let i = 0; i < (null == aggregators ? void 0 : aggregators.length); i++) aggregators[i].recalculate(); else aggregators.recalculate();
            const aggregatorCells = table.internalProps.layoutMap.getAggregatorCellAddress(range.start.col, range.start.row, range.end.col, range.end.row);
            for (let i = 0; i < aggregatorCells.length; i++) {
                const range = table.getCellRange(aggregatorCells[i].col, aggregatorCells[i].row);
                for (let sCol = range.start.col; sCol <= range.end.col; sCol++) for (let sRow = range.start.row; sRow <= range.end.row; sRow++) table.scenegraph.updateCellContent(sCol, sRow);
            }
        }
        for (let sCol = range.start.col; sCol <= range.end.col; sCol++) for (let sRow = range.start.row; sRow <= range.end.row; sRow++) table.scenegraph.updateCellContent(sCol, sRow);
        if ("adaptive" === table.widthMode || table.autoFillWidth && table.getAllColsWidth() <= table.tableNoFrameWidth) 0 === table.internalProps._widthResizedColMap.size && table.scenegraph.recalculateColWidths(); else if (!table.internalProps._widthResizedColMap.has(col)) {
            const oldWidth = table.getColWidth(col), newWidth = computeColWidth(col, 0, table.rowCount - 1, table, !1);
            newWidth !== oldWidth && table.scenegraph.updateColWidth(col, newWidth - oldWidth);
        }
        if ("adaptive" === table.heightMode || table.autoFillHeight && table.getAllRowsHeight() <= table.tableNoFrameHeight) 0 === table.internalProps._heightResizedRowMap.size && table.scenegraph.recalculateRowHeights(); else if (table.isAutoRowHeight(row) && !table.internalProps._heightResizedRowMap.has(row)) {
            const oldHeight = table.getRowHeight(row), newHeight = computeRowHeight(row, 0, table.colCount - 1, table);
            table.scenegraph.updateRowHeight(row, newHeight - oldHeight);
        }
        const changedValue = table.getCellOriginValue(col, row);
        oldValue !== changedValue && triggerEvent && table.fireListeners(TABLE_EVENT_TYPE.CHANGE_CELL_VALUE, {
            col: col,
            row: row,
            rawValue: beforeChangeValue,
            currentValue: oldValue,
            changedValue: changedValue
        }), table.scenegraph.updateNextFrame();
    }
}

export function listTableChangeCellValues(startCol, startRow, values, workOnEditableCell, triggerEvent, table) {
    var _a, _b;
    let pasteColEnd = startCol, pasteRowEnd = startRow;
    const beforeChangeValues = [], oldValues = [];
    let cellUpdateType;
    for (let i = 0; i < values.length && !(startRow + i > table.rowCount - 1); i++) {
        const rowValues = values[i], rawRowValues = [], oldRowValues = [];
        beforeChangeValues.push(rawRowValues), oldValues.push(oldRowValues);
        for (let j = 0; j < rowValues.length && !(startCol + j > table.colCount - 1); j++) {
            cellUpdateType = getCellUpdateType(startCol + j, startRow + i, table, cellUpdateType);
            const beforeChangeValue = table.getCellRawValue(startCol + j, startRow + i);
            rawRowValues.push(beforeChangeValue);
            const oldValue = table.getCellOriginValue(startCol + j, startRow + i);
            oldRowValues.push(oldValue);
        }
    }
    for (let i = 0; i < values.length && !(startRow + i > table.rowCount - 1); i++) {
        pasteRowEnd = startRow + i;
        const rowValues = values[i];
        let thisRowPasteColEnd = startCol;
        for (let j = 0; j < rowValues.length && !(startCol + j > table.colCount - 1); j++) {
            thisRowPasteColEnd = startCol + j;
            let isCanChange = !1;
            if (!1 === workOnEditableCell) isCanChange = !0; else if (table.isHasEditorDefine(startCol + j, startRow + i)) {
                const editor = table.getEditor(startCol + j, startRow + i), oldValue = oldValues[i][j], value = rowValues[j], maybePromiseOrValue = null === (_b = null === (_a = null == editor ? void 0 : editor.validateValue) || void 0 === _a ? void 0 : _a.call(editor, value, oldValue)) || void 0 === _b || _b;
                isCanChange = !!isPromise(maybePromiseOrValue) || (!0 === maybePromiseOrValue || "validate-exit" === maybePromiseOrValue || "invalidate-exit" === maybePromiseOrValue);
            }
            if (isCanChange) {
                const value = rowValues[j], recordIndex = table.getRecordShowIndexByCell(startCol + j, startRow + i), {field: field} = table.internalProps.layoutMap.getBody(startCol + j, startRow + i), beforeChangeValue = beforeChangeValues[i][j], oldValue = oldValues[i][j];
                table.isHeader(startCol + j, startRow + i) ? table.internalProps.layoutMap.updateColumnTitle(startCol + j, startRow + i, value) : table.dataSource.changeFieldValue(value, recordIndex, field, startCol + j, startRow + i, table);
                const changedValue = table.getCellOriginValue(startCol + j, startRow + i);
                oldValue !== changedValue && triggerEvent && table.fireListeners(TABLE_EVENT_TYPE.CHANGE_CELL_VALUE, {
                    col: startCol + j,
                    row: startRow + i,
                    rawValue: beforeChangeValue,
                    currentValue: oldValue,
                    changedValue: changedValue
                });
            }
        }
        pasteColEnd = Math.max(pasteColEnd, thisRowPasteColEnd);
    }
    const startRange = table.getCellRange(startCol, startRow), range = table.getCellRange(pasteColEnd, pasteRowEnd), aggregators = table.internalProps.layoutMap.getAggregatorsByCellRange(startRange.start.col, startRange.start.row, range.end.col, range.end.row);
    if (aggregators) {
        for (let i = 0; i < (null == aggregators ? void 0 : aggregators.length); i++) aggregators[i].recalculate();
        if ("normal" === cellUpdateType) {
            const aggregatorCells = table.internalProps.layoutMap.getAggregatorCellAddress(startRange.start.col, startRange.start.row, range.end.col, range.end.row);
            for (let i = 0; i < aggregatorCells.length; i++) {
                const range = table.getCellRange(aggregatorCells[i].col, aggregatorCells[i].row);
                for (let sCol = range.start.col; sCol <= range.end.col; sCol++) for (let sRow = range.start.row; sRow <= range.end.row; sRow++) table.scenegraph.updateCellContent(sCol, sRow);
            }
        }
    }
    if ("group" === cellUpdateType && table.dataSource.updateRecordsForGroup([], []), 
    "sort" === cellUpdateType || "group" === cellUpdateType) return table.dataSource.sortedIndexMap.clear(), 
    sortRecords(table), table.refreshRowColCount(), table.internalProps.layoutMap.clearCellRangeMap(), 
    table.scenegraph.clearCells(), void table.scenegraph.createSceneGraph();
    for (let sCol = startRange.start.col; sCol <= range.end.col; sCol++) for (let sRow = startRange.start.row; sRow <= range.end.row; sRow++) table.scenegraph.updateCellContent(sCol, sRow);
    if ("adaptive" === table.widthMode || table.autoFillWidth && table.getAllColsWidth() <= table.tableNoFrameWidth) 0 === table.internalProps._widthResizedColMap.size && table.scenegraph.recalculateColWidths(); else for (let sCol = startCol; sCol <= range.end.col; sCol++) if (!table.internalProps._widthResizedColMap.has(sCol)) {
        const oldWidth = table.getColWidth(sCol), newWidth = computeColWidth(sCol, 0, table.rowCount - 1, table, !1);
        newWidth !== oldWidth && table.scenegraph.updateColWidth(sCol, newWidth - oldWidth);
    }
    if ("adaptive" === table.heightMode || table.autoFillHeight && table.getAllRowsHeight() <= table.tableNoFrameHeight) table.scenegraph.recalculateRowHeights(); else if (table.isAutoRowHeight(startRow)) {
        const rows = [], deltaYs = [];
        for (let sRow = startRow; sRow <= range.end.row; sRow++) if (table.rowHeightsMap.get(sRow)) {
            const oldHeight = table.getRowHeight(sRow), newHeight = computeRowHeight(sRow, 0, table.colCount - 1, table);
            rows.push(sRow), deltaYs.push(newHeight - oldHeight);
        }
        table.scenegraph.updateRowsHeight(rows, deltaYs);
    }
    table.scenegraph.updateNextFrame();
}

function getCellUpdateType(col, row, table, oldCellUpdateType) {
    if ("group" === oldCellUpdateType) return oldCellUpdateType;
    if ("sort" === oldCellUpdateType && !table.options.groupBy) return oldCellUpdateType;
    let cellUpdateType = "normal";
    if (table.options.groupBy) cellUpdateType = "group"; else if (!table.isHeader(col, row) && table.dataSource.lastOrderField) {
        table.getBodyField(col, row) === table.dataSource.lastOrderField && (cellUpdateType = "sort");
    }
    return cellUpdateType;
}

export function sortRecords(table) {
    let sortState = table.sortState;
    sortState = !sortState || Array.isArray(sortState) ? sortState : [ sortState ], 
    sortState && (sortState = sortState.map((item => {
        var _a;
        return item.orderFn = null !== (_a = table._getSortFuncFromHeaderOption(void 0, item.field)) && void 0 !== _a ? _a : defaultOrderFn, 
        item;
    })), table.dataSource.sort(sortState));
}

export function listTableAddRecord(record, recordIndex, table) {
    var _a, _b, _c, _d;
    if (table.options.groupBy) null === (_b = (_a = table.dataSource).addRecordsForGroup) || void 0 === _b || _b.call(_a, [ record ], recordIndex), 
    table.refreshRowColCount(), table.internalProps.layoutMap.clearCellRangeMap(), table.sortState && sortRecords(table), 
    table.scenegraph.clearCells(), table.scenegraph.createSceneGraph(); else if ("tree" === table.dataSource.rowHierarchyType) null === (_d = (_c = table.dataSource).addRecordsForTree) || void 0 === _d || _d.call(_c, [ record ], recordIndex), 
    table.refreshRowColCount(), table.internalProps.layoutMap.clearCellRangeMap(), table.sortState && sortRecords(table), 
    table.scenegraph.clearCells(), table.scenegraph.createSceneGraph(); else if (table.sortState) table.dataSource.addRecordForSorted(record), 
    sortRecords(table), table.refreshRowColCount(), table.scenegraph.clearCells(), table.scenegraph.createSceneGraph(); else {
        (void 0 === recordIndex || recordIndex > table.dataSource.sourceLength) && (recordIndex = table.dataSource.sourceLength);
        const headerCount = table.transpose ? table.rowHeaderLevelCount : table.columnHeaderLevelCount;
        table.dataSource.addRecord(record, recordIndex);
        const oldRowCount = table.rowCount;
        if (table.refreshRowColCount(), 0 === table.scenegraph.proxy.totalActualBodyRowCount) return table.scenegraph.clearCells(), 
        void table.scenegraph.createSceneGraph();
        const newRowCount = table.transpose ? table.colCount : table.rowCount;
        if (table.pagination) {
            const {perPageCount: perPageCount, currentPage: currentPage} = table.pagination, endIndex = perPageCount * (currentPage || 0) + perPageCount;
            if (recordIndex < endIndex) if (recordIndex < endIndex - perPageCount) table.scenegraph.clearCells(), 
            table.scenegraph.createSceneGraph(); else {
                const rowNum = recordIndex - (endIndex - perPageCount) + headerCount;
                if (oldRowCount - headerCount === table.pagination.perPageCount) {
                    const updateRows = [];
                    for (let row = rowNum; row < newRowCount; row++) table.transpose ? updateRows.push({
                        col: row,
                        row: 0
                    }) : updateRows.push({
                        col: 0,
                        row: row
                    });
                    table.transpose ? table.scenegraph.updateCol([], [], updateRows) : table.scenegraph.updateRow([], [], updateRows);
                } else {
                    const addRows = [];
                    for (let row = rowNum; row < Math.min(newRowCount, rowNum + 1); row++) table.transpose ? addRows.push({
                        col: row,
                        row: 0
                    }) : addRows.push({
                        col: 0,
                        row: row
                    });
                    table.transpose ? table.scenegraph.updateCol([], addRows, []) : table.scenegraph.updateRow([], addRows, []);
                }
            }
        } else {
            const addRows = [];
            for (let row = recordIndex + headerCount; row < recordIndex + headerCount + 1; row++) table.transpose ? addRows.push({
                col: row,
                row: 0
            }) : addRows.push({
                col: 0,
                row: row
            });
            const updateRows = [], topAggregationCount = table.internalProps.layoutMap.hasAggregationOnTopCount, bottomAggregationCount = table.internalProps.layoutMap.hasAggregationOnBottomCount;
            for (let row = headerCount; row < headerCount + topAggregationCount; row++) table.transpose ? updateRows.push({
                col: row,
                row: 0
            }) : updateRows.push({
                col: 0,
                row: row
            });
            for (let row = (table.transpose ? table.colCount : table.rowCount) - bottomAggregationCount; row < (table.transpose ? table.colCount : table.rowCount); row++) table.transpose ? updateRows.push({
                col: row,
                row: 0
            }) : updateRows.push({
                col: 0,
                row: row
            });
            table.transpose ? table.scenegraph.updateCol([], addRows, []) : table.scenegraph.updateRow([], addRows, []);
        }
    }
}

export function listTableAddRecords(records, recordIndex, table) {
    var _a, _b, _c, _d;
    if (table.options.groupBy) null === (_b = (_a = table.dataSource).addRecordsForGroup) || void 0 === _b || _b.call(_a, records, recordIndex), 
    table.refreshRowColCount(), table.internalProps.layoutMap.clearCellRangeMap(), table.sortState && sortRecords(table), 
    table.scenegraph.clearCells(), table.scenegraph.createSceneGraph(); else if ("tree" === table.dataSource.rowHierarchyType) null === (_d = (_c = table.dataSource).addRecordsForTree) || void 0 === _d || _d.call(_c, records, recordIndex), 
    table.refreshRowColCount(), table.internalProps.layoutMap.clearCellRangeMap(), table.sortState && sortRecords(table), 
    table.scenegraph.clearCells(), table.scenegraph.createSceneGraph(); else if (table.sortState) table.dataSource.addRecordsForSorted(records), 
    sortRecords(table), table.refreshRowColCount(), table.scenegraph.clearCells(), table.scenegraph.createSceneGraph(); else {
        void 0 === recordIndex || recordIndex > table.dataSource.sourceLength ? recordIndex = table.dataSource.sourceLength : recordIndex < 0 && (recordIndex = 0);
        const headerCount = table.transpose ? table.rowHeaderLevelCount : table.columnHeaderLevelCount;
        table.dataSource.addRecords(records, recordIndex);
        const oldRowCount = table.transpose ? table.colCount : table.rowCount;
        if (table.refreshRowColCount(), 0 === table.scenegraph.proxy.totalActualBodyRowCount) return table.scenegraph.clearCells(), 
        void table.scenegraph.createSceneGraph();
        const newRowCount = table.transpose ? table.colCount : table.rowCount;
        if (table.pagination) {
            const {perPageCount: perPageCount, currentPage: currentPage} = table.pagination, endIndex = perPageCount * (currentPage || 0) + perPageCount;
            if (recordIndex < endIndex) if (recordIndex < endIndex - perPageCount) table.scenegraph.clearCells(), 
            table.scenegraph.createSceneGraph(); else {
                const rowNum = recordIndex - (endIndex - perPageCount) + headerCount;
                if (oldRowCount - headerCount === table.pagination.perPageCount) {
                    const updateRows = [];
                    for (let row = rowNum; row < newRowCount; row++) table.transpose ? updateRows.push({
                        col: row,
                        row: 0
                    }) : updateRows.push({
                        col: 0,
                        row: row
                    });
                    table.transpose ? table.scenegraph.updateCol([], [], updateRows) : table.scenegraph.updateRow([], [], updateRows);
                } else {
                    const addRows = [];
                    for (let row = rowNum; row < Math.min(newRowCount, rowNum + (Array.isArray(records) ? records.length : 1)); row++) table.transpose ? addRows.push({
                        col: row,
                        row: 0
                    }) : addRows.push({
                        col: 0,
                        row: row
                    });
                    table.transpose ? table.scenegraph.updateCol([], addRows, []) : table.scenegraph.updateRow([], addRows, []);
                }
            }
        } else {
            const addRows = [];
            for (let row = recordIndex + headerCount; row < recordIndex + headerCount + (Array.isArray(records) ? records.length : 1); row++) table.transpose ? addRows.push({
                col: row,
                row: 0
            }) : addRows.push({
                col: 0,
                row: row
            });
            const topAggregationCount = table.internalProps.layoutMap.hasAggregationOnTopCount, bottomAggregationCount = table.internalProps.layoutMap.hasAggregationOnBottomCount, updateRows = [];
            for (let row = headerCount; row < headerCount + topAggregationCount; row++) table.transpose ? updateRows.push({
                col: row,
                row: 0
            }) : updateRows.push({
                col: 0,
                row: row
            });
            for (let row = (table.transpose ? table.colCount : table.rowCount) - bottomAggregationCount; row < (table.transpose ? table.colCount : table.rowCount); row++) table.transpose ? updateRows.push({
                col: row,
                row: 0
            }) : updateRows.push({
                col: 0,
                row: row
            });
            table.transpose ? table.scenegraph.updateCol([], addRows, updateRows) : table.scenegraph.updateRow([], addRows, updateRows);
        }
    }
}

export function listTableDeleteRecords(recordIndexs, table) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    if ((null == recordIndexs ? void 0 : recordIndexs.length) > 0) if (table.options.groupBy) null === (_b = (_a = table.dataSource).deleteRecordsForGroup) || void 0 === _b || _b.call(_a, recordIndexs), 
    table.refreshRowColCount(), table.internalProps.layoutMap.clearCellRangeMap(), table.sortState && sortRecords(table), 
    table.scenegraph.clearCells(), table.scenegraph.createSceneGraph(); else if ("tree" === table.dataSource.rowHierarchyType) null === (_d = (_c = table.dataSource).deleteRecordsForTree) || void 0 === _d || _d.call(_c, recordIndexs), 
    table.refreshRowColCount(), table.internalProps.layoutMap.clearCellRangeMap(), table.sortState && sortRecords(table), 
    table.scenegraph.clearCells(), table.scenegraph.createSceneGraph(); else if (table.sortState) table.dataSource.deleteRecordsForSorted(recordIndexs), 
    sortRecords(table), table.refreshRowColCount(), table.scenegraph.clearCells(), table.scenegraph.createSceneGraph(); else {
        const deletedRecordIndexs = table.dataSource.deleteRecords(recordIndexs);
        if (0 === deletedRecordIndexs.length) return;
        const oldRowCount = table.transpose ? table.colCount : table.rowCount;
        table.refreshRowColCount();
        const newRowCount = table.transpose ? table.colCount : table.rowCount, recordIndexsMinToMax = deletedRecordIndexs.sort(((a, b) => a - b)), minRecordIndex = recordIndexsMinToMax[0];
        if (table.pagination) {
            const {perPageCount: perPageCount, currentPage: currentPage} = table.pagination, endIndex = perPageCount * (currentPage || 0) + perPageCount;
            if (minRecordIndex < endIndex) if (minRecordIndex < endIndex - perPageCount) table.scenegraph.clearCells(), 
            table.scenegraph.createSceneGraph(); else {
                const headerCount = table.transpose ? table.rowHeaderLevelCount : table.columnHeaderLevelCount, topAggregationCount = table.internalProps.layoutMap.hasAggregationOnTopCount, updateRows = [], delRows = [];
                for (let row = minRecordIndex - (endIndex - perPageCount) + (table.transpose ? table.rowHeaderLevelCount : table.columnHeaderLevelCount) + topAggregationCount; row < newRowCount; row++) table.transpose ? updateRows.push({
                    col: row,
                    row: 0
                }) : updateRows.push({
                    col: 0,
                    row: row
                });
                for (let row = headerCount; row < headerCount + topAggregationCount; row++) table.transpose ? updateRows.push({
                    col: row,
                    row: 0
                }) : updateRows.push({
                    col: 0,
                    row: row
                });
                if (newRowCount < oldRowCount) for (let row = newRowCount; row < oldRowCount; row++) table.transpose ? delRows.push({
                    col: row,
                    row: 0
                }) : delRows.push({
                    col: 0,
                    row: row
                });
                null === (_e = table.reactCustomLayout) || void 0 === _e || _e.clearCache(), table.transpose ? table.scenegraph.updateCol(delRows, [], updateRows) : table.scenegraph.updateRow(delRows, [], updateRows), 
                null === (_f = table.reactCustomLayout) || void 0 === _f || _f.updateAllCustomCell();
            }
        } else {
            const delRows = [], headerCount = table.transpose ? table.rowHeaderLevelCount : table.columnHeaderLevelCount, topAggregationCount = table.internalProps.layoutMap.hasAggregationOnTopCount, bottomAggregationCount = table.internalProps.layoutMap.hasAggregationOnBottomCount;
            for (let index = 0; index < recordIndexsMinToMax.length; index++) {
                const rowNum = recordIndexsMinToMax[index] + headerCount + topAggregationCount;
                table.transpose ? delRows.push({
                    col: rowNum,
                    row: 0
                }) : delRows.push({
                    col: 0,
                    row: rowNum
                });
            }
            const updateRows = [];
            for (let row = headerCount; row < headerCount + topAggregationCount; row++) table.transpose ? updateRows.push({
                col: row,
                row: 0
            }) : updateRows.push({
                col: 0,
                row: row
            });
            for (let row = (table.transpose ? table.colCount : table.rowCount) - bottomAggregationCount; row < (table.transpose ? table.colCount : table.rowCount); row++) table.transpose ? updateRows.push({
                col: row,
                row: 0
            }) : updateRows.push({
                col: 0,
                row: row
            });
            null === (_g = table.reactCustomLayout) || void 0 === _g || _g.clearCache(), table.transpose ? table.scenegraph.updateCol(delRows, [], updateRows) : table.scenegraph.updateRow(delRows, [], updateRows), 
            null === (_h = table.reactCustomLayout) || void 0 === _h || _h.updateAllCustomCell();
        }
    }
}

export function listTableUpdateRecords(records, recordIndexs, table) {
    var _a, _b, _c, _d;
    if ((null == recordIndexs ? void 0 : recordIndexs.length) > 0) if (table.options.groupBy) null === (_b = (_a = table.dataSource).updateRecordsForGroup) || void 0 === _b || _b.call(_a, records, recordIndexs), 
    table.refreshRowColCount(), table.internalProps.layoutMap.clearCellRangeMap(), table.sortState && sortRecords(table), 
    table.scenegraph.clearCells(), table.scenegraph.createSceneGraph(); else if ("tree" === table.dataSource.rowHierarchyType) null === (_d = (_c = table.dataSource).updateRecordsForTree) || void 0 === _d || _d.call(_c, records, recordIndexs), 
    table.refreshRowColCount(), table.internalProps.layoutMap.clearCellRangeMap(), table.sortState && sortRecords(table), 
    table.scenegraph.clearCells(), table.scenegraph.createSceneGraph(); else if (table.sortState) table.dataSource.updateRecordsForSorted(records, recordIndexs), 
    sortRecords(table), table.refreshRowColCount(), table.scenegraph.clearCells(), table.scenegraph.createSceneGraph(); else {
        const updateRecordIndexs = table.dataSource.updateRecords(records, recordIndexs);
        if (0 === updateRecordIndexs.length) return;
        const recordIndexsMinToMax = updateRecordIndexs.map((index => table.getBodyRowIndexByRecordIndex(index))).sort(((a, b) => a - b));
        if (table.pagination) {
            const {perPageCount: perPageCount, currentPage: currentPage} = table.pagination, headerCount = table.transpose ? table.rowHeaderLevelCount : table.columnHeaderLevelCount, topAggregationCount = table.internalProps.layoutMap.hasAggregationOnTopCount, endIndex = perPageCount * (currentPage || 0) + perPageCount, updateRows = [];
            for (let index = 0; index < recordIndexsMinToMax.length; index++) {
                const recordIndex = recordIndexsMinToMax[index];
                if (recordIndex < endIndex && recordIndex >= endIndex - perPageCount) {
                    const rowNum = recordIndex - (endIndex - perPageCount) + (table.transpose ? table.rowHeaderLevelCount : table.columnHeaderLevelCount) + topAggregationCount;
                    updateRows.push(rowNum);
                }
            }
            if (updateRows.length >= 1) {
                const updateRowCells = [];
                for (let index = 0; index < updateRows.length; index++) {
                    const updateRow = updateRows[index];
                    table.transpose ? updateRowCells.push({
                        col: updateRow,
                        row: 0
                    }) : updateRowCells.push({
                        col: 0,
                        row: updateRow
                    });
                }
                for (let row = headerCount; row < headerCount + topAggregationCount; row++) table.transpose ? updateRowCells.push({
                    col: row,
                    row: 0
                }) : updateRowCells.push({
                    col: 0,
                    row: row
                });
                table.transpose ? table.scenegraph.updateCol([], [], updateRowCells) : table.scenegraph.updateRow([], [], updateRowCells);
            }
        } else {
            const updateRows = [], headerCount = table.transpose ? table.rowHeaderLevelCount : table.columnHeaderLevelCount, topAggregationCount = table.internalProps.layoutMap.hasAggregationOnTopCount, bottomAggregationCount = table.internalProps.layoutMap.hasAggregationOnBottomCount;
            for (let index = 0; index < recordIndexsMinToMax.length; index++) {
                const rowNum = recordIndexsMinToMax[index] + headerCount + topAggregationCount;
                table.transpose ? updateRows.push({
                    col: rowNum,
                    row: 0
                }) : updateRows.push({
                    col: 0,
                    row: rowNum
                });
            }
            for (let row = headerCount; row < headerCount + topAggregationCount; row++) table.transpose ? updateRows.push({
                col: row,
                row: 0
            }) : updateRows.push({
                col: 0,
                row: row
            });
            for (let row = (table.transpose ? table.colCount : table.rowCount) - bottomAggregationCount; row < (table.transpose ? table.colCount : table.rowCount); row++) table.transpose ? updateRows.push({
                col: row,
                row: 0
            }) : updateRows.push({
                col: 0,
                row: row
            });
            table.transpose ? table.scenegraph.updateCol([], [], updateRows) : table.scenegraph.updateRow([], [], updateRows);
        }
    }
}
//# sourceMappingURL=record-helper.js.map