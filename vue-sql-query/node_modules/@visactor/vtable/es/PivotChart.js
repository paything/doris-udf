import { AggregationType } from "./ts-types";

import { PivotHeaderLayoutMap } from "./layout/pivot-header-layout";

import { PIVOT_CHART_EVENT_TYPE } from "./ts-types/pivot-table/PIVOT_TABLE_EVENT_TYPE";

import { cellInRange } from "./tools/helper";

import { Dataset } from "./dataset/dataset";

import { parseMarkLineGetExtendRange } from "./core/tableHelper";

import { BaseTable } from "./core/BaseTable";

import { clearCellChartCacheImage, clearChartCacheImage, updateChartData } from "./scenegraph/refresh-node/update-chart";

import { cloneDeep, isArray, isNumber } from "@visactor/vutils";

import { TABLE_EVENT_TYPE } from "./core/TABLE_EVENT_TYPE";

import { cloneDeepSpec } from "@visactor/vutils-extension";

import { DimensionTree } from "./layout/tree-helper";

import { IndicatorDimensionKeyPlaceholder } from "./tools/global";

import { checkHasCartesianChart } from "./layout/chart-helper/get-chart-spec";

import { supplementIndicatorNodesForCustomTree } from "./layout/layout-helper";

import { Factory } from "./core/factory";

import { registerAxis, registerEmptyTip, registerLegend, registerMenu, registerTitle, registerTooltip } from "./components";

import { registerChartCell, registerCheckboxCell, registerImageCell, registerProgressBarCell, registerRadioCell, registerSparkLineCell, registerTextCell, registerVideoCell } from "./scenegraph/group-creater/cell-type";

import { hasLinearAxis } from "./layout/chart-helper/get-axis-config";

import { cacheStageCanvas, clearChartRenderQueue } from "./scenegraph/graphic/contributions/chart-render-helper";

registerAxis(), registerEmptyTip(), registerLegend(), registerMenu(), registerTitle(), 
registerTooltip(), registerChartCell(), registerCheckboxCell(), registerImageCell(), 
registerProgressBarCell(), registerRadioCell(), registerSparkLineCell(), registerTextCell(), 
registerVideoCell();

export class PivotChart extends BaseTable {
    constructor(container, options) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z;
        let columnDimensionTree, rowDimensionTree;
        super(container, options), this.layoutNodeId = {
            seqId: 0
        }, this._selectedDataItemsInChart = [], this._selectedDimensionInChart = [], this._chartEventMap = {}, 
        (options = this.options).layout && Object.assign(options, options.layout), this.internalProps.columns = cloneDeep(options.columns), 
        this.internalProps.rows = cloneDeep(options.rows), this.internalProps.indicators = cloneDeepSpec(options.indicators), 
        this.internalProps.columnTree = !options.indicatorsAsCol || (null === (_a = options.columns) || void 0 === _a ? void 0 : _a.length) || options.columnTree ? cloneDeep(options.columnTree) : [], 
        this.internalProps.rowTree = options.indicatorsAsCol || (null === (_b = options.rows) || void 0 === _b ? void 0 : _b.length) || options.rowTree ? cloneDeep(options.rowTree) : [], 
        this.internalProps.records = options.records, this.setCustomStateNameToSpec(), this.internalProps.columnResizeType = null !== (_e = null !== (_d = null === (_c = options.resize) || void 0 === _c ? void 0 : _c.columnResizeType) && void 0 !== _d ? _d : options.columnResizeType) && void 0 !== _e ? _e : "column", 
        this.internalProps.rowResizeType = null !== (_h = null !== (_g = null === (_f = options.resize) || void 0 === _f ? void 0 : _f.rowResizeType) && void 0 !== _g ? _g : options.rowResizeType) && void 0 !== _h ? _h : "row", 
        this.internalProps.dataConfig = {
            isPivotChart: !0
        }, this._axes = isArray(options.axes) ? options.axes : [], options.columnTree && (!1 !== options.indicatorsAsCol && (this.internalProps.columnTree = supplementIndicatorNodesForCustomTree(this.internalProps.columnTree, options.indicators)), 
        columnDimensionTree = new DimensionTree(null !== (_j = this.internalProps.columnTree) && void 0 !== _j ? _j : [], this.layoutNodeId)), 
        options.rowTree && (!1 === options.indicatorsAsCol && (this.internalProps.rowTree = supplementIndicatorNodesForCustomTree(this.internalProps.rowTree, options.indicators)), 
        rowDimensionTree = new DimensionTree(null !== (_k = this.internalProps.rowTree) && void 0 !== _k ? _k : [], this.layoutNodeId));
        const rowKeys = (null === (_l = null == rowDimensionTree ? void 0 : rowDimensionTree.dimensionKeys) || void 0 === _l ? void 0 : _l.count) ? rowDimensionTree.dimensionKeys.valueArr() : null !== (_o = null === (_m = options.rows) || void 0 === _m ? void 0 : _m.reduce(((keys, rowObj) => ("string" == typeof rowObj ? keys.push(rowObj) : keys.push(rowObj.dimensionKey), 
        keys)), [])) && void 0 !== _o ? _o : [], columnKeys = (null === (_p = null == columnDimensionTree ? void 0 : columnDimensionTree.dimensionKeys) || void 0 === _p ? void 0 : _p.count) ? columnDimensionTree.dimensionKeys.valueArr() : null !== (_r = null === (_q = options.columns) || void 0 === _q ? void 0 : _q.reduce(((keys, columnObj) => ("string" == typeof columnObj ? keys.push(columnObj) : keys.push(columnObj.dimensionKey), 
        keys)), [])) && void 0 !== _r ? _r : [], indicatorKeys = null !== (_t = null === (_s = options.indicators) || void 0 === _s ? void 0 : _s.reduce(((keys, indicatorObj) => ("string" == typeof indicatorObj ? keys.push(indicatorObj) : keys.push(indicatorObj.indicatorKey), 
        keys)), [])) && void 0 !== _t ? _t : [];
        if (this.internalProps.dataConfig.collectValuesBy = this._generateCollectValuesConfig(columnKeys, rowKeys), 
        this.internalProps.dataConfig.aggregationRules = this._generateAggregationRules(), 
        this.internalProps.dataConfig.dimensionSortArray = this._getDimensionSortArray(), 
        this.dataset = new Dataset(this.internalProps.dataConfig, rowKeys, columnKeys, indicatorKeys, this.internalProps.indicators, null === (_u = options.indicatorsAsCol) || void 0 === _u || _u, options.records, void 0, void 0, this.internalProps.columnTree, this.internalProps.rowTree, !0), 
        this.options.indicatorsAsCol && checkHasCartesianChart(this.internalProps.indicators)) {
            const supplyAxisNode = nodes => {
                nodes.forEach((node => {
                    var _a;
                    (null === (_a = node.children) || void 0 === _a ? void 0 : _a.length) ? supplyAxisNode(node.children) : node.children = [ {
                        dimensionKey: "axis",
                        value: ""
                    } ];
                }));
            };
            (null === (_v = this.dataset.rowHeaderTree) || void 0 === _v ? void 0 : _v.length) ? supplyAxisNode(this.dataset.rowHeaderTree) : this.dataset.rowHeaderTree = [ {
                dimensionKey: "axis",
                value: ""
            } ];
        }
        if (options.columnTree || !1 !== options.indicatorsAsCol && (this.dataset.colHeaderTree = supplementIndicatorNodesForCustomTree(this.dataset.colHeaderTree, options.indicators)), 
        options.rowTree || !1 === options.indicatorsAsCol && (this.dataset.rowHeaderTree = supplementIndicatorNodesForCustomTree(this.dataset.rowHeaderTree, options.indicators)), 
        columnDimensionTree = new DimensionTree(null !== (_w = this.dataset.colHeaderTree) && void 0 !== _w ? _w : [], this.layoutNodeId), 
        rowDimensionTree = new DimensionTree(null !== (_x = this.dataset.rowHeaderTree) && void 0 !== _x ? _x : [], this.layoutNodeId), 
        this.internalProps.layoutMap = new PivotHeaderLayoutMap(this, this.dataset, columnDimensionTree, rowDimensionTree), 
        this.refreshHeader(), this.internalProps.useOneRowHeightFillAll = !1, this.scenegraph.createSceneGraph(), 
        options.title) {
            const Title = Factory.getComponent("title");
            this.internalProps.title = new Title(options.title, this), this.scenegraph.resize();
        }
        if (this.options.emptyTip) if (this.internalProps.emptyTip) null === (_y = this.internalProps.emptyTip) || void 0 === _y || _y.resetVisible(); else {
            const EmptyTip = Factory.getComponent("emptyTip");
            this.internalProps.emptyTip = new EmptyTip(this.options.emptyTip, this), null === (_z = this.internalProps.emptyTip) || void 0 === _z || _z.resetVisible();
        }
        setTimeout((() => {
            this.fireListeners(TABLE_EVENT_TYPE.INITIALIZED, null);
        }), 0);
    }
    static get EVENT_TYPE() {
        return PIVOT_CHART_EVENT_TYPE;
    }
    get pivotChartAxes() {
        return this._axes;
    }
    get recordsCount() {
        var _a;
        return null === (_a = this.records) || void 0 === _a ? void 0 : _a.length;
    }
    isListTable() {
        return !1;
    }
    isPivotTable() {
        return !0;
    }
    isPivotChart() {
        return !0;
    }
    _canResizeColumn(col, row) {
        const ifCan = super._canResizeColumn(col, row);
        if (ifCan && !this.internalProps.layoutMap.indicatorsAsCol) {
            const cellDefine = this.internalProps.layoutMap.getBody(col, this.columnHeaderLevelCount);
            if (null == cellDefine ? void 0 : cellDefine.disableColumnResize) return !1;
        }
        return ifCan;
    }
    updateOption(options) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1;
        const internalProps = this.internalProps;
        let columnDimensionTree, rowDimensionTree;
        super.updateOption(options), this.layoutNodeId = {
            seqId: 0
        }, this.internalProps.columns = cloneDeep(options.columns), this.internalProps.rows = cloneDeep(options.rows), 
        this.internalProps.indicators = (null === (_a = options.indicators) || void 0 === _a ? void 0 : _a.length) ? cloneDeepSpec(options.indicators) : [], 
        this.internalProps.columnTree = !options.indicatorsAsCol || (null === (_b = options.columns) || void 0 === _b ? void 0 : _b.length) || options.columnTree ? cloneDeep(options.columnTree) : [], 
        this.internalProps.rowTree = options.indicatorsAsCol || (null === (_c = options.rows) || void 0 === _c ? void 0 : _c.length) || options.rowTree ? cloneDeep(options.rowTree) : [], 
        options.records && (this.internalProps.records = options.records), this.setCustomStateNameToSpec(), 
        this._selectedDataItemsInChart = [], internalProps.columnResizeType = null !== (_f = null !== (_e = null === (_d = options.resize) || void 0 === _d ? void 0 : _d.columnResizeType) && void 0 !== _e ? _e : options.columnResizeType) && void 0 !== _f ? _f : "column", 
        internalProps.rowResizeType = null !== (_j = null !== (_h = null === (_g = options.resize) || void 0 === _g ? void 0 : _g.rowResizeType) && void 0 !== _h ? _h : options.rowResizeType) && void 0 !== _j ? _j : "row", 
        internalProps.dataConfig = {
            isPivotChart: !0
        }, this._axes = isArray(options.axes) ? options.axes : [], options.columnTree && (!1 !== options.indicatorsAsCol && (this.internalProps.columnTree = supplementIndicatorNodesForCustomTree(this.internalProps.columnTree, options.indicators)), 
        columnDimensionTree = new DimensionTree(null !== (_k = this.internalProps.columnTree) && void 0 !== _k ? _k : [], this.layoutNodeId)), 
        options.rowTree && (!1 === options.indicatorsAsCol && (this.internalProps.rowTree = supplementIndicatorNodesForCustomTree(this.internalProps.rowTree, options.indicators)), 
        rowDimensionTree = new DimensionTree(null !== (_l = this.internalProps.rowTree) && void 0 !== _l ? _l : [], this.layoutNodeId));
        const rowKeys = (null === (_m = null == rowDimensionTree ? void 0 : rowDimensionTree.dimensionKeys) || void 0 === _m ? void 0 : _m.count) ? rowDimensionTree.dimensionKeys.valueArr() : null !== (_p = null === (_o = options.rows) || void 0 === _o ? void 0 : _o.reduce(((keys, rowObj) => ("string" == typeof rowObj ? keys.push(rowObj) : keys.push(rowObj.dimensionKey), 
        keys)), [])) && void 0 !== _p ? _p : [], columnKeys = (null === (_q = null == columnDimensionTree ? void 0 : columnDimensionTree.dimensionKeys) || void 0 === _q ? void 0 : _q.count) ? columnDimensionTree.dimensionKeys.valueArr() : null !== (_s = null === (_r = options.columns) || void 0 === _r ? void 0 : _r.reduce(((keys, columnObj) => ("string" == typeof columnObj ? keys.push(columnObj) : keys.push(columnObj.dimensionKey), 
        keys)), [])) && void 0 !== _s ? _s : [], indicatorKeys = null !== (_u = null === (_t = options.indicators) || void 0 === _t ? void 0 : _t.reduce(((keys, indicatorObj) => ("string" == typeof indicatorObj ? keys.push(indicatorObj) : keys.push(indicatorObj.indicatorKey), 
        keys)), [])) && void 0 !== _u ? _u : [];
        if (this.internalProps.dataConfig.collectValuesBy = this._generateCollectValuesConfig(columnKeys, rowKeys), 
        this.internalProps.dataConfig.aggregationRules = this._generateAggregationRules(), 
        this.internalProps.dataConfig.dimensionSortArray = this._getDimensionSortArray(), 
        this.dataset = new Dataset(this.internalProps.dataConfig, rowKeys, columnKeys, indicatorKeys, this.internalProps.indicators, null === (_v = options.indicatorsAsCol) || void 0 === _v || _v, null !== (_w = options.records) && void 0 !== _w ? _w : this.internalProps.records, void 0, void 0, this.internalProps.columnTree, this.internalProps.rowTree, !0), 
        this.options.indicatorsAsCol && checkHasCartesianChart(this.internalProps.indicators)) {
            const supplyAxisNode = nodes => {
                nodes.forEach((node => {
                    var _a;
                    (null === (_a = node.children) || void 0 === _a ? void 0 : _a.length) ? supplyAxisNode(node.children) : node.children = [ {
                        dimensionKey: "axis",
                        value: ""
                    } ];
                }));
            };
            (null === (_x = this.dataset.rowHeaderTree) || void 0 === _x ? void 0 : _x.length) ? supplyAxisNode(this.dataset.rowHeaderTree) : this.dataset.rowHeaderTree = [ {
                dimensionKey: "axis",
                value: ""
            } ];
        }
        if (options.columnTree || !1 !== options.indicatorsAsCol && (this.dataset.colHeaderTree = supplementIndicatorNodesForCustomTree(this.dataset.colHeaderTree, options.indicators)), 
        options.rowTree || !1 === options.indicatorsAsCol && (this.dataset.rowHeaderTree = supplementIndicatorNodesForCustomTree(this.dataset.rowHeaderTree, options.indicators)), 
        columnDimensionTree = new DimensionTree(null !== (_y = this.dataset.colHeaderTree) && void 0 !== _y ? _y : [], this.layoutNodeId), 
        rowDimensionTree = new DimensionTree(null !== (_z = this.dataset.rowHeaderTree) && void 0 !== _z ? _z : [], this.layoutNodeId), 
        internalProps.layoutMap = new PivotHeaderLayoutMap(this, this.dataset, columnDimensionTree, rowDimensionTree), 
        this.refreshHeader(), this.internalProps.useOneRowHeightFillAll = !1, internalProps.releaseList && (internalProps.releaseList.forEach((releaseObj => {
            var _a;
            return null === (_a = null == releaseObj ? void 0 : releaseObj.release) || void 0 === _a ? void 0 : _a.call(releaseObj);
        })), internalProps.releaseList = null), this.scenegraph.clearCells(), this.scenegraph.createSceneGraph(), 
        options.title) {
            const Title = Factory.getComponent("title");
            this.internalProps.title = new Title(options.title, this), this.scenegraph.resize();
        }
        if (this.options.emptyTip) if (this.internalProps.emptyTip) null === (_0 = this.internalProps.emptyTip) || void 0 === _0 || _0.resetVisible(); else {
            const EmptyTip = Factory.getComponent("emptyTip");
            this.internalProps.emptyTip = new EmptyTip(this.options.emptyTip, this), null === (_1 = this.internalProps.emptyTip) || void 0 === _1 || _1.resetVisible();
        }
        return new Promise((resolve => {
            setTimeout(resolve, 0);
        }));
    }
    updatePagination() {}
    refreshHeader() {
        this.setMinMaxLimitWidth(!0), this.refreshRowColCount();
    }
    refreshRowColCount() {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const table = this, {layoutMap: layoutMap} = table.internalProps;
        layoutMap && (table.colCount = null !== (_a = layoutMap.colCount) && void 0 !== _a ? _a : 0, 
        table.rowCount = null !== (_b = layoutMap.rowCount) && void 0 !== _b ? _b : 0, table.internalProps.frozenColCount = null !== (_c = layoutMap.rowHeaderLevelCount) && void 0 !== _c ? _c : 0, 
        table.frozenRowCount = Math.max(layoutMap.headerLevelCount, null !== (_d = this.options.frozenRowCount) && void 0 !== _d ? _d : 0), 
        table.bottomFrozenRowCount !== (null !== (_e = null == layoutMap ? void 0 : layoutMap.bottomFrozenRowCount) && void 0 !== _e ? _e : 0) && (table.bottomFrozenRowCount = null !== (_f = null == layoutMap ? void 0 : layoutMap.bottomFrozenRowCount) && void 0 !== _f ? _f : 0), 
        table.rightFrozenColCount !== (null !== (_g = null == layoutMap ? void 0 : layoutMap.rightFrozenColCount) && void 0 !== _g ? _g : 0) && (table.rightFrozenColCount = null !== (_h = null == layoutMap ? void 0 : layoutMap.rightFrozenColCount) && void 0 !== _h ? _h : 0), 
        this.stateManager.setFrozenCol(this.internalProps.frozenColCount));
    }
    _getSortFuncFromHeaderOption(columns, field, fieldKey) {}
    syncHierarchyState(sourceNode, targetNode) {
        var _a, _b;
        sourceNode.value === targetNode.value && sourceNode.dimensionKey === targetNode.dimensionKey && (targetNode.hierarchyState = null !== (_a = targetNode.hierarchyState) && void 0 !== _a ? _a : (null == targetNode ? void 0 : targetNode.children) ? sourceNode.hierarchyState : void 0, 
        null === (_b = null == targetNode ? void 0 : targetNode.children) || void 0 === _b || _b.forEach(((targetChildNode, index) => {
            var _a;
            (null === (_a = null == sourceNode ? void 0 : sourceNode.children) || void 0 === _a ? void 0 : _a[index]) && targetChildNode && this.syncHierarchyState(sourceNode.children[index], targetChildNode);
        })));
    }
    getRecordShowIndexByCell(col, row) {}
    getTableIndexByRecordIndex(recordIndex) {}
    getTableIndexByField(field) {}
    getCellAddrByFieldRecord(field, recordIndex) {}
    getBodyIndexByRow(row) {
        const {layoutMap: layoutMap} = this.internalProps;
        return layoutMap.getBodyIndexByRow(row);
    }
    getBodyIndexByCol(col) {
        const {layoutMap: layoutMap} = this.internalProps;
        return layoutMap.getBodyIndexByCol(col);
    }
    getCellValue(col, row, skipCustomMerge) {
        var _a, _b, _c;
        if (!skipCustomMerge) {
            const customMergeText = this.getCustomMergeValue(col, row);
            if (customMergeText) return customMergeText;
        }
        if (this.internalProps.layoutMap.isHeader(col, row)) {
            if (this.internalProps.layoutMap.isBottomFrozenRow(col, row) || this.internalProps.layoutMap.isRightFrozenColumn(col, row)) {
                const indicatorKeys = this.internalProps.layoutMap.getIndicatorKeyInChartSpec(col, row);
                let indicatorInfo;
                return null == indicatorKeys || indicatorKeys.forEach((key => {
                    const info = this.internalProps.layoutMap.getIndicatorInfo(key);
                    info && (indicatorInfo = info);
                })), null !== (_b = null !== (_a = null == indicatorInfo ? void 0 : indicatorInfo.title) && void 0 !== _a ? _a : null == indicatorInfo ? void 0 : indicatorInfo.indicatorKey) && void 0 !== _b ? _b : "";
            }
            const {title: title, fieldFormat: fieldFormat} = this.internalProps.layoutMap.getHeader(col, row);
            return "function" == typeof fieldFormat ? fieldFormat(title, col, row, this) : title;
        }
        if (this.dataset) {
            let indicatorPosition;
            const cellDimensionPath = this.internalProps.layoutMap.getCellHeaderPaths(col, row), colKeys = cellDimensionPath.colHeaderPaths.map(((colPath, index) => {
                var _a;
                return colPath.indicatorKey && (indicatorPosition = {
                    position: "col",
                    index: index
                }), null !== (_a = colPath.indicatorKey) && void 0 !== _a ? _a : colPath.value;
            })), rowKeys = cellDimensionPath.rowHeaderPaths.map(((rowPath, index) => {
                var _a;
                return rowPath.indicatorKey && (indicatorPosition = {
                    position: "row",
                    index: index
                }), null !== (_a = rowPath.indicatorKey) && void 0 !== _a ? _a : rowPath.value;
            })), aggregator = this.dataset.getAggregator(rowKeys, colKeys, this.internalProps.layoutMap.getIndicatorKey(col, row), !0, indicatorPosition);
            return aggregator.value ? aggregator.value() : void 0;
        }
        const {fieldFormat: fieldFormat} = this.internalProps.layoutMap.getBody(col, row), rowIndex = this.getBodyIndexByRow(row), colIndex = this.getBodyIndexByCol(col), dataValue = null === (_c = this.records[rowIndex]) || void 0 === _c ? void 0 : _c[colIndex];
        if ("function" == typeof fieldFormat) {
            return fieldFormat(dataValue, col, row, this);
        }
        return dataValue;
    }
    getCellOriginValue(col, row) {
        var _a, _b, _c;
        const table = this;
        if (table.internalProps.layoutMap.isHeader(col, row)) {
            if (this.internalProps.layoutMap.isBottomFrozenRow(col, row) || this.internalProps.layoutMap.isRightFrozenColumn(col, row)) {
                const indicatorKeys = this.internalProps.layoutMap.getIndicatorKeyInChartSpec(col, row);
                let indicatorInfo;
                return null == indicatorKeys || indicatorKeys.forEach((key => {
                    const info = this.internalProps.layoutMap.getIndicatorInfo(key);
                    info && (indicatorInfo = info);
                })), null !== (_b = null !== (_a = null == indicatorInfo ? void 0 : indicatorInfo.title) && void 0 !== _a ? _a : null == indicatorInfo ? void 0 : indicatorInfo.indicatorKey) && void 0 !== _b ? _b : "";
            }
            const {title: title} = table.internalProps.layoutMap.getHeader(col, row);
            return "function" == typeof title ? title() : title;
        }
        if (this.dataset) {
            let indicatorPosition;
            const cellDimensionPath = this.internalProps.layoutMap.getCellHeaderPaths(col, row), colKeys = cellDimensionPath.colHeaderPaths.map(((colPath, index) => {
                var _a;
                return colPath.indicatorKey && (indicatorPosition = {
                    position: "col",
                    index: index
                }), null !== (_a = colPath.indicatorKey) && void 0 !== _a ? _a : colPath.value;
            })), rowKeys = cellDimensionPath.rowHeaderPaths.map(((rowPath, index) => {
                var _a;
                return rowPath.indicatorKey && (indicatorPosition = {
                    position: "row",
                    index: index
                }), null !== (_a = rowPath.indicatorKey) && void 0 !== _a ? _a : rowPath.value;
            })), aggregator = this.dataset.getAggregator(rowKeys, colKeys, this.internalProps.layoutMap.getIndicatorKey(col, row), !0, indicatorPosition);
            return aggregator.value ? aggregator.value() : void 0;
        }
        const rowIndex = this.getBodyIndexByRow(row), colIndex = this.getBodyIndexByCol(col);
        return null === (_c = this.records[rowIndex]) || void 0 === _c ? void 0 : _c[colIndex];
    }
    getCellRawValue(col, row) {
        return this.getCellOriginValue(col, row);
    }
    getCellOriginRecord(col, row) {
        if (!this.internalProps.layoutMap.isHeader(col, row) && this.dataset) {
            let indicatorPosition;
            const cellDimensionPath = this.internalProps.layoutMap.getCellHeaderPaths(col, row), colKeys = cellDimensionPath.colHeaderPaths.map(((colPath, index) => {
                var _a;
                return colPath.indicatorKey && (indicatorPosition = {
                    position: "col",
                    index: index
                }), null !== (_a = colPath.indicatorKey) && void 0 !== _a ? _a : colPath.value;
            })), rowKeys = cellDimensionPath.rowHeaderPaths.map(((rowPath, index) => {
                var _a;
                return rowPath.indicatorKey && (indicatorPosition = {
                    position: "row",
                    index: index
                }), null !== (_a = rowPath.indicatorKey) && void 0 !== _a ? _a : rowPath.value;
            }));
            return this.dataset.getAggregator(rowKeys, colKeys, this.internalProps.layoutMap.getIndicatorKey(col, row), !0, indicatorPosition).records;
        }
    }
    getCellRawRecord(col, row) {
        return this.getCellOriginRecord(col, row);
    }
    getPivotSortState(col, row) {
        if (!this.pivotSortState) return;
        const cellRange = this.getCellRange(col, row);
        for (let i = 0; i < this.pivotSortState.length; i++) {
            const {col: sortCol, row: sortRow, order: order} = this.pivotSortState[i];
            if (cellInRange(cellRange, sortCol, sortRow)) return order;
        }
    }
    _moveHeaderPosition(source, target) {
        var _a, _b, _c, _d;
        const moveContext = this.internalProps.layoutMap.moveHeaderPosition(source, target);
        if (moveContext) {
            if ("column" === moveContext.moveType) {
                if ((null === (_b = null === (_a = this.options.records) || void 0 === _a ? void 0 : _a[0]) || void 0 === _b ? void 0 : _b.constructor) === Array) for (let row = 0; row < this.internalProps.records.length; row++) {
                    const sourceColumns = this.internalProps.records[row].splice(moveContext.sourceIndex - this.rowHeaderLevelCount, moveContext.sourceSize);
                    sourceColumns.unshift(moveContext.targetIndex - this.rowHeaderLevelCount, 0), Array.prototype.splice.apply(this.internalProps.records[row], sourceColumns);
                }
                this.colWidthsMap.adjustOrder(moveContext.sourceIndex, moveContext.targetIndex, moveContext.sourceSize), 
                this.setMinMaxLimitWidth();
            } else if ("row" === moveContext.moveType) {
                if ((null === (_d = null === (_c = this.options.records) || void 0 === _c ? void 0 : _c[0]) || void 0 === _d ? void 0 : _d.constructor) === Array) {
                    const sourceRows = this.internalProps.records.splice(moveContext.sourceIndex - this.columnHeaderLevelCount, moveContext.sourceSize);
                    sourceRows.unshift(moveContext.targetIndex - this.columnHeaderLevelCount, 0), Array.prototype.splice.apply(this.internalProps.records, sourceRows);
                }
                this.rowHeightsMap.adjustOrder(moveContext.sourceIndex, moveContext.targetIndex, moveContext.sourceSize);
            }
            return moveContext;
        }
        return null;
    }
    toggleHierarchyState(col, row, recalculateColWidths = !0) {}
    getHeaderCellAddressByPath(dimensionPaths) {
        return this.internalProps.layoutMap.getPivotCellAdress(dimensionPaths);
    }
    getCellAddressByHeaderPaths(dimensionPaths) {
        return this.internalProps.layoutMap.getCellAdressByHeaderPath(dimensionPaths);
    }
    getHeaderPathByXY(coordinate) {
        let cellAddr;
        cellAddr = coordinate ? this.getCellAt(coordinate.x + this.getFrozenColsWidth() + this.scrollLeft + 1, coordinate.y + this.getFrozenRowsHeight() + this.scrollTop + 1) : this.getCellAt(this.getFrozenColsWidth() + this.scrollLeft + 1, this.getFrozenRowsHeight() + this.scrollTop + 1);
        return this.internalProps.layoutMap.getCellHeaderPaths(cellAddr.col, cellAddr.row);
    }
    getHierarchyState(col, row) {
        var _a;
        return null === (_a = this._getHeaderLayoutMap(col, row)) || void 0 === _a ? void 0 : _a.hierarchyState;
    }
    getMenuInfo(col, row, type) {
        const dimensionInfos = this.internalProps.layoutMap.getPivotDimensionInfo(col, row);
        return {
            dimensionKey: dimensionInfos[dimensionInfos.length - 1].dimensionKey,
            value: this.getCellValue(col, row),
            cellLocation: this.getCellLocation(col, row),
            isPivotCorner: this.isCornerHeader(col, row),
            event: void 0
        };
    }
    _generateCollectValuesConfig(columnKeys, rowKeys) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s;
        columnKeys = columnKeys.filter((key => key !== IndicatorDimensionKeyPlaceholder)), 
        rowKeys = rowKeys.filter((key => key !== IndicatorDimensionKeyPlaceholder));
        const indicators = this.internalProps.indicators, collectValuesBy = {};
        for (let i = 0, len = null == indicators ? void 0 : indicators.length; i < len; i++) if ("string" != typeof indicators[i] && indicators[i].chartSpec) {
            if ("pie" === (null === (_a = indicators[i].chartSpec) || void 0 === _a ? void 0 : _a.type) || "rose" === (null === (_b = indicators[i].chartSpec) || void 0 === _b ? void 0 : _b.type) || "radar" === (null === (_c = indicators[i].chartSpec) || void 0 === _c ? void 0 : _c.type) || "gauge" === (null === (_d = indicators[i].chartSpec) || void 0 === _d ? void 0 : _d.type) || "wordCloud" === (null === (_e = indicators[i].chartSpec) || void 0 === _e ? void 0 : _e.type)) continue;
            const indicatorDefine = indicators[i], indicatorSpec = indicatorDefine.chartSpec;
            if (!1 === this.options.indicatorsAsCol) if (!1 !== (null == indicatorSpec ? void 0 : indicatorSpec.stack) && ("bar" === (null == indicatorSpec ? void 0 : indicatorSpec.type) || "area" === (null == indicatorSpec ? void 0 : indicatorSpec.type)) && (indicatorSpec.stack = !0), 
            collectValuesBy[indicatorDefine.indicatorKey] = {
                by: rowKeys,
                range: !0,
                sumBy: (null == indicatorSpec ? void 0 : indicatorSpec.stack) && columnKeys.concat(null == indicatorSpec ? void 0 : indicatorSpec.xField)
            }, indicatorSpec.series) indicatorSpec.series.forEach((chartSeries => {
                var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
                const xField = "string" == typeof chartSeries.xField ? chartSeries.xField : chartSeries.xField[0];
                collectValuesBy[xField] = {
                    by: columnKeys,
                    type: "horizontal" !== chartSeries.direction ? "xField" : void 0,
                    range: hasLinearAxis(chartSeries, this._axes, "horizontal" === chartSeries.direction, !0),
                    sortBy: "horizontal" !== chartSeries.direction ? null !== (_d = null === (_c = null === (_b = null === (_a = null == chartSeries ? void 0 : chartSeries.data) || void 0 === _a ? void 0 : _a.fields) || void 0 === _b ? void 0 : _b[xField]) || void 0 === _c ? void 0 : _c.domain) && void 0 !== _d ? _d : null === (_g = null === (_f = null === (_e = null == indicatorSpec ? void 0 : indicatorSpec.data) || void 0 === _e ? void 0 : _e.fields) || void 0 === _f ? void 0 : _f[xField]) || void 0 === _g ? void 0 : _g.domain : void 0
                };
                const yField = chartSeries.yField;
                !1 !== chartSeries.stack && ("bar" === chartSeries.type || "area" === chartSeries.type) && (chartSeries.stack = !0), 
                collectValuesBy[yField] = {
                    by: rowKeys,
                    range: hasLinearAxis(chartSeries, this._axes, "horizontal" === chartSeries.direction, !1),
                    sumBy: chartSeries.stack && columnKeys.concat(null == chartSeries ? void 0 : chartSeries.xField),
                    sortBy: "horizontal" === chartSeries.direction ? null !== (_l = null === (_k = null === (_j = null === (_h = null == chartSeries ? void 0 : chartSeries.data) || void 0 === _h ? void 0 : _h.fields) || void 0 === _j ? void 0 : _j[yField]) || void 0 === _k ? void 0 : _k.domain) && void 0 !== _l ? _l : null === (_p = null === (_o = null === (_m = null == indicatorSpec ? void 0 : indicatorSpec.data) || void 0 === _m ? void 0 : _m.fields) || void 0 === _o ? void 0 : _o[yField]) || void 0 === _p ? void 0 : _p.domain : void 0,
                    extendRange: parseMarkLineGetExtendRange(indicatorSpec.markLine)
                };
            })); else {
                const xField = "string" == typeof indicatorSpec.xField ? indicatorSpec.xField : indicatorSpec.xField[0];
                collectValuesBy[xField] = {
                    by: columnKeys,
                    type: "horizontal" !== indicatorSpec.direction ? "xField" : void 0,
                    range: hasLinearAxis(indicatorSpec, this._axes, "horizontal" === indicatorSpec.direction, !0),
                    sortBy: "horizontal" !== indicatorSpec.direction ? null === (_h = null === (_g = null === (_f = null == indicatorSpec ? void 0 : indicatorSpec.data) || void 0 === _f ? void 0 : _f.fields) || void 0 === _g ? void 0 : _g[xField]) || void 0 === _h ? void 0 : _h.domain : void 0
                }, !1 !== (null == indicatorSpec ? void 0 : indicatorSpec.stack) && ("bar" === (null == indicatorSpec ? void 0 : indicatorSpec.type) || "area" === (null == indicatorSpec ? void 0 : indicatorSpec.type)) && (indicatorSpec.stack = !0);
                const yField = indicatorSpec.yField;
                collectValuesBy[yField] = {
                    by: rowKeys,
                    range: "horizontal" !== indicatorSpec.direction,
                    sumBy: indicatorSpec.stack && columnKeys.concat(null == indicatorSpec ? void 0 : indicatorSpec.xField),
                    sortBy: "horizontal" === indicatorSpec.direction ? null === (_l = null === (_k = null === (_j = null == indicatorSpec ? void 0 : indicatorSpec.data) || void 0 === _j ? void 0 : _j.fields) || void 0 === _k ? void 0 : _k[yField]) || void 0 === _l ? void 0 : _l.domain : void 0,
                    extendRange: parseMarkLineGetExtendRange(indicatorSpec.markLine)
                };
            } else {
                const indicatorDefine = indicators[i];
                if (!1 !== (null == indicatorSpec ? void 0 : indicatorSpec.stack) && ("bar" === (null == indicatorSpec ? void 0 : indicatorSpec.type) || "area" === (null == indicatorSpec ? void 0 : indicatorSpec.type)) && (indicatorSpec.stack = !0), 
                collectValuesBy[indicatorDefine.indicatorKey] = {
                    by: columnKeys,
                    range: !0,
                    sumBy: (null == indicatorSpec ? void 0 : indicatorSpec.stack) && rowKeys.concat(null == indicatorSpec ? void 0 : indicatorSpec.yField)
                }, indicatorSpec.series) indicatorSpec.series.forEach((chartSeries => {
                    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
                    const yField = "string" == typeof chartSeries.yField ? chartSeries.yField : chartSeries.yField[0];
                    collectValuesBy[yField] = {
                        by: rowKeys,
                        type: "horizontal" === chartSeries.direction ? "yField" : void 0,
                        range: hasLinearAxis(chartSeries, this._axes, "horizontal" === chartSeries.direction, !1),
                        sortBy: "horizontal" === chartSeries.direction ? null !== (_d = null === (_c = null === (_b = null === (_a = null == chartSeries ? void 0 : chartSeries.data) || void 0 === _a ? void 0 : _a.fields) || void 0 === _b ? void 0 : _b[yField]) || void 0 === _c ? void 0 : _c.domain) && void 0 !== _d ? _d : null === (_g = null === (_f = null === (_e = null == indicatorSpec ? void 0 : indicatorSpec.data) || void 0 === _e ? void 0 : _e.fields) || void 0 === _f ? void 0 : _f[yField]) || void 0 === _g ? void 0 : _g.domain : void 0
                    };
                    const xField = chartSeries.xField;
                    !1 !== chartSeries.stack && ("bar" === chartSeries.type || "area" === chartSeries.type) && (chartSeries.stack = !0), 
                    collectValuesBy[xField] = {
                        by: columnKeys,
                        range: hasLinearAxis(chartSeries, this._axes, "horizontal" === chartSeries.direction, !0),
                        sumBy: chartSeries.stack && rowKeys.concat(null == chartSeries ? void 0 : chartSeries.yField),
                        sortBy: "horizontal" !== chartSeries.direction ? null !== (_l = null === (_k = null === (_j = null === (_h = null == chartSeries ? void 0 : chartSeries.data) || void 0 === _h ? void 0 : _h.fields) || void 0 === _j ? void 0 : _j[xField]) || void 0 === _k ? void 0 : _k.domain) && void 0 !== _l ? _l : null === (_p = null === (_o = null === (_m = null == indicatorSpec ? void 0 : indicatorSpec.data) || void 0 === _m ? void 0 : _m.fields) || void 0 === _o ? void 0 : _o[xField]) || void 0 === _p ? void 0 : _p.domain : void 0,
                        extendRange: parseMarkLineGetExtendRange(indicatorSpec.markLine)
                    };
                })); else {
                    const yField = "string" == typeof indicatorSpec.yField ? indicatorSpec.yField : indicatorSpec.yField[0];
                    collectValuesBy[yField] = {
                        by: rowKeys,
                        type: "horizontal" === indicatorSpec.direction ? "yField" : void 0,
                        range: hasLinearAxis(indicatorSpec, this._axes, "horizontal" === indicatorSpec.direction, !1),
                        sortBy: "horizontal" === indicatorSpec.direction ? null === (_p = null === (_o = null === (_m = null == indicatorSpec ? void 0 : indicatorSpec.data) || void 0 === _m ? void 0 : _m.fields) || void 0 === _o ? void 0 : _o[yField]) || void 0 === _p ? void 0 : _p.domain : void 0
                    }, !1 !== (null == indicatorSpec ? void 0 : indicatorSpec.stack) && ("bar" === (null == indicatorSpec ? void 0 : indicatorSpec.type) || "area" === (null == indicatorSpec ? void 0 : indicatorSpec.type)) && (indicatorSpec.stack = !0);
                    const xField = indicatorSpec.xField;
                    collectValuesBy[xField] = {
                        by: columnKeys,
                        range: hasLinearAxis(indicatorSpec, this._axes, "horizontal" === indicatorSpec.direction, !0),
                        sumBy: indicatorSpec.stack && rowKeys.concat(null == indicatorSpec ? void 0 : indicatorSpec.yField),
                        sortBy: "horizontal" !== indicatorSpec.direction ? null === (_s = null === (_r = null === (_q = null == indicatorSpec ? void 0 : indicatorSpec.data) || void 0 === _q ? void 0 : _q.fields) || void 0 === _r ? void 0 : _r[xField]) || void 0 === _s ? void 0 : _s.domain : void 0,
                        extendRange: parseMarkLineGetExtendRange(indicatorSpec.markLine)
                    };
                }
            }
        }
        return collectValuesBy;
    }
    _generateAggregationRules() {
        var _a;
        const aggregationRules = [];
        return null === (_a = this.internalProps.indicators) || void 0 === _a || _a.forEach((indicator => {
            var _a, _b;
            if ("string" == typeof indicator) aggregationRules.push({
                indicatorKey: indicator,
                field: indicator,
                aggregationType: AggregationType.RECORD
            }); else if (null === (_a = indicator.chartSpec) || void 0 === _a ? void 0 : _a.series) {
                const fields = [];
                null === (_b = indicator.chartSpec) || void 0 === _b || _b.series.forEach((seriesSpec => {
                    const seriesField = !1 === this.options.indicatorsAsCol ? seriesSpec.yField : seriesSpec.xField;
                    -1 === fields.indexOf(seriesField) && fields.push(seriesField);
                })), aggregationRules.push({
                    indicatorKey: indicator.indicatorKey,
                    field: fields,
                    aggregationType: AggregationType.RECORD
                });
            } else {
                const field = !1 === this.options.indicatorsAsCol ? indicator.chartSpec.yField : indicator.chartSpec.xField;
                aggregationRules.push({
                    indicatorKey: indicator.indicatorKey,
                    field: null != field ? field : indicator.indicatorKey,
                    aggregationType: AggregationType.RECORD
                });
            }
        })), aggregationRules;
    }
    setCustomStateNameToSpec() {
        var _a;
        const setCustomStateName = spec => {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
            (null === (_b = null === (_a = spec.bar) || void 0 === _a ? void 0 : _a.state) || void 0 === _b ? void 0 : _b.selected) && (spec.bar.state.vtable_selected = spec.bar.state.selected, 
            spec.bar.state.vtable_selected_reverse = spec.bar.state.selected_reverse, delete spec.bar.state.selected, 
            delete spec.bar.state.selected_reverse), (null === (_d = null === (_c = spec.point) || void 0 === _c ? void 0 : _c.state) || void 0 === _d ? void 0 : _d.selected) && (spec.point.state.vtable_selected = spec.point.state.selected, 
            spec.point.state.vtable_selected_reverse = spec.point.state.selected_reverse, delete spec.point.state.selected, 
            delete spec.point.state.selected_reverse), (null === (_f = null === (_e = spec.line) || void 0 === _e ? void 0 : _e.state) || void 0 === _f ? void 0 : _f.selected) && (spec.line.state.vtable_selected = spec.line.state.selected, 
            spec.line.state.vtable_selected_reverse = spec.line.state.selected_reverse, delete spec.line.state.selected, 
            delete spec.line.state.selected_reverse), (null === (_h = null === (_g = spec.area) || void 0 === _g ? void 0 : _g.state) || void 0 === _h ? void 0 : _h.selected) && (spec.area.state.vtable_selected = spec.area.state.selected, 
            spec.area.state.vtable_selected_reverse = spec.area.state.selected_reverse, delete spec.area.state.selected, 
            delete spec.area.state.selected_reverse), (null === (_k = null === (_j = spec.pie) || void 0 === _j ? void 0 : _j.state) || void 0 === _k ? void 0 : _k.selected) && (spec.pie.state.vtable_selected = spec.pie.state.selected, 
            spec.pie.state.vtable_selected_reverse = spec.pie.state.selected_reverse, delete spec.pie.state.selected, 
            delete spec.pie.state.selected_reverse);
        };
        null === (_a = this.internalProps.indicators) || void 0 === _a || _a.forEach((indicator => {
            if (indicator.chartSpec) {
                const spec = indicator.chartSpec;
                spec.series ? spec.series.forEach((series => {
                    setCustomStateName(series);
                })) : setCustomStateName(spec);
            }
        }));
    }
    updateFilterRules(filterRules) {
        this.internalProps.dataConfig.filterRules = filterRules, this.dataset.updateFilterRules(filterRules), 
        clearChartCacheImage(this.scenegraph), updateChartData(this.scenegraph), this.render();
    }
    clearChartCacheImage(col, row) {
        isNumber(col) && isNumber(row) ? clearCellChartCacheImage(col, row, this.scenegraph) : clearChartCacheImage(this.scenegraph);
    }
    getLegendSelected() {
        var _a;
        const selected = [];
        return null === (_a = this.internalProps.legends) || void 0 === _a || _a.forEach((legend => {
            const data = legend.legendComponent._getSelectedLegends().map((d => d.label));
            selected.push(...data);
        })), selected;
    }
    setLegendSelected(selectedData) {
        var _a;
        null === (_a = this.internalProps.legends) || void 0 === _a || _a.forEach((legend => {
            legend.legendComponent.setSelected(selectedData);
        }));
    }
    getChartDatumPosition(datum, cellHeaderPaths) {
        const {chartInstance: chartInstance, bounds: bounds} = this.getChartInstance(cellHeaderPaths);
        if (chartInstance) {
            const position = chartInstance.convertDatumToPosition(datum);
            return position ? {
                x: Math.round(position.x + bounds.x1),
                y: Math.round(position.y + bounds.y1)
            } : null;
        }
        return null;
    }
    getCellAddressByRecord(record) {
        const rowHeaderPaths = [], colHeaderPaths = [], recordKeyMapToIndicatorKeys = {}, indicatorRecordKeys = [];
        this.dataset.dataConfig.aggregationRules.forEach((aggregationRule => {
            if ("string" == typeof aggregationRule.field) recordKeyMapToIndicatorKeys[aggregationRule.field] = aggregationRule.indicatorKey, 
            indicatorRecordKeys.push(aggregationRule.field); else for (let i = 0; i < aggregationRule.field.length; i++) recordKeyMapToIndicatorKeys[aggregationRule.field[i]] = aggregationRule.indicatorKey, 
            indicatorRecordKeys.push(aggregationRule.field[i]);
        }));
        for (const key in record) this.dataset.rows.indexOf(key) >= 0 && rowHeaderPaths.push({
            dimensionKey: key,
            value: record[key]
        }), this.dataset.columns.indexOf(key) >= 0 && colHeaderPaths.push({
            dimensionKey: key,
            value: record[key]
        }), indicatorRecordKeys.indexOf(key) >= 0 && (this.dataset.indicatorsAsCol ? colHeaderPaths.push({
            indicatorKey: recordKeyMapToIndicatorKeys[key]
        }) : rowHeaderPaths.push({
            indicatorKey: recordKeyMapToIndicatorKeys[key]
        }));
        return this.getCellAddressByHeaderPaths({
            rowHeaderPaths: rowHeaderPaths,
            colHeaderPaths: colHeaderPaths,
            cellLocation: "body"
        });
    }
    getChartInstance(cellHeaderPaths) {
        var _a, _b, _c, _d, _e;
        const cellAddr = this.getCellAddressByHeaderPaths(cellHeaderPaths);
        if (cellAddr) {
            const cellPosition = this.getCellRelativeRect(cellAddr.col, cellAddr.row), cellGroup = this.scenegraph.getCell(cellAddr.col, cellAddr.row);
            let chartInstance;
            const chartNode = null === (_a = null == cellGroup ? void 0 : cellGroup.getChildren()) || void 0 === _a ? void 0 : _a[0];
            if (chartNode.attribute.chartInstance) {
                chartInstance = chartNode.attribute.chartInstance;
                const {dataId: dataId, data: data, axes: axes, spec: spec} = chartNode.attribute, viewBox = chartNode.getViewBox();
                null == axes || axes.forEach(((axis, index) => {
                    var _a, _b, _c, _d, _e;
                    "linear" === axis.type ? chartInstance.updateModelSpecSync({
                        type: "axes",
                        index: index
                    }, {
                        min: null !== (_b = null === (_a = axis.range) || void 0 === _a ? void 0 : _a.min) && void 0 !== _b ? _b : 0,
                        max: null !== (_d = null === (_c = axis.range) || void 0 === _c ? void 0 : _c.max) && void 0 !== _d ? _d : 0,
                        tick: {
                            tickMode: null === (_e = axis.tick) || void 0 === _e ? void 0 : _e.tickMode
                        }
                    }, !0) : "band" === axis.type && chartInstance.updateModelSpec({
                        type: "axes",
                        index: index
                    }, {
                        domain: axis.domain.slice(0)
                    }, !0);
                })), chartInstance.updateViewBox({
                    x1: 0,
                    x2: viewBox.x2 - viewBox.x1,
                    y1: 0,
                    y2: viewBox.y2 - viewBox.y1
                }, !1, !1);
                const chartStage = chartInstance.getStage(), matrix = chartNode.globalTransMatrix.clone(), stageMatrix = chartNode.stage.window.getViewBoxTransform();
                if (matrix.multiply(stageMatrix.a, stageMatrix.b, stageMatrix.c, stageMatrix.d, stageMatrix.e, stageMatrix.f), 
                chartStage.window.setViewBoxTransform && chartStage.window.setViewBoxTransform(matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f), 
                "string" == typeof dataId) chartInstance.updateDataSync(dataId, null != data ? data : []); else {
                    const dataBatch = [];
                    for (const dataIdStr in dataId) {
                        const dataIdAndField = dataId[dataIdStr], series = spec.series.find((item => {
                            var _a;
                            return (null === (_a = null == item ? void 0 : item.data) || void 0 === _a ? void 0 : _a.id) === dataIdStr;
                        }));
                        dataBatch.push({
                            id: dataIdStr,
                            values: dataIdAndField ? null !== (_b = null == data ? void 0 : data.filter((item => item.hasOwnProperty(dataIdAndField)))) && void 0 !== _b ? _b : [] : null != data ? data : [],
                            fields: null === (_c = null == series ? void 0 : series.data) || void 0 === _c ? void 0 : _c.fields
                        }), chartInstance.updateFullDataSync || chartInstance.updateDataSync(dataIdStr, dataIdAndField ? null !== (_d = null == data ? void 0 : data.filter((item => item.hasOwnProperty(dataIdAndField)))) && void 0 !== _d ? _d : [] : null != data ? data : []);
                    }
                    null === (_e = chartInstance.updateFullDataSync) || void 0 === _e || _e.call(chartInstance, dataBatch);
                }
                this.render();
            }
            return {
                chartInstance: chartInstance,
                bounds: cellPosition.bounds
            };
        }
        return {};
    }
    activateChartInstance(cellHeaderPaths) {
        var _a, _b, _c, _d, _e;
        const cellAddr = this.getCellAddressByHeaderPaths(cellHeaderPaths);
        if (cellAddr) {
            const col = cellAddr.col, row = cellAddr.row, cellGroup = this.scenegraph.getCell(col, row), chartNode = null === (_a = null == cellGroup ? void 0 : cellGroup.getChildren()) || void 0 === _a ? void 0 : _a[0], activeChartInstance = this.scenegraph.activateChart(col, row), {dataId: dataId, data: data, axes: axes, spec: spec} = chartNode.attribute, viewBox = chartNode.getViewBox();
            null == axes || axes.forEach(((axis, index) => {
                var _a, _b, _c, _d, _e;
                "linear" === axis.type ? activeChartInstance.updateModelSpecSync({
                    type: "axes",
                    index: index
                }, {
                    min: null !== (_b = null === (_a = axis.range) || void 0 === _a ? void 0 : _a.min) && void 0 !== _b ? _b : 0,
                    max: null !== (_d = null === (_c = axis.range) || void 0 === _c ? void 0 : _c.max) && void 0 !== _d ? _d : 0,
                    tick: {
                        tickMode: null === (_e = axis.tick) || void 0 === _e ? void 0 : _e.tickMode
                    }
                }, !0) : "band" === axis.type && activeChartInstance.updateModelSpec({
                    type: "axes",
                    index: index
                }, {
                    domain: axis.domain.slice(0)
                }, !0);
            })), activeChartInstance.updateViewBox({
                x1: 0,
                x2: viewBox.x2 - viewBox.x1,
                y1: 0,
                y2: viewBox.y2 - viewBox.y1
            }, !1, !1);
            const chartStage = activeChartInstance.getStage();
            chartStage.needRender = !0;
            const matrix = chartNode.globalTransMatrix.clone(), stageMatrix = chartNode.stage.window.getViewBoxTransform().clone();
            if (stageMatrix.multiply(matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f), 
            chartStage.window.setViewBoxTransform(stageMatrix.a, stageMatrix.b, stageMatrix.c, stageMatrix.d, stageMatrix.e, stageMatrix.f), 
            "string" == typeof dataId) activeChartInstance.updateDataSync(dataId, null != data ? data : []); else {
                const dataBatch = [];
                for (const dataIdStr in dataId) {
                    const dataIdAndField = dataId[dataIdStr], series = spec.series.find((item => {
                        var _a;
                        return (null === (_a = null == item ? void 0 : item.data) || void 0 === _a ? void 0 : _a.id) === dataIdStr;
                    }));
                    dataBatch.push({
                        id: dataIdStr,
                        values: dataIdAndField ? null !== (_b = null == data ? void 0 : data.filter((item => item.hasOwnProperty(dataIdAndField)))) && void 0 !== _b ? _b : [] : null != data ? data : [],
                        fields: null === (_c = null == series ? void 0 : series.data) || void 0 === _c ? void 0 : _c.fields
                    }), activeChartInstance.updateFullDataSync || activeChartInstance.updateDataSync(dataIdStr, dataIdAndField ? null !== (_d = null == data ? void 0 : data.filter((item => item.hasOwnProperty(dataIdAndField)))) && void 0 !== _d ? _d : [] : null != data ? data : []);
                }
                null === (_e = activeChartInstance.updateFullDataSync) || void 0 === _e || _e.call(activeChartInstance, dataBatch);
            }
            return activeChartInstance;
        }
    }
    replaceChartCacheImage(cellHeaderPaths, chartInstance) {
        var _a;
        const cellAddr = this.getCellAddressByHeaderPaths(cellHeaderPaths);
        if (cellAddr) {
            const cellGroup = this.scenegraph.getCell(cellAddr.col, cellAddr.row), chartNode = null === (_a = null == cellGroup ? void 0 : cellGroup.getChildren()) || void 0 === _a ? void 0 : _a[0];
            cacheStageCanvas(chartInstance.getStage(), chartNode);
        }
    }
    _getDimensionSortArray() {
        var _a, _b;
        if (null === (_b = null === (_a = this.options) || void 0 === _a ? void 0 : _a.axes) || void 0 === _b ? void 0 : _b.length) {
            const dimensionAxisOrient = this.options.indicatorsAsCol ? "left" : "bottom", dimensionAxisOption = this.options.axes.find((axis => axis.orient === dimensionAxisOrient));
            if (dimensionAxisOption && isArray(dimensionAxisOption.domain)) return dimensionAxisOption.domain;
        }
    }
    setRecords(records) {
        var _a, _b;
        this.internalProps.layoutMap.release(), clearChartRenderQueue();
        const oldHoverState = {
            col: this.stateManager.hover.cellPos.col,
            row: this.stateManager.hover.cellPos.row
        };
        this.options.records = this.internalProps.records = records;
        const options = this.options, internalProps = this.internalProps;
        let columnDimensionTree, rowDimensionTree;
        this.dataset.setRecords(records), columnDimensionTree = options.columnTree ? internalProps.layoutMap.columnDimensionTree : new DimensionTree(null !== (_a = this.dataset.colHeaderTree) && void 0 !== _a ? _a : [], this.layoutNodeId), 
        rowDimensionTree = options.rowTree ? internalProps.layoutMap.rowDimensionTree : new DimensionTree(null !== (_b = this.dataset.rowHeaderTree) && void 0 !== _b ? _b : [], this.layoutNodeId), 
        internalProps.layoutMap = new PivotHeaderLayoutMap(this, this.dataset, columnDimensionTree, rowDimensionTree), 
        this.refreshHeader(), this.internalProps.useOneRowHeightFillAll = !1, this.scenegraph.clearCells(), 
        this.clearCellStyleCache(), this.scenegraph.createSceneGraph(), this.stateManager.updateHoverPos(oldHoverState.col, oldHoverState.row), 
        this.internalProps.title && !this.internalProps.title.isReleased && (this._updateSize(), 
        this.internalProps.title.resize(), this.scenegraph.resize()), this.eventManager.updateEventBinder();
    }
    _hasCustomRenderOrLayout() {
        if (this.options.customRender) return !0;
        const {columnsDefine: columnsDefine, rowsDefine: rowsDefine, indicatorsDefine: indicatorsDefine} = this.internalProps.layoutMap;
        for (let i = 0; i < columnsDefine.length; i++) {
            const columnDefine = columnsDefine[i];
            if ("string" != typeof columnDefine && (columnDefine.headerCustomLayout || columnDefine.headerCustomRender)) return !0;
        }
        for (let i = 0; i < rowsDefine.length; i++) {
            const rowDefine = rowsDefine[i];
            if ("string" != typeof rowDefine && (rowDefine.headerCustomLayout || rowDefine.headerCustomRender)) return !0;
        }
        for (let i = 0; i < indicatorsDefine.length; i++) {
            const indicatorDefine = indicatorsDefine[i];
            if ("string" != typeof indicatorDefine && (indicatorDefine.customLayout || indicatorDefine.headerCustomLayout || indicatorDefine.customRender || indicatorDefine.headerCustomRender)) return !0;
        }
        return !1;
    }
    changeRecordOrder(source, target) {}
    getLayoutColumnTree() {
        return this.internalProps.layoutMap.getLayoutColumnTree();
    }
    getLayoutColumnTreeCount() {
        return this.internalProps.layoutMap.getLayoutColumnTreeCount();
    }
    getLayoutRowTree() {
        return this.internalProps.layoutMap.getLayoutRowTree();
    }
    getLayoutRowTreeCount() {
        return this.internalProps.layoutMap.getLayoutRowTreeCount();
    }
    getCellHeaderTreeNodes(col, row) {
        return this.internalProps.layoutMap.getCellHeaderPathsWithTreeNode(col, row);
    }
}
//# sourceMappingURL=PivotChart.js.map