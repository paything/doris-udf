import { HierarchyState, InternalIconName } from "../ts-types";

import * as registerIcons from "../icons";

import { Style } from "./style/Style";

import { TextStyle } from "./style/MultilineTextStyle";

import { ProgressBarStyle } from "./style/ProgressBarStyle";

import { ImageStyle } from "./style/ImageStyle";

import * as icons from "../tools/icons";

import { obj } from "../tools/helper";

import { CheckboxStyle } from "./style/CheckboxStyle";

import { RadioStyle } from "./style/RadioStyle";

import { isValid } from "@visactor/vutils";

import { SwitchStyle } from "./style/SwitchStyle";

import { ButtonStyle } from "./style/ButtonStyle";

export class BodyHelper {
    constructor(_table) {
        this._table = _table;
        const regedIcons = registerIcons.get();
        this.expandIcon = regedIcons[InternalIconName.expandIconName], this.collapseIcon = regedIcons[InternalIconName.collapseIconName];
    }
    getIcons(col, row, cellValue, dataValue, context) {
        const iconArr = [], hierarchyIcon = this.getHierarchyIcon(col, row);
        hierarchyIcon && iconArr.push(hierarchyIcon);
        const {icon: iconDefine} = this._table.getBodyColumnDefine(col, row);
        if (iconDefine) {
            let iconResults;
            if ("function" == typeof iconDefine) {
                iconResults = iconDefine({
                    col: col,
                    row: row,
                    value: cellValue,
                    dataValue: dataValue,
                    table: this._table
                });
            } else iconResults = iconDefine;
            const regedIcons = registerIcons.get(), addIcon = columnIcon => {
                let icon;
                icon = "string" == typeof columnIcon ? regedIcons[columnIcon] : columnIcon, icon && iconArr.push(icon);
            };
            Array.isArray(iconResults) ? iconResults.forEach(((columnIcon, index) => {
                addIcon(columnIcon);
            })) : addIcon(iconResults);
        }
        return context && iconArr.forEach(((i, index) => {
            (i.content || i.src) && (iconArr[index] = this.getCellIconFromRecordValue(i, col, row));
        })), iconArr;
    }
    getStyleClass(cellType) {
        switch (cellType) {
          case "text":
          case "link":
            return TextStyle;

          case "image":
          case "video":
            return ImageStyle;

          case "chart":
          case "sparkline":
            return Style;

          case "progressbar":
            return ProgressBarStyle;

          case "checkbox":
            return CheckboxStyle;

          case "radio":
            return RadioStyle;

          case "switch":
            return SwitchStyle;

          case "button":
            return ButtonStyle;
        }
        return TextStyle;
    }
    getCellIconFromRecordValue(icon, col, row) {
        if (Array.isArray(icon)) return icon.map((i => this.getCellIconFromRecordValue(i, col, row)));
        if (!obj.isObject(icon) || "function" == typeof icon) return this._table.getFieldData(icon, col, row);
        const retIcon = {}, iconOpt = icon;
        return icons.iconPropKeys.forEach((k => {
            var _a, _b;
            if (void 0 !== iconOpt[k]) {
                const f = this._table.getFieldData(iconOpt[k], col, row);
                isValid(f) ? retIcon[k] = f : (null === (_b = (_a = this._table)._hasField) || void 0 === _b ? void 0 : _b.call(_a, iconOpt[k], col, row)) || (retIcon[k] = iconOpt[k]);
            }
        })), retIcon;
    }
    getHierarchyIcon(col, row) {
        const hierarchyState = this._table.getHierarchyState(col, row);
        return hierarchyState === HierarchyState.expand ? this.expandIcon : hierarchyState === HierarchyState.collapse ? this.collapseIcon : void 0;
    }
    getHierarchyIconWidth() {
        var _a, _b;
        return this.expandIcon.width + (null !== (_a = this.expandIcon.marginLeft) && void 0 !== _a ? _a : 0) + (null !== (_b = this.expandIcon.marginRight) && void 0 !== _b ? _b : 0);
    }
}
//# sourceMappingURL=body-helper.js.map