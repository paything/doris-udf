{"version":3,"sources":["../src/dataset/dataset.ts"],"names":[],"mappings":"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","file":"dataset.js","sourcesContent":["import { isArray, isValid } from '@visactor/vutils';\nimport type {\n  FilterRules,\n  IPivotTableDataConfig,\n  SortRule,\n  AggregationRules,\n  AggregationRule,\n  SortRules,\n  DerivedFieldRule,\n  DerivedFieldRules,\n  SortByIndicatorRule,\n  SortByRule,\n  SortTypeRule,\n  SortFuncRule,\n  Totals,\n  MappingRules,\n  SortOrder,\n  IHeaderTreeDefine,\n  CollectValueBy,\n  CollectedValue,\n  IIndicator,\n  IPivotChartDataConfig,\n  CalculateddFieldRules,\n  SortType\n} from '../ts-types';\nimport { AggregationType } from '../ts-types';\nimport type { Aggregator, IAggregator } from '../ts-types/dataset/aggregation';\nimport {\n  registeredAggregators,\n  AvgAggregator,\n  CountAggregator,\n  CustomAggregator,\n  MaxAggregator,\n  MinAggregator,\n  NoneAggregator,\n  RecalculateAggregator,\n  RecordAggregator,\n  SumAggregator,\n  naturalSort,\n  sortBy,\n  typeSort\n} from '../ts-types/dataset/aggregation';\nimport { IndicatorDimensionKeyPlaceholder } from '../tools/global';\nimport { join } from '../tools/join';\n/**\n * 数据处理模块\n */\nexport class Dataset {\n  /**\n   * 用户配置\n   */\n  dataConfig?: IPivotTableDataConfig | IPivotChartDataConfig;\n  // /**\n  //  * 分页配置\n  //  */\n  // pagination: IPagination;\n  /**\n   * 明细数据\n   */\n  records?: any[] | Record<string, any[]>;\n  filteredRecords?: any[] | Record<string, any[]>;\n  /**\n   * 树形节点，最后的子节点对应到body部分的每个单元格 树结构： 行-列-单元格\n   */\n  tree: Record<string, Record<string, Aggregator[]>> = {};\n  changedTree: Record<string, Record<string, any[]>> = {};\n  private colFlatKeys: Record<string, number> = {}; //记录某个colKey已经被添加过colKeys到\n  private rowFlatKeys: Record<string, number> = {}; //记录某个rowKey已经被添加过rowKeys到\n\n  //列表头的每列对应的表头键值\n  colKeys: string[][] = [];\n  //行表头的每行对应的表头键值\n  rowKeys: string[][] = [];\n\n  // 存储下未排序即初始normal下rowKeys和colKeys\n  colKeys_normal: string[][] = [];\n  rowKeys_normal: string[][] = [];\n  // /**\n  //  * 对应dataset中的rowKeys，行表头的每行表头键值，包含小计总计\n  //  */\n  // rowKeysPath: string[][];\n  // /**\n  //  * 对应dataset中的colKeys，列表头的每列表头键值，包含小计总计\n  //  */\n  // colKeysPath: string[][];\n  // allTotal: SumAggregator;\n  rowOrder = 'key_a_to_z';\n  colOrder = 'key_a_to_z';\n  //是否已排序\n  sorted = false;\n  //排序规则\n  sortRules?: SortRules;\n  //过滤规则\n  filterRules?: FilterRules;\n  //聚合规则\n  aggregationRules?: AggregationRules;\n  //派生字段规则\n  derivedFieldRules?: DerivedFieldRules;\n  mappingRules?: MappingRules;\n  calculatedFieldRules?: CalculateddFieldRules;\n  /** 计算字段 */\n  calculatedFiledKeys?: string[];\n  calculatedFieldDependIndicatorKeys?: string[];\n  //汇总配置\n  totals?: Totals;\n  //全局统计各指标的极值\n  indicatorStatistics: { max: Aggregator; min: Aggregator; total: Aggregator }[] = [];\n\n  stringJoinChar = String.fromCharCode(0);\n  //缓存rows对应每个值是否为汇总字段\n  private rowsIsTotal: boolean[] = [];\n  private colsIsTotal: boolean[] = [];\n  private colGrandTotalLabel: string;\n  private colSubTotalLabel: string;\n  private rowGrandTotalLabel: string;\n  private rowSubTotalLabel: string;\n  private needSplitPositiveAndNegative?: boolean;\n  collectValuesBy?: Record<string, CollectValueBy>; //收集维度值，field收集维度，by按什么进行分组收集\n  collectedValues: Record<string, Record<string, CollectedValue>> = {};\n  cacheCollectedValues: Record<string, Record<string, CollectedValue>> = {};\n  rows: string[];\n  rowsHasValue: boolean[]; //rows中的key是否有在records中体现\n  columns: string[];\n  columnsHasValue: boolean[]; //columns中的key是否有在records中体现\n  indicatorKeys: string[];\n  indicatorKeysIncludeCalculatedFieldDependIndicatorKeys: string[];\n  customRowTree?: IHeaderTreeDefine[];\n  customColTree?: IHeaderTreeDefine[];\n  // 存储自定义表头树 对应每一行的 key path\n  customRowTreeDimensionPaths: {\n    dimensionKey?: string | number;\n    value: string;\n    indicatorKey?: string | number;\n    isVirtual?: boolean;\n    childKeys?: (string | number)[];\n  }[][];\n  // 存储自定义表头树 对应每一行的 key path\n  customColTreeDimensionPaths: {\n    dimensionKey?: string | number;\n    value: string;\n    indicatorKey?: string | number;\n    isVirtual?: boolean;\n  }[][];\n  // // 存储行表头path 这个是全量的 对比于分页截取的rowKeysPath；\n  // private rowKeysPath_FULL: string[][];\n  colHeaderTree: any[];\n  rowHeaderTree: any[];\n  rowHierarchyType: 'grid' | 'tree' | 'grid-tree';\n  columnHierarchyType: 'grid' | 'grid-tree';\n  indicators?: (string | IIndicator)[];\n  indicatorsAsCol: boolean;\n  // 记录用户传入的汇总数据\n  totalRecordsTree: Record<string, Record<string, Aggregator[]>> = {};\n  hasExtensionRowTree?: boolean;\n  parseCustomTreeToMatchRecords?: boolean;\n  constructor(\n    dataConfig: IPivotTableDataConfig | IPivotChartDataConfig | undefined,\n    // pagination: IPagination,\n    rows: string[],\n    columns: string[],\n    indicatorKeys: string[],\n    indicators: (string | IIndicator)[] | undefined,\n    indicatorsAsCol: boolean,\n    records: any[] | Record<string, any[]> | undefined,\n    rowHierarchyType?: 'grid' | 'tree' | 'grid-tree',\n    columnHierarchyType?: 'grid' | 'grid-tree',\n    customColTree?: IHeaderTreeDefine[],\n    customRowTree?: IHeaderTreeDefine[],\n    needSplitPositiveAndNegative?: boolean,\n    hasExtensionRowTree?: boolean,\n    parseCustomTreeToMatchRecords?: boolean\n  ) {\n    this.registerAggregators();\n    this.dataConfig = dataConfig;\n    this.filterRules = this.dataConfig?.filterRules;\n    this.rowHierarchyType = rowHierarchyType ?? 'grid';\n    this.columnHierarchyType = columnHierarchyType ?? 'grid';\n    // this.allTotal = new SumAggregator(this.indicators[0]);\n    this.sortRules = this.dataConfig?.sortRules;\n    this.aggregationRules = this.dataConfig?.aggregationRules;\n    this.derivedFieldRules = this.dataConfig?.derivedFieldRules;\n    this.mappingRules = this.dataConfig?.mappingRules;\n    this.calculatedFieldRules = this.dataConfig?.calculatedFieldRules;\n    this.calculatedFiledKeys = this.calculatedFieldRules?.map(rule => rule.key) ?? [];\n    this.calculatedFieldDependIndicatorKeys =\n      this.calculatedFieldRules?.reduce((arr: string[], rule) => {\n        for (let i = 0; i < rule.dependIndicatorKeys.length; i++) {\n          if (arr.indexOf(rule.dependIndicatorKeys[i]) === -1) {\n            arr.push(rule.dependIndicatorKeys[i]);\n          }\n        }\n        return arr;\n      }, []) ?? [];\n    this.totals = this.dataConfig?.totals;\n    this.rows = rows;\n    this.columns = columns;\n    this.indicatorKeys = indicatorKeys;\n    this.indicatorKeysIncludeCalculatedFieldDependIndicatorKeys = [...indicatorKeys];\n\n    for (let m = 0; m < this.calculatedFieldDependIndicatorKeys.length; m++) {\n      if (\n        this.indicatorKeysIncludeCalculatedFieldDependIndicatorKeys.indexOf(\n          this.calculatedFieldDependIndicatorKeys[m]\n        ) === -1\n      ) {\n        this.indicatorKeysIncludeCalculatedFieldDependIndicatorKeys.push(this.calculatedFieldDependIndicatorKeys[m]);\n      }\n    }\n    this.indicatorsAsCol = indicatorsAsCol;\n    this.indicators = indicators;\n    this.customColTree = customColTree;\n    this.customRowTree = customRowTree;\n    this.hasExtensionRowTree = hasExtensionRowTree;\n    this.parseCustomTreeToMatchRecords = parseCustomTreeToMatchRecords;\n    if (this.parseCustomTreeToMatchRecords) {\n      this.customColTreeDimensionPaths = this.customTreeToDimensionPathArr(this.customColTree, 'col');\n      if (!this.hasExtensionRowTree) {\n        this.customRowTreeDimensionPaths = this.customTreeToDimensionPathArr(this.customRowTree, 'row');\n      }\n    }\n    this.colGrandTotalLabel = this.totals?.column?.grandTotalLabel ?? '总计';\n    this.colSubTotalLabel = this.totals?.column?.subTotalLabel ?? '小计';\n    this.rowGrandTotalLabel = this.totals?.row?.grandTotalLabel ?? '总计';\n    this.rowSubTotalLabel = this.totals?.row?.subTotalLabel ?? '小计';\n    this.collectValuesBy = (this.dataConfig as IPivotChartDataConfig)?.collectValuesBy;\n    this.needSplitPositiveAndNegative = needSplitPositiveAndNegative ?? false;\n    this.rowsIsTotal = new Array(this.rows?.length ?? 0).fill(false);\n    this.colsIsTotal = new Array(this.columns?.length ?? 0).fill(false);\n\n    if (this.totals?.row && this.totals.row.showSubTotals !== false && this.totals.row.subTotalsDimensions) {\n      for (let i = 0, len = this.totals?.row?.subTotalsDimensions?.length ?? 0; i < len; i++) {\n        const dimension = this.totals.row.subTotalsDimensions[i];\n        const dimensionIndex = this.rows.indexOf(dimension);\n        this.rowsIsTotal[dimensionIndex] = true;\n      }\n    }\n    if (this.totals?.column && this.totals.column.showSubTotals !== false && this.totals.column.subTotalsDimensions) {\n      for (let i = 0, len = this.totals?.column?.subTotalsDimensions?.length ?? 0; i < len; i++) {\n        const dimension = this.totals.column.subTotalsDimensions[i];\n        const dimensionIndex = this.columns.indexOf(dimension);\n        this.colsIsTotal[dimensionIndex] = true;\n      }\n    }\n    // this.rowKeysPath = [];\n    // this.rowKeysPath_FULL = [];\n    // this.colKeysPath = [];\n    this.setRecords(records);\n    // this.updatePagination(pagination);\n  }\n\n  setRecords(records: any[] | Record<string, any[]>) {\n    this.records = records;\n    this.collectedValues = {};\n    this.cacheCollectedValues = {};\n    this.totalRecordsTree = {};\n    this.tree = {};\n    this.colFlatKeys = {};\n    this.rowFlatKeys = {};\n    this.colKeys = [];\n    this.rowKeys = [];\n    this.rowsHasValue = [];\n    this.columnsHasValue = [];\n    this.sorted = false;\n    if (records) {\n      //处理数据\n      this.records = records;\n      const t0 = typeof window !== 'undefined' ? window.performance.now() : 0;\n      // if (records?.[0]?.constructor !== Array) {\n      // 不能加这个判断来提升性能了，\n      // PivotChart 会有这种设置情况\n      // records: {\n      //   \"0\": [\n      //     {\n      //       \"10001\": \"数量\",\n      //       \"10002\": \"37534\",\n      //       \"10003\": \"sum_1700027602758\",\n      //       \"30001\": \"数量\",\n      //       \"1700046734980\": \"\",\n      //       sum_1700027602758: \"37534\",\n      //     },\n      //   ],\n      // },\n      this.processRecords();\n      // }\n\n      //processRecord中按照collectValuesBy 收集了维度值。现在需要对有聚合需求的sumby 处理收集维度值范围\n      this.processCollectedValuesWithSumBy();\n      //processRecord中按照collectValuesBy 收集了维度值。现在需要对有排序需求的处理sortby\n      this.generateCollectedValuesSortRule();\n      this.processCollectedValuesWithSortBy();\n      const t1 = typeof window !== 'undefined' ? window.performance.now() : 0;\n      console.log('processRecords:', t1 - t0);\n\n      // 处理汇总\n      const t4 = typeof window !== 'undefined' ? window.performance.now() : 0;\n      this.totalStatistics();\n      const t5 = typeof window !== 'undefined' ? window.performance.now() : 0;\n      console.log('totalStatistics:', t5 - t4);\n\n      this.rowKeys_normal = this.rowKeys.slice();\n      this.colKeys_normal = this.colKeys.slice();\n      //对维度排序\n      const t2 = typeof window !== 'undefined' ? window.performance.now() : 0;\n      this.sortKeys();\n      const t3 = typeof window !== 'undefined' ? window.performance.now() : 0;\n      console.log('sortKeys:', t3 - t2);\n      //转为树形\n      // const t4 = typeof window !== 'undefined' ? window.performance.now() : 0;\n      // this.madeTree(this.rowKeys);\n      // const t41 = typeof window !== 'undefined' ? window.performance.now() : 0;\n      // console.log('madeTree:', t41 - t4);\n\n      const t7 = typeof window !== 'undefined' ? window.performance.now() : 0;\n      if (this.customRowTree) {\n        // if (!this.indicatorsAsCol) {\n        //   this.customRowTree = this._adjustCustomTree(this.customRowTree);\n        // }\n\n        this.rowHeaderTree = this.customRowTree;\n      } else {\n        if (this.rowHierarchyType === 'tree') {\n          this.rowHeaderTree = this.ArrToTree1(\n            this.rowKeys,\n            this.rows.filter((key, index) => {\n              return this.rowsHasValue[index];\n            }),\n            this.indicatorsAsCol ? undefined : this.indicators,\n            this.totals?.row?.showGrandTotals ||\n              (!this.indicatorsAsCol && this.columns.length === 0) ||\n              (this.indicatorsAsCol && this.rows.length === 0),\n            this.rowGrandTotalLabel,\n            this.totals?.row?.showGrandTotalsOnTop ?? false\n          );\n        } else {\n          this.rowHeaderTree = this.ArrToTree(\n            this.rowKeys,\n            this.rows.filter((key, index) => {\n              return this.rowsHasValue[index];\n            }),\n            this.indicatorsAsCol ? undefined : this.indicators,\n            this.rowsIsTotal,\n            this.totals?.row?.showGrandTotals || (this.indicatorsAsCol && this.rows.length === 0),\n            this.rowGrandTotalLabel,\n            this.rowSubTotalLabel,\n            this.totals?.row?.showGrandTotalsOnTop ?? false,\n            this.totals?.row?.showSubTotalsOnTop ?? false\n          );\n        }\n      }\n      if (this.customColTree) {\n        // if (this.indicatorsAsCol) {\n        //   this.customColTree = this._adjustCustomTree(this.customColTree);\n        // }\n        this.colHeaderTree = this.customColTree;\n      } else {\n        // if (this.columnHierarchyType !== 'grid') {\n        //   this.colHeaderTree = this.ArrToTree1(\n        //     this.colKeys,\n        //     this.columns.filter((key, index) => {\n        //       return this.columnsHasValue[index];\n        //     }),\n        //     this.indicatorsAsCol ? this.indicators : undefined,\n        //     this.totals?.column?.showGrandTotals ||\n        //       (!this.indicatorsAsCol && this.columns.length === 0) ||\n        //       (this.indicatorsAsCol && this.rows.length === 0),\n        //     this.colGrandTotalLabel\n        //   );\n        // } else {\n        this.colHeaderTree = this.ArrToTree(\n          this.colKeys,\n          this.columns.filter((key, index) => {\n            return this.columnsHasValue[index];\n          }),\n          this.indicatorsAsCol ? this.indicators : undefined,\n          this.colsIsTotal,\n          this.totals?.column?.showGrandTotals || (!this.indicatorsAsCol && this.columns.length === 0), // || this.rows.length === 0,//todo  这里原有逻辑暂时注释掉\n          this.colGrandTotalLabel,\n          this.colSubTotalLabel,\n          this.totals?.column?.showGrandTotalsOnLeft ?? false,\n          this.totals?.column?.showSubTotalsOnLeft ?? false\n        );\n        // }\n      }\n      const t8 = typeof window !== 'undefined' ? window.performance.now() : 0;\n      console.log('TreeToArr:', t8 - t7);\n\n      if ((this.dataConfig as IPivotChartDataConfig)?.isPivotChart) {\n        // 处理PivotChart双轴图0值对齐\n        // this.dealWithZeroAlign();\n\n        // 记录PivotChart维度对应的数据\n        this.cacheDeminsionCollectedValues();\n      }\n    }\n  }\n  //将聚合类型注册 收集到aggregators\n  registerAggregator(type: string, aggregator: any) {\n    registeredAggregators[type] = aggregator;\n  }\n  //将聚合类型注册\n  registerAggregators() {\n    this.registerAggregator(AggregationType.RECORD, RecordAggregator);\n    this.registerAggregator(AggregationType.SUM, SumAggregator);\n    this.registerAggregator(AggregationType.COUNT, CountAggregator);\n    this.registerAggregator(AggregationType.MAX, MaxAggregator);\n    this.registerAggregator(AggregationType.MIN, MinAggregator);\n    this.registerAggregator(AggregationType.AVG, AvgAggregator);\n    this.registerAggregator(AggregationType.NONE, NoneAggregator);\n    this.registerAggregator(AggregationType.RECALCULATE, RecalculateAggregator);\n    this.registerAggregator(AggregationType.CUSTOM, CustomAggregator);\n  }\n  /**processRecord中按照collectValuesBy 收集了维度值。现在需要对有聚合需求的 处理收集维度值范围 */\n  private processCollectedValuesWithSumBy() {\n    for (const field in this.collectedValues) {\n      if (this.collectValuesBy?.[field]?.sumBy) {\n        for (const byKeys in this.collectedValues[field]) {\n          let max;\n\n          //考虑有markLine设置sum的情况\n          if (this.collectValuesBy[field]?.extendRange === 'sum') {\n            max = Object.values(this.collectedValues[field][byKeys]).reduce((acc, cur) => {\n              return acc + cur.value();\n            }, 0);\n            max += Math.round(max / 20);\n          } else {\n            // 寻找最大值作为轴范围的max\n            max = Object.values(this.collectedValues[field][byKeys]).reduce((acc, cur) => {\n              return cur.value() > acc ? cur.value() : acc;\n            }, Number.MIN_SAFE_INTEGER);\n            //考虑有markLine设置max的情况\n            if (this.collectValuesBy[field]?.extendRange === 'max') {\n              max += Math.round(max / 20);\n            } else if (typeof this.collectValuesBy[field]?.extendRange === 'number') {\n              max = Math.max(max, this.collectValuesBy[field]?.extendRange as number);\n            }\n          }\n          const min = Object.values(this.collectedValues[field][byKeys]).reduce((acc, cur) => {\n            return cur.value() < acc ? cur.value() : acc;\n          }, Number.MAX_SAFE_INTEGER);\n          let positiveMax;\n          let negativeMin;\n          if (this.needSplitPositiveAndNegative) {\n            positiveMax = Object.values(this.collectedValues[field][byKeys]).reduce((acc, cur) => {\n              return cur.positiveValue() > acc ? cur.positiveValue() : acc;\n            }, Number.MIN_SAFE_INTEGER);\n            negativeMin = Object.values(this.collectedValues[field][byKeys]).reduce((acc, cur) => {\n              return cur.negativeValue() < acc ? cur.negativeValue() : acc;\n            }, Number.MAX_SAFE_INTEGER);\n          }\n\n          this.collectedValues[field][byKeys] = {};\n          (\n            this.collectedValues[field][byKeys] as {\n              max: number;\n              min: number;\n              positiveMax?: number;\n              negativeMin?: number;\n            }\n          ).max = max;\n          (\n            this.collectedValues[field][byKeys] as {\n              max: number;\n              min: number;\n              positiveMax?: number;\n              negativeMin?: number;\n            }\n          ).min = min;\n          if (this.needSplitPositiveAndNegative) {\n            (\n              this.collectedValues[field][byKeys] as {\n                max: number;\n                min: number;\n                positiveMax?: number;\n                negativeMin?: number;\n              }\n            ).positiveMax = positiveMax;\n            (\n              this.collectedValues[field][byKeys] as {\n                max: number;\n                min: number;\n                positiveMax?: number;\n                negativeMin?: number;\n              }\n            ).negativeMin = negativeMin;\n          }\n        }\n      }\n    }\n  }\n  /**processRecord中按照collectValuesBy 收集了维度值。现在需要对有排序需求的处理 */\n  private processCollectedValuesWithSortBy() {\n    const that = this;\n    for (const field in this.collectedValues) {\n      if (this.collectValuesBy?.[field]?.sortBy) {\n        for (const byKeys in this.collectedValues[field]) {\n          this.collectedValues[field][byKeys] = (this.collectedValues[field][byKeys] as Array<string>).sort(\n            (a, b) =>\n              (that.collectValuesBy![field].sortBy?.indexOf(a) ?? -1) -\n              (that.collectValuesBy![field].sortBy?.indexOf(b) ?? -1)\n          );\n        }\n      }\n    }\n  }\n  /**\n   * 为了轴顺序的一致  这里将收集到的轴范围进行排序 并写入sortBy。这样不同单元格的轴顺序保持一致 同时过滤数据updateFilterRules后也不影响排序\n   */\n  private generateCollectedValuesSortRule() {\n    for (const field in this.collectedValues) {\n      if (this.collectValuesBy && this.collectValuesBy[field] && !this.collectValuesBy[field].sortBy) {\n        let sortByRule: string[] = [];\n        for (const byKeys in this.collectedValues[field]) {\n          if (Array.isArray(this.collectedValues[field][byKeys])) {\n            // 将数组中的元素合并到数组sortByRule中\n            sortByRule.push(...(this.collectedValues[field][byKeys] as Array<string>));\n            // 使用Set和Array.from()方法去除重复值\n            sortByRule = Array.from(new Set(sortByRule));\n          }\n        }\n        if (sortByRule.length > 0) {\n          this.collectValuesBy[field].sortBy = sortByRule;\n        }\n      }\n    }\n  }\n  /**\n   * 处理数据,遍历所有条目，过滤和派生字段的处理有待优化TODO\n   */\n  private processRecords() {\n    let isNeedFilter = false;\n    if ((this.filterRules?.length ?? 0) >= 1) {\n      isNeedFilter = true;\n    }\n    //常规records是数组的情况\n    if (Array.isArray(this.records)) {\n      if (!this.filteredRecords) {\n        this.filteredRecords = [];\n      }\n      for (let i = 0, len = this.records.length; i < len; i++) {\n        const record = this.records[i];\n        if (!isNeedFilter || this.filterRecord(record)) {\n          (this.filteredRecords as any[]).push(record);\n          this.processRecord(record);\n        }\n      }\n    } else {\n      if (!this.filteredRecords) {\n        this.filteredRecords = {};\n      }\n      //records是用户传来的按指标分组后的数据\n      for (const key in this.records) {\n        for (let i = 0, len = this.records[key].length; i < len; i++) {\n          const record = this.records[key][i];\n          if (!isNeedFilter || this.filterRecord(record)) {\n            if (!(this.filteredRecords as Record<string, any[]>)[key]) {\n              (this.filteredRecords as Record<string, any[]>)[key] = [];\n            }\n            (this.filteredRecords as Record<string, any[]>)[key].push(record);\n            this.processRecord(record, key);\n          }\n        }\n      }\n    }\n    this.rowFlatKeys = {};\n    this.colFlatKeys = {};\n  }\n  private filterRecord(record: any) {\n    let isReserved = true;\n    if (this.filterRules) {\n      for (let i = 0; i < this.filterRules.length; i++) {\n        const filterRule = this.filterRules[i];\n        if (filterRule.filterKey) {\n          const filterValue = record[filterRule.filterKey];\n          if (filterRule.filteredValues?.indexOf(filterValue) === -1) {\n            isReserved = false;\n            break;\n          }\n        } else if (!filterRule.filterFunc?.(record)) {\n          isReserved = false;\n          break;\n        }\n      }\n    }\n    return isReserved;\n  }\n  /**\n   * 处理单条数据\n   * @param record\n   * @param assignedIndicatorKey 指定要计算的指标key  外部用户 用指标做records的key 分别存储不同指标对应的数据时 会传入这个参数\n   * @returns\n   */\n  private processRecord(record: any, assignedIndicatorKey?: string) {\n    //这个派生字段的计算位置有待确定，是否应该放到filter之前\n    this.derivedFieldRules?.forEach((derivedFieldRule: DerivedFieldRule, i: number) => {\n      if (derivedFieldRule.fieldName && derivedFieldRule.derivedFunc) {\n        record[derivedFieldRule.fieldName] = derivedFieldRule.derivedFunc(record);\n      }\n    });\n    //#region 按照collectValuesBy 收集维度值\n    for (const field in this.collectValuesBy) {\n      if (isValid(record[field])) {\n        if (!this.collectedValues[field]) {\n          this.collectedValues[field] = {};\n        }\n        const collectKeys = this.collectValuesBy[field].by.map(byField => record[byField]).join(this.stringJoinChar);\n        if (!this.collectedValues[field][collectKeys]) {\n          if (this.collectValuesBy[field].sumBy) {\n            this.collectedValues[field][collectKeys] = {};\n          } else if (this.collectValuesBy[field].range) {\n            this.collectedValues[field][collectKeys] = {\n              min: Number.MAX_SAFE_INTEGER,\n              max: Number.MIN_SAFE_INTEGER\n            };\n          } else {\n            this.collectedValues[field][collectKeys] = [];\n          }\n        }\n\n        if (this.collectValuesBy[field].sumBy) {\n          const sumByKeys: string = this.collectValuesBy[field].sumBy\n            ?.map(byField => record[byField])\n            .join(this.stringJoinChar);\n          if (!(this.collectedValues[field][collectKeys] as any)[sumByKeys]) {\n            (this.collectedValues[field][collectKeys] as any)[sumByKeys] = new registeredAggregators[\n              AggregationType.SUM\n            ]({\n              key: field,\n              field: field,\n              isRecord: undefined,\n              needSplitPositiveAndNegative: this.needSplitPositiveAndNegative\n            });\n          }\n          (this.collectedValues[field][collectKeys] as any)[sumByKeys].push(record);\n        } else if (this.collectValuesBy[field].range) {\n          const fieldRange = this.collectedValues[field][collectKeys] as {\n            max: number;\n            min: number;\n          };\n          const max = Math.max(record[field], fieldRange.max);\n          const min = Math.min(record[field], fieldRange.min);\n          if (!isNaN(max)) {\n            fieldRange.max = max;\n            fieldRange.min = min;\n          }\n        } else {\n          const fieldRange = this.collectedValues[field][collectKeys] as Array<string>;\n          if (fieldRange.indexOf(record[field]) === -1) {\n            fieldRange.push(record[field]);\n          }\n        }\n      }\n    }\n    //#endregion\n\n    let isToTalRecord = false;\n    //#region 收集rowKey colKey\n    // 原先的逻辑不关心customRowTree 只是根据rows 从record上收集维度path。现在考虑了rowTree和colTree的传入，需要依据colTree的真实定义的path来给数据做对应关系。\n    // 一条数据可能对应多个path（多列），所以这里收集rowKeys colKeys 是个path的数组，同时兼容path中有indicatorKey和没有indicatorKey的情况\n    const colKeys: { colKey: string[]; indicatorKey: string | number }[] = [];\n    const rowKeys: { rowKey: string[]; indicatorKey: string | number }[] = [];\n\n    if (\n      this.parseCustomTreeToMatchRecords &&\n      !(this.dataConfig as IPivotChartDataConfig)?.isPivotChart &&\n      this.customRowTree?.length &&\n      !assignedIndicatorKey && // 目前应该透视图才有可能传入assignedIndicatorKey  所以前面判断了isPivotChart 这个应该也没用了\n      !this.hasExtensionRowTree // 有扩展树的情况不走新处理逻辑 走旧的即可\n    ) {\n      const rowTreePath = this.getFieldMatchRowDimensionPaths(record);\n      if (rowTreePath.length > 0) {\n        for (let i = 0, len = rowTreePath.length; i < len; i++) {\n          const rowPath = rowTreePath[i];\n          const rowKey: string[] = [];\n          let indicatorKey;\n          for (let j = 0, len1 = rowPath.length; j < len1; j++) {\n            if (isValid(rowPath[j].indicatorKey)) {\n              indicatorKey = rowPath[j].indicatorKey;\n            } else {\n              rowKey.push(rowPath[j].value);\n            }\n          }\n          rowKeys.push({ rowKey, indicatorKey });\n        }\n      }\n    } else {\n      const rowKey: string[] = [];\n      rowKeys.push({ rowKey, indicatorKey: assignedIndicatorKey });\n      for (let l = 0, len1 = this.rows.length; l < len1; l++) {\n        const rowAttr = this.rows[l];\n        if (rowAttr in record) {\n          this.rowsHasValue[l] = true;\n          rowKey.push(record[rowAttr]);\n        } else if (rowAttr !== IndicatorDimensionKeyPlaceholder) {\n          //如果数据中缺失某个维度的值 可以认为是用户传入的汇总数据\n          if (\n            this.dataConfig?.totals?.row?.showGrandTotals &&\n            l === 0 &&\n            !this.rows.find((rk: string) => {\n              // 判断没有其他字段在record中 例如rows中维度有省份和城市，当前在判断省份 数据中确实省份自动 可以认为是行总计的前提是城市也不应该存在\n              return rk in record;\n            })\n          ) {\n            rowKey.push(this.rowGrandTotalLabel);\n            isToTalRecord = true;\n            break;\n          } else if (\n            // this.dataConfig?.totals?.row?.showSubTotals &&\n            this.dataConfig?.totals?.row?.subTotalsDimensions &&\n            this.dataConfig?.totals?.row?.subTotalsDimensions.indexOf(this.rows[l - 1]) >= 0\n          ) {\n            if (this.rowHierarchyType !== 'tree') {\n              //如果是tree的话 不附加标签'小计'\n              rowKey.push(this.rowSubTotalLabel);\n            }\n            isToTalRecord = true;\n            break;\n          }\n        }\n      }\n    }\n\n    if (\n      this.parseCustomTreeToMatchRecords &&\n      !(this.dataConfig as IPivotChartDataConfig)?.isPivotChart &&\n      this.customColTree?.length &&\n      !assignedIndicatorKey &&\n      !this.hasExtensionRowTree\n    ) {\n      const colTreePath = this.getFieldMatchColDimensionPaths(record);\n      if (colTreePath.length > 0) {\n        for (let i = 0, len = colTreePath.length; i < len; i++) {\n          const colPath = colTreePath[i];\n          const colKey: string[] = [];\n          let indicatorKey;\n          for (let j = 0, len1 = colPath.length; j < len1; j++) {\n            if (isValid(colPath[j].indicatorKey)) {\n              indicatorKey = colPath[j].indicatorKey;\n            } else {\n              colKey.push(colPath[j].value);\n            }\n          }\n          colKeys.push({ colKey: colKey, indicatorKey });\n        }\n      }\n    } else {\n      const colKey: string[] = [];\n      colKeys.push({ colKey, indicatorKey: assignedIndicatorKey });\n      for (let n = 0, len2 = this.columns.length; n < len2; n++) {\n        const colAttr = this.columns[n];\n        if (colAttr in record) {\n          this.columnsHasValue[n] = true;\n          colKey.push(record[colAttr]);\n        } else if (colAttr !== IndicatorDimensionKeyPlaceholder) {\n          //如果数据中缺失某个维度的值 可以认为是用户传入的汇总数据\n          if (\n            this.dataConfig?.totals?.column?.showGrandTotals &&\n            n === 0 &&\n            !this.columns.find((ck: string) => {\n              // 判断没有其他字段在record中\n              return ck in record;\n            })\n          ) {\n            colKey.push(this.colGrandTotalLabel);\n            isToTalRecord = true;\n            break;\n          } else if (\n            // this.dataConfig?.totals?.column?.showSubTotals &&\n            this.dataConfig?.totals?.column?.subTotalsDimensions &&\n            this.dataConfig?.totals?.column?.subTotalsDimensions.indexOf(this.columns[n - 1]) >= 0\n          ) {\n            // if (this.columnHierarchyType === 'grid') {\n            colKey.push(this.colSubTotalLabel);\n            // }\n            isToTalRecord = true;\n            break;\n          }\n        }\n      }\n    }\n    //#endregion\n    //#region 对path的数组 rowKeys和colKeys 做双重循环\n    for (let row_i = 0; row_i < rowKeys.length; row_i++) {\n      const rowKey = rowKeys[row_i].rowKey;\n      let assignedIndicatorKey_value;\n      if (!this.indicatorsAsCol) {\n        assignedIndicatorKey_value = rowKeys[row_i].indicatorKey;\n      }\n      for (let col_j = 0; col_j < colKeys.length; col_j++) {\n        const colKey = colKeys[col_j].colKey;\n        if (this.indicatorsAsCol) {\n          assignedIndicatorKey_value = colKeys[col_j].indicatorKey;\n        }\n        const flatRowKey = rowKey.join(this.stringJoinChar);\n        const flatColKey = colKey.join(this.stringJoinChar);\n\n        //#region 收集用户传入的汇总数据到totalRecordsTree\n        //该条数据为汇总数据\n        if (isToTalRecord) {\n          if (!this.totalRecordsTree[flatRowKey]) {\n            this.totalRecordsTree[flatRowKey] = {};\n          }\n          if (!this.totalRecordsTree[flatRowKey][flatColKey]) {\n            this.totalRecordsTree[flatRowKey][flatColKey] = [];\n          }\n          const toComputeIndicatorKeys = this.indicatorKeysIncludeCalculatedFieldDependIndicatorKeys;\n          for (let i = 0; i < toComputeIndicatorKeys.length; i++) {\n            if (this.calculatedFiledKeys.indexOf(toComputeIndicatorKeys[i]) >= 0) {\n              const calculatedFieldRule = this.calculatedFieldRules?.find(\n                rule => rule.key === toComputeIndicatorKeys[i]\n              );\n              if (!this.totalRecordsTree[flatRowKey]?.[flatColKey]?.[i]) {\n                this.totalRecordsTree[flatRowKey][flatColKey][i] = new registeredAggregators[\n                  AggregationType.RECALCULATE\n                ]({\n                  key: toComputeIndicatorKeys[i],\n                  field: toComputeIndicatorKeys[i],\n                  isRecord: true,\n                  // single: true,\n                  formatFun: (\n                    this.indicators?.find((indicator: string | IIndicator) => {\n                      if (typeof indicator !== 'string') {\n                        return indicator.indicatorKey === toComputeIndicatorKeys[i];\n                      }\n                      return false;\n                    }) as IIndicator\n                  )?.format,\n                  calculateFun: calculatedFieldRule?.calculateFun,\n                  dependAggregators: this.totalRecordsTree[flatRowKey][flatColKey],\n                  dependIndicatorKeys: calculatedFieldRule?.dependIndicatorKeys\n                });\n              }\n              toComputeIndicatorKeys[i] in record && this.totalRecordsTree[flatRowKey]?.[flatColKey]?.[i].push(record);\n            } else {\n              const aggRule = this.getAggregatorRule(toComputeIndicatorKeys[i]);\n              if (!this.totalRecordsTree[flatRowKey]?.[flatColKey]?.[i]) {\n                this.totalRecordsTree[flatRowKey][flatColKey][i] = new registeredAggregators[\n                  aggRule?.aggregationType ?? AggregationType.SUM\n                ]({\n                  // single: true,\n                  key: toComputeIndicatorKeys[i],\n                  field: aggRule?.field ?? toComputeIndicatorKeys[i],\n                  aggregationFun: aggRule?.aggregationFun,\n                  formatFun:\n                    aggRule?.formatFun ??\n                    (\n                      this.indicators?.find((indicator: string | IIndicator) => {\n                        if (typeof indicator !== 'string') {\n                          return indicator.indicatorKey === toComputeIndicatorKeys[i];\n                        }\n                        return false;\n                      }) as IIndicator\n                    )?.format\n                });\n              }\n\n              //push融合了计算过程\n              toComputeIndicatorKeys[i] in record && this.totalRecordsTree[flatRowKey]?.[flatColKey]?.[i].push(record);\n            }\n          }\n          return;\n        }\n        //#endregion\n\n        // 此方法判断效率很低\n        // if (this.rowKeys.indexOf(rowKey) === -1) this.rowKeys.push(rowKey);\n        // if (this.colKeys.indexOf(colKey) === -1) this.colKeys.push(colKey);\n\n        // 这一段代码需要再考虑下 目前isToTalRecord中没有 this.rowKeys.push逻辑 。造成的一个问题例如有列小计的相关自定义汇总数据，但没有push到this.rowKeys中\n        // 但是放到上面目前isToTalRecord逻辑return之前的话 会引起新的问题。这个this.rowKeys的补充是否需要从this.totalRecordsTree中获取到？ TODO（pivot-tree demo加上列小计就能复现）\n        if (rowKey.length !== 0) {\n          if (!this.rowFlatKeys[flatRowKey]) {\n            this.rowKeys.push(rowKey);\n            this.rowFlatKeys[flatRowKey] = 1;\n          }\n        }\n        if (colKey.length !== 0) {\n          if (!this.colFlatKeys[flatColKey]) {\n            this.colKeys.push(colKey);\n            this.colFlatKeys[flatColKey] = 1;\n          }\n        }\n\n        //组织树结构： 行-列-单元格  行key为flatRowKey如’山东青岛‘  列key为flatColKey如’家具椅子‘\n        if (!this.tree[flatRowKey]) {\n          this.tree[flatRowKey] = {};\n        }\n        //这里改成数组 因为可能是多个指标值 遍历indicators 生成对应类型的聚合对象\n        if (!this.tree[flatRowKey]?.[flatColKey]) {\n          this.tree[flatRowKey][flatColKey] = [];\n        }\n\n        const toComputeIndicatorKeys = this.indicatorKeysIncludeCalculatedFieldDependIndicatorKeys;\n        for (let i = 0; i < toComputeIndicatorKeys.length; i++) {\n          if (this.calculatedFiledKeys.indexOf(toComputeIndicatorKeys[i]) >= 0) {\n            const calculatedFieldRule = this.calculatedFieldRules?.find(rule => rule.key === toComputeIndicatorKeys[i]);\n            if (!this.tree[flatRowKey]?.[flatColKey]?.[i]) {\n              this.tree[flatRowKey][flatColKey][i] = new registeredAggregators[AggregationType.RECALCULATE]({\n                key: toComputeIndicatorKeys[i],\n                field: toComputeIndicatorKeys[i],\n                isRecord: true,\n                formatFun: (\n                  this.indicators?.find((indicator: string | IIndicator) => {\n                    if (typeof indicator !== 'string') {\n                      return indicator.indicatorKey === toComputeIndicatorKeys[i];\n                    }\n                    return false;\n                  }) as IIndicator\n                )?.format,\n                calculateFun: calculatedFieldRule?.calculateFun,\n                dependAggregators: this.tree[flatRowKey][flatColKey],\n                dependIndicatorKeys: calculatedFieldRule?.dependIndicatorKeys\n              });\n            }\n            this.tree[flatRowKey]?.[flatColKey]?.[i].push(record);\n          } else {\n            const aggRule = this.getAggregatorRule(toComputeIndicatorKeys[i]);\n            let needAddToAggregator = false;\n            if (assignedIndicatorKey_value) {\n              if (assignedIndicatorKey === assignedIndicatorKey_value) {\n                // 参数传入的assignedIndicatorKey 表示records是指标已经分好组的 组里一定要加入指标聚合对象中\n                toComputeIndicatorKeys[i] === assignedIndicatorKey_value && (needAddToAggregator = true);\n              } else {\n                toComputeIndicatorKeys[i] === assignedIndicatorKey_value &&\n                  toComputeIndicatorKeys[i] in record &&\n                  (needAddToAggregator = true);\n              }\n            }\n            //加入聚合结果 考虑field为数组的情况\n            else if (aggRule?.field) {\n              if (typeof aggRule?.field === 'string') {\n                aggRule?.field in record && (needAddToAggregator = true);\n              } else {\n                const isPush = aggRule?.field.find((field: string) => {\n                  return field in record;\n                });\n                isPush && (needAddToAggregator = true);\n              }\n            } else {\n              //push融合了计算过程\n              toComputeIndicatorKeys[i] in record && (needAddToAggregator = true);\n            }\n            if (!this.tree[flatRowKey]?.[flatColKey]?.[i] && needAddToAggregator) {\n              this.tree[flatRowKey][flatColKey][i] = new registeredAggregators[\n                aggRule?.aggregationType ?? AggregationType.SUM\n              ]({\n                key: toComputeIndicatorKeys[i],\n                field: aggRule?.field ?? toComputeIndicatorKeys[i],\n                aggregationFun: aggRule?.aggregationFun,\n                formatFun:\n                  aggRule?.formatFun ??\n                  (\n                    this.indicators?.find((indicator: string | IIndicator) => {\n                      if (typeof indicator !== 'string') {\n                        return indicator.indicatorKey === toComputeIndicatorKeys[i];\n                      }\n                      return false;\n                    }) as IIndicator\n                  )?.format\n              });\n            }\n\n            if (needAddToAggregator) {\n              this.tree[flatRowKey]?.[flatColKey]?.[i].push(record);\n            }\n          }\n        }\n        //统计整体的最大最小值和总计值 共mapping使用\n        if (this.mappingRules) {\n          for (let i = 0; i < this.indicatorKeys.length; i++) {\n            if (!this.indicatorStatistics[i]) {\n              const aggRule = this.getAggregatorRule(this.indicatorKeys[i]);\n              this.indicatorStatistics[i] = {\n                max: new registeredAggregators[AggregationType.MAX]({\n                  key: this.indicatorKeys[i],\n                  field: this.indicatorKeys[i]\n                }),\n                min: new registeredAggregators[AggregationType.MIN]({\n                  key: this.indicatorKeys[i],\n                  field: this.indicatorKeys[i]\n                }),\n                total: new registeredAggregators[aggRule?.aggregationType ?? AggregationType.SUM]({\n                  key: this.indicatorKeys[i],\n                  field: aggRule?.field ?? this.indicatorKeys[i],\n                  aggregationFun: aggRule?.aggregationFun,\n                  formatFun:\n                    aggRule?.formatFun ??\n                    (\n                      this.indicators?.find((indicator: string | IIndicator) => {\n                        if (typeof indicator !== 'string') {\n                          return indicator.indicatorKey === this.indicatorKeys[i];\n                        }\n                        return false;\n                      }) as IIndicator\n                    )?.format\n                })\n              };\n            }\n            //push融合了计算过程\n            this.indicatorStatistics[i].max.push(this.tree[flatRowKey]?.[flatColKey]?.[i].value());\n            this.indicatorStatistics[i].min.push(this.tree[flatRowKey]?.[flatColKey]?.[i].value());\n            this.indicatorStatistics[i].total.push(record);\n          }\n        }\n      }\n    }\n    //#endregion\n  }\n  /**\n   *  TODO 需要完善TreeToArr这里的逻辑\n   * 全量更新排序规则 对数据重新排序 生成行列paths\n   * @param sortRules\n   */\n  updateSortRules(sortRules: SortRules) {\n    this.sorted = false;\n    this.sortRules = sortRules;\n    this.sortKeys();\n    //和初始化代码逻辑一致 但未考虑透视图类型\n    if (!this.customRowTree) {\n      if (this.rowHierarchyType === 'tree') {\n        this.rowHeaderTree = this.ArrToTree1(\n          this.rowKeys,\n          this.rows.filter((key, index) => {\n            return this.rowsHasValue[index];\n          }),\n          this.indicatorsAsCol ? undefined : this.indicators,\n          this.totals?.row?.showGrandTotals ||\n            (!this.indicatorsAsCol && this.columns.length === 0) ||\n            (this.indicatorsAsCol && this.rows.length === 0),\n          this.rowGrandTotalLabel,\n          this.totals?.row?.showGrandTotalsOnTop ?? false\n        );\n      } else {\n        this.rowHeaderTree = this.ArrToTree(\n          this.rowKeys,\n          this.rows.filter((key, index) => {\n            return this.rowsHasValue[index];\n          }),\n          this.indicatorsAsCol ? undefined : this.indicators,\n          this.rowsIsTotal,\n          this.totals?.row?.showGrandTotals || (this.indicatorsAsCol && this.rows.length === 0),\n          this.rowGrandTotalLabel,\n          this.rowSubTotalLabel,\n          this.totals?.row?.showGrandTotalsOnTop ?? false,\n          this.totals?.row?.showSubTotalsOnTop ?? false\n        );\n      }\n    }\n\n    if (!this.customColTree) {\n      this.colHeaderTree = this.ArrToTree(\n        this.colKeys,\n        this.columns.filter((key, index) => {\n          return this.columnsHasValue[index];\n        }),\n        this.indicatorsAsCol ? this.indicators : undefined,\n        this.colsIsTotal,\n        this.totals?.column?.showGrandTotals || (!this.indicatorsAsCol && this.columns.length === 0), // || this.rows.length === 0,//todo  这里原有逻辑暂时注释掉\n        this.colGrandTotalLabel,\n        this.colSubTotalLabel,\n        this.totals?.column?.showGrandTotalsOnLeft ?? false,\n        this.totals?.column?.showSubTotalsOnLeft ?? false\n      );\n    }\n    // this.rowKeysPath_FULL = this.TreeToArr(\n    //   this.ArrToTree(\n    //     this.rowKeys,\n    //     this.rows,\n    //     this.indicatorsAsCol ? undefined : this.indicators,\n    //     this.rowsIsTotal,\n    //     this?.totals?.row?.showGrandTotals || this.columns.length === 0,\n    //     this.rowGrandTotalLabel,\n    //     this.rowSubTotalLabel\n    //   )\n    // );\n    // this.colKeysPath = this.TreeToArr(\n    //   this.ArrToTree(\n    //     this.colKeys,\n    //     this.columns,\n    //     this.indicatorsAsCol ? this.indicators : undefined,\n    //     this.colsIsTotal,\n    //     this.totals?.column?.showGrandTotals || this.rows.length === 0,\n    //     this.colGrandTotalLabel,\n    //     this.colSubTotalLabel\n    //   )\n    // );\n  }\n  /** 更新过滤规则 修改tree数据及收集的value */\n  updateFilterRules(filterRules: FilterRules, isResetTree: boolean = false) {\n    this.filterRules = filterRules;\n    this.filteredRecords = undefined;\n    if (isResetTree) {\n      this.tree = {};\n    } else {\n      for (const treeRowKey in this.tree) {\n        for (const treeColKey in this.tree[treeRowKey]) {\n          for (let i = 0; i < this.tree[treeRowKey][treeColKey].length; i++) {\n            this.tree[treeRowKey][treeColKey][i]?.reset();\n          }\n        }\n      }\n    }\n    this.collectedValues = {};\n    this.processRecords();\n    this.processCollectedValuesWithSumBy();\n    this.processCollectedValuesWithSortBy();\n    this.totalStatistics();\n    if ((this.dataConfig as IPivotChartDataConfig)?.isPivotChart) {\n      // 处理PivotChart双轴图0值对齐\n      // this.dealWithZeroAlign();\n      // 记录PivotChart维度对应的数据\n      this.cacheDeminsionCollectedValues();\n    }\n  }\n  private getAggregatorRule(indicatorKey: string): AggregationRule<AggregationType> | undefined {\n    return this.aggregationRules?.find((value: AggregationRule<AggregationType>, index: number) => {\n      return indicatorKey === value.indicatorKey;\n    });\n  }\n  /**\n   * 根据行列的维度key 获取聚合对象\n   * @param rowKey\n   * @param colKey\n   * @param indicator\n   * @returns\n   */\n  getAggregator(\n    rowKey: string[] | string = [],\n    colKey: string[] | string = [],\n    indicator: string,\n    considerChangedValue: boolean = true,\n    indicatorPosition?: { position: 'col' | 'row'; index?: number }\n  ): IAggregator {\n    const indicatorIndex = this.indicatorKeys.indexOf(indicator);\n    // let agg;\n    let flatRowKey;\n    let flatColKey;\n    if (typeof rowKey === 'string') {\n      flatRowKey = rowKey;\n    } else {\n      //考虑 指标key有可能在数组中间位置或者前面的可能 将其删除再添加到尾部\n      if (!indicatorPosition || indicatorPosition.position === 'row') {\n        rowKey.map((key, i) => {\n          if (key === indicator && (!isValid(indicatorPosition?.index) || i === indicatorPosition.index)) {\n            rowKey.splice(i, 1);\n          }\n        });\n      }\n      if (rowKey.length < this.rows.length && this.rowHierarchyType === 'grid-tree') {\n        // 如果是平铺树结构 小计需要处理补充到rowKey中\n        if (rowKey[0] === this.rowGrandTotalLabel) {\n        } else if (\n          this.totals?.row?.subTotalsDimensions &&\n          this.totals?.row?.subTotalsDimensions?.length >= 1 &&\n          rowKey[rowKey.length - 1] !== this.rowSubTotalLabel\n        ) {\n          rowKey.push(this.rowSubTotalLabel);\n        }\n      }\n      // flatRowKey = rowKey.join(this.stringJoinChar);\n      flatRowKey = join(rowKey, this.stringJoinChar);\n    }\n\n    if (typeof colKey === 'string') {\n      flatColKey = colKey;\n    } else {\n      //考虑 指标key有可能在数组中间位置或者前面的可能 将其删除再添加到尾部\n      if (!indicatorPosition || indicatorPosition.position === 'col') {\n        colKey.map((key, i) => {\n          if (key === indicator && (!isValid(indicatorPosition?.index) || i === indicatorPosition.index)) {\n            colKey.splice(i, 1);\n          }\n        });\n      }\n      if (colKey.length < this.columns.length && this.columnHierarchyType === 'grid-tree') {\n        if (colKey[0] === this.colGrandTotalLabel) {\n        } else if (\n          this.totals?.column?.subTotalsDimensions &&\n          this.totals?.column?.subTotalsDimensions?.length >= 1 &&\n          colKey[colKey.length - 1] !== this.colSubTotalLabel\n        ) {\n          colKey.push(this.colSubTotalLabel);\n        }\n      }\n      // flatColKey = colKey.join(this.stringJoinChar);\n      flatColKey = join(colKey, this.stringJoinChar);\n    }\n    //TODO 原有逻辑 但这里先强制跳过\n    // if ( rowKey.length === 0 && colKey.length === 0) {\n    // agg = this.allTotal;\n    // } else if (rowKey.length === 0) {\n    //   // agg = this.tree.total[flatColKey]?.[sortByIndicatorIndex];\n    //   agg = this.colTotals[flatColKey]?.[sortByIndicatorIndex];\n    // } else if (colKey.length === 0) {\n    //   // agg = this.tree[flatRowKey].total?.[sortByIndicatorIndex];\n    //   agg = this.rowTotals[flatRowKey]?.[sortByIndicatorIndex];\n    // } else {\n    const agg = this.tree[flatRowKey]?.[flatColKey]?.[indicatorIndex];\n    if (considerChangedValue && isValid(this.changedTree[flatRowKey]?.[flatColKey]?.[indicatorIndex])) {\n      const changeValue = this.changedTree[flatRowKey][flatColKey][indicatorIndex];\n      if (agg) {\n        return {\n          value: () => {\n            return changeValue;\n          },\n          formatValue: agg.formatValue,\n          formatFun: agg.formatFun,\n          records: agg.records,\n          recalculate() {\n            // do nothing\n          },\n          push() {\n            // do nothing\n          },\n          deleteRecord() {\n            // do nothing\n          },\n          updateRecord() {\n            // do nothing\n          },\n          clearCacheValue() {\n            // do nothing\n          },\n          reset() {\n            // do nothing\n          }\n        };\n        // agg.clearCacheValue();\n        // agg.value = () => { // 你们直接在原来的agg上赋值 会影响获取原始值的获取\n        //   return changeValue;\n        // };\n      }\n      return {\n        records: [],\n        value() {\n          return changeValue;\n        },\n        push() {\n          // do nothing\n        },\n        deleteRecord() {\n          // do nothing\n        },\n        updateRecord() {\n          // do nothing\n        },\n        recalculate() {\n          // do nothing\n        },\n        formatValue() {\n          return changeValue;\n        },\n        clearCacheValue() {\n          // do nothing\n        },\n        reset() {\n          // do nothing\n        }\n      };\n    }\n\n    // }\n    return agg\n      ? agg\n      : {\n          records: [],\n          push() {\n            // do nothing\n          },\n          deleteRecord() {\n            // do nothing\n          },\n          updateRecord() {\n            // do nothing\n          },\n          recalculate() {\n            // do nothing\n          },\n          value(): any {\n            return null;\n          },\n          clearCacheValue() {\n            // do nothing\n          },\n          reset() {\n            // do nothing\n          }\n        };\n  }\n  /**\n   * 根据排序规则 对维度keys排序\n   */\n  sortKeys() {\n    this.colKeys = this.colKeys_normal.slice();\n    this.rowKeys = this.rowKeys_normal.slice();\n    const that = this;\n    if (!this.sorted) {\n      this.sorted = true;\n      // const getValue = function (rowKey: any, colKey: any) {\n      //   return that.getAggregator(rowKey, colKey, '').value();\n      // };\n\n      // switch (this.rowOrder) {\n      //   case 'value_a_to_z':\n      //     this.rowKeys.sort(function (a, b) {\n      //       return naturalSort(getValue(a, []), getValue(b, []));\n      //     });\n      //     break;\n      //   case 'value_z_to_a':\n      //     this.rowKeys.sort(function (a, b) {\n      //       return -naturalSort(getValue(a, []), getValue(b, []));\n      //     });\n      //     break;\n      //   default:\n      this.rowKeys.sort(this.arrSort(this.rows, true));\n      // }\n      // switch (this.colOrder) {\n      //   case 'value_a_to_z':\n      //     this.colKeys.sort(function (a, b) {\n      //       return naturalSort(getValue([], a), getValue([], b));\n      //     });\n      //     break;\n      //   case 'value_z_to_a':\n      //     this.colKeys.sort(function (a, b) {\n      //       return -naturalSort(getValue([], a), getValue([], b));\n      //     });\n      //     break;\n      //   default:\n      const sortfun = this.arrSort(this.columns, false);\n      this.colKeys.sort(sortfun);\n      // }\n    }\n  }\n  /**\n   * 生成排序函数 综合配置的多条排序规则\n   * @param fieldArr 排序维度名称 如行rows 列columns\n   * @returns\n   */\n  arrSort(fieldArr: string[], isRow: boolean) {\n    let field;\n    const that = this;\n    const sortersArr: any[] = function (_this: any) {\n      const results: any = [];\n      for (let l = 0, len1 = fieldArr.length; l < len1; l++) {\n        field = fieldArr[l];\n        let isHasSortRule = false;\n        if (that.sortRules) {\n          for (let m = 0, len2 = that.sortRules.length; m < len2; m++) {\n            if (that.sortRules[m].sortField === field) {\n              isHasSortRule = true;\n              results.push({\n                field,\n                fieldIndex: l,\n                sortRule: that.sortRules[m],\n                func: that.getSort(that.sortRules[m], isRow)\n              });\n\n              // if (that.sortRules[m].sortByIndicator) {\n              //   isHasSortRule = true;\n              //   results.push({\n              //     field,\n              //     fieldIndex: l,\n              //     sortRule: that.sortRules[m],\n              //     func: that.getSort(that.sortRules[m], field),\n              //   });\n              // }\n            }\n          }\n        }\n        // 去掉内部默认排序\n        // if (!isHasSortRule) {\n        //   results.push({ field, fieldIndex: l, func: naturalSort });\n        // }\n      }\n      return results;\n    }.call(this);\n    return function (a: string[], b: string[]) {\n      let comparison;\n      let sorter;\n      for (let i = 0; i < sortersArr.length; i++) {\n        sorter = sortersArr[i];\n        // if (!(sorter.sortRule?.sortType === SortType.NORMAL || sorter.sortRule?.sortType === SortType.normal)) {\n        if (sorter.sortRule?.sortByIndicator) {\n          let aChanged = a;\n          let bChanged = b;\n          if (sorter.fieldIndex < fieldArr.length - 1) {\n            aChanged = a.slice(0, sorter.fieldIndex + 1);\n            if (that.rowHierarchyType === 'grid' && isRow) {\n              aChanged.push(that.rowSubTotalLabel);\n            } else if (!isRow) {\n              aChanged.push(that.colSubTotalLabel);\n            }\n            bChanged = b.slice(0, sorter.fieldIndex + 1);\n            if (that.rowHierarchyType === 'grid' && isRow) {\n              bChanged.push(that.rowSubTotalLabel);\n            } else if (!isRow) {\n              bChanged.push(that.colSubTotalLabel);\n            }\n          }\n          comparison = sorter.func(aChanged, bChanged, sorter.sortRule?.sortType);\n        } else {\n          comparison = sorter.func?.(a[sorter.fieldIndex], b[sorter.fieldIndex], sorter.sortRule?.sortType);\n        }\n        if (comparison !== 0) {\n          return comparison;\n          // return (\n          //   comparison *\n          //   (sorter.sortRule?.sortType === SortType.DESC || sorter.sortRule?.sortType === SortType.desc ? -1 : 1)\n          // );\n        }\n      }\n      return 0;\n    };\n  }\n  /**\n   * 根据具体排序 获取不同的排序函数\n   * @param sortRule\n   * @returns\n   */\n  getSort(sortRule: SortRule, isSortRow: boolean) {\n    const that = this;\n\n    if ((<SortByIndicatorRule>sortRule).sortByIndicator) {\n      return (a: string[], b: string[], sortType?: SortType) => {\n        /**\n         * 根据rowKey和colKey获取tree上对应的聚合值\n         * @param rowKey\n         * @param colKey\n         * @returns\n         */\n        const getValue = function (rowKey: any, colKey: any) {\n          //如果rowKey提供的不全 如 [地区,省,城市] 只提供了如[华东,山东] 会补全为[华东,山东,小计]\n          if (\n            that.rowHierarchyType === 'grid' &&\n            rowKey.length < that.rows.length &&\n            rowKey[rowKey.length - 1] !== that.rowSubTotalLabel &&\n            rowKey[rowKey.length - 1] !== that.rowGrandTotalLabel\n          ) {\n            rowKey.push(that.rowSubTotalLabel);\n          }\n          if (\n            colKey.length < that.columns.length &&\n            colKey[colKey.length - 1] !== that.colSubTotalLabel &&\n            colKey[colKey.length - 1] !== that.colGrandTotalLabel\n          ) {\n            colKey.push(that.colSubTotalLabel);\n          }\n          return that.getAggregator(rowKey, colKey, (<SortByIndicatorRule>sortRule).sortByIndicator!).value();\n        };\n        if (isSortRow) {\n          if ((<SortByIndicatorRule>sortRule).sortFunc) {\n            return (<SortByIndicatorRule>sortRule).sortFunc(\n              getValue(a, (<SortByIndicatorRule>sortRule).query),\n              getValue(b, (<SortByIndicatorRule>sortRule).query),\n              a,\n              b,\n              sortType\n            );\n          }\n          return naturalSort(\n            getValue(a, (<SortByIndicatorRule>sortRule).query),\n            getValue(b, (<SortByIndicatorRule>sortRule).query),\n            sortType\n          );\n        }\n        if ((<SortByIndicatorRule>sortRule).sortFunc) {\n          return (<SortByIndicatorRule>sortRule).sortFunc(\n            getValue((<SortByIndicatorRule>sortRule).query, a),\n            getValue((<SortByIndicatorRule>sortRule).query, b),\n            a,\n            b,\n            sortType\n          );\n        }\n        return naturalSort(\n          getValue((<SortByIndicatorRule>sortRule).query, a),\n          getValue((<SortByIndicatorRule>sortRule).query, b),\n          sortType\n        );\n      };\n    } else if ((<SortByRule>sortRule).sortBy) {\n      return sortBy((<SortByRule>sortRule).sortBy);\n    }\n\n    if ((<SortFuncRule>sortRule).sortFunc) {\n      return (<SortFuncRule>sortRule).sortFunc;\n    }\n    if ((<SortTypeRule>sortRule).sortType) {\n      return typeSort;\n    }\n    return naturalSort;\n  }\n  /**\n   * 汇总小计\n   */\n  totalStatistics() {\n    const that = this;\n    /**\n     * 计算每一行的所有列的汇总值\n     * @param flatRowKey\n     * @param flatColKey\n     */\n    const colCompute = (flatRowKey: string, flatColKey: string) => {\n      if (this.totalRecordsTree?.[flatRowKey]?.[flatColKey]) {\n        // 利用汇总数据替换\n        if (!this.tree[flatRowKey]) {\n          this.tree[flatRowKey] = {};\n        }\n        this.tree[flatRowKey][flatColKey] = this.totalRecordsTree?.[flatRowKey]?.[flatColKey];\n        return;\n      }\n      const colKey = flatColKey.split(this.stringJoinChar);\n      if (\n        that.totals?.column?.subTotalsDimensions &&\n        that.totals?.column?.subTotalsDimensions?.length > 0 &&\n        that.totals.column.showSubTotals !== false\n      ) {\n        for (let i = 0, len = that.totals?.column?.subTotalsDimensions?.length; i < len; i++) {\n          const dimension = that.totals.column.subTotalsDimensions[i];\n          const dimensionIndex = that.columns.indexOf(dimension);\n          if (dimensionIndex >= 0) {\n            const colTotalKey = colKey.slice(0, dimensionIndex + 1);\n            // if (this.columnHierarchyType === 'grid') {\n            colTotalKey.push(that.colSubTotalLabel);\n            // }\n            const flatColTotalKey = colTotalKey.join(this.stringJoinChar);\n            if (this.totalRecordsTree?.[flatRowKey]?.[flatColTotalKey]) {\n              // 利用汇总数据替换\n              this.tree[flatRowKey][flatColTotalKey] = this.totalRecordsTree?.[flatRowKey]?.[flatColTotalKey];\n              return;\n            }\n            if (!this.tree[flatRowKey][flatColTotalKey]) {\n              this.tree[flatRowKey][flatColTotalKey] = [];\n            }\n            const toComputeIndicatorKeys = this.indicatorKeysIncludeCalculatedFieldDependIndicatorKeys;\n\n            for (let i = 0; i < toComputeIndicatorKeys.length; i++) {\n              if (this.calculatedFiledKeys.indexOf(toComputeIndicatorKeys[i]) >= 0) {\n                const calculatedFieldRule = this.calculatedFieldRules?.find(\n                  rule => rule.key === toComputeIndicatorKeys[i]\n                );\n                if (!this.tree[flatRowKey]?.[flatColTotalKey]?.[i]) {\n                  this.tree[flatRowKey][flatColTotalKey][i] = new registeredAggregators[AggregationType.RECALCULATE]({\n                    key: toComputeIndicatorKeys[i],\n                    field: toComputeIndicatorKeys[i],\n                    isRecord: true,\n                    formatFun: (\n                      this.indicators?.find((indicator: string | IIndicator) => {\n                        if (typeof indicator !== 'string') {\n                          return indicator.indicatorKey === toComputeIndicatorKeys[i];\n                        }\n                        return false;\n                      }) as IIndicator\n                    )?.format,\n                    calculateFun: calculatedFieldRule?.calculateFun,\n                    dependAggregators: this.tree[flatRowKey][flatColTotalKey],\n                    dependIndicatorKeys: calculatedFieldRule?.dependIndicatorKeys\n                  });\n                }\n                if (flatColTotalKey !== flatColKey) {\n                  this.tree[flatRowKey][flatColTotalKey][i].push(that.tree[flatRowKey]?.[flatColKey]?.[i]);\n                }\n              } else {\n                if (!this.tree[flatRowKey][flatColTotalKey][i]) {\n                  const aggRule = this.getAggregatorRule(toComputeIndicatorKeys[i]);\n                  this.tree[flatRowKey][flatColTotalKey][i] = new registeredAggregators[\n                    aggRule?.aggregationType ?? AggregationType.SUM\n                  ]({\n                    key: toComputeIndicatorKeys[i],\n                    field: aggRule?.field ?? toComputeIndicatorKeys[i],\n                    aggregationFun: aggRule?.aggregationFun,\n                    formatFun:\n                      aggRule?.formatFun ??\n                      (\n                        this.indicators?.find((indicator: string | IIndicator) => {\n                          if (typeof indicator !== 'string') {\n                            return indicator.indicatorKey === toComputeIndicatorKeys[i];\n                          }\n                          return false;\n                        }) as IIndicator\n                      )?.format\n                  });\n                }\n                if (flatColTotalKey !== flatColKey) {\n                  this.tree[flatRowKey][flatColTotalKey][i].push(that.tree[flatRowKey]?.[flatColKey]?.[i]);\n                }\n              }\n            }\n          }\n        }\n      }\n      if (that.totals?.column?.showGrandTotals || this.rows.length === 0) {\n        const flatColTotalKey = that.colGrandTotalLabel;\n        if (this.totalRecordsTree?.[flatRowKey]?.[flatColTotalKey]) {\n          // 利用汇总数据替换\n          this.tree[flatRowKey][flatColTotalKey] = this.totalRecordsTree?.[flatRowKey]?.[flatColTotalKey];\n          return;\n        }\n        if (!this.tree[flatRowKey][flatColTotalKey]) {\n          this.tree[flatRowKey][flatColTotalKey] = [];\n        }\n        const toComputeIndicatorKeys = this.indicatorKeysIncludeCalculatedFieldDependIndicatorKeys;\n        for (let i = 0; i < toComputeIndicatorKeys.length; i++) {\n          if (this.calculatedFiledKeys.indexOf(toComputeIndicatorKeys[i]) >= 0) {\n            const calculatedFieldRule = this.calculatedFieldRules?.find(rule => rule.key === toComputeIndicatorKeys[i]);\n            if (!this.tree[flatRowKey]?.[flatColTotalKey]?.[i]) {\n              this.tree[flatRowKey][flatColTotalKey][i] = new registeredAggregators[AggregationType.RECALCULATE]({\n                key: toComputeIndicatorKeys[i],\n                field: toComputeIndicatorKeys[i],\n                isRecord: true,\n                formatFun: (\n                  this.indicators?.find((indicator: string | IIndicator) => {\n                    if (typeof indicator !== 'string') {\n                      return indicator.indicatorKey === toComputeIndicatorKeys[i];\n                    }\n                    return false;\n                  }) as IIndicator\n                )?.format,\n                calculateFun: calculatedFieldRule?.calculateFun,\n                dependAggregators: this.tree[flatRowKey][flatColTotalKey],\n                dependIndicatorKeys: calculatedFieldRule?.dependIndicatorKeys\n              });\n            }\n            if (flatColTotalKey !== flatColKey) {\n              this.tree[flatRowKey][flatColTotalKey][i].push(that.tree[flatRowKey]?.[flatColKey]?.[i]);\n            }\n          } else {\n            if (!this.tree[flatRowKey][flatColTotalKey][i]) {\n              const aggRule = this.getAggregatorRule(toComputeIndicatorKeys[i]);\n              this.tree[flatRowKey][flatColTotalKey][i] = new registeredAggregators[\n                aggRule?.aggregationType ?? AggregationType.SUM\n              ]({\n                key: toComputeIndicatorKeys[i],\n                field: aggRule?.field ?? toComputeIndicatorKeys[i],\n                formatFun:\n                  aggRule?.formatFun ??\n                  (\n                    this.indicators?.find((indicator: string | IIndicator) => {\n                      if (typeof indicator !== 'string') {\n                        return indicator.indicatorKey === toComputeIndicatorKeys[i];\n                      }\n                      return false;\n                    }) as IIndicator\n                  )?.format\n              });\n            }\n            if (flatColTotalKey !== flatColKey) {\n              this.tree[flatRowKey][flatColTotalKey][i].push(that.tree[flatRowKey]?.[flatColKey]?.[i]);\n            }\n          }\n        }\n      }\n    };\n\n    if (\n      (that?.totals?.column?.subTotalsDimensions && that?.totals?.column?.subTotalsDimensions?.length >= 1) ||\n      (that?.totals?.row?.subTotalsDimensions && that?.totals?.row?.subTotalsDimensions?.length >= 1) ||\n      that?.totals?.column?.showGrandTotals ||\n      that?.totals?.row?.showGrandTotals\n      // ||\n      // that.rows.length === 0 || //todo  这里原有逻辑暂时注释掉\n      // that.columns.length === 0\n    ) {\n      const rowTotalKeys: string[] = [];\n\n      Object.keys(that.tree).forEach(flatRowKey => {\n        const rowKey = flatRowKey.split(this.stringJoinChar);\n        Object.keys(that.tree[flatRowKey]).forEach(flatColKey => {\n          if (\n            that.totals?.row?.subTotalsDimensions &&\n            that.totals?.row?.subTotalsDimensions?.length > 0 &&\n            that.totals.row.showSubTotals !== false\n          ) {\n            for (let i = 0, len = that.totals?.row?.subTotalsDimensions?.length; i < len; i++) {\n              const dimension = that.totals.row.subTotalsDimensions[i];\n              const dimensionIndex = that.rows.indexOf(dimension);\n              if (dimensionIndex >= 0 && dimensionIndex < that.rows.length - 1) {\n                const rowTotalKey = rowKey.slice(0, dimensionIndex + 1);\n                if (this.rowHierarchyType !== 'tree') {\n                  // 如果是tree的情况则不追加小计单元格值\n                  rowTotalKey.push(that.rowSubTotalLabel);\n                }\n                const flatRowTotalKey = rowTotalKey.join(this.stringJoinChar);\n                if (!this.tree[flatRowTotalKey]) {\n                  this.tree[flatRowTotalKey] = {};\n                  rowTotalKeys.push(flatRowTotalKey);\n                }\n                if (!this.tree[flatRowTotalKey][flatColKey]) {\n                  this.tree[flatRowTotalKey][flatColKey] = [];\n                }\n                const toComputeIndicatorKeys = this.indicatorKeysIncludeCalculatedFieldDependIndicatorKeys;\n                for (let i = 0; i < toComputeIndicatorKeys.length; i++) {\n                  if (!this.tree[flatRowTotalKey][flatColKey][i]) {\n                    if (this.calculatedFiledKeys.indexOf(toComputeIndicatorKeys[i]) >= 0) {\n                      const calculatedFieldRule = this.calculatedFieldRules?.find(\n                        rule => rule.key === toComputeIndicatorKeys[i]\n                      );\n                      this.tree[flatRowTotalKey][flatColKey][i] = new registeredAggregators[\n                        AggregationType.RECALCULATE\n                      ]({\n                        key: toComputeIndicatorKeys[i],\n                        field: toComputeIndicatorKeys[i],\n                        isRecord: true,\n                        formatFun: (\n                          this.indicators?.find((indicator: string | IIndicator) => {\n                            if (typeof indicator !== 'string') {\n                              return indicator.indicatorKey === toComputeIndicatorKeys[i];\n                            }\n                            return false;\n                          }) as IIndicator\n                        )?.format,\n                        calculateFun: calculatedFieldRule?.calculateFun,\n                        dependAggregators: this.tree[flatRowTotalKey][flatColKey],\n                        dependIndicatorKeys: calculatedFieldRule?.dependIndicatorKeys\n                      });\n                    } else {\n                      const aggRule = this.getAggregatorRule(toComputeIndicatorKeys[i]);\n                      this.tree[flatRowTotalKey][flatColKey][i] = new registeredAggregators[\n                        aggRule?.aggregationType ?? AggregationType.SUM\n                      ]({\n                        key: toComputeIndicatorKeys[i],\n                        field: aggRule?.field ?? toComputeIndicatorKeys[i],\n                        formatFun:\n                          aggRule?.formatFun ??\n                          (\n                            this.indicators?.find((indicator: string | IIndicator) => {\n                              if (typeof indicator !== 'string') {\n                                return indicator.indicatorKey === toComputeIndicatorKeys[i];\n                              }\n                              return false;\n                            }) as IIndicator\n                          )?.format\n                      });\n                    }\n                  }\n                  if (flatRowTotalKey !== flatRowKey) {\n                    this.tree[flatRowTotalKey][flatColKey][i].push(that.tree[flatRowKey]?.[flatColKey]?.[i]);\n                  }\n                }\n              }\n            }\n          }\n\n          if (that.totals?.row?.showGrandTotals || this.columns.length === 0) {\n            const flatRowTotalKey = that.rowGrandTotalLabel;\n            if (!this.tree[flatRowTotalKey]) {\n              this.tree[flatRowTotalKey] = {};\n              rowTotalKeys.push(flatRowTotalKey);\n            }\n            if (!this.tree[flatRowTotalKey][flatColKey]) {\n              this.tree[flatRowTotalKey][flatColKey] = [];\n            }\n            const toComputeIndicatorKeys = this.indicatorKeysIncludeCalculatedFieldDependIndicatorKeys;\n            for (let i = 0; i < toComputeIndicatorKeys.length; i++) {\n              if (!this.tree[flatRowTotalKey][flatColKey][i]) {\n                if (this.calculatedFiledKeys.indexOf(toComputeIndicatorKeys[i]) >= 0) {\n                  const calculatedFieldRule = this.calculatedFieldRules?.find(\n                    rule => rule.key === toComputeIndicatorKeys[i]\n                  );\n                  this.tree[flatRowTotalKey][flatColKey][i] = new registeredAggregators[AggregationType.RECALCULATE]({\n                    key: toComputeIndicatorKeys[i],\n                    field: toComputeIndicatorKeys[i],\n                    isRecord: true,\n                    formatFun: (\n                      this.indicators?.find((indicator: string | IIndicator) => {\n                        if (typeof indicator !== 'string') {\n                          return indicator.indicatorKey === toComputeIndicatorKeys[i];\n                        }\n                        return false;\n                      }) as IIndicator\n                    )?.format,\n                    calculateFun: calculatedFieldRule?.calculateFun,\n                    dependAggregators: this.tree[flatRowTotalKey][flatColKey],\n                    dependIndicatorKeys: calculatedFieldRule?.dependIndicatorKeys\n                  });\n                } else {\n                  const aggRule = this.getAggregatorRule(toComputeIndicatorKeys[i]);\n                  this.tree[flatRowTotalKey][flatColKey][i] = new registeredAggregators[\n                    aggRule?.aggregationType ?? AggregationType.SUM\n                  ]({\n                    key: toComputeIndicatorKeys[i],\n                    field: aggRule?.field ?? toComputeIndicatorKeys[i],\n                    formatFun:\n                      aggRule?.formatFun ??\n                      (\n                        this.indicators?.find((indicator: string | IIndicator) => {\n                          if (typeof indicator !== 'string') {\n                            return indicator.indicatorKey === toComputeIndicatorKeys[i];\n                          }\n                          return false;\n                        }) as IIndicator\n                      )?.format\n                  });\n                }\n              }\n              if (flatRowTotalKey !== flatRowKey) {\n                this.tree[flatRowTotalKey][flatColKey][i].push(that.tree[flatRowKey]?.[flatColKey]?.[i]);\n              }\n            }\n          }\n          colCompute(flatRowKey, flatColKey);\n        });\n      });\n      //增加出来的rowTotalKeys 再遍历一次 汇总小计的小计 如 东北小计（row）-办公用品小计（col）所指单元格的值\n      rowTotalKeys.forEach(flatRowKey => {\n        Object.keys(that.tree[flatRowKey]).forEach(flatColKey => {\n          colCompute(flatRowKey, flatColKey);\n\n          // //处理 row-sub-total  中没有col-sub-total的情况\n          // if (\n          //   that.totals?.column?.subTotalsDimensions &&\n          //   that.totals?.column?.subTotalsDimensions?.length > 0 &&\n          //   that.totals.column.showSubTotals !== false\n          // ) {\n          //   const colKey = flatColKey.split(this.stringJoinChar);\n          //   for (let i = 0, len = that.totals?.column?.subTotalsDimensions?.length; i < len; i++) {\n          //     const dimension = that.totals.column.subTotalsDimensions[i];\n          //     const dimensionIndex = that.columns.indexOf(dimension);\n          //     if (dimensionIndex >= 0) {\n          //       const colTotalKey = colKey.slice(0, dimensionIndex + 1);\n          //       colTotalKey.push(that.colSubTotalLabel);\n          //       const flatColTotalKey = colTotalKey.join(this.stringJoinChar);\n          //       if (!this.tree[flatRowKey][flatColTotalKey]) {\n          //         colCompute(flatRowKey, flatColTotalKey);\n          //       }\n          //     }\n          //   }\n          // }\n        });\n        // //处理 row-total  中没有col-total的情况\n        // if (that.totals?.column?.showGrandTotals || this.rows.length === 0) {\n        //   const flatColTotalKey = that.colGrandTotalLabel;\n        //   if (!this.tree[flatRowKey][flatColTotalKey]) {\n        //     colCompute(flatRowKey, flatColTotalKey);\n        //   }\n        // }\n      });\n    }\n    // else if (that.rowHierarchyType === 'tree') {\n    // for (const flatRowKey in that.totalRecordsTree) {\n    //   for (const flatColKey in that.totalRecordsTree[flatRowKey]) {\n    //     colCompute(flatRowKey, flatColKey);\n    //   }\n    // }\n    // }\n    for (const flatRowKey in that.totalRecordsTree) {\n      for (const flatColKey in that.totalRecordsTree[flatRowKey]) {\n        colCompute(flatRowKey, flatColKey);\n      }\n    }\n  }\n  /**\n   * 将rowKeys和colKeys 转为树形结构\n   * @param arr\n   * @returns\n   */\n  private ArrToTree1(\n    arr: string[][],\n    rows: string[],\n    indicators: (string | IIndicator)[] | undefined,\n    isGrandTotal: boolean,\n    grandTotalLabel: string,\n    showGrandTotalsOnTop: boolean\n  ) {\n    /**\n     *\n     * @param {string} s 父级id\n     * @param {number} n 需转换数字\n     */\n    // const getId = (pId: any, curId: any) => `${pId}$${curId}`;\n    const result: any[] = []; // 结果\n    const concatStr = this.stringJoinChar; // 连接符(随便写，保证key唯一性就OK)\n    const map = new Map(); // 存储根节点 主要提升性能\n    function addList(list: any, isGrandTotal: boolean) {\n      const path: any[] = []; // 路径\n      let node: any; // 当前节点\n      list.forEach((value: any, index: number) => {\n        path.push(value);\n        const flatKey = path.join(concatStr);\n        //id的值可以每次生成一个新的 这里用的path作为id 方便layout对象获取\n        let item: { value: string; dimensionKey: string; children: any[] | undefined } = map.get(flatKey); // 当前节点\n        if (!item) {\n          item = {\n            value,\n            // id: flatKey, //getId(node?.id ?? '', (node?.children?.length ?? result.length) + 1),\n            dimensionKey: rows[index],\n            //树的叶子节点补充指标\n            children:\n              index === list.length - 1 && (indicators?.length ?? 0) >= 1\n                ? indicators?.map(indicator => {\n                    if (typeof indicator === 'string') {\n                      return {\n                        indicatorKey: indicator,\n                        value: indicator\n                      };\n                    }\n                    return {\n                      indicatorKey: indicator.indicatorKey,\n                      value: indicator.title\n                    };\n                  })\n                : []\n          };\n\n          map.set(flatKey, item); // 存储路径对应的节点\n          if (node) {\n            node.children.push(item);\n          } else {\n            if (showGrandTotalsOnTop && isGrandTotal) {\n              result.unshift(item);\n            } else {\n              result.push(item);\n            }\n          }\n        }\n        node = item; // 更新当前节点\n      });\n    }\n\n    arr.forEach(item => addList(item, false));\n    if (isGrandTotal) {\n      addList([grandTotalLabel], isGrandTotal);\n    }\n    return result;\n  }\n  /**\n   * 将rowKeys和colKeys 转为树形结构\n   * @param arr\n   * @param subTotalFlags 标志小计的维度\n   * @returns\n   */\n  private ArrToTree(\n    arr: string[][],\n    rows: string[],\n    indicators: (string | IIndicator)[] | undefined,\n    subTotalFlags: boolean[],\n    isGrandTotal: boolean,\n    grandTotalLabel: string,\n    subTotalLabel: string,\n    showGrandTotalsOnTop: boolean,\n    showSubTotalsOnTop: boolean\n  ) {\n    /**\n     *\n     * @param {string} s 父级id\n     * @param {number} n 需转换数字\n     */\n    // const getId = (pId: any, curId: any) => `${pId}$${curId}`;\n    let result: any[] = []; // 结果\n    const concatStr = this.stringJoinChar; // 连接符(随便写，保证key唯一性就OK)\n    const map = new Map(); // 存储根节点 主要提升性能\n    function addList(list: any) {\n      const path: any[] = []; // 路径\n      let node: any; // 当前节点\n      list.forEach((value: any, index: number) => {\n        path.push(value);\n        const flatKey = path.join(concatStr);\n        //id的值可以每次生成一个新的 这里用的path作为id 方便layout对象获取\n        let item: { value: string; dimensionKey: string; children: any[] | undefined } = map.get(flatKey); // 当前节点\n        if (!item) {\n          item = {\n            value,\n            dimensionKey: rows[index],\n            // id: flatKey, //getId(node?.id ?? '', (node?.children?.length ?? result.length) + 1),\n            //树的叶子节点补充指标\n            children:\n              index === list.length - 1 && (indicators?.length ?? 0) >= 1\n                ? indicators?.map(indicator => {\n                    if (typeof indicator === 'string') {\n                      return {\n                        indicatorKey: indicator,\n                        value: indicator\n                      };\n                    }\n                    return {\n                      indicatorKey: indicator.indicatorKey,\n                      value: indicator.title\n                    };\n                  })\n                : []\n          };\n          if (subTotalFlags[index]) {\n            let curChild = item.children ?? [];\n            // for (let i = index; i < list.length - 1; i++) {\n            const totalChild: {\n              value: string;\n              dimensionKey: string;\n              children: any[] | undefined;\n              levelSpan: number;\n              role: string;\n            } = {\n              value: subTotalLabel,\n              dimensionKey: rows[index + 1],\n              levelSpan: subTotalFlags.length - index - 1,\n              // id: `${flatKey}${concatStr}${subTotalLabel}`, // getId(item?.id, 1),\n              //树的叶子节点补充指标\n              children:\n                // i + 1 === list.length - 1 &&\n                (indicators?.length ?? 0) >= 1\n                  ? indicators?.map(indicator => {\n                      if (typeof indicator === 'string') {\n                        return {\n                          indicatorKey: indicator,\n                          value: indicator\n                        };\n                      }\n                      return {\n                        indicatorKey: indicator.indicatorKey,\n                        value: indicator.title\n                      };\n                    })\n                  : [],\n              role: 'sub-total'\n            };\n\n            curChild.push(totalChild);\n\n            curChild = totalChild.children ?? [];\n\n            // }\n          }\n          map.set(flatKey, item); // 存储路径对应的节点\n          if (node) {\n            //为了确保汇总小计放到最后 使用splice插入到倒数第二个位置。如果小计放前面 直接push就行\n            if (subTotalFlags[index - 1] && !showSubTotalsOnTop) {\n              node.children.splice(node.children.length - 1, 0, item);\n            } else {\n              node.children.push(item);\n            }\n          } else {\n            result.push(item);\n          }\n        }\n        node = item; // 更新当前节点\n      });\n    }\n    if (arr?.length) {\n      arr.forEach(item => addList(item));\n    } else if (indicators) {\n      result = indicators?.map((indicator: IIndicator | string): { indicatorKey: string; value: string } => {\n        if (typeof indicator === 'string') {\n          return { indicatorKey: indicator, value: indicator };\n        }\n        return { indicatorKey: indicator.indicatorKey, value: indicator.title ?? indicator.indicatorKey };\n      });\n    }\n    //最后将总计的节点加上\n    if (isGrandTotal && arr?.length) {\n      const node: { value: string; dimensionKey: string; children: any[]; levelSpan: number; role: string } = {\n        value: grandTotalLabel, // getId(item?.id, 1),\n        dimensionKey: rows[0],\n        levelSpan: subTotalFlags.length,\n        children:\n          indicators?.map(indicator => {\n            if (typeof indicator === 'string') {\n              return {\n                indicatorKey: indicator,\n                value: indicator\n              };\n            }\n            return {\n              indicatorKey: indicator.indicatorKey,\n              value: indicator.title\n            };\n          }) ?? [],\n        role: 'grand-total'\n      };\n      if (showGrandTotalsOnTop) {\n        result.unshift(node);\n      } else {\n        result.push(node);\n      }\n    }\n    return result;\n  }\n\n  private cacheDeminsionCollectedValues() {\n    for (const key in this.collectValuesBy) {\n      if (this.collectValuesBy[key].type === 'xField' || this.collectValuesBy[key].type === 'yField') {\n        if ((this.dataConfig as IPivotChartDataConfig).dimensionSortArray) {\n          this.cacheCollectedValues[key] = arraySortByAnotherArray(\n            this.collectedValues[key] as unknown as string[],\n            (this.dataConfig as IPivotChartDataConfig).dimensionSortArray!\n          ) as unknown as Record<string, CollectedValue>;\n        } else {\n          this.cacheCollectedValues[key] = this.collectedValues[key];\n        }\n      }\n    }\n  }\n\n  changeTreeNodeValue(\n    rowKey: string[] | string = [],\n    colKey: string[] | string = [],\n    indicator: string,\n    newValue: string | number\n  ) {\n    const indicatorIndex = this.indicatorKeys.indexOf(indicator);\n\n    let flatRowKey;\n    let flatColKey;\n    if (typeof rowKey === 'string') {\n      flatRowKey = rowKey;\n    } else {\n      flatRowKey = rowKey.join(this.stringJoinChar);\n    }\n\n    if (typeof colKey === 'string') {\n      flatColKey = colKey;\n    } else {\n      flatColKey = colKey.join(this.stringJoinChar);\n    }\n\n    if (this.changedTree[flatRowKey]?.[flatColKey]) {\n      this.changedTree[flatRowKey][flatColKey][indicatorIndex] = newValue;\n    } else if (this.changedTree[flatRowKey]) {\n      this.changedTree[flatRowKey][flatColKey] = [];\n      this.changedTree[flatRowKey][flatColKey][indicatorIndex] = newValue;\n    } else {\n      this.changedTree[flatRowKey] = {};\n      this.changedTree[flatRowKey][flatColKey] = [];\n      this.changedTree[flatRowKey][flatColKey][indicatorIndex] = newValue;\n    }\n    const cellAggregator = this.tree[flatRowKey]?.[flatColKey]?.[indicatorIndex];\n    if (cellAggregator?.records.length === 1) {\n      cellAggregator.records[0][this.indicatorKeys[indicatorIndex]] = newValue;\n    }\n  }\n\n  changeRecordFieldValue(fieldName: string, oldValue: string | number, value: string | number) {\n    let isIndicatorName = false;\n\n    for (let i = 0; i < this.indicatorKeys.length; i++) {\n      if (this.indicatorKeys[i] === fieldName) {\n        isIndicatorName = true;\n      }\n    }\n\n    if (!isIndicatorName) {\n      //常规records是数组的情况\n      if (Array.isArray(this.records)) {\n        for (let i = 0, len = this.records.length; i < len; i++) {\n          const record = this.records[i];\n          if (record[fieldName] === oldValue) {\n            record[fieldName] = value;\n          }\n        }\n      } else {\n        //records是用户传来的按指标分组后的数据\n        for (const key in this.records) {\n          for (let i = 0, len = this.records[key].length; i < len; i++) {\n            const record = this.records[key][i];\n            if (record[fieldName] === oldValue) {\n              record[fieldName] = value;\n            }\n          }\n        }\n      }\n\n      this.rowFlatKeys = {};\n      this.colFlatKeys = {};\n      this.tree = {};\n      this.processRecords();\n    }\n  }\n  /** 主要是树形结构懒加载使用 */\n  _rowTreeHasChanged() {\n    if (!this.hasExtensionRowTree) {\n      this.customRowTreeDimensionPaths = this.customTreeToDimensionPathArr(this.customRowTree, 'row');\n    }\n  }\n  changeDataConfig(dataConfig: {\n    rows: string[]; //行维度字段数组；\n    columns: string[]; //列维度字段数组；\n  }) {\n    this.rows = dataConfig.rows;\n    this.columns = dataConfig.columns;\n  }\n  addRecords(records: any[]) {\n    for (let i = 0, len = records.length; i < len; i++) {\n      const record = records[i];\n      this.processRecord(record);\n    }\n    if (Array.isArray(this.records)) {\n      this.records.push(records);\n    }\n  }\n\n  //将树形结构转为二维数组\n  private customTreeToDimensionPathArr(tree: IHeaderTreeDefine[], type: 'col' | 'row') {\n    const result: {\n      dimensionKey?: string | number;\n      value: string;\n      indicatorKey?: string | number;\n      isVirtual?: boolean;\n    }[][] = []; // 结果\n    const that = this;\n    function getPath(\n      node: IHeaderTreeDefine,\n      arr: {\n        dimensionKey?: string | number;\n        value: string;\n        indicatorKey?: string | number;\n        virtual?: boolean;\n        childKeys?: (string | number)[];\n      }[]\n    ) {\n      if (!node.virtual) {\n        if (\n          arr[arr.length - 1]?.childKeys &&\n          node.dimensionKey &&\n          arr[arr.length - 1].childKeys.indexOf(node.dimensionKey) === -1 &&\n          node.dimensionKey !== arr[arr.length - 1].dimensionKey\n        ) {\n          arr[arr.length - 1].childKeys.push(node.dimensionKey);\n        }\n        arr.push({\n          dimensionKey: isValid(node.indicatorKey) ? undefined : node.dimensionKey,\n          value: node.value,\n          indicatorKey: node.indicatorKey,\n          virtual: node.virtual\n        });\n      }\n      if ((node.children as [])?.length > 0) {\n        if (that.rowHierarchyType === 'tree' && type === 'row') {\n          arr[arr.length - 1].childKeys = [];\n          result.push([...arr]);\n        }\n        // 存在多个节点就递归\n        (node.children as [])?.forEach((childItem: IHeaderTreeDefine) => getPath(childItem, [...arr]));\n      } else {\n        result.push(arr);\n      }\n    }\n    tree?.forEach((treeNode: IHeaderTreeDefine) => getPath(treeNode, []));\n    return result;\n  }\n\n  private getFieldMatchColDimensionPaths(record: any) {\n    const fieldMatchDimensionPaths = [];\n    for (let i = 0; i < (this.customColTreeDimensionPaths?.length ?? 0); i++) {\n      const dimensionPath: {\n        dimensionKey?: string | number;\n        value: string;\n        indicatorKey?: string | number;\n        isVirtual?: boolean;\n      }[] = this.customColTreeDimensionPaths[i];\n      let isMatch = true;\n      for (let j = 0; j < dimensionPath.length; j++) {\n        const dimension = dimensionPath[j];\n        if (\n          (dimension.dimensionKey && record[dimension.dimensionKey] !== dimension.value) ||\n          (dimension.indicatorKey && record[dimension.indicatorKey] === undefined)\n        ) {\n          isMatch = false;\n          break;\n        }\n      }\n      if (isMatch) {\n        fieldMatchDimensionPaths.push(dimensionPath);\n      }\n    }\n    return fieldMatchDimensionPaths;\n  }\n\n  private getFieldMatchRowDimensionPaths(record: any) {\n    const fieldMatchDimensionPaths = [];\n    for (let i = 0; i < (this.customRowTreeDimensionPaths?.length ?? 0); i++) {\n      const dimensionPath: {\n        dimensionKey?: string | number;\n        value: string;\n        indicatorKey?: string | number;\n        isVirtual?: boolean;\n        childKeys?: (string | number)[];\n      }[] = this.customRowTreeDimensionPaths[i];\n      let isMatch = true;\n      for (let j = 0; j < dimensionPath.length; j++) {\n        const dimension = dimensionPath[j];\n        if (\n          (dimension.dimensionKey && record[dimension.dimensionKey] !== dimension.value) ||\n          (dimension.indicatorKey && record[dimension.indicatorKey] === undefined)\n        ) {\n          isMatch = false;\n          break;\n        }\n        if (dimension.childKeys && j === dimensionPath.length - 1) {\n          if (dimension.childKeys.length > 0 && dimension.childKeys.find(key => isValid(record[key]))) {\n            isMatch = false;\n            break;\n          }\n        }\n      }\n      //上面条件符合 在进一步判断 如果有是指标在行的情况 且展示为树形结构，除了有指标的节点外 其他节点都不需要统计指标值\n      if (isMatch) {\n        if (!this.indicatorsAsCol && this.rowHierarchyType === 'tree') {\n          if (\n            !dimensionPath.find(path => {\n              return path.indicatorKey;\n            })\n          ) {\n            isMatch = false;\n          }\n        }\n      }\n      if (isMatch) {\n        fieldMatchDimensionPaths.push(dimensionPath);\n      }\n    }\n    return fieldMatchDimensionPaths;\n  }\n}\n\nfunction arraySortByAnotherArray(array: string[], sortArray: string[]) {\n  return array.sort((a, b) => {\n    const aIndex = sortArray.indexOf(a);\n    const bIndex = sortArray.indexOf(b);\n    if (aIndex < bIndex) {\n      return -1;\n    }\n    if (aIndex > bIndex) {\n      return 1;\n    }\n    return 0;\n  });\n}\n"]}