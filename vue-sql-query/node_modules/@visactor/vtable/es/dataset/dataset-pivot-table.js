import { AggregationType, SortType } from "../ts-types";

import { AvgAggregator, CountAggregator, MaxAggregator, MinAggregator, SumAggregator, naturalSort, sortBy, typeSort } from "../ts-types/dataset/aggregation";

export class DatasetForPivotTable {
    constructor(dataConfig, rows, columns, indicators, records, customColTree, customRowTree) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2;
        this.tree = {}, this.colFlatKeys = {}, this.rowFlatKeys = {}, this.colKeys = [], 
        this.rowKeys = [], this.rowOrder = "key_a_to_z", this.colOrder = "key_a_to_z", this.sorted = !1, 
        this.indicatorStatistics = [], this.aggregators = {}, this.stringJoinChar = String.fromCharCode(0), 
        this.rowsIsTotal = [], this.colsIsTotal = [], this.registerAggregators(), this.dataConfig = dataConfig, 
        this.sortRules = null === (_a = this.dataConfig) || void 0 === _a ? void 0 : _a.sortRules, 
        this.aggregationRules = null === (_b = this.dataConfig) || void 0 === _b ? void 0 : _b.aggregationRules, 
        this.derivedFieldRules = null === (_c = this.dataConfig) || void 0 === _c ? void 0 : _c.derivedFieldRules, 
        this.mappingRules = null === (_d = this.dataConfig) || void 0 === _d ? void 0 : _d.mappingRules, 
        this.totals = null === (_e = this.dataConfig) || void 0 === _e ? void 0 : _e.totals, 
        this.rows = rows, this.columns = columns, this.indicatorKeys = indicators, this.colGrandTotalLabel = null !== (_h = null === (_g = null === (_f = this.totals) || void 0 === _f ? void 0 : _f.column) || void 0 === _g ? void 0 : _g.grandTotalLabel) && void 0 !== _h ? _h : "总计", 
        this.colSubTotalLabel = null !== (_l = null === (_k = null === (_j = this.totals) || void 0 === _j ? void 0 : _j.column) || void 0 === _k ? void 0 : _k.subTotalLabel) && void 0 !== _l ? _l : "小计", 
        this.rowGrandTotalLabel = null !== (_p = null === (_o = null === (_m = this.totals) || void 0 === _m ? void 0 : _m.row) || void 0 === _o ? void 0 : _o.grandTotalLabel) && void 0 !== _p ? _p : "总计", 
        this.rowSubTotalLabel = null !== (_s = null === (_r = null === (_q = this.totals) || void 0 === _q ? void 0 : _q.row) || void 0 === _r ? void 0 : _r.subTotalLabel) && void 0 !== _s ? _s : "小计", 
        this.rowsIsTotal = new Array(this.rows.length).fill(!1), this.colsIsTotal = new Array(this.columns.length).fill(!1);
        for (let i = 0, len = null === (_v = null === (_u = null === (_t = this.totals) || void 0 === _t ? void 0 : _t.row) || void 0 === _u ? void 0 : _u.subTotalsDimensions) || void 0 === _v ? void 0 : _v.length; i < len; i++) {
            const dimension = this.totals.row.subTotalsDimensions[i], dimensionIndex = this.rows.indexOf(dimension);
            this.rowsIsTotal[dimensionIndex] = !0;
        }
        for (let i = 0, len = null === (_y = null === (_x = null === (_w = this.totals) || void 0 === _w ? void 0 : _w.column) || void 0 === _x ? void 0 : _x.subTotalsDimensions) || void 0 === _y ? void 0 : _y.length; i < len; i++) {
            const dimension = this.totals.column.subTotalsDimensions[i], dimensionIndex = this.columns.indexOf(dimension);
            this.colsIsTotal[dimensionIndex] = !0;
        }
        if (records) {
            this.records = records;
            "undefined" != typeof window && window.performance.now();
            this.setRecords(records);
            "undefined" != typeof window && window.performance.now(), "undefined" != typeof window && window.performance.now();
            this.totalStatistics();
            "undefined" != typeof window && window.performance.now(), "undefined" != typeof window && window.performance.now();
            this.sortKeys();
            "undefined" != typeof window && window.performance.now(), "undefined" != typeof window && window.performance.now();
            this.rowKeysPath = customRowTree ? this.TreeToArr2(customRowTree) : this.TreeToArr(this.ArrToTree(this.rowKeys, this.rowsIsTotal, (null === (_0 = null === (_z = null == this ? void 0 : this.totals) || void 0 === _z ? void 0 : _z.row) || void 0 === _0 ? void 0 : _0.showGrandTotals) || 0 === this.columns.length, this.rowGrandTotalLabel, this.rowSubTotalLabel)), 
            this.colKeysPath = customColTree ? this.TreeToArr2(customColTree) : this.TreeToArr(this.ArrToTree(this.colKeys, this.colsIsTotal, (null === (_2 = null === (_1 = this.totals) || void 0 === _1 ? void 0 : _1.column) || void 0 === _2 ? void 0 : _2.showGrandTotals) || 0 === this.rows.length, this.colGrandTotalLabel, this.colSubTotalLabel));
            "undefined" != typeof window && window.performance.now();
        }
        delete this.rowFlatKeys, delete this.colFlatKeys;
    }
    registerAggregator(type, aggregator) {
        this.aggregators[type] = aggregator;
    }
    registerAggregators() {
        this.registerAggregator(AggregationType.SUM, SumAggregator), this.registerAggregator(AggregationType.COUNT, CountAggregator), 
        this.registerAggregator(AggregationType.MAX, MaxAggregator), this.registerAggregator(AggregationType.MIN, MinAggregator), 
        this.registerAggregator(AggregationType.AVG, AvgAggregator);
    }
    setRecords(records) {
        this.processRecords();
    }
    processRecords() {
        for (let i = 0, len = this.records.length; i < len; i++) {
            const record = this.records[i];
            this.filterRecord(record) && this.processRecord(record);
        }
    }
    filterRecord(record) {
        var _a, _b, _c, _d;
        let isReserved = !0;
        for (let i = 0; i < (null === (_b = null === (_a = this.dataConfig) || void 0 === _a ? void 0 : _a.filterRules) || void 0 === _b ? void 0 : _b.length); i++) {
            const filterRule = null === (_c = this.dataConfig) || void 0 === _c ? void 0 : _c.filterRules[i];
            if (!(null === (_d = filterRule.filterFunc) || void 0 === _d ? void 0 : _d.call(filterRule, record))) {
                isReserved = !1;
                break;
            }
        }
        return isReserved;
    }
    processRecord(record) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
        null === (_a = this.derivedFieldRules) || void 0 === _a || _a.forEach(((derivedFieldRule, i) => {
            record[derivedFieldRule.fieldName] = derivedFieldRule.derivedFunc(record);
        }));
        const colKey = [], rowKey = [];
        for (let l = 0, len1 = this.rows.length; l < len1; l++) {
            const rowAttr = this.rows[l];
            rowKey.push(record[rowAttr]);
        }
        for (let n = 0, len2 = this.columns.length; n < len2; n++) {
            const colAttr = this.columns[n];
            colKey.push(record[colAttr]);
        }
        const flatRowKey = rowKey.join(this.stringJoinChar), flatColKey = colKey.join(this.stringJoinChar);
        if (0 !== rowKey.length && (this.rowFlatKeys[flatRowKey] || (this.rowKeys.push(rowKey), 
        this.rowFlatKeys[flatRowKey] = 1)), 0 !== colKey.length && (this.colFlatKeys[flatColKey] || (this.colKeys.push(colKey), 
        this.colFlatKeys[flatColKey] = 1)), 0 !== colKey.length || 0 !== rowKey.length) {
            this.tree[flatRowKey] || (this.tree[flatRowKey] = {}), (null === (_b = this.tree[flatRowKey]) || void 0 === _b ? void 0 : _b[flatColKey]) || (this.tree[flatRowKey][flatColKey] = []);
            for (let i = 0; i < this.indicatorKeys.length; i++) {
                if (!(null === (_d = null === (_c = this.tree[flatRowKey]) || void 0 === _c ? void 0 : _c[flatColKey]) || void 0 === _d ? void 0 : _d[i])) {
                    const aggRule = this.getAggregatorRule(this.indicatorKeys[i]);
                    this.tree[flatRowKey][flatColKey][i] = new this.aggregators[null !== (_e = null == aggRule ? void 0 : aggRule.aggregationType) && void 0 !== _e ? _e : AggregationType.SUM](null !== (_f = null == aggRule ? void 0 : aggRule.field) && void 0 !== _f ? _f : this.indicatorKeys[i], null == aggRule ? void 0 : aggRule.formatFun);
                }
                null === (_h = null === (_g = this.tree[flatRowKey]) || void 0 === _g ? void 0 : _g[flatColKey]) || void 0 === _h || _h[i].push(record);
            }
        }
        if (this.mappingRules) for (let i = 0; i < this.indicatorKeys.length; i++) {
            if (!this.indicatorStatistics[i]) {
                const aggRule = this.getAggregatorRule(this.indicatorKeys[i]);
                this.indicatorStatistics[i] = {
                    max: new this.aggregators[AggregationType.MAX](this.indicatorKeys[i]),
                    min: new this.aggregators[AggregationType.MIN](this.indicatorKeys[i]),
                    total: new this.aggregators[null !== (_j = null == aggRule ? void 0 : aggRule.aggregationType) && void 0 !== _j ? _j : AggregationType.SUM](null !== (_k = null == aggRule ? void 0 : aggRule.field) && void 0 !== _k ? _k : this.indicatorKeys[i], null == aggRule ? void 0 : aggRule.formatFun)
                };
            }
            this.indicatorStatistics[i].max.push(null === (_m = null === (_l = this.tree[flatRowKey]) || void 0 === _l ? void 0 : _l[flatColKey]) || void 0 === _m ? void 0 : _m[i].value()), 
            this.indicatorStatistics[i].min.push(null === (_p = null === (_o = this.tree[flatRowKey]) || void 0 === _o ? void 0 : _o[flatColKey]) || void 0 === _p ? void 0 : _p[i].value()), 
            this.indicatorStatistics[i].total.push(record);
        }
    }
    updateSortRules(sortRules) {
        var _a, _b, _c, _d;
        this.sorted = !1, this.sortRules = sortRules, this.sortKeys(), this.rowKeysPath = this.TreeToArr(this.ArrToTree(this.rowKeys, this.rowsIsTotal, (null === (_b = null === (_a = null == this ? void 0 : this.totals) || void 0 === _a ? void 0 : _a.row) || void 0 === _b ? void 0 : _b.showGrandTotals) || 0 === this.columns.length, this.rowGrandTotalLabel, this.rowSubTotalLabel)), 
        this.colKeysPath = this.TreeToArr(this.ArrToTree(this.colKeys, this.colsIsTotal, (null === (_d = null === (_c = this.totals) || void 0 === _c ? void 0 : _c.column) || void 0 === _d ? void 0 : _d.showGrandTotals) || 0 === this.rows.length, this.colGrandTotalLabel, this.colSubTotalLabel));
    }
    getAggregatorRule(indicatorKey) {
        var _a;
        return null === (_a = this.aggregationRules) || void 0 === _a ? void 0 : _a.find(((value, index) => indicatorKey === value.indicatorKey));
    }
    getAggregator(rowKey = [], colKey = [], indicator) {
        var _a, _b;
        const indicatorIndex = this.indicatorKeys.indexOf(indicator);
        let agg, flatRowKey, flatColKey;
        return flatRowKey = "string" == typeof rowKey ? rowKey : rowKey.join(this.stringJoinChar), 
        flatColKey = "string" == typeof colKey ? colKey : colKey.join(this.stringJoinChar), 
        0 === rowKey.length && 0 === colKey.length || (agg = null === (_b = null === (_a = this.tree[flatRowKey]) || void 0 === _a ? void 0 : _a[flatColKey]) || void 0 === _b ? void 0 : _b[indicatorIndex]), 
        agg || {
            records: [],
            key: "",
            push() {},
            deleteRecord() {},
            updateRecord() {},
            recalculate() {},
            value: () => null,
            formatValue: () => "",
            reset() {},
            clearCacheValue() {}
        };
    }
    sortKeys() {
        if (!this.sorted) {
            this.sorted = !0, this.rowKeys.sort(this.arrSort(this.rows, !0));
            const sortfun = this.arrSort(this.columns, !1);
            this.colKeys.sort(sortfun);
        }
    }
    arrSort(fieldArr, isRow) {
        let field;
        const that = this, sortersArr = function(_this) {
            const results = [];
            for (let l = 0, len1 = fieldArr.length; l < len1; l++) {
                field = fieldArr[l];
                let isHasSortRule = !1;
                if (that.sortRules) for (let m = 0, len2 = that.sortRules.length; m < len2; m++) that.sortRules[m].sortField === field && (isHasSortRule = !0, 
                results.push({
                    field: field,
                    fieldIndex: l,
                    sortRule: that.sortRules[m],
                    func: that.getSort(that.sortRules[m], isRow)
                }));
                isHasSortRule || results.push({
                    field: field,
                    fieldIndex: l,
                    func: naturalSort
                });
            }
            return results;
        }.call(this);
        return function(a, b) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
            let comparison, sorter;
            for (let i = 0; i < sortersArr.length; i++) {
                if (sorter = sortersArr[i], null === (_a = sorter.sortRule) || void 0 === _a ? void 0 : _a.sortByIndicator) {
                    let aChanged = a, bChanged = b;
                    sorter.fieldIndex < fieldArr.length - 1 && (aChanged = a.slice(0, sorter.fieldIndex + 1), 
                    aChanged.push(isRow ? null === (_c = null === (_b = that.totals) || void 0 === _b ? void 0 : _b.row) || void 0 === _c ? void 0 : _c.subTotalLabel : null === (_e = null === (_d = that.totals) || void 0 === _d ? void 0 : _d.column) || void 0 === _e ? void 0 : _e.subTotalLabel), 
                    bChanged = b.slice(0, sorter.fieldIndex + 1), bChanged.push(isRow ? null === (_g = null === (_f = that.totals) || void 0 === _f ? void 0 : _f.row) || void 0 === _g ? void 0 : _g.subTotalLabel : null === (_j = null === (_h = that.totals) || void 0 === _h ? void 0 : _h.column) || void 0 === _j ? void 0 : _j.subTotalLabel)), 
                    comparison = sorter.func(aChanged, bChanged, null === (_k = sorter.sortRule) || void 0 === _k ? void 0 : _k.sortType);
                } else comparison = sorter.func(a[sorter.fieldIndex], b[sorter.fieldIndex], null === (_l = sorter.sortRule) || void 0 === _l ? void 0 : _l.sortType);
                if (0 !== comparison) return comparison * ((null === (_m = sorter.sortRule) || void 0 === _m ? void 0 : _m.sortType) === SortType.DESC ? -1 : 1);
            }
            return 0;
        };
    }
    getSort(sortRule, isSortRow) {
        const that = this;
        return sortRule.sortByIndicator ? (a, b, sortType) => {
            const getValue = function(rowKey, colKey) {
                return rowKey.length < that.rows.length && rowKey[rowKey.length - 1] !== that.rowSubTotalLabel && rowKey[rowKey.length - 1] !== that.rowGrandTotalLabel && rowKey.push(that.rowSubTotalLabel), 
                colKey.length < that.columns.length && colKey[colKey.length - 1] !== that.colSubTotalLabel && colKey[colKey.length - 1] !== that.colGrandTotalLabel && colKey.push(that.colSubTotalLabel), 
                that.getAggregator(rowKey, colKey, sortRule.sortByIndicator).value();
            };
            return isSortRow ? naturalSort(getValue(a, sortRule.query), getValue(b, sortRule.query), sortType) : naturalSort(getValue(sortRule.query, a), getValue(sortRule.query, b), sortType);
        } : sortRule.sortBy ? sortBy(sortRule.sortBy) : sortRule.sortType ? typeSort : sortRule.sortFunc ? sortRule.sortFunc : naturalSort;
    }
    totalStatistics() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
        const that = this;
        if ((null === (_b = null === (_a = null == that ? void 0 : that.totals) || void 0 === _a ? void 0 : _a.column) || void 0 === _b ? void 0 : _b.showSubTotals) && (null === (_e = null === (_d = null === (_c = null == that ? void 0 : that.totals) || void 0 === _c ? void 0 : _c.column) || void 0 === _d ? void 0 : _d.subTotalsDimensions) || void 0 === _e ? void 0 : _e.length) >= 1 || (null === (_g = null === (_f = null == that ? void 0 : that.totals) || void 0 === _f ? void 0 : _f.row) || void 0 === _g ? void 0 : _g.showSubTotals) && (null === (_k = null === (_j = null === (_h = null == that ? void 0 : that.totals) || void 0 === _h ? void 0 : _h.row) || void 0 === _j ? void 0 : _j.subTotalsDimensions) || void 0 === _k ? void 0 : _k.length) >= 1 || (null === (_m = null === (_l = null == that ? void 0 : that.totals) || void 0 === _l ? void 0 : _l.column) || void 0 === _m ? void 0 : _m.showGrandTotals) || (null === (_p = null === (_o = null == that ? void 0 : that.totals) || void 0 === _o ? void 0 : _o.row) || void 0 === _p ? void 0 : _p.showGrandTotals) || 0 === that.rows.length || 0 === that.columns.length) {
            const rowTotalKeys = [], colCompute = (flatRowKey, flatColKey) => {
                var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
                const colKey = flatColKey.split(this.stringJoinChar);
                for (let i = 0, len = null === (_c = null === (_b = null === (_a = that.totals) || void 0 === _a ? void 0 : _a.column) || void 0 === _b ? void 0 : _b.subTotalsDimensions) || void 0 === _c ? void 0 : _c.length; i < len; i++) {
                    const dimension = that.totals.column.subTotalsDimensions[i], dimensionIndex = that.columns.indexOf(dimension);
                    if (dimensionIndex >= 0) {
                        const colTotalKey = colKey.slice(0, dimensionIndex + 1);
                        colTotalKey.push(null !== (_f = null === (_e = null === (_d = that.totals) || void 0 === _d ? void 0 : _d.column) || void 0 === _e ? void 0 : _e.subTotalLabel) && void 0 !== _f ? _f : "小计");
                        const flatColTotalKey = colTotalKey.join(this.stringJoinChar);
                        this.tree[flatRowKey][flatColTotalKey] || (this.tree[flatRowKey][flatColTotalKey] = []);
                        for (let i = 0; i < this.indicatorKeys.length; i++) {
                            if (!this.tree[flatRowKey][flatColTotalKey][i]) {
                                const aggRule = this.getAggregatorRule(this.indicatorKeys[i]);
                                this.tree[flatRowKey][flatColTotalKey][i] = new this.aggregators[null !== (_g = null == aggRule ? void 0 : aggRule.aggregationType) && void 0 !== _g ? _g : AggregationType.SUM](null !== (_h = null == aggRule ? void 0 : aggRule.field) && void 0 !== _h ? _h : this.indicatorKeys[i], null == aggRule ? void 0 : aggRule.formatFun);
                            }
                            this.tree[flatRowKey][flatColTotalKey][i].push(null === (_k = null === (_j = that.tree[flatRowKey]) || void 0 === _j ? void 0 : _j[flatColKey]) || void 0 === _k ? void 0 : _k[i]);
                        }
                    }
                }
                if ((null === (_m = null === (_l = that.totals) || void 0 === _l ? void 0 : _l.column) || void 0 === _m ? void 0 : _m.showGrandTotals) || 0 === this.rows.length) {
                    const flatColTotalKey = that.colGrandTotalLabel;
                    this.tree[flatRowKey][flatColTotalKey] || (this.tree[flatRowKey][flatColTotalKey] = []);
                    for (let i = 0; i < this.indicatorKeys.length; i++) {
                        if (!this.tree[flatRowKey][flatColTotalKey][i]) {
                            const aggRule = this.getAggregatorRule(this.indicatorKeys[i]);
                            this.tree[flatRowKey][flatColTotalKey][i] = new this.aggregators[null !== (_o = null == aggRule ? void 0 : aggRule.aggregationType) && void 0 !== _o ? _o : AggregationType.SUM](null !== (_p = null == aggRule ? void 0 : aggRule.field) && void 0 !== _p ? _p : this.indicatorKeys[i], null == aggRule ? void 0 : aggRule.formatFun);
                        }
                        this.tree[flatRowKey][flatColTotalKey][i].push(null === (_r = null === (_q = that.tree[flatRowKey]) || void 0 === _q ? void 0 : _q[flatColKey]) || void 0 === _r ? void 0 : _r[i]);
                    }
                }
            };
            Object.keys(that.tree).forEach((flatRowKey => {
                const rowKey = flatRowKey.split(this.stringJoinChar);
                Object.keys(that.tree[flatRowKey]).forEach((flatColKey => {
                    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
                    for (let i = 0, len = null === (_c = null === (_b = null === (_a = that.totals) || void 0 === _a ? void 0 : _a.row) || void 0 === _b ? void 0 : _b.subTotalsDimensions) || void 0 === _c ? void 0 : _c.length; i < len; i++) {
                        const dimension = that.totals.row.subTotalsDimensions[i], dimensionIndex = that.rows.indexOf(dimension);
                        if (dimensionIndex >= 0) {
                            const rowTotalKey = rowKey.slice(0, dimensionIndex + 1);
                            rowTotalKey.push(null !== (_f = null === (_e = null === (_d = that.totals) || void 0 === _d ? void 0 : _d.row) || void 0 === _e ? void 0 : _e.subTotalLabel) && void 0 !== _f ? _f : "小计");
                            const flatRowTotalKey = rowTotalKey.join(this.stringJoinChar);
                            if (this.tree[flatRowTotalKey] || (this.tree[flatRowTotalKey] = {}, rowTotalKeys.push(flatRowTotalKey)), 
                            !this.tree[flatRowTotalKey][flatColKey]) {
                                this.tree[flatRowTotalKey][flatColKey] = [];
                                for (let i = 0; i < this.indicatorKeys.length; i++) {
                                    if (!this.tree[flatRowTotalKey][flatColKey][i]) {
                                        const aggRule = this.getAggregatorRule(this.indicatorKeys[i]);
                                        this.tree[flatRowTotalKey][flatColKey][i] = new this.aggregators[null !== (_g = null == aggRule ? void 0 : aggRule.aggregationType) && void 0 !== _g ? _g : AggregationType.SUM](null !== (_h = null == aggRule ? void 0 : aggRule.field) && void 0 !== _h ? _h : this.indicatorKeys[i], null == aggRule ? void 0 : aggRule.formatFun);
                                    }
                                    this.tree[flatRowTotalKey][flatColKey][i].push(null === (_k = null === (_j = that.tree[flatRowKey]) || void 0 === _j ? void 0 : _j[flatColKey]) || void 0 === _k ? void 0 : _k[i]);
                                }
                            }
                        }
                        if ((null === (_m = null === (_l = that.totals) || void 0 === _l ? void 0 : _l.row) || void 0 === _m ? void 0 : _m.showGrandTotals) || 0 === this.columns.length) {
                            const flatRowTotalKey = that.rowGrandTotalLabel;
                            this.tree[flatRowTotalKey] || (this.tree[flatRowTotalKey] = {}, rowTotalKeys.push(flatRowTotalKey)), 
                            this.tree[flatRowTotalKey][flatColKey] || (this.tree[flatRowTotalKey][flatColKey] = []);
                            for (let i = 0; i < this.indicatorKeys.length; i++) {
                                if (!this.tree[flatRowTotalKey][flatColKey][i]) {
                                    const aggRule = this.getAggregatorRule(this.indicatorKeys[i]);
                                    this.tree[flatRowTotalKey][flatColKey][i] = new this.aggregators[null !== (_o = null == aggRule ? void 0 : aggRule.aggregationType) && void 0 !== _o ? _o : AggregationType.SUM](null !== (_p = null == aggRule ? void 0 : aggRule.field) && void 0 !== _p ? _p : this.indicatorKeys[i], null == aggRule ? void 0 : aggRule.formatFun);
                                }
                                this.tree[flatRowTotalKey][flatColKey][i].push(null === (_r = null === (_q = that.tree[flatRowKey]) || void 0 === _q ? void 0 : _q[flatColKey]) || void 0 === _r ? void 0 : _r[i]);
                            }
                        }
                        colCompute(flatRowKey, flatColKey);
                    }
                }));
            })), rowTotalKeys.forEach((flatRowKey => {
                Object.keys(that.tree[flatRowKey]).forEach((flatColKey => {
                    colCompute(flatRowKey, flatColKey);
                }));
            }));
        }
    }
    ArrToTree(arr, subTotalFlags, isGrandTotal, grandTotalLabel, subTotalLabel) {
        const result = [], concatStr = this.stringJoinChar, map = new Map;
        if (arr.forEach((item => function(list) {
            const path = [];
            let node;
            list.forEach(((value, index) => {
                path.push(value);
                const flatKey = path.join(concatStr);
                let item = map.get(flatKey);
                if (!item) {
                    if (item = {
                        id: flatKey,
                        children: []
                    }, subTotalFlags[index]) {
                        let curChild = item.children;
                        for (let i = index; i < list.length - 1; i++) {
                            const totalChild = {
                                id: `${flatKey}${concatStr}${subTotalLabel}`,
                                children: []
                            };
                            curChild.push(totalChild), curChild = totalChild.children;
                        }
                    }
                    map.set(flatKey, item), node ? subTotalFlags[index - 1] ? node.children.splice(node.children.length - 1, 0, item) : node.children.push(item) : result.push(item);
                }
                node = item;
            }));
        }(item))), isGrandTotal) {
            const node = {
                id: grandTotalLabel,
                children: []
            };
            let curChild = node.children;
            for (let i = 1; i < subTotalFlags.length; i++) {
                const totalChild = {
                    id: grandTotalLabel,
                    children: []
                };
                curChild.push(totalChild), curChild = totalChild.children;
            }
            result.push(node);
        }
        return result;
    }
    TreeToArr(tree) {
        const result = [];
        function getPath(node, arr) {
            var _a;
            arr.push(node.id), node.children.length > 0 ? null === (_a = node.children) || void 0 === _a || _a.forEach((childItem => getPath(childItem, [ ...arr ]))) : result.push(arr);
        }
        return tree.forEach((treeNode => getPath(treeNode, []))), result;
    }
    TreeToArr2(tree) {
        const result = [];
        function getPath(node, arr) {
            var _a, _b;
            arr.push(arr.length > 0 ? [ arr[arr.length - 1], node.value ].join(String.fromCharCode(0)) : node.value), 
            (null === (_a = node.children) || void 0 === _a ? void 0 : _a.length) > 0 ? null === (_b = node.children) || void 0 === _b || _b.forEach((childItem => getPath(childItem, [ ...arr ]))) : result.push(arr);
        }
        return tree.forEach((treeNode => getPath(treeNode, []))), result;
    }
}