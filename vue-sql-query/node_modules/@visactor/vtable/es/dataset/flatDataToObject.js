import { isValid } from "@visactor/vutils";

export class FlatDataToObjects {
    constructor(dataConfig, records) {
        if (this.tree = {}, this.beforeChangedTree = {}, this.colFlatKeys = {}, this.rowFlatKeys = {}, 
        this.stringJoinChar = String.fromCharCode(0), this.rowsIsTotal = [], this.colsIsTotal = [], 
        this.dataConfig = dataConfig, records) {
            this.records = records;
            "undefined" != typeof window && window.performance.now();
            this.setRecords(records);
            "undefined" != typeof window && window.performance.now();
        }
    }
    changeDataConfig(dataConfig) {
        this.dataConfig = dataConfig;
    }
    setRecords(records) {
        this.processRecords();
    }
    processRecords() {
        for (let i = 0, len = this.records.length; i < len; i++) {
            const record = this.records[i];
            this.processRecord(record);
        }
    }
    processRecord(record) {
        var _a;
        const colKey = [], rowKey = [];
        for (let l = 0, len1 = this.dataConfig.rows.length; l < len1; l++) {
            const rowAttr = this.dataConfig.rows[l];
            void 0 !== record[rowAttr] && rowAttr !== this.dataConfig.indicatorDimensionKey && rowKey.push(record[rowAttr]);
        }
        for (let n = 0, len2 = this.dataConfig.columns.length; n < len2; n++) {
            const colAttr = this.dataConfig.columns[n];
            void 0 !== record[colAttr] && colAttr !== this.dataConfig.indicatorDimensionKey && colKey.push(record[colAttr]);
        }
        null === (_a = this.dataConfig.indicators) || void 0 === _a || _a.forEach((indicatorKey => {
            const recordValue = record[indicatorKey];
            void 0 !== recordValue && (this.dataConfig.indicatorsAsCol ? colKey.push(indicatorKey) : rowKey.push(indicatorKey));
            const flatRowKey = rowKey.join(this.stringJoinChar), flatColKey = colKey.join(this.stringJoinChar);
            0 !== rowKey.length && (this.rowFlatKeys[flatRowKey] || (this.rowFlatKeys[flatRowKey] = 1)), 
            0 !== colKey.length && (this.colFlatKeys[flatColKey] || (this.colFlatKeys[flatColKey] = 1)), 
            0 === colKey.length && 0 === rowKey.length || (this.tree[flatRowKey] || (this.tree[flatRowKey] = {}), 
            void 0 !== recordValue && (this.tree[flatRowKey][flatColKey] = {
                value: recordValue,
                record: record
            }, this.dataConfig.indicatorsAsCol ? colKey.pop() : rowKey.pop()));
        }));
    }
    getTreeNode(rowKey = [], colKey = [], indicator, ifChangedValue = !0) {
        var _a, _b, _c, _d;
        let flatRowKey, flatColKey;
        if ("string" == typeof rowKey) flatRowKey = rowKey; else {
            let isHasIndicator = !1;
            rowKey.map(((key, i) => {
                key === indicator && (rowKey.splice(i, 1), isHasIndicator = !0);
            })), isHasIndicator && rowKey.push(indicator), flatRowKey = rowKey.join(this.stringJoinChar);
        }
        if ("string" == typeof colKey) flatColKey = colKey; else {
            let isHasIndicator = !1;
            colKey.map(((key, i) => {
                key === indicator && (colKey.splice(i, 1), isHasIndicator = !0);
            })), isHasIndicator && colKey.push(indicator), flatColKey = colKey.join(this.stringJoinChar);
        }
        return ifChangedValue ? null !== (_c = null === (_b = null === (_a = this.tree) || void 0 === _a ? void 0 : _a[flatRowKey]) || void 0 === _b ? void 0 : _b[flatColKey]) && void 0 !== _c ? _c : void 0 : isValid(null === (_d = this.beforeChangedTree[flatRowKey]) || void 0 === _d ? void 0 : _d[flatColKey]) ? {
            value: this.beforeChangedTree[flatRowKey][flatColKey].value,
            record: this.beforeChangedTree[flatRowKey][flatColKey].record
        } : void 0;
    }
    changeTreeNodeValue(rowKey = [], colKey = [], indicator, newValue) {
        var _a, _b, _c, _d, _e, _f, _g;
        let flatRowKey, flatColKey;
        if ("string" == typeof rowKey) flatRowKey = rowKey; else {
            let isHasIndicator = !1;
            rowKey.map(((key, i) => {
                key === indicator && (rowKey.splice(i, 1), isHasIndicator = !0);
            })), isHasIndicator && rowKey.push(indicator), flatRowKey = rowKey.join(this.stringJoinChar);
        }
        if ("string" == typeof colKey) flatColKey = colKey; else {
            let isHasIndicator = !1;
            colKey.map(((key, i) => {
                key === indicator && (colKey.splice(i, 1), isHasIndicator = !0);
            })), isHasIndicator && colKey.push(indicator), flatColKey = colKey.join(this.stringJoinChar);
        }
        const oldValue = null === (_b = null === (_a = this.tree[flatRowKey]) || void 0 === _a ? void 0 : _a[flatColKey]) || void 0 === _b ? void 0 : _b.value, oldRecord = Object.assign({}, null === (_d = null === (_c = this.tree[flatRowKey]) || void 0 === _c ? void 0 : _c[flatColKey]) || void 0 === _d ? void 0 : _d.record);
        (null === (_f = null === (_e = this.tree[flatRowKey]) || void 0 === _e ? void 0 : _e[flatColKey]) || void 0 === _f ? void 0 : _f.record) ? (this.tree[flatRowKey][flatColKey].record[indicator] = newValue, 
        this.tree[flatRowKey][flatColKey].value = newValue) : (this.tree[flatRowKey] || (this.tree[flatRowKey] = {}), 
        this.tree[flatRowKey][flatColKey] = {
            record: this._buildRecord(rowKey, colKey, indicator, newValue),
            value: newValue
        }), (null === (_g = this.beforeChangedTree[flatRowKey]) || void 0 === _g ? void 0 : _g[flatColKey]) || (this.beforeChangedTree[flatRowKey] = {}, 
        this.beforeChangedTree[flatRowKey][flatColKey] = {
            record: void 0,
            value: void 0
        }, this.beforeChangedTree[flatRowKey][flatColKey].record = oldRecord, this.beforeChangedTree[flatRowKey][flatColKey].value = oldValue);
    }
    _buildRecord(rowKey = [], colKey = [], indicator, value) {
        const record = {}, rowDimensions = this.dataConfig.rows, colDimensions = this.dataConfig.columns;
        return rowDimensions.forEach(((dimension, index) => {
            dimension !== this.dataConfig.indicatorDimensionKey && (record[dimension] = rowKey[index]);
        })), colDimensions.forEach(((dimension, index) => {
            dimension !== this.dataConfig.indicatorDimensionKey && (record[dimension] = colKey[index]);
        })), record[indicator] = value, this.records.push(record), record;
    }
    addRecords(records) {
        for (let i = 0, len = records.length; i < len; i++) {
            const record = records[i];
            this.processRecord(record);
        }
        this.records.push(records);
    }
    changeRecordFieldValue(fieldName, oldValue, value) {
        let isIndicatorName = !1;
        for (let i = 0; i < this.dataConfig.indicators.length; i++) this.dataConfig.indicators[i] === fieldName && (isIndicatorName = !0);
        if (!isIndicatorName) {
            for (let i = 0, len = this.records.length; i < len; i++) {
                const record = this.records[i];
                record[fieldName] === oldValue && (record[fieldName] = value);
            }
            this.rowFlatKeys = {}, this.colFlatKeys = {}, this.tree = {}, this.processRecords();
        }
    }
}
//# sourceMappingURL=flatDataToObject.js.map