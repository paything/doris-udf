import { getProp } from "../../scenegraph/utils/get-prop";

import { HighlightScope } from "../../ts-types";

import { isValid } from "@visactor/vutils";

import { getCellMergeRange } from "../../tools/merge-range";

import { cellInRange } from "../../tools/helper";

export function getCellSelectColor(cellGroup, table) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
    let colorKey, selectStyle;
    if ("cell" === cellGroup.role && isValid(cellGroup.mergeStartCol) && isValid(cellGroup.mergeStartRow) && isValid(cellGroup.mergeEndCol) && isValid(cellGroup.mergeEndRow)) {
        const {colStart: colStart, colEnd: colEnd, rowStart: rowStart, rowEnd: rowEnd} = getCellMergeRange(cellGroup, table.scenegraph);
        for (let col = colStart; col <= colEnd; col++) for (let row = rowStart; row <= rowEnd; row++) {
            const key = isCellSelected(table.stateManager, col, row, cellGroup);
            !key || colorKey && "cellBgColor" !== key || (colorKey = key);
        }
    } else "cell" === cellGroup.role && (colorKey = isCellSelected(table.stateManager, cellGroup.col, cellGroup.row, cellGroup));
    if (!colorKey) return;
    const layout = table.internalProps.layoutMap;
    layout.isCornerHeader(cellGroup.col, cellGroup.row) ? selectStyle = (null === (_a = table.theme.cornerHeaderStyle) || void 0 === _a ? void 0 : _a.select) || (null === (_b = table.theme.headerStyle) || void 0 === _b ? void 0 : _b.select) : layout.isColumnHeader(cellGroup.col, cellGroup.row) ? selectStyle = null === (_c = table.theme.headerStyle) || void 0 === _c ? void 0 : _c.select : layout.isRowHeader(cellGroup.col, cellGroup.row) ? selectStyle = null === (_d = table.theme.rowHeaderStyle) || void 0 === _d ? void 0 : _d.select : layout.isBottomFrozenRow(cellGroup.col, cellGroup.row) ? selectStyle = (null === (_e = table.theme.bottomFrozenStyle) || void 0 === _e ? void 0 : _e.select) || (table.isListTable() ? null === (_f = table.theme.bodyStyle) || void 0 === _f ? void 0 : _f.select : null === (_g = table.theme.headerStyle) || void 0 === _g ? void 0 : _g.select) : layout.isRightFrozenColumn(cellGroup.col, cellGroup.row) ? selectStyle = (null === (_h = table.theme.rightFrozenStyle) || void 0 === _h ? void 0 : _h.select) || (table.isListTable() ? null === (_j = table.theme.bodyStyle) || void 0 === _j ? void 0 : _j.select : null === (_k = table.theme.rowHeaderStyle) || void 0 === _k ? void 0 : _k.select) : table.isHeader(cellGroup.col, cellGroup.row) || (selectStyle = null === (_l = table.theme.bodyStyle) || void 0 === _l ? void 0 : _l.select);
    return getProp(colorKey, selectStyle, cellGroup.col, cellGroup.row, table);
}

function isSelectMultipleRange(range) {
    return range.start.col !== range.end.col || range.start.row !== range.end.row;
}

function getSelectModeRange(state, col, row) {
    let selectMode;
    const {highlightScope: highlightScope, cellPos: cellPos, ranges: ranges} = state.select, range = ranges[0], rangeColStart = Math.min(range.start.col, range.end.col), rangeColEnd = Math.max(range.start.col, range.end.col), rangeRowStart = Math.min(range.start.row, range.end.row), rangeRowEnd = Math.max(range.start.row, range.end.row);
    return highlightScope === HighlightScope.single && cellPos.col === col && cellPos.row === row ? selectMode = "cellBgColor" : highlightScope === HighlightScope.column && col >= rangeColStart && col <= rangeColEnd ? selectMode = cellInRange(ranges[0], col, row) ? "cellBgColor" : "inlineColumnBgColor" : highlightScope === HighlightScope.row && row >= rangeRowStart && row <= rangeRowEnd ? selectMode = cellInRange(ranges[0], col, row) ? "cellBgColor" : "inlineRowBgColor" : highlightScope === HighlightScope.cross && (cellInRange(ranges[0], col, row) ? selectMode = "cellBgColor" : col >= rangeColStart && col <= rangeColEnd ? selectMode = "inlineColumnBgColor" : row >= rangeRowStart && row <= rangeRowEnd && (selectMode = "inlineRowBgColor")), 
    selectMode;
}

function getSelectMode(state, col, row) {
    let selectMode;
    const {highlightScope: highlightScope, cellPos: cellPos} = state.select;
    return highlightScope === HighlightScope.single && cellPos.col === col && cellPos.row === row ? selectMode = "cellBgColor" : highlightScope === HighlightScope.column && cellPos.col === col ? selectMode = cellPos.col === col && cellPos.row === row ? "cellBgColor" : "inlineColumnBgColor" : highlightScope === HighlightScope.row && cellPos.row === row ? selectMode = cellPos.col === col && cellPos.row === row ? "cellBgColor" : "inlineRowBgColor" : highlightScope === HighlightScope.cross && (cellPos.col === col && cellPos.row === row ? selectMode = "cellBgColor" : cellPos.col === col ? selectMode = "inlineColumnBgColor" : cellPos.row === row && (selectMode = "inlineRowBgColor")), 
    selectMode;
}

export function isCellSelected(state, col, row, cellGroup) {
    const {highlightInRange: highlightInRange, disableHeader: disableHeader, ranges: ranges} = state.select;
    let selectMode;
    const isSelectRange = 1 === ranges.length && isSelectMultipleRange(null == ranges ? void 0 : ranges[0]) && highlightInRange;
    if (isSelectRange ? 1 === (null == ranges ? void 0 : ranges.length) && ranges[0].start && ranges[0].end : 1 === (null == ranges ? void 0 : ranges.length) && ranges[0].end.col === ranges[0].start.col && ranges[0].end.row === ranges[0].start.row) {
        if (state.table.isHeader(col, row) && disableHeader) return;
        if (selectMode = isSelectRange ? getSelectModeRange(state, col, row) : getSelectMode(state, col, row), 
        selectMode) {
            isCellDisableSelect(state.table, col, row) && (selectMode = void 0);
        }
    } else if ("replace" === state.table.theme.selectionStyle.selectionFillMode) for (let i = 0; i < ranges.length; i++) {
        const range = ranges[i], rangeColStart = Math.min(range.start.col, range.end.col), rangeColEnd = Math.max(range.start.col, range.end.col), rangeRowStart = Math.min(range.start.row, range.end.row), rangeRowEnd = Math.max(range.start.row, range.end.row);
        if (rangeColStart <= col && rangeRowStart <= row && rangeColEnd >= col && rangeRowEnd >= row) {
            selectMode = "cellBgColor";
            break;
        }
    }
    return selectMode;
}

export function isCellDisableSelect(table, col, row) {
    var _a, _b;
    const globalDisableSelect = null === (_a = table.options.select) || void 0 === _a ? void 0 : _a.disableSelect;
    if ("function" == typeof globalDisableSelect ? globalDisableSelect(col, row, table) : globalDisableSelect) return !0;
    if (table.isHeader(col, row)) {
        let cellDisable = null === (_b = table.options.select) || void 0 === _b ? void 0 : _b.disableHeaderSelect;
        if (cellDisable) return !0;
        const columnDefine = table.getHeaderDefine(col, row);
        if (cellDisable = null == columnDefine ? void 0 : columnDefine.disableHeaderSelect, 
        cellDisable) return !0;
    } else {
        const columnDefine = table.getBodyColumnDefine(col, row), disableSelect = null == columnDefine ? void 0 : columnDefine.disableSelect;
        if ("function" == typeof disableSelect ? disableSelect(col, row, table) : disableSelect) return !0;
    }
    return !1;
}
//# sourceMappingURL=is-cell-select-highlight.js.map
