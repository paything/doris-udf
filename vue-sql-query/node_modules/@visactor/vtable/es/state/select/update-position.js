import { InteractionState } from "../../ts-types";

export function updateSelectPosition(state, col, row, isShift, isCtrl, isSelectAll, makeSelectCellVisible = !0, skipBodyMerge = !1) {
    var _a, _b;
    const {table: table, interactionState: interactionState} = state, {scenegraph: scenegraph} = table, {highlightScope: highlightScope, disableHeader: disableHeader, cellPos: cellPos, disableCtrlMultiSelect: disableCtrlMultiSelect} = state.select;
    if (-1 !== col && -1 !== row && makeSelectCellVisible && table._makeVisibleCell(col, row), 
    -1 !== col && -1 !== row && makeSelectCellVisible) if (interactionState === InteractionState.grabing && state.select.ranges.length > 0) {
        const currentRange = state.select.ranges[state.select.ranges.length - 1];
        col > currentRange.start.col && col > currentRange.end.col && table._makeVisibleCell(col + 1, row), 
        row > currentRange.start.row && row > currentRange.end.row && table._makeVisibleCell(col, row + 1), 
        col < currentRange.start.col && col < currentRange.end.col && table._makeVisibleCell(col - 1, row), 
        row < currentRange.start.row && row < currentRange.end.row && table._makeVisibleCell(col, row - 1);
    } else table._makeVisibleCell(col, row);
    if (isSelectAll) {
        state.select.ranges = [], scenegraph.deleteAllSelectBorder();
        let _startCol = 0, _startRow = 0;
        const {disableHeaderSelect: disableHeaderSelect, disableRowSeriesNumberSelect: disableRowSeriesNumberSelect} = (null === (_a = table.options.keyboardOptions) || void 0 === _a ? void 0 : _a.selectAllOnCtrlA) || {};
        disableHeaderSelect && (_startCol = table.rowHeaderLevelCount, _startRow = table.columnHeaderLevelCount), 
        (disableRowSeriesNumberSelect || disableHeaderSelect && table.transpose) && table.options.rowSeriesNumber && (_startCol += 1), 
        state.select.ranges.push({
            start: {
                col: _startCol,
                row: _startRow
            },
            end: {
                col: table.colCount - 1,
                row: table.rowCount - 1
            }
        });
        const currentRange = state.select.ranges[state.select.ranges.length - 1];
        scenegraph.updateCellSelectBorder(currentRange, !1);
    } else if (-1 === cellPos.col || -1 === cellPos.row || -1 !== col && -1 !== row) if (interactionState !== InteractionState.default || table.eventManager.isDraging || table.stateManager.isResizeCol()) {
        if ((interactionState === InteractionState.grabing || table.eventManager.isDraging) && !table.stateManager.isResizeCol()) {
            let extendSelectRange = !0;
            -1 === cellPos.col && (cellPos.col = col), -1 === cellPos.row && (cellPos.row = row), 
            cellPos.col = col, cellPos.row = row;
            const currentRange = state.select.ranges[state.select.ranges.length - 1];
            if (currentRange) {
                if (table.internalProps.layoutMap.isSeriesNumberInBody(currentRange.start.col, currentRange.start.row)) extendSelectRange = !1, 
                currentRange.end = {
                    col: table.colCount - 1,
                    row: row
                }; else if (state.fillHandle.isFilling) {
                    if ("top" === state.fillHandle.direction) if (row === state.fillHandle.beforeFillMinRow && row === state.fillHandle.beforeFillMaxRow) currentRange.start.row = currentRange.end.row = row; else if (row <= state.fillHandle.beforeFillMinRow) {
                        if (currentRange.start.row < currentRange.end.row) {
                            const temp = currentRange.start.row;
                            currentRange.start.row = currentRange.end.row, currentRange.end.row = temp;
                        }
                        currentRange.end.row = row;
                    } else row === state.fillHandle.beforeFillMaxRow && (currentRange.start.row > currentRange.end.row ? currentRange.start.row = row : currentRange.end.row = row); else if ("bottom" === state.fillHandle.direction) {
                        if (row >= state.fillHandle.beforeFillMaxRow) {
                            if (currentRange.start.row > currentRange.end.row) {
                                const temp = currentRange.start.row;
                                currentRange.start.row = currentRange.end.row, currentRange.end.row = temp;
                            }
                            currentRange.end.row = row;
                        }
                    } else if ("left" === state.fillHandle.direction) if (col === state.fillHandle.beforeFillMinCol && col === state.fillHandle.beforeFillMaxCol) currentRange.start.col = currentRange.end.col = col; else if (col <= state.fillHandle.beforeFillMinCol) {
                        if (currentRange.start.col < currentRange.end.col) {
                            const temp = currentRange.start.col;
                            currentRange.start.col = currentRange.end.col, currentRange.end.col = temp;
                        }
                        currentRange.end.col = col;
                    } else col === state.fillHandle.beforeFillMaxCol && (currentRange.start.col > currentRange.end.col ? currentRange.start.col = col : currentRange.end.col = col); else if ("right" === state.fillHandle.direction && col >= state.fillHandle.beforeFillMaxCol) {
                        if (currentRange.start.col > currentRange.end.col) {
                            const temp = currentRange.start.col;
                            currentRange.start.col = currentRange.end.col, currentRange.end.col = temp;
                        }
                        currentRange.end.col = col;
                    }
                } else {
                    currentRange.end = {
                        col: col,
                        row: row
                    };
                    const cellRange = skipBodyMerge ? {
                        start: {
                            col: col,
                            row: row
                        },
                        end: {
                            col: col,
                            row: row
                        }
                    } : table.getCellRange(col, row);
                    currentRange.start.col < cellRange.end.col ? currentRange.end.col = cellRange.end.col : currentRange.start.col > cellRange.start.col && (currentRange.end.col = cellRange.start.col), 
                    currentRange.start.row < cellRange.end.row ? currentRange.end.row = cellRange.end.row : currentRange.start.row > cellRange.start.row && (currentRange.end.row = cellRange.start.row), 
                    "body" === state.select.headerSelectMode && (table.isRowHeader(col, row) ? (currentRange.start.col = table.rowHeaderLevelCount + table.leftRowSeriesNumberCount, 
                    currentRange.end.col = table.colCount - 1) : table.isColumnHeader(col, row) ? (currentRange.start.row = table.columnHeaderLevelCount, 
                    currentRange.end.row = table.rowCount - 1) : table.internalProps.layoutMap.isSeriesNumberInBody(col, row) ? (currentRange.start.col = table.leftRowSeriesNumberCount, 
                    currentRange.end.col = table.colCount - 1) : table.isCornerHeader(col, row) ? (currentRange.start.col = table.rowHeaderLevelCount + table.leftRowSeriesNumberCount, 
                    currentRange.start.row = table.columnHeaderLevelCount, currentRange.end.col = table.colCount - 1, 
                    currentRange.end.row = table.rowCount - 1) : table.isSeriesNumber(col, row) && (currentRange.start.col = table.leftRowSeriesNumberCount, 
                    currentRange.start.row = table.columnHeaderLevelCount, currentRange.end.col = table.colCount - 1, 
                    currentRange.end.row = table.rowCount - 1)), skipBodyMerge && (currentRange.skipBodyMerge = !0);
                }
                currentRange && currentRange.start.row <= table.rowCount - 1 && currentRange.end.row <= table.rowCount - 1 && currentRange.start.col <= table.colCount - 1 && currentRange.end.col <= table.colCount - 1 && scenegraph.updateCellSelectBorder(currentRange, extendSelectRange);
            }
        }
    } else {
        const currentRange = state.select.ranges[state.select.ranges.length - 1];
        if (isShift && currentRange) {
            if (isCtrl && !disableCtrlMultiSelect || (cellPos.col = col, cellPos.row = row), 
            "cell" !== state.select.headerSelectMode && table.isColumnHeader(col, row)) {
                const startCol = Math.min(currentRange.start.col, currentRange.end.col, col), endCol = Math.max(currentRange.start.col, currentRange.end.col, col), startRow = Math.min(currentRange.start.row, currentRange.end.row, row), endRow = table.rowCount - 1;
                "body" === state.select.headerSelectMode ? (currentRange.start = {
                    col: startCol,
                    row: table.columnHeaderLevelCount
                }, currentRange.end = {
                    col: endCol,
                    row: table.rowCount - 1
                }) : (currentRange.start = {
                    col: startCol,
                    row: startRow
                }, currentRange.end = {
                    col: endCol,
                    row: endRow
                });
            } else if ("cell" !== state.select.headerSelectMode && table.isRowHeader(col, row)) {
                const startCol = Math.min(currentRange.start.col, currentRange.end.col, col), endCol = table.colCount - 1, startRow = Math.min(currentRange.start.row, currentRange.end.row, row), endRow = Math.max(currentRange.start.row, currentRange.end.row, row);
                "body" === state.select.headerSelectMode ? (currentRange.start = {
                    col: table.leftRowSeriesNumberCount + table.rowHeaderLevelCount,
                    row: startRow
                }, currentRange.end = {
                    col: table.colCount - 1,
                    row: endRow
                }) : (currentRange.start = {
                    col: startCol,
                    row: startRow
                }, currentRange.end = {
                    col: endCol,
                    row: endRow
                });
            } else if ("cell" !== state.select.headerSelectMode && table.isSeriesNumberInBody(col, row)) {
                const startCol = Math.min(currentRange.start.col, currentRange.end.col, col), endCol = table.colCount - 1, startRow = Math.min(currentRange.start.row, currentRange.end.row, row), endRow = Math.max(currentRange.start.row, currentRange.end.row, row);
                "body" === state.select.headerSelectMode ? (currentRange.start = {
                    col: table.leftRowSeriesNumberCount,
                    row: startRow
                }, currentRange.end = {
                    col: table.colCount - 1,
                    row: endRow
                }) : (currentRange.start = {
                    col: startCol,
                    row: startRow
                }, currentRange.end = {
                    col: endCol,
                    row: endRow
                });
            } else currentRange.end = {
                col: col,
                row: row
            };
            scenegraph.deleteLastSelectedRangeComponents(), scenegraph.updateCellSelectBorder(currentRange);
        } else {
            let extendSelectRange = !0;
            if (-1 === cellPos.col || -1 === cellPos.row || isCtrl && !disableCtrlMultiSelect || (state.select.ranges = [], 
            scenegraph.deleteAllSelectBorder()), "cell" !== state.select.headerSelectMode && table.isColumnHeader(col, row)) {
                const cellRange = table.getCellRange(col, row);
                "body" === state.select.headerSelectMode ? state.select.ranges.push({
                    start: {
                        col: cellRange.start.col,
                        row: table.columnHeaderLevelCount
                    },
                    end: {
                        col: cellRange.end.col,
                        row: table.rowCount - 1
                    },
                    skipBodyMerge: !0
                }) : state.select.ranges.push({
                    start: {
                        col: cellRange.start.col,
                        row: cellRange.start.row
                    },
                    end: {
                        col: cellRange.end.col,
                        row: table.rowCount - 1
                    },
                    skipBodyMerge: !0
                });
            } else if ("cell" !== state.select.headerSelectMode && table.isRowHeader(col, row)) {
                const cellRange = table.getCellRange(col, row);
                "body" === state.select.headerSelectMode ? state.select.ranges.push({
                    start: {
                        col: table.rowHeaderLevelCount + table.leftRowSeriesNumberCount,
                        row: cellRange.start.row
                    },
                    end: {
                        col: table.colCount - 1,
                        row: cellRange.end.row
                    },
                    skipBodyMerge: !0
                }) : state.select.ranges.push({
                    start: {
                        col: cellRange.start.col,
                        row: cellRange.start.row
                    },
                    end: {
                        col: table.colCount - 1,
                        row: cellRange.end.row
                    },
                    skipBodyMerge: !0
                });
            } else if (table.internalProps.layoutMap.isSeriesNumberInHeader(col, row)) {
                extendSelectRange = !1;
                const {cornerHeaderSelectMode: cornerHeaderSelectMode} = state.select;
                if ("body" === cornerHeaderSelectMode) state.select.ranges.push({
                    start: {
                        col: table.leftRowSeriesNumberCount,
                        row: table.columnHeaderLevelCount
                    },
                    end: {
                        col: table.colCount - 1,
                        row: table.rowCount - 1
                    },
                    skipBodyMerge: !0
                }); else if ("inline" === cornerHeaderSelectMode) {
                    const cellRange = skipBodyMerge ? {
                        start: {
                            col: col,
                            row: row
                        },
                        end: {
                            col: col,
                            row: row
                        }
                    } : table.getCellRange(col, row);
                    state.select.ranges.push({
                        start: {
                            col: cellRange.start.col,
                            row: cellRange.start.row
                        },
                        end: {
                            col: cellRange.end.col,
                            row: table.rowCount - 1
                        },
                        skipBodyMerge: !0
                    });
                } else if ("cell" === cornerHeaderSelectMode) {
                    const cellRange = skipBodyMerge ? {
                        start: {
                            col: col,
                            row: row
                        },
                        end: {
                            col: col,
                            row: row
                        }
                    } : table.getCellRange(col, row);
                    state.select.ranges.push({
                        start: {
                            col: cellRange.start.col,
                            row: cellRange.start.row
                        },
                        end: {
                            col: cellRange.end.col,
                            row: cellRange.end.row
                        },
                        skipBodyMerge: skipBodyMerge || void 0
                    });
                } else state.select.ranges.push({
                    start: {
                        col: 0,
                        row: 0
                    },
                    end: {
                        col: table.colCount - 1,
                        row: table.rowCount - 1
                    },
                    skipBodyMerge: !0
                });
            } else if (table.internalProps.layoutMap.isSeriesNumberInBody(col, row)) extendSelectRange = !1, 
            "body" === state.select.headerSelectMode ? state.select.ranges.push({
                start: {
                    col: table.leftRowSeriesNumberCount,
                    row: row
                },
                end: {
                    col: table.colCount - 1,
                    row: row
                },
                skipBodyMerge: !0
            }) : state.select.ranges.push({
                start: {
                    col: col,
                    row: row
                },
                end: {
                    col: table.colCount - 1,
                    row: row
                },
                skipBodyMerge: !0
            }); else if (table.internalProps.layoutMap.isCornerHeader(col, row)) {
                extendSelectRange = !1;
                const {cornerHeaderSelectMode: cornerHeaderSelectMode} = state.select;
                if ("body" === cornerHeaderSelectMode) state.select.ranges.push({
                    start: {
                        col: table.rowHeaderLevelCount + table.leftRowSeriesNumberCount,
                        row: table.columnHeaderLevelCount
                    },
                    end: {
                        col: table.colCount - 1,
                        row: table.rowCount - 1
                    },
                    skipBodyMerge: !0
                }); else if ("cell" === cornerHeaderSelectMode) {
                    const cellRange = skipBodyMerge ? {
                        start: {
                            col: col,
                            row: row
                        },
                        end: {
                            col: col,
                            row: row
                        }
                    } : table.getCellRange(col, row);
                    state.select.ranges.push({
                        start: {
                            col: cellRange.start.col,
                            row: cellRange.start.row
                        },
                        end: {
                            col: cellRange.end.col,
                            row: cellRange.end.row
                        },
                        skipBodyMerge: skipBodyMerge || void 0
                    });
                } else if ("inline" === cornerHeaderSelectMode) {
                    const cellRange = skipBodyMerge ? {
                        start: {
                            col: col,
                            row: row
                        },
                        end: {
                            col: col,
                            row: row
                        }
                    } : table.getCellRange(col, row);
                    state.select.ranges.push({
                        start: {
                            col: cellRange.start.col,
                            row: cellRange.start.row
                        },
                        end: {
                            col: cellRange.end.col,
                            row: table.rowCount - 1
                        },
                        skipBodyMerge: !0
                    });
                } else state.select.ranges.push({
                    start: {
                        col: table.leftRowSeriesNumberCount,
                        row: 0
                    },
                    end: {
                        col: table.colCount - 1,
                        row: table.rowCount - 1
                    },
                    skipBodyMerge: !0
                });
            } else if (col >= 0 && row >= 0) {
                const cellRange = skipBodyMerge ? {
                    start: {
                        col: col,
                        row: row
                    },
                    end: {
                        col: col,
                        row: row
                    }
                } : table.getCellRange(col, row);
                state.select.ranges.push({
                    start: {
                        col: cellRange.start.col,
                        row: cellRange.start.row
                    },
                    end: {
                        col: cellRange.end.col,
                        row: cellRange.end.row
                    },
                    skipBodyMerge: skipBodyMerge || void 0
                });
            }
            cellPos.col = col, cellPos.row = row;
            const currentRange = null === (_b = state.select.ranges) || void 0 === _b ? void 0 : _b[state.select.ranges.length - 1];
            currentRange && currentRange.start.row <= table.rowCount - 1 && currentRange.end.row <= table.rowCount - 1 && currentRange.start.col <= table.colCount - 1 && currentRange.end.col <= table.colCount - 1 && scenegraph.updateCellSelectBorder(currentRange, extendSelectRange);
        }
    } else cellPos.col = -1, cellPos.row = -1, state.select.ranges = [], scenegraph.deleteAllSelectBorder();
    scenegraph.updateNextFrame();
}

export function selectEnd(scenegraph) {
    scenegraph.moveSelectingRangeComponentsToSelectedRangeComponents();
}
//# sourceMappingURL=update-position.js.map
