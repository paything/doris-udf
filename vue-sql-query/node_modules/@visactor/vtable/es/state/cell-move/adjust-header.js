export function adjustMoveHeaderTarget(source, target, table) {
    const sourceCellRange = table.getCellRange(source.col, source.row);
    if (table.isColumnHeader(source.col, source.row)) {
        const targetCellRange = table.getCellRange(target.col, sourceCellRange.start.row);
        target.row >= table.columnHeaderLevelCount && (target.row = table.columnHeaderLevelCount - 1), 
        target.col >= source.col ? target.col = targetCellRange.end.col : target.col = targetCellRange.start.col;
    } else if (table.isRowHeader(source.col, source.row)) {
        const layoutMap = table.internalProps.layoutMap, targetCellRange = table.getCellRange(sourceCellRange.start.col, target.row);
        if (target.col >= table.rowHeaderLevelCount + layoutMap.leftRowSeriesNumberColumnCount && (target.col = table.rowHeaderLevelCount + layoutMap.leftRowSeriesNumberColumnCount - 1), 
        "tree" === layoutMap.rowHierarchyType) {
            const sourceRowHeaderPaths = layoutMap.getCellHeaderPathsWithTreeNode(source.col, source.row).rowHeaderPaths, targetRowHeaderPaths = layoutMap.getCellHeaderPathsWithTreeNode(target.col, target.row).rowHeaderPaths;
            if (sourceRowHeaderPaths.length <= targetRowHeaderPaths.length) {
                const targetPathNode = targetRowHeaderPaths[sourceRowHeaderPaths.length - 1];
                targetPathNode && (target.row >= source.row ? target.row = targetPathNode.startInTotal + targetPathNode.size - 1 + table.columnHeaderLevelCount : target.row = targetPathNode.startInTotal + table.columnHeaderLevelCount);
            }
        } else target.row >= source.row ? target.row = targetCellRange.end.row : target.row = targetCellRange.start.row;
    }
    return target;
}
//# sourceMappingURL=adjust-header.js.map
