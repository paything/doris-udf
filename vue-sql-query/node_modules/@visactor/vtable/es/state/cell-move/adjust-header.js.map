{"version":3,"sources":["../src/state/cell-move/adjust-header.ts"],"names":[],"mappings":"AAKA,MAAM,UAAU,sBAAsB,CAAC,MAAmB,EAAE,MAAmB,EAAE,KAAmB;IAClG,MAAM,eAAe,GAAG,KAAK,CAAC,YAAY,CAAC,MAAM,CAAC,GAAG,EAAE,MAAM,CAAC,GAAG,CAAC,CAAC;IAEnE,IAAI,KAAK,CAAC,cAAc,CAAC,MAAM,CAAC,GAAG,EAAE,MAAM,CAAC,GAAG,CAAC,EAAE;QAEhD,MAAM,eAAe,GAAG,KAAK,CAAC,YAAY,CAAC,MAAM,CAAC,GAAG,EAAE,eAAe,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QAElF,IAAI,MAAM,CAAC,GAAG,IAAI,KAAK,CAAC,sBAAsB,EAAE;YAC9C,MAAM,CAAC,GAAG,GAAG,KAAK,CAAC,sBAAsB,GAAG,CAAC,CAAC;SAC/C;QAED,IAAI,MAAM,CAAC,GAAG,IAAI,MAAM,CAAC,GAAG,EAAE;YAC5B,MAAM,CAAC,GAAG,GAAG,eAAe,CAAC,GAAG,CAAC,GAAG,CAAC;SACtC;aAAM;YACL,MAAM,CAAC,GAAG,GAAG,eAAe,CAAC,KAAK,CAAC,GAAG,CAAC;SACxC;KACF;SAAM,IACL,KAAK,CAAC,WAAW,CAAC,MAAM,CAAC,GAAG,EAAE,MAAM,CAAC,GAAG,CAAC,EAGzC;QACA,MAAM,SAAS,GAAG,KAAK,CAAC,aAAa,CAAC,SAAiC,CAAC;QACxE,MAAM,eAAe,GAAG,KAAK,CAAC,YAAY,CAAC,eAAe,CAAC,KAAK,CAAC,GAAG,EAAE,MAAM,CAAC,GAAG,CAAC,CAAC;QAClF,IAAI,MAAM,CAAC,GAAG,IAAI,KAAK,CAAC,mBAAmB,GAAG,SAAS,CAAC,8BAA8B,EAAE;YACtF,MAAM,CAAC,GAAG,GAAG,KAAK,CAAC,mBAAmB,GAAG,SAAS,CAAC,8BAA8B,GAAG,CAAC,CAAC;SACvF;QAED,IAAI,SAAS,CAAC,gBAAgB,KAAK,MAAM,EAAE;YACzC,MAAM,oBAAoB,GAAG,SAAS,CAAC,8BAA8B,CAAC,MAAM,CAAC,GAAG,EAAE,MAAM,CAAC,GAAG,CAAC;iBAC1F,cAAqB,CAAC;YACzB,MAAM,oBAAoB,GAAG,SAAS,CAAC,8BAA8B,CAAC,MAAM,CAAC,GAAG,EAAE,MAAM,CAAC,GAAG,CAAC;iBAC1F,cAAqB,CAAC;YACzB,IAAI,oBAAoB,CAAC,MAAM,IAAI,oBAAoB,CAAC,MAAM,EAAE;gBAC9D,MAAM,cAAc,GAAG,oBAAoB,CAAC,oBAAoB,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;gBAE7E,IAAI,cAAc,EAAE;oBAClB,IAAI,MAAM,CAAC,GAAG,IAAI,MAAM,CAAC,GAAG,EAAE;wBAE5B,MAAM,CAAC,GAAG,GAAG,cAAc,CAAC,YAAY,GAAG,cAAc,CAAC,IAAI,GAAG,CAAC,GAAG,KAAK,CAAC,sBAAsB,CAAC;qBACnG;yBAAM;wBACL,MAAM,CAAC,GAAG,GAAG,cAAc,CAAC,YAAY,GAAG,KAAK,CAAC,sBAAsB,CAAC;qBACzE;iBACF;aACF;SACF;aAAM,IAAI,MAAM,CAAC,GAAG,IAAI,MAAM,CAAC,GAAG,EAAE;YAEnC,MAAM,CAAC,GAAG,GAAG,eAAe,CAAC,GAAG,CAAC,GAAG,CAAC;SACtC;aAAM;YAEL,MAAM,CAAC,GAAG,GAAG,eAAe,CAAC,KAAK,CAAC,GAAG,CAAC;SACxC;KACF;IACD,OAAO,MAAM,CAAC;AAChB,CAAC","file":"adjust-header.js","sourcesContent":["import type { ListTable } from '../../ListTable';\nimport type { PivotHeaderLayoutMap } from '../../layout/pivot-header-layout';\nimport type { CellAddress } from '../../ts-types';\nimport type { BaseTableAPI } from '../../ts-types/base-table';\n\nexport function adjustMoveHeaderTarget(source: CellAddress, target: CellAddress, table: BaseTableAPI) {\n  const sourceCellRange = table.getCellRange(source.col, source.row);\n\n  if (table.isColumnHeader(source.col, source.row)) {\n    // 处理是目标位置处是合并单元格的情况\n    const targetCellRange = table.getCellRange(target.col, sourceCellRange.start.row);\n    // 如果是拖拽处是body target.row处理成表头最后一层\n    if (target.row >= table.columnHeaderLevelCount) {\n      target.row = table.columnHeaderLevelCount - 1;\n    }\n    //如果拖拽目标的列在原位置的右侧 位置是合并单元格的最右侧\n    if (target.col >= source.col) {\n      target.col = targetCellRange.end.col;\n    } else {\n      target.col = targetCellRange.start.col;\n    } //左侧 位置是合并单元格的最左侧\n  } else if (\n    table.isRowHeader(source.col, source.row)\n    // ||\n    // ((table as ListTable).transpose && table.internalProps.layoutMap.isSeriesNumberInBody(source.col, source.row))\n  ) {\n    const layoutMap = table.internalProps.layoutMap as PivotHeaderLayoutMap;\n    const targetCellRange = table.getCellRange(sourceCellRange.start.col, target.row);\n    if (target.col >= table.rowHeaderLevelCount + layoutMap.leftRowSeriesNumberColumnCount) {\n      target.col = table.rowHeaderLevelCount + layoutMap.leftRowSeriesNumberColumnCount - 1;\n    }\n    // tree模式[透视表行表头]\n    if (layoutMap.rowHierarchyType === 'tree') {\n      const sourceRowHeaderPaths = layoutMap.getCellHeaderPathsWithTreeNode(source.col, source.row)\n        .rowHeaderPaths as any;\n      const targetRowHeaderPaths = layoutMap.getCellHeaderPathsWithTreeNode(target.col, target.row)\n        .rowHeaderPaths as any;\n      if (sourceRowHeaderPaths.length <= targetRowHeaderPaths.length) {\n        const targetPathNode = targetRowHeaderPaths[sourceRowHeaderPaths.length - 1]; //找到共同层级节点\n        // 根据这个目标节点找到结束的row index\n        if (targetPathNode) {\n          if (target.row >= source.row) {\n            //如果拖拽目标的列在原位置的上面 位置是层级的最上端\n            target.row = targetPathNode.startInTotal + targetPathNode.size - 1 + table.columnHeaderLevelCount;\n          } else {\n            target.row = targetPathNode.startInTotal + table.columnHeaderLevelCount;\n          }\n        } //如果拖拽目标的列在原位置的下面 位置是层级的最下端\n      }\n    } else if (target.row >= source.row) {\n      //table模式 如果拖拽目标的列在原位置的下面 位置是层级的最下端\n      target.row = targetCellRange.end.row;\n    } else {\n      //table模式  如果拖拽目标的列在原位置的上面 位置是层级的最上端\n      target.row = targetCellRange.start.row;\n    }\n  }\n  return target;\n}\n"]}