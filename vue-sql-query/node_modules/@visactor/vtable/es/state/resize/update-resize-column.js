export function updateResizeColumn(xInTable, yInTable, state) {
    xInTable = Math.ceil(xInTable), yInTable = Math.ceil(yInTable);
    let detaX = state.columnResize.isRightFrozen ? state.columnResize.x - xInTable : xInTable - state.columnResize.x;
    if (Math.abs(detaX) < 1) return;
    const widthCache = state.table.getColWidth(state.columnResize.col);
    let width = widthCache;
    width += detaX;
    const minWidth = state.table.getMinColWidth(state.columnResize.col), maxWidth = state.table.getMaxColWidth(state.columnResize.col);
    if (width < minWidth || width > maxWidth) {
        if (widthCache === minWidth || widthCache === maxWidth) return;
        detaX = widthCache - minWidth > maxWidth - widthCache ? maxWidth - widthCache : minWidth - widthCache;
    }
    let afterSize = state.table.getColWidth(state.columnResize.col) + detaX;
    if (afterSize < state.table.internalProps.limitMinWidth && (afterSize = state.table.internalProps.limitMinWidth, 
    detaX = afterSize - state.table.getColWidth(state.columnResize.col)), "adaptive" === state.table.widthMode && state.columnResize.col < state.table.colCount - 1) {
        const rightColWidthCache = state.table.getColWidth(state.columnResize.col + 1), rightColMinWidth = state.table.getMinColWidth(state.columnResize.col + 1), rightColMaxWidth = state.table.getMaxColWidth(state.columnResize.col + 1);
        let rightColWidth = rightColWidthCache;
        if (rightColWidth -= detaX, rightColWidth < rightColMinWidth || rightColWidth > rightColMaxWidth) {
            if (rightColWidthCache === rightColMinWidth || rightColWidthCache === rightColMaxWidth) return;
            detaX = rightColWidthCache - rightColMinWidth > rightColMaxWidth - rightColWidthCache ? rightColMaxWidth - rightColWidthCache : rightColMinWidth - rightColWidthCache;
        }
        rightColWidth - detaX < state.table.internalProps.limitMinWidth && (detaX = rightColWidth - state.table.internalProps.limitMinWidth);
    }
    detaX = Math.ceil(detaX), state.columnResize.col < state.table.rowHeaderLevelCount || state.columnResize.col >= state.table.colCount - state.table.rightFrozenColCount ? updateResizeColForColumn(detaX, state) : "indicator" === state.table.internalProps.columnResizeType ? updateResizeColForIndicator(detaX, state) : "indicatorGroup" === state.table.internalProps.columnResizeType ? updateResizeColForIndicatorGroup(detaX, state) : "all" === state.table.internalProps.columnResizeType ? updateResizeColForAll(detaX, state) : updateResizeColForColumn(detaX, state), 
    state.columnResize.x = xInTable, state.table.scenegraph.component.updateResizeCol(state.columnResize.col, yInTable, state.columnResize.isRightFrozen), 
    state.columnResize.col < state.table.frozenColCount && !state.table.isPivotTable() && !state.table.transpose ? state.table.scenegraph.component.setFrozenColumnShadow(state.table.frozenColCount - 1, state.columnResize.isRightFrozen) : state.table.options.frozenColCount && state.table.scenegraph.component.setFrozenColumnShadow(state.table.frozenColCount - 1), 
    (state.columnResize.col >= state.table.colCount - state.table.rightFrozenColCount && !state.table.isPivotTable() && !state.table.transpose || state.table.options.rightFrozenColCount) && state.table.scenegraph.component.setRightFrozenColumnShadow(state.table.colCount - state.table.rightFrozenColCount), 
    state.table.scenegraph.updateNextFrame();
}

function updateResizeColForColumn(detaX, state) {
    "adaptive" === state.table.widthMode && state.columnResize.col < state.table.colCount - 1 ? (state.table.scenegraph.updateColWidth(state.columnResize.col, detaX), 
    state.table.scenegraph.updateColWidth(state.columnResize.col + 1, -detaX), state.table.internalProps._widthResizedColMap.add(state.columnResize.col), 
    state.table.internalProps._widthResizedColMap.add(state.columnResize.col + 1)) : (state.table.scenegraph.updateColWidth(state.columnResize.col, detaX), 
    state.table.internalProps._widthResizedColMap.add(state.columnResize.col));
}

function updateResizeColForAll(detaX, state) {
    const layout = state.table.internalProps.layoutMap;
    for (let col = state.table.frozenColCount; col < state.table.colCount - state.table.rightFrozenColCount; col++) {
        if (!(state.table.internalProps.transpose || state.table.isPivotTable() && !layout.indicatorsAsCol)) {
            const cellDefine = layout.getBody(col, state.table.columnHeaderLevelCount);
            if (null == cellDefine ? void 0 : cellDefine.disableColumnResize) continue;
        }
        state.table.scenegraph.updateColWidth(col, detaX), state.table.internalProps._widthResizedColMap.add(col);
    }
}

function updateResizeColForIndicator(detaX, state) {
    const layout = state.table.internalProps.layoutMap;
    let resizeIndicatorKey, resizeDimensionKey, resizeDimensionValue;
    if (layout.indicatorsAsCol) resizeIndicatorKey = layout.getIndicatorKey(state.columnResize.col, state.table.columnHeaderLevelCount); else {
        const headerPaths = layout.getCellHeaderPaths(state.columnResize.col, state.table.columnHeaderLevelCount - 1), headerPath = headerPaths.colHeaderPaths[headerPaths.colHeaderPaths.length - 1];
        resizeDimensionKey = headerPath.dimensionKey, resizeDimensionValue = headerPath.value;
    }
    for (let col = state.table.rowHeaderLevelCount; col < state.table.colCount - state.table.rightFrozenColCount; col++) {
        const indicatorKey = layout.getIndicatorKey(col, state.table.columnHeaderLevelCount);
        if (layout.indicatorsAsCol && indicatorKey === resizeIndicatorKey) state.table.scenegraph.updateColWidth(col, detaX), 
        state.table.internalProps._widthResizedColMap.add(col); else if (!layout.indicatorsAsCol) {
            const headerPaths = layout.getCellHeaderPaths(col, state.table.columnHeaderLevelCount - 1), headerPath = null == headerPaths ? void 0 : headerPaths.colHeaderPaths[headerPaths.colHeaderPaths.length - 1];
            headerPath && resizeDimensionKey === headerPath.dimensionKey && resizeDimensionValue === headerPath.value && (state.table.scenegraph.updateColWidth(col, detaX), 
            state.table.internalProps._widthResizedColMap.add(col));
        }
    }
}

function updateResizeColForIndicatorGroup(detaX, state) {
    const layout = state.table.internalProps.layoutMap, headerPaths = layout.getCellHeaderPaths(state.columnResize.col, state.table.columnHeaderLevelCount), node = layout.getHeadNodeByRowOrColDimensions(headerPaths.colHeaderPaths.slice(0, headerPaths.colHeaderPaths.length - 1)), startCol = node.startInTotal + state.table.frozenColCount, endCol = node.startInTotal + state.table.frozenColCount + node.size - 1, totalColWidth = state.table.getColsWidth(startCol, endCol), moveX = detaX;
    for (let col = startCol; col <= endCol; col++) {
        if (!(state.table.internalProps.transpose || state.table.isPivotTable() && !layout.indicatorsAsCol)) {
            const cellDefine = layout.getBody(col, state.table.columnHeaderLevelCount);
            if (null == cellDefine ? void 0 : cellDefine.disableColumnResize) continue;
        }
        let deltaWidth = state.table.getColWidth(col) / totalColWidth * moveX;
        deltaWidth > 0 && deltaWidth < .5 ? deltaWidth = .5 : deltaWidth < 0 && deltaWidth >= -.5 && (deltaWidth = -.5), 
        state.table.scenegraph.updateColWidth(col, deltaWidth), state.table.internalProps._widthResizedColMap.add(col);
    }
}
//# sourceMappingURL=update-resize-column.js.map
