import { Group } from "./../../vrender";

export function emptyCustomLayout(args) {
    return {
        rootContainer: new Group({}),
        renderDefault: !0
    };
}

export class ReactCustomLayout {
    constructor(table) {
        this.table = table, this.customLayoutFuncCache = new Map, this.reactRemoveGraphicCache = new Map, 
        this.reactRemoveAllGraphicCache = new Map, this.headerCustomLayoutFuncCache = new Map, 
        this.headerReactRemoveGraphicCache = new Map, this.headerReactRemoveAllGraphicCache = new Map;
    }
    hasReactCreateGraphic(componentId, isHeaderCustomLayout) {
        return isHeaderCustomLayout ? this.headerCustomLayoutFuncCache.has(componentId) : this.customLayoutFuncCache.has(componentId);
    }
    setReactCreateGraphic(componentId, createGraphic, isHeaderCustomLayout) {
        isHeaderCustomLayout ? this.headerCustomLayoutFuncCache.set(componentId, createGraphic) : this.customLayoutFuncCache.set(componentId, createGraphic);
    }
    setReactRemoveGraphic(componentId, removeGraphic, isHeaderCustomLayout) {
        isHeaderCustomLayout ? this.headerReactRemoveGraphicCache.set(componentId, removeGraphic) : this.reactRemoveGraphicCache.set(componentId, removeGraphic);
    }
    setReactRemoveAllGraphic(componentId, removeGraphic, isHeaderCustomLayout) {
        isHeaderCustomLayout ? this.headerReactRemoveAllGraphicCache.set(componentId, removeGraphic) : this.reactRemoveAllGraphicCache.set(componentId, removeGraphic);
    }
    updateCustomCell(componentId, isHeaderCustomLayout) {
        const table = this.table;
        if ("autoWidth" === table.widthMode && table.scenegraph.recalculateColWidths(), 
        (table.isAutoRowHeight() || "auto" === table.internalProps.defaultRowHeight && !isHeaderCustomLayout || "auto" === table.internalProps.defaultHeaderRowHeight && isHeaderCustomLayout) && table.scenegraph.recalculateRowHeights(), 
        table.isPivotTable()) {
            const ranges = getUpdateCustomCellRangeInPivotTable(componentId, table, isHeaderCustomLayout);
            for (let i = 0; i < ranges.length; i++) {
                const range = ranges[i];
                for (let col = range.start.col; col <= range.end.col; col++) for (let row = range.start.row; row <= range.end.row; row++) table.scenegraph.updateCellContent(col, row);
            }
        } else {
            const range = getUpdateCustomCellRangeInListTable(componentId, table, isHeaderCustomLayout);
            for (let col = range.start.col; col <= range.end.col; col++) for (let row = range.start.row; row <= range.end.row; row++) table.scenegraph.updateCellContent(col, row);
        }
        table.scenegraph.renderSceneGraph();
    }
    getCustomLayoutFunc(col, row) {
        var _a;
        if (this.table.isHeader(col, row)) {
            const {componentId: componentId} = this.table.getHeaderDefine(col, row);
            return null !== (_a = this.headerCustomLayoutFuncCache.get(componentId)) && void 0 !== _a ? _a : emptyCustomLayout;
        }
        const {componentId: componentId} = this.table.getBodyColumnDefine(col, row);
        return this.customLayoutFuncCache.get(componentId) || emptyCustomLayout;
    }
    removeCustomCell(col, row) {
        let removeFun;
        if (this.table.isHeader(col, row)) {
            const define = this.table.getHeaderDefine(col, row), {componentId: componentId} = define;
            removeFun = this.headerReactRemoveGraphicCache.get(componentId);
        } else {
            const define = this.table.getBodyColumnDefine(col, row), {componentId: componentId} = define;
            removeFun = this.reactRemoveGraphicCache.get(componentId);
        }
        removeFun && removeFun(col, row);
    }
    clearCache() {
        this.reactRemoveAllGraphicCache.forEach((removeFun => {
            removeFun();
        })), this.headerReactRemoveAllGraphicCache.forEach((removeFun => {
            removeFun();
        }));
    }
    updateAllCustomCell() {
        this.customLayoutFuncCache.forEach(((createFun, componentId) => {
            this.updateCustomCell(componentId);
        })), this.headerCustomLayoutFuncCache.forEach(((createFun, componentId) => {
            this.updateCustomCell(componentId, !0);
        }));
    }
}

function getUpdateCustomCellRangeInListTable(componentId, table, isHeaderCustomLayout) {
    const rowSeriesNumber = table.internalProps.rowSeriesNumber ? 1 : 0;
    if (isHeaderCustomLayout) {
        const layoutMap = table.internalProps.layoutMap, {headerObjects: headerObjects} = table.internalProps.layoutMap;
        let headerId;
        for (let i = 0; i < headerObjects.length; i++) {
            const headerObject = headerObjects[i];
            if (headerObject.define.componentId === componentId) {
                headerId = headerObject.id;
                break;
            }
        }
        const startCell = layoutMap.getHeaderCellAdressById(headerId);
        return layoutMap.getCellRange(startCell.col, startCell.row);
    }
    const {columnObjects: columnObjects} = table.internalProps.layoutMap;
    for (let i = 0; i < columnObjects.length; i++) {
        if (columnObjects[i].define.componentId === componentId) return {
            start: {
                col: rowSeriesNumber + i,
                row: table.columnHeaderLevelCount
            },
            end: {
                col: rowSeriesNumber + i,
                row: table.rowCount - 1
            }
        };
    }
    return {
        start: {
            col: 0,
            row: 0
        },
        end: {
            col: table.colCount - 1,
            row: table.rowCount - 1
        }
    };
}

function getUpdateCustomCellRangeInPivotTable(componentId, table, isHeaderCustomLayout) {
    const rowSeriesNumber = table.internalProps.rowSeriesNumber ? 1 : 0, ranges = [], layoutMap = table.internalProps.layoutMap;
    if (isHeaderCustomLayout) {
        const {headerObjects: headerObjects} = layoutMap, headerIds = [];
        for (let i = 0; i < headerObjects.length; i++) {
            const headerObject = headerObjects[i];
            headerObject && (headerObject.define.componentId === componentId && headerIds.push(headerObject.id));
        }
        for (let i = 0; i < headerIds.length; i++) {
            const headerId = headerIds[i], startCell = layoutMap.getHeaderCellAdressById(headerId), range = layoutMap.getCellRange(startCell.col, startCell.row);
            ranges.push(range);
        }
    } else {
        let columnIndex;
        const {columnObjects: columnObjects, indicatorsAsCol: indicatorsAsCol} = layoutMap;
        for (let i = 0; i < columnObjects.length; i++) {
            if (columnObjects[i].define.componentId === componentId) {
                columnIndex = i;
                break;
            }
        }
        if (indicatorsAsCol) for (let column = layoutMap.rowHeaderLevelCount + columnIndex; column < layoutMap.colCount; column += columnObjects.length) {
            const range = {
                start: {
                    col: column + rowSeriesNumber,
                    row: layoutMap.columnHeaderLevelCount
                },
                end: {
                    col: column + rowSeriesNumber,
                    row: layoutMap.rowCount - 1
                }
            };
            ranges.push(range);
        } else for (let row = layoutMap.columnHeaderLevelCount + columnIndex; row < layoutMap.rowCount; row += columnObjects.length) {
            const range = {
                start: {
                    col: layoutMap.rowHeaderLevelCount + rowSeriesNumber,
                    row: row
                },
                end: {
                    col: layoutMap.colCount - 1,
                    row: row
                }
            };
            ranges.push(range);
        }
    }
    return ranges;
}
//# sourceMappingURL=react-custom-layout.js.map
