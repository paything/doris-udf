import { isXAxis } from "../util/orient";

import { isEmpty, last as peek } from "@visactor/vutils";

export function doOverlap(axisComponent, axis) {
    const layer0LabelsContainer = axisComponent.find((node => "axis-label-container-layer-0" === node.name), !0), layer1LabelsContainer = axisComponent.find((node => "axis-label-container-layer-1" === node.name), !0);
    overlap(layer0LabelsContainer ? layer0LabelsContainer.getChildren() : [], axis), 
    overlap(layer1LabelsContainer ? layer1LabelsContainer.getChildren() : [], axis);
}

function labelFlush(axisLabels, axis) {
    const {width: width, height: height} = axis.getLayoutRect(), isX = isXAxis(axis.orient), isInverse = !0 === axis.option.inverse, first = axisLabels[0], last = peek(axisLabels);
    if (isX) if (isInverse) {
        const start = width, end = 0, startBound = first.AABBBounds.x2, endBound = last.AABBBounds.x1;
        startBound > start && first.setAttributes({
            x: start,
            textAlign: "right"
        }), endBound < end && last.setAttributes({
            x: end,
            textAlign: "left"
        });
    } else {
        const start = 0, end = width, startBound = first.AABBBounds.x1, endBound = last.AABBBounds.x2;
        startBound < start && first.setAttributes({
            x: start,
            textAlign: "left"
        }), endBound > end && last.setAttributes({
            x: end,
            textAlign: "right"
        });
    } else if (isInverse) {
        const startBound = first.AABBBounds.y1, endBound = last.AABBBounds.y2, start = 0, end = height;
        startBound < start && first.setAttributes({
            y: start,
            textBaseline: "top"
        }), endBound > end && last.setAttributes({
            y: end,
            textBaseline: "bottom"
        });
    } else {
        const start = height, end = 0, startBound = first.AABBBounds.y2, endBound = last.AABBBounds.y1;
        startBound > start && first.setAttributes({
            y: start,
            textBaseline: "bottom"
        }), endBound < end && last.setAttributes({
            y: end,
            textBaseline: "top"
        });
    }
}

function overlap(axisLabels, axis) {
    var _a;
    const spec = axis.option;
    isEmpty(axisLabels) || (null === (_a = null == spec ? void 0 : spec.label) || void 0 === _a ? void 0 : _a.flush) && labelFlush(axisLabels, axis);
}
//# sourceMappingURL=label-overlap.js.map
