import { isValid, merge } from "@visactor/vutils";

import { DefaultSparklineSpec } from "../tools/global";

import { HierarchyState } from "../ts-types";

import { checkHasChart, getChartDataId } from "./chart-helper/get-chart-spec";

import { checkHasAggregation, checkHasAggregationOnBottom, checkHasAggregationOnTop, checkHasTreeDefine } from "./layout-helper";

import { DimensionTree } from "./tree-helper";

import { getCellRange } from "./cell-range/simple-cell-range";

export class SimpleHeaderLayoutMap {
    constructor(table, columns, showHeader, hierarchyIndent) {
        var _a, _b;
        this.seqId = 0, this.leftRowSeriesNumberColumnCount = 0, this.rightRowSeriesNumberColumnCount = 0, 
        this.bodyRowSpanCount = 1, this._transpose = !1, this._showHeader = !0, this._recordsCount = 0, 
        this._hasAggregation = !1, this._hasAggregationOnTopCount = 0, this._hasAggregationOnBottomCount = 0, 
        this._cellRangeMap = new Map, this._showHeader = showHeader, this._table = table, 
        this._columns = [], this._columnsIncludeHided = [], this._headerCellIds = [], this.hierarchyIndent = null != hierarchyIndent ? hierarchyIndent : 20, 
        this.hierarchyTextStartAlignment = table.options.hierarchyTextStartAlignment, this.columnHierarchyType = table.options.headerHierarchyType, 
        this.columnExpandLevel = null !== (_a = table.options.headerExpandLevel) && void 0 !== _a ? _a : 1, 
        this.columnTree = new DimensionTree(columns, {
            seqId: 0
        }, null !== (_b = this.columnHierarchyType) && void 0 !== _b ? _b : null, "grid-tree" === this.columnHierarchyType ? this.columnExpandLevel : void 0), 
        this._headerObjectsIncludeHided = this._addHeaders(0, columns, []), this._headerObjects = this._headerObjectsIncludeHided.filter((col => !0 !== col.define.hide)), 
        this._headerObjectMap = this._headerObjects.reduce(((o, e) => (o[e.id] = e, o)), {}), 
        this.rowHierarchyType = checkHasTreeDefine(this) ? "tree" : "grid", this._hasAggregation = checkHasAggregation(this), 
        this._hasAggregationOnBottomCount = checkHasAggregationOnBottom(this), this._hasAggregationOnTopCount = checkHasAggregationOnTop(this), 
        this.handleRowSeriesNumber(table.internalProps.rowSeriesNumber);
    }
    handleRowSeriesNumber(rowSeriesNumber) {
        var _a;
        rowSeriesNumber && (Array.isArray(rowSeriesNumber) ? this.rowSeriesNumberColumn = rowSeriesNumber.map(((seriesNumber, index) => {
            var _a, _b;
            return {
                id: this.seqId++,
                title: seriesNumber.title,
                define: merge({
                    field: "_vtable_rowSeries_number_" + index
                }, seriesNumber),
                cellType: null !== (_a = seriesNumber.cellType) && void 0 !== _a ? _a : "text",
                headerType: "checkbox" === seriesNumber.cellType ? "checkbox" : "text",
                style: seriesNumber.style,
                width: seriesNumber.width,
                format: seriesNumber.format,
                field: null !== (_b = seriesNumber.field) && void 0 !== _b ? _b : "_vtable_rowSeries_number_" + index,
                icon: seriesNumber.icon,
                headerIcon: seriesNumber.headerIcon,
                isChildNode: !1
            };
        })) : this.rowSeriesNumberColumn = [ {
            id: this.seqId++,
            title: rowSeriesNumber.title,
            define: merge({
                field: "_vtable_rowSeries_number"
            }, rowSeriesNumber),
            cellType: null !== (_a = rowSeriesNumber.cellType) && void 0 !== _a ? _a : "text",
            headerType: "checkbox" === rowSeriesNumber.cellType ? "checkbox" : "text",
            style: rowSeriesNumber.style,
            width: rowSeriesNumber.width,
            format: rowSeriesNumber.format,
            field: "_vtable_rowSeries_number",
            icon: rowSeriesNumber.icon,
            headerIcon: rowSeriesNumber.headerIcon,
            isChildNode: !1
        } ], this.leftRowSeriesNumberColumn = this.rowSeriesNumberColumn.filter((rowSeriesNumberItem => !0)), 
        this.rightRowSeriesNumberColumn = this.rowSeriesNumberColumn.filter((rowSeriesNumberItem => !1)), 
        this.leftRowSeriesNumberColumnCount = this.leftRowSeriesNumberColumn.length, this.rightRowSeriesNumberColumnCount = this.rightRowSeriesNumberColumn.length);
    }
    get transpose() {
        return this._transpose;
    }
    set transpose(_transpose) {
        this._transpose = _transpose;
    }
    get showHeader() {
        return this._showHeader;
    }
    set showHeader(_showHeader) {
        this._showHeader = _showHeader;
    }
    isSeriesNumberInHeader(col, row) {
        if (this.leftRowSeriesNumberColumnCount > 0 && col >= 0 && row >= 0 && col < this.leftRowSeriesNumberColumnCount) {
            if (this.transpose) return !1;
            if (row < this.headerLevelCount) return !0;
        }
        if (this.rightRowSeriesNumberColumnCount > 0 && row >= 0 && col >= this.colCount - this.rightRowSeriesNumberColumnCount) {
            if (this.transpose) return !1;
            if (row < this.headerLevelCount) return !0;
        }
        return !1;
    }
    isSeriesNumberInBody(col, row) {
        if (this.leftRowSeriesNumberColumnCount > 0 && col >= 0 && col < this.leftRowSeriesNumberColumnCount) {
            if (this.transpose) return !0;
            if (row >= this.headerLevelCount) return !0;
        }
        if (this.rightRowSeriesNumberColumnCount > 0 && col >= this.colCount - this.rightRowSeriesNumberColumnCount) {
            if (this.transpose) return !0;
            if (row >= this.headerLevelCount) return !0;
        }
        return !1;
    }
    isSeriesNumber(col, row) {
        if (isValid(col) && isValid(row)) {
            if (this.leftRowSeriesNumberColumnCount > 0 && col >= 0 && row >= 0 && col < this.leftRowSeriesNumberColumnCount) return !0;
            if (this.rightRowSeriesNumberColumnCount > 0 && row >= 0 && col >= this.colCount - this.rightRowSeriesNumberColumnCount) return !0;
        }
        return !1;
    }
    getSeriesNumberHeader(col, row) {
        if (this.leftRowSeriesNumberColumnCount > 0 && col >= 0 && col < this.leftRowSeriesNumberColumnCount) {
            if (this.transpose) return;
            if (row < this.headerLevelCount) return Object.assign({}, this.leftRowSeriesNumberColumn[col], {
                style: Object.assign({}, this._table.transpose ? this._table.internalProps.theme.rowHeaderStyle : this._table.internalProps.theme.headerStyle, this._table.internalProps.rowSeriesNumber.headerStyle)
            });
        }
        if (this.rightRowSeriesNumberColumnCount > 0 && col >= this.colCount - this.rightRowSeriesNumberColumnCount && row < this.headerLevelCount) {
            if (this.transpose) return;
            if (row < this.headerLevelCount) return this.rightRowSeriesNumberColumn[col - (this.colCount - this.rightRowSeriesNumberColumnCount)];
        }
    }
    getSeriesNumberBody(col, row) {
        if (this.leftRowSeriesNumberColumnCount > 0 && col >= 0 && col < this.leftRowSeriesNumberColumnCount) {
            if (this.transpose) return this.leftRowSeriesNumberColumn[col];
            if (row >= this.headerLevelCount) return this.leftRowSeriesNumberColumn[col];
        }
        if (this.rightRowSeriesNumberColumnCount > 0 && col >= this.colCount - this.rightRowSeriesNumberColumnCount) {
            if (this.transpose) return this.rightRowSeriesNumberColumn[col - (this.colCount - this.rightRowSeriesNumberColumnCount)];
            if (row >= this.headerLevelCount) return this.rightRowSeriesNumberColumn[col - (this.colCount - this.rightRowSeriesNumberColumnCount)];
        }
    }
    isHeader(col, row) {
        return !!(this.transpose && col >= this.leftRowSeriesNumberColumnCount && col < this.headerLevelCount + this.leftRowSeriesNumberColumnCount) || !this.transpose && row >= 0 && row < this.headerLevelCount;
    }
    isAggregation(col, row) {
        if (this.hasAggregation) {
            if (this.hasAggregationOnBottomCount) if (this.transpose) {
                if (col >= this.colCount - this.hasAggregationOnBottomCount) return !0;
            } else if (row >= this.rowCount - this.hasAggregationOnBottomCount) return !0;
            if (this.hasAggregationOnTopCount) if (this.transpose) {
                if (col >= this.rowHeaderLevelCount && col < this.rowHeaderLevelCount + this.hasAggregationOnTopCount) return !0;
            } else if (row >= this.columnHeaderLevelCount && row < this.columnHeaderLevelCount + this.hasAggregationOnTopCount) return !0;
        }
        return !1;
    }
    isTopAggregation(col, row) {
        if (this.hasAggregationOnTopCount) if (this.transpose) {
            if (col >= this.rowHeaderLevelCount && col < this.rowHeaderLevelCount + this.hasAggregationOnTopCount) return !0;
        } else if (row >= this.columnHeaderLevelCount && row < this.columnHeaderLevelCount + this.hasAggregationOnTopCount) return !0;
        return !1;
    }
    isBottomAggregation(col, row) {
        if (this.hasAggregationOnBottomCount) if (this.transpose) {
            if (col >= this.colCount - this.hasAggregationOnBottomCount) return !0;
        } else if (row >= this.rowCount - this.hasAggregationOnBottomCount) return !0;
        return !1;
    }
    get hasAggregation() {
        return this._hasAggregation;
    }
    get hasAggregationOnTopCount() {
        return this._hasAggregationOnTopCount;
    }
    get hasAggregationOnBottomCount() {
        return this._hasAggregationOnBottomCount;
    }
    getAggregatorsByCell(col, row) {
        return this.getColumnDefine(col, row).vtable_aggregator;
    }
    getAggregatorsByCellRange(startCol, startRow, endCol, endRow) {
        let aggregators = [];
        if (!this.transpose) {
            for (let i = startCol; i <= endCol; i++) {
                const column = this.getColumnDefine(i, startRow);
                column.vtable_aggregator && (aggregators = aggregators.concat(Array.isArray(column.vtable_aggregator) ? column.vtable_aggregator : [ column.vtable_aggregator ]));
            }
            return aggregators;
        }
        for (let i = startRow; i <= endRow; i++) {
            const column = this.getColumnDefine(startCol, i);
            column.vtable_aggregator && (aggregators = aggregators.concat(Array.isArray(column.vtable_aggregator) ? column.vtable_aggregator : [ column.vtable_aggregator ]));
        }
        return [];
    }
    getAggregatorOnTop(col, row) {
        const column = this.getColumnDefine(col, row), aggregators = column.vtable_aggregator, aggregation = column.aggregation;
        if (Array.isArray(aggregation)) {
            const topAggregators = aggregation.reduce(((indexs, agg, index) => (agg.showOnTop && indexs.push(index), 
            indexs)), []).map((index => aggregators[index]));
            return this.transpose ? topAggregators[col - this.rowHeaderLevelCount] : topAggregators[row - this.columnHeaderLevelCount];
        }
        return this.transpose && col - this.rowHeaderLevelCount == 0 ? (null == aggregation ? void 0 : aggregation.showOnTop) ? aggregators : null : this.transpose || row - this.columnHeaderLevelCount != 0 ? null : (null == aggregation ? void 0 : aggregation.showOnTop) ? aggregators : null;
    }
    getAggregatorOnBottom(col, row) {
        const column = this.getColumnDefine(col, row), aggregators = column.vtable_aggregator, aggregation = column.aggregation;
        if (Array.isArray(aggregation)) {
            const bottomAggregators = aggregation.reduce(((indexs, agg, index) => (agg.showOnTop || indexs.push(index), 
            indexs)), []).map((index => aggregators[index]));
            return this.transpose ? bottomAggregators[col - (this.colCount - this.hasAggregationOnBottomCount)] : bottomAggregators[row - (this.rowCount - this.hasAggregationOnBottomCount)];
        }
        return this.transpose && col - (this.colCount - this.hasAggregationOnBottomCount) == 0 ? (null == aggregation ? void 0 : aggregation.showOnTop) ? null : aggregators : this.transpose || row - (this.rowCount - this.hasAggregationOnBottomCount) != 0 || (null == aggregation ? void 0 : aggregation.showOnTop) ? null : aggregators;
    }
    getAggregatorCellAddress(startCol, startRow, endCol, endRow) {
        const cellAddrs = [], topCount = this.hasAggregationOnTopCount, bottomCount = this.hasAggregationOnBottomCount;
        if (this.transpose) for (let row = startRow; row <= endRow; row++) {
            if (this.getColumnDefine(startCol, row).vtable_aggregator) {
                for (let i = 0; i < topCount; i++) cellAddrs.push({
                    col: this.headerLevelCount + i,
                    row: row
                });
                for (let i = 0; i < bottomCount; i++) cellAddrs.push({
                    col: this.rowCount - bottomCount + i,
                    row: row
                });
            }
        } else for (let col = startCol; col <= endCol; col++) {
            if (this.getColumnDefine(col, startRow).vtable_aggregator) {
                for (let i = 0; i < topCount; i++) cellAddrs.push({
                    col: col,
                    row: this.headerLevelCount + i
                });
                for (let i = 0; i < bottomCount; i++) cellAddrs.push({
                    col: col,
                    row: this.rowCount - bottomCount + i
                });
            }
        }
        return cellAddrs;
    }
    getCellLocation(col, row) {
        return this.isHeader(col, row) ? this.transpose ? "rowHeader" : "columnHeader" : "body";
    }
    isRowHeader(col, row) {
        return !!(this.transpose && col >= this.leftRowSeriesNumberColumnCount && col < this.headerLevelCount + this.leftRowSeriesNumberColumnCount);
    }
    isColumnHeader(col, row) {
        return !this.transpose && row >= 0 && row <= this.headerLevelCount - 1 && col >= this.leftRowSeriesNumberColumnCount && col < this.colCount - this.rightRowSeriesNumberColumnCount;
    }
    isFrozenColumn(col, row) {
        if (isValid(row)) {
            if (col >= 0 && col < this.frozenColCount && row >= this.frozenRowCount && row < this.rowCount - this.bottomFrozenRowCount) return !0;
        } else if (this.frozenColCount > 0 && col >= 0 && col < this.frozenColCount) return !0;
        return !1;
    }
    isRightFrozenColumn(col, row) {
        if (isValid(row)) {
            if (col >= this.colCount - this.rightFrozenColCount && row >= this.frozenRowCount && row < this.rowCount - this.bottomFrozenRowCount) return !0;
        } else if (this.rightFrozenColCount > 0 && col >= this.colCount - this.rightFrozenColCount) return !0;
        return !1;
    }
    isFrozenRow(col, row) {
        if (isValid(row)) {
            if (row >= 0 && row < this.frozenRowCount && col >= this.frozenColCount && col < this.colCount - this.rightFrozenColCount) return !0;
        } else if (row = col, this.frozenRowCount > 0 && row >= 0 && row < this.frozenRowCount) return !0;
        return !1;
    }
    isBottomFrozenRow(col, row) {
        if (isValid(row)) {
            if (row >= this.rowCount - this.bottomFrozenRowCount && col >= this.frozenColCount && col < this.colCount - this.rightFrozenColCount) return !0;
        } else if (row = col, this.bottomFrozenRowCount > 0 && row >= this.rowCount - this.bottomFrozenRowCount) return !0;
        return !1;
    }
    isLeftTopCorner(col, row) {
        return col >= 0 && col < this.frozenColCount && row >= 0 && row < this.frozenRowCount;
    }
    isLeftBottomCorner(col, row) {
        return col >= 0 && col < this.frozenColCount && row >= this.rowCount - this.bottomFrozenRowCount;
    }
    isRightTopCorner(col, row) {
        return col >= this.colCount - this.rightFrozenColCount && row >= 0 && row < this.frozenRowCount;
    }
    isRightBottomCorner(col, row) {
        return col >= this.colCount - this.rightFrozenColCount && row >= this.rowCount - this.bottomFrozenRowCount;
    }
    isCornerHeader(col, row) {
        return !1;
    }
    getColumnHeaderRange() {
        var _a, _b;
        return this.transpose ? {
            start: {
                col: 0,
                row: 0
            },
            end: {
                col: this._headerCellIds.length - 1,
                row: (null !== (_a = this.rowCount) && void 0 !== _a ? _a : 0) - 1
            }
        } : {
            start: {
                col: 0,
                row: 0
            },
            end: {
                col: (null !== (_b = this.colCount) && void 0 !== _b ? _b : 0) - 1,
                row: this._headerCellIds.length - 1
            }
        };
    }
    getRowHeaderRange() {
        var _a, _b;
        return this.transpose ? {
            start: {
                col: 0,
                row: 0
            },
            end: {
                col: this._headerCellIds.length - 1,
                row: (null !== (_a = this.rowCount) && void 0 !== _a ? _a : 0) - 1
            }
        } : {
            start: {
                col: 0,
                row: 0
            },
            end: {
                col: (null !== (_b = this.colCount) && void 0 !== _b ? _b : 0) - 1,
                row: this._headerCellIds.length - 1
            }
        };
    }
    getCornerHeaderRange() {}
    getBodyRange() {
        var _a, _b, _c, _d;
        return this.transpose ? {
            start: {
                col: this.headerLevelCount,
                row: 0
            },
            end: {
                col: (null !== (_a = this.colCount) && void 0 !== _a ? _a : 0) - 1,
                row: (null !== (_b = this.rowCount) && void 0 !== _b ? _b : 0) - 1
            }
        } : {
            start: {
                col: 0,
                row: this.headerLevelCount
            },
            end: {
                col: (null !== (_c = this.colCount) && void 0 !== _c ? _c : 0) - 1,
                row: (null !== (_d = this.rowCount) && void 0 !== _d ? _d : 0) - 1
            }
        };
    }
    get headerLevelCount() {
        return this.showHeader ? this._headerCellIds.length : 0;
    }
    get columnHeaderLevelCount() {
        return this.transpose ? 0 : this.headerLevelCount;
    }
    get rowHeaderLevelCount() {
        return this.transpose ? this.headerLevelCount : 0;
    }
    get frozenColCount() {
        return this._table.internalProps.frozenColCount ? this.colCount > this._table.internalProps.frozenColCount ? this._table.internalProps.frozenColCount : this.colCount : 0;
    }
    get frozenRowCount() {
        return this._table.internalProps.frozenRowCount ? this.rowCount >= this._table.internalProps.frozenRowCount ? this._table.internalProps.frozenRowCount : this.rowCount : 0;
    }
    get bottomFrozenRowCount() {
        return this._table.internalProps.bottomFrozenRowCount ? this.rowCount - this.headerLevelCount >= this._table.internalProps.bottomFrozenRowCount ? this._table.internalProps.bottomFrozenRowCount : this.rowCount - this.headerLevelCount : 0;
    }
    get rightFrozenColCount() {
        return this._table.internalProps.rightFrozenColCount ? this.colCount - this.frozenColCount >= this._table.internalProps.rightFrozenColCount ? this._table.internalProps.rightFrozenColCount : Math.max(0, this.colCount - this.frozenColCount) : 0;
    }
    get colCount() {
        return this.transpose ? this.headerLevelCount + this.recordsCount + this.leftRowSeriesNumberColumnCount + this.rightRowSeriesNumberColumnCount : this._columns.length + this.leftRowSeriesNumberColumnCount + this.rightRowSeriesNumberColumnCount;
    }
    get rowCount() {
        return this.transpose ? this._columns.length : this.headerLevelCount + this.recordsCount;
    }
    get bodyRowCount() {
        return this.transpose ? this._columns.length : this.rowCount - this.bottomFrozenRowCount - this.headerLevelCount;
    }
    get bodyColCount() {
        return this.transpose ? this.colCount - this.rightFrozenColCount - this.rowHeaderLevelCount : this._columns.length;
    }
    get recordsCount() {
        return this._recordsCount;
    }
    set recordsCount(recordsCount) {
        this._recordsCount = recordsCount;
    }
    get headerObjects() {
        return this._headerObjects;
    }
    get columnObjects() {
        return this._columns;
    }
    get headerObjectsIncludeHided() {
        return this._headerObjectsIncludeHided;
    }
    get columnWidths() {
        if (this.leftRowSeriesNumberColumnCount) {
            const widths = this.leftRowSeriesNumberColumn.map((item => ({
                width: item.width,
                minWidth: item.minWidth,
                maxWidth: item.maxWidth
            })));
            return widths.push(...this._columns.map((item => ({
                width: item.width,
                minWidth: item.minWidth,
                maxWidth: item.maxWidth
            })))), widths;
        }
        return this._columns.map((item => ({
            width: item.width,
            minWidth: item.minWidth,
            maxWidth: item.maxWidth
        })));
    }
    getColumnWidthDefined(col) {
        var _a;
        if (col >= 0) {
            if (col < this.leftRowSeriesNumberColumnCount) return this.leftRowSeriesNumberColumn[col];
            if (this.transpose) {
                let maxWidth, minWidth, width = 0;
                if (col >= this.rowHeaderLevelCount + this.leftRowSeriesNumberColumnCount) {
                    let isAuto;
                    return this.columnObjects.forEach(((obj, index) => {
                        "number" == typeof obj.width ? width = Math.max(obj.width, width) : "auto" === obj.width && (isAuto = !0), 
                        "number" == typeof obj.minWidth && (minWidth = Math.max(obj.minWidth, minWidth)), 
                        "number" == typeof obj.maxWidth && (maxWidth = Math.max(obj.maxWidth, maxWidth));
                    })), width = width > 0 ? width : isAuto ? "auto" : void 0, {
                        width: width,
                        minWidth: minWidth,
                        maxWidth: maxWidth
                    };
                }
                if (this.isRowHeader(col, 0)) {
                    const defaultWidth = Array.isArray(this._table.defaultHeaderColWidth) ? null !== (_a = this._table.defaultHeaderColWidth[col]) && void 0 !== _a ? _a : this._table.defaultColWidth : this._table.defaultHeaderColWidth;
                    return "auto" === defaultWidth ? {
                        width: "auto"
                    } : {
                        width: defaultWidth
                    };
                }
            }
            return this._columns[col - this.leftRowSeriesNumberColumnCount];
        }
    }
    getCellId(col, row) {
        var _a, _b, _c, _d;
        return this.transpose ? col >= this.headerLevelCount + this.leftRowSeriesNumberColumnCount ? null === (_a = this._columns[row]) || void 0 === _a ? void 0 : _a.id : this.isSeriesNumber(col, row) ? row + "_series_number" : null === (_b = this._headerCellIds[col - this.leftRowSeriesNumberColumnCount]) || void 0 === _b ? void 0 : _b[row] : this.isSeriesNumber(col, row) ? this.rowSeriesNumberColumn[col].id : this.headerLevelCount <= row ? null === (_c = this._columns[col - this.leftRowSeriesNumberColumnCount]) || void 0 === _c ? void 0 : _c.id : null === (_d = this._headerCellIds[row]) || void 0 === _d ? void 0 : _d[col - this.leftRowSeriesNumberColumnCount];
    }
    getHeader(col, row) {
        if (this.isSeriesNumberInHeader(col, row)) return this.getSeriesNumberHeader(col, row);
        const id = this.getCellId(col, row);
        return this._headerObjectMap[id];
    }
    getHeaderField(col, row) {
        var _a, _b, _c;
        if (this.isSeriesNumberInHeader(col, row)) return null === (_a = this.getSeriesNumberHeader(col, row)) || void 0 === _a ? void 0 : _a.field;
        if (this.isSeriesNumberInBody(col, row)) return null === (_b = this.getSeriesNumberBody(col, row)) || void 0 === _b ? void 0 : _b.field;
        const id = this.getCellId(col, row);
        return (null === (_c = this._headerObjectMap[id]) || void 0 === _c ? void 0 : _c.field) || (this.transpose ? this._columns[row] && this._columns[row].field : this._columns[col - this.leftRowSeriesNumberColumnCount] && this._columns[col - this.leftRowSeriesNumberColumnCount].field);
    }
    getHeaderCellAdressById(id) {
        for (let i = 0; i < this._headerCellIds.length; i++) {
            const row = this._headerCellIds[i];
            for (let j = 0; j < row.length; j++) if (row[j] === id) return this.transpose ? {
                col: i,
                row: j
            } : {
                col: j + this.leftRowSeriesNumberColumnCount,
                row: i
            };
        }
    }
    getHeaderCellAddressByField(field) {
        const hd = this.headerObjects.find((col => col && col.field === field));
        return hd && this.getHeaderCellAdressById(hd.id);
    }
    getBody(col, _row) {
        return this.isSeriesNumber(col, _row) ? this.getSeriesNumberBody(col, _row) : this.transpose ? this._columns[_row] : this._columns[col - this.leftRowSeriesNumberColumnCount];
    }
    getBodyLayoutRangeById(id) {
        var _a, _b;
        if (this.transpose) {
            for (let row = 0; row < (null !== (_a = this.rowCount) && void 0 !== _a ? _a : 0); row++) if (id === this._columns[row].id) return {
                start: {
                    col: 0,
                    row: row
                },
                end: {
                    col: 0,
                    row: row
                }
            };
        } else for (let col = this.leftRowSeriesNumberColumnCount; col < (null !== (_b = this.colCount) && void 0 !== _b ? _b : 0); col++) if (id === this._columns[col - this.leftRowSeriesNumberColumnCount].id) return {
            start: {
                col: col,
                row: 0
            },
            end: {
                col: col,
                row: 0
            }
        };
        return {
            start: {
                col: -1,
                row: -1
            },
            end: {
                col: -1,
                row: -1
            }
        };
    }
    getCellRange(col, row) {
        return getCellRange(col, row, this);
    }
    isCellRangeEqual(col, row, targetCol, targetRow) {
        const range1 = this.getCellRange(col, row), range2 = this.getCellRange(targetCol, targetRow);
        return range1.start.col === range2.start.col && range1.end.col === range2.end.col && range1.start.row === range2.start.row && range1.end.row === range2.end.row;
    }
    getRecordShowIndexByCell(col, row) {
        const skipRowCount = this.hasAggregationOnTopCount ? this.headerLevelCount + 1 : this.headerLevelCount;
        return this.transpose ? col < skipRowCount ? -1 : col - skipRowCount : row < skipRowCount ? -1 : row - skipRowCount;
    }
    getRecordStartRowByRecordIndex(index) {
        return (this.hasAggregationOnTopCount ? this.headerLevelCount + 1 : this.headerLevelCount) + index;
    }
    _addHeaders(row, column, roots, hideColumnsSubHeader) {
        const results = [], rowCells = this._newRow(row, hideColumnsSubHeader);
        return column.forEach((hd => {
            var _a, _b, _c, _d;
            const col = this._columns.length, id = this.seqId++, cell = {
                id: id,
                title: null !== (_a = hd.title) && void 0 !== _a ? _a : hd.caption,
                headerIcon: hd.headerIcon,
                field: hd.field,
                style: hd.headerStyle,
                headerType: null !== (_b = hd.headerType) && void 0 !== _b ? _b : "text",
                dropDownMenu: hd.dropDownMenu,
                define: hd,
                hierarchyState: hd.hierarchyState,
                columnWidthComputeMode: hd.columnWidthComputeMode
            };
            results[id] = cell;
            for (let r = row - 1; r >= 0; r--) this._headerCellIds[r] && (this._headerCellIds[r][col] = roots[r]);
            hideColumnsSubHeader ? this._headerCellIds[row - 1] && (rowCells[col] = this._headerCellIds[row - 1][col]) : rowCells[col] = id;
            const expand = !hd.hierarchyState || hd.hierarchyState === HierarchyState.expand;
            if (hd.columns && expand) {
                !hd.columns.every((c => c.hide)) && this._addHeaders(row + 1, hd.columns, [ ...roots, id ], hd.hideColumnsSubHeader || hideColumnsSubHeader).forEach((c => results.push(c)));
            } else {
                const colDef = {
                    id: this.seqId++,
                    field: hd.field,
                    fieldFormat: hd.fieldFormat,
                    width: hd.width,
                    minWidth: hd.minWidth,
                    maxWidth: hd.maxWidth,
                    icon: hd.icon,
                    cellType: null !== (_d = null !== (_c = hd.cellType) && void 0 !== _c ? _c : hd.columnType) && void 0 !== _d ? _d : "text",
                    chartModule: "chartModule" in hd ? hd.chartModule : null,
                    chartSpec: "chartSpec" in hd ? hd.chartSpec : null,
                    sparklineSpec: "sparklineSpec" in hd ? hd.sparklineSpec : DefaultSparklineSpec,
                    style: hd.style,
                    define: hd,
                    columnWidthComputeMode: hd.columnWidthComputeMode,
                    disableColumnResize: null == hd ? void 0 : hd.disableColumnResize,
                    aggregation: hd.aggregation,
                    isChildNode: row >= 1
                };
                if (this._columnsIncludeHided.push(colDef), !0 !== hd.hide) {
                    this._columns.push(colDef);
                    for (let r = row + 1; r < this._headerCellIds.length; r++) this._headerCellIds[r][col] = id;
                }
            }
        })), results;
    }
    _newRow(row, hideColumnsSubHeader = !1) {
        if (this._headerCellIds[row]) {
            const prev = this._headerCellIds[row - 1];
            if (prev.length > this._headerCellIds[row].length) for (let col = this._headerCellIds[row].length; col < prev.length; col++) this._headerCellIds[row][col] = prev[col];
            return this._headerCellIds[row];
        }
        if (hideColumnsSubHeader) return [];
        const newRow = this._headerCellIds[row] = [];
        if (!this._columns.length) return newRow;
        const prev = this._headerCellIds[row - 1];
        for (let col = 0; col < prev.length; col++) newRow[col] = prev[col];
        return newRow;
    }
    getCellHeaderPaths(col, row) {
        if (this.isSeriesNumber(col, row)) return;
        let colPath = [], rowPath = [];
        return this.transpose ? rowPath = [ {
            field: this._columns[row].field
        } ] : colPath = [ {
            field: this._columns[col - this.leftRowSeriesNumberColumnCount].field
        } ], {
            colHeaderPaths: colPath,
            rowHeaderPaths: rowPath,
            cellLocation: this.getCellLocation(col, row)
        };
    }
    getParentCellId(col, row) {
        if (0 !== row) {
            if (this.isColumnHeader(col, row)) return this.getCellId(col, row - 1);
            if (this.isRowHeader(col, row)) {
                if (this.isSeriesNumberInBody(col - 1, row)) return;
                return this.getCellId(col - 1, row);
            }
        }
    }
    canMoveHeaderPosition(source, target) {
        if (this.isSeriesNumberInHeader(target.col, target.row) || this.isSeriesNumberInHeader(source.col, source.row)) return !1;
        if (!this.transpose && this.isSeriesNumberInBody(target.col, target.row) && this.isSeriesNumberInBody(source.col, source.row)) {
            const sourceIndex = this.getRecordShowIndexByCell(0, source.row), targetIndex = this.getRecordShowIndexByCell(0, target.row);
            return this._table.dataSource.canChangeOrder(sourceIndex, targetIndex);
        }
        if (this.transpose && this.isSeriesNumberInBody(target.col, target.row) && this.isSeriesNumberInBody(source.col, source.row) && (this.getBody(source.col + this.leftRowSeriesNumberColumnCount, source.row).isChildNode && this.getBody(target.col + this.leftRowSeriesNumberColumnCount, target.row).isChildNode ? (source.col = source.col + this.leftRowSeriesNumberColumnCount + this.rowHeaderLevelCount - 1, 
        target.col = target.col + this.leftRowSeriesNumberColumnCount + this.rowHeaderLevelCount - 1) : (source.col = source.col + this.leftRowSeriesNumberColumnCount, 
        target.col = target.col + this.leftRowSeriesNumberColumnCount)), source.col < 0 || source.row < 0 || target.col < 0 || target.row < 0) return !1;
        if ("disabled" === this._table.internalProps.frozenColDragHeaderMode && this._table.isFrozenColumn(target.col)) return !1;
        const sourceCellRange = this.getCellRange(source.col, source.row);
        if (this.isColumnHeader(source.col, source.row)) {
            return this.getParentCellId(source.col, sourceCellRange.start.row) === this.getParentCellId(target.col, sourceCellRange.start.row);
        }
        if (this.isRowHeader(source.col, source.row)) {
            return this.getParentCellId(sourceCellRange.start.col, source.row) === this.getParentCellId(sourceCellRange.start.col, target.row);
        }
        return !1;
    }
    moveHeaderPosition(source, target) {
        var _a, _b;
        if ((!(null === (_a = this._table.options.dragOrder) || void 0 === _a ? void 0 : _a.validateDragOrderOnEnd) || (null === (_b = this._table.options.dragOrder) || void 0 === _b ? void 0 : _b.validateDragOrderOnEnd(source, target))) && this.canMoveHeaderPosition(source, target)) {
            let sourceCellRange = this.getCellRange(source.col, source.row);
            if (this.isColumnHeader(source.col, source.row)) {
                const sourceSize = sourceCellRange.end.col - sourceCellRange.start.col + 1;
                let targetIndex;
                const targetCellRange = this.getCellRange(target.col, sourceCellRange.start.row);
                if (targetIndex = target.col >= source.col ? targetCellRange.end.col - sourceSize + 1 : targetCellRange.start.col, 
                targetIndex === sourceCellRange.start.col) return null;
                for (let row = 0; row < this._headerCellIds.length; row++) {
                    const sourceIds = this._headerCellIds[row].splice(sourceCellRange.start.col - this.leftRowSeriesNumberColumnCount, sourceSize);
                    sourceIds.unshift(targetIndex - this.leftRowSeriesNumberColumnCount, 0), Array.prototype.splice.apply(this._headerCellIds[row], sourceIds);
                }
                const sourceColumns = this._columns.splice(sourceCellRange.start.col - this.leftRowSeriesNumberColumnCount, sourceSize);
                return sourceColumns.unshift(targetIndex - this.leftRowSeriesNumberColumnCount, 0), 
                Array.prototype.splice.apply(this._columns, sourceColumns), this.columnTree.movePosition(sourceCellRange.start.row, sourceCellRange.start.col - this.leftRowSeriesNumberColumnCount, targetIndex - this.leftRowSeriesNumberColumnCount), 
                this.columnTree.reset(this.columnTree.tree.children), this._cellRangeMap = new Map, 
                {
                    sourceIndex: sourceCellRange.start.col,
                    targetIndex: targetIndex,
                    sourceSize: sourceSize,
                    targetSize: targetCellRange.end.col - targetCellRange.start.col + 1,
                    moveType: "column"
                };
            }
            if (this.isRowHeader(source.col, source.row) || this.isSeriesNumberInBody(source.col, source.row) && this.transpose) {
                this.isSeriesNumberInBody(source.col, source.row) && (sourceCellRange = this.getCellRange(source.col + this.leftRowSeriesNumberColumnCount, source.row));
                const sourceSize = sourceCellRange.end.row - sourceCellRange.start.row + 1;
                let targetIndex;
                const targetCellRange = this.getCellRange(sourceCellRange.start.col, target.row);
                if (targetIndex = target.row >= source.row ? targetCellRange.end.row - sourceSize + 1 : targetCellRange.start.row, 
                targetIndex === sourceCellRange.start.row) return null;
                for (let row = 0; row < this._headerCellIds.length; row++) {
                    const sourceIds = this._headerCellIds[row].splice(sourceCellRange.start.row, sourceSize);
                    sourceIds.unshift(targetIndex, 0), Array.prototype.splice.apply(this._headerCellIds[row], sourceIds);
                }
                const sourceColumns = this._columns.splice(sourceCellRange.start.row, sourceSize);
                return sourceColumns.unshift(targetIndex, 0), Array.prototype.splice.apply(this._columns, sourceColumns), 
                this.columnTree.movePosition(sourceCellRange.start.col - this.leftRowSeriesNumberColumnCount, sourceCellRange.start.row, targetIndex + (target.row > source.row ? sourceCellRange.end.row - sourceCellRange.start.row : 0)), 
                this.columnTree.reset(this.columnTree.tree.children), this._cellRangeMap = new Map, 
                {
                    sourceIndex: sourceCellRange.start.row,
                    targetIndex: targetIndex,
                    sourceSize: sourceSize,
                    targetSize: targetCellRange.end.row - targetCellRange.start.row + 1,
                    moveType: "row"
                };
            }
            if (this.isSeriesNumberInBody(source.col, source.row)) return {
                sourceIndex: source.row,
                targetIndex: target.row,
                sourceSize: 1,
                targetSize: 1,
                moveType: "row"
            };
        }
        return null;
    }
    toggleHierarchyState(diffDataIndices) {
        return {
            addCellPositions: diffDataIndices.add.map((index => ({
                col: 0,
                row: this._table.columnHeaderLevelCount + index
            }))),
            removeCellPositions: diffDataIndices.remove.map((index => ({
                col: 0,
                row: this._table.columnHeaderLevelCount + index
            })))
        };
    }
    setChartInstance(_col, _row, chartInstance) {
        const columnObj = this.transpose ? this._columns[_row] : this._columns[_col - this.leftRowSeriesNumberColumnCount];
        "function" != typeof columnObj.chartSpec && (columnObj.chartInstance = chartInstance);
    }
    getChartInstance(_col, _row) {
        return (this.transpose ? this._columns[_row] : this._columns[_col - this.leftRowSeriesNumberColumnCount]).chartInstance;
    }
    checkHasChart() {
        return checkHasChart(this);
    }
    getAxisConfigInPivotChart(col, row) {}
    isEmpty(col, row) {
        return !1;
    }
    isAxisCell(col, row) {
        return !1;
    }
    getChartAxes(col, row) {
        return [];
    }
    isShareChartSpec(col, row) {
        const body = this.getBody(col, row);
        return "function" != typeof (null == body ? void 0 : body.chartSpec);
    }
    isNoChartDataRenderNothing(col, row) {
        const body = this.getBody(col, row);
        return (null == body ? void 0 : body.define).noDataRenderNothing;
    }
    getChartSpec(col, row) {
        return this.getRawChartSpec(col, row);
    }
    getRawChartSpec(col, row) {
        const body = this.getBody(col, row), chartSpec = null == body ? void 0 : body.chartSpec;
        if ("function" == typeof chartSpec) {
            return chartSpec({
                col: col,
                row: row,
                dataValue: this._table.getCellOriginValue(col, row) || "",
                value: this._table.getCellValue(col, row) || "",
                rect: this._table.getCellRangeRelativeRect(this._table.getCellRange(col, row)),
                table: this._table
            });
        }
        return chartSpec;
    }
    getChartDataId(col, row) {
        return getChartDataId(col, row, this);
    }
    release() {
        const activeChartInstance = this._table._getActiveChartInstance();
        null == activeChartInstance || activeChartInstance.release(), this.columnObjects.forEach((indicatorObject => {
            var _a;
            null === (_a = indicatorObject.chartInstance) || void 0 === _a || _a.release();
        }));
    }
    clearCellRangeMap() {
        this._cellRangeMap.clear();
    }
    updateColumnTitle(col, row, title) {
        const define = this._table.internalProps.layoutMap.getHeader(col, row);
        define.title = title, define.define.title = title;
    }
    getColumnByField(field) {
        var _a;
        return null === (_a = this.columnObjects) || void 0 === _a ? void 0 : _a.reduce(((pre, cur, index) => (cur.field === field && pre.push({
            col: index,
            columnDefine: cur
        }), pre)), []);
    }
    getColumnByKey(key) {
        var _a;
        let col;
        return {
            columnDefine: null === (_a = this.columnObjects) || void 0 === _a ? void 0 : _a.find(((columnData, index) => {
                var _a;
                return (null === (_a = columnData.define) || void 0 === _a ? void 0 : _a.key) === key && (col = index + this.leftRowSeriesNumberColumnCount, 
                !0);
            })),
            col: col
        };
    }
    getColumnDefine(col, row) {
        if (col >= 0) return col < this.leftRowSeriesNumberColumnCount ? this.leftRowSeriesNumberColumn[col].define : this.transpose ? this._columns[row].define : this._columns[col - this.leftRowSeriesNumberColumnCount].define;
    }
}
//# sourceMappingURL=simple-header-layout.js.map