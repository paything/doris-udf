import { cloneDeep, isValid } from "@visactor/vutils";

import { NumberMap } from "../tools/NumberMap";

import { IndicatorDimensionKeyPlaceholder } from "../tools/global";

import { HierarchyState } from "../ts-types";

export class DimensionTree {
    constructor(tree, sharedVar, hierarchyType = "grid", rowExpandLevel = void 0) {
        this.hasHideNode = !1, this.sizeIncludeParent = !1, this.tree = {
            id: 0,
            dimensionKey: "",
            value: "",
            children: [],
            level: -1,
            afterSpanLevel: -1,
            levelSpan: 1,
            startIndex: 0,
            size: 0,
            startInTotal: 0,
            hierarchyState: void 0
        }, this.totalLevel = 0, this.expandedMaxLevel = 0, this.dimensionKeys = new NumberMap, 
        this.dimensionKeysIncludeVirtual = new NumberMap, this.cache = new Map, this.sizeIncludeParent = null != rowExpandLevel, 
        this.setExpandLevel = rowExpandLevel, this.hierarchyType = hierarchyType, this.sharedVar = sharedVar, 
        this.reset(tree);
    }
    reset(tree) {
        this.totalLevel = 0, this.expandedMaxLevel = 0, this.hasHideNode = !1, this.cache.clear(), 
        this.dimensionKeys = new NumberMap, this.dimensionKeysIncludeVirtual = new NumberMap, 
        this.tree.children = tree, this.setTreeNode(this.tree, 0, this.tree);
    }
    setTreeNode(node, startIndex, parent) {
        var _a, _b, _c, _d;
        node.startIndex = startIndex, node.startInTotal = (null !== (_a = parent.startInTotal) && void 0 !== _a ? _a : 0) + node.startIndex, 
        node.hide && (this.hasHideNode = !0), (null !== (_b = node.dimensionKey) && void 0 !== _b ? _b : node.indicatorKey) && (node.virtual || this.dimensionKeys.contain(node.indicatorKey ? IndicatorDimensionKeyPlaceholder : node.dimensionKey) || this.dimensionKeys.put(node.level, node.indicatorKey ? IndicatorDimensionKeyPlaceholder : node.dimensionKey), 
        this.dimensionKeysIncludeVirtual.contain(node.indicatorKey ? IndicatorDimensionKeyPlaceholder : node.dimensionKey) || this.dimensionKeysIncludeVirtual.put(node.level, node.indicatorKey ? IndicatorDimensionKeyPlaceholder : node.dimensionKey), 
        node.id || (node.id = ++this.sharedVar.seqId));
        let size = node.dimensionKey && this.sizeIncludeParent ? 1 : 0;
        const children = node.children || node.columns;
        return "grid" === this.hierarchyType || null === this.hierarchyType ? (null == children ? void 0 : children.length) >= 1 ? children.forEach((n => {
            var _a, _b, _c;
            n.level = (null !== (_a = node.level) && void 0 !== _a ? _a : 0) + 1, "grid" === this.hierarchyType && (n.afterSpanLevel = (null !== (_b = node.afterSpanLevel) && void 0 !== _b ? _b : 0) + (null !== (_c = node.levelSpan) && void 0 !== _c ? _c : 1)), 
            this.totalLevel = Math.max(this.totalLevel, n.level + 1), size += this.setTreeNode(n, size, node);
        })) : size = -1 === node.level ? 0 : 1 : node.hierarchyState === HierarchyState.expand && (null == children ? void 0 : children.length) >= 1 ? children.forEach((n => {
            var _a;
            n.level = (null !== (_a = node.level) && void 0 !== _a ? _a : 0) + 1, this.totalLevel = Math.max(this.totalLevel, n.level + 1), 
            this.expandedMaxLevel = Math.max(this.expandedMaxLevel, n.level + 1), size += this.setTreeNode(n, size, node);
        })) : node.hierarchyState === HierarchyState.collapse && (null == children ? void 0 : children.length) >= 1 ? children.forEach((n => {
            var _a;
            n.level = (null !== (_a = node.level) && void 0 !== _a ? _a : 0) + 1, this.totalLevel = Math.max(this.totalLevel, n.level + 1), 
            this.setTreeNode(n, size, node);
        })) : !node.hierarchyState && node.level + 1 < this.setExpandLevel && ((null == children ? void 0 : children.length) >= 1 || !0 === children) ? ((null === (_c = children[0]) || void 0 === _c ? void 0 : _c.indicatorKey) && "grid-tree" === this.hierarchyType || (node.hierarchyState = HierarchyState.expand), 
        (null == children ? void 0 : children.length) >= 1 && children.forEach((n => {
            var _a;
            n.level = (null !== (_a = node.level) && void 0 !== _a ? _a : 0) + 1, this.totalLevel = Math.max(this.totalLevel, n.level + 1), 
            this.expandedMaxLevel = Math.max(this.expandedMaxLevel, n.level + 1), size += this.setTreeNode(n, size, node);
        }))) : (null == children ? void 0 : children.length) >= 1 || !0 === children ? ((null === (_d = children[0]) || void 0 === _d ? void 0 : _d.indicatorKey) && "grid-tree" === this.hierarchyType || (node.hierarchyState = HierarchyState.collapse), 
        (null == children ? void 0 : children.length) >= 1 && children.forEach((n => {
            var _a;
            n.level = (null !== (_a = node.level) && void 0 !== _a ? _a : 0) + 1, this.totalLevel = Math.max(this.totalLevel, n.level + 1), 
            this.setTreeNode(n, size, node);
        }))) : (node.hierarchyState = HierarchyState.none, size = -1 === node.level ? 0 : 1), 
        node.size = size, size;
    }
    getTreePath(index, maxDeep = 30) {
        const path = [];
        return this.searchPath(index, this.tree, path, maxDeep), path.shift(), path;
    }
    findNodeById(nodes, id) {
        return nodes.find((node => node.id === id));
    }
    searchPath(index, node, path, maxDeep) {
        if (!node) return;
        if (index < node.startIndex || index >= node.startIndex + node.size) return;
        if (path.push(node), !node.children || 0 === node.children.length || node.level >= maxDeep) return;
        const cIndex = index - node.startIndex;
        if (this.cache.has(node.level + 1)) {
            const cacheNode = this.cache.get(node.level + 1);
            if (cIndex >= cacheNode.startIndex && cIndex < cacheNode.startIndex + cacheNode.size) return void this.searchPath(cIndex, cacheNode, path, maxDeep);
        }
        let left = 0, right = node.children.length - 1;
        for (;left <= right; ) {
            const middle = Math.floor((left + right) / 2), element = node.children[middle];
            if (cIndex >= element.startIndex && cIndex < element.startIndex + element.size) {
                this.cache.set(element.level, element);
                const deleteLevels = [];
                this.cache.forEach(((node, key) => {
                    key > element.level && deleteLevels.push(key);
                })), deleteLevels.forEach((key => {
                    this.cache.delete(key);
                })), this.searchPath(cIndex, element, path, maxDeep);
                break;
            }
            cIndex < element.startIndex ? right = middle - 1 : left = middle + 1;
        }
    }
    movePosition(level, sourceIndex, targetIndex) {
        let parNode, sourceSubIndex, targetSubIndex;
        const findTargetNode = (node, subIndex) => {
            if (void 0 !== sourceSubIndex && void 0 !== targetSubIndex) return;
            node.level === level && (node.startInTotal === sourceIndex && (sourceSubIndex = subIndex), 
            node.startInTotal <= targetIndex && targetIndex <= node.startInTotal + node.size - 1 && (targetSubIndex = subIndex));
            const children = node.children || node.columns;
            if (children && node.level < level) {
                parNode = node;
                for (let i = 0; i < children.length; i++) (sourceIndex >= children[i].startInTotal && sourceIndex <= children[i].startInTotal + children[i].size || targetIndex >= children[i].startInTotal && targetIndex <= children[i].startInTotal + children[i].size) && findTargetNode(children[i], i);
            }
        };
        findTargetNode(this.tree, 0);
        const children = parNode.children || parNode.columns, sourceColumns = children.splice(sourceSubIndex, 1);
        sourceColumns.unshift(targetSubIndex, 0), Array.prototype.splice.apply(children, sourceColumns);
    }
    getCopiedTree() {
        const children = cloneDeep(this.tree.children);
        return clearNode(children), children;
    }
}

export function generateLayoutTree(tree, children) {
    null == children || children.forEach((node => {
        var _a, _b;
        const diemnsonNode = {
            dimensionKey: node.dimensionKey,
            indicatorKey: node.indicatorKey,
            value: node.value,
            hierarchyState: node.hierarchyState,
            children: void 0,
            virtual: null !== (_a = node.virtual) && void 0 !== _a && _a,
            levelSpan: null !== (_b = node.levelSpan) && void 0 !== _b ? _b : 1
        };
        tree.push(diemnsonNode), node.children && (diemnsonNode.children = [], generateLayoutTree(diemnsonNode.children, node.children));
    }));
}

export function countLayoutTree(children, countParentNode) {
    let count = 0;
    return null == children || children.forEach((node => {
        countParentNode ? count++ : node.children && 0 !== node.children.length || count++, 
        node.children && (count += countLayoutTree(node.children, countParentNode));
    })), count;
}

export function dealHeader(hd, _headerCellIds, results, roots, row, layoutMap) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z;
    const id = hd.id, dimensionInfo = null !== (_b = null === (_a = layoutMap.rowsDefine) || void 0 === _a ? void 0 : _a.find((dimension => "string" != typeof dimension && dimension.dimensionKey === hd.dimensionKey))) && void 0 !== _b ? _b : null === (_c = layoutMap.columnsDefine) || void 0 === _c ? void 0 : _c.find((dimension => "string" != typeof dimension && dimension.dimensionKey === hd.dimensionKey)), indicatorInfo = null === (_d = layoutMap.indicatorsDefine) || void 0 === _d ? void 0 : _d.find((indicator => "string" != typeof indicator && (hd.indicatorKey ? indicator.indicatorKey === hd.indicatorKey : indicator.title === hd.value && !hd.dimensionKey))), cell = {
        id: id,
        title: null !== (_e = hd.value) && void 0 !== _e ? _e : null == indicatorInfo ? void 0 : indicatorInfo.title,
        field: hd.dimensionKey,
        style: "function" == typeof (null === (_f = null != indicatorInfo ? indicatorInfo : dimensionInfo) || void 0 === _f ? void 0 : _f.headerStyle) ? null === (_g = null != indicatorInfo ? indicatorInfo : dimensionInfo) || void 0 === _g ? void 0 : _g.headerStyle : Object.assign({}, null === (_h = null != indicatorInfo ? indicatorInfo : dimensionInfo) || void 0 === _h ? void 0 : _h.headerStyle),
        headerType: null !== (_k = null !== (_j = null == indicatorInfo ? void 0 : indicatorInfo.headerType) && void 0 !== _j ? _j : null == dimensionInfo ? void 0 : dimensionInfo.headerType) && void 0 !== _k ? _k : "text",
        headerIcon: null !== (_l = null == indicatorInfo ? void 0 : indicatorInfo.headerIcon) && void 0 !== _l ? _l : null == dimensionInfo ? void 0 : dimensionInfo.headerIcon,
        define: Object.assign({}, hd, null != indicatorInfo ? indicatorInfo : Object.assign({}, dimensionInfo, {
            sort: void 0
        })),
        fieldFormat: null !== (_m = null == indicatorInfo ? void 0 : indicatorInfo.headerFormat) && void 0 !== _m ? _m : null == dimensionInfo ? void 0 : dimensionInfo.headerFormat,
        dropDownMenu: null !== (_o = null == indicatorInfo ? void 0 : indicatorInfo.dropDownMenu) && void 0 !== _o ? _o : null == dimensionInfo ? void 0 : dimensionInfo.dropDownMenu,
        pivotInfo: {
            value: hd.value,
            dimensionKey: hd.dimensionKey,
            isPivotCorner: !1
        },
        width: null == dimensionInfo ? void 0 : dimensionInfo.width,
        minWidth: null == dimensionInfo ? void 0 : dimensionInfo.minWidth,
        maxWidth: null == dimensionInfo ? void 0 : dimensionInfo.maxWidth,
        showSort: null !== (_p = null == indicatorInfo ? void 0 : indicatorInfo.showSort) && void 0 !== _p ? _p : null == dimensionInfo ? void 0 : dimensionInfo.showSort,
        sort: null == indicatorInfo ? void 0 : indicatorInfo.sort,
        description: null == dimensionInfo ? void 0 : dimensionInfo.description
    };
    indicatorInfo ? (indicatorInfo.customRender && (hd.customRender = indicatorInfo.customRender), 
    isValid(null === (_q = layoutMap._indicators) || void 0 === _q ? void 0 : _q.find((indicator => indicator.indicatorKey === indicatorInfo.indicatorKey))) || null === (_r = layoutMap._indicators) || void 0 === _r || _r.push({
        id: ++layoutMap.sharedVar.seqId,
        indicatorKey: indicatorInfo.indicatorKey,
        field: indicatorInfo.indicatorKey,
        fieldFormat: null == indicatorInfo ? void 0 : indicatorInfo.format,
        cellType: null !== (_t = null !== (_s = null == indicatorInfo ? void 0 : indicatorInfo.cellType) && void 0 !== _s ? _s : null == indicatorInfo ? void 0 : indicatorInfo.columnType) && void 0 !== _t ? _t : "text",
        chartModule: "chartModule" in indicatorInfo ? indicatorInfo.chartModule : null,
        chartSpec: "chartSpec" in indicatorInfo ? indicatorInfo.chartSpec : null,
        noDataRenderNothing: "noDataRenderNothing" in indicatorInfo && indicatorInfo.noDataRenderNothing,
        sparklineSpec: "sparklineSpec" in indicatorInfo ? indicatorInfo.sparklineSpec : null,
        style: null == indicatorInfo ? void 0 : indicatorInfo.style,
        icon: null == indicatorInfo ? void 0 : indicatorInfo.icon,
        define: Object.assign({}, hd, indicatorInfo, {
            dragHeader: null == dimensionInfo ? void 0 : dimensionInfo.dragHeader
        }),
        width: null == indicatorInfo ? void 0 : indicatorInfo.width,
        minWidth: null == indicatorInfo ? void 0 : indicatorInfo.minWidth,
        maxWidth: null == indicatorInfo ? void 0 : indicatorInfo.maxWidth,
        disableColumnResize: null == indicatorInfo ? void 0 : indicatorInfo.disableColumnResize
    })) : hd.indicatorKey && (isValid(null === (_u = layoutMap._indicators) || void 0 === _u ? void 0 : _u.find((indicator => indicator.indicatorKey === hd.indicatorKey))) || null === (_v = layoutMap._indicators) || void 0 === _v || _v.push({
        id: ++layoutMap.sharedVar.seqId,
        indicatorKey: hd.indicatorKey,
        field: hd.indicatorKey,
        cellType: "text",
        define: Object.assign({}, hd)
    })), results[id] = cell, layoutMap._headerObjects[id] = cell;
    for (let r = row - 1; r >= 0; r--) _headerCellIds[r][layoutMap.colIndex] = roots[r];
    if (_headerCellIds[row][layoutMap.colIndex] = id, hd.levelSpan > 1) for (let i = 1; i < hd.levelSpan; i++) {
        if (!_headerCellIds[row + i]) {
            _headerCellIds[row + i] = [];
            for (let col = 0; col < layoutMap.colIndex; col++) _headerCellIds[row + i][col] = _headerCellIds[row][col];
        }
        _headerCellIds[row + i][layoutMap.colIndex] = id;
    }
    if ((null === (_w = hd.children) || void 0 === _w ? void 0 : _w.length) >= 1) layoutMap._addHeaders(_headerCellIds, row + (null !== (_x = hd.levelSpan) && void 0 !== _x ? _x : 1), null !== (_y = hd.children) && void 0 !== _y ? _y : [], [ ...roots, ...Array(null !== (_z = hd.levelSpan) && void 0 !== _z ? _z : 1).fill(id) ], results); else {
        for (let r = row + 1; r < _headerCellIds.length; r++) _headerCellIds[r][layoutMap.colIndex] = id;
        layoutMap.colIndex++;
    }
}

export function dealHeaderForGridTreeMode(hd, _headerCellIds, results, roots, row, totalLevel, expandedMaxLevel, show, dimensions, isRowTree, indicatorsAsCol, layoutMap) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14;
    const id = hd.id, dimensionInfo = null !== (_b = null === (_a = layoutMap.rowsDefine) || void 0 === _a ? void 0 : _a.find((dimension => "string" != typeof dimension && dimension.dimensionKey === hd.dimensionKey))) && void 0 !== _b ? _b : null === (_c = layoutMap.columnsDefine) || void 0 === _c ? void 0 : _c.find((dimension => "string" != typeof dimension && dimension.dimensionKey === hd.dimensionKey)), indicatorInfo = null === (_d = layoutMap.indicatorsDefine) || void 0 === _d ? void 0 : _d.find((indicator => "string" != typeof indicator && (hd.indicatorKey ? indicator.indicatorKey === hd.indicatorKey : indicator.title === hd.value && !hd.dimensionKey))), cell = {
        id: id,
        title: null !== (_e = hd.value) && void 0 !== _e ? _e : null == indicatorInfo ? void 0 : indicatorInfo.title,
        field: hd.dimensionKey,
        style: "function" == typeof (null === (_f = null != indicatorInfo ? indicatorInfo : dimensionInfo) || void 0 === _f ? void 0 : _f.headerStyle) ? null === (_g = null != indicatorInfo ? indicatorInfo : dimensionInfo) || void 0 === _g ? void 0 : _g.headerStyle : Object.assign({}, null === (_h = null != indicatorInfo ? indicatorInfo : dimensionInfo) || void 0 === _h ? void 0 : _h.headerStyle),
        headerType: null !== (_k = null !== (_j = null == indicatorInfo ? void 0 : indicatorInfo.headerType) && void 0 !== _j ? _j : null == dimensionInfo ? void 0 : dimensionInfo.headerType) && void 0 !== _k ? _k : "text",
        headerIcon: null !== (_l = null == indicatorInfo ? void 0 : indicatorInfo.headerIcon) && void 0 !== _l ? _l : null == dimensionInfo ? void 0 : dimensionInfo.headerIcon,
        define: Object.assign(hd, {
            linkJump: null === (_m = null != indicatorInfo ? indicatorInfo : dimensionInfo) || void 0 === _m ? void 0 : _m.linkJump,
            linkDetect: null === (_o = null != indicatorInfo ? indicatorInfo : dimensionInfo) || void 0 === _o ? void 0 : _o.linkDetect,
            templateLink: null === (_p = null != indicatorInfo ? indicatorInfo : dimensionInfo) || void 0 === _p ? void 0 : _p.templateLink,
            keepAspectRatio: null !== (_r = null === (_q = null != indicatorInfo ? indicatorInfo : dimensionInfo) || void 0 === _q ? void 0 : _q.keepAspectRatio) && void 0 !== _r && _r,
            imageAutoSizing: null === (_s = null != indicatorInfo ? indicatorInfo : dimensionInfo) || void 0 === _s ? void 0 : _s.imageAutoSizing,
            headerCustomRender: null === (_t = null != indicatorInfo ? indicatorInfo : dimensionInfo) || void 0 === _t ? void 0 : _t.headerCustomRender,
            headerCustomLayout: null === (_u = null != indicatorInfo ? indicatorInfo : dimensionInfo) || void 0 === _u ? void 0 : _u.headerCustomLayout,
            dragHeader: null == dimensionInfo ? void 0 : dimensionInfo.dragHeader,
            disableHeaderHover: !!(null === (_v = null != indicatorInfo ? indicatorInfo : dimensionInfo) || void 0 === _v ? void 0 : _v.disableHeaderHover),
            disableHeaderSelect: !!(null === (_w = null != indicatorInfo ? indicatorInfo : dimensionInfo) || void 0 === _w ? void 0 : _w.disableHeaderSelect),
            showSort: null !== (_x = null == indicatorInfo ? void 0 : indicatorInfo.showSort) && void 0 !== _x ? _x : null == dimensionInfo ? void 0 : dimensionInfo.showSort,
            hide: null == indicatorInfo ? void 0 : indicatorInfo.hide
        }),
        fieldFormat: null !== (_y = null == indicatorInfo ? void 0 : indicatorInfo.headerFormat) && void 0 !== _y ? _y : null == dimensionInfo ? void 0 : dimensionInfo.headerFormat,
        dropDownMenu: null !== (_z = null == indicatorInfo ? void 0 : indicatorInfo.dropDownMenu) && void 0 !== _z ? _z : null == dimensionInfo ? void 0 : dimensionInfo.dropDownMenu,
        pivotInfo: {
            value: hd.value,
            dimensionKey: hd.dimensionKey,
            isPivotCorner: !1
        },
        hierarchyLevel: hd.level,
        dimensionTotalLevel: totalLevel,
        hierarchyState: hd.hierarchyState,
        width: null == dimensionInfo ? void 0 : dimensionInfo.width,
        minWidth: null == dimensionInfo ? void 0 : dimensionInfo.minWidth,
        maxWidth: null == dimensionInfo ? void 0 : dimensionInfo.maxWidth,
        showSort: null !== (_0 = null == indicatorInfo ? void 0 : indicatorInfo.showSort) && void 0 !== _0 ? _0 : null == dimensionInfo ? void 0 : dimensionInfo.showSort,
        sort: null == indicatorInfo ? void 0 : indicatorInfo.sort,
        description: null == dimensionInfo ? void 0 : dimensionInfo.description,
        parentCellId: roots[roots.length - 1]
    };
    indicatorInfo ? (indicatorInfo.customRender && (hd.customRender = indicatorInfo.customRender), 
    isValid(null === (_1 = layoutMap._indicators) || void 0 === _1 ? void 0 : _1.find((indicator => indicator.indicatorKey === indicatorInfo.indicatorKey))) || null === (_2 = layoutMap._indicators) || void 0 === _2 || _2.push({
        id: ++layoutMap.sharedVar.seqId,
        indicatorKey: indicatorInfo.indicatorKey,
        field: indicatorInfo.indicatorKey,
        fieldFormat: null == indicatorInfo ? void 0 : indicatorInfo.format,
        cellType: null !== (_4 = null !== (_3 = null == indicatorInfo ? void 0 : indicatorInfo.cellType) && void 0 !== _3 ? _3 : null == indicatorInfo ? void 0 : indicatorInfo.columnType) && void 0 !== _4 ? _4 : "text",
        chartModule: "chartModule" in indicatorInfo ? indicatorInfo.chartModule : null,
        chartSpec: "chartSpec" in indicatorInfo ? indicatorInfo.chartSpec : null,
        noDataRenderNothing: "noDataRenderNothing" in indicatorInfo && indicatorInfo.noDataRenderNothing,
        sparklineSpec: "sparklineSpec" in indicatorInfo ? indicatorInfo.sparklineSpec : null,
        style: null == indicatorInfo ? void 0 : indicatorInfo.style,
        icon: null == indicatorInfo ? void 0 : indicatorInfo.icon,
        define: Object.assign({}, hd, indicatorInfo, {
            dragHeader: null == dimensionInfo ? void 0 : dimensionInfo.dragHeader
        }),
        width: null == indicatorInfo ? void 0 : indicatorInfo.width,
        minWidth: null == indicatorInfo ? void 0 : indicatorInfo.minWidth,
        maxWidth: null == indicatorInfo ? void 0 : indicatorInfo.maxWidth,
        disableColumnResize: null == indicatorInfo ? void 0 : indicatorInfo.disableColumnResize
    })) : hd.indicatorKey && (isValid(null === (_5 = layoutMap._indicators) || void 0 === _5 ? void 0 : _5.find((indicator => indicator.indicatorKey === hd.indicatorKey))) || null === (_6 = layoutMap._indicators) || void 0 === _6 || _6.push({
        id: ++layoutMap.sharedVar.seqId,
        indicatorKey: hd.indicatorKey,
        field: hd.indicatorKey,
        cellType: "text",
        define: Object.assign({}, hd)
    })), results[id] = cell, layoutMap._headerObjects[id] = cell;
    for (let r = row - 1; r >= 0; r--) _headerCellIds[r][layoutMap.colIndex] = roots[r];
    _headerCellIds[row][layoutMap.colIndex] = id;
    const span = Math.min((isRowTree ? indicatorsAsCol : !indicatorsAsCol) ? expandedMaxLevel : expandedMaxLevel - 1, null !== (_7 = hd.levelSpan) && void 0 !== _7 ? _7 : 1e3);
    if (span > 0) for (let r = row + 1; r < span; r++) {
        if (!_headerCellIds[r]) {
            _headerCellIds[r] = [];
            for (let col = 0; col < layoutMap.colIndex; col++) _headerCellIds[r][col] = _headerCellIds[row][col];
        }
        _headerCellIds[r][layoutMap.colIndex] = id;
    }
    if ((null === (_8 = (hd.hierarchyState === HierarchyState.expand && hd).children) || void 0 === _8 ? void 0 : _8.length) >= 1) layoutMap._addHeadersForGridTreeMode(_headerCellIds, row + (null !== (_9 = hd.levelSpan) && void 0 !== _9 ? _9 : 1), null !== (_10 = hd.children) && void 0 !== _10 ? _10 : [], [ ...roots, ...Array(null !== (_11 = hd.levelSpan) && void 0 !== _11 ? _11 : 1).fill(id) ], totalLevel, expandedMaxLevel, show && hd.hierarchyState === HierarchyState.expand, dimensions, results, isRowTree); else {
        const needSupplementLength = (isRowTree ? indicatorsAsCol : !indicatorsAsCol) ? expandedMaxLevel : expandedMaxLevel - 1;
        for (let r = row + 1; r < needSupplementLength; r++) _headerCellIds[r] || (_headerCellIds[r] = []), 
        _headerCellIds[r][layoutMap.colIndex] = id;
        if (row <= needSupplementLength - 1 && (isRowTree && !1 === indicatorsAsCol || !isRowTree && !0 === indicatorsAsCol)) {
            let lastIndidcatorChildren = hd;
            const levelSpan = needSupplementLength - row;
            for (;lastIndidcatorChildren && !(null === (_12 = lastIndidcatorChildren.children) || void 0 === _12 ? void 0 : _12[0].indicatorKey); ) lastIndidcatorChildren = lastIndidcatorChildren.children[0];
            layoutMap._addHeadersForGridTreeMode(_headerCellIds, expandedMaxLevel - 1, null !== (_13 = lastIndidcatorChildren.children) && void 0 !== _13 ? _13 : [], [ ...roots, ...Array(Math.max(levelSpan, null !== (_14 = hd.levelSpan) && void 0 !== _14 ? _14 : 1)).fill(id) ], totalLevel, expandedMaxLevel, !0, dimensions, results, isRowTree);
        } else layoutMap.colIndex++;
    }
}

export function dealHeaderForTreeMode(hd, _headerCellIds, results, roots, row, totalLevel, show, dimensions, layoutMap) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4;
    const id = hd.id, dimensionInfo = dimensions.find((dimension => "string" != typeof dimension && dimension.dimensionKey === hd.dimensionKey)), indicatorInfo = null === (_a = layoutMap.indicatorsDefine) || void 0 === _a ? void 0 : _a.find((indicator => "string" != typeof indicator && (hd.indicatorKey ? indicator.indicatorKey === hd.indicatorKey : indicator.title === hd.value))), cell = {
        id: id,
        title: null !== (_b = hd.value) && void 0 !== _b ? _b : indicatorInfo.title,
        field: hd.dimensionKey,
        style: hd.level + 1 === totalLevel || "function" == typeof (null === (_c = null != indicatorInfo ? indicatorInfo : dimensionInfo) || void 0 === _c ? void 0 : _c.headerStyle) ? null === (_d = null != indicatorInfo ? indicatorInfo : dimensionInfo) || void 0 === _d ? void 0 : _d.headerStyle : Object.assign({}, null === (_e = null != indicatorInfo ? indicatorInfo : dimensionInfo) || void 0 === _e ? void 0 : _e.headerStyle, {
            textAlign: "left"
        }),
        headerType: null !== (_g = null !== (_f = null == indicatorInfo ? void 0 : indicatorInfo.headerType) && void 0 !== _f ? _f : null == dimensionInfo ? void 0 : dimensionInfo.headerType) && void 0 !== _g ? _g : "text",
        headerIcon: null !== (_h = null == indicatorInfo ? void 0 : indicatorInfo.headerIcon) && void 0 !== _h ? _h : null == dimensionInfo ? void 0 : dimensionInfo.headerIcon,
        define: Object.assign(hd, {
            linkJump: null === (_j = null != indicatorInfo ? indicatorInfo : dimensionInfo) || void 0 === _j ? void 0 : _j.linkJump,
            linkDetect: null === (_k = null != indicatorInfo ? indicatorInfo : dimensionInfo) || void 0 === _k ? void 0 : _k.linkDetect,
            templateLink: null === (_l = null != indicatorInfo ? indicatorInfo : dimensionInfo) || void 0 === _l ? void 0 : _l.templateLink,
            keepAspectRatio: null !== (_o = null === (_m = null != indicatorInfo ? indicatorInfo : dimensionInfo) || void 0 === _m ? void 0 : _m.keepAspectRatio) && void 0 !== _o && _o,
            imageAutoSizing: null === (_p = null != indicatorInfo ? indicatorInfo : dimensionInfo) || void 0 === _p ? void 0 : _p.imageAutoSizing,
            headerCustomRender: null === (_q = null != indicatorInfo ? indicatorInfo : dimensionInfo) || void 0 === _q ? void 0 : _q.headerCustomRender,
            headerCustomLayout: null === (_r = null != indicatorInfo ? indicatorInfo : dimensionInfo) || void 0 === _r ? void 0 : _r.headerCustomLayout,
            dragHeader: null == dimensionInfo ? void 0 : dimensionInfo.dragHeader,
            disableHeaderHover: !!(null === (_s = null != indicatorInfo ? indicatorInfo : dimensionInfo) || void 0 === _s ? void 0 : _s.disableHeaderHover),
            disableHeaderSelect: !!(null === (_t = null != indicatorInfo ? indicatorInfo : dimensionInfo) || void 0 === _t ? void 0 : _t.disableHeaderSelect),
            showSort: null !== (_u = null == indicatorInfo ? void 0 : indicatorInfo.showSort) && void 0 !== _u ? _u : null == dimensionInfo ? void 0 : dimensionInfo.showSort,
            hide: null == indicatorInfo ? void 0 : indicatorInfo.hide
        }),
        fieldFormat: null !== (_v = null == indicatorInfo ? void 0 : indicatorInfo.headerFormat) && void 0 !== _v ? _v : null == dimensionInfo ? void 0 : dimensionInfo.headerFormat,
        dropDownMenu: null !== (_w = null == indicatorInfo ? void 0 : indicatorInfo.dropDownMenu) && void 0 !== _w ? _w : null == dimensionInfo ? void 0 : dimensionInfo.dropDownMenu,
        pivotInfo: {
            value: hd.value,
            dimensionKey: hd.dimensionKey,
            isPivotCorner: !1
        },
        hierarchyLevel: hd.level,
        dimensionTotalLevel: totalLevel,
        hierarchyState: hd.hierarchyState,
        width: null == dimensionInfo ? void 0 : dimensionInfo.width,
        minWidth: null == dimensionInfo ? void 0 : dimensionInfo.minWidth,
        maxWidth: null == dimensionInfo ? void 0 : dimensionInfo.maxWidth,
        parentCellId: roots[roots.length - 1]
    };
    indicatorInfo ? (indicatorInfo.customRender && (hd.customRender = indicatorInfo.customRender), 
    isValid(null === (_x = layoutMap._indicators) || void 0 === _x ? void 0 : _x.find((indicator => indicator.indicatorKey === indicatorInfo.indicatorKey))) || null === (_y = layoutMap._indicators) || void 0 === _y || _y.push({
        id: ++layoutMap.sharedVar.seqId,
        indicatorKey: indicatorInfo.indicatorKey,
        field: indicatorInfo.indicatorKey,
        fieldFormat: null == indicatorInfo ? void 0 : indicatorInfo.format,
        cellType: null !== (_0 = null !== (_z = null == indicatorInfo ? void 0 : indicatorInfo.cellType) && void 0 !== _z ? _z : null == indicatorInfo ? void 0 : indicatorInfo.columnType) && void 0 !== _0 ? _0 : "text",
        chartModule: "chartModule" in indicatorInfo ? indicatorInfo.chartModule : null,
        chartSpec: "chartSpec" in indicatorInfo ? indicatorInfo.chartSpec : null,
        noDataRenderNothing: "noDataRenderNothing" in indicatorInfo && indicatorInfo.noDataRenderNothing,
        sparklineSpec: "sparklineSpec" in indicatorInfo ? indicatorInfo.sparklineSpec : null,
        style: null == indicatorInfo ? void 0 : indicatorInfo.style,
        icon: null == indicatorInfo ? void 0 : indicatorInfo.icon,
        define: Object.assign({}, hd, indicatorInfo, {
            dragHeader: null == dimensionInfo ? void 0 : dimensionInfo.dragHeader
        }),
        width: null == indicatorInfo ? void 0 : indicatorInfo.width,
        minWidth: null == indicatorInfo ? void 0 : indicatorInfo.minWidth,
        maxWidth: null == indicatorInfo ? void 0 : indicatorInfo.maxWidth,
        disableColumnResize: null == indicatorInfo ? void 0 : indicatorInfo.disableColumnResize
    })) : hd.indicatorKey && (isValid(null === (_1 = layoutMap._indicators) || void 0 === _1 ? void 0 : _1.find((indicator => indicator.indicatorKey === hd.indicatorKey))) || null === (_2 = layoutMap._indicators) || void 0 === _2 || _2.push({
        id: ++layoutMap.sharedVar.seqId,
        indicatorKey: hd.indicatorKey,
        field: hd.indicatorKey,
        cellType: "text",
        define: Object.assign({}, hd)
    })), results[id] = cell, layoutMap._headerObjects[id] = cell, _headerCellIds[row][layoutMap.colIndex] = id;
    for (let r = row - 1; r >= 0; r--) _headerCellIds[r][layoutMap.colIndex] = roots[r];
    if (hd.hierarchyState === HierarchyState.expand && (null === (_3 = hd.children) || void 0 === _3 ? void 0 : _3.length) >= 1) show && layoutMap.colIndex++, 
    layoutMap._addHeadersForTreeMode(_headerCellIds, row, null !== (_4 = hd.children) && void 0 !== _4 ? _4 : [], [ ...roots, id ], totalLevel, show && hd.hierarchyState === HierarchyState.expand, dimensions, results); else {
        show && layoutMap.colIndex++;
        for (let r = row + 1; r < _headerCellIds.length; r++) _headerCellIds[r][layoutMap.colIndex] = id;
    }
}

function clearNode(children) {
    for (let i = 0; i < children.length; i++) {
        const node = children[i];
        delete node.level, delete node.startIndex, delete node.id, delete node.levelSpan, 
        delete node.size, delete node.startInTotal;
        const childrenNew = node.children || node.columns;
        childrenNew && clearNode(childrenNew);
    }
}

export function deleteTreeHideNode(tree_children, dimensionPath, indicators, hasHideNode, table) {
    var _a;
    for (let i = tree_children.length - 1; i >= 0; i--) {
        const node = tree_children[i];
        if (dimensionPath.push(node), hasHideNode && node.hide) tree_children.splice(i, 1); else if (node.indicatorKey) {
            const hide = null === (_a = null == indicators ? void 0 : indicators.find((indicator => indicator.indicatorKey === node.indicatorKey))) || void 0 === _a ? void 0 : _a.hide;
            "function" == typeof hide ? hide({
                dimensionPaths: dimensionPath,
                table: table
            }) && tree_children.splice(i, 1) : hide && tree_children.splice(i, 1);
        } else node.children && node.children.length > 0 && deleteTreeHideNode(node.children, dimensionPath, indicators, hasHideNode, table);
        dimensionPath.pop();
    }
}
//# sourceMappingURL=tree-helper.js.map