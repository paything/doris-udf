import { transpose } from "../tools/util";

import { HierarchyState } from "../ts-types";

import { IndicatorDimensionKeyPlaceholder } from "../tools/global";

import { diffCellAddress, diffCellAddressForGridTree, diffCellAddressForGridTreeOnColumn } from "../tools/diff-cell";

import { checkHasCartesianChart, checkHasChart, getChartAxes, getChartDataId, getChartSpec, getRawChartSpec, isCartesianChart, isHasCartesianChartInline, isNoChartDataRenderNothing, isShareChartSpec } from "./chart-helper/get-chart-spec";

import { DimensionTree, countLayoutTree, dealHeader, dealHeaderForGridTreeMode, dealHeaderForTreeMode, generateLayoutTree } from "./tree-helper";

import { cloneDeep, isArray, isValid } from "@visactor/vutils";

import { getQuadProps } from "../scenegraph/utils/padding";

import { Factory } from "../core/factory";

const defaultDimension = {
    startInTotal: 0,
    afterSpanLevel: 0
};

export class PivotHeaderLayoutMap {
    constructor(table, dataset, columnDimensionTree, rowDimensionTree) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w;
        this.colIndex = 0, this._showHeader = !0, this.columnHeaderObjs = [], this.rowHeaderObjs = [], 
        this._cornerHeaderCellFullPathIds = [], this._columnHeaderCellFullPathIds = [], 
        this._rowHeaderCellFullPathIds = [], this._rowHeaderCellFullPathIds_FULL = [], this._cornerHeaderCellIds = [], 
        this._columnHeaderCellIds = [], this._rowHeaderCellIds = [], this._rowHeaderCellIds_FULL = [], 
        this._columnWidths = [], this.columnPaths = [], this._headerObjects = [], this._headerObjectMap = {}, 
        this._indicators = [], this.indicatorsAsCol = !0, this.hideIndicatorName = !1, this._showRowHeader = !0, 
        this._showColumnHeader = !0, this._indicatorShowType = "column", this.rowHierarchyTextStartAlignment = !1, 
        this.rowDimensionKeys = [], this.colDimensionKeys = [], this.indicatorKeys = [], 
        this.indicatorDimensionKey = IndicatorDimensionKeyPlaceholder, this._rowHeaderExtensionTree = {}, 
        this._extensionRowDimensionKeys = [], this.fullRowDimensionKeys = [], this.leftRowSeriesNumberColumnCount = 0, 
        this.rightRowSeriesNumberColumnCount = 0, this._useGetBodyCache = !1, this._getBodyCache = new Map, 
        this._useHeaderPathCache = !1, this._colHeaderPathCache = new Map, this._rowHeaderPathCache = new Map, 
        this.sharedVar = table.layoutNodeId, this._table = table, "tree" === table.options.rowHierarchyType && (this.extensionRows = table.options.extensionRows), 
        this.dataset = dataset, this._largeCellRangeCache = [], this._CellHeaderPathMap = new Map, 
        this.rowTree = table.internalProps.rowTree, this.columnTree = table.internalProps.columnTree, 
        this.rowsDefine = null !== (_a = table.internalProps.rows) && void 0 !== _a ? _a : [], 
        this.columnsDefine = null !== (_b = table.internalProps.columns) && void 0 !== _b ? _b : [], 
        this.indicatorsDefine = null !== (_c = table.internalProps.indicators) && void 0 !== _c ? _c : [], 
        this.indicatorTitle = table.options.indicatorTitle, this.indicatorsAsCol = null === (_d = table.options.indicatorsAsCol) || void 0 === _d || _d, 
        this.hideIndicatorName = null !== (_e = table.options.hideIndicatorName) && void 0 !== _e && _e, 
        this.showRowHeader = null === (_f = table.options.showRowHeader) || void 0 === _f || _f, 
        this.showColumnHeader = null === (_g = table.options.showColumnHeader) || void 0 === _g || _g, 
        this.rowHeaderTitle = table.options.rowHeaderTitle, this.columnHeaderTitle = table.options.columnHeaderTitle, 
        this.rowHierarchyType = null !== (_h = table.options.rowHierarchyType) && void 0 !== _h ? _h : "grid", 
        this.columnHierarchyType = null !== (_j = table.options.columnHierarchyType) && void 0 !== _j ? _j : "grid", 
        this.rowExpandLevel = null !== (_k = table.options.rowExpandLevel) && void 0 !== _k ? _k : 1, 
        this.columnExpandLevel = null !== (_l = table.options.columnExpandLevel) && void 0 !== _l ? _l : 1, 
        this.rowHierarchyIndent = null !== (_m = table.options.rowHierarchyIndent) && void 0 !== _m ? _m : 20, 
        this.rowHierarchyTextStartAlignment = table.options.rowHierarchyTextStartAlignment, 
        this.cornerSetting = Object.assign({
            titleOnDimension: "column",
            forceShowHeader: !1
        }, table.options.corner), (null === (_p = null === (_o = this._table.options) || void 0 === _o ? void 0 : _o.customConfig) || void 0 === _p ? void 0 : _p.enablePivotPathCache) && (this._useHeaderPathCache = !0, 
        this._colHeaderPathCache.clear(), this._rowHeaderPathCache.clear()), dataset && (this.rowTree = dataset.rowHeaderTree, 
        this.columnTree = dataset.colHeaderTree), null === (_q = this.indicatorsDefine) || void 0 === _q || _q.forEach((indicator => {
            "string" == typeof indicator ? this.indicatorKeys.push(indicator) : this.indicatorKeys.push(indicator.indicatorKey);
        })), this.columnDimensionTree = columnDimensionTree, this.rowDimensionTree = rowDimensionTree, 
        this.colDimensionKeys = this.columnDimensionTree.dimensionKeysIncludeVirtual.valueArr(), 
        this.rowDimensionKeys = this.rowDimensionTree.dimensionKeysIncludeVirtual.valueArr(), 
        this.fullRowDimensionKeys = this.fullRowDimensionKeys.concat(this.rowDimensionKeys), 
        this.resetRowHeaderLevelCount(), this._table.isPivotChart() && (this.hasTwoIndicatorAxes = this.indicatorsDefine.some((indicatorObject => {
            var _a, _b;
            if (indicatorObject.chartSpec && indicatorObject.chartSpec.series && indicatorObject.chartSpec.series.length > 1) {
                const axes = null !== (_b = null !== (_a = indicatorObject.chartSpec.axes) && void 0 !== _a ? _a : this._table.pivotChartAxes) && void 0 !== _b ? _b : [];
                if (!axes.length || axes.every((axis => axis.orient !== (this.indicatorsAsCol ? "top" : "right") || !1 !== axis.visible))) return !0;
            }
            return !1;
        }))), this.resetColumnHeaderLevelCount(), this._generateColHeaderIds(), this.colIndex = 0, 
        this._generateRowHeaderIds(), this._rowHeaderCellFullPathIds_FULL = transpose(this._rowHeaderCellFullPathIds_FULL), 
        "tree" === table.options.rowHierarchyType && (null === (_r = this.extensionRows) || void 0 === _r ? void 0 : _r.length) >= 1 && (this.generateExtensionRowTree(), 
        this.extensionRows.forEach((extensionRow => {
            const rowKeys = [];
            extensionRow.rows.forEach((row => {
                "string" == typeof row ? rowKeys.push(row) : rowKeys.push(row.dimensionKey);
            })), this._extensionRowDimensionKeys.push(rowKeys), this.fullRowDimensionKeys = this.fullRowDimensionKeys.concat(rowKeys);
        }))), this.sharedVar.seqId = Math.max(this.sharedVar.seqId, this._headerObjects.length);
        let rowDimensionKeys, colDimensionKeys = this.columnDimensionTree.dimensionKeysIncludeVirtual.valueArr();
        !this.dataset || this._table.isPivotChart() || 0 !== (null !== (_t = null === (_s = this.dataset.records) || void 0 === _s ? void 0 : _s.length) && void 0 !== _t ? _t : 0) || this.dataset.customColTree || (colDimensionKeys = this.columnsDefine.map((define => "string" == typeof define ? define : define.dimensionKey)), 
        this.indicatorsAsCol && colDimensionKeys.push(this.indicatorDimensionKey)), colDimensionKeys = this.columnHeaderTitle ? [ "" ].concat(colDimensionKeys) : colDimensionKeys;
        let extensionRowDimensions = [];
        if ("tree" === this.rowHierarchyType && (null === (_u = this.extensionRows) || void 0 === _u ? void 0 : _u.length) >= 1) {
            const rowTreeFirstKey = [];
            rowTreeFirstKey.push(this.rowDimensionKeys[0]), this._extensionRowDimensionKeys.forEach((extensionRowKeys => {
                rowTreeFirstKey.push(extensionRowKeys[0]);
            })), extensionRowDimensions = this.extensionRows.reduce(((dimensions, cur) => dimensions.concat(cur.rows)), []), 
            rowDimensionKeys = this.rowHeaderTitle ? [ "" ].concat(rowTreeFirstKey) : rowTreeFirstKey;
        } else rowDimensionKeys = this.rowDimensionTree.dimensionKeysIncludeVirtual.valueArr(), 
        !this.dataset || this._table.isPivotChart() || 0 !== (null !== (_w = null === (_v = this.dataset.records) || void 0 === _v ? void 0 : _v.length) && void 0 !== _w ? _w : 0) || this.dataset.customRowTree || (rowDimensionKeys = this.rowsDefine.map((define => "string" == typeof define ? define : define.dimensionKey)), 
        this.indicatorsAsCol || rowDimensionKeys.push(this.indicatorDimensionKey)), rowDimensionKeys = this.rowHeaderTitle ? [ "" ].concat(rowDimensionKeys) : rowDimensionKeys;
        this.cornerHeaderObjs = this._addCornerHeaders(colDimensionKeys, rowDimensionKeys, this.columnsDefine.concat(...this.rowsDefine, ...extensionRowDimensions)), 
        this.colIndex = 0, this._headerObjectMap = this._headerObjects.reduce(((o, e) => (o[e.id] = e, 
        o)), {}), this.indicatorsAsCol && !this.hideIndicatorName ? this._indicatorShowType = "column" : this.indicatorsAsCol || this.hideIndicatorName ? this._indicatorShowType = "none" : this._indicatorShowType = "row", 
        this.generateCellIdsConsiderHideHeader(), this.setPagination(table.options.pagination), 
        this._table.isPivotChart() && (this._chartItemSpanSize = 0, this._chartItemBandSize = 0, 
        this._indicators.find((indicatorObject => {
            var _a, _b, _c, _d, _e, _f, _g, _h;
            (null === (_a = null == indicatorObject ? void 0 : indicatorObject.style) || void 0 === _a ? void 0 : _a.padding) && (this._chartPadding = indicatorObject.style.padding), 
            (null === (_b = indicatorObject.chartSpec) || void 0 === _b ? void 0 : _b.barWidth) && "number" == typeof indicatorObject.chartSpec.barWidth && (this._chartItemSpanSize = null === (_c = indicatorObject.chartSpec) || void 0 === _c ? void 0 : _c.barWidth);
            const bandAxisConfig = null === (_e = null === (_d = indicatorObject.chartSpec) || void 0 === _d ? void 0 : _d.axes) || void 0 === _e ? void 0 : _e.find((axis => "band" === axis.type));
            return (null == bandAxisConfig ? void 0 : bandAxisConfig.bandSize) && (this._chartItemBandSize = null == bandAxisConfig ? void 0 : bandAxisConfig.bandSize, 
            this._chartPaddingInner = null !== (_f = isArray(bandAxisConfig.paddingInner) ? bandAxisConfig.paddingInner[0] : bandAxisConfig.paddingInner) && void 0 !== _f ? _f : 0, 
            this._chartPaddingOuter = null !== (_g = isArray(bandAxisConfig.paddingOuter) ? bandAxisConfig.paddingOuter[0] : bandAxisConfig.paddingOuter) && void 0 !== _g ? _g : 0), 
            this._chartItemSpanSize > 0 || (null === (_h = indicatorObject.chartSpec.series) || void 0 === _h || _h.find((seriesObject => (seriesObject.barWidth && "number" == typeof seriesObject.barWidth && (this._chartItemSpanSize = seriesObject.barWidth), 
            this._chartItemSpanSize > 0))), !1);
        }))), this.handleRowSeriesNumber(table.internalProps.rowSeriesNumber), this.setColumnWidths();
    }
    handleRowSeriesNumber(rowSeriesNumber) {
        var _a;
        rowSeriesNumber && (Array.isArray(rowSeriesNumber) ? this.rowSeriesNumberColumn = rowSeriesNumber.map((seriesNumber => {
            var _a;
            return {
                id: "",
                title: seriesNumber.title,
                define: seriesNumber,
                cellType: null !== (_a = seriesNumber.cellType) && void 0 !== _a ? _a : "text",
                headerType: seriesNumber.cellType && "radio" !== seriesNumber.cellType ? seriesNumber.cellType : "text",
                width: seriesNumber.width,
                style: seriesNumber.style,
                format: seriesNumber.format,
                field: seriesNumber.field,
                icon: seriesNumber.icon,
                headerIcon: seriesNumber.headerIcon,
                isChildNode: !1
            };
        })) : this.rowSeriesNumberColumn = [ {
            id: "",
            title: rowSeriesNumber.title,
            define: rowSeriesNumber,
            cellType: null !== (_a = rowSeriesNumber.cellType) && void 0 !== _a ? _a : "text",
            headerType: rowSeriesNumber.cellType && "radio" !== rowSeriesNumber.cellType ? rowSeriesNumber.cellType : "text",
            style: rowSeriesNumber.style,
            width: rowSeriesNumber.width,
            format: rowSeriesNumber.format,
            field: "",
            icon: rowSeriesNumber.icon,
            headerIcon: rowSeriesNumber.headerIcon,
            isChildNode: !1
        } ], this.leftRowSeriesNumberColumn = this.rowSeriesNumberColumn.filter((rowSeriesNumberItem => !0)), 
        this.rightRowSeriesNumberColumn = this.rowSeriesNumberColumn.filter((rowSeriesNumberItem => !1)), 
        this.leftRowSeriesNumberColumnCount = this.leftRowSeriesNumberColumn.length, this.rightRowSeriesNumberColumnCount = this.rightRowSeriesNumberColumn.length);
    }
    _generateColHeaderIds() {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        if ((null === (_a = this.columnDimensionTree.tree.children) || void 0 === _a ? void 0 : _a.length) >= 1) if ("grid-tree" === this.columnHierarchyType) {
            const startCol = 0;
            this._addHeadersForGridTreeMode(this._columnHeaderCellFullPathIds, startCol, this.columnDimensionTree.tree.children, [], this.columnDimensionTree.totalLevel, this._getColumnHeaderTreeExpandedMaxLevelCount(), !0, this.columnsDefine, this.columnHeaderObjs, !1);
        } else {
            let startRow = 0;
            if (this.dataset && !this._table.isPivotChart() && 0 === (null !== (_c = null === (_b = this.dataset.records) || void 0 === _b ? void 0 : _b.length) && void 0 !== _c ? _c : 0) && !this.dataset.customColTree && !this.dataset.customRowTree && this.indicatorsAsCol && this._getColumnHeaderTreeExpandedMaxLevelCount() < this.columnHeaderLevelCount) {
                startRow = this.columnHeaderLevelCount - this._getColumnHeaderTreeExpandedMaxLevelCount();
                for (let i = 0; i < startRow; i++) this._columnHeaderCellFullPathIds.unshift([]);
            }
            this._addHeaders(this._columnHeaderCellFullPathIds, startRow, this.columnDimensionTree.tree.children, [], this.columnHeaderObjs);
        }
        if (this.columnHeaderTitle) {
            this.sharedVar.seqId = Math.max(this.sharedVar.seqId, this._headerObjects.length);
            const id = ++this.sharedVar.seqId, firstRowIds = Array(this.colCount - this.rowHeaderLevelCount - this.rightFrozenColCount).fill(id);
            this._columnHeaderCellFullPathIds.unshift(firstRowIds);
            const cell = {
                id: id,
                title: "string" == typeof this.columnHeaderTitle.title ? this.columnHeaderTitle.title : this.columnsDefine.reduce(((title, value) => "string" == typeof value ? title : title + (title ? `/${value.title}` : `${value.title}`)), ""),
                field: void 0,
                headerType: null !== (_e = null === (_d = this.columnHeaderTitle) || void 0 === _d ? void 0 : _d.headerType) && void 0 !== _e ? _e : "text",
                style: null === (_f = this.columnHeaderTitle) || void 0 === _f ? void 0 : _f.headerStyle,
                define: {
                    id: id,
                    disableHeaderHover: !!(null === (_g = this.columnHeaderTitle) || void 0 === _g ? void 0 : _g.disableHeaderHover),
                    disableHeaderSelect: !!(null === (_h = this.columnHeaderTitle) || void 0 === _h ? void 0 : _h.disableHeaderSelect)
                }
            };
            this.columnHeaderObjs.push(cell), this._headerObjects[id] = cell;
        }
    }
    _generateRowHeaderIds() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        if ((null === (_a = this.rowDimensionTree.tree.children) || void 0 === _a ? void 0 : _a.length) >= 1) if ("tree" === this.rowHierarchyType) this._addHeadersForTreeMode(this._rowHeaderCellFullPathIds_FULL, 0, this.rowDimensionTree.tree.children, [], this.rowDimensionTree.totalLevel, !0, this.rowsDefine, this.rowHeaderObjs); else if ("grid-tree" === this.rowHierarchyType) {
            const startRow = 0;
            this._addHeadersForGridTreeMode(this._rowHeaderCellFullPathIds_FULL, startRow, this.rowDimensionTree.tree.children, [], this.rowDimensionTree.totalLevel, this._getRowHeaderTreeExpandedMaxLevelCount(), !0, this.rowsDefine, this.rowHeaderObjs, !0);
        } else {
            let startRow = 0;
            if (this.dataset && !this._table.isPivotChart() && 0 === (null !== (_c = null === (_b = this.dataset.records) || void 0 === _b ? void 0 : _b.length) && void 0 !== _c ? _c : 0) && !this.dataset.customColTree && !this.dataset.customRowTree && !this.indicatorsAsCol && this._getRowHeaderTreeExpandedMaxLevelCount() < this.rowHeaderLevelCount) {
                startRow = this.rowHeaderLevelCount - this._getRowHeaderTreeExpandedMaxLevelCount();
                for (let i = 0; i < startRow; i++) this._rowHeaderCellFullPathIds_FULL.unshift([]);
            }
            this._addHeaders(this._rowHeaderCellFullPathIds_FULL, startRow, this.rowDimensionTree.tree.children, [], this.rowHeaderObjs);
        }
        if (this.rowHeaderTitle) {
            this.sharedVar.seqId = Math.max(this.sharedVar.seqId, this._headerObjects.length);
            const id = ++this.sharedVar.seqId, firstColIds = Array(null !== (_e = null === (_d = this._rowHeaderCellFullPathIds_FULL[0]) || void 0 === _d ? void 0 : _d.length) && void 0 !== _e ? _e : this.rowDimensionTree.tree.size).fill(id);
            this._rowHeaderCellFullPathIds_FULL.unshift(firstColIds);
            const cell = {
                id: id,
                title: "string" == typeof this.rowHeaderTitle.title ? this.rowHeaderTitle.title : this.rowsDefine.reduce(((title, value) => "string" == typeof value ? title : title + (title ? `/${value.title}` : `${value.title}`)), ""),
                field: void 0,
                headerType: null !== (_g = null === (_f = this.rowHeaderTitle) || void 0 === _f ? void 0 : _f.headerType) && void 0 !== _g ? _g : "text",
                style: null === (_h = this.rowHeaderTitle) || void 0 === _h ? void 0 : _h.headerStyle,
                define: {
                    id: id,
                    disableHeaderHover: !!(null === (_j = this.rowHeaderTitle) || void 0 === _j ? void 0 : _j.disableHeaderHover),
                    disableHeaderSelect: !!(null === (_k = this.rowHeaderTitle) || void 0 === _k ? void 0 : _k.disableHeaderSelect)
                }
            };
            this.rowHeaderObjs.push(cell), this._headerObjects[id] = cell;
        }
    }
    _getRowHeaderTreeExpandedMaxLevelCount() {
        return "tree" === this.rowHierarchyType ? 1 : "grid-tree" === this.rowHierarchyType ? "row" === this.cornerSetting.titleOnDimension ? this.rowDimensionTree.totalLevel : this.indicatorsAsCol ? this.rowDimensionTree.expandedMaxLevel : this.rowDimensionTree.expandedMaxLevel + 1 : this.rowDimensionTree.totalLevel;
    }
    _getColumnHeaderTreeExpandedMaxLevelCount() {
        return "grid-tree" === this.columnHierarchyType ? "column" === this.cornerSetting.titleOnDimension ? this.columnDimensionTree.totalLevel : !1 === this.indicatorsAsCol ? this.columnDimensionTree.expandedMaxLevel : this.columnDimensionTree.expandedMaxLevel + 1 : this.columnDimensionTree.totalLevel;
    }
    _addHeaders(_headerCellIds, row, header, roots, results) {
        const _this = this;
        _headerCellIds[row] || function(row) {
            const newRow = _headerCellIds[row] = [];
            if (0 === _this.colIndex) return newRow;
            const prev = _headerCellIds[row - 1];
            for (let col = 0; col < (null == prev ? void 0 : prev.length); col++) newRow[col] = prev[col];
        }(row);
        for (let i = 0; i < header.length; i++) {
            const hd = header[i];
            dealHeader(hd, _headerCellIds, results, roots, row, this);
        }
    }
    _addHeadersForTreeMode(_headerCellIds, row, header, roots, totalLevel, show, dimensions, results) {
        const _this = this;
        _headerCellIds[row] || function(row) {
            const newRow = _headerCellIds[row] = [];
            if (0 === _this.colIndex) return newRow;
            const prev = _headerCellIds[row - 1];
            for (let col = 0; col < (null == prev ? void 0 : prev.length); col++) newRow[col] = prev[col];
        }(row);
        for (let i = 0; i < header.length; i++) {
            const hd = header[i];
            dealHeaderForTreeMode(hd, _headerCellIds, results, roots, row, totalLevel, show, dimensions, this);
        }
    }
    _addHeadersForGridTreeMode(_headerCellIds, row, header, roots, totalLevel, expandedMaxLevel, show, dimensions, results, isRowTree) {
        const _this = this;
        _headerCellIds[row] || function(row) {
            const newRow = _headerCellIds[row] = [];
            if (0 === _this.colIndex) return newRow;
            const prev = _headerCellIds[row - 1];
            for (let col = 0; col < (null == prev ? void 0 : prev.length); col++) newRow[col] = prev[col];
        }(row);
        for (let i = 0; i < header.length; i++) {
            const hd = header[i];
            dealHeaderForGridTreeMode(hd, _headerCellIds, results, roots, row, totalLevel, expandedMaxLevel, show, dimensions, isRowTree, this.indicatorsAsCol, this);
        }
    }
    _addCornerHeaders(colDimensionKeys, rowDimensionKeys, dimensions) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        this._cornerHeaderCellFullPathIds = [];
        const results = [], colLevelCount = "grid-tree" === this.columnHierarchyType && this._getColumnHeaderTreeExpandedMaxLevelCount() || this.columnHeaderLevelCount, rowLevelCount = "grid-tree" === this.rowHierarchyType && this._getRowHeaderTreeExpandedMaxLevelCount() || this.rowHeaderLevelCount;
        if (0 === colLevelCount || 0 === rowLevelCount) return results;
        if ("all" === this.cornerSetting.titleOnDimension) if (this.indicatorsAsCol) {
            if (colDimensionKeys) for (let i = 0; i < colLevelCount; i++) {
                const dimensionKey = colDimensionKeys[i], id = ++this.sharedVar.seqId, dimensionInfo = dimensions.find((dimension => "string" != typeof dimension && dimension.dimensionKey === dimensionKey)), cell = {
                    id: id,
                    title: dimensionKey === this.indicatorDimensionKey ? this.indicatorTitle : dimensionInfo ? dimensionInfo.title : "axis" === dimensionKey ? "" : dimensionKey,
                    field: dimensionKey,
                    style: this.cornerSetting.headerStyle,
                    headerType: null !== (_a = this.cornerSetting.headerType) && void 0 !== _a ? _a : "text",
                    showSort: null == dimensionInfo ? void 0 : dimensionInfo.showSortInCorner,
                    sort: null == dimensionInfo ? void 0 : dimensionInfo.sort,
                    define: {
                        showSort: null == dimensionInfo ? void 0 : dimensionInfo.showSortInCorner,
                        sort: null == dimensionInfo ? void 0 : dimensionInfo.sort,
                        dimensionKey: dimensionKey,
                        id: id,
                        value: dimensionKey,
                        headerEditor: this.cornerSetting.headerEditor,
                        disableHeaderHover: !!this.cornerSetting.disableHeaderHover,
                        disableHeaderSelect: !!this.cornerSetting.disableHeaderSelect
                    },
                    dropDownMenu: null == dimensionInfo ? void 0 : dimensionInfo.cornerDropDownMenu,
                    headerIcon: null == dimensionInfo ? void 0 : dimensionInfo.cornerHeaderIcon,
                    pivotInfo: {
                        value: null !== (_b = null == dimensionInfo ? void 0 : dimensionInfo.title) && void 0 !== _b ? _b : "",
                        dimensionKey: dimensionKey,
                        isPivotCorner: !0
                    },
                    description: null == dimensionInfo ? void 0 : dimensionInfo.cornerDescription
                };
                results[id] = cell, this._headerObjects[id] = cell, this._cornerHeaderCellFullPathIds[i] || (this._cornerHeaderCellFullPathIds[i] = []);
                for (let r = 0; r < rowLevelCount; r++) this._cornerHeaderCellFullPathIds[i][r] = id;
            }
            if (rowDimensionKeys) for (let i = 0; i < rowLevelCount; i++) {
                const dimensionKey = rowDimensionKeys[i], id = ++this.sharedVar.seqId, dimensionInfo = dimensions.find((dimension => "string" != typeof dimension && dimension.dimensionKey === dimensionKey)), cell = {
                    id: id,
                    title: dimensionKey === this.indicatorDimensionKey ? this.indicatorTitle : dimensionInfo ? dimensionInfo.title : "axis" === dimensionKey ? "" : dimensionKey,
                    field: dimensionKey,
                    style: this.cornerSetting.headerStyle,
                    headerType: null !== (_c = this.cornerSetting.headerType) && void 0 !== _c ? _c : "text",
                    showSort: null == dimensionInfo ? void 0 : dimensionInfo.showSortInCorner,
                    sort: null == dimensionInfo ? void 0 : dimensionInfo.sort,
                    define: {
                        showSort: null == dimensionInfo ? void 0 : dimensionInfo.showSortInCorner,
                        sort: null == dimensionInfo ? void 0 : dimensionInfo.sort,
                        dimensionKey: dimensionKey,
                        id: id,
                        value: dimensionKey,
                        headerEditor: this.cornerSetting.headerEditor,
                        disableHeaderHover: !!this.cornerSetting.disableHeaderHover,
                        disableHeaderSelect: !!this.cornerSetting.disableHeaderSelect
                    },
                    dropDownMenu: null == dimensionInfo ? void 0 : dimensionInfo.cornerDropDownMenu,
                    headerIcon: null == dimensionInfo ? void 0 : dimensionInfo.cornerHeaderIcon,
                    pivotInfo: {
                        value: null !== (_d = null == dimensionInfo ? void 0 : dimensionInfo.title) && void 0 !== _d ? _d : "",
                        dimensionKey: dimensionKey,
                        isPivotCorner: !0
                    },
                    description: null == dimensionInfo ? void 0 : dimensionInfo.cornerDescription
                };
                results[id] = cell, this._headerObjects[id] = cell, this._cornerHeaderCellFullPathIds[this._cornerHeaderCellFullPathIds.length - 1] || (this._cornerHeaderCellFullPathIds[this._cornerHeaderCellFullPathIds.length - 1] = []), 
                this._cornerHeaderCellFullPathIds[this._cornerHeaderCellFullPathIds.length - 1][i] = id;
            }
        } else {
            if (rowDimensionKeys) for (let i = 0; i < rowLevelCount; i++) {
                const dimensionKey = rowDimensionKeys[i], id = ++this.sharedVar.seqId, dimensionInfo = dimensions.find((dimension => "string" != typeof dimension && dimension.dimensionKey === dimensionKey)), cell = {
                    id: id,
                    title: dimensionKey === this.indicatorDimensionKey ? this.indicatorTitle : dimensionInfo ? dimensionInfo.title : "axis" === dimensionKey ? "" : dimensionKey,
                    field: dimensionKey,
                    style: this.cornerSetting.headerStyle,
                    headerType: null !== (_e = this.cornerSetting.headerType) && void 0 !== _e ? _e : "text",
                    showSort: null == dimensionInfo ? void 0 : dimensionInfo.showSortInCorner,
                    sort: null == dimensionInfo ? void 0 : dimensionInfo.sort,
                    define: {
                        showSort: null == dimensionInfo ? void 0 : dimensionInfo.showSortInCorner,
                        sort: null == dimensionInfo ? void 0 : dimensionInfo.sort,
                        dimensionKey: dimensionKey,
                        id: id,
                        value: dimensionKey,
                        headerEditor: this.cornerSetting.headerEditor,
                        disableHeaderHover: !!this.cornerSetting.disableHeaderHover,
                        disableHeaderSelect: !!this.cornerSetting.disableHeaderSelect
                    },
                    dropDownMenu: null == dimensionInfo ? void 0 : dimensionInfo.cornerDropDownMenu,
                    headerIcon: null == dimensionInfo ? void 0 : dimensionInfo.cornerHeaderIcon,
                    pivotInfo: {
                        value: null !== (_f = null == dimensionInfo ? void 0 : dimensionInfo.title) && void 0 !== _f ? _f : "",
                        dimensionKey: dimensionKey,
                        isPivotCorner: !0
                    },
                    description: null == dimensionInfo ? void 0 : dimensionInfo.cornerDescription
                };
                results[id] = cell, this._headerObjects[id] = cell;
                for (let r = 0; r < colLevelCount; r++) this._cornerHeaderCellFullPathIds[r] || (this._cornerHeaderCellFullPathIds[r] = []), 
                this._cornerHeaderCellFullPathIds[r][i] = id;
            }
            if (colDimensionKeys) for (let c = 0; c < colLevelCount; c++) {
                const dimensionKey = colDimensionKeys[c], id = ++this.sharedVar.seqId, dimensionInfo = dimensions.find((dimension => "string" != typeof dimension && dimension.dimensionKey === dimensionKey)), cell = {
                    id: id,
                    title: dimensionKey === this.indicatorDimensionKey ? this.indicatorTitle : dimensionInfo ? dimensionInfo.title : "axis" === dimensionKey ? "" : dimensionKey,
                    field: dimensionKey,
                    style: this.cornerSetting.headerStyle,
                    headerType: null !== (_g = this.cornerSetting.headerType) && void 0 !== _g ? _g : "text",
                    showSort: null == dimensionInfo ? void 0 : dimensionInfo.showSortInCorner,
                    sort: null == dimensionInfo ? void 0 : dimensionInfo.sort,
                    define: {
                        showSort: null == dimensionInfo ? void 0 : dimensionInfo.showSortInCorner,
                        sort: null == dimensionInfo ? void 0 : dimensionInfo.sort,
                        dimensionKey: dimensionKey,
                        id: id,
                        value: dimensionKey,
                        headerEditor: this.cornerSetting.headerEditor,
                        disableHeaderHover: !!this.cornerSetting.disableHeaderHover,
                        disableHeaderSelect: !!this.cornerSetting.disableHeaderSelect
                    },
                    dropDownMenu: null == dimensionInfo ? void 0 : dimensionInfo.cornerDropDownMenu,
                    headerIcon: null == dimensionInfo ? void 0 : dimensionInfo.cornerHeaderIcon,
                    pivotInfo: {
                        value: null !== (_h = null == dimensionInfo ? void 0 : dimensionInfo.title) && void 0 !== _h ? _h : "",
                        dimensionKey: dimensionKey,
                        isPivotCorner: !0
                    },
                    description: null == dimensionInfo ? void 0 : dimensionInfo.cornerDescription
                };
                results[id] = cell, this._headerObjects[id] = cell, this._cornerHeaderCellFullPathIds[c][this._cornerHeaderCellFullPathIds[c].length - 1] = id;
            }
        } else if ("row" === this.cornerSetting.titleOnDimension || "column" === this.cornerSetting.titleOnDimension) {
            const dimensionKeys = "row" === (null === (_j = this.cornerSetting) || void 0 === _j ? void 0 : _j.titleOnDimension) ? rowDimensionKeys : colDimensionKeys;
            dimensionKeys && dimensionKeys.forEach(((dimensionKey, key) => {
                var _a, _b;
                const id = ++this.sharedVar.seqId, dimensionInfo = dimensions.find((dimension => "string" != typeof dimension && dimension.dimensionKey === dimensionKey)), cell = {
                    id: id,
                    title: dimensionKey === this.indicatorDimensionKey ? this.indicatorTitle : dimensionInfo ? dimensionInfo.title : "axis" === dimensionKey ? "" : dimensionKey,
                    field: dimensionKey,
                    style: this.cornerSetting.headerStyle,
                    headerType: null !== (_a = this.cornerSetting.headerType) && void 0 !== _a ? _a : "text",
                    showSort: null == dimensionInfo ? void 0 : dimensionInfo.showSortInCorner,
                    sort: null == dimensionInfo ? void 0 : dimensionInfo.sort,
                    define: {
                        showSort: null == dimensionInfo ? void 0 : dimensionInfo.showSortInCorner,
                        sort: null == dimensionInfo ? void 0 : dimensionInfo.sort,
                        dimensionKey: dimensionKey,
                        id: id,
                        value: dimensionKey,
                        headerCustomRender: this.cornerSetting.customRender,
                        headerCustomLayout: this.cornerSetting.customLayout,
                        headerEditor: this.cornerSetting.headerEditor,
                        disableHeaderHover: !!this.cornerSetting.disableHeaderHover,
                        disableHeaderSelect: !!this.cornerSetting.disableHeaderSelect
                    },
                    dropDownMenu: null == dimensionInfo ? void 0 : dimensionInfo.cornerDropDownMenu,
                    headerIcon: null == dimensionInfo ? void 0 : dimensionInfo.cornerHeaderIcon,
                    pivotInfo: {
                        value: null !== (_b = null == dimensionInfo ? void 0 : dimensionInfo.title) && void 0 !== _b ? _b : "",
                        dimensionKey: dimensionKey,
                        isPivotCorner: !0
                    },
                    description: null == dimensionInfo ? void 0 : dimensionInfo.cornerDescription
                };
                if (results[id] = cell, this._headerObjects[id] = cell, "column" === this.cornerSetting.titleOnDimension) {
                    this._cornerHeaderCellFullPathIds[key] || (this._cornerHeaderCellFullPathIds[key] = []);
                    for (let r = 0; r < this.rowHeaderLevelCount; r++) this._cornerHeaderCellFullPathIds[key][r] = id;
                } else if ("row" === this.cornerSetting.titleOnDimension) for (let r = 0; r < this.columnHeaderLevelCount; r++) this._cornerHeaderCellFullPathIds[r] || (this._cornerHeaderCellFullPathIds[r] = []), 
                this._cornerHeaderCellFullPathIds[r][key] = id;
            }));
        } else {
            const id = ++this.sharedVar.seqId, cell = {
                id: id,
                title: "",
                field: "维度名称",
                style: this.cornerSetting.headerStyle,
                headerType: null !== (_k = this.cornerSetting.headerType) && void 0 !== _k ? _k : "text",
                define: {
                    dimensionKey: "维度名称",
                    id: id,
                    headerCustomRender: this.cornerSetting.customRender,
                    headerCustomLayout: this.cornerSetting.customLayout,
                    disableHeaderHover: !!this.cornerSetting.disableHeaderHover,
                    disableHeaderSelect: !!this.cornerSetting.disableHeaderSelect
                }
            };
            results[id] = cell, this._headerObjects[id] = cell;
            for (let r = 0; r < this.columnHeaderLevelCount; r++) for (let j = 0; j < this.rowHeaderLevelCount; j++) this._cornerHeaderCellFullPathIds[r] || (this._cornerHeaderCellFullPathIds[r] = []), 
            this._cornerHeaderCellFullPathIds[r][j] = id;
        }
        return results;
    }
    generateExtensionRowTree() {
        this.extensionRows.forEach(((extensionRow, indexP) => {
            const old_rowHeaderCellIds = this._rowHeaderCellFullPathIds_FULL;
            this._rowHeaderCellFullPathIds_FULL = [], old_rowHeaderCellIds.forEach(((row_ids, index) => {
                const key = row_ids[row_ids.length - 1];
                let tree, rowExtensionDimensionTree;
                if (this.colIndex = 0, "function" == typeof extensionRow.rowTree) {
                    const fullCellIds = this.findFullCellIds(row_ids);
                    tree = extensionRow.rowTree(fullCellIds.map((id => ({
                        dimensionKey: this._headerObjects[id].field,
                        value: this._headerObjects[id].title
                    }))));
                } else tree = cloneDeep(extensionRow.rowTree);
                this._rowHeaderExtensionTree[key] ? (this._rowHeaderExtensionTree[key].reset(this._rowHeaderExtensionTree[key].tree.children), 
                rowExtensionDimensionTree = this._rowHeaderExtensionTree[key]) : (rowExtensionDimensionTree = new DimensionTree(null != tree ? tree : [], this.sharedVar, this.rowHierarchyType, void 0), 
                this._rowHeaderExtensionTree[key] = rowExtensionDimensionTree);
                const extensionRowTreeHeaderIds = [];
                this._addHeadersForTreeMode(extensionRowTreeHeaderIds, 0, rowExtensionDimensionTree.tree.children, [], rowExtensionDimensionTree.totalLevel, !0, extensionRow.rows, this.rowHeaderObjs);
                for (let i = 0; i < extensionRowTreeHeaderIds[0].length; i++) this._rowHeaderCellFullPathIds_FULL.push(row_ids.concat(extensionRowTreeHeaderIds[0][i]));
            }));
        }));
    }
    setColumnWidths() {
        var _a, _b, _c;
        const returnWidths = new Array(this.colCount).fill(void 0);
        if (this.leftRowSeriesNumberColumnCount && (returnWidths[0] = this.leftRowSeriesNumberColumn[0]), 
        this.showHeader && this.showRowHeader) if (this.rowHeaderTitle && (returnWidths[0 + this.leftRowSeriesNumberColumnCount] = {}), 
        "tree" === this.rowHierarchyType) {
            const mainDimensionFirstRowKey = this.rowDimensionKeys[0];
            if (mainDimensionFirstRowKey) {
                const dimension = null === (_a = this.rowsDefine) || void 0 === _a ? void 0 : _a.find((dimension => "string" != typeof dimension && dimension.dimensionKey === mainDimensionFirstRowKey));
                dimension && (returnWidths[0 + (this.rowHeaderTitle ? 1 : 0) + this.leftRowSeriesNumberColumnCount] = {
                    width: dimension.width,
                    minWidth: dimension.minWidth,
                    maxWidth: dimension.maxWidth
                });
            }
            null === (_b = this._extensionRowDimensionKeys) || void 0 === _b || _b.forEach(((extensionRowDimensionKeys, index) => {
                var _a;
                const curDimensionFirstRowKey = extensionRowDimensionKeys[0];
                if (curDimensionFirstRowKey) {
                    const dimension = null === (_a = this.extensionRows[index].rows) || void 0 === _a ? void 0 : _a.find((dimension => "string" != typeof dimension && dimension.dimensionKey === curDimensionFirstRowKey));
                    dimension && (returnWidths[index + 1 + (this.rowHeaderTitle ? 1 : 0) + this.leftRowSeriesNumberColumnCount] = {
                        width: dimension.width,
                        minWidth: dimension.minWidth,
                        maxWidth: dimension.maxWidth
                    });
                }
            }));
        } else {
            (this.rowDimensionTree.totalLevel > 0 ? this.rowDimensionTree.dimensionKeysIncludeVirtual.valueArr() : this.rowsDefine.map((dimension => "string" == typeof dimension ? dimension : dimension.dimensionKey))).forEach(((objKey, index) => {
                var _a;
                const dimension = null === (_a = this.rowsDefine) || void 0 === _a ? void 0 : _a.find((dimension => "string" != typeof dimension && dimension.dimensionKey === objKey));
                dimension && (returnWidths[index + (this.rowHeaderTitle ? 1 : 0) + this.leftRowSeriesNumberColumnCount] = {
                    width: dimension.width,
                    minWidth: dimension.minWidth,
                    maxWidth: dimension.maxWidth
                });
            }));
        }
        if (this.indicatorsAsCol) for (let i = this.rowHeaderLevelCount + this.leftRowSeriesNumberColumnCount; i < this.colCount; i++) {
            const cellDefine = this.getBody(i, this.columnHeaderLevelCount);
            returnWidths[i] = {
                width: null == cellDefine ? void 0 : cellDefine.width,
                minWidth: null == cellDefine ? void 0 : cellDefine.minWidth,
                maxWidth: null == cellDefine ? void 0 : cellDefine.maxWidth
            };
        } else {
            let maxWidth, minWidth, isAuto, width = 0;
            null === (_c = this._indicators) || void 0 === _c || _c.forEach(((obj, index) => {
                var _a, _b;
                "number" == typeof obj.width ? width = Math.max(obj.width, width) : "auto" === obj.width && (isAuto = !0), 
                "number" == typeof obj.minWidth && (minWidth = Math.max(obj.minWidth, null !== (_a = minWidth) && void 0 !== _a ? _a : 0)), 
                "number" == typeof obj.maxWidth && (maxWidth = Math.min(obj.maxWidth, null !== (_b = maxWidth) && void 0 !== _b ? _b : Number.MAX_VALUE));
            })), width = width > 0 ? width : isAuto ? "auto" : void 0, returnWidths.fill({
                width: width,
                minWidth: minWidth,
                maxWidth: maxWidth
            }, this.rowHeaderLevelCount + this.leftRowSeriesNumberColumnCount, this.colCount - this.rightFrozenColCount);
        }
        this._columnWidths = returnWidths;
    }
    get columnWidths() {
        return this._columnWidths;
    }
    getColumnWidthDefined(col) {
        return this._columnWidths[col];
    }
    get showHeader() {
        return this._showHeader;
    }
    set showHeader(_showHeader) {
        this._showHeader = _showHeader;
    }
    get showColumnHeader() {
        return this._showColumnHeader;
    }
    set showColumnHeader(_showColumnHeader) {
        this._showColumnHeader = _showColumnHeader;
    }
    get showRowHeader() {
        return this._showRowHeader;
    }
    set showRowHeader(_showRowHeader) {
        this._showRowHeader = _showRowHeader;
    }
    get columnHeaderTitle() {
        return this._columnHeaderTitle;
    }
    set columnHeaderTitle(_columnHeaderTitle) {
        this._columnHeaderTitle = _columnHeaderTitle;
    }
    get rowHeaderTitle() {
        return this._rowHeaderTitle;
    }
    set rowHeaderTitle(_rowHeaderTitle) {
        this._rowHeaderTitle = _rowHeaderTitle;
    }
    getHeaderFieldKey(col, row) {}
    getCellLocation(col, row) {
        return this.isCornerHeader(col, row) ? "cornerHeader" : this.isColumnHeader(col, row) ? "columnHeader" : this.isRowHeader(col, row) ? "rowHeader" : "body";
    }
    isHeader(col, row) {
        return col >= this.leftRowSeriesNumberColumnCount && col < this.rowHeaderLevelCount + this.leftRowSeriesNumberColumnCount || (row >= 0 && row < this.columnHeaderLevelCount || (col >= this.colCount - this.rightHeaderColCount || row >= this.rowCount - this.bottomHeaderRowCount));
    }
    isCornerHeader(col, row) {
        return col >= 0 && col < this.rowHeaderLevelCount + this.leftRowSeriesNumberColumnCount && row >= 0 && row < this.columnHeaderLevelCount;
    }
    isColumnHeader(col, row) {
        return col >= this.rowHeaderLevelCount + this.leftRowSeriesNumberColumnCount && row >= 0 && row < this.columnHeaderLevelCount;
    }
    isRowHeader(col, row) {
        return col >= this.leftRowSeriesNumberColumnCount && col < this.rowHeaderLevelCount + this.leftRowSeriesNumberColumnCount && row >= this.columnHeaderLevelCount;
    }
    isFrozen(col, row) {
        return this.isFrozenColumn(col) || this.isRightFrozenColumn(col) || this.isBottomFrozenRow(row) || this.isFrozenRow(row) || this.isSeriesNumberInBody(col, row) || this.isSeriesNumberInHeader(col, row);
    }
    isFrozenColumn(col, row) {
        if (isValid(row)) {
            if (col >= 0 && col < this.frozenColCount && row >= this.frozenRowCount && row < this.rowCount - this.bottomFrozenRowCount) return !0;
        } else if (this.frozenColCount > 0 && col >= 0 && col < this.frozenColCount) return !0;
        return !1;
    }
    isRightFrozenColumn(col, row) {
        if (isValid(row)) {
            if (col >= this.colCount - this.rightFrozenColCount && row >= this.frozenRowCount && row < this.rowCount - this.bottomFrozenRowCount) return !0;
        } else if (this.rightFrozenColCount > 0 && col >= this.colCount - this.rightFrozenColCount) return !0;
        return !1;
    }
    isFrozenRow(col, row) {
        if (isValid(row)) {
            if (row >= 0 && row < this.frozenRowCount && col >= this.frozenColCount && col < this.colCount - this.rightFrozenColCount) return !0;
        } else if (row = col, this.frozenRowCount > 0 && row >= 0 && row < this.frozenRowCount) return !0;
        return !1;
    }
    isBottomFrozenRow(col, row) {
        if (isValid(row)) {
            if (row >= this.rowCount - this.bottomFrozenRowCount && col >= this.frozenColCount && col < this.colCount - this.rightFrozenColCount) return !0;
        } else if (row = col, this.bottomFrozenRowCount > 0 && row >= this.rowCount - this.bottomFrozenRowCount) return !0;
        return !1;
    }
    isLeftTopCorner(col, row) {
        return col >= 0 && col < this.frozenColCount && row >= 0 && row < this.frozenRowCount;
    }
    isLeftBottomCorner(col, row) {
        return col >= 0 && col < this.frozenColCount && row >= this.rowCount - this.bottomFrozenRowCount;
    }
    isRightTopCorner(col, row) {
        return col >= this.colCount - this.rightFrozenColCount && row >= 0 && row < this.frozenRowCount;
    }
    isRightBottomCorner(col, row) {
        return col >= this.colCount - this.rightFrozenColCount && row >= this.rowCount - this.bottomFrozenRowCount;
    }
    getColumnHeaderRange() {
        return {
            start: {
                col: this.rowHeaderLevelCount,
                row: 0
            },
            end: {
                col: this.colCount - 1,
                row: this.columnHeaderLevelCount - 1
            }
        };
    }
    getRowHeaderRange() {
        return {
            start: {
                col: 0,
                row: this.columnHeaderLevelCount
            },
            end: {
                col: this.rowHeaderLevelCount - 1,
                row: this.rowCount - 1
            }
        };
    }
    getCornerHeaderRange() {
        return {
            start: {
                col: 0,
                row: 0
            },
            end: {
                col: this.rowHeaderLevelCount - 1,
                row: this.columnHeaderLevelCount - 1
            }
        };
    }
    getBodyRange() {
        return {
            start: {
                col: this.rowHeaderLevelCount,
                row: this.columnHeaderLevelCount
            },
            end: {
                col: this.colCount - 1,
                row: this.rowCount - 1
            }
        };
    }
    resetCellIds() {}
    get frozenColCount() {
        return this._table.internalProps.frozenColCount ? this.colCount > this._table.internalProps.frozenColCount ? this._table.internalProps.frozenColCount : this.colCount : 0;
    }
    get frozenRowCount() {
        return this._table.internalProps.frozenRowCount ? this.rowCount >= this._table.internalProps.frozenRowCount ? this._table.internalProps.frozenRowCount : this.rowCount : 0;
    }
    get headerLevelCount() {
        return this.columnHeaderLevelCount;
    }
    resetColumnHeaderLevelCount() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        if (this.showHeader && this.showColumnHeader) {
            if (this._table.isPivotChart() && this.indicatorsAsCol && !(null === (_b = null === (_a = this.dataset) || void 0 === _a ? void 0 : _a.colKeys) || void 0 === _b ? void 0 : _b.length) && 0 === (null === (_d = null === (_c = this.columnDimensionTree) || void 0 === _c ? void 0 : _c.tree) || void 0 === _d ? void 0 : _d.level) && !this.hasTwoIndicatorAxes) return void (this.columnHeaderLevelCount = 0);
            let count = this._getColumnHeaderTreeExpandedMaxLevelCount();
            return this.indicatorsAsCol && this.hideIndicatorName && this.colDimensionKeys[this.colDimensionKeys.length - 1] === this.indicatorDimensionKey && count--, 
            0 === count && this.dataset && !(null === (_e = this.dataset.customColTree) || void 0 === _e ? void 0 : _e.length) ? "row" !== this.cornerSetting.titleOnDimension && "all" !== this.cornerSetting.titleOnDimension || !this.cornerSetting.forceShowHeader ? this._table.isPivotChart() || 0 !== (null !== (_g = null === (_f = this.dataset.records) || void 0 === _f ? void 0 : _f.length) && void 0 !== _g ? _g : 0) || "column" !== this.cornerSetting.titleOnDimension && "all" !== this.cornerSetting.titleOnDimension || (count = null !== (_h = this.columnsDefine.length) && void 0 !== _h ? _h : 0) : count = 1 : !this.dataset || this._table.isPivotChart() || 0 !== (null !== (_k = null === (_j = this.dataset.records) || void 0 === _j ? void 0 : _j.length) && void 0 !== _k ? _k : 0) || this.dataset.customColTree || "column" !== this.cornerSetting.titleOnDimension && "all" !== this.cornerSetting.titleOnDimension || (count = null !== (_l = this.columnsDefine.length) && void 0 !== _l ? _l : 0, 
            !this.hideIndicatorName && this.indicatorsAsCol && count++), this.columnHeaderTitle && (count += 1), 
            this._table.isPivotChart() && this.indicatorsAsCol && !this.hasTwoIndicatorAxes && checkHasCartesianChart(this.indicatorsDefine) && (count -= 1), 
            void (this.columnHeaderLevelCount = count);
        }
        this.columnHeaderLevelCount = this.indicatorsAsCol ? this.hideIndicatorName ? 0 : 1 : 0;
    }
    resetRowHeaderLevelCount() {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        if (this.showHeader && this.showRowHeader) {
            if ("tree" === this.rowHierarchyType) {
                const extensionRowCount = null !== (_b = null === (_a = this.extensionRows) || void 0 === _a ? void 0 : _a.length) && void 0 !== _b ? _b : 0;
                return this.rowHeaderTitle ? void (this.rowHeaderLevelCount = 1 + (this.rowDimensionTree.totalLevel ? 1 : 0) + extensionRowCount) : void (this.rowHeaderLevelCount = (this.rowDimensionTree.totalLevel ? 1 : 0) + extensionRowCount);
            }
            const rowLevelCount = this._getRowHeaderTreeExpandedMaxLevelCount();
            let count = rowLevelCount;
            return 0 === count && this.dataset && !(null === (_c = this.dataset.customRowTree) || void 0 === _c ? void 0 : _c.length) ? "column" !== this.cornerSetting.titleOnDimension && "all" !== this.cornerSetting.titleOnDimension || !this.cornerSetting.forceShowHeader ? this._table.isPivotChart() || 0 !== (null !== (_e = null === (_d = this.dataset.records) || void 0 === _d ? void 0 : _d.length) && void 0 !== _e ? _e : 0) || "row" !== this.cornerSetting.titleOnDimension && "all" !== this.cornerSetting.titleOnDimension || (count = null !== (_f = this.rowsDefine.length) && void 0 !== _f ? _f : 0) : count = 1 : !this.dataset || this._table.isPivotChart() || 0 !== (null !== (_h = null === (_g = this.dataset.records) || void 0 === _g ? void 0 : _g.length) && void 0 !== _h ? _h : 0) || this.dataset.customRowTree || "row" !== this.cornerSetting.titleOnDimension && "all" !== this.cornerSetting.titleOnDimension || (count = this.rowsDefine.length, 
            this.hideIndicatorName || this.indicatorsAsCol || count++), !this.indicatorsAsCol && this.hideIndicatorName && this.rowDimensionKeys[this.rowDimensionKeys.length - 1] === this.indicatorDimensionKey && (count = rowLevelCount - 1), 
            this.rowHeaderTitle && (count += 1), void (this.rowHeaderLevelCount = count);
        }
        this.rowHeaderLevelCount = this.indicatorsAsCol || this.hideIndicatorName ? 0 : 1;
    }
    get columnHeaderLevelCount() {
        return this._columnHeaderLevelCount;
    }
    set columnHeaderLevelCount(count) {
        this._columnHeaderLevelCount = count;
    }
    get rowHeaderLevelCount() {
        return this._rowHeaderLevelCount;
    }
    set rowHeaderLevelCount(count) {
        this._rowHeaderLevelCount = count;
    }
    get colCount() {
        var _a, _b, _c, _d;
        let bodyColCount;
        return bodyColCount = this._getColumnHeaderTreeExpandedMaxLevelCount() > 0 || this._table.isPivotChart() || (null === (_a = this.dataset.records) || void 0 === _a ? void 0 : _a.length) > 0 || this.dataset.records && !Array.isArray(this.dataset.records) ? (null !== (_c = null === (_b = this._columnHeaderCellIds[0]) || void 0 === _b ? void 0 : _b.length) && void 0 !== _c ? _c : this.columnDimensionTree.tree.size) || ((null === (_d = this._indicators) || void 0 === _d ? void 0 : _d.length) > 0 ? 1 : 0) : 0, 
        bodyColCount + this.rowHeaderLevelCount + this.rightHeaderColCount + this.leftRowSeriesNumberColumnCount;
    }
    get rowCount() {
        var _a, _b, _c, _d;
        return ((this._table.records || this.dataset.records) && (!Array.isArray(this._table.records) || this._table.records.length > 0) && (null === (_a = this._indicators) || void 0 === _a ? void 0 : _a.length) > 0 && !(null === (_b = this._rowHeaderCellIds) || void 0 === _b ? void 0 : _b.length) ? 1 : null !== (_d = null === (_c = this._rowHeaderCellIds) || void 0 === _c ? void 0 : _c.length) && void 0 !== _d ? _d : 0) + this.columnHeaderLevelCount + this.bottomHeaderRowCount;
    }
    get bodyRowSpanCount() {
        return this.rowDimensionTree.tree.size;
    }
    get bottomFrozenRowCount() {
        if (!this._table.isPivotChart()) return this._table.internalProps.bottomFrozenRowCount ? this.rowCount - this.headerLevelCount >= this._table.internalProps.bottomFrozenRowCount ? this._table.internalProps.bottomFrozenRowCount : this.rowCount - this.headerLevelCount : 0;
        if (this.indicatorKeys.length >= 1 && checkHasCartesianChart(this.indicatorsDefine)) {
            const axisOption = this._table.pivotChartAxes.find((axisOption => "bottom" === axisOption.orient));
            return !1 === (null == axisOption ? void 0 : axisOption.visible) ? 0 : (this.indicatorsAsCol, 
            1);
        }
        return 0;
    }
    get rightFrozenColCount() {
        if (!this._table.isPivotChart()) return this._table.internalProps.rightFrozenColCount ? this.colCount - this.rowHeaderLevelCount >= this._table.internalProps.rightFrozenColCount ? this._table.internalProps.rightFrozenColCount : this.colCount - this.rowHeaderLevelCount : 0;
        const axisOption = this._table.pivotChartAxes.find((axisOption => "right" === axisOption.orient));
        return !1 === (null == axisOption ? void 0 : axisOption.visible) || this.indicatorsAsCol ? 0 : this.hasTwoIndicatorAxes ? 1 : 0;
    }
    get bodyRowCount() {
        return this.rowCount - this.bottomFrozenRowCount - this.headerLevelCount;
    }
    get bodyColCount() {
        return this.colCount - this.rightFrozenColCount - this.rowHeaderLevelCount;
    }
    get headerObjects() {
        return this._headerObjects;
    }
    get columnObjects() {
        return this._indicators;
    }
    getCellId(col, row) {
        var _a, _b, _c, _d, _e;
        if (row >= 0 && col >= 0) {
            if (this.isSeriesNumber(col, row)) return "";
            if (this.isCornerHeader(col, row)) return null === (_a = this._cornerHeaderCellIds[row]) || void 0 === _a ? void 0 : _a[col - this.leftRowSeriesNumberColumnCount];
            if (this.isColumnHeader(col, row)) return null === (_b = this._columnHeaderCellIds[row]) || void 0 === _b ? void 0 : _b[col - this.rowHeaderLevelCount - this.leftRowSeriesNumberColumnCount];
            if (this.isRowHeader(col, row)) return null === (_c = this._rowHeaderCellIds[row - this.columnHeaderLevelCount]) || void 0 === _c ? void 0 : _c[col - this.leftRowSeriesNumberColumnCount];
            if (this.isRightFrozenColumn(col, row)) return null === (_d = this._rowHeaderCellIds[row - this.columnHeaderLevelCount]) || void 0 === _d ? void 0 : _d[this.rowHeaderLevelCount - 1];
            if (this.isBottomFrozenRow(col, row)) return null === (_e = this._columnHeaderCellIds[this.columnHeaderLevelCount - 1]) || void 0 === _e ? void 0 : _e[col - this.rowHeaderLevelCount - this.leftRowSeriesNumberColumnCount];
        }
    }
    getHeader(col, row) {
        var _a;
        if (this.isSeriesNumberInHeader(col, row)) return this.getSeriesNumberHeader(col, row);
        const id = this.getCellId(col, row);
        return null !== (_a = this._headerObjectMap[id]) && void 0 !== _a ? _a : {
            id: void 0,
            field: "",
            headerType: "text",
            define: void 0
        };
    }
    getHeaderField(col, row) {
        var _a, _b;
        const id = this.getCellId(col, row);
        return (null === (_a = this._headerObjectMap[id]) || void 0 === _a ? void 0 : _a.field) || (null === (_b = this.getBody(col, row)) || void 0 === _b ? void 0 : _b.field);
    }
    getHeaderCellAdressById(id) {
        for (let i = 0; i < this._columnHeaderCellIds.length; i++) {
            const row = this._columnHeaderCellIds[i];
            for (let j = 0; j < row.length; j++) if (row[j] === id) return {
                col: j + this._table.frozenColCount,
                row: i
            };
        }
        for (let i = 0; i < this._rowHeaderCellIds.length; i++) {
            const row = this._rowHeaderCellIds[i];
            for (let j = 0; j < row.length; j++) if (row[j] === id) return {
                col: j,
                row: i + this._table.frozenRowCount
            };
        }
        for (let i = 0; i < this._cornerHeaderCellIds.length; i++) {
            const row = this._cornerHeaderCellIds[i];
            for (let j = 0; j < row.length; j++) if (row[j] === id) return {
                col: j,
                row: i
            };
        }
    }
    getHeaderCellAddressByField(field) {
        const hd = this.headerObjects.find((col => col && col.field === field));
        return hd && this.getHeaderCellAdressById(hd.id);
    }
    getBody(_col, _row) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        const cache = this.getBodyWidthCache(_col, _row);
        if (cache) return cache;
        if (this.isSeriesNumber(_col, _row)) {
            const body = this.getSeriesNumberBody(_col, _row);
            return this.setBodyWidthCache(_col, _row, body), body;
        }
        const paths = this.getCellHeaderPaths(_col, _row);
        if (this.indicatorsAsCol) {
            const indicatorKey = null === (_b = null === (_a = paths.colHeaderPaths) || void 0 === _a ? void 0 : _a.find((colPath => colPath.indicatorKey))) || void 0 === _b ? void 0 : _b.indicatorKey, body = isValid(indicatorKey) && null !== (_e = null !== (_d = null === (_c = this._indicators) || void 0 === _c ? void 0 : _c.find((indicator => indicator.indicatorKey === indicatorKey))) && void 0 !== _d ? _d : this._indicators[0]) && void 0 !== _e ? _e : {
                id: "",
                field: void 0,
                indicatorKey: void 0,
                cellType: "text",
                define: void 0
            };
            return this.setBodyWidthCache(_col, _row, body), body;
        }
        const indicatorKey = null === (_g = null === (_f = paths.rowHeaderPaths) || void 0 === _f ? void 0 : _f.find((rowPath => rowPath.indicatorKey))) || void 0 === _g ? void 0 : _g.indicatorKey, body = isValid(indicatorKey) && null !== (_k = null !== (_j = null === (_h = this._indicators) || void 0 === _h ? void 0 : _h.find((indicator => indicator.indicatorKey === indicatorKey))) && void 0 !== _j ? _j : this._indicators[0]) && void 0 !== _k ? _k : {
            id: "",
            field: void 0,
            indicatorKey: void 0,
            cellType: "text",
            define: void 0
        };
        return this.setBodyWidthCache(_col, _row, body), body;
    }
    getCellRange(col, row) {
        var _a, _b;
        const result = {
            start: {
                col: col,
                row: row
            },
            end: {
                col: col,
                row: row
            }
        };
        if (!this.isHeader(col, row) || -1 === col || -1 === row) return result;
        if (this.isRightFrozenColumn(col, row) || this.isBottomFrozenRow(col, row)) return result;
        if (this._table.isPivotChart()) {
            if (this.isLeftBottomCorner(col, row)) return {
                start: {
                    col: 0,
                    row: this.rowCount - this.bottomFrozenRowCount
                },
                end: {
                    col: this.frozenColCount - 1,
                    row: this.rowCount - 1
                }
            };
            if (this.isRightTopCorner(col, row)) return {
                start: {
                    col: this.colCount - this.rightFrozenColCount,
                    row: 0
                },
                end: {
                    col: this.colCount - 1,
                    row: this.frozenRowCount - 1
                }
            };
            if (this.isRightBottomCorner(col, row)) return {
                start: {
                    col: this.colCount - this.rightFrozenColCount,
                    row: this.rowCount - this.bottomFrozenRowCount
                },
                end: {
                    col: this.colCount - 1,
                    row: this.rowCount - 1
                }
            };
        }
        for (let i = 0; i < this._largeCellRangeCache.length; i++) {
            const range = this._largeCellRangeCache[i];
            if (col >= range.start.col && col <= range.end.col && row >= range.start.row && row <= range.end.row) return range;
        }
        if (this.isHeader(col, row) && -1 !== col && -1 !== row) {
            const id = this.getCellId(col, row);
            for (let c = col - 1; c >= 0 && id === this.getCellId(c, row); c--) result.start.col = c;
            for (let c = col + 1; c < (null !== (_a = this.colCount) && void 0 !== _a ? _a : 0) && id === this.getCellId(c, row); c++) result.end.col = c;
            for (let r = row - 1; r >= 0 && id === this.getCellId(col, r); r--) result.start.row = r;
            for (let r = row + 1; r < (null !== (_b = this.rowCount) && void 0 !== _b ? _b : 0) && !(id !== this.getCellId(col, r) || this.isSeriesNumberInHeader(col, row) && r >= this.columnHeaderLevelCount); r++) result.end.row = r;
        }
        return (result.end.col - result.start.col > 100 || result.end.row - result.start.row > 100) && this._largeCellRangeCache.push(result), 
        result;
    }
    isCellRangeEqual(col, row, targetCol, targetRow) {
        const range1 = this.getCellRange(col, row), range2 = this.getCellRange(targetCol, targetRow);
        return range1.start.col === range2.start.col && range1.end.col === range2.end.col && range1.start.row === range2.start.row && range1.end.row === range2.end.row;
    }
    getBodyIndexByRow(row) {
        return row < this.columnHeaderLevelCount || row >= this.rowCount - this.bottomHeaderRowCount ? -1 : row - this.columnHeaderLevelCount;
    }
    get bottomHeaderRowCount() {
        return this._table.isPivotChart() ? this.bottomFrozenRowCount : 0;
    }
    get rightHeaderColCount() {
        return this._table.isPivotChart() ? this.rightFrozenColCount : 0;
    }
    getBodyIndexByCol(col) {
        return col < this.rowHeaderLevelCount + this.leftRowSeriesNumberColumnCount || col >= this.colCount - this.rightHeaderColCount ? -1 : col - this.rowHeaderLevelCount - this.leftRowSeriesNumberColumnCount;
    }
    getRecordStartRowByRecordIndex(index) {
        return this.columnHeaderLevelCount + index;
    }
    getRecordShowIndexByCell(col, row) {}
    getCellHeaderPathsWithTreeNode(col, row) {
        let _largeCellRangeCacheIndex = -1;
        for (let i = 0; i < this._largeCellRangeCache.length; i++) {
            const range = this._largeCellRangeCache[i];
            if (col >= range.start.col && col <= range.end.col && row >= range.start.row && row <= range.end.row) {
                _largeCellRangeCacheIndex = i;
                break;
            }
        }
        let colPath = this.getColHeaderPathCache(col, row), rowPath = this.getRowHeaderPathCache(col, row);
        const recordCol = this.getBodyIndexByCol(col), recordRow = this.getBodyIndexByRow(row) + this.currentPageStartIndex;
        if (!colPath && row >= 0 && recordCol >= 0) {
            if (colPath = [], "grid-tree" === this.columnHierarchyType) {
                const col_pathIds = [];
                this._columnHeaderCellFullPathIds.map((arr => {
                    col_pathIds.push(arr[recordCol]);
                }));
                const findedRowPath = this.getTreePathByCellIds(col_pathIds);
                colPath.push(...findedRowPath);
            } else colPath = this.columnDimensionTree.getTreePath(recordCol, this.showHeader && this.showColumnHeader ? row - (this.columnHeaderTitle ? 1 : 0) : this.columnDimensionTree.totalLevel);
            this.setColHeaderPathCache(col, row, colPath);
        }
        if (!rowPath && col >= 0 && recordRow >= 0) {
            if (rowPath = [], "tree" === this.rowHierarchyType) {
                const row_pathIds = this._rowHeaderCellFullPathIds[recordRow];
                let findTree = this.rowDimensionTree, level = 0;
                for (;findTree && row_pathIds; ) {
                    const pathIds = [];
                    let cellId = row_pathIds[level];
                    for (pathIds.push(cellId); ;) {
                        const hd = this._headerObjectMap[cellId];
                        if (!(null == hd ? void 0 : hd.parentCellId)) break;
                        pathIds.unshift(hd.parentCellId), cellId = hd.parentCellId;
                    }
                    const findedRowPath = this.getTreePathByCellIds(pathIds);
                    rowPath.push(...findedRowPath), findTree = this._rowHeaderExtensionTree[row_pathIds[level]], 
                    level++;
                }
            } else if ("grid-tree" === this.rowHierarchyType) {
                const row_pathIds = this._rowHeaderCellFullPathIds[recordRow], findedRowPath = this.getTreePathByCellIds(row_pathIds);
                rowPath.push(...findedRowPath);
            } else rowPath = this.rowDimensionTree.getTreePath(recordRow, this.showHeader && this.showRowHeader ? col - (this.rowHeaderTitle ? 1 : 0) - this.leftRowSeriesNumberColumnCount : this.rowDimensionTree.totalLevel);
            this.setRowHeaderPathCache(col, row, rowPath);
        }
        return {
            colHeaderPaths: colPath,
            rowHeaderPaths: rowPath,
            cellLocation: this.getCellLocation(col, row)
        };
    }
    getTreePathByCellIds(row_pathIds) {
        const paths = [];
        for (let i = 0; i < row_pathIds.length; i++) {
            const id = row_pathIds[i];
            if (i > 0 && id === row_pathIds[i - 1]) continue;
            const hd = this._headerObjects[id];
            (null == hd ? void 0 : hd.define) && paths.push(hd.define);
        }
        return paths;
    }
    getCellHeaderPaths(col, row) {
        var _a, _b;
        const headerPathsWidthNode = this.getCellHeaderPathsWithTreeNode(col, row), headerPaths = {
            colHeaderPaths: [],
            rowHeaderPaths: [],
            cellLocation: headerPathsWidthNode.cellLocation
        };
        return null === (_a = headerPathsWidthNode.colHeaderPaths) || void 0 === _a || _a.forEach((colHeader => {
            var _a, _b, _c;
            const colHeaderPath = {};
            colHeaderPath.dimensionKey = colHeader.dimensionKey, colHeaderPath.indicatorKey = colHeader.indicatorKey, 
            colHeaderPath.value = null !== (_c = null !== (_a = colHeader.value) && void 0 !== _a ? _a : null === (_b = this.getIndicatorInfoByIndicatorKey(colHeader.indicatorKey)) || void 0 === _b ? void 0 : _b.title) && void 0 !== _c ? _c : "", 
            colHeaderPath.virtual = colHeader.virtual, colHeaderPath.role = colHeader.role, 
            headerPaths.colHeaderPaths.push(colHeaderPath);
        })), null === (_b = headerPathsWidthNode.rowHeaderPaths) || void 0 === _b || _b.forEach((rowHeader => {
            var _a, _b, _c;
            if ("axis" !== rowHeader.dimensionKey) {
                const rowHeaderPath = {};
                rowHeaderPath.dimensionKey = rowHeader.dimensionKey, rowHeaderPath.indicatorKey = rowHeader.indicatorKey, 
                rowHeaderPath.value = null !== (_c = null !== (_a = rowHeader.value) && void 0 !== _a ? _a : null === (_b = this.getIndicatorInfoByIndicatorKey(rowHeader.indicatorKey)) || void 0 === _b ? void 0 : _b.title) && void 0 !== _c ? _c : "", 
                rowHeaderPath.virtual = rowHeader.virtual, rowHeaderPath.role = rowHeader.role, 
                headerPaths.rowHeaderPaths.push(rowHeaderPath);
            }
        })), headerPaths;
    }
    getIndicatorInfoByIndicatorKey(indicatorKey) {
        var _a;
        return null === (_a = this.indicatorsDefine) || void 0 === _a ? void 0 : _a.find((indicator => "string" != typeof indicator && (!!indicatorKey && indicator.indicatorKey === indicatorKey)));
    }
    findFullCellIds(row_pathIds) {
        const pathIds = [];
        for (let level = 0; level < row_pathIds.length; level++) {
            let cellId = row_pathIds[level];
            for (pathIds.push(cellId); ;) {
                const hd = this._headerObjectMap[cellId];
                if (!(null == hd ? void 0 : hd.parentCellId)) break;
                pathIds.unshift(hd.parentCellId), cellId = hd.parentCellId;
            }
        }
        return pathIds;
    }
    getHeaderDimension(col, row) {
        var _a, _b, _c;
        if (this.isHeader(col, row)) {
            const header = this.getHeader(col, row);
            return null !== (_b = null === (_a = this.rowsDefine) || void 0 === _a ? void 0 : _a.find((dimension => "string" != typeof dimension && dimension.dimensionKey === header.field))) && void 0 !== _b ? _b : null === (_c = this.columnsDefine) || void 0 === _c ? void 0 : _c.find((dimension => "string" != typeof dimension && dimension.dimensionKey === header.field));
        }
    }
    isColumnIndicatorHeader(col, row) {
        return "column" === this._indicatorShowType && row === this.columnHeaderLevelCount - 1 && col >= this.rowHeaderLevelCount;
    }
    isRowIndicatorHeader(col, row) {
        return "row" === this._indicatorShowType && col === this.rowHeaderLevelCount - 1 && row >= this.columnHeaderLevelCount;
    }
    isIndicatorHeader(col, row) {
        return this.isColumnIndicatorHeader(col, row) || this.isRowIndicatorHeader(col, row);
    }
    toggleHierarchyState(col, row) {
        var _a, _b, _c, _d, _e, _f;
        this.colIndex = 0;
        const lastLevelIndex = (this.indicatorsAsCol ? this.rowHeaderLevelCount - 1 : this.rowHeaderLevelCount - 2) - this.leftRowSeriesNumberColumnCount, oldRowHeaderCellIds = this._rowHeaderCellFullPathIds_FULL.slice(0), oldRowHeaderCellPositons = oldRowHeaderCellIds.map(((id, row) => ({
            col: col,
            row: row + this.columnHeaderLevelCount
        }))), hd = this.getHeader(col, row);
        if (hd.define.hierarchyState = hd.define.hierarchyState === HierarchyState.collapse ? HierarchyState.expand : HierarchyState.collapse, 
        this.rowDimensionTree.reset(this.rowDimensionTree.tree.children), this.resetRowHeaderLevelCount(), 
        this._rowHeaderCellFullPathIds_FULL = [], this.rowDimensionKeys = this.rowDimensionTree.dimensionKeysIncludeVirtual.valueArr(), 
        this.fullRowDimensionKeys = [], this.fullRowDimensionKeys = this.fullRowDimensionKeys.concat(this.rowDimensionKeys), 
        "tree" === this.rowHierarchyType) this._addHeadersForTreeMode(this._rowHeaderCellFullPathIds_FULL, 0, this.rowDimensionTree.tree.children, [], this.rowDimensionTree.totalLevel, !0, this.rowsDefine, this.rowHeaderObjs); else if ("grid-tree" === this.rowHierarchyType) {
            const startRow = 0;
            this._addHeadersForGridTreeMode(this._rowHeaderCellFullPathIds_FULL, startRow, this.rowDimensionTree.tree.children, [], this.rowDimensionTree.totalLevel, this._getRowHeaderTreeExpandedMaxLevelCount(), !0, this.rowsDefine, this.rowHeaderObjs, !0), 
            this.cornerHeaderObjs = this._addCornerHeaders(this.colDimensionKeys, this.rowDimensionKeys, this.columnsDefine.concat(...this.rowsDefine));
        }
        if (this.rowHeaderTitle) {
            const id = ++this.sharedVar.seqId, firstColIds = Array(this.rowCount - this.columnHeaderLevelCount).fill(id);
            this._rowHeaderCellFullPathIds_FULL.unshift(firstColIds);
            const cell = {
                id: id,
                title: "string" == typeof this.rowHeaderTitle.title ? this.rowHeaderTitle.title : this.rowsDefine.reduce(((title, value) => "string" == typeof value ? title : title + (title ? `/${value.title}` : `${value.title}`)), ""),
                field: void 0,
                headerType: null !== (_b = null === (_a = this.rowHeaderTitle) || void 0 === _a ? void 0 : _a.headerType) && void 0 !== _b ? _b : "text",
                style: null === (_c = this.rowHeaderTitle) || void 0 === _c ? void 0 : _c.headerStyle,
                define: {
                    field: "",
                    headerType: "text",
                    cellType: "text",
                    disableHeaderHover: !!(null === (_d = this.rowHeaderTitle) || void 0 === _d ? void 0 : _d.disableHeaderHover),
                    disableHeaderSelect: !!(null === (_e = this.rowHeaderTitle) || void 0 === _e ? void 0 : _e.disableHeaderSelect)
                }
            };
            this.rowHeaderObjs.push(cell), this._headerObjects[id] = cell;
        }
        let diffCell;
        if (this._rowHeaderCellFullPathIds_FULL = transpose(this._rowHeaderCellFullPathIds_FULL), 
        "tree" === this.rowHierarchyType && (null === (_f = this.extensionRows) || void 0 === _f ? void 0 : _f.length) >= 1 && this.generateExtensionRowTree(), 
        this.colIndex = 0, this._headerObjectMap = this._headerObjects.reduce(((o, e) => (o[e.id] = e, 
        o)), {}), this._CellHeaderPathMap = new Map, this._largeCellRangeCache.length = 0, 
        "tree" === this.rowHierarchyType) diffCell = diffCellAddress(col, row, oldRowHeaderCellIds.map((oldCellId => oldCellId[col - this.leftRowSeriesNumberColumnCount])), this._rowHeaderCellFullPathIds_FULL.map((newCellId => newCellId[col - this.leftRowSeriesNumberColumnCount])), oldRowHeaderCellPositons, this); else {
            const new_lastLevelIndex = (this.indicatorsAsCol ? this.rowHeaderLevelCount - 1 : this.rowHeaderLevelCount - 2) - this.leftRowSeriesNumberColumnCount;
            diffCell = diffCellAddressForGridTree(col, row, oldRowHeaderCellIds.map((oldCellId => oldCellId[lastLevelIndex])), this._rowHeaderCellFullPathIds_FULL.map((newCellId => newCellId[new_lastLevelIndex])), oldRowHeaderCellPositons, this);
        }
        return this.generateCellIdsConsiderHideHeader(), this.setPagination(this.pagination), 
        "grid-tree" === this.rowHierarchyType && this.setColumnWidths(), diffCell;
    }
    toggleHierarchyStateForColumnTree(col, row) {
        var _a, _b, _c, _d, _e;
        this.colIndex = 0;
        const lastLevelIndex = this.indicatorsAsCol ? this.columnHeaderLevelCount - 2 : this.columnHeaderLevelCount - 1, oldColumnHeaderCellIds = this._columnHeaderCellFullPathIds.slice(0), oldColumnHeaderCellPositons = oldColumnHeaderCellIds[this.columnHeaderLevelCount - 1].map(((id, col) => ({
            col: col + this.rowHeaderLevelCount,
            row: row
        }))), hd = this.getHeader(col, row);
        if (hd.define.hierarchyState = hd.define.hierarchyState === HierarchyState.collapse ? HierarchyState.expand : HierarchyState.collapse, 
        this.columnDimensionTree.reset(this.columnDimensionTree.tree.children), this.resetColumnHeaderLevelCount(), 
        this._columnHeaderCellFullPathIds = [], this.colDimensionKeys = this.columnDimensionTree.dimensionKeysIncludeVirtual.valueArr(), 
        "grid-tree" === this.columnHierarchyType) {
            const startRow = 0;
            this._addHeadersForGridTreeMode(this._columnHeaderCellFullPathIds, startRow, this.columnDimensionTree.tree.children, [], this.columnDimensionTree.totalLevel, this._getColumnHeaderTreeExpandedMaxLevelCount(), !0, this.columnsDefine, this.columnHeaderObjs, !1), 
            this.cornerHeaderObjs = this._addCornerHeaders(this.colDimensionKeys, this.rowDimensionKeys, this.columnsDefine.concat(...this.rowsDefine));
        }
        if (this.columnHeaderTitle) {
            const id = ++this.sharedVar.seqId, firstRowIds = Array(this.colCount - this.rowHeaderLevelCount - this.rightFrozenColCount).fill(id);
            this._columnHeaderCellFullPathIds.unshift(firstRowIds);
            const cell = {
                id: id,
                title: "string" == typeof this.columnHeaderTitle.title ? this.columnHeaderTitle.title : this.columnsDefine.reduce(((title, value) => "string" == typeof value ? title : title + (title ? `/${value.title}` : `${value.title}`)), ""),
                field: void 0,
                headerType: null !== (_b = null === (_a = this.columnHeaderTitle) || void 0 === _a ? void 0 : _a.headerType) && void 0 !== _b ? _b : "text",
                style: null === (_c = this.columnHeaderTitle) || void 0 === _c ? void 0 : _c.headerStyle,
                define: {
                    id: id,
                    disableHeaderHover: !!(null === (_d = this.columnHeaderTitle) || void 0 === _d ? void 0 : _d.disableHeaderHover),
                    disableHeaderSelect: !!(null === (_e = this.columnHeaderTitle) || void 0 === _e ? void 0 : _e.disableHeaderSelect)
                }
            };
            this.columnHeaderObjs.push(cell), this._headerObjects[id] = cell;
        }
        this.colIndex = 0, this._headerObjectMap = this._headerObjects.reduce(((o, e) => (o[e.id] = e, 
        o)), {}), this._CellHeaderPathMap = new Map, this._largeCellRangeCache.length = 0;
        const new_lastLevelIndex = this.indicatorsAsCol ? this.columnHeaderLevelCount - 2 : this.columnHeaderLevelCount - 1, diffCell = diffCellAddressForGridTreeOnColumn(col, row, oldColumnHeaderCellIds[lastLevelIndex], this._columnHeaderCellFullPathIds[new_lastLevelIndex], oldColumnHeaderCellPositons, this);
        return this.generateCellIdsConsiderHideHeader(), "grid-tree" === this.columnHierarchyType && this.setColumnWidths(), 
        diffCell;
    }
    isHeaderForColWidth(col, row) {
        return this.isHeader(col, row);
    }
    getHeaderForColWidth(col, row) {
        return this.getHeader(col, row);
    }
    getPivotCellAdress(dimensions) {
        var _a;
        if (!Array.isArray(dimensions)) return;
        let rowDimension, colDimension, rowArr = this.rowTree, colArr = this.columnTree;
        for (let i = 0; i < dimensions.length; i++) {
            const highlightDimension = dimensions[i];
            if ((highlightDimension.isPivotCorner || !isValid(highlightDimension.value)) && i === dimensions.length - 1) {
                if ("row" === (null === (_a = null == this ? void 0 : this.cornerSetting) || void 0 === _a ? void 0 : _a.titleOnDimension)) {
                    let col = 0;
                    return "grid" === this.rowHierarchyType && (col = this.rowDimensionKeys.indexOf(highlightDimension.dimensionKey)), 
                    -1 === col ? void 0 : {
                        col: (this.rowHeaderTitle ? col + 1 : col) + this.leftRowSeriesNumberColumnCount,
                        row: 0
                    };
                }
                const row = this.colDimensionKeys.indexOf(highlightDimension.dimensionKey);
                return -1 === row ? void 0 : {
                    col: 0 + this.leftRowSeriesNumberColumnCount,
                    row: this.columnHeaderTitle ? row + 1 : row
                };
            }
            let isCol = !1;
            for (let j = 0; j < colArr.length; j++) {
                const dimension = colArr[j];
                if ((isValid(highlightDimension.dimensionKey) && dimension.dimensionKey === highlightDimension.dimensionKey || isValid(highlightDimension.indicatorKey) && dimension.indicatorKey === highlightDimension.indicatorKey) && dimension.value === highlightDimension.value) {
                    colArr = dimension.children, colDimension = dimension, isCol = !0;
                    break;
                }
            }
            if (!isCol) for (let k = 0; k < rowArr.length; k++) {
                const dimension = rowArr[k];
                if ((isValid(highlightDimension.dimensionKey) && dimension.dimensionKey === highlightDimension.dimensionKey || isValid(highlightDimension.indicatorKey) && dimension.indicatorKey === highlightDimension.indicatorKey) && dimension.value === highlightDimension.value) {
                    rowArr = dimension.children, rowDimension = dimension;
                    break;
                }
            }
        }
        let col = 0, row = 0;
        if (rowDimension) {
            row = this.columnHeaderLevelCount;
            const {startInTotal: startInTotal, afterSpanLevel: afterSpanLevel} = rowDimension;
            return row += startInTotal, col = "grid" === this.rowHierarchyType ? (this.rowHeaderTitle ? afterSpanLevel + 1 : afterSpanLevel) + this.leftRowSeriesNumberColumnCount : 0 + this.leftRowSeriesNumberColumnCount, 
            {
                col: col,
                row: row
            };
        }
        if (colDimension) {
            col = this.rowHeaderLevelCount + this.leftRowSeriesNumberColumnCount;
            const {startInTotal: startInTotal, afterSpanLevel: afterSpanLevel} = colDimension;
            return col += startInTotal, row = this.columnHeaderTitle ? afterSpanLevel + 1 : afterSpanLevel, 
            {
                col: col,
                row: row
            };
        }
    }
    getPivotDimensionInfo(col, row) {
        var _a;
        const {colHeaderPaths: colHeaderPaths, rowHeaderPaths: rowHeaderPaths} = this.getCellHeaderPaths(col, row), pivotInfo = [];
        return colHeaderPaths.length ? colHeaderPaths.forEach(((path, i) => {
            pivotInfo.push({
                dimensionKey: path.dimensionKey,
                value: path.value,
                isPivotCorner: !1,
                indicatorKey: path.indicatorKey
            });
        })) : rowHeaderPaths.length ? rowHeaderPaths.forEach(((path, i) => {
            pivotInfo.push({
                dimensionKey: path.dimensionKey,
                value: path.value,
                isPivotCorner: !1,
                indicatorKey: path.indicatorKey
            });
        })) : this.isCornerHeader(col, row) && ("row" === (null === (_a = null == this ? void 0 : this.cornerSetting) || void 0 === _a ? void 0 : _a.titleOnDimension) ? pivotInfo.push({
            dimensionKey: this.rowDimensionKeys[(this.rowHeaderTitle ? col - 1 : col) - this.leftRowSeriesNumberColumnCount],
            isPivotCorner: !0
        }) : pivotInfo.push({
            dimensionKey: this.colDimensionKeys[this.columnHeaderTitle ? row - 1 : row],
            isPivotCorner: !0
        })), pivotInfo;
    }
    getIndicatorKey(col, row) {
        var _a;
        return null === (_a = this.getBody(col, row)) || void 0 === _a ? void 0 : _a.indicatorKey;
    }
    getParentCellId(col, row) {
        if (0 !== row) return this.isColumnHeader(col, row) ? this.getCellId(col, row - 1) : this.isRowHeader(col, row) ? this.getCellId(col - 1, row) : void 0;
    }
    getRowHeaderCellAddressByCellId(cellId) {
        let col, row;
        if (this._rowHeaderCellIds.find(((cellIds, rowIndex) => !!cellIds.find(((id, colIndex) => id === cellId && (col = colIndex, 
        !0))) && (row = rowIndex, !0))), isValid(col) && isValid(row)) return {
            col: col,
            row: row + this.columnHeaderLevelCount
        };
    }
    canMoveHeaderPosition(source, target) {
        if (this.isSeriesNumberInHeader(target.col, target.row) || this.isSeriesNumberInHeader(source.col, source.row)) return !1;
        if (this.isCornerHeader(target.col, target.row)) return !1;
        if (source.col < 0 || source.row < 0 || target.col < 0 || target.row < 0) return !1;
        this.isSeriesNumberInBody(target.col, target.row) && this.isSeriesNumberInBody(source.col, source.row) && (source.col = source.col + this.leftRowSeriesNumberColumnCount + this.rowHeaderLevelCount - 1, 
        target.col = target.col + this.leftRowSeriesNumberColumnCount + this.rowHeaderLevelCount - 1);
        const sourceCellRange = this.getCellRange(source.col, source.row);
        if (this.isColumnHeader(source.col, source.row)) {
            return this.getParentCellId(source.col, sourceCellRange.start.row) === this.getParentCellId(target.col, sourceCellRange.start.row);
        }
        if (this.isRowHeader(source.col, source.row)) {
            if ("tree" !== this.rowHierarchyType) {
                return this.getParentCellId(sourceCellRange.start.col, source.row) === this.getParentCellId(sourceCellRange.start.col, target.row);
            }
            {
                const sourceRowHeaderPaths = cloneDeep(this.getCellHeaderPathsWithTreeNode(source.col, source.row).rowHeaderPaths), targetRowHeaderPaths = cloneDeep(this.getCellHeaderPathsWithTreeNode(target.col, target.row).rowHeaderPaths);
                if (sourceRowHeaderPaths.pop(), targetRowHeaderPaths.pop(), sourceRowHeaderPaths.length <= targetRowHeaderPaths.length) {
                    if (sourceRowHeaderPaths.length === targetRowHeaderPaths.length) return !sourceRowHeaderPaths.find(((item, i) => item.dimensionKey !== targetRowHeaderPaths[i].dimensionKey || item.value !== targetRowHeaderPaths[i].value));
                    if (sourceRowHeaderPaths.length > 0) for (let i = 0; i < sourceRowHeaderPaths.length; i++) if (sourceRowHeaderPaths[i].startInTotal !== targetRowHeaderPaths[i].startInTotal) return !1;
                    return !0;
                }
            }
        }
        return !1;
    }
    moveHeaderPosition(source, target) {
        var _a, _b;
        if ((!(null === (_a = this._table.options.dragOrder) || void 0 === _a ? void 0 : _a.validateDragOrderOnEnd) || (null === (_b = this._table.options.dragOrder) || void 0 === _b ? void 0 : _b.validateDragOrderOnEnd(source, target))) && this.canMoveHeaderPosition(source, target) && !this.isCellRangeEqual(source.col, source.row, target.col, target.row)) {
            const sourceCellRange = this.getCellRange(source.col, source.row);
            if (this.isColumnHeader(source.col, source.row)) {
                const sourceSize = sourceCellRange.end.col - sourceCellRange.start.col + 1;
                let targetIndex;
                const targetCellRange = this.getCellRange(target.col, sourceCellRange.start.row);
                if (targetIndex = target.col >= source.col ? targetCellRange.end.col - sourceSize + 1 : targetCellRange.start.col, 
                targetIndex === sourceCellRange.start.col) return null;
                for (let row = 0; row < this._columnHeaderCellFullPathIds.length; row++) {
                    const sourceIds = this._columnHeaderCellFullPathIds[row].splice(sourceCellRange.start.col - this.rowHeaderLevelCount - this.leftRowSeriesNumberColumnCount, sourceSize);
                    sourceIds.unshift(targetIndex - this.rowHeaderLevelCount - this.leftRowSeriesNumberColumnCount, 0), 
                    Array.prototype.splice.apply(this._columnHeaderCellFullPathIds[row], sourceIds);
                }
                const sourceColumns = this._columnWidths.splice(sourceCellRange.start.col - this.leftRowSeriesNumberColumnCount, sourceSize);
                return sourceColumns.unshift(targetIndex - this.leftRowSeriesNumberColumnCount, 0), 
                Array.prototype.splice.apply(this._columnWidths, sourceColumns), this.columnDimensionTree.movePosition(this.getCellHeaderPathsWithTreeNode(source.col, source.row).colHeaderPaths.length - 1, sourceCellRange.start.col - this.rowHeaderLevelCount - this.leftRowSeriesNumberColumnCount, targetCellRange.start.col - this.rowHeaderLevelCount - this.leftRowSeriesNumberColumnCount), 
                this.columnDimensionTree.reset(this.columnDimensionTree.tree.children), this._CellHeaderPathMap = new Map, 
                this._largeCellRangeCache.length = 0, {
                    sourceIndex: sourceCellRange.start.col,
                    targetIndex: targetIndex,
                    sourceSize: sourceSize,
                    targetSize: targetCellRange.end.col - targetCellRange.start.col + 1,
                    moveType: "column"
                };
            }
            if (this.isRowHeader(source.col, source.row)) {
                let targetIndex;
                const sourceRowHeaderPaths = this.getCellHeaderPathsWithTreeNode(source.col, source.row).rowHeaderPaths, targetRowHeaderPaths = this.getCellHeaderPathsWithTreeNode(target.col, target.row).rowHeaderPaths, sourceRowHeaderNode = sourceRowHeaderPaths[sourceRowHeaderPaths.length - 1], targetRowHeaderNode = targetRowHeaderPaths[sourceRowHeaderPaths.length - 1], sourceSize = sourceRowHeaderNode.size;
                if (targetIndex = target.row >= source.row ? targetRowHeaderNode.startInTotal + targetRowHeaderNode.size - sourceSize : targetRowHeaderNode.startInTotal, 
                targetIndex === sourceCellRange.start.row - this.columnHeaderLevelCount) return null;
                const sourceIds = this._rowHeaderCellIds.splice(sourceCellRange.start.row - this.columnHeaderLevelCount, sourceSize);
                sourceIds.unshift(targetIndex - this.currentPageStartIndex, 0), Array.prototype.splice.apply(this._rowHeaderCellIds, sourceIds);
                const sourceIds0 = this._rowHeaderCellFullPathIds.splice(sourceCellRange.start.row - this.columnHeaderLevelCount, sourceSize);
                sourceIds0.unshift(targetIndex - this.currentPageStartIndex, 0), Array.prototype.splice.apply(this._rowHeaderCellFullPathIds, sourceIds0);
                const sourceIds_FULL = this._rowHeaderCellIds_FULL.splice(sourceCellRange.start.row - this.columnHeaderLevelCount + this.currentPageStartIndex, sourceSize);
                sourceIds_FULL.unshift(targetIndex, 0), Array.prototype.splice.apply(this._rowHeaderCellIds_FULL, sourceIds_FULL);
                const sourceIds_FULL0 = this._rowHeaderCellFullPathIds_FULL.splice(sourceCellRange.start.row - this.columnHeaderLevelCount + this.currentPageStartIndex, sourceSize);
                return sourceIds_FULL0.unshift(targetIndex, 0), Array.prototype.splice.apply(this._rowHeaderCellFullPathIds_FULL, sourceIds_FULL0), 
                this.rowDimensionTree.movePosition(sourceRowHeaderPaths.length - 1, sourceCellRange.start.row - this.columnHeaderLevelCount, targetIndex + (target.row > source.row ? sourceRowHeaderNode.size - 1 : 0)), 
                this.rowDimensionTree.reset(this.rowDimensionTree.tree.children), this._CellHeaderPathMap = new Map, 
                this._largeCellRangeCache.length = 0, {
                    sourceIndex: sourceCellRange.start.row,
                    targetIndex: targetIndex + this.columnHeaderLevelCount,
                    sourceSize: sourceSize,
                    targetSize: targetRowHeaderNode.size,
                    moveType: "row"
                };
            }
        }
        return null;
    }
    getCellAdressByHeaderPath(dimensionPaths) {
        var _a, _b, _c, _d, _e, _f;
        let colHeaderPaths, rowHeaderPaths, isCornerCell = !1, forceBody = !1;
        if (Array.isArray(dimensionPaths)) {
            if (dimensionPaths.length > this.rowDimensionKeys.length + this.colDimensionKeys.length) return;
            colHeaderPaths = dimensionPaths.filter((path => this.colDimensionKeys.indexOf(path.dimensionKey) >= 0 || this.colDimensionKeys.indexOf(this.indicatorDimensionKey) >= 0 && path.indicatorKey)), 
            rowHeaderPaths = dimensionPaths.filter((path => this.rowDimensionKeys.indexOf(path.dimensionKey) >= 0 || this.rowDimensionKeys.indexOf(this.indicatorDimensionKey) >= 0 && path.indicatorKey));
        } else colHeaderPaths = dimensionPaths.colHeaderPaths, rowHeaderPaths = dimensionPaths.rowHeaderPaths, 
        "body" === (null == dimensionPaths ? void 0 : dimensionPaths.cellLocation) && this._table.isPivotTable() && (forceBody = !0);
        if (!Array.isArray(colHeaderPaths) && !Array.isArray(rowHeaderPaths)) return;
        if (null == colHeaderPaths || colHeaderPaths.sort(((a, b) => {
            var _a, _b;
            return this.colDimensionKeys.indexOf(null !== (_a = a.dimensionKey) && void 0 !== _a ? _a : this.indicatorDimensionKey) - this.colDimensionKeys.indexOf(null !== (_b = b.dimensionKey) && void 0 !== _b ? _b : this.indicatorDimensionKey);
        })), null == rowHeaderPaths || rowHeaderPaths.sort(((a, b) => {
            var _a, _b;
            return this.fullRowDimensionKeys.indexOf(null !== (_a = a.dimensionKey) && void 0 !== _a ? _a : this.indicatorDimensionKey) - this.fullRowDimensionKeys.indexOf(null !== (_b = b.dimensionKey) && void 0 !== _b ? _b : this.indicatorDimensionKey);
        })), null == colHeaderPaths || colHeaderPaths.forEach((a => {
            a.isPivotCorner && (isCornerCell = !0);
        })), null == rowHeaderPaths || rowHeaderPaths.forEach((a => {
            a.isPivotCorner && (isCornerCell = !0);
        })), isCornerCell) if ("all" === this.cornerSetting.titleOnDimension && this.indicatorsAsCol && 0 === colHeaderPaths.length) {
            for (let i = 0; i < this.rowDimensionKeys.length; i++) if ((null === (_a = rowHeaderPaths[0]) || void 0 === _a ? void 0 : _a.dimensionKey) === this.rowDimensionKeys[i]) return {
                col: i + this.leftRowSeriesNumberColumnCount,
                row: this.columnHeaderLevelCount - 1
            };
        } else if ("all" !== this.cornerSetting.titleOnDimension || this.indicatorsAsCol || 0 !== rowHeaderPaths.length) {
            if ("row" === this.cornerSetting.titleOnDimension || "all" === this.cornerSetting.titleOnDimension && !this.indicatorsAsCol) {
                for (let i = 0; i < this.rowDimensionKeys.length; i++) if ((null === (_c = rowHeaderPaths[0]) || void 0 === _c ? void 0 : _c.dimensionKey) === this.rowDimensionKeys[i]) return {
                    col: i + this.leftRowSeriesNumberColumnCount,
                    row: 0
                };
            } else for (let i = 0; i < this.colDimensionKeys.length; i++) if ((null === (_d = colHeaderPaths[0]) || void 0 === _d ? void 0 : _d.dimensionKey) === this.colDimensionKeys[i]) return {
                col: 0,
                row: i
            };
        } else for (let i = 0; i < this.colDimensionKeys.length; i++) if ((null === (_b = colHeaderPaths[0]) || void 0 === _b ? void 0 : _b.dimensionKey) === this.colDimensionKeys[i]) return {
            col: this.rowHeaderLevelCount - 1,
            row: i
        };
        let col, row, defaultCol, defaultRow, needLowestLevel_colPaths = !1, needLowestLevel_rowPaths = !1;
        (null == colHeaderPaths ? void 0 : colHeaderPaths.length) >= 1 && (null == rowHeaderPaths ? void 0 : rowHeaderPaths.length) >= 1 && (needLowestLevel_colPaths = !0, 
        needLowestLevel_rowPaths = !0), colHeaderPaths.length >= this._getColumnHeaderTreeExpandedMaxLevelCount() && (needLowestLevel_colPaths = !0), 
        rowHeaderPaths.length >= this._getRowHeaderTreeExpandedMaxLevelCount() && (needLowestLevel_rowPaths = !0);
        let rowDimensionFinded, colDimensionFinded, rowArr = this.rowTree, colArr = this.columnTree;
        if (colHeaderPaths) for (let i = 0; i < colHeaderPaths.length; i++) {
            const colDimension = colHeaderPaths[i];
            for (let j = 0; j < colArr.length; j++) {
                const dimension = colArr[j];
                if (!isValid(colDimension.indicatorKey) && dimension.dimensionKey === colDimension.dimensionKey && dimension.value === colDimension.value || isValid(colDimension.indicatorKey) && dimension.indicatorKey === colDimension.indicatorKey && (isValid(dimension.value) && isValid(colDimension.value) && colDimension.value === dimension.value || !isValid(dimension.value) || !isValid(colDimension.value))) {
                    colArr = dimension.children, needLowestLevel_colPaths && !(null == colArr ? void 0 : colArr.length) ? colDimensionFinded = dimension : needLowestLevel_colPaths || (colDimensionFinded = dimension);
                    break;
                }
            }
        }
        if ((null == rowHeaderPaths ? void 0 : rowHeaderPaths.length) >= 1) if ("tree" === this.rowHierarchyType) {
            const rowDimension = rowHeaderPaths[rowHeaderPaths.length - 1], cellIDs = this.headerObjects.filter((hd => ((null == hd ? void 0 : hd.field) === rowDimension.dimensionKey || (null == hd ? void 0 : hd.field) === rowDimension.indicatorKey) && (null == hd ? void 0 : hd.title) === rowDimension.value)).map((hd => hd.id)), findedCellIdPath = this._rowHeaderCellIds.filter((rowHdCellIDs => cellIDs.indexOf(rowHdCellIDs[rowHdCellIDs.length - 1]) >= 0)).find((pathIds => {
                const fullCellIds = this.findFullCellIds(pathIds);
                return fullCellIds.length === rowHeaderPaths.length && fullCellIds.every((id => {
                    const curHd = this._headerObjectMap[id];
                    return rowHeaderPaths.find((rowDimensionPath => rowDimensionPath.dimensionKey === curHd.field && rowDimensionPath.value === curHd.title));
                }));
            }));
            row = this._rowHeaderCellIds.indexOf(findedCellIdPath) + this.columnHeaderLevelCount;
        } else for (let i = 0; i < rowHeaderPaths.length; i++) {
            const rowDimension = rowHeaderPaths[i];
            for (let j = 0; j < rowArr.length; j++) {
                const dimension = rowArr[j];
                if (!isValid(rowDimension.indicatorKey) && dimension.dimensionKey === rowDimension.dimensionKey && dimension.value === rowDimension.value || isValid(rowDimension.indicatorKey) && dimension.indicatorKey === rowDimension.indicatorKey && (!isValid(rowDimension.value) || dimension.value === rowDimension.value)) {
                    rowArr = dimension.children, (!needLowestLevel_rowPaths || (null == rowArr ? void 0 : rowArr.length) && !rowArr.some((row => "axis" === row.dimensionKey))) && needLowestLevel_rowPaths || (rowDimensionFinded = dimension);
                    break;
                }
            }
        }
        if (forceBody || !needLowestLevel_colPaths || !needLowestLevel_rowPaths || (rowDimensionFinded || isValid(row)) && colDimensionFinded) {
            if (rowDimensionFinded || forceBody) {
                row = this.columnHeaderLevelCount;
                const {startInTotal: startInTotal, afterSpanLevel: afterSpanLevel} = null !== (_e = rowDimensionFinded) && void 0 !== _e ? _e : defaultDimension;
                row += null != startInTotal ? startInTotal : 0, defaultCol = "grid" === this.rowHierarchyType ? (this.rowHeaderTitle ? afterSpanLevel + 1 : afterSpanLevel) + this.leftRowSeriesNumberColumnCount : 0;
            }
            if (colDimensionFinded || forceBody) {
                col = this.rowHeaderLevelCount + this.leftRowSeriesNumberColumnCount;
                const {startInTotal: startInTotal, afterSpanLevel: afterSpanLevel} = null !== (_f = colDimensionFinded) && void 0 !== _f ? _f : defaultDimension;
                col += null != startInTotal ? startInTotal : 0, defaultRow = this.columnHeaderTitle ? afterSpanLevel + 1 : afterSpanLevel;
            }
            return isValid(col) || isValid(row) ? {
                col: null != col ? col : defaultCol,
                row: null != row ? row : defaultRow
            } : void 0;
        }
    }
    setChartInstance(_col, _row, chartInstance) {
        var _a, _b, _c, _d;
        const paths = this.getCellHeaderPaths(_col, _row);
        let indicatorObj;
        if (this.indicatorsAsCol) {
            const indicatorKey = null === (_a = paths.colHeaderPaths.find((colPath => colPath.indicatorKey))) || void 0 === _a ? void 0 : _a.indicatorKey;
            indicatorObj = null === (_b = this._indicators) || void 0 === _b ? void 0 : _b.find((indicator => indicator.indicatorKey === indicatorKey));
        } else {
            const indicatorKey = null === (_c = paths.rowHeaderPaths.find((rowPath => rowPath.indicatorKey))) || void 0 === _c ? void 0 : _c.indicatorKey;
            indicatorObj = null === (_d = this._indicators) || void 0 === _d ? void 0 : _d.find((indicator => indicator.indicatorKey === indicatorKey));
        }
        "function" != typeof (null == indicatorObj ? void 0 : indicatorObj.chartSpec) && indicatorObj && (indicatorObj.chartInstance = chartInstance);
    }
    getChartInstance(_col, _row) {
        var _a, _b, _c, _d;
        const paths = this.getCellHeaderPaths(_col, _row);
        let indicatorObj;
        if (this.indicatorsAsCol) {
            const indicatorKey = null === (_a = paths.colHeaderPaths.find((colPath => colPath.indicatorKey))) || void 0 === _a ? void 0 : _a.indicatorKey;
            indicatorObj = null === (_b = this._indicators) || void 0 === _b ? void 0 : _b.find((indicator => indicator.indicatorKey === indicatorKey));
        } else {
            const indicatorKey = null === (_c = paths.rowHeaderPaths.find((rowPath => rowPath.indicatorKey))) || void 0 === _c ? void 0 : _c.indicatorKey;
            indicatorObj = null === (_d = this._indicators) || void 0 === _d ? void 0 : _d.find((indicator => indicator.indicatorKey === indicatorKey));
        }
        return null == indicatorObj ? void 0 : indicatorObj.chartInstance;
    }
    checkHasChart() {
        return checkHasChart(this);
    }
    getDimension(dimensionKey, type) {
        var _a, _b;
        return "column" === type ? null === (_a = this.columnsDefine) || void 0 === _a ? void 0 : _a.find((dimension => "string" != typeof dimension && dimension.dimensionKey === dimensionKey)) : "row" === type ? null === (_b = this.rowsDefine) || void 0 === _b ? void 0 : _b.find((dimension => "string" != typeof dimension && dimension.dimensionKey === dimensionKey)) : void 0;
    }
    getAxisConfigInPivotChart(col, row) {
        if ((this.isFrozenColumn(col, row) || this.isRightFrozenColumn(col, row)) && isHasCartesianChartInline(col, row, "row", this) || (this.isFrozenRow(col, row) || this.isBottomFrozenRow(col, row)) && isHasCartesianChartInline(col, row, "col", this)) {
            const config = Factory.getFunction("getAxisConfigInPivotChart")(col, row, this);
            if (!1 === (null == config ? void 0 : config.visible)) return;
            return config;
        }
    }
    isEmpty(col, row) {
        return !!this._table.isPivotChart() && (!!this.isLeftBottomCorner(col, row) || (!!this.isRightBottomCorner(col, row) || !!this.isRightTopCorner(col, row)));
    }
    isAxisCell(col, row) {
        if (!this._table.isPivotChart()) return !1;
        if (this.indicatorKeys.length >= 1 && checkHasCartesianChart(this.indicatorsDefine)) {
            if (this.isBottomFrozenRow(col, row) && isHasCartesianChartInline(col, row, "col", this) || this.isRightFrozenColumn(col, row) && isHasCartesianChartInline(col, row, "row", this)) return !0;
            if (this.isRowHeader(col, row) && col === this.rowHeaderLevelCount - 1 && isHasCartesianChartInline(col, row, "row", this)) return !0;
            if (this.hasTwoIndicatorAxes && this.indicatorsAsCol && row === this.columnHeaderLevelCount - 1 && isHasCartesianChartInline(col, row, "col", this)) return !0;
        }
        return !1;
    }
    getChartAxes(col, row) {
        if (isCartesianChart(col, row, this) || this.isAxisCell(col, row)) return getChartAxes(col, row, this);
    }
    getRawChartSpec(col, row) {
        return getRawChartSpec(col, row, this);
    }
    getChartSpec(col, row) {
        return getChartSpec(col, row, this);
    }
    isShareChartSpec(col, row) {
        return isShareChartSpec(col, row, this);
    }
    getChartDataId(col, row) {
        return getChartDataId(col, row, this);
    }
    isNoChartDataRenderNothing(col, row) {
        return isNoChartDataRenderNothing(col, row, this);
    }
    setPagination(pagination) {
        var _a, _b, _c, _d, _e, _f, _g;
        if (this.clearCellRangeMap(), this._table.internalProps.useOneRowHeightFillAll = !1, 
        this.pagination = pagination, "grid" === this.rowHierarchyType && isValid(null === (_a = this.pagination) || void 0 === _a ? void 0 : _a.perPageCount) && isValid(null === (_b = this.pagination) || void 0 === _b ? void 0 : _b.currentPage)) {
            !1 === this.indicatorsAsCol && (this.pagination.perPageCount = Math.ceil(this.pagination.perPageCount / this.indicatorKeys.length) * this.indicatorKeys.length);
            const {perPageCount: perPageCount, currentPage: currentPage} = this.pagination;
            this.currentPageStartIndex = perPageCount * (currentPage || 0), this.currentPageEndIndex = this.currentPageStartIndex + perPageCount, 
            this._rowHeaderCellIds = null === (_c = this._rowHeaderCellIds_FULL) || void 0 === _c ? void 0 : _c.slice(this.currentPageStartIndex, this.currentPageEndIndex), 
            this._rowHeaderCellFullPathIds = null === (_d = this._rowHeaderCellFullPathIds_FULL) || void 0 === _d ? void 0 : _d.slice(this.currentPageStartIndex, this.currentPageEndIndex);
        } else this.currentPageStartIndex = 0, this.currentPageEndIndex = this._rowHeaderCellIds_FULL.length, 
        this._rowHeaderCellIds = null === (_e = this._rowHeaderCellIds_FULL) || void 0 === _e ? void 0 : _e.slice(this.currentPageStartIndex, this.currentPageEndIndex), 
        this._rowHeaderCellFullPathIds = null === (_f = this._rowHeaderCellFullPathIds_FULL) || void 0 === _f ? void 0 : _f.slice(this.currentPageStartIndex, this.currentPageEndIndex);
        this.pagination && (this.pagination.totalCount = null === (_g = this._rowHeaderCellIds_FULL) || void 0 === _g ? void 0 : _g.length);
    }
    release() {
        var _a;
        const activeChartInstance = this._table._getActiveChartInstance();
        null == activeChartInstance || activeChartInstance.release(), null === (_a = this._indicators) || void 0 === _a || _a.forEach((indicatorObject => {
            var _a;
            null === (_a = indicatorObject.chartInstance) || void 0 === _a || _a.release();
        }));
    }
    getHeadNode(col, row) {
        var _a, _b, _c;
        let dimensions;
        const headerPaths = this.getCellHeaderPaths(col, row);
        return headerPaths.rowHeaderPaths && (null !== (_b = null === (_a = headerPaths.rowHeaderPaths) || void 0 === _a ? void 0 : _a.length) && void 0 !== _b ? _b : 0) > 0 ? dimensions = null === (_c = headerPaths.rowHeaderPaths) || void 0 === _c ? void 0 : _c.slice(0, headerPaths.rowHeaderPaths.length) : headerPaths.colHeaderPaths && headerPaths.colHeaderPaths.length > 0 && (dimensions = headerPaths.colHeaderPaths.slice(0, headerPaths.colHeaderPaths.length)), 
        this.getHeadNodeByRowOrColDimensions(dimensions, col, row);
    }
    getHeadNodeByRowOrColDimensions(dimensions, col, row) {
        var _a;
        if (!Array.isArray(dimensions)) return;
        let rowDimension, colDimension, rowArr = this.rowTree, colArr = this.columnTree;
        if (isValid(row) && isValid(col) && "tree" === this.rowHierarchyType && this.extensionRows && col >= 1 + this.leftRowSeriesNumberColumnCount) {
            const hdId = this.getCellId(col - 1, row);
            rowArr = this._rowHeaderExtensionTree[hdId].tree.children;
        }
        for (let i = 0; i < dimensions.length; i++) {
            const highlightDimension = dimensions[i];
            if ((highlightDimension.isPivotCorner || !isValid(highlightDimension.value)) && i === dimensions.length - 1) return;
            let isCol = !1;
            for (let j = 0; j < colArr.length; j++) {
                const dimension = colArr[j];
                if (isValid(highlightDimension.dimensionKey) && dimension.dimensionKey === highlightDimension.dimensionKey && dimension.value === highlightDimension.value || isValid(highlightDimension.indicatorKey) && dimension.indicatorKey === highlightDimension.indicatorKey && (dimension.value === highlightDimension.value || !isValid(highlightDimension.value) || !isValid(dimension.value))) {
                    colArr = dimension.children, colDimension = dimension, isCol = !0;
                    break;
                }
            }
            if (!isCol) for (let k = 0; k < (null !== (_a = null == rowArr ? void 0 : rowArr.length) && void 0 !== _a ? _a : 0); k++) {
                const dimension = rowArr[k];
                if (isValid(highlightDimension.dimensionKey) && dimension.dimensionKey === highlightDimension.dimensionKey && dimension.value === highlightDimension.value || isValid(highlightDimension.indicatorKey) && dimension.indicatorKey === highlightDimension.indicatorKey && (dimension.value === highlightDimension.value || !isValid(highlightDimension.value) || !isValid(dimension.value))) {
                    rowArr = dimension.children, rowDimension = dimension;
                    break;
                }
            }
        }
        return rowDimension || (colDimension || void 0);
    }
    clearCellRangeMap() {
        this._largeCellRangeCache.length = 0, this._CellHeaderPathMap = new Map;
    }
    getDimensionKeyInChartSpec(_col, _row) {
        var _a, _b, _c, _d, _e, _f;
        let dimensionKey;
        if (!1 === this.indicatorsAsCol) for (let i = 0; i < this.indicatorsDefine.length; i++) {
            const chartSpec = this.indicatorsDefine[i].chartSpec;
            if (chartSpec && (dimensionKey = null !== (_a = chartSpec.xField) && void 0 !== _a ? _a : null === (_c = null === (_b = null == chartSpec ? void 0 : chartSpec.series) || void 0 === _b ? void 0 : _b[0]) || void 0 === _c ? void 0 : _c.xField, 
            dimensionKey)) return dimensionKey;
        } else for (let i = 0; i < this.indicatorsDefine.length; i++) {
            const chartSpec = this.indicatorsDefine[i].chartSpec;
            if (chartSpec && (dimensionKey = null !== (_d = chartSpec.yField) && void 0 !== _d ? _d : null === (_f = null === (_e = null == chartSpec ? void 0 : chartSpec.series) || void 0 === _e ? void 0 : _e[0]) || void 0 === _f ? void 0 : _f.yField, 
            dimensionKey)) return dimensionKey;
        }
        return null;
    }
    _generateChartState() {
        return {
            vtable_selected: {
                filter: datum => {
                    var _a;
                    if (this._table._selectedDataItemsInChart.length >= 1) {
                        return !!this._table._selectedDataItemsInChart.find((item => {
                            for (const itemKey in item) if ("object" != typeof item[itemKey] && item[itemKey] !== datum[itemKey]) return !1;
                            return !0;
                        }));
                    }
                    if (null === (_a = this._table._selectedDimensionInChart) || void 0 === _a ? void 0 : _a.length) {
                        return !!this._table._selectedDimensionInChart.every((item => "object" == typeof item.value || datum[item.key] === item.value));
                    }
                    return !1;
                }
            },
            vtable_selected_reverse: {
                filter: datum => {
                    var _a;
                    if (this._table._selectedDataItemsInChart.length >= 1) {
                        return !this._table._selectedDataItemsInChart.find((item => {
                            for (const itemKey in item) if ("object" != typeof item[itemKey] && item[itemKey] !== datum[itemKey]) return !1;
                            return !0;
                        }));
                    }
                    if (null === (_a = this._table._selectedDimensionInChart) || void 0 === _a ? void 0 : _a.length) {
                        return !this._table._selectedDimensionInChart.every((item => "object" == typeof item.value || datum[item.key] === item.value));
                    }
                    return !1;
                }
            }
        };
    }
    updateDataStateToChartInstance(activeChartInstance) {
        var _a;
        if (!1 !== (null === (_a = null == activeChartInstance ? void 0 : activeChartInstance.getSpec().select) || void 0 === _a ? void 0 : _a.enable)) {
            activeChartInstance || (activeChartInstance = this._table._getActiveChartInstance());
            const state = this._generateChartState();
            this._indicators.forEach((_indicatorObject => {
                var _a;
                const chartInstance = _indicatorObject.chartInstance;
                !1 !== (null === (_a = _indicatorObject.chartSpec.select) || void 0 === _a ? void 0 : _a.enable) && chartInstance.updateState(state);
            })), null == activeChartInstance || activeChartInstance.updateState(state);
        }
    }
    updateDataStateToActiveChartInstance(activeChartInstance) {
        var _a;
        if (!1 !== (null === (_a = null == activeChartInstance ? void 0 : activeChartInstance.getSpec().select) || void 0 === _a ? void 0 : _a.enable)) {
            activeChartInstance || (activeChartInstance = this._table._getActiveChartInstance());
            const state = this._generateChartState();
            null == activeChartInstance || activeChartInstance.updateState(state);
        }
    }
    getIndicatorKeyInChartSpec(_col, _row) {
        const chartSpec = this.getRawChartSpec(_col, _row), indicatorKeys = [];
        if (chartSpec) {
            if (chartSpec.series || chartSpec.xField || chartSpec.yField) return !1 === this.indicatorsAsCol ? chartSpec.series ? chartSpec.series.forEach((chartSeries => {
                const yField = chartSeries.yField;
                indicatorKeys.push(yField);
            })) : indicatorKeys.push(chartSpec.yField) : chartSpec.series ? chartSpec.series.forEach((chartSeries => {
                const xField = chartSeries.xField;
                indicatorKeys.push(xField);
            })) : indicatorKeys.push(chartSpec.xField), indicatorKeys;
            if (chartSpec.valueField && indicatorKeys.push(chartSpec.valueField), indicatorKeys.length >= 1) return indicatorKeys;
        }
        return null;
    }
    getOptimunHeightForChart(row) {
        var _a, _b, _c, _d, _e;
        const path = this.getCellHeaderPaths(this.rowHeaderLevelCount, row).rowHeaderPaths;
        let collectedValues, height;
        for (const key in this.dataset.collectValuesBy) if ("yField" === this.dataset.collectValuesBy[key].type && !this.dataset.collectValuesBy[key].range) {
            collectedValues = null === (_a = this.dataset.collectedValues[key]) || void 0 === _a ? void 0 : _a[path.map((pathObj => pathObj.value)).join(this.dataset.stringJoinChar)];
            break;
        }
        if (this._chartItemBandSize) height = scaleWholeRangeSize(null !== (_b = null == collectedValues ? void 0 : collectedValues.length) && void 0 !== _b ? _b : 0, this._chartItemBandSize, this._chartPaddingInner, this._chartPaddingOuter); else {
            const barWidth = this._chartItemSpanSize || 25;
            height = (null !== (_c = null == collectedValues ? void 0 : collectedValues.length) && void 0 !== _c ? _c : 0) * (barWidth + barWidth / 3);
        }
        const padding = getQuadProps(null !== (_e = null !== (_d = this._chartPadding) && void 0 !== _d ? _d : this._table.theme.bodyStyle.padding) && void 0 !== _e ? _e : 0);
        return height + padding[0] + padding[2];
    }
    getOptimunWidthForChart(col) {
        var _a, _b, _c, _d, _e;
        const path = this.getCellHeaderPaths(col, this.columnHeaderLevelCount).colHeaderPaths;
        let collectedValues, width;
        for (const key in this.dataset.collectValuesBy) if ("xField" === this.dataset.collectValuesBy[key].type && !this.dataset.collectValuesBy[key].range) {
            collectedValues = null === (_a = this.dataset.collectedValues[key]) || void 0 === _a ? void 0 : _a[path.map((pathObj => pathObj.value)).join(this.dataset.stringJoinChar)];
            break;
        }
        if (this._chartItemBandSize) width = scaleWholeRangeSize(null !== (_b = null == collectedValues ? void 0 : collectedValues.length) && void 0 !== _b ? _b : 0, this._chartItemBandSize, this._chartPaddingInner, this._chartPaddingOuter); else {
            const barWidth = this._chartItemSpanSize || 25;
            width = (null !== (_c = null == collectedValues ? void 0 : collectedValues.length) && void 0 !== _c ? _c : 0) * (barWidth + barWidth / 3);
        }
        const padding = getQuadProps(null !== (_e = null !== (_d = this._chartPadding) && void 0 !== _d ? _d : this._table.theme.bodyStyle.padding) && void 0 !== _e ? _e : 0);
        return width + padding[1] + padding[3];
    }
    get leftAxesCount() {
        if (!this._table.isPivotChart()) return 0;
        const axisOption = this._table.pivotChartAxes.find((axisOption => "left" === axisOption.orient));
        return !1 === (null == axisOption ? void 0 : axisOption.visible) ? 0 : (this.indicatorsAsCol, 
        1);
    }
    get topAxesCount() {
        if (!this._table.isPivotChart()) return 0;
        const axisOption = this._table.pivotChartAxes.find((axisOption => "top" === axisOption.orient));
        return !1 === (null == axisOption ? void 0 : axisOption.visible) ? 0 : this.indicatorsAsCol && this.hasTwoIndicatorAxes ? 1 : 0;
    }
    get rightAxesCount() {
        return this.rightFrozenColCount;
    }
    get bottomAxesCount() {
        return this.bottomFrozenRowCount;
    }
    getColKeysPath(col, row) {
        const path = this.getCellHeaderPaths(col, row), colKey = [];
        return path.colHeaderPaths.length && path.colHeaderPaths.forEach((path => {
            path.dimensionKey && colKey.push(path.value);
        })), null == colKey ? void 0 : colKey.join(this.dataset.stringJoinChar);
    }
    getRowKeysPath(col, row) {
        const path = this.getCellHeaderPaths(col, row), rowKey = [];
        return path.rowHeaderPaths.length && path.rowHeaderPaths.forEach((path => {
            path.dimensionKey && rowKey.push(path.value);
        })), null == rowKey ? void 0 : rowKey.join(this.dataset.stringJoinChar);
    }
    getIndicatorInfo(indicatorKey, indicatorValue = "") {
        var _a;
        return null === (_a = this.indicatorsDefine) || void 0 === _a ? void 0 : _a.find((indicator => "string" != typeof indicator && (indicatorKey ? indicator.indicatorKey === indicatorKey : !!indicatorValue && indicator.title === indicatorValue)));
    }
    getLayoutColumnTree() {
        const tree = [], children = this.columnDimensionTree.tree.children;
        return generateLayoutTree(tree, children), tree;
    }
    getLayoutRowTree() {
        const tree = [], children = this.rowDimensionTree.tree.children;
        return generateLayoutTree(tree, children), tree;
    }
    getLayoutColumnTreeCount() {
        const children = this.columnDimensionTree.tree.children;
        return countLayoutTree(children, "tree" === this.rowHierarchyType);
    }
    getLayoutRowTreeCount() {
        var _a;
        const children = this.rowDimensionTree.tree.children;
        let totalCount = countLayoutTree(children, "tree" === this.rowHierarchyType);
        return null === (_a = this.extensionRows) || void 0 === _a || _a.forEach((extensionRow => {
            if ("function" != typeof extensionRow.rowTree) {
                const thisTreeCount = countLayoutTree(extensionRow.rowTree, !0);
                totalCount *= thisTreeCount;
            }
        })), totalCount;
    }
    resetHeaderTree() {
        var _a, _b, _c;
        this.colIndex = 0, this._rowHeaderCellFullPathIds_FULL = [], this._columnHeaderCellFullPathIds = [], 
        this._columnHeaderCellIds = [];
        const dataset = this.dataset;
        this.rowTree = dataset.rowHeaderTree, this.columnTree = dataset.colHeaderTree;
        const beforeRowDimensions = this.rowDimensionTree.tree.children;
        null === (_a = this.rowTree) || void 0 === _a || _a.forEach(((node, index) => {
            const beforeRowDimension = beforeRowDimensions.find((item => item.dimensionKey === node.dimensionKey && item.value === node.value));
            beforeRowDimension && this._table._syncHierarchyState(beforeRowDimension, node);
        })), this.columnDimensionTree = new DimensionTree(null !== (_b = this.columnTree) && void 0 !== _b ? _b : [], this.sharedVar, this.columnHierarchyType, "grid" !== this.columnHierarchyType ? this.columnExpandLevel : void 0), 
        this.rowDimensionTree = new DimensionTree(null !== (_c = this.rowTree) && void 0 !== _c ? _c : [], this.sharedVar, this.rowHierarchyType, "grid" !== this.rowHierarchyType ? this.rowExpandLevel : void 0), 
        this.resetColumnHeaderLevelCount(), this._generateColHeaderIds(), this.colIndex = 0, 
        this._generateRowHeaderIds(), this._rowHeaderCellFullPathIds_FULL = transpose(this._rowHeaderCellFullPathIds_FULL), 
        this._headerObjectMap = this._headerObjects.reduce(((o, e) => (o[e.id] = e, o)), {}), 
        this._CellHeaderPathMap = new Map, this._largeCellRangeCache.length = 0, this.generateCellIdsConsiderHideHeader(), 
        this.setPagination(this.pagination);
    }
    isSeriesNumberInHeader(col, row) {
        return this.leftRowSeriesNumberColumnCount > 0 && col >= 0 && row >= 0 && col < this.leftRowSeriesNumberColumnCount && row < this.headerLevelCount || this.rightRowSeriesNumberColumnCount > 0 && row >= 0 && col >= this.colCount - this.rightRowSeriesNumberColumnCount && row < this.headerLevelCount;
    }
    isSeriesNumberInBody(col, row) {
        return this.leftRowSeriesNumberColumnCount > 0 && col >= 0 && col < this.leftRowSeriesNumberColumnCount && row >= this.headerLevelCount || this.rightRowSeriesNumberColumnCount > 0 && col >= this.colCount - this.rightRowSeriesNumberColumnCount && row >= this.headerLevelCount;
    }
    isSeriesNumber(col, row) {
        if (isValid(col) && isValid(row)) {
            if (this.leftRowSeriesNumberColumnCount > 0 && col >= 0 && row >= 0 && col < this.leftRowSeriesNumberColumnCount) return !0;
            if (this.rightRowSeriesNumberColumnCount > 0 && row >= 0 && col >= this.colCount - this.rightRowSeriesNumberColumnCount) return !0;
        }
        return !1;
    }
    getSeriesNumberHeader(col, row) {
        return this.leftRowSeriesNumberColumnCount > 0 && col >= 0 && col < this.leftRowSeriesNumberColumnCount && row < this.headerLevelCount ? Object.assign({}, this.leftRowSeriesNumberColumn[col], {
            style: Object.assign({}, this._table.internalProps.theme.cornerHeaderStyle, this._table.internalProps.rowSeriesNumber.headerStyle)
        }) : this.rightRowSeriesNumberColumnCount > 0 && col >= this.colCount - this.rightRowSeriesNumberColumnCount && row < this.headerLevelCount && row < this.headerLevelCount ? this.rightRowSeriesNumberColumn[col - (this.colCount - this.rightRowSeriesNumberColumnCount)] : void 0;
    }
    getSeriesNumberBody(col, row) {
        return this.leftRowSeriesNumberColumnCount > 0 && col >= 0 && col < this.leftRowSeriesNumberColumnCount && row >= this.headerLevelCount ? this.leftRowSeriesNumberColumn[col] : this.rightRowSeriesNumberColumnCount > 0 && col >= this.colCount - this.rightRowSeriesNumberColumnCount && row >= this.headerLevelCount ? this.rightRowSeriesNumberColumn[col - (this.colCount - this.rightRowSeriesNumberColumnCount)] : void 0;
    }
    changeTreeNodeTitle(col, row, value) {
        this.getHeadNode(col, row).value = value;
        const id = this.getCellId(col, row);
        this._headerObjectMap[id].title = value;
    }
    changeCornerTitle(col, row, value) {
        if (this.isCornerHeader(col, row)) {
            const id = this.getCellId(col, row);
            this._headerObjectMap[id].title = value;
        }
    }
    generateCellIdsConsiderHideHeader() {
        var _a, _b, _c, _d;
        if (this._columnHeaderCellIds = this._columnHeaderCellFullPathIds.slice(), !this.showColumnHeader) if (this.indicatorsAsCol && !this.hideIndicatorName) {
            const indicatorIndex = this.colDimensionKeys.indexOf(IndicatorDimensionKeyPlaceholder), indicatorIds = this._columnHeaderCellIds.splice(indicatorIndex, 1);
            this._columnHeaderCellIds.splice(0, this._columnHeaderCellIds.length), this._columnHeaderCellIds.push(indicatorIds[0]);
        } else this._columnHeaderCellIds.splice(0, this._columnHeaderCellIds.length);
        if (this._rowHeaderCellIds_FULL = this._rowHeaderCellFullPathIds_FULL.slice(), !this.showRowHeader) if (this.indicatorsAsCol || this.hideIndicatorName) this._rowHeaderCellIds_FULL.forEach(((cellIds, index) => {
            const _cellIds = cellIds.slice();
            _cellIds.splice(0, _cellIds.length), this._rowHeaderCellIds_FULL[index] = _cellIds;
        })); else {
            const indicatorIndex = this.rowDimensionKeys.indexOf(IndicatorDimensionKeyPlaceholder);
            this._rowHeaderCellIds_FULL.forEach(((cellIds, index) => {
                const _cellIds = cellIds.slice(), indicator = _cellIds.splice(indicatorIndex, 1);
                _cellIds.splice(0, _cellIds.length), _cellIds.push(indicator[0]), this._rowHeaderCellIds_FULL[index] = _cellIds;
            }));
        }
        if (this._rowHeaderCellIds = this._rowHeaderCellIds_FULL.slice(), this._cornerHeaderCellIds = this._cornerHeaderCellFullPathIds.slice(), 
        0 === this.rowHeaderLevelCount || 0 === this.columnHeaderLevelCount) this._cornerHeaderCellIds = []; else if ("row" !== this.cornerSetting.titleOnDimension || this.showRowHeader) {
            if ("column" === this.cornerSetting.titleOnDimension && !this.showColumnHeader) if (this.indicatorsAsCol && !this.hideIndicatorName) {
                const indicatorIndex = this.colDimensionKeys.indexOf(IndicatorDimensionKeyPlaceholder), indicatorIds = this._cornerHeaderCellIds.splice(indicatorIndex, 1);
                this._cornerHeaderCellIds.splice(0, this._cornerHeaderCellIds.length), this._cornerHeaderCellIds.push(indicatorIds[0]);
            } else this._cornerHeaderCellIds.splice(0, this._cornerHeaderCellIds.length);
        } else if (this.indicatorsAsCol || this.hideIndicatorName) this._cornerHeaderCellIds.forEach(((cellIds, index) => {
            const _cellIds = cellIds.slice();
            _cellIds.splice(0, _cellIds.length), this._cornerHeaderCellIds[index] = _cellIds;
        })); else {
            const indicatorIndex = this.rowDimensionKeys.indexOf(IndicatorDimensionKeyPlaceholder);
            this._cornerHeaderCellIds.forEach(((cellIds, index) => {
                const _cellIds = cellIds.slice(), indicator = _cellIds.splice(indicatorIndex, 1);
                _cellIds.splice(0, _cellIds.length), _cellIds.push(indicator[0]), this._cornerHeaderCellIds[index] = _cellIds;
            }));
        }
        if ("grid-tree" === this.rowHierarchyType && "column" === this.cornerSetting.titleOnDimension) this._cornerHeaderCellIds[0].length < this._rowHeaderCellIds[0].length ? this._cornerHeaderCellIds.forEach(((cellIds, index) => {
            const oldLength = cellIds.length;
            cellIds.length = this._rowHeaderCellIds[0].length, cellIds.fill(cellIds[0], oldLength);
        })) : this._cornerHeaderCellIds[0].length > this._rowHeaderCellIds[0].length && this._cornerHeaderCellIds.forEach(((cellIds, index) => {
            cellIds.length = this._rowHeaderCellIds[0].length;
        })); else if ("grid-tree" === this.columnHierarchyType && "row" === this.cornerSetting.titleOnDimension) if ((null === (_a = this._cornerHeaderCellIds) || void 0 === _a ? void 0 : _a.length) < (null === (_b = this._columnHeaderCellIds) || void 0 === _b ? void 0 : _b.length)) {
            const oldLength = this._cornerHeaderCellIds.length;
            this._cornerHeaderCellIds.length = this._columnHeaderCellIds.length, this._cornerHeaderCellIds.fill(this._cornerHeaderCellIds[0], oldLength);
        } else (null === (_c = this._cornerHeaderCellIds) || void 0 === _c ? void 0 : _c.length) > (null === (_d = this._columnHeaderCellIds) || void 0 === _d ? void 0 : _d.length) && (this._cornerHeaderCellIds.length = this._columnHeaderCellIds.length);
    }
    enableUseGetBodyCache() {
        this._useGetBodyCache = !0, this._getBodyCache.clear();
    }
    disableUseGetBodyCache() {
        this._useGetBodyCache = !1, this._getBodyCache.clear();
    }
    enableUseHeaderPathCache() {
        var _a, _b;
        (null === (_b = null === (_a = this._table.options) || void 0 === _a ? void 0 : _a.customConfig) || void 0 === _b ? void 0 : _b.enablePivotPathCache) ? this._useHeaderPathCache = !0 : (this._useHeaderPathCache = !0, 
        this._colHeaderPathCache.clear(), this._rowHeaderPathCache.clear());
    }
    disableUseHeaderPathCache() {
        var _a, _b;
        (null === (_b = null === (_a = this._table.options) || void 0 === _a ? void 0 : _a.customConfig) || void 0 === _b ? void 0 : _b.enablePivotPathCache) ? this._useHeaderPathCache = !0 : (this._useHeaderPathCache = !1, 
        this._colHeaderPathCache.clear(), this._rowHeaderPathCache.clear());
    }
    getBodyWidthCache(col, row) {
        if (this._useGetBodyCache && !this.isHeader(col, row) && !this.isSeriesNumber(col, row)) return this.indicatorsAsCol && this._getBodyCache.has(col) ? this._getBodyCache.get(col) : !this.indicatorsAsCol && this._getBodyCache.has(row) ? this._getBodyCache.get(row) : void 0;
    }
    setBodyWidthCache(col, row, cache) {
        !this._useGetBodyCache || this.isHeader(col, row) || this.isSeriesNumber(col, row) || (this.indicatorsAsCol ? this._getBodyCache.set(col, cache) : this._getBodyCache.set(row, cache));
    }
    getColHeaderPathCache(col, row) {
        if (this._useHeaderPathCache && !this.isHeader(col, row) && !this.isSeriesNumber(col, row) && this._colHeaderPathCache.has(col)) return this._colHeaderPathCache.get(col);
    }
    setColHeaderPathCache(col, row, cache) {
        !this._useHeaderPathCache || this.isHeader(col, row) || this.isSeriesNumber(col, row) || this._colHeaderPathCache.set(col, cache);
    }
    getRowHeaderPathCache(col, row) {
        if (this._useHeaderPathCache && !this.isHeader(col, row) && !this.isSeriesNumber(col, row) && this._rowHeaderPathCache.has(row)) return this._rowHeaderPathCache.get(row);
    }
    setRowHeaderPathCache(col, row, cache) {
        !this._useHeaderPathCache || this.isHeader(col, row) || this.isSeriesNumber(col, row) || this._rowHeaderPathCache.set(row, cache);
    }
    clearHeaderPathCache() {
        this._colHeaderPathCache.clear(), this._rowHeaderPathCache.clear();
    }
}

function scaleWholeRangeSize(count, bandwidth, paddingInner, paddingOuter) {
    1 === paddingInner && (paddingInner = 0);
    const space = bandSpace(count, paddingInner, paddingOuter), step = bandwidth / (1 - paddingInner);
    return Math.ceil(space * step);
}

function bandSpace(count, paddingInner, paddingOuter) {
    let space;
    return space = 1 === count ? count + 2 * paddingOuter : count - paddingInner + 2 * paddingOuter, 
    count ? space > 0 ? space : 1 : 0;
}
//# sourceMappingURL=pivot-header-layout.js.map