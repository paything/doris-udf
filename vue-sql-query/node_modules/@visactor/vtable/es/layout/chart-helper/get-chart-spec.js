import { isArray, isNumber, merge } from "@visactor/vutils";

import { getAxisOption, getAxisRangeAndTicks } from "./get-axis-config";

import { cloneDeepSpec } from "@visactor/vutils-extension";

import { DEFAULT_TEXT_FONT_SIZE } from "../../components/axis/get-axis-attributes";

import { getTickModeFunction } from "./tick-align";

const NO_AXISID_FRO_VTABLE = "NO_AXISID_FRO_VTABLE";

export function getRawChartSpec(col, row, layout) {
    var _a, _b;
    const paths = layout.getCellHeaderPaths(col, row);
    let indicatorObj;
    if (layout.indicatorsAsCol) {
        const indicatorKey = null === (_a = paths.colHeaderPaths.find((colPath => colPath.indicatorKey))) || void 0 === _a ? void 0 : _a.indicatorKey;
        indicatorObj = layout.columnObjects.find((indicator => indicator.indicatorKey === indicatorKey));
    } else {
        const indicatorKey = null === (_b = paths.rowHeaderPaths.find((rowPath => rowPath.indicatorKey))) || void 0 === _b ? void 0 : _b.indicatorKey;
        indicatorObj = layout.columnObjects.find((indicator => indicator.indicatorKey === indicatorKey));
    }
    const chartSpec = null == indicatorObj ? void 0 : indicatorObj.chartSpec;
    if ("function" == typeof chartSpec) {
        return chartSpec({
            col: col,
            row: row,
            dataValue: layout._table.getCellOriginValue(col, row) || "",
            value: layout._table.getCellValue(col, row) || "",
            rect: layout._table.getCellRangeRelativeRect(layout._table.getCellRange(col, row)),
            table: layout._table
        });
    }
    return chartSpec;
}

export function isShareChartSpec(col, row, layout) {
    var _a, _b;
    const paths = layout.getCellHeaderPaths(col, row);
    let indicatorObj;
    if (layout.indicatorsAsCol) {
        const indicatorKey = null === (_a = paths.colHeaderPaths.find((colPath => colPath.indicatorKey))) || void 0 === _a ? void 0 : _a.indicatorKey;
        indicatorObj = layout.columnObjects.find((indicator => indicator.indicatorKey === indicatorKey));
    } else {
        const indicatorKey = null === (_b = paths.rowHeaderPaths.find((rowPath => rowPath.indicatorKey))) || void 0 === _b ? void 0 : _b.indicatorKey;
        indicatorObj = layout.columnObjects.find((indicator => indicator.indicatorKey === indicatorKey));
    }
    return "function" != typeof (null == indicatorObj ? void 0 : indicatorObj.chartSpec);
}

export function isNoChartDataRenderNothing(col, row, layout) {
    var _a, _b;
    const paths = layout.getCellHeaderPaths(col, row);
    let indicatorObj;
    if (layout.indicatorsAsCol) {
        const indicatorKey = null === (_a = paths.colHeaderPaths.find((colPath => colPath.indicatorKey))) || void 0 === _a ? void 0 : _a.indicatorKey;
        indicatorObj = layout.columnObjects.find((indicator => indicator.indicatorKey === indicatorKey));
    } else {
        const indicatorKey = null === (_b = paths.rowHeaderPaths.find((rowPath => rowPath.indicatorKey))) || void 0 === _b ? void 0 : _b.indicatorKey;
        indicatorObj = layout.columnObjects.find((indicator => indicator.indicatorKey === indicatorKey));
    }
    return null == indicatorObj ? void 0 : indicatorObj.noDataRenderNothing;
}

export function checkHasCartesianChart(indicatorsDefine) {
    let isHasCartesianChart = !1;
    for (let i = 0; i < indicatorsDefine.length; i++) {
        const columnObj = indicatorsDefine[i];
        if (columnObj.chartSpec && "wordCloud" !== columnObj.chartSpec.type && "radar" !== columnObj.chartSpec.type && "gauge" !== columnObj.chartSpec.type && "pie" !== columnObj.chartSpec.type && "funnel" !== columnObj.chartSpec.type && "rose" !== columnObj.chartSpec.type) {
            isHasCartesianChart = !0;
            break;
        }
    }
    return isHasCartesianChart;
}

export function isCartesianChart(col, row, layout) {
    let isHasCartesianChart = !0;
    const chartSpec = layout.getRawChartSpec(col, row);
    return chartSpec && "pie" !== chartSpec.type && "radar" !== chartSpec.type && "gauge" !== chartSpec.type && "wordCloud" !== chartSpec.type && "funnel" !== chartSpec.type && "rose" !== chartSpec.type || (isHasCartesianChart = !1), 
    isHasCartesianChart;
}

export function isHasCartesianChartInline(col, row, checkDirection, layout) {
    let isHasCartesianChart = !1;
    if (layout.indicatorsAsCol && "row" === checkDirection || !layout.indicatorsAsCol && "col" === checkDirection) for (let i = 0; i < layout.indicatorsDefine.length; i++) {
        const columnObj = layout.indicatorsDefine[i];
        if (columnObj.chartSpec && "pie" !== columnObj.chartSpec.type && "wordCloud" !== columnObj.chartSpec.type && "radar" !== columnObj.chartSpec.type && "gauge" !== columnObj.chartSpec.type && "funnel" !== columnObj.chartSpec.type && "rose" !== columnObj.chartSpec.type) {
            isHasCartesianChart = !0;
            break;
        }
    } else {
        const chartSpec = layout.getRawChartSpec(col, row);
        chartSpec ? "pie" !== chartSpec.type && "radar" !== chartSpec.type && "gauge" !== chartSpec.type && "wordCloud" !== chartSpec.type && "funnel" !== chartSpec.type && "rose" !== chartSpec.type && (isHasCartesianChart = !0) : isHasCartesianChart = !1;
    }
    return isHasCartesianChart;
}

export function getChartSpec(col, row, layout) {
    let chartSpec = layout.getRawChartSpec(col, row);
    return chartSpec ? layout._table.isPivotChart() ? (chartSpec = cloneDeepSpec(chartSpec), 
    chartSpec.sortDataByAxis = !0, isArray(chartSpec.series) && chartSpec.series.forEach((serie => {
        serie.sortDataByAxis = !0;
    })), "gauge" !== chartSpec.type && "rose" !== chartSpec.type && "radar" !== chartSpec.type && (chartSpec.axes = layout.getChartAxes(col, row)), 
    chartSpec.padding = 0, chartSpec.dataZoom = [], chartSpec) : chartSpec : null;
}

export function getChartAxes(col, row, layout) {
    var _a, _b, _c;
    const axes = [];
    if (layout.indicatorsAsCol) {
        const indicatorKeys = layout.getIndicatorKeyInChartSpec(col, row), colPath = layout.getColKeysPath(col, row);
        indicatorKeys.forEach(((key, index) => {
            const {range: range, targetTicks: targetTicks, targetRange: targetRange, axisOption: axisOption} = getAxisRangeAndTicks(col, row, index, 0 === index ? "bottom" : "top", 0 === index ? "top" : "bottom", indicatorKeys, colPath, layout);
            isNumber(null == axisOption ? void 0 : axisOption.min) && (range.min = axisOption.min), 
            isNumber(null == axisOption ? void 0 : axisOption.max) && (range.max = axisOption.max), 
            hasSameAxis(axisOption, axes) || axes.push(merge({
                range: range,
                label: {
                    style: {
                        fontSize: DEFAULT_TEXT_FONT_SIZE
                    }
                }
            }, axisOption, {
                type: (null == axisOption ? void 0 : axisOption.type) || "linear",
                orient: 0 === index ? "bottom" : "top",
                label: {
                    visible: !1,
                    flush: !0
                },
                title: {
                    visible: !1
                },
                domainLine: {
                    visible: !1
                },
                seriesIndex: (null == axisOption ? void 0 : axisOption.seriesId) ? void 0 : index,
                tick: {
                    tickMode: getTickModeFunction(targetTicks, targetRange, range, index)
                },
                sync: {
                    axisId: NO_AXISID_FRO_VTABLE
                }
            }));
        }));
        let rowDimensionKey = layout.getDimensionKeyInChartSpec(layout.rowHeaderLevelCount, row);
        isArray(rowDimensionKey) && (rowDimensionKey = rowDimensionKey[0]);
        const data = layout.dataset.cacheCollectedValues[rowDimensionKey] || layout.dataset.collectedValues[rowDimensionKey] || [], rowPath = layout.getRowKeysPath(col, row), domain = data[null != rowPath ? rowPath : ""], {axisOption: axisOption, isPercent: isPercent, chartType: chartType} = getAxisOption(col, row, "left", layout);
        axes.push(merge({
            domain: "linear" !== (null == axisOption ? void 0 : axisOption.type) || Array.isArray(domain) ? Array.from(null != domain ? domain : []) : void 0,
            range: "linear" !== (null == axisOption ? void 0 : axisOption.type) || Array.isArray(domain) ? void 0 : domain,
            label: {
                style: {
                    fontSize: DEFAULT_TEXT_FONT_SIZE
                }
            }
        }, axisOption, {
            type: null !== (_a = null == axisOption ? void 0 : axisOption.type) && void 0 !== _a ? _a : "band",
            orient: "left",
            label: {
                visible: !1
            },
            domainLine: {
                visible: !1
            },
            tick: {
                visible: !1
            },
            subTick: {
                visible: !1
            },
            title: {
                visible: !1
            }
        }));
    } else {
        const indicatorKeys = layout.getIndicatorKeyInChartSpec(col, row), rowPath = layout.getRowKeysPath(col, row);
        indicatorKeys.forEach(((key, index) => {
            const {range: range, targetTicks: targetTicks, targetRange: targetRange, axisOption: axisOption} = getAxisRangeAndTicks(col, row, index, 0 === index ? "left" : "right", 0 === index ? "right" : "left", indicatorKeys, rowPath, layout);
            isNumber(null == axisOption ? void 0 : axisOption.min) && (range.min = axisOption.min), 
            isNumber(null == axisOption ? void 0 : axisOption.max) && (range.max = axisOption.max), 
            hasSameAxis(axisOption, axes) || axes.push(merge({
                range: range,
                label: {
                    style: {
                        fontSize: DEFAULT_TEXT_FONT_SIZE
                    }
                }
            }, axisOption, {
                type: (null == axisOption ? void 0 : axisOption.type) || "linear",
                orient: 0 === index ? "left" : "right",
                label: {
                    visible: !1,
                    flush: !0
                },
                title: {
                    visible: !1
                },
                domainLine: {
                    visible: !1
                },
                seriesIndex: (null == axisOption ? void 0 : axisOption.seriesId) ? void 0 : index,
                tick: {
                    tickMode: getTickModeFunction(targetTicks, targetRange, range, index)
                },
                sync: {
                    axisId: NO_AXISID_FRO_VTABLE
                }
            }));
        }));
        let columnDimensionKey = layout.getDimensionKeyInChartSpec(col, layout.columnHeaderLevelCount);
        isArray(columnDimensionKey) && (columnDimensionKey = columnDimensionKey[0]);
        const data = layout.dataset.cacheCollectedValues[columnDimensionKey] || layout.dataset.collectedValues[columnDimensionKey] || [], colPath = layout.getColKeysPath(col, row), domain = null !== (_b = null == data ? void 0 : data[null != colPath ? colPath : ""]) && void 0 !== _b ? _b : [], {axisOption: axisOption, isPercent: isPercent, chartType: chartType} = getAxisOption(col, row, "bottom", layout);
        axes.push(merge({
            domain: "linear" !== (null == axisOption ? void 0 : axisOption.type) || Array.isArray(domain) ? Array.from(null != domain ? domain : []) : void 0,
            range: "linear" !== (null == axisOption ? void 0 : axisOption.type) || Array.isArray(domain) ? void 0 : domain,
            label: {
                style: {
                    fontSize: DEFAULT_TEXT_FONT_SIZE
                }
            }
        }, axisOption, {
            type: null !== (_c = null == axisOption ? void 0 : axisOption.type) && void 0 !== _c ? _c : "band",
            orient: "bottom",
            visible: !0,
            label: {
                visible: !1
            },
            domainLine: {
                visible: !1
            },
            tick: {
                visible: !1
            },
            subTick: {
                visible: !1
            },
            title: {
                visible: !1
            }
        }));
    }
    return axes;
}

export function getChartDataId(col, row, layout) {
    var _a;
    const chartSpec = layout.getRawChartSpec(col, row);
    if (null == chartSpec ? void 0 : chartSpec.series) {
        const dataIdfield = {};
        return (null === (_a = chartSpec.data) || void 0 === _a ? void 0 : _a.id) && (dataIdfield[chartSpec.data.id] = void 0), 
        null == chartSpec || chartSpec.series.forEach((seriesSpec => {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
            if (!(null === (_a = seriesSpec.data) || void 0 === _a ? void 0 : _a.fromDataId)) if (null === (_b = seriesSpec.data) || void 0 === _b ? void 0 : _b.transforms) dataIdfield[null !== (_l = null !== (_j = null === (_h = seriesSpec.data) || void 0 === _h ? void 0 : _h.id) && void 0 !== _j ? _j : null === (_k = chartSpec.data) || void 0 === _k ? void 0 : _k.id) && void 0 !== _l ? _l : "data"] = void 0; else {
                const seriesField = "horizontal" === seriesSpec.direction ? seriesSpec.xField : seriesSpec.yField;
                dataIdfield[null !== (_f = null !== (_d = null === (_c = seriesSpec.data) || void 0 === _c ? void 0 : _c.id) && void 0 !== _d ? _d : null === (_e = chartSpec.data) || void 0 === _e ? void 0 : _e.id) && void 0 !== _f ? _f : "data"] = (null === (_g = seriesSpec.data) || void 0 === _g ? void 0 : _g.id) ? seriesField : void 0;
            }
        })), dataIdfield;
    }
    return chartSpec.data.id;
}

export function checkHasChart(layout) {
    let isHasChart = !1;
    for (let i = 0; i < layout.columnObjects.length; i++) {
        if (layout.columnObjects[i].chartSpec) {
            isHasChart = !0;
            break;
        }
    }
    return isHasChart;
}

function hasSameAxis(axisOption, axes) {
    if (axisOption && isArray(axisOption.seriesId) && axisOption.seriesId.length > 0) {
        if (axes.filter((axis => !(axis.orient !== axisOption.orient || !axis.seriesId || axis.seriesId.length !== axisOption.seriesId.length || !axis.seriesId.every(((id, index) => id === axisOption.seriesId[index]))))).length > 0) return !0;
    }
    return !1;
}
//# sourceMappingURL=get-chart-spec.js.map
