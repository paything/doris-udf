import { NumberMap } from '../tools/NumberMap';
import type { Either } from '../tools/helper';
import type { CellInfo, ColumnIconOption, HeaderData, ICustomRender, IDimension, IDimensionInfo, IIndicator, LayoutObjectId } from '../ts-types';
import { HierarchyState } from '../ts-types';
import type { PivotHeaderLayoutMap } from './pivot-header-layout';
import type { BaseTableAPI } from '../ts-types/base-table';
interface ITreeLayoutBaseHeadNode {
    id: number;
    value: string;
    children: ITreeLayoutHeadNode[] | undefined;
    columns?: any;
    level: number;
    afterSpanLevel: number;
    levelSpan: number;
    startIndex: number;
    size: number;
    startInTotal: number;
    customRender?: ICustomRender;
    hierarchyState: HierarchyState;
    headerIcon?: (string | ColumnIconOption)[] | ((args: CellInfo) => (string | ColumnIconOption)[]);
}
interface ITreeLayoutDimensionHeadNode extends ITreeLayoutBaseHeadNode {
    dimensionKey: string;
    virtual?: boolean;
}
interface ITreeLayoutIndicatorHeadNode extends ITreeLayoutBaseHeadNode {
    indicatorKey: string;
    hide?: boolean;
}
export type ITreeLayoutHeadNode = Either<ITreeLayoutDimensionHeadNode, ITreeLayoutIndicatorHeadNode>;
export declare class DimensionTree {
    sharedVar: {
        seqId: number;
    };
    hasHideNode: boolean;
    sizeIncludeParent: boolean;
    setExpandLevel: number;
    hierarchyType: 'grid' | 'tree' | 'grid-tree';
    tree: ITreeLayoutHeadNode;
    totalLevel: number;
    expandedMaxLevel: number;
    dimensionKeys: NumberMap<string>;
    dimensionKeysIncludeVirtual: NumberMap<string>;
    cache: Map<number, any>;
    constructor(tree: ITreeLayoutHeadNode[], sharedVar: {
        seqId: number;
    }, hierarchyType?: 'grid' | 'tree' | 'grid-tree', rowExpandLevel?: number);
    reset(tree: ITreeLayoutHeadNode[]): void;
    setTreeNode(node: ITreeLayoutHeadNode, startIndex: number, parent: ITreeLayoutHeadNode): number;
    getTreePath(index: number, maxDeep?: number): Array<ITreeLayoutHeadNode>;
    findNodeById(nodes: ITreeLayoutHeadNode[], id: LayoutObjectId): ITreeLayoutHeadNode;
    searchPath(index: number, node: ITreeLayoutHeadNode, path: Array<ITreeLayoutHeadNode>, maxDeep: number): void;
    movePosition(level: number, sourceIndex: number, targetIndex: number): void;
    getCopiedTree(): any;
}
export type LayouTreeNode = {
    dimensionKey?: string;
    indicatorKey?: string;
    value: string;
    hierarchyState: HierarchyState;
    children?: LayouTreeNode[];
};
export declare function generateLayoutTree(tree: LayouTreeNode[], children: ITreeLayoutHeadNode[]): void;
export declare function countLayoutTree(children: {
    children?: any;
}[], countParentNode: boolean): number;
export declare function dealHeader(hd: ITreeLayoutHeadNode, _headerCellIds: number[][], results: HeaderData[], roots: number[], row: number, layoutMap: PivotHeaderLayoutMap): void;
export declare function dealHeaderForGridTreeMode(hd: ITreeLayoutHeadNode, _headerCellIds: number[][], results: HeaderData[], roots: number[], row: number, totalLevel: number, expandedMaxLevel: number, show: boolean, dimensions: (IDimension | string)[], isRowTree: boolean, indicatorsAsCol: boolean, layoutMap: PivotHeaderLayoutMap): void;
export declare function dealHeaderForTreeMode(hd: ITreeLayoutHeadNode, _headerCellIds: number[][], results: HeaderData[], roots: number[], row: number, totalLevel: number, show: boolean, dimensions: (IDimension | string)[], layoutMap: PivotHeaderLayoutMap): void;
export declare function deleteTreeHideNode(tree_children: LayouTreeNode[], dimensionPath: IDimensionInfo[], indicators: IIndicator[], hasHideNode: boolean, table: BaseTableAPI): void;
export {};
