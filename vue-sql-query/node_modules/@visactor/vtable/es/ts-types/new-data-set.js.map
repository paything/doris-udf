{"version":3,"sources":["../src/ts-types/new-data-set.ts"],"names":[],"mappings":"AAYA,MAAM,CAAN,IAAY,eAUX;AAVD,WAAY,eAAe;IACzB,oCAAiB,CAAA;IACjB,gCAAa,CAAA;IACb,8BAAW,CAAA;IACX,8BAAW,CAAA;IACX,8BAAW,CAAA;IACX,8BAAW,CAAA;IACX,kCAAe,CAAA;IACf,oCAAiB,CAAA;IACjB,8CAA2B,CAAA;AAC7B,CAAC,EAVW,eAAe,KAAf,eAAe,QAU1B;AACD,MAAM,CAAN,IAAY,QAOX;AAPD,WAAY,QAAQ;IAClB,uBAAW,CAAA;IACX,yBAAa,CAAA;IACb,6BAAiB,CAAA;IACjB,yBAAa,CAAA;IACb,uBAAW,CAAA;IACX,6BAAiB,CAAA;AACnB,CAAC,EAPW,QAAQ,KAAR,QAAQ,QAOnB","file":"new-data-set.js","sourcesContent":["import type { ColorPropertyDefine } from '.';\nimport type { Either } from '../tools/helper';\nimport type { BaseTableAPI } from './base-table';\n\n//#region 总计小计\nexport interface TotalsStatus {\n  isRowTotal: boolean;\n  isRowSubTotal: boolean;\n  isColTotal: boolean;\n  isColSubTotal: boolean;\n}\n\nexport enum AggregationType {\n  RECORD = 'RECORD',\n  NONE = 'NONE', //不做聚合 只获取其中一条数据作为节点的record 取其field\n  SUM = 'SUM',\n  MIN = 'MIN',\n  MAX = 'MAX',\n  AVG = 'AVG',\n  COUNT = 'COUNT',\n  CUSTOM = 'CUSTOM',\n  RECALCULATE = 'RECALCULATE'\n}\nexport enum SortType {\n  ASC = 'ASC',\n  DESC = 'DESC',\n  NORMAL = 'NORMAL',\n  desc = 'desc',\n  asc = 'asc',\n  normal = 'normal'\n}\nexport interface CalcTotals {\n  aggregationType?: AggregationType; // 聚合方式\n  // calcFunc?: (query: Record<string, any>, arr: Record<string, any>[]) => number;\n}\n\nexport interface Total {\n  /** 是否显示总计; 如果配置了total对象，showGrandTotals默认false */\n  showGrandTotals: boolean;\n  /** 是否显示小计;  如果配置了total对象，showSubTotals默认为true */\n  showSubTotals: boolean;\n\n  // // 计算总计方法\n  // calcGrandTotals?: CalcTotals;\n  // // 计算小计方法\n  // calcSubTotals?: CalcTotals;\n  /** 小计汇总维度定义 */\n  subTotalsDimensions?: string[];\n  /** 汇总节点显示名称  默认'总计' */\n  grandTotalLabel?: string;\n  /** 汇总节点显示名称  默认'小计' */\n  subTotalLabel?: string;\n}\n\nexport interface Totals {\n  row?: Total & {\n    /** 总计显示在上 默认false */\n    showGrandTotalsOnTop?: boolean;\n    /** 小计显示在上 默认false */\n    showSubTotalsOnTop?: boolean;\n  };\n  column?: Total & {\n    /** 总计显示在左 默认false */\n    showGrandTotalsOnLeft?: boolean;\n    /** 小计显示在左 默认false */\n    showSubTotalsOnLeft?: boolean;\n  };\n}\n\n//#endregion 总计小计\n\n//#region 排序规则\n// export interface SortRule {\n//   //排序维度\n//   sortField: string;\n//   //以下均为排序方法\n//   //1. 指定排序类型\n//   sortType?: SortType;\n//   //2. 按维度成员指定排序\n//   sortBy?: string[];\n//   //3. 按指标值排序\n//   sortByIndicator?: string;\n//   //如果按指标值排序，还需要指定另外一个（行或列）方向的底层维度成员具体值\n//   query?: string[];\n//   //4. 自定义排序方法function\n//   sortFunc?: (a: any, b: any) => number;\n// }\n//以下均为排序方法\n//1. 指定排序类型\nexport interface SortTypeRule {\n  /**排序维度 */\n  sortField: string;\n  /**升序降序 ASC or DESC*/\n  sortType?: SortType;\n}\n//2. 按维度成员指定排序\nexport interface SortByRule {\n  /**排序维度 */\n  sortField: string;\n  /**升序降序 ASC or DESC*/\n  sortType?: SortType;\n  /**根据指定具体顺序排序 */\n  sortBy?: string[];\n}\n//3. 按指标值排序\nexport interface SortByIndicatorRule {\n  /**排序维度 */\n  sortField: string;\n  /**升序降序 ASC or DESC*/\n  sortType?: SortType;\n  /**排序根据某个指标值 */\n  sortByIndicator?: string;\n  /**如果按指标值排序，还需要指定另外一个（行或列）方向的底层维度成员具体值。例如按照办公用品下的纸张 ['办公用品', '纸张'] */\n  query?: string[];\n  /**自定义排序函数 否则按自然排序 */\n  sortFunc?: (\n    value_a: string | number,\n    value_b: string | number,\n    path_a: string[],\n    path_b: string[],\n    sortType: SortType\n  ) => number;\n}\n//4. 自定义排序方法function\nexport interface SortFuncRule {\n  /**排序维度 */\n  sortField: string;\n  /**升序降序 ASC or DESC*/\n  sortType?: SortType;\n  /**自定义排序函数 */\n  sortFunc?: (a: any, b: any, sortType: SortType) => number;\n}\n//自定义排序方法参数\n// export interface SortFuncParam extends SortRule {\n//   data: Array<string | Record<string, any>>;\n// }\nexport type SortRule = SortTypeRule | SortByRule | SortByIndicatorRule | SortFuncRule;\nexport type SortRules = SortRule[];\n//#endregion 排序规则\n\n//#region 过滤规则\nexport interface FilterFuncRule {\n  filterFunc?: (row: Record<string, any>) => boolean;\n}\nexport interface FilterValueRule {\n  filterKey?: string;\n  filteredValues?: unknown[];\n}\nexport type FilterRules = Either<FilterFuncRule, FilterValueRule>[];\n//#endregion 过滤规则\n\n//#region 聚合规则\nexport interface AggregationRule<T extends AggregationType> {\n  /** 区别于field 重新起个key值，供配置indicators使用 */\n  indicatorKey: string;\n  // 可以收集单个字段的聚合结果，或者收集多个字段的聚合结果\n  field: string[] | string;\n  aggregationType: string | T;\n  /** aggregationType 配置为 AggregationType.CUSTOM 时，需要配置 aggregationFun。*/\n  aggregationFun?: T extends AggregationType.CUSTOM ? (values: any[], records: any[]) => any : undefined;\n  /**计算结果格式化 */\n  formatFun?: (value: number, col: number, row: number, table: BaseTableAPI) => number | string;\n}\nexport type AggregationRules = AggregationRule<AggregationType>[];\n\n//#endregion 聚合规则\n\n//#region 映射规则\nexport interface MappingRule {\n  label?: LabelMapping;\n  symbol?: SymbolMapping;\n  bgColor?: MappingFuncRule;\n}\nexport type MappingRules = MappingRule[];\nexport interface LabelMapping {\n  text?: MappingFuncRule;\n  color?: MappingFuncRule;\n}\nexport interface SymbolMapping {\n  shape?: 'circle' | 'rect';\n  color?: MappingFuncRule;\n  size?: MappingFuncRule;\n}\n\nexport type MappingFuncRule = {\n  indicatorKey: string;\n  mapping?: ColorPropertyDefine;\n};\n\n//#endregion 映射规则\n\n//#region 派生字段规则\nexport interface DerivedFieldRule {\n  fieldName?: string;\n  derivedFunc?: (record: Record<string, any>) => any;\n}\nexport type DerivedFieldRules = DerivedFieldRule[];\n//#endregion 派生字段规则\n\n//#region 计算字段规则\nexport interface CalculateddFieldRule {\n  /** 唯一标识，可以当做新指标的key，用于配置在 indicators 中在透视表中展示。 */\n  key: string;\n  /** 计算字段依赖的指标，可以是在 records 中具体对应的指标字段 or 不是数据records 中的字段\n   * 如果依赖的指标不在 records 中，则需要在 aggregationRules 中明确配置，具体指明聚合规则和 indicatorKey 以在 dependIndicatorKeys 所使用。 */\n  dependIndicatorKeys: string[];\n  /** 计算字段的计算函数，依赖的指标值作为参数传入，返回值作为计算字段的值。   */\n  calculateFun?: (dependFieldsValue: any) => any;\n}\n\nexport type CalculateddFieldRules = CalculateddFieldRule[];\n//#endregion 计算字段规则\n\n/**\n * 基本表数据处理配置\n */\nexport interface IListTableDataConfig {\n  groupByRules?: string[]; //按照行列维度分组规则；\n  // aggregationRules?: AggregationRules; //按照行列维度聚合值计算规则；\n  // sortRules?: SortTypeRule | SortByRule | SortFuncRule; //排序规则 不能简单的将sortState挪到这里 sort的规则在column中配置的；\n  filterRules?: FilterRules; //过滤规则；\n  // totals?: Totals; //小计或总计；\n  // derivedFieldRules?: DerivedFieldRules;\n}\n/**\n * 透视表数据处理配置\n */\nexport interface IPivotTableDataConfig {\n  aggregationRules?: AggregationRules; //按照行列维度聚合值计算规则；\n  sortRules?: SortRules; //排序规则；\n  filterRules?: FilterRules; //过滤规则；\n  totals?: Totals; //小计或总计；\n  /**\n   * 目前mappding还不太好用  不建议使用  建议先用style\n   */\n  mappingRules?: MappingRules;\n  derivedFieldRules?: DerivedFieldRules;\n  calculatedFieldRules?: CalculateddFieldRules;\n}\n\n/**\n * 透视图数据处理配置\n */\nexport interface IPivotChartDataConfig extends IPivotTableDataConfig {\n  /**\n   * PivotChart专有\n   */\n  collectValuesBy?: Record<string, CollectValueBy>;\n  /**\n   * PivotChart专有\n   */\n  isPivotChart?: boolean;\n  /**\n   * PivotChart专有\n   */\n  dimensionSortArray?: string[];\n}\n\n/** 在处理数据的过程中 去额外收集某个维度的维度值范围 可为离散值或者连续值范围 */\nexport type CollectValueBy = {\n  /** 要收集的字段按什么进行分组 */\n  by: string[];\n  /** 是否计算一个range范围 true的话对应的收集数据的结果为{max:number,min:number} */\n  range?: boolean;\n  /** 收集是按照sumBy字段相同的进行分组聚合 聚合结果求最大最小值；如果不设置该值 则按单条数据求最大最小值 */\n  sumBy?: string[];\n  /** 帮助计算列宽使用 如果是chart图表 收集的是xFiled的维度值 可以根据维度值的个数乘于图元宽度计算一个最优列宽*/\n  type?: 'xField' | 'yField' | undefined;\n  /** 如果是收集的离散值，离散值的排序依据 */\n  sortBy?: string[];\n  /** chartSpec中设置了markLine autoRange的情况 考虑扩展轴范围 */\n  extendRange?: number | 'sum' | 'max';\n};\nexport type CollectedValue = { max?: number; min?: number } | Array<string>;\n\n//#region 提供给基本表格的类型\nexport type Aggregation = {\n  aggregationType: AggregationType;\n  showOnTop?: boolean;\n  formatFun?: (value: number, col: number, row: number, table: BaseTableAPI) => string | number;\n};\n\nexport type CustomAggregation = {\n  aggregationType: AggregationType.CUSTOM;\n  aggregationFun: (values: any[], records: any[]) => any;\n  showOnTop?: boolean;\n  formatFun?: (value: number, col: number, row: number, table: BaseTableAPI) => string | number;\n};\n//#endregion\n"]}