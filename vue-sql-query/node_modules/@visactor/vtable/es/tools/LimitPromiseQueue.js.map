{"version":3,"sources":["../src/tools/LimitPromiseQueue.ts"],"names":[],"mappings":"AAAA,MAAM,OAAO,iBAAiB;IAI5B,YAAY,GAAW;QACrB,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC;QACf,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC;QAChB,IAAI,CAAC,iBAAiB,GAAG,EAAE,CAAC;IAC9B,CAAC;IAOD,IAAI,CAAC,MAAW,EAAE,GAAG,GAAU;QAC7B,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;YACrC,MAAM,IAAI,GAAG,IAAI,CAAC,WAAW,CAAC,MAAM,EAAE,GAAG,EAAE,OAAO,EAAE,MAAM,CAAC,CAAC;YAC5D,IAAI,IAAI,CAAC,MAAM,IAAI,IAAI,CAAC,GAAG,EAAE;gBAC3B,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;aACnC;iBAAM;gBACL,IAAI,EAAE,CAAC;aACR;QACH,CAAC,CAAC,CAAC;IACL,CAAC;IAWD,WAAW,CAAC,MAAgB,EAAE,GAAU,EAAE,OAAY,EAAE,MAAW;QACjE,OAAO,GAAG,EAAE;YAEV,IAAI,CAAC,MAAM,EAAE,CAAC;YAEd,MAAM,CAAC,GAAG,GAAG,CAAC;iBACX,IAAI,CAAC,OAAO,CAAC;iBACb,KAAK,CAAC,MAAM,CAAC;iBACb,OAAO,CAAC,GAAG,EAAE;gBACZ,OAAO,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;gBAEvB,IAAI,CAAC,MAAM,EAAE,CAAC;gBACd,IAAI,IAAI,CAAC,iBAAiB,CAAC,MAAM,EAAE;oBACjC,MAAM,IAAI,GAAG,IAAI,CAAC,iBAAiB,CAAC,KAAK,EAAE,CAAC;oBAC5C,IAAI,EAAE,CAAC;iBACR;YACH,CAAC,CAAC,CAAC;QACP,CAAC,CAAC;IACJ,CAAC;CACF","file":"LimitPromiseQueue.js","sourcesContent":["export class LimitPromiseQueue {\n  max: number;\n  _count: number;\n  _pendingTaskQueue: Function[];\n  constructor(max: number) {\n    this.max = max;\n    this._count = 0;\n    this._pendingTaskQueue = [];\n  }\n  /**\n   * 调用器，将异步任务函数和它的参数传入\n   * @param caller 异步任务函数，返回Promise的函数\n   * @param args 异步任务函数的参数列表\n   * @returns {Promise} 返回一个新的Promise\n   */\n  call(caller: any, ...arg: any[]) {\n    return new Promise((resolve, reject) => {\n      const task = this._createTask(caller, arg, resolve, reject);\n      if (this._count >= this.max) {\n        this._pendingTaskQueue.push(task);\n      } else {\n        task();\n      }\n    });\n  }\n\n  /**\n   * 创建一个任务\n   * @param caller 实际执行的函数\n   * @param args 执行函数的参数\n   * @param resolve\n   * @param reject\n   * @returns {Function} 返回一个任务函数\n   * @private\n   */\n  _createTask(caller: Function, arg: any[], resolve: any, reject: any) {\n    return () => {\n      // 当前请求数量加一\n      this._count++;\n      // 实际上是在这里调用了异步任务，并将异步任务的返回（resolve和reject）抛给了上层\n      caller(...arg)\n        .then(resolve)\n        .catch(reject)\n        .finally(() => {\n          console.log('finally');\n          // 任务队列的消费区，利用Promise的finally方法，在异步任务结束后，取出下一个任务执行\n          this._count--;\n          if (this._pendingTaskQueue.length) {\n            const task = this._pendingTaskQueue.shift();\n            task();\n          }\n        });\n    };\n  }\n}\n"]}