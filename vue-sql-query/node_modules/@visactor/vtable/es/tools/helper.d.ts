import type { CellPosition, CellRange, MaybeCall } from '../ts-types';
declare const isNode: boolean;
type ArrayElementPredicate = (t: any, i: number, arr: any[]) => boolean;
declare const array: {
    readonly find: (arr: any[], predicate: ArrayElementPredicate) => any;
    readonly findIndex: (arr: any[], predicate: ArrayElementPredicate) => number;
};
declare function isObject(obj: any): obj is Record<string, any>;
export declare function omit<T, K extends keyof T>(source: T, omits: K[]): Omit<T, K>;
export declare function defaults(source: any, defs: Partial<any>): any;
export declare function extend<T, U>(t: T, u: U): T & U;
export declare function extend<T, U, V>(t: T, u: U, v: V): T & U & V;
export declare function extend<T>(...args: T[]): T;
declare function applyChainSafe(obj: any, fn: (value: any, name: string) => any, ...names: string[]): any;
declare function getChainSafe(obj: any, ...names: string[]): any;
declare function getOrApply<_T, A extends any[]>(value: undefined, ...args: A): undefined;
declare function getOrApply<_T, A extends any[]>(value: null, ...args: A): null;
declare function getOrApply<T, A extends any[]>(value: MaybeCall<T, A>, ...args: A): T;
declare function endsWith(str: string, searchString: string, position?: number): boolean;
export declare function isPromise(data: any | Promise<any> | undefined): data is Promise<any>;
export declare function getPromiseValue<T = any>(value: T | Promise<T>, callback: (value: T) => void): void;
declare function isTouchEvent(e: TouchEvent | MouseEvent): e is TouchEvent;
declare function getIgnoreCase(obj: any, name: string): any;
export declare function toBoxArray<T>(obj: T | T[]): [T, T, T, T];
export { isNode, getChainSafe, applyChainSafe, getOrApply, getIgnoreCase, array };
export declare function cellInRange(range: CellRange, col: number, row: number): boolean;
export declare function cellInRanges(ranges: CellRange[], col: number, row: number): boolean;
export declare function adjust(range: CellRange): CellRange;
export declare function rangeIntersected(range: CellRange, range1: CellRange): boolean;
export declare function rangeContained(range: CellRange, range1: CellRange): boolean;
export declare const browser: {
    IE: boolean;
    Edge: boolean;
    Chrome: boolean;
    Firefox: boolean;
    Safari: boolean;
    heightLimit: number;
};
export declare const obj: {
    isObject: typeof isObject;
};
export declare const str: {
    endsWith: typeof endsWith;
};
export declare const event: {
    isTouchEvent: typeof isTouchEvent;
};
export declare const style: {
    toBoxArray: typeof toBoxArray;
};
export declare const emptyFn: Function;
export declare function cellInPlaneRange(col: number, row: number, rangePosStart: CellPosition, rangePosEnd: CellPosition): boolean;
export type Either<X, Y> = ({
    [KX in keyof X]: X[KX];
} & {
    [KY in Exclude<keyof Y, keyof X>]?: never;
}) | ({
    [KY in keyof Y]: Y[KY];
} & {
    [KX in Exclude<keyof X, keyof Y>]?: never;
});
export declare function checkIntersect(rectA: {
    x1: number;
    x2: number;
    y1: number;
    y2: number;
}, rectB: {
    x1: number;
    x2: number;
    y1: number;
    y2: number;
}): boolean;
