import { validToString } from "../tools/util";

const isNode = "undefined" == typeof window || void 0 === window.window;

let arrayFind, arrayFindIndex;

const array = {
    get find() {
        return arrayFind || (arrayFind = Array.prototype.find ? (arr, predicate) => Array.prototype.find.call(arr, predicate) : (arr, predicate) => {
            const index = array.findIndex(arr, predicate);
            return index >= 0 ? arr[index] : void 0;
        }, arrayFind);
    },
    get findIndex() {
        return arrayFindIndex || (arrayFindIndex = Array.prototype.findIndex ? (arr, predicate) => Array.prototype.findIndex.call(arr, predicate) : (arr, predicate) => {
            const {length: length} = arr;
            for (let i = 0; i < length; i++) {
                if (predicate(arr[i], i, arr)) return i;
            }
            return -1;
        }, arrayFindIndex);
    }
};

function analyzeUserAgent() {
    if (isNode) return {
        IE: !1,
        Edge: !1,
        Chrome: !1,
        Firefox: !1,
        Safari: !1
    };
    const ua = window.navigator.userAgent.toLowerCase();
    return {
        IE: !!/(msie|trident)/.exec(ua),
        Edge: ua.indexOf("edge") > -1,
        Chrome: ua.indexOf("chrome") > -1 && -1 === ua.indexOf("edge"),
        Firefox: ua.indexOf("firefox") > -1,
        Safari: ua.indexOf("safari") > -1 && -1 === ua.indexOf("edge")
    };
}

const {IE: IE, Chrome: Chrome, Firefox: Firefox, Edge: Edge, Safari: Safari} = analyzeUserAgent();

function isObject(obj) {
    return obj === Object(obj);
}

export function omit(source, omits) {
    const result = {};
    for (const key in source) omits.indexOf(key) >= 0 || Object.defineProperty(result, key, {
        get: () => source[key],
        set(val) {
            source[key] = val;
        },
        configurable: !0,
        enumerable: !0
    });
    return result;
}

export function defaults(source, defs) {
    const keys = [], result = {};
    for (const key in source) keys.push(key), Object.defineProperty(result, key, {
        get() {
            const val = source[key];
            return void 0 === val ? defs[key] : val;
        },
        set(val) {
            source[key] = val;
        },
        configurable: !0,
        enumerable: !0
    });
    for (const key in defs) keys.indexOf(key) >= 0 || Object.defineProperty(result, key, {
        get() {
            const val = source[key];
            return void 0 === val ? defs[key] : val;
        },
        set(val) {
            source[key] = val;
        },
        configurable: !0,
        enumerable: !0
    });
    return result;
}

export function extend(...args) {
    const result = {};
    return args.forEach((source => {
        for (const key in source) Object.defineProperty(result, key, {
            get: () => source[key],
            set(val) {
                source[key] = val;
            },
            configurable: !0,
            enumerable: !0
        });
    })), result;
}

function applyChainSafe(obj, fn, ...names) {
    let value = obj;
    for (let i = 0; i < names.length && null != value; i++) value = fn(value, names[i]);
    return value;
}

function getChainSafe(obj, ...names) {
    return applyChainSafe(obj, ((val, name) => val[name]), ...names);
}

function getOrApply(value, ...args) {
    return "function" == typeof value ? value(...args) : value;
}

function endsWith(str, searchString, position) {
    const subjectString = validToString(str);
    ("number" != typeof position || !isFinite(position) || Math.floor(position) !== position || position > subjectString.length) && (position = subjectString.length), 
    position -= searchString.length;
    const lastIndex = subjectString.lastIndexOf(searchString, position);
    return -1 !== lastIndex && lastIndex === position;
}

export function isPromise(data) {
    return Boolean(data && "function" == typeof data.then);
}

export function getPromiseValue(value, callback) {
    isPromise(value) ? value.then((result => {
        callback(result);
    })).catch((err => {})) : callback(value);
}

function isTouchEvent(e) {
    return !!e.changedTouches;
}

function getIgnoreCase(obj, name) {
    if (obj[name]) return obj[name];
    const l = name.toLowerCase();
    if (obj[l]) return obj[l];
    const u = name.toLowerCase();
    if (obj[u]) return obj[u];
    for (const k in obj) if (k.toLowerCase() === l) return obj[k];
}

export function toBoxArray(obj) {
    return Array.isArray(obj) ? 3 === obj.length ? [ obj[0], obj[1], obj[2], obj[1] ] : 2 === obj.length ? [ obj[0], obj[1], obj[0], obj[1] ] : 1 === obj.length ? [ obj[0], obj[0], obj[0], obj[0] ] : [ obj[0], obj[1], obj[2], obj[3] ] : [ obj, obj, obj, obj ];
}

export { isNode, getChainSafe, applyChainSafe, getOrApply, getIgnoreCase, array };

export function cellInRange(range, col, row) {
    return range.start.col <= col && col <= range.end.col && range.start.row <= row && row <= range.end.row || range.end.col <= col && col <= range.start.col && range.end.row <= row && row <= range.start.row || range.end.col <= col && col <= range.start.col && range.start.row <= row && row <= range.end.row || range.start.col <= col && col <= range.end.col && range.end.row <= row && row <= range.start.row;
}

export function cellInRanges(ranges, col, row) {
    for (let i = 0; i < ranges.length; i++) {
        const range = ranges[i], startCol = Math.min(range.start.col, range.end.col), endCol = Math.max(range.start.col, range.end.col), startRow = Math.min(range.start.row, range.end.row), endRow = Math.max(range.start.row, range.end.row);
        if (startCol <= col && col <= endCol && startRow <= row && row <= endRow || endCol <= col && col <= startCol && endRow <= row && row <= startRow) return !0;
    }
    return !1;
}

export function adjust(range) {
    return {
        start: {
            col: Math.min(range.start.col, range.end.col),
            row: Math.min(range.start.row, range.end.row)
        },
        end: {
            col: Math.max(range.start.col, range.end.col),
            row: Math.max(range.start.row, range.end.row)
        }
    };
}

export function rangeIntersected(range, range1) {
    const rangeAdjust = adjust(range), range1Adjust = adjust(range1);
    if (Math.max(rangeAdjust.start.col, range1Adjust.start.col) <= Math.min(rangeAdjust.end.col, range1Adjust.end.col)) {
        if (Math.max(rangeAdjust.start.row, range1Adjust.start.row) <= Math.min(rangeAdjust.end.row, range1Adjust.end.row)) return !0;
    }
    return !1;
}

export function rangeContained(range, range1) {
    const rangeAdjust = adjust(range), range1Adjust = adjust(range1);
    return rangeAdjust.start.col <= range1Adjust.start.col && rangeAdjust.end.col >= range1Adjust.end.col && rangeAdjust.start.row <= range1Adjust.start.row && rangeAdjust.end.row >= range1Adjust.end.row;
}

export const browser = {
    IE: IE,
    Edge: Edge,
    Chrome: Chrome,
    Firefox: Firefox,
    Safari: Safari,
    heightLimit: Chrome ? 33554431 : Firefox ? 17895588 : 10737433
};

export const obj = {
    isObject: isObject
};

export const str = {
    endsWith: endsWith
};

export const event = {
    isTouchEvent: isTouchEvent
};

export const style = {
    toBoxArray: toBoxArray
};

export const emptyFn = Function.prototype;

export function cellInPlaneRange(col, row, rangePosStart, rangePosEnd) {
    return rangePosStart.col <= col && col <= rangePosEnd.col && rangePosStart.row <= row && row <= rangePosEnd.row || rangePosEnd.col <= col && col <= rangePosStart.col && rangePosEnd.row <= row && row <= rangePosStart.row;
}

export function checkIntersect(rectA, rectB) {
    return !(rectA.x2 <= rectB.x1 || rectA.x1 >= rectB.x2 || rectA.y2 <= rectB.y1 || rectA.y1 >= rectB.y2) && !(rectA.x1 <= rectB.x1 && rectA.x2 >= rectB.x2 && rectA.y1 <= rectB.y1 && rectA.y2 >= rectB.y2 || rectB.x1 <= rectA.x1 && rectB.x2 >= rectA.x2 && rectB.y1 <= rectA.y1 && rectB.y2 >= rectA.y2);
}
//# sourceMappingURL=helper.js.map
