{"version":3,"sources":["../src/tools/get-data-path/index.ts"],"names":[],"mappings":"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","file":"index.js","sourcesContent":["import { isArray } from '@visactor/vutils';\nimport type { PivotChart } from '../../PivotChart';\nimport type { IPivotTableCellHeaderPaths, PivotChartConstructorOptions } from '../../ts-types';\nimport { createDataset } from './create-dataset';\nimport { PivotHeaderLayoutMap } from '../../layout/pivot-header-layout';\nimport type { ITreeLayoutHeadNode } from '../../layout/tree-helper';\nimport { DimensionTree } from '../../layout/tree-helper';\nimport { IndicatorDimensionKeyPlaceholder } from '../global';\n\nexport function getDataCellPath(\n  options: PivotChartConstructorOptions,\n  data: Object,\n  compareFunc?: (a: any, b: any) => boolean\n): IPivotTableCellHeaderPaths | undefined {\n  // mock dataset\n  const results = createDataset(options);\n  let columnDimensionTree = results.columnDimensionTree;\n  let rowDimensionTree = results.rowDimensionTree;\n\n  let isNeedResetColumnDimensionTree = false;\n  let isNeedResetRowDimensionTree = false;\n  if (options.columnTree) {\n    if (options.indicatorsAsCol && !columnDimensionTree.dimensionKeys.contain(IndicatorDimensionKeyPlaceholder)) {\n      isNeedResetColumnDimensionTree = true;\n    }\n  }\n  if (options.rowTree) {\n    if (!options.indicatorsAsCol && !rowDimensionTree.dimensionKeys.contain(IndicatorDimensionKeyPlaceholder)) {\n      isNeedResetRowDimensionTree = true;\n    }\n  }\n  const { dataset, layoutNodeId } = results;\n  // mock pivotChart\n  const mockTable = {\n    options,\n    layoutNodeId,\n    internalProps: options,\n    isPivotChart: () => true,\n    pivotChartAxes: [] as any[],\n    _selectedDataItemsInChart: [] as any[],\n    _getActiveChartInstance: () => {\n      return {\n        updateState: () => {\n          // do nothing\n        }\n      };\n    }\n  };\n  if (!options.columnTree || isNeedResetColumnDimensionTree) {\n    columnDimensionTree = new DimensionTree((dataset.colHeaderTree as ITreeLayoutHeadNode[]) ?? [], layoutNodeId);\n  }\n  if (!options.rowTree || isNeedResetRowDimensionTree) {\n    rowDimensionTree = new DimensionTree((dataset.rowHeaderTree as ITreeLayoutHeadNode[]) ?? [], layoutNodeId);\n  }\n  // mock layoutMap\n  const layoutMap = new PivotHeaderLayoutMap(\n    mockTable as unknown as PivotChart,\n    dataset,\n    columnDimensionTree,\n    rowDimensionTree\n  );\n\n  // compare data\n  for (let col = 0; col < layoutMap.colCount; col++) {\n    for (let row = 0; row < layoutMap.rowCount; row++) {\n      if (layoutMap.isHeader(col, row)) {\n        continue;\n      }\n\n      const cellDimensionPath = layoutMap.getCellHeaderPaths(col, row);\n      const colKeys = cellDimensionPath.colHeaderPaths.map((colPath: any) => {\n        return colPath.indicatorKey ?? colPath.value;\n      });\n      const rowKeys = cellDimensionPath.rowHeaderPaths.map((rowPath: any) => {\n        return rowPath.indicatorKey ?? rowPath.value;\n      });\n      // const aggregator = dataset.getAggregator(\n      //   rowKey[rowKey.length - 1],\n      //   colKey[colKey.length - 1],\n      //   (layoutMap as PivotHeaderLayoutMap).getIndicatorKey(col, row)\n      // );\n\n      const aggregator = dataset.getAggregator(\n        !layoutMap.indicatorsAsCol ? rowKeys.slice(0, -1) : rowKeys,\n        layoutMap.indicatorsAsCol ? colKeys.slice(0, -1) : colKeys,\n        (layoutMap as PivotHeaderLayoutMap).getIndicatorKey(col, row)\n      );\n\n      const result = compareData(\n        aggregator.value ? aggregator.value() : undefined,\n        data,\n        col,\n        row,\n        layoutMap,\n        compareFunc\n      );\n      if (result) {\n        return result;\n      }\n    }\n  }\n  return undefined;\n}\n\nfunction compareData(\n  data1: Object[],\n  data2: Object,\n  col: number,\n  row: number,\n  layoutMap: PivotHeaderLayoutMap,\n  compareFunc?: (a: any, b: any) => boolean\n) {\n  if (isArray(data1)) {\n    for (let i = 0; i < data1.length; i++) {\n      if (compareFunc ? compareFunc(data1[i], data2) : defaultCompare(data1[i], data2)) {\n        return layoutMap.getCellHeaderPaths(col, row);\n      }\n    }\n  }\n  return undefined;\n}\n\nfunction defaultCompare(a: any, b: any) {\n  return JSON.stringify(a) === JSON.stringify(b);\n}\n"]}