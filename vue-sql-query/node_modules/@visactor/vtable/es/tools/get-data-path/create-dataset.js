import { Dataset } from "../../dataset/dataset";

import { supplementIndicatorNodesForCustomTree } from "../../layout/layout-helper";

import { DimensionTree } from "../../layout/tree-helper";

import { AggregationType } from "../../ts-types";

export function createDataset(options) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
    const layoutNodeId = {
        seqId: 0
    }, dataConfig = {
        isPivotChart: !0
    };
    let columnDimensionTree, rowDimensionTree, columnTree, rowTree;
    options.columnTree && (!1 !== options.indicatorsAsCol && (columnTree = supplementIndicatorNodesForCustomTree(options.columnTree, options.indicators)), 
    columnDimensionTree = new DimensionTree(null !== (_a = options.columnTree) && void 0 !== _a ? _a : [], layoutNodeId)), 
    options.rowTree && (!1 === options.indicatorsAsCol && (rowTree = supplementIndicatorNodesForCustomTree(options.rowTree, options.indicators)), 
    rowDimensionTree = new DimensionTree(null !== (_b = options.rowTree) && void 0 !== _b ? _b : [], layoutNodeId));
    const rowKeys = (null === (_c = rowDimensionTree.dimensionKeys) || void 0 === _c ? void 0 : _c.count) ? rowDimensionTree.dimensionKeys.valueArr() : null !== (_e = null === (_d = options.rows) || void 0 === _d ? void 0 : _d.reduce(((keys, rowObj) => ("string" == typeof rowObj ? keys.push(rowObj) : keys.push(rowObj.dimensionKey), 
    keys)), [])) && void 0 !== _e ? _e : [], columnKeys = (null === (_f = columnDimensionTree.dimensionKeys) || void 0 === _f ? void 0 : _f.count) ? columnDimensionTree.dimensionKeys.valueArr() : null !== (_h = null === (_g = options.columns) || void 0 === _g ? void 0 : _g.reduce(((keys, columnObj) => ("string" == typeof columnObj ? keys.push(columnObj) : keys.push(columnObj.dimensionKey), 
    keys)), [])) && void 0 !== _h ? _h : [], indicatorKeys = null !== (_k = null === (_j = options.indicators) || void 0 === _j ? void 0 : _j.reduce(((keys, indicatorObj) => ("string" == typeof indicatorObj ? keys.push(indicatorObj) : keys.push(indicatorObj.indicatorKey), 
    keys)), [])) && void 0 !== _k ? _k : [];
    dataConfig.collectValuesBy = _generateCollectValuesConfig(options, columnKeys, rowKeys), 
    dataConfig.aggregationRules = _generateAggregationRules(options);
    return {
        dataset: new Dataset(dataConfig, rowKeys, columnKeys, indicatorKeys, options.indicators, null === (_l = options.indicatorsAsCol) || void 0 === _l || _l, options.records, void 0, void 0, columnTree || options.columnTree, rowTree || options.rowTree, !0),
        columnDimensionTree: columnDimensionTree,
        rowDimensionTree: rowDimensionTree,
        layoutNodeId: layoutNodeId
    };
}

function _generateCollectValuesConfig(option, columnKeys, rowKeys) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y;
    const collectValuesBy = {};
    for (let i = 0, len = null === (_a = option.indicators) || void 0 === _a ? void 0 : _a.length; i < len; i++) if ("string" != typeof option.indicators[i] && option.indicators[i].chartSpec) if (!1 === option.indicatorsAsCol) {
        const indicatorDefine = option.indicators[i];
        if (collectValuesBy[indicatorDefine.indicatorKey] = {
            by: rowKeys,
            range: !0,
            sumBy: !1 !== (null === (_b = indicatorDefine.chartSpec) || void 0 === _b ? void 0 : _b.stack) && columnKeys.concat(null === (_c = indicatorDefine.chartSpec) || void 0 === _c ? void 0 : _c.xField)
        }, indicatorDefine.chartSpec.series) indicatorDefine.chartSpec.series.forEach((chartSeries => {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
            const xField = "string" == typeof chartSeries.xField ? chartSeries.xField : chartSeries.xField[0];
            collectValuesBy[xField] = {
                by: columnKeys,
                type: "horizontal" !== chartSeries.direction ? "xField" : void 0,
                range: "horizontal" === chartSeries.direction,
                sortBy: "horizontal" !== chartSeries.direction ? null !== (_d = null === (_c = null === (_b = null === (_a = null == chartSeries ? void 0 : chartSeries.data) || void 0 === _a ? void 0 : _a.fields) || void 0 === _b ? void 0 : _b[xField]) || void 0 === _c ? void 0 : _c.domain) && void 0 !== _d ? _d : null === (_h = null === (_g = null === (_f = null === (_e = indicatorDefine.chartSpec) || void 0 === _e ? void 0 : _e.data) || void 0 === _f ? void 0 : _f.fields) || void 0 === _g ? void 0 : _g[xField]) || void 0 === _h ? void 0 : _h.domain : void 0
            };
            const yField = chartSeries.yField;
            collectValuesBy[yField] = {
                by: rowKeys,
                range: "horizontal" !== chartSeries.direction,
                sumBy: !1 !== chartSeries.stack && columnKeys.concat(null == chartSeries ? void 0 : chartSeries.xField),
                sortBy: "horizontal" === chartSeries.direction ? null !== (_m = null === (_l = null === (_k = null === (_j = null == chartSeries ? void 0 : chartSeries.data) || void 0 === _j ? void 0 : _j.fields) || void 0 === _k ? void 0 : _k[yField]) || void 0 === _l ? void 0 : _l.domain) && void 0 !== _m ? _m : null === (_r = null === (_q = null === (_p = null === (_o = indicatorDefine.chartSpec) || void 0 === _o ? void 0 : _o.data) || void 0 === _p ? void 0 : _p.fields) || void 0 === _q ? void 0 : _q[yField]) || void 0 === _r ? void 0 : _r.domain : void 0
            };
        })); else {
            const xField = "string" == typeof indicatorDefine.chartSpec.xField ? indicatorDefine.chartSpec.xField : indicatorDefine.chartSpec.xField[0];
            collectValuesBy[xField] = {
                by: columnKeys,
                type: "horizontal" !== indicatorDefine.chartSpec.direction ? "xField" : void 0,
                range: "horizontal" === indicatorDefine.chartSpec.direction,
                sortBy: "horizontal" !== indicatorDefine.chartSpec.direction ? null === (_g = null === (_f = null === (_e = null === (_d = indicatorDefine.chartSpec) || void 0 === _d ? void 0 : _d.data) || void 0 === _e ? void 0 : _e.fields) || void 0 === _f ? void 0 : _f[xField]) || void 0 === _g ? void 0 : _g.domain : void 0
            };
            const yField = indicatorDefine.chartSpec.yField;
            collectValuesBy[yField] = {
                by: rowKeys,
                range: "horizontal" !== option.indicators[i].chartSpec.direction,
                sumBy: !1 !== indicatorDefine.chartSpec.stack && columnKeys.concat(null === (_h = indicatorDefine.chartSpec) || void 0 === _h ? void 0 : _h.xField),
                sortBy: "horizontal" === indicatorDefine.chartSpec.direction ? null === (_m = null === (_l = null === (_k = null === (_j = indicatorDefine.chartSpec) || void 0 === _j ? void 0 : _j.data) || void 0 === _k ? void 0 : _k.fields) || void 0 === _l ? void 0 : _l[yField]) || void 0 === _m ? void 0 : _m.domain : void 0
            };
        }
    } else {
        const indicatorDefine = option.indicators[i];
        if (collectValuesBy[indicatorDefine.indicatorKey] = {
            by: columnKeys,
            range: !0,
            sumBy: !1 !== (null === (_o = indicatorDefine.chartSpec) || void 0 === _o ? void 0 : _o.stack) && rowKeys.concat(null === (_p = indicatorDefine.chartSpec) || void 0 === _p ? void 0 : _p.yField)
        }, indicatorDefine.chartSpec.series) indicatorDefine.chartSpec.series.forEach((chartSeries => {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
            const yField = "string" == typeof chartSeries.yField ? chartSeries.yField : chartSeries.yField[0];
            collectValuesBy[yField] = {
                by: rowKeys,
                type: "horizontal" === chartSeries.direction ? "yField" : void 0,
                range: "horizontal" !== chartSeries.direction,
                sortBy: "horizontal" === chartSeries.direction ? null !== (_d = null === (_c = null === (_b = null === (_a = null == chartSeries ? void 0 : chartSeries.data) || void 0 === _a ? void 0 : _a.fields) || void 0 === _b ? void 0 : _b[yField]) || void 0 === _c ? void 0 : _c.domain) && void 0 !== _d ? _d : null === (_h = null === (_g = null === (_f = null === (_e = indicatorDefine.chartSpec) || void 0 === _e ? void 0 : _e.data) || void 0 === _f ? void 0 : _f.fields) || void 0 === _g ? void 0 : _g[yField]) || void 0 === _h ? void 0 : _h.domain : void 0
            };
            const xField = chartSeries.xField;
            collectValuesBy[xField] = {
                by: columnKeys,
                range: "horizontal" === chartSeries.direction,
                sumBy: !1 !== chartSeries.stack && rowKeys.concat(null == chartSeries ? void 0 : chartSeries.yField),
                sortBy: "horizontal" !== chartSeries.direction ? null !== (_m = null === (_l = null === (_k = null === (_j = null == chartSeries ? void 0 : chartSeries.data) || void 0 === _j ? void 0 : _j.fields) || void 0 === _k ? void 0 : _k[xField]) || void 0 === _l ? void 0 : _l.domain) && void 0 !== _m ? _m : null === (_r = null === (_q = null === (_p = null === (_o = indicatorDefine.chartSpec) || void 0 === _o ? void 0 : _o.data) || void 0 === _p ? void 0 : _p.fields) || void 0 === _q ? void 0 : _q[xField]) || void 0 === _r ? void 0 : _r.domain : void 0
            };
        })); else {
            const yField = "string" == typeof indicatorDefine.chartSpec.yField ? indicatorDefine.chartSpec.yField : indicatorDefine.chartSpec.yField[0];
            collectValuesBy[yField] = {
                by: rowKeys,
                type: "horizontal" === indicatorDefine.chartSpec.direction ? "yField" : void 0,
                range: "horizontal" !== indicatorDefine.chartSpec.direction,
                sortBy: "horizontal" === indicatorDefine.chartSpec.direction ? null === (_t = null === (_s = null === (_r = null === (_q = indicatorDefine.chartSpec) || void 0 === _q ? void 0 : _q.data) || void 0 === _r ? void 0 : _r.fields) || void 0 === _s ? void 0 : _s[yField]) || void 0 === _t ? void 0 : _t.domain : void 0
            };
            const xField = indicatorDefine.chartSpec.xField;
            collectValuesBy[xField] = {
                by: columnKeys,
                range: "horizontal" === option.indicators[i].chartSpec.direction,
                sumBy: !1 !== indicatorDefine.chartSpec.stack && rowKeys.concat(null === (_u = indicatorDefine.chartSpec) || void 0 === _u ? void 0 : _u.yField),
                sortBy: "horizontal" !== indicatorDefine.chartSpec.direction ? null === (_y = null === (_x = null === (_w = null === (_v = indicatorDefine.chartSpec) || void 0 === _v ? void 0 : _v.data) || void 0 === _w ? void 0 : _w.fields) || void 0 === _x ? void 0 : _x[xField]) || void 0 === _y ? void 0 : _y.domain : void 0
            };
        }
    }
    return collectValuesBy;
}

function _generateAggregationRules(options) {
    var _a;
    const aggregationRules = [];
    return null === (_a = options.indicators) || void 0 === _a || _a.forEach((indicator => {
        var _a, _b;
        if ("string" == typeof indicator) aggregationRules.push({
            indicatorKey: indicator,
            field: indicator,
            aggregationType: AggregationType.RECORD
        }); else if (null === (_a = indicator.chartSpec) || void 0 === _a ? void 0 : _a.series) {
            const fields = [];
            null === (_b = indicator.chartSpec) || void 0 === _b || _b.series.forEach((seriesSpec => {
                const seriesField = !1 === options.indicatorsAsCol ? seriesSpec.yField : seriesSpec.xField;
                -1 === fields.indexOf(seriesField) && fields.push(seriesField);
            })), aggregationRules.push({
                indicatorKey: indicator.indicatorKey,
                field: fields,
                aggregationType: AggregationType.RECORD
            });
        } else {
            const field = !1 === options.indicatorsAsCol ? indicator.chartSpec.yField : indicator.chartSpec.xField;
            aggregationRules.push({
                indicatorKey: indicator.indicatorKey,
                field: null != field ? field : indicator.indicatorKey,
                aggregationType: AggregationType.RECORD
            });
        }
    })), aggregationRules;
}
//# sourceMappingURL=create-dataset.js.map
