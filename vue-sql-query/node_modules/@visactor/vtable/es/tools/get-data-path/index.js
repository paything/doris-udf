import { isArray } from "@visactor/vutils";

import { createDataset } from "./create-dataset";

import { PivotHeaderLayoutMap } from "../../layout/pivot-header-layout";

import { DimensionTree } from "../../layout/tree-helper";

import { IndicatorDimensionKeyPlaceholder } from "../global";

export function getDataCellPath(options, data, compareFunc) {
    var _a, _b;
    const results = createDataset(options);
    let columnDimensionTree = results.columnDimensionTree, rowDimensionTree = results.rowDimensionTree, isNeedResetColumnDimensionTree = !1, isNeedResetRowDimensionTree = !1;
    options.columnTree && options.indicatorsAsCol && !columnDimensionTree.dimensionKeys.contain(IndicatorDimensionKeyPlaceholder) && (isNeedResetColumnDimensionTree = !0), 
    options.rowTree && (options.indicatorsAsCol || rowDimensionTree.dimensionKeys.contain(IndicatorDimensionKeyPlaceholder) || (isNeedResetRowDimensionTree = !0));
    const {dataset: dataset, layoutNodeId: layoutNodeId} = results, mockTable = {
        options: options,
        layoutNodeId: layoutNodeId,
        internalProps: options,
        isPivotChart: () => !0,
        pivotChartAxes: [],
        _selectedDataItemsInChart: [],
        _getActiveChartInstance: () => ({
            updateState: () => {}
        })
    };
    options.columnTree && !isNeedResetColumnDimensionTree || (columnDimensionTree = new DimensionTree(null !== (_a = dataset.colHeaderTree) && void 0 !== _a ? _a : [], layoutNodeId)), 
    options.rowTree && !isNeedResetRowDimensionTree || (rowDimensionTree = new DimensionTree(null !== (_b = dataset.rowHeaderTree) && void 0 !== _b ? _b : [], layoutNodeId));
    const layoutMap = new PivotHeaderLayoutMap(mockTable, dataset, columnDimensionTree, rowDimensionTree);
    for (let col = 0; col < layoutMap.colCount; col++) for (let row = 0; row < layoutMap.rowCount; row++) {
        if (layoutMap.isHeader(col, row)) continue;
        const cellDimensionPath = layoutMap.getCellHeaderPaths(col, row), colKeys = cellDimensionPath.colHeaderPaths.map((colPath => {
            var _a;
            return null !== (_a = colPath.indicatorKey) && void 0 !== _a ? _a : colPath.value;
        })), rowKeys = cellDimensionPath.rowHeaderPaths.map((rowPath => {
            var _a;
            return null !== (_a = rowPath.indicatorKey) && void 0 !== _a ? _a : rowPath.value;
        })), aggregator = dataset.getAggregator(layoutMap.indicatorsAsCol ? rowKeys : rowKeys.slice(0, -1), layoutMap.indicatorsAsCol ? colKeys.slice(0, -1) : colKeys, layoutMap.getIndicatorKey(col, row)), result = compareData(aggregator.value ? aggregator.value() : void 0, data, col, row, layoutMap, compareFunc);
        if (result) return result;
    }
}

function compareData(data1, data2, col, row, layoutMap, compareFunc) {
    if (isArray(data1)) for (let i = 0; i < data1.length; i++) if (compareFunc ? compareFunc(data1[i], data2) : defaultCompare(data1[i], data2)) return layoutMap.getCellHeaderPaths(col, row);
}

function defaultCompare(a, b) {
    return JSON.stringify(a) === JSON.stringify(b);
}
//# sourceMappingURL=index.js.map
