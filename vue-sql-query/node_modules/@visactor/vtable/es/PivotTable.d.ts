import type { FieldData, FieldDef, PivotTableAPI, SortRules, CellAddress, ICellHeaderPaths, DropDownMenuEventInfo, FieldKeyDef, PivotTableConstructorOptions, IHeaderTreeDefine, IDimensionInfo, SortOrder, IPagination, CellLocation, FilterRules } from './ts-types';
import { HierarchyState } from './ts-types';
import { FlatDataToObjects } from './dataset/flatDataToObject';
import { PIVOT_TABLE_EVENT_TYPE } from './ts-types/pivot-table/PIVOT_TABLE_EVENT_TYPE';
import { Dataset } from './dataset/dataset';
import { BaseTable } from './core/BaseTable';
import type { PivotTableProtected } from './ts-types/base-table';
import { type LayouTreeNode } from './layout/tree-helper';
import type { IEditor } from '@visactor/vtable-editors';
export declare class PivotTable extends BaseTable implements PivotTableAPI {
    layoutNodeId: {
        seqId: number;
    };
    internalProps: PivotTableProtected;
    options: PivotTableConstructorOptions;
    pivotSortState: {
        dimensions: IDimensionInfo[];
        order: SortOrder;
    }[];
    dataset?: Dataset;
    flatDataToObjects?: FlatDataToObjects;
    constructor(options: PivotTableConstructorOptions);
    constructor(container: HTMLElement, options: PivotTableConstructorOptions);
    static get EVENT_TYPE(): typeof PIVOT_TABLE_EVENT_TYPE;
    isListTable(): false;
    isPivotTable(): true;
    isPivotChart(): false;
    get recordsCount(): any;
    _canResizeColumn(col: number, row: number): boolean;
    updateOption(options: PivotTableConstructorOptions): Promise<unknown>;
    updatePagination(pagination?: IPagination): void;
    refreshHeader(): void;
    refreshRowColCount(): void;
    protected _getSortFuncFromHeaderOption(columns: undefined, field: FieldDef, fieldKey?: FieldKeyDef): ((v1: any, v2: any, order: SortOrder) => 0 | 1 | -1) | undefined;
    get rowHierarchyType(): 'grid' | 'tree' | 'grid-tree';
    get columnHierarchyType(): 'grid' | 'grid-tree';
    _syncHierarchyState(sourceNode: any, targetNode: IHeaderTreeDefine): void;
    getRecordShowIndexByCell(col: number, row: number): number;
    getTableIndexByRecordIndex(recordIndex: number): number;
    getTableIndexByField(field: FieldDef): number;
    getCellAddrByFieldRecord(field: FieldDef, recordIndex: number): CellAddress;
    getBodyIndexByRow(row: number): number;
    getBodyIndexByCol(col: number): number;
    getFieldData(field: string, col: number, row: number): FieldData;
    getCellValue(col: number, row: number, skipCustomMerge?: boolean): FieldData;
    getCellOriginValue(col: number, row: number): FieldData;
    getCellRawValue(col: number, row: number): FieldData;
    getCellOriginRecord(col: number, row: number): any;
    getCellRawRecord(col: number, row: number): any;
    updateSortRules(sortRules: SortRules, col?: number, row?: number): void;
    _changePivotSortStateBySortRules(): void;
    _parseColumnWidthConfig(columnWidthConfig: {
        dimensions: IDimensionInfo[];
        width: number;
    }[]): void;
    _parseColumnWidthConfigForRowHeader(columnWidthConfig: {
        dimensions: IDimensionInfo[];
        width: number;
    }[]): void;
    updatePivotSortState(pivotSortStateConfig: {
        dimensions: IDimensionInfo[];
        order: SortOrder;
    }[]): void;
    sort(col: number, row: number, order: SortOrder): void;
    getPivotSortState(col: number, row: number): SortOrder;
    _moveHeaderPosition(source: CellAddress, target: CellAddress): {
        sourceIndex: number;
        targetIndex: any;
        sourceSize: any;
        targetSize: any;
        moveType: "row" | "column";
    };
    toggleHierarchyState(col: number, row: number, recalculateColWidths?: boolean): void;
    _refreshHierarchyState(col: number, row: number, recalculateColWidths?: boolean, beforeUpdateCell?: Function): void;
    getHeaderCellAddressByPath(dimensionPaths: IDimensionInfo[]): CellAddress;
    getCellAddressByHeaderPaths(dimensionPaths: {
        colHeaderPaths: IDimensionInfo[];
        rowHeaderPaths: IDimensionInfo[];
        cellLocation: CellLocation;
    } | IDimensionInfo[]): CellAddress;
    getHeaderPathByXY(coordinate?: {
        x: number;
        y: number;
    }): ICellHeaderPaths;
    getHierarchyState(col: number, row: number): HierarchyState;
    getLayoutColumnTree(): LayouTreeNode[];
    getLayoutColumnTreeCount(): number;
    getLayoutRowTree(): LayouTreeNode[];
    getLayoutRowTreeCount(): number;
    getCellHeaderTreeNodes(col: number, row: number): ICellHeaderPaths;
    getMenuInfo(col: number, row: number, type: string): DropDownMenuEventInfo;
    setRecords(records: Array<any>): void;
    startEditCell(col?: number, row?: number, value?: string | number): void;
    completeEditCell(): void;
    getEditor(col: number, row: number): IEditor<any, any>;
    isHasEditorDefine(col: number, row: number): boolean;
    changeCellValue(col: number, row: number, value: string | undefined, workOnEditableCell?: boolean): void;
    changeCellValues(startCol: number, startRow: number, values: string[][], workOnEditableCell?: boolean): void;
    private _changeCellValueToDataSet;
    _hasCustomRenderOrLayout(): boolean;
    changeRecordOrder(source: number, target: number): void;
    setTreeNodeChildren(children: IHeaderTreeDefine[], records: any[], col: number, row: number): void;
    updateFilterRules(filterRules: FilterRules): void;
    getFilteredRecords(): FilterRules;
    getCellPivotRole(col: number, row: number): {
        colRole: "normal";
        rowRole: "normal";
        cellLocation: CellLocation;
    };
    setLoadingHierarchyState(col: number, row: number): void;
    release(): void;
}
