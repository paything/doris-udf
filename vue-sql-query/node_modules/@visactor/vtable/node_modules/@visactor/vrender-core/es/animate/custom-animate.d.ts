import type { IPoint, IPointLike } from '@visactor/vutils';
import { CustomPath2D } from '../common/custom-path2d';
import type { EasingType, IArea, ICurve, ICustomPath2D, IGraphic, IGroup, ILine, ILineAttribute, ILinearGradient, IRect, IRectAttribute, ISegment, IShadowRoot } from '../interface';
import { ACustomAnimate } from './animate';
export declare class IncreaseCount extends ACustomAnimate<{
    text: string | number;
}> {
    valid: boolean;
    private fromNumber;
    private toNumber;
    private decimalLength;
    constructor(from: {
        text: string | number;
    }, to: {
        text: string | number;
    }, duration: number, easing: EasingType, params?: {
        fixed?: boolean;
    });
    getEndProps(): Record<string, any> | void;
    onBind(): void;
    onEnd(): void;
    onUpdate(end: boolean, ratio: number, out: Record<string, any>): void;
}
export declare class FadeInPlus extends ACustomAnimate<any> {
    direction: number;
    toFill: string;
    toStroke: string;
    fillGradient: ILinearGradient;
    strokeGradient: ILinearGradient;
    fill: boolean;
    stroke: boolean;
    constructor(from: any, to: any, duration: number, easing: EasingType, params?: {
        direction?: number;
        fill?: boolean;
        stroke?: boolean;
    });
    getEndProps(): Record<string, any>;
    onBind(): void;
    onEnd(): void;
    onUpdate(end: boolean, ratio: number, out: Record<string, any>): void;
    leftToRight(end: boolean, ratio: number, out: Record<string, any>): void;
    strokePath(end: boolean, ratio: number, out: Record<string, any>): void;
    rightToLeft(end: boolean, ratio: number, out: Record<string, any>): void;
    topToBottom(end: boolean, ratio: number, out: Record<string, any>): void;
    bottomToTop(end: boolean, ratio: number, out: Record<string, any>): void;
}
export declare class InputText extends ACustomAnimate<{
    text: string;
}> {
    valid: boolean;
    target: IGraphic;
    private fromText;
    private toText;
    getEndProps(): Record<string, any>;
    onBind(): void;
    onEnd(): void;
    onUpdate(end: boolean, ratio: number, out: Record<string, any>): void;
}
export declare class StreamLight extends ACustomAnimate<any> {
    valid: boolean;
    target: IGraphic;
    rect: IRect;
    line: ILine;
    area: IArea;
    constructor(from: any, to: any, duration: number, easing: EasingType, params?: {
        attribute?: Partial<IRectAttribute | ILineAttribute>;
        streamLength?: number;
        isHorizontal?: boolean;
    });
    getEndProps(): Record<string, any>;
    onStart(): void;
    onStartLineOrArea(type: 'line' | 'area'): void;
    onStartRect(): void;
    onBind(): void;
    onEnd(): void;
    onUpdate(end: boolean, ratio: number, out: Record<string, any>): void;
    protected onUpdateRect(end: boolean, ratio: number, out: Record<string, any>): void;
    protected onUpdateLineOrArea(end: boolean, ratio: number, out: Record<string, any>): void;
    protected _onUpdateLineOrAreaWithCache(customPath: ICustomPath2D, g: ILine | IArea, end: boolean, ratio: number, out: Record<string, any>): void;
    protected _updateCurves(customPath: ICustomPath2D, curves: ICurve<IPoint>[], totalLen: number, ratio: number): void;
    protected _onUpdateLineWithoutCache(customPath: ICustomPath2D, line: ILine, end: boolean, ratio: number, out: Record<string, any>): void;
}
export declare class Meteor extends ACustomAnimate<any> {
    size: number;
    target: IGraphic;
    root: IShadowRoot;
    posList: IPoint[];
    get lastPos(): IPoint;
    constructor(size: number, duration: number, easing: EasingType, params?: any);
    onBind(): void;
    onUpdate(end: boolean, ratio: number, out: Record<string, any>): void;
}
export declare class MotionPath extends ACustomAnimate<any> {
    valid: boolean;
    pathLength: number;
    path: CustomPath2D;
    distance: number;
    initAngle: number;
    changeAngle: boolean;
    cb?: (from: any, to: any, ratio: number, target: IGraphic) => void;
    constructor(from: any, to: any, duration: number, easing: EasingType, params?: {
        path: CustomPath2D;
        distance: number;
        cb?: (from: any, to: any, ratio: number, target: IGraphic) => void;
        initAngle?: number;
        changeAngle?: boolean;
    });
    onUpdate(end: boolean, ratio: number, out: Record<string, any>): void;
}
export declare class TagPointsUpdate extends ACustomAnimate<{
    points?: IPointLike[];
    segments?: ISegment[];
}> {
    protected fromPoints: IPointLike[];
    protected toPoints: IPointLike[];
    protected points: IPointLike[];
    protected interpolatePoints: [IPointLike, IPointLike][];
    protected newPointAnimateType: 'grow' | 'appear' | 'clip';
    protected clipRange: number;
    protected shrinkClipRange: number;
    protected clipRangeByDimension: 'x' | 'y';
    protected segmentsCache: number[];
    constructor(from: any, to: any, duration: number, easing: EasingType, params?: {
        newPointAnimateType?: 'grow' | 'appear' | 'clip';
        clipRangeByDimension?: 'x' | 'y';
    });
    private getPoints;
    onBind(): void;
    onFirstRun(): void;
    onUpdate(end: boolean, ratio: number, out: Record<string, any>): void;
}
export declare class GraphicAnimate extends ACustomAnimate<any> {
    graphic: IGraphic;
    constructor(from: any, to: any, duration: number, easing: EasingType, params?: {
        graphic: IGraphic;
    });
    onUpdate(end: boolean, ratio: number, out: Record<string, any>): void;
}
export declare class ClipGraphicAnimate extends ACustomAnimate<any> {
    private _group?;
    private _clipGraphic?;
    protected clipFromAttribute?: any;
    protected clipToAttribute?: any;
    private _lastClip?;
    private _lastPath?;
    constructor(from: any, to: any, duration: number, easing: EasingType, params: {
        group: IGroup;
        clipGraphic: IGraphic;
    });
    onBind(): void;
    onEnd(): void;
    onUpdate(end: boolean, ratio: number, out: Record<string, any>): void;
}
export declare class ClipAngleAnimate extends ClipGraphicAnimate {
    constructor(from: any, to: any, duration: number, easing: EasingType, params: {
        group: IGroup;
        center?: {
            x: number;
            y: number;
        };
        startAngle?: number;
        radius?: number;
        orient?: 'clockwise' | 'anticlockwise';
        animationType?: 'in' | 'out';
    });
}
export declare class ClipRadiusAnimate extends ClipGraphicAnimate {
    constructor(from: any, to: any, duration: number, easing: EasingType, params: {
        group: IGroup;
        center?: {
            x: number;
            y: number;
        };
        startRadius?: number;
        endRadius?: number;
        animationType?: 'in' | 'out';
    });
}
export declare class ClipDirectionAnimate extends ClipGraphicAnimate {
    constructor(from: any, to: any, duration: number, easing: EasingType, params: {
        group: IGroup;
        direction?: 'x' | 'y';
        orient?: 'positive' | 'negative';
        width?: number;
        height?: number;
        animationType?: 'in' | 'out';
    });
}
type RotateSphereParams = {
    center: {
        x: number;
        y: number;
        z: number;
    };
    r: number;
    cb?: (out: any) => void;
} | (() => any);
export declare class RotateBySphereAnimate extends ACustomAnimate<any> {
    params: RotateSphereParams;
    theta: number;
    phi: number;
    onStart(): void;
    onBind(): void;
    onEnd(): void;
    onUpdate(end: boolean, ratio: number, out: Record<string, any>): void;
}
export declare class AttributeAnimate extends ACustomAnimate<any> {
    target: IGroup;
    constructor(to: Record<string, any>, duration: number, easing: EasingType);
    getEndProps(): Record<string, any>;
    onBind(): void;
    onEnd(): void;
    onUpdate(end: boolean, ratio: number, out: Record<string, any>): void;
}
export declare class AnimateGroup extends ACustomAnimate<any> {
    customAnimates: ACustomAnimate<any>[];
    updating: boolean;
    constructor(duration: number, customAnimates: ACustomAnimate<any>[]);
    initAnimates(): void;
    getEndProps(): Record<string, any>;
    onBind(): void;
    onEnd(): void;
    onStart(): void;
    onUpdate(end: boolean, ratio: number, out: Record<string, any>): void;
}
export declare class AnimateGroup1 extends ACustomAnimate<any> {
    customAnimates: ACustomAnimate<any>[];
    updating: boolean;
    constructor(duration: number, customAnimates: ACustomAnimate<any>[]);
    initAnimates(): void;
    getEndProps(): Record<string, any>;
    onBind(): void;
    onEnd(): void;
    onUpdate(end: boolean, ratio: number, out: Record<string, any>): void;
}
export {};
