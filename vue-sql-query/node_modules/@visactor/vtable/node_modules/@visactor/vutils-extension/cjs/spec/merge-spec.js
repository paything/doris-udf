"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.mergeSpecWithFilter = exports.mergeSpec = void 0;

const vutils_1 = require("@visactor/vutils");

function baseMerge(target, source, shallowArray = !1) {
    if (source) {
        if (target === source) return;
        if ((0, vutils_1.isValid)(source) && "object" == typeof source) {
            const iterable = Object(source), props = [];
            for (const key in iterable) props.push(key);
            let {length: length} = props, propIndex = -1;
            for (;length--; ) {
                const key = props[++propIndex];
                (0, vutils_1.isValid)(iterable[key]) && "object" == typeof iterable[key] && !(0, 
                vutils_1.isArray)(target[key]) ? baseMergeDeep(target, source, key, shallowArray) : assignMergeValue(target, key, iterable[key]);
            }
        }
    }
}

function baseMergeDeep(target, source, key, shallowArray = !1) {
    const objValue = target[key], srcValue = source[key];
    let newValue = source[key], isCommon = !0;
    if ((0, vutils_1.isArray)(srcValue)) {
        if (shallowArray) newValue = []; else if ((0, vutils_1.isArray)(objValue)) newValue = objValue; else if ((0, 
        vutils_1.isArrayLike)(objValue)) {
            newValue = new Array(objValue.length);
            let index = -1;
            const length = objValue.length;
            for (;++index < length; ) newValue[index] = objValue[index];
        }
    } else (0, vutils_1.isPlainObject)(srcValue) ? (newValue = null != objValue ? objValue : {}, 
    "function" != typeof objValue && "object" == typeof objValue || (newValue = {})) : isCommon = !1;
    isCommon && baseMerge(newValue, srcValue, shallowArray), assignMergeValue(target, key, newValue);
}

function assignMergeValue(target, key, value) {
    (void 0 !== value && !eq(target[key], value) || void 0 === value && !(key in target)) && (target[key] = value);
}

function eq(value, other) {
    return value === other || Number.isNaN(value) && Number.isNaN(other);
}

function mergeSpec(target, ...sources) {
    let sourceIndex = -1;
    const length = sources.length;
    for (;++sourceIndex < length; ) {
        baseMerge(target, sources[sourceIndex], !0);
    }
    return target;
}

function mergeSpecWithFilter(target, filter, spec, forceMerge) {
    Object.keys(target).forEach((k => {
        if ((0, vutils_1.isObject)(filter)) filter.type === k && ((0, vutils_1.isArray)(target[k]) ? target[k].length >= filter.index && (target[k][filter.index] = forceMerge ? mergeSpec({}, target[k][filter.index], spec) : spec) : target[k] = forceMerge ? mergeSpec({}, target[k], spec) : spec); else if ((0, 
        vutils_1.isArray)(target[k])) {
            const index = target[k].findIndex((_s => _s.id === filter));
            index >= 0 && (target[k][index] = forceMerge ? mergeSpec({}, target[k][index], spec) : spec);
        } else target.id === filter && (target[k] = forceMerge ? mergeSpec({}, target[k], spec) : spec);
    }));
}

exports.mergeSpec = mergeSpec, exports.mergeSpecWithFilter = mergeSpecWithFilter;
//# sourceMappingURL=merge-spec.js.map