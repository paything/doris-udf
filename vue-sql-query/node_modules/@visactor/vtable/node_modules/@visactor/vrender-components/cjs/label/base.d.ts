import type { IGroup, IGraphic, IText, ILine, IRichText } from '@visactor/vrender-core';
import type { IAABBBounds, IBoundsLike, IPointLike } from '@visactor/vutils';
import { AbstractComponent } from '../core/base';
import type { PointLocationCfg } from '../core/type';
import type { Bitmap, BitmapTool } from './overlap';
import { bitmapTool } from './overlap';
import type { BaseLabelAttrs, OverlapAttrs, ILabelAnimation, LabelItem, ILabelEnterAnimation, ILabelExitAnimation, ILabelUpdateAnimation, LabelContent } from './type';
import type { ComponentOptions } from '../interface';
export declare class LabelBase<T extends BaseLabelAttrs> extends AbstractComponent<T> {
    name: string;
    protected _baseMarks?: IGraphic[];
    protected _isCollectionBase: boolean;
    protected _bitmap?: Bitmap;
    protected _animationConfig?: {
        enter: ILabelEnterAnimation | false;
        exit: ILabelExitAnimation | false;
        update: ILabelUpdateAnimation | false;
    };
    static defaultAttributes: Partial<BaseLabelAttrs>;
    setBitmap(bitmap: Bitmap): void;
    protected _bmpTool?: ReturnType<typeof bitmapTool>;
    setBitmapTool(bmpTool: ReturnType<typeof bitmapTool>): void;
    protected _graphicToText: Map<IGraphic, LabelContent>;
    protected _idToGraphic: Map<string, IGraphic>;
    protected _idToPoint: Map<string, IPointLike>;
    private _lastHover;
    private _lastSelect;
    private _enableAnimation;
    constructor(attributes: BaseLabelAttrs, options?: ComponentOptions);
    protected labeling(textBounds: IBoundsLike, graphicBounds: IBoundsLike, position?: BaseLabelAttrs['position'], offset?: number): {
        x: number;
        y: number;
    } | undefined;
    protected _getLabelLinePoints(text: IText | IRichText, baseMark?: IGraphic): {
        x: number;
        y: number;
    }[];
    protected _createLabelLine(text: IText | IRichText, baseMark?: IGraphic): ILine | undefined;
    protected render(): void;
    private _bindEvent;
    private _setStatesOfText;
    protected _setStatesOfLabelLine(target: IGraphic): void;
    private _onHover;
    private _onUnHover;
    private _onClick;
    protected _createLabelText(attributes: LabelItem): IRichText | IText;
    private _prepare;
    protected getRelatedGraphic(item: LabelItem): IGraphic<Partial<import("@visactor/vrender-core").IGraphicAttribute>>;
    protected _initText(data?: LabelItem[]): (IText | IRichText)[];
    protected _layout(texts: (IText | IRichText)[]): (IText | IRichText)[];
    protected _overlapping(labels: (IText | IRichText)[]): (IRichText | IText)[];
    protected _overlapGlobal(labels: (IText | IRichText)[], option: OverlapAttrs, bmpTool: BitmapTool, bitmap: Bitmap): (IRichText | IText)[];
    protected _processClampForce(text: IText, bmpTool: BitmapTool, bitmap: Bitmap, overlapPadding?: number): boolean;
    protected _overlapByStrategy(labels: (IText | IRichText)[], option: OverlapAttrs, bmpTool: BitmapTool, bitmap: Bitmap): (IRichText | IText)[];
    protected isMarkInsideRect(baseMark: IGraphic, bmpTool: BitmapTool): boolean;
    protected getBaseMarkGroup(): IGroup;
    protected getGraphicBounds(graphic?: IGraphic, point?: Partial<PointLocationCfg>, position?: string): IBoundsLike;
    protected _renderLabels(labels: (IText | IRichText)[]): void;
    protected _addLabel(label: LabelContent, texts?: LabelContent['text'][], labelLines?: LabelContent['labelLine'][], index?: number): void;
    protected _updateLabel(prevLabel: LabelContent, currentLabel: LabelContent): void;
    protected _removeLabel(textMap: Map<any, LabelContent>): void;
    private updateStatesOfLabels;
    protected _handleRelatedGraphicSetState: (e: any) => void;
    protected _syncStateWithRelatedGraphic(relatedGraphic: IGraphic): void;
    protected _afterRelatedGraphicAttributeUpdate(text: IText | IRichText, texts: (IText | IRichText)[], labelLine: ILine, labelLines: ILine[], index: number, relatedGraphic: IGraphic, to: any, { mode, duration, easing, delay }: ILabelAnimation): (event: any) => {};
    protected _smartInvert(labels: (IText | IRichText)[]): void;
    protected _canPlaceInside(textBound: IBoundsLike, shapeBound: IAABBBounds): boolean;
    setLocation(point: PointLocationCfg): void;
    disableAnimation(): void;
    enableAnimation(): void;
}
