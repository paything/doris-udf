{"version":3,"sources":["../src/polar.ts"],"names":[],"mappings":"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","file":"polar.js","sourcesContent":["import type { IPointLike } from '@visactor/vutils';\n// eslint-disable-next-line no-duplicate-imports\nimport {\n  clampRadian,\n  isNumberClose,\n  isValidNumber,\n  isNil,\n  polarToCartesian,\n  isArray,\n  minInArray,\n  maxInArray\n} from '@visactor/vutils';\nimport { Coordinate } from './base';\nimport type { IPolarCoordinate, IDimensionType, IPolarPointLike } from './interface';\n\nexport class PolarCoordinate extends Coordinate implements IPolarCoordinate {\n  readonly type = 'polar';\n\n  private _isUserOrigin: boolean = false;\n  private _isUserRadius: boolean = false;\n  protected startAngle: number = 0;\n  protected endAngle: number = 2 * Math.PI;\n  protected innerRadius: number = 0;\n  protected outerRadius: number = 0;\n\n  private _updateStartEndPoint() {\n    const origin = this.origin();\n    const minAngle = Math.min(this.startAngle, this.endAngle);\n    const maxAngle = Math.max(this.startAngle, this.endAngle);\n    const init0 = (2 * minAngle) / Math.PI;\n    const init1 = (2 * maxAngle) / Math.PI;\n    const angles = [minAngle, maxAngle];\n    let i = Math.ceil(init0);\n\n    while (i <= init1) {\n      angles.push((i * Math.PI) / 2);\n      i++;\n    }\n    const len = angles.length;\n    const xs: number[] = [];\n    const ys: number[] = [];\n\n    for (i = 0; i < len; i++) {\n      const p0 = polarToCartesian(origin, this.innerRadius, angles[i]);\n      const p1 = polarToCartesian(origin, this.outerRadius, angles[i]);\n\n      xs.push(p0.x);\n      xs.push(p1.x);\n      ys.push(p0.y);\n      ys.push(p1.y);\n    }\n    const minX = minInArray(xs);\n    const minY = minInArray(ys);\n\n    const maxX = maxInArray(xs);\n    const maxY = maxInArray(ys);\n\n    this.startPoint = { x: minX, y: minY };\n    this.endPoint = { x: maxX, y: maxY };\n  }\n\n  protected _updateSize() {\n    super._updateSize();\n\n    if (!this._isUserOrigin) {\n      this.originPoint = { x: this.width / 2, y: this.height / 2 };\n      this._invokeTransforms();\n    }\n\n    if (!this._isUserRadius) {\n      this.outerRadius = Math.min(\n        Math.abs(this.startPoint.x - this.originPoint.x),\n        Math.abs(this.endPoint.x - this.originPoint.x),\n        Math.abs(this.startPoint.y - this.originPoint.y),\n        Math.abs(this.endPoint.y - this.originPoint.y)\n      );\n    }\n  }\n\n  angle(): [number, number];\n  angle(startAngle: number, endAngle: number): this;\n  angle(angle: [number, number]): this;\n  angle(angle?: [number, number] | number, endAngle?: number) {\n    if (isNil(angle)) {\n      return [this.startAngle, this.endAngle];\n    }\n    if (Array.isArray(angle)) {\n      this.startAngle = angle[0];\n      this.endAngle = angle[1];\n    } else {\n      this.startAngle = angle;\n      this.endAngle = endAngle ?? angle;\n    }\n\n    this._updateStartEndPoint();\n    return this;\n  }\n\n  radius(): [number, number];\n  radius(innerRadius: number, outerRadius: number): this;\n  radius(radius: [number, number]): this;\n  radius(radius?: [number, number] | number, outerRadius?: number) {\n    if (isNil(radius)) {\n      return [this.innerRadius, this.outerRadius];\n    }\n    this._isUserRadius = true;\n    if (Array.isArray(radius)) {\n      this.innerRadius = Math.min(radius[0], radius[1]);\n      this.outerRadius = Math.max(radius[1], radius[1]);\n    } else {\n      this.innerRadius = Math.min(radius, outerRadius);\n      this.outerRadius = Math.max(radius, outerRadius);\n    }\n\n    this._updateStartEndPoint();\n    return this;\n  }\n\n  /** set origin point */\n  origin(): IPointLike;\n  origin(point: IPointLike): this;\n  origin(point: [number, number]): this;\n  origin(x: number, y: number): this;\n  origin(x?: number | IPointLike | [number, number], y?: number) {\n    if (isNil(x)) {\n      return this.originPoint;\n    }\n    this._isUserOrigin = true;\n    this.originPoint = this._parsePoint(x, y);\n    this._updateStartEndPoint();\n    // TODO: maybe use dirty flag to update matrix instead\n    this._invokeTransforms();\n    return this;\n  }\n\n  convert(point: IPolarPointLike | IPointLike | [number, number]): IPointLike {\n    if (isValidNumber((point as IPolarPointLike).r1) || isValidNumber((point as IPolarPointLike).theta1)) {\n      const convertedPoint = this.convertPoint(point as IPolarPointLike);\n      const convertedPoint1 = this.convertPoint({\n        r: (point as IPolarPointLike).r1 ?? (point as IPolarPointLike).r,\n        theta: (point as IPolarPointLike).theta1 ?? (point as IPolarPointLike).theta\n      });\n      convertedPoint.x1 = convertedPoint1.x;\n      convertedPoint.y1 = convertedPoint1.y;\n      return convertedPoint;\n    } else if (isValidNumber((point as IPointLike).x1) || isValidNumber((point as IPointLike).y1)) {\n      const convertedPoint = this.convertPoint(point as IPointLike);\n      const convertedPoint1 = this.convertPoint({\n        x: (point as IPointLike).x1 ?? (point as IPointLike).x,\n        y: (point as IPointLike).y1 ?? (point as IPointLike).y\n      });\n      convertedPoint.x1 = convertedPoint1.x;\n      convertedPoint.y1 = convertedPoint1.y;\n      return convertedPoint;\n    }\n    return this.convertPoint(point);\n  }\n\n  invert(point: IPointLike): IPolarPointLike {\n    if (isValidNumber(point.x1) || isValidNumber(point.y1)) {\n      const invertedPoint = this.invertPoint(point);\n      const invertedPoint1 = this.invertPoint({ x: point.x1 ?? point.x, y: point.y1 ?? point.y });\n      invertedPoint.r1 = invertedPoint1.r;\n      invertedPoint.theta1 = invertedPoint1.theta;\n      return invertedPoint;\n    }\n    return this.invertPoint(point);\n  }\n\n  /**\n   *\n   * @param dim        dim: 'x' | 'theta', associated to the angle, dim: 'y' | 'r', associated to the radius\n   * @param isSubshaft\n   * @param reversed\n   * @returns\n   */\n  getRangeByDimension(dim: IDimensionType, isSubshaft?: boolean, reversed?: boolean): [number, number] {\n    const isAngle = this.isMainDimension(dim);\n    const res: [number, number] = isAngle ? [this.startAngle, this.endAngle] : [this.innerRadius, this.outerRadius];\n\n    return reversed ? [res[1], res[0]] : res;\n  }\n\n  getVisualPositionByDimension(dim: IDimensionType, isSubshaft?: boolean, reversed?: boolean) {\n    const isAngle = this.isMainDimension(dim);\n\n    return isAngle ? (isSubshaft ? 'inside' : 'outside') : isSubshaft ? 'end' : 'start';\n  }\n\n  getAxisPointsByDimension(\n    dim: IDimensionType,\n    isSubshaft?: boolean,\n    reversed?: boolean,\n    baseValue?: number\n  ): [IPointLike, IPointLike] {\n    const isAngle = this.isMainDimension(dim);\n\n    if (!isAngle) {\n      const origin = this.origin();\n      const res: [IPointLike, IPointLike] = !isNil(baseValue)\n        ? [polarToCartesian(origin, this.innerRadius, baseValue), polarToCartesian(origin, this.outerRadius, baseValue)]\n        : isSubshaft\n        ? [\n            polarToCartesian(origin, this.innerRadius, this.endAngle),\n            polarToCartesian(origin, this.outerRadius, this.endAngle)\n          ]\n        : [\n            polarToCartesian(origin, this.innerRadius, this.startAngle),\n            polarToCartesian(origin, this.outerRadius, this.startAngle)\n          ];\n\n      return reversed ? [res[1], res[0]] : res;\n    }\n\n    return null;\n  }\n\n  private convertPoint(point: IPolarPointLike | IPointLike | [number, number]) {\n    const isTransposed = this.isTransposed();\n    let theta: number;\n    let r: number;\n\n    if (!isNil((point as IPolarPointLike).r) && !isNil((point as IPolarPointLike).theta)) {\n      theta = isTransposed ? (point as IPolarPointLike).r : (point as IPolarPointLike).theta;\n      r = isTransposed ? (point as IPolarPointLike).theta : (point as IPolarPointLike).r;\n    } else if (isArray(point)) {\n      theta = isTransposed ? (point as [number, number])[0] : (point as [number, number])[1];\n      r = isTransposed ? (point as [number, number])[1] : (point as [number, number])[0];\n    } else {\n      theta = isTransposed ? (point as IPointLike).y : (point as IPointLike).x;\n      r = isTransposed ? (point as IPointLike).x : (point as IPointLike).y;\n    }\n\n    const convertedPoint: IPointLike = {\n      x: Math.cos(theta) * r,\n      y: Math.sin(theta) * r\n    };\n    if ((point as IPointLike).defined === false) {\n      convertedPoint.defined = false;\n    }\n    const transformedPoint = Object.assign({}, convertedPoint);\n    this.convertMatrix.transformPoint(convertedPoint, transformedPoint);\n\n    return transformedPoint;\n  }\n\n  private invertPoint(point: IPointLike): IPolarPointLike {\n    const untransformedPoint = Object.assign({}, point);\n    this.invertMatrix.transformPoint(point, untransformedPoint);\n\n    const cos = untransformedPoint.x;\n    const sin = untransformedPoint.y;\n    if (isNumberClose(cos, 0) && isNumberClose(sin, 0)) {\n      const invertedPoint: IPolarPointLike = { r: 0, theta: 0 };\n      if (untransformedPoint.defined === false) {\n        invertedPoint.defined = false;\n      }\n      return invertedPoint;\n    }\n\n    let theta = Math.atan(sin / cos);\n    if (cos >= 0) {\n      theta += Math.PI * 2;\n    } else {\n      theta += Math.PI;\n    }\n    // when theta is Math.PI*2, it should be set to zero\n    if (theta >= Math.PI * 2) {\n      theta -= Math.PI * 2;\n    }\n    theta = clampRadian(theta);\n    const radius = isNumberClose(sin, 0) ? cos / Math.cos(theta) : sin / Math.sin(theta);\n    const invertedPoint: IPolarPointLike = this.isTransposed()\n      ? {\n          r: theta,\n          theta: radius\n        }\n      : {\n          r: radius,\n          theta\n        };\n\n    if (untransformedPoint.defined === false) {\n      invertedPoint.defined = false;\n    }\n    return invertedPoint;\n  }\n}\n"]}