{"version":3,"sources":["../src/base.ts"],"names":[],"mappings":"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","file":"base.js","sourcesContent":["import type { IPointLike, IMatrix } from '@visactor/vutils';\n// eslint-disable-next-line no-duplicate-imports\nimport { isArray, isNil, isNumber, Matrix } from '@visactor/vutils';\nimport type { CoordinateTransform, CoordinateType, IBaseCoordinate, IDimensionType } from './interface';\n\nexport abstract class Coordinate implements IBaseCoordinate {\n  readonly type: CoordinateType;\n\n  /** coordinate range start point */\n  protected startPoint: IPointLike = { x: 0, y: 0 };\n  /** coordinate range end point */\n  protected endPoint: IPointLike = { x: 0, y: 0 };\n  /** coordinate origin point */\n  protected originPoint: IPointLike = { x: 0, y: 0 };\n  /** coordinate range width */\n  protected width: number = 0;\n  /** coordinate range height */\n  protected height: number = 0;\n\n  /** coordinate transforms, such as translate / rotate / scale...  */\n  protected transforms: CoordinateTransform[] = [];\n  /** compute all coordinate transforms with single matrix */\n  protected convertMatrix: IMatrix | null;\n  protected invertMatrix: IMatrix | null;\n\n  /** set start point */\n  start(): IPointLike;\n  start(point: IPointLike): this;\n  start(point: [number, number]): this;\n  start(x: number, y: number): this;\n  start(x?: number | IPointLike | [number, number], y?: number) {\n    if (isNil(x)) {\n      return this.startPoint;\n    }\n    this.startPoint = this._parsePoint(x, y);\n    this._updateSize();\n    return this;\n  }\n\n  /** set end point */\n  end(): IPointLike;\n  end(point: IPointLike): this;\n  end(point: [number, number]): this;\n  end(x: number, y: number): this;\n  end(x?: number | IPointLike | [number, number], y?: number) {\n    if (isNil(x)) {\n      return this.endPoint;\n    }\n    this.endPoint = this._parsePoint(x, y);\n    this._updateSize();\n    return this;\n  }\n\n  /** convert point from current coordinate into canvas coordinate */\n  abstract convert(...args: any[]): any;\n  /** convert point from canvas coordinate into current coordinate */\n  abstract invert(...args: any[]): any;\n\n  abstract getRangeByDimension(dim: IDimensionType, isSubshaft?: boolean, reversed?: boolean): [number, number];\n\n  abstract getVisualPositionByDimension(dim: IDimensionType, isSubshaft?: boolean, reversed?: boolean): string;\n\n  abstract getAxisPointsByDimension(\n    dim: IDimensionType,\n    isSubshaft?: boolean,\n    reversed?: boolean,\n    baseValue?: number\n  ): [IPointLike, IPointLike] | null;\n\n  protected _parsePoint(x: number | IPointLike | [number, number], y?: number) {\n    const point: IPointLike = { x: 0, y: 0 };\n    if (isArray(x)) {\n      point.x = x[0];\n      point.y = x[1];\n    } else if (isNumber(x)) {\n      point.x = x;\n      point.y = y as number;\n    } else {\n      point.x = x.x;\n      point.y = x.y;\n    }\n    return point;\n  }\n\n  protected _updateSize() {\n    this.width = this.endPoint.x - this.startPoint.x;\n    this.height = this.endPoint.y - this.startPoint.y;\n  }\n\n  isTransposed() {\n    return this.transforms && this.transforms.filter(transform => transform.type === 'transpose').length % 2 !== 0;\n  }\n\n  isMainDimension(dim: IDimensionType) {\n    let isMain = dim === 'x' || dim === 'theta' || dim === '0';\n\n    if (this.isTransposed()) {\n      isMain = !isMain;\n    }\n\n    return isMain;\n  }\n\n  /** apply coordinate transforms */\n  applyTransforms(transforms: CoordinateTransform[]) {\n    this.transforms = transforms.slice();\n    this._invokeTransforms();\n    return this;\n  }\n\n  protected _invokeTransforms() {\n    this.invertMatrix = null;\n    this.convertMatrix = null;\n    this.invertMatrix = new Matrix();\n    // origin point is handled by translate transform\n    this.invertMatrix.translate(this.originPoint.x, this.originPoint.y);\n    // multiply all coordinate transform matrix\n    this.transforms.forEach(transform => {\n      switch (transform.type) {\n        case 'translate':\n          this.invertMatrix.translate(transform.offset.x, transform.offset.y);\n          break;\n        case 'rotate':\n          this.invertMatrix.rotateByCenter(transform.angle, this.originPoint.x, this.originPoint.y);\n          break;\n        case 'scale':\n          this.invertMatrix.scale(transform.scale.x, transform.scale.y);\n          break;\n        case 'transpose':\n          if (this.type !== 'polar') {\n            this.invertMatrix.transpose();\n          }\n          break;\n      }\n    });\n    this.invertMatrix;\n    this.convertMatrix = this.invertMatrix.getInverse();\n  }\n}\n"]}