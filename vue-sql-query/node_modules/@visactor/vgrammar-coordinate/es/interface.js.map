{"version":3,"sources":["../src/interface.ts"],"names":[],"mappings":"","file":"interface.js","sourcesContent":["import type { IPointLike } from '@visactor/vutils';\n\n// TODO: move to vis-util\nexport interface IPolarPoint {\n  r: number;\n  theta: number;\n  r1?: number;\n  theta1?: number;\n  defined?: boolean;\n  clone: () => IPolarPoint;\n  copyFrom: (p: IPolarPoint) => IPolarPoint;\n  set: (x: number, y: number) => IPolarPoint;\n  add: (point: IPolarPoint | number) => IPolarPoint;\n  sub: (point: IPolarPoint | number) => IPolarPoint;\n  multi: (point: IPolarPoint | number) => IPolarPoint;\n  div: (point: IPolarPoint | number) => IPolarPoint;\n}\nexport declare type IPolarPointLike = Pick<IPolarPoint, 'r' | 'theta' | 'r1' | 'theta1' | 'defined'>;\n\nexport type CoordinateType = 'cartesian' | 'polar';\n\n// Coordinate Transform\n\nexport type CoordinateTransform =\n  | {\n      type: 'translate';\n      offset: { x: number; y: number };\n    }\n  | {\n      type: 'rotate';\n      angle: number;\n    }\n  | {\n      type: 'scale';\n      scale: { x: number; y: number };\n    }\n  | {\n      type: 'transpose';\n    };\n\n// Coordinates\n\nexport interface IBaseCoordinate {\n  readonly type: CoordinateType;\n  start: (() => IPointLike) &\n    ((point: IPointLike) => this) &\n    ((point: [number, number]) => this) &\n    ((x: number, y: number) => this);\n\n  end: (() => IPointLike) &\n    ((point: IPointLike) => this) &\n    ((point: [number, number]) => this) &\n    ((x: number, y: number) => this);\n  convert: (...args: any[]) => any;\n  invert: (...args: any[]) => any;\n\n  isTransposed: () => boolean;\n\n  isMainDimension: (dim: IDimensionType) => boolean;\n\n  applyTransforms: (transforms: CoordinateTransform[]) => this;\n\n  getRangeByDimension: (dim: IDimensionType, isSubshaft?: boolean, reversed?: boolean) => [number, number];\n\n  getVisualPositionByDimension: (dim: IDimensionType, isSubshaft?: boolean, reversed?: boolean) => string;\n\n  getAxisPointsByDimension: (\n    dim: IDimensionType,\n    isSubshaft?: boolean,\n    reversed?: boolean,\n    baseValue?: number\n  ) => [IPointLike, IPointLike] | null;\n}\n\nexport interface ICartesianCoordinate extends IBaseCoordinate {\n  convert: (point: IPointLike) => IPointLike;\n  invert: (point: IPointLike) => IPointLike;\n}\n\nexport type IDimensionType = 'r' | 'theta' | 'x' | 'y' | '0' | '1';\n\nexport interface IPolarCoordinate extends IBaseCoordinate {\n  origin: (() => IPointLike) &\n    ((point: IPointLike) => this) &\n    ((point: [number, number]) => this) &\n    ((x: number, y: number) => this);\n\n  angle: (() => [number, number]) & ((sa: number, ea: number) => this) & ((a: [number, number]) => this);\n  radius: (() => [number, number]) & ((ir: number, or: number) => this) & ((r: [number, number]) => this);\n  convert: (point: IPolarPointLike) => IPointLike;\n  invert: (point: IPointLike) => IPolarPointLike;\n}\n"]}