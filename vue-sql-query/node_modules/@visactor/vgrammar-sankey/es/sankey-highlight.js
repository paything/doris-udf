import { InteractionStateEnum, BaseInteraction } from "@visactor/vgrammar-core";

import { array } from "@visactor/vutils";

export class SankeyHighlight extends BaseInteraction {
    constructor(view, options) {
        var _a, _b;
        super(view, options), this.type = SankeyHighlight.type, this.highlightAdjacentElement = (element, isNode) => {
            var _a, _b;
            const datum = element.getDatum(), allLinkElements = null !== (_b = null === (_a = this._linkMark) || void 0 === _a ? void 0 : _a.elements) && void 0 !== _b ? _b : [], highlightNodes = isNode ? [ datum.key ] : [ datum.source, datum.target ], getIsHighlight = isNode ? linkDatum => linkDatum.target === datum.key || linkDatum.source === datum.key : linkDatum => linkDatum.source === datum.source && linkDatum.target === datum.target;
            return allLinkElements.forEach((linkEl => {
                const linkDatum = linkEl.getDatum();
                getIsHighlight(linkDatum) ? (linkEl.removeState(this.options.blurState), linkEl.addState(this.options.highlightState, {
                    ratio: 1
                }), highlightNodes.includes(linkDatum.source) || highlightNodes.push(linkDatum.source), 
                highlightNodes.includes(linkDatum.target) || highlightNodes.push(linkDatum.target)) : (linkEl.removeState(this.options.highlightState), 
                linkEl.addState(this.options.blurState));
            })), highlightNodes;
        }, this.highlightRelatedBySourceTarget = (element, isNode) => {
            var _a, _b, _c, _d, _e, _f;
            if (!isNode) return this.highlightAdjacentElement(element, isNode);
            const datum = element.getDatum(), allNodeElements = null !== (_b = null === (_a = this._nodeMark) || void 0 === _a ? void 0 : _a.elements) && void 0 !== _b ? _b : [], highlightNodes = [], allLinkElements = null !== (_d = null === (_c = this._linkMark) || void 0 === _c ? void 0 : _c.elements) && void 0 !== _d ? _d : [], highlightLinks = [], allNodes = allNodeElements.reduce(((res, nodeEl) => {
                const nodeDatum = nodeEl.getDatum();
                return res[null == nodeDatum ? void 0 : nodeDatum.key] = {
                    datum: nodeDatum,
                    el: nodeEl
                }, res;
            }), {}), downNodes = [ datum ], upNodes = [ datum ];
            for (;downNodes.length; ) {
                const first = downNodes.pop();
                (null === (_e = null == first ? void 0 : first.sourceLinks) || void 0 === _e ? void 0 : _e.length) && first.sourceLinks.forEach((link => {
                    highlightLinks.push(link), allNodes[link.target] && downNodes.push(allNodes[link.target].datum);
                }));
            }
            for (;upNodes.length; ) {
                const first = upNodes.pop();
                (null === (_f = null == first ? void 0 : first.targetLinks) || void 0 === _f ? void 0 : _f.length) && first.targetLinks.forEach((link => {
                    highlightLinks.push(link), allNodes[link.source] && upNodes.push(allNodes[link.source].datum);
                }));
            }
            return allLinkElements.forEach((linkEl => {
                const linkDatum = linkEl.getDatum();
                highlightLinks.some((link => link.source === linkDatum.source && link.target === linkDatum.target)) ? (linkEl.removeState(this.options.blurState), 
                linkEl.addState(this.options.highlightState, {
                    ratio: 1
                }), highlightNodes.includes(linkDatum.source) || highlightNodes.push(linkDatum.source), 
                highlightNodes.includes(linkDatum.target) || highlightNodes.push(linkDatum.target)) : (linkEl.removeState(this.options.highlightState), 
                linkEl.addState(this.options.blurState));
            })), highlightNodes;
        }, this.highlightRelatedElement = (element, isNode) => {
            var _a, _b, _c, _d, _e;
            const allLinkElements = null !== (_b = null === (_a = this._linkMark) || void 0 === _a ? void 0 : _a.elements) && void 0 !== _b ? _b : [];
            if (!!!(null === (_e = null === (_d = null === (_c = allLinkElements[0]) || void 0 === _c ? void 0 : _c.getDatum) || void 0 === _d ? void 0 : _d.call(_c)) || void 0 === _e ? void 0 : _e.parents)) return this.highlightRelatedBySourceTarget(element, isNode);
            const datum = element.getDatum(), highlightNodes = isNode ? [ datum.key ] : [ datum.source, datum.target ], upstreamLinks = this.parseUpstreamLinks(element, isNode);
            return allLinkElements.forEach((linkEl => {
                const linkDatum = linkEl.getDatum(), originalDatum = array(linkDatum.datum);
                if (!isNode && linkDatum.source === datum.source && linkDatum.target === datum.target) return linkEl.removeState(this.options.blurState), 
                void linkEl.addState(this.options.highlightState, {
                    ratio: 1
                });
                const selectedDatum = isNode ? originalDatum.filter((entry => {
                    var _a;
                    return (null !== (_a = entry.parents) && void 0 !== _a ? _a : []).some((par => par.key === datum.key));
                })) : originalDatum.filter((entry => {
                    var _a;
                    return (null !== (_a = entry.parents) && void 0 !== _a ? _a : []).some((par => par.key === datum.target));
                }));
                if (selectedDatum && selectedDatum.length) {
                    highlightNodes.includes(linkDatum.source) || highlightNodes.push(linkDatum.source), 
                    highlightNodes.includes(linkDatum.target) || highlightNodes.push(linkDatum.target);
                    const ratio = selectedDatum.reduce(((sum, d) => sum + d.value), 0) / linkDatum.value;
                    return linkEl.removeState(this.options.blurState), void linkEl.addState(this.options.highlightState, {
                        ratio: ratio
                    });
                }
                const upSelectedLink = upstreamLinks.find((upLink => upLink.source === linkDatum.source && upLink.target === linkDatum.target));
                if (upSelectedLink) return highlightNodes.includes(linkDatum.source) || highlightNodes.push(linkDatum.source), 
                highlightNodes.includes(linkDatum.target) || highlightNodes.push(linkDatum.target), 
                linkEl.removeState(this.options.blurState), void linkEl.addState(this.options.highlightState, {
                    ratio: upSelectedLink.value / linkDatum.value
                });
                linkEl.removeState(this.options.highlightState), linkEl.addState(this.options.blurState);
            })), highlightNodes;
        }, this.highlightElement = (element, isNode) => {
            var _a, _b;
            const allNodeElements = null !== (_b = null === (_a = this._nodeMark) || void 0 === _a ? void 0 : _a.elements) && void 0 !== _b ? _b : [], highlightNodes = "related" === this.options.effect ? this.highlightRelatedElement(element, isNode) : this.highlightAdjacentElement(element, isNode);
            allNodeElements.forEach((el => {
                highlightNodes.includes(el.getDatum().key) ? (el.removeState(this.options.blurState), 
                el.addState(this.options.highlightState)) : (el.removeState(this.options.highlightState), 
                el.addState(this.options.blurState));
            }));
        }, this.handleStart = e => {
            e.element && (e.element.mark === this._nodeMark ? (this._activeElement = e.element, 
            this.highlightElement(e.element, !0)) : e.element.mark === this._linkMark && (this._activeElement = e.element, 
            this.highlightElement(e.element, !1)));
        }, this.handleReset = e => {
            e.element && e.element === this._activeElement && this.clearPrevElements();
        }, this.options = Object.assign({}, SankeyHighlight.defaultOptions, options), this._nodeMark = null === (_a = view.getMarksBySelector(this.options.nodeSelector)) || void 0 === _a ? void 0 : _a[0], 
        this._linkMark = null === (_b = view.getMarksBySelector(this.options.linkSelector)) || void 0 === _b ? void 0 : _b[0];
    }
    getEvents() {
        return [ {
            type: this.options.trigger,
            handler: this.handleStart
        }, {
            type: this.options.triggerOff,
            handler: this.handleReset
        } ];
    }
    clearPrevElements() {
        [ this._linkMark, this._nodeMark ].forEach((mark => {
            mark && mark.elements.forEach((el => {
                el.hasState(this.options.highlightState) && el.removeState(this.options.highlightState), 
                el.hasState(this.options.blurState) && el.removeState(this.options.blurState);
            }));
        }));
    }
    parseUpstreamLinks(element, isNode) {
        const datum = element.getDatum();
        return (isNode ? datum.targetLinks : array(datum)).reduce(((res, link) => (array(link.datum).forEach((dividedLink => {
            var _a;
            const parents = null !== (_a = dividedLink.parents) && void 0 !== _a ? _a : [ {
                key: dividedLink.source
            } ], len = isNode ? parents.length : parents.length - 1;
            for (let i = 0; i < len; i++) {
                const source = parents[i].key, target = parents[i + 1] ? parents[i + 1].key : datum.key, value = dividedLink.value, existingItem = res.find((item => item.source === source && item.target === target));
                existingItem ? existingItem.value += value : res.push({
                    source: source,
                    target: target,
                    value: value
                });
            }
        })), res)), []);
    }
}

SankeyHighlight.type = "sankey-highlight", SankeyHighlight.defaultOptions = {
    highlightState: InteractionStateEnum.highlight,
    blurState: InteractionStateEnum.blur,
    trigger: "pointerover",
    triggerOff: "pointerout",
    effect: "related"
};
//# sourceMappingURL=sankey-highlight.js.map