import type { GeometricMaskShape, TextShapeMask } from '@visactor/vgrammar-util';
export type TagItemAttribute<T> = T | ((d?: any) => T);
export type TagItemFunction<T> = (d?: any) => T;
export type Bounds = [{
    x: number;
    y: number;
}, {
    x: number;
    y: number;
}];
export interface Rect {
    x: number;
    y: number;
    width: number;
    height: number;
}
export type FieldOption = {
    field: string;
};
export type CallbackOption = (datum: any) => any;
export type AsType = {
    x: string;
    y: string;
    fontFamily: string;
    fontSize: string;
    fontStyle: string;
    fontWeight: string;
    angle: string;
    opacity: string;
    visible: string;
    isFillingWord: string;
    color: string;
};
export type SegmentationInputType = {
    shapeUrl: string | TextShapeMask | GeometricMaskShape;
    size: [number, number];
    ratio: number;
    maskCanvas?: HTMLCanvasElement;
    tempCanvas?: HTMLCanvasElement | any;
    boardSize: [number, number];
    random: boolean;
    randomGenerator?: any;
    isEmptyPixel?: (imageData: ImageData, i: number, j: number) => boolean;
};
export type ShapeConfigType = {
    x: number;
    y: number;
    width: number;
    height: number;
    scale: number;
};
export type segmentationType = {
    regions: any;
    labels: number[];
    labelNumber: number;
};
export type ShapeBoundsType = {
    x1: number;
    x2: number;
    y1: number;
    y2: number;
    width: number;
    height: number;
};
export interface SegmentationOutputType extends SegmentationInputType {
    segmentation: segmentationType;
    shapeBounds: ShapeBoundsType;
    shapeMaxR: number;
    shapeRatio: number;
    shapeCenter: number[];
    shapeArea: number;
    fillingInitialFontSize?: number;
    fillingDeltaFontSize?: number;
}
export type wordsConfigType = {
    getText: TagItemFunction<string>;
    getFontSize?: TagItemFunction<number>;
    fontSizeRange?: [number, number];
    colorMode: 'linear' | 'ordinal';
    getColor: TagItemFunction<string>;
    getFillingColor?: TagItemFunction<string>;
    colorList?: string[];
    getColorHex?: TagItemFunction<string>;
    getFontFamily: TagItemFunction<string>;
    rotateList: number[];
    getPadding: TagItemFunction<number>;
    getFontStyle: TagItemFunction<string>;
    getFontWeight: TagItemFunction<string>;
    getFontOpacity: TagItemFunction<number>;
    fontSizeScale?: TagItemFunction<number>;
    colorScale?: TagItemFunction<string>;
    fillingColorScale?: TagItemFunction<string>;
};
export type LayoutConfigType = {
    size: [number, number];
    ratio: number;
    shapeUrl: string | TextShapeMask | GeometricMaskShape;
    random: boolean;
    textLayoutTimes: number;
    removeWhiteBorder: boolean;
    layoutMode: 'default' | 'ensureMapping' | 'ensureMappingEnlarge';
    fontSizeShrinkFactor: number;
    stepFactor: number;
    importantWordCount: number;
    globalShinkLimit: number;
    fontSizeEnlargeFactor: number;
    fillingRatio: number;
    fillingTimes: number;
    fillingXStep: number;
    fillingYStep: number;
    fillingInitialFontSize?: number;
    fillingDeltaFontSize?: number;
    fillingInitialOpacity: number;
    fillingDeltaOpacity: number;
    getFillingFontFamily: TagItemFunction<string>;
    getFillingFontStyle: TagItemFunction<string>;
    getFillingFontWeight: TagItemFunction<string>;
    getFillingPadding: TagItemFunction<number>;
    fillingRotateList: number[];
    fillingDeltaFontSizeFactor: number;
    fillingColorList: string[];
    sameColorList: boolean;
    board?: number[];
    minInitFontSize: number;
    minFontSize: number;
    minFillFontSize: number;
};
export type CloudWordType = {
    x: number;
    y: number;
    weight: number;
    text: string;
    fontFamily: string;
    fontWeight: string;
    fontStyle: string;
    rotate: number;
    fontSize: number;
    opacity: number;
    padding: number;
    color: string;
    fillingColor: string;
    datum: any;
    visible: boolean;
    hasPlaced: boolean;
    wordSize?: [number, number];
    bounds?: any;
    hasText?: boolean;
    sprite?: number[];
    LT?: [number, number];
};
export interface WordCloudShapeOptions {
    dataIndexKey?: string;
    text: FieldOption | TagItemAttribute<string> | string;
    size?: [number, number];
    fontFamily?: FieldOption | TagItemAttribute<string> | string;
    fontStyle?: FieldOption | TagItemAttribute<string> | string;
    fontOpacity?: FieldOption | TagItemAttribute<number> | number;
    fontWeight?: FieldOption | TagItemAttribute<string> | string;
    fontSize?: FieldOption | TagItemAttribute<number> | number;
    fontSizeRange?: [number, number];
    padding?: FieldOption | TagItemAttribute<number> | number;
    colorMode?: 'linear' | 'ordinal';
    colorField?: FieldOption;
    colorHexField?: FieldOption;
    colorList?: string[];
    rotate?: FieldOption | TagItemAttribute<number> | number;
    rotateList?: number[];
    shape: string | TextShapeMask | GeometricMaskShape;
    random?: boolean;
    textLayoutTimes?: number;
    layoutMode?: 'default' | 'ensureMapping' | 'ensureMappingEnlarge';
    ratio?: number;
    removeWhiteBorder?: boolean;
    fontSizeShrinkFactor?: number;
    stepFactor?: number;
    importantWordCount?: number;
    globalShinkLimit?: number;
    fontSizeEnlargeFactor?: number;
    fillingRatio?: number;
    fillingTimes?: number;
    fillingXRatioStep?: number;
    fillingYRatioStep?: number;
    fillingXStep?: number;
    fillingYStep?: number;
    fillingInitialFontSize?: number;
    fillingDeltaFontSize?: number;
    fillingInitialOpacity?: number;
    fillingDeltaOpacity?: number;
    fillingFontFamily?: FieldOption | TagItemAttribute<string> | string;
    fillingFontStyle?: FieldOption | TagItemAttribute<string> | string;
    fillingFontWeight?: FieldOption | TagItemAttribute<string> | string;
    fillingPadding?: FieldOption | TagItemAttribute<number> | number;
    fillingDeltaFontSizeFactor?: number;
    fillingColorList?: string[];
    fillingColorField?: FieldOption;
    fillingRotateList?: number[];
    as?: AsType;
    minInitFontSize?: number;
    minFontSize?: number;
    minFillFontSize?: number;
    onUpdateMaskCanvas?: (canvas?: HTMLCanvasElement) => void;
}
